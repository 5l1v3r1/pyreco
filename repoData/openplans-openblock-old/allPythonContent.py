__FILENAME__ = bootstrap
#!/usr/bin/env python
## WARNING: This file is generated
#!/usr/bin/env python
"""Create a "virtual" Python installation
"""

# If you change the version here, change it in setup.py 
# and docs/conf.py as well.
virtualenv_version = "1.6.4"

import base64
import sys
import os
import optparse
import re
import shutil
import logging
import tempfile
import zlib
import errno
import distutils.sysconfig
try:
    import subprocess
except ImportError:
    if sys.version_info <= (2, 3):
        print('ERROR: %s' % sys.exc_info()[1])
        print('ERROR: this script requires Python 2.4 or greater; or at least the subprocess module.')
        print('If you copy subprocess.py from a newer version of Python this script will probably work')
        sys.exit(101)
    else:
        raise
try:
    set
except NameError:
    from sets import Set as set
try:
    basestring
except NameError:
    basestring = str

join = os.path.join
py_version = 'python%s.%s' % (sys.version_info[0], sys.version_info[1])

is_jython = sys.platform.startswith('java')
is_pypy = hasattr(sys, 'pypy_version_info')
is_win  = (sys.platform == 'win32')
abiflags = getattr(sys, 'abiflags', '')

if is_pypy:
    expected_exe = 'pypy'
elif is_jython:
    expected_exe = 'jython'
else:
    expected_exe = 'python'


REQUIRED_MODULES = ['os', 'posix', 'posixpath', 'nt', 'ntpath', 'genericpath',
                    'fnmatch', 'locale', 'encodings', 'codecs',
                    'stat', 'UserDict', 'readline', 'copy_reg', 'types',
                    're', 'sre', 'sre_parse', 'sre_constants', 'sre_compile',
                    'zlib']

REQUIRED_FILES = ['lib-dynload', 'config']

majver, minver = sys.version_info[:2]
if majver == 2:
    if minver >= 6:
        REQUIRED_MODULES.extend(['warnings', 'linecache', '_abcoll', 'abc'])
    if minver >= 7:
        REQUIRED_MODULES.extend(['_weakrefset'])
    if minver <= 3:
        REQUIRED_MODULES.extend(['sets', '__future__'])
elif majver == 3:
    # Some extra modules are needed for Python 3, but different ones
    # for different versions.
    REQUIRED_MODULES.extend(['_abcoll', 'warnings', 'linecache', 'abc', 'io',
                             '_weakrefset', 'copyreg', 'tempfile', 'random',
                             '__future__', 'collections', 'keyword', 'tarfile',
                             'shutil', 'struct', 'copy'])
    if minver >= 2:
        REQUIRED_FILES[-1] = 'config-%s' % majver
    if minver == 3:
        # The whole list of 3.3 modules is reproduced below - the current
        # uncommented ones are required for 3.3 as of now, but more may be
        # added as 3.3 development continues.
        REQUIRED_MODULES.extend([
            #"aifc",
            #"antigravity",
            #"argparse",
            #"ast",
            #"asynchat",
            #"asyncore",
            "base64",
            #"bdb",
            #"binhex",
            "bisect",
            #"calendar",
            #"cgi",
            #"cgitb",
            #"chunk",
            #"cmd",
            #"codeop",
            #"code",
            #"colorsys",
            #"_compat_pickle",
            #"compileall",
            #"concurrent",
            #"configparser",
            #"contextlib",
            #"cProfile",
            #"crypt",
            #"csv",
            #"ctypes",
            #"curses",
            #"datetime",
            #"dbm",
            #"decimal",
            #"difflib",
            #"dis",
            #"doctest",
            #"dummy_threading",
            "_dummy_thread",
            #"email",
            #"filecmp",
            #"fileinput",
            #"formatter",
            #"fractions",
            #"ftplib",
            #"functools",
            #"getopt",
            #"getpass",
            #"gettext",
            #"glob",
            #"gzip",
            "hashlib",
            "heapq",
            "hmac",
            #"html",
            #"http",
            #"idlelib",
            #"imaplib",
            #"imghdr",
            #"importlib",
            #"inspect",
            #"json",
            #"lib2to3",
            #"logging",
            #"macpath",
            #"macurl2path",
            #"mailbox",
            #"mailcap",
            #"_markupbase",
            #"mimetypes",
            #"modulefinder",
            #"multiprocessing",
            #"netrc",
            #"nntplib",
            #"nturl2path",
            #"numbers",
            #"opcode",
            #"optparse",
            #"os2emxpath",
            #"pdb",
            #"pickle",
            #"pickletools",
            #"pipes",
            #"pkgutil",
            #"platform",
            #"plat-linux2",
            #"plistlib",
            #"poplib",
            #"pprint",
            #"profile",
            #"pstats",
            #"pty",
            #"pyclbr",
            #"py_compile",
            #"pydoc_data",
            #"pydoc",
            #"_pyio",
            #"queue",
            #"quopri",
            "reprlib",
            "rlcompleter",
            #"runpy",
            #"sched",
            #"shelve",
            #"shlex",
            #"smtpd",
            #"smtplib",
            #"sndhdr",
            #"socket",
            #"socketserver",
            #"sqlite3",
            #"ssl",
            #"stringprep",
            #"string",
            #"_strptime",
            #"subprocess",
            #"sunau",
            #"symbol",
            #"symtable",
            #"sysconfig",
            #"tabnanny",
            #"telnetlib",
            #"test",
            #"textwrap",
            #"this",
            #"_threading_local",
            #"threading",
            #"timeit",
            #"tkinter",
            #"tokenize",
            #"token",
            #"traceback",
            #"trace",
            #"tty",
            #"turtledemo",
            #"turtle",
            #"unittest",
            #"urllib",
            #"uuid",
            #"uu",
            #"wave",
            "weakref",
            #"webbrowser",
            #"wsgiref",
            #"xdrlib",
            #"xml",
            #"xmlrpc",
            #"zipfile",
        ])

if is_pypy:
    # these are needed to correctly display the exceptions that may happen
    # during the bootstrap
    REQUIRED_MODULES.extend(['traceback', 'linecache'])

class Logger(object):

    """
    Logging object for use in command-line script.  Allows ranges of
    levels, to avoid some redundancy of displayed information.
    """

    DEBUG = logging.DEBUG
    INFO = logging.INFO
    NOTIFY = (logging.INFO+logging.WARN)/2
    WARN = WARNING = logging.WARN
    ERROR = logging.ERROR
    FATAL = logging.FATAL

    LEVELS = [DEBUG, INFO, NOTIFY, WARN, ERROR, FATAL]

    def __init__(self, consumers):
        self.consumers = consumers
        self.indent = 0
        self.in_progress = None
        self.in_progress_hanging = False

    def debug(self, msg, *args, **kw):
        self.log(self.DEBUG, msg, *args, **kw)
    def info(self, msg, *args, **kw):
        self.log(self.INFO, msg, *args, **kw)
    def notify(self, msg, *args, **kw):
        self.log(self.NOTIFY, msg, *args, **kw)
    def warn(self, msg, *args, **kw):
        self.log(self.WARN, msg, *args, **kw)
    def error(self, msg, *args, **kw):
        self.log(self.WARN, msg, *args, **kw)
    def fatal(self, msg, *args, **kw):
        self.log(self.FATAL, msg, *args, **kw)
    def log(self, level, msg, *args, **kw):
        if args:
            if kw:
                raise TypeError(
                    "You may give positional or keyword arguments, not both")
        args = args or kw
        rendered = None
        for consumer_level, consumer in self.consumers:
            if self.level_matches(level, consumer_level):
                if (self.in_progress_hanging
                    and consumer in (sys.stdout, sys.stderr)):
                    self.in_progress_hanging = False
                    sys.stdout.write('\n')
                    sys.stdout.flush()
                if rendered is None:
                    if args:
                        rendered = msg % args
                    else:
                        rendered = msg
                    rendered = ' '*self.indent + rendered
                if hasattr(consumer, 'write'):
                    consumer.write(rendered+'\n')
                else:
                    consumer(rendered)

    def start_progress(self, msg):
        assert not self.in_progress, (
            "Tried to start_progress(%r) while in_progress %r"
            % (msg, self.in_progress))
        if self.level_matches(self.NOTIFY, self._stdout_level()):
            sys.stdout.write(msg)
            sys.stdout.flush()
            self.in_progress_hanging = True
        else:
            self.in_progress_hanging = False
        self.in_progress = msg

    def end_progress(self, msg='done.'):
        assert self.in_progress, (
            "Tried to end_progress without start_progress")
        if self.stdout_level_matches(self.NOTIFY):
            if not self.in_progress_hanging:
                # Some message has been printed out since start_progress
                sys.stdout.write('...' + self.in_progress + msg + '\n')
                sys.stdout.flush()
            else:
                sys.stdout.write(msg + '\n')
                sys.stdout.flush()
        self.in_progress = None
        self.in_progress_hanging = False

    def show_progress(self):
        """If we are in a progress scope, and no log messages have been
        shown, write out another '.'"""
        if self.in_progress_hanging:
            sys.stdout.write('.')
            sys.stdout.flush()

    def stdout_level_matches(self, level):
        """Returns true if a message at this level will go to stdout"""
        return self.level_matches(level, self._stdout_level())

    def _stdout_level(self):
        """Returns the level that stdout runs at"""
        for level, consumer in self.consumers:
            if consumer is sys.stdout:
                return level
        return self.FATAL

    def level_matches(self, level, consumer_level):
        """
        >>> l = Logger([])
        >>> l.level_matches(3, 4)
        False
        >>> l.level_matches(3, 2)
        True
        >>> l.level_matches(slice(None, 3), 3)
        False
        >>> l.level_matches(slice(None, 3), 2)
        True
        >>> l.level_matches(slice(1, 3), 1)
        True
        >>> l.level_matches(slice(2, 3), 1)
        False
        """
        if isinstance(level, slice):
            start, stop = level.start, level.stop
            if start is not None and start > consumer_level:
                return False
            if stop is not None and stop <= consumer_level:
                return False
            return True
        else:
            return level >= consumer_level

    #@classmethod
    def level_for_integer(cls, level):
        levels = cls.LEVELS
        if level < 0:
            return levels[0]
        if level >= len(levels):
            return levels[-1]
        return levels[level]

    level_for_integer = classmethod(level_for_integer)

# create a silent logger just to prevent this from being undefined
# will be overridden with requested verbosity main() is called.
logger = Logger([(Logger.LEVELS[-1], sys.stdout)])

def mkdir(path):
    if not os.path.exists(path):
        logger.info('Creating %s', path)
        os.makedirs(path)
    else:
        logger.info('Directory %s already exists', path)

def copyfileordir(src, dest):
    if os.path.isdir(src):
        shutil.copytree(src, dest, True)
    else:
        shutil.copy2(src, dest)

def copyfile(src, dest, symlink=True):
    if not os.path.exists(src):
        # Some bad symlink in the src
        logger.warn('Cannot find file %s (bad symlink)', src)
        return
    if os.path.exists(dest):
        logger.debug('File %s already exists', dest)
        return
    if not os.path.exists(os.path.dirname(dest)):
        logger.info('Creating parent directories for %s' % os.path.dirname(dest))
        os.makedirs(os.path.dirname(dest))
    if not os.path.islink(src):
        srcpath = os.path.abspath(src)
    else:
        srcpath = os.readlink(src)
    if symlink and hasattr(os, 'symlink'):
        logger.info('Symlinking %s', dest)
        try:
            os.symlink(srcpath, dest)
        except (OSError, NotImplementedError):
            logger.info('Symlinking failed, copying to %s', dest)
            copyfileordir(src, dest)
    else:
        logger.info('Copying to %s', dest)
        copyfileordir(src, dest)

def writefile(dest, content, overwrite=True):
    if not os.path.exists(dest):
        logger.info('Writing %s', dest)
        f = open(dest, 'wb')
        f.write(content.encode('utf-8'))
        f.close()
        return
    else:
        f = open(dest, 'rb')
        c = f.read()
        f.close()
        if c != content:
            if not overwrite:
                logger.notify('File %s exists with different content; not overwriting', dest)
                return
            logger.notify('Overwriting %s with new content', dest)
            f = open(dest, 'wb')
            f.write(content.encode('utf-8'))
            f.close()
        else:
            logger.info('Content %s already in place', dest)

def rmtree(dir):
    if os.path.exists(dir):
        logger.notify('Deleting tree %s', dir)
        shutil.rmtree(dir)
    else:
        logger.info('Do not need to delete %s; already gone', dir)

def make_exe(fn):
    if hasattr(os, 'chmod'):
        oldmode = os.stat(fn).st_mode & 0xFFF # 0o7777
        newmode = (oldmode | 0x16D) & 0xFFF # 0o555, 0o7777
        os.chmod(fn, newmode)
        logger.info('Changed mode of %s to %s', fn, oct(newmode))

def _find_file(filename, dirs):
    for dir in dirs:
        if os.path.exists(join(dir, filename)):
            return join(dir, filename)
    return filename

def _install_req(py_executable, unzip=False, distribute=False,
                 search_dirs=None, never_download=False):

    if search_dirs is None:
        search_dirs = file_search_dirs()

    if not distribute:
        setup_fn = 'setuptools-0.6c11-py%s.egg' % sys.version[:3]
        project_name = 'setuptools'
        bootstrap_script = EZ_SETUP_PY
        source = None
    else:
        setup_fn = None
        source = 'distribute-0.6.19.tar.gz'
        project_name = 'distribute'
        bootstrap_script = DISTRIBUTE_SETUP_PY

        # If we are running under -p, we need to remove the current
        # directory from sys.path temporarily here, so that we
        # definitely get the pkg_resources from the site directory of
        # the interpreter we are running under, not the one
        # virtualenv.py is installed under (which might lead to py2/py3
        # incompatibility issues)
        _prev_sys_path = sys.path
        if os.environ.get('VIRTUALENV_INTERPRETER_RUNNING'):
            sys.path = sys.path[1:]

        try:
            try:
                # check if the global Python has distribute installed or plain
                # setuptools
                import pkg_resources
                if not hasattr(pkg_resources, '_distribute'):
                    location = os.path.dirname(pkg_resources.__file__)
                    logger.notify("A globally installed setuptools was found (in %s)" % location)
                    logger.notify("Use the --no-site-packages option to use distribute in "
                                  "the virtualenv.")
            except ImportError:
                pass
        finally:
            sys.path = _prev_sys_path

    if setup_fn is not None:
        setup_fn = _find_file(setup_fn, search_dirs)

    if source is not None:
        source = _find_file(source, search_dirs)

    if is_jython and os._name == 'nt':
        # Jython's .bat sys.executable can't handle a command line
        # argument with newlines
        fd, ez_setup = tempfile.mkstemp('.py')
        os.write(fd, bootstrap_script)
        os.close(fd)
        cmd = [py_executable, ez_setup]
    else:
        cmd = [py_executable, '-c', bootstrap_script]
    if unzip:
        cmd.append('--always-unzip')
    env = {}
    remove_from_env = []
    if logger.stdout_level_matches(logger.DEBUG):
        cmd.append('-v')

    old_chdir = os.getcwd()
    if setup_fn is not None and os.path.exists(setup_fn):
        logger.info('Using existing %s egg: %s' % (project_name, setup_fn))
        cmd.append(setup_fn)
        if os.environ.get('PYTHONPATH'):
            env['PYTHONPATH'] = setup_fn + os.path.pathsep + os.environ['PYTHONPATH']
        else:
            env['PYTHONPATH'] = setup_fn
    else:
        # the source is found, let's chdir
        if source is not None and os.path.exists(source):
            logger.info('Using existing %s egg: %s' % (project_name, source))
            os.chdir(os.path.dirname(source))
            # in this case, we want to be sure that PYTHONPATH is unset (not
            # just empty, really unset), else CPython tries to import the
            # site.py that it's in virtualenv_support
            remove_from_env.append('PYTHONPATH')
        else:
            if never_download:
                logger.fatal("Can't find any local distributions of %s to install "
                             "and --never-download is set.  Either re-run virtualenv "
                             "without the --never-download option, or place a %s "
                             "distribution (%s) in one of these "
                             "locations: %r" % (project_name, project_name, 
                                                setup_fn or source,
                                                search_dirs))
                sys.exit(1)

            logger.info('No %s egg found; downloading' % project_name)
        cmd.extend(['--always-copy', '-U', project_name])
    logger.start_progress('Installing %s...' % project_name)
    logger.indent += 2
    cwd = None
    if project_name == 'distribute':
        env['DONT_PATCH_SETUPTOOLS'] = 'true'

    def _filter_ez_setup(line):
        return filter_ez_setup(line, project_name)

    if not os.access(os.getcwd(), os.W_OK):
        cwd = tempfile.mkdtemp()
        if source is not None and os.path.exists(source):
            # the current working dir is hostile, let's copy the
            # tarball to a temp dir
            target = os.path.join(cwd, os.path.split(source)[-1])
            shutil.copy(source, target)
    try:
        call_subprocess(cmd, show_stdout=False,
                        filter_stdout=_filter_ez_setup,
                        extra_env=env,
                        remove_from_env=remove_from_env,
                        cwd=cwd)
    finally:
        logger.indent -= 2
        logger.end_progress()
        if os.getcwd() != old_chdir:
            os.chdir(old_chdir)
        if is_jython and os._name == 'nt':
            os.remove(ez_setup)

def file_search_dirs():
    here = os.path.dirname(os.path.abspath(__file__))
    dirs = ['.', here,
            join(here, 'virtualenv_support')]
    if os.path.splitext(os.path.dirname(__file__))[0] != 'virtualenv':
        # Probably some boot script; just in case virtualenv is installed...
        try:
            import virtualenv
        except ImportError:
            pass
        else:
            dirs.append(os.path.join(os.path.dirname(virtualenv.__file__), 'virtualenv_support'))
    return [d for d in dirs if os.path.isdir(d)]

def install_setuptools(py_executable, unzip=False,
                       search_dirs=None, never_download=False):
    _install_req(py_executable, unzip, 
                 search_dirs=search_dirs, never_download=never_download)

def install_distribute(py_executable, unzip=False, 
                       search_dirs=None, never_download=False):
    _install_req(py_executable, unzip, distribute=True, 
                 search_dirs=search_dirs, never_download=never_download)

_pip_re = re.compile(r'^pip-.*(zip|tar.gz|tar.bz2|tgz|tbz)$', re.I)
def install_pip(py_executable, search_dirs=None, never_download=False):    
    if search_dirs is None:
        search_dirs = file_search_dirs()

    filenames = []
    for dir in search_dirs:
        filenames.extend([join(dir, fn) for fn in os.listdir(dir)
                          if _pip_re.search(fn)])
    filenames = [(os.path.basename(filename).lower(), i, filename) for i, filename in enumerate(filenames)]
    filenames.sort()
    filenames = [filename for basename, i, filename in filenames]
    if not filenames:
        filename = 'pip'
    else:
        filename = filenames[-1]
    easy_install_script = 'easy_install'
    if sys.platform == 'win32':
        easy_install_script = 'easy_install-script.py'
    cmd = [py_executable, join(os.path.dirname(py_executable), easy_install_script), filename]
    if filename == 'pip':
        if never_download:
            logger.fatal("Can't find any local distributions of pip to install "
                         "and --never-download is set.  Either re-run virtualenv "
                         "without the --never-download option, or place a pip "
                         "source distribution (zip/tar.gz/tar.bz2) in one of these "
                         "locations: %r" % search_dirs)
            sys.exit(1)
        logger.info('Installing pip from network...')
    else:
        logger.info('Installing existing %s distribution: %s' % (
                os.path.basename(filename), filename))
    logger.start_progress('Installing pip...')
    logger.indent += 2
    def _filter_setup(line):
        return filter_ez_setup(line, 'pip')
    try:
        call_subprocess(cmd, show_stdout=False,
                        filter_stdout=_filter_setup)
    finally:
        logger.indent -= 2
        logger.end_progress()

def filter_ez_setup(line, project_name='setuptools'):
    if not line.strip():
        return Logger.DEBUG
    if project_name == 'distribute':
        for prefix in ('Extracting', 'Now working', 'Installing', 'Before',
                       'Scanning', 'Setuptools', 'Egg', 'Already',
                       'running', 'writing', 'reading', 'installing',
                       'creating', 'copying', 'byte-compiling', 'removing',
                       'Processing'):
            if line.startswith(prefix):
                return Logger.DEBUG
        return Logger.DEBUG
    for prefix in ['Reading ', 'Best match', 'Processing setuptools',
                   'Copying setuptools', 'Adding setuptools',
                   'Installing ', 'Installed ']:
        if line.startswith(prefix):
            return Logger.DEBUG
    return Logger.INFO

def main():
    parser = optparse.OptionParser(
        version=virtualenv_version,
        usage="%prog [OPTIONS] DEST_DIR")

    parser.add_option(
        '-v', '--verbose',
        action='count',
        dest='verbose',
        default=0,
        help="Increase verbosity")

    parser.add_option(
        '-q', '--quiet',
        action='count',
        dest='quiet',
        default=0,
        help='Decrease verbosity')

    parser.add_option(
        '-p', '--python',
        dest='python',
        metavar='PYTHON_EXE',
        help='The Python interpreter to use, e.g., --python=python2.5 will use the python2.5 '
        'interpreter to create the new environment.  The default is the interpreter that '
        'virtualenv was installed with (%s)' % sys.executable)

    parser.add_option(
        '--clear',
        dest='clear',
        action='store_true',
        help="Clear out the non-root install and start from scratch")

    parser.add_option(
        '--no-site-packages',
        dest='no_site_packages',
        action='store_true',
        help="Don't give access to the global site-packages dir to the "
             "virtual environment")

    parser.add_option(
        '--unzip-setuptools',
        dest='unzip_setuptools',
        action='store_true',
        help="Unzip Setuptools or Distribute when installing it")

    parser.add_option(
        '--relocatable',
        dest='relocatable',
        action='store_true',
        help='Make an EXISTING virtualenv environment relocatable.  '
        'This fixes up scripts and makes all .pth files relative')

    parser.add_option(
        '--distribute',
        dest='use_distribute',
        action='store_true',
        help='Use Distribute instead of Setuptools. Set environ variable '
        'VIRTUALENV_USE_DISTRIBUTE to make it the default ')

    default_search_dirs = file_search_dirs()
    parser.add_option(
        '--extra-search-dir',
        dest="search_dirs",
        action="append",
        default=default_search_dirs,
        help="Directory to look for setuptools/distribute/pip distributions in. "
        "You can add any number of additional --extra-search-dir paths.")

    parser.add_option(
        '--never-download',
        dest="never_download",
        action="store_true",
        help="Never download anything from the network.  Instead, virtualenv will fail "
        "if local distributions of setuptools/distribute/pip are not present.")

    parser.add_option(
        '--prompt=',
        dest='prompt',
        help='Provides an alternative prompt prefix for this environment')

    if 'extend_parser' in globals():
        extend_parser(parser)

    options, args = parser.parse_args()

    global logger

    if 'adjust_options' in globals():
        adjust_options(options, args)

    verbosity = options.verbose - options.quiet
    logger = Logger([(Logger.level_for_integer(2-verbosity), sys.stdout)])

    if options.python and not os.environ.get('VIRTUALENV_INTERPRETER_RUNNING'):
        env = os.environ.copy()
        interpreter = resolve_interpreter(options.python)
        if interpreter == sys.executable:
            logger.warn('Already using interpreter %s' % interpreter)
        else:
            logger.notify('Running virtualenv with interpreter %s' % interpreter)
            env['VIRTUALENV_INTERPRETER_RUNNING'] = 'true'
            file = __file__
            if file.endswith('.pyc'):
                file = file[:-1]
            popen = subprocess.Popen([interpreter, file] + sys.argv[1:], env=env)
            raise SystemExit(popen.wait())

    if not args:
        print('You must provide a DEST_DIR')
        parser.print_help()
        sys.exit(2)
    if len(args) > 1:
        print('There must be only one argument: DEST_DIR (you gave %s)' % (
            ' '.join(args)))
        parser.print_help()
        sys.exit(2)

    home_dir = args[0]

    if os.environ.get('WORKING_ENV'):
        logger.fatal('ERROR: you cannot run virtualenv while in a workingenv')
        logger.fatal('Please deactivate your workingenv, then re-run this script')
        sys.exit(3)

    if 'PYTHONHOME' in os.environ:
        logger.warn('PYTHONHOME is set.  You *must* activate the virtualenv before using it')
        del os.environ['PYTHONHOME']

    if options.relocatable:
        make_environment_relocatable(home_dir)
        return

    create_environment(home_dir, site_packages=not options.no_site_packages, clear=options.clear,
                       unzip_setuptools=options.unzip_setuptools,
                       use_distribute=options.use_distribute or majver > 2,
                       prompt=options.prompt,
                       search_dirs=options.search_dirs,
                       never_download=options.never_download)
    if 'after_install' in globals():
        after_install(options, home_dir)

def call_subprocess(cmd, show_stdout=True,
                    filter_stdout=None, cwd=None,
                    raise_on_returncode=True, extra_env=None,
                    remove_from_env=None):
    cmd_parts = []
    for part in cmd:
        if len(part) > 45:
            part = part[:20]+"..."+part[-20:]
        if ' ' in part or '\n' in part or '"' in part or "'" in part:
            part = '"%s"' % part.replace('"', '\\"')
        cmd_parts.append(part)
    cmd_desc = ' '.join(cmd_parts)
    if show_stdout:
        stdout = None
    else:
        stdout = subprocess.PIPE
    logger.debug("Running command %s" % cmd_desc)
    if extra_env or remove_from_env:
        env = os.environ.copy()
        if extra_env:
            env.update(extra_env)
        if remove_from_env:
            for varname in remove_from_env:
                env.pop(varname, None)
    else:
        env = None
    try:
        proc = subprocess.Popen(
            cmd, stderr=subprocess.STDOUT, stdin=None, stdout=stdout,
            cwd=cwd, env=env)
    except Exception:
        e = sys.exc_info()[1]
        logger.fatal(
            "Error %s while executing command %s" % (e, cmd_desc))
        raise
    all_output = []
    if stdout is not None:
        stdout = proc.stdout
        encoding = sys.getdefaultencoding()
        while 1:
            line = stdout.readline().decode(encoding)
            if not line:
                break
            line = line.rstrip()
            all_output.append(line)
            if filter_stdout:
                level = filter_stdout(line)
                if isinstance(level, tuple):
                    level, line = level
                logger.log(level, line)
                if not logger.stdout_level_matches(level):
                    logger.show_progress()
            else:
                logger.info(line)
    else:
        proc.communicate()
    proc.wait()
    if proc.returncode:
        if raise_on_returncode:
            if all_output:
                logger.notify('Complete output from command %s:' % cmd_desc)
                logger.notify('\n'.join(all_output) + '\n----------------------------------------')
            raise OSError(
                "Command %s failed with error code %s"
                % (cmd_desc, proc.returncode))
        else:
            logger.warn(
                "Command %s had error code %s"
                % (cmd_desc, proc.returncode))


def create_environment(home_dir, site_packages=True, clear=False,
                       unzip_setuptools=False, use_distribute=False,
                       prompt=None, search_dirs=None, never_download=False):
    """
    Creates a new environment in ``home_dir``.

    If ``site_packages`` is true (the default) then the global
    ``site-packages/`` directory will be on the path.

    If ``clear`` is true (default False) then the environment will
    first be cleared.
    """
    home_dir, lib_dir, inc_dir, bin_dir = path_locations(home_dir)

    py_executable = os.path.abspath(install_python(
        home_dir, lib_dir, inc_dir, bin_dir,
        site_packages=site_packages, clear=clear))

    install_distutils(home_dir)

    if use_distribute or os.environ.get('VIRTUALENV_USE_DISTRIBUTE'):
        install_distribute(py_executable, unzip=unzip_setuptools, 
                           search_dirs=search_dirs, never_download=never_download)
    else:
        install_setuptools(py_executable, unzip=unzip_setuptools, 
                           search_dirs=search_dirs, never_download=never_download)

    install_pip(py_executable, search_dirs=search_dirs, never_download=never_download)

    install_activate(home_dir, bin_dir, prompt)

def path_locations(home_dir):
    """Return the path locations for the environment (where libraries are,
    where scripts go, etc)"""
    # XXX: We'd use distutils.sysconfig.get_python_inc/lib but its
    # prefix arg is broken: http://bugs.python.org/issue3386
    if sys.platform == 'win32':
        # Windows has lots of problems with executables with spaces in
        # the name; this function will remove them (using the ~1
        # format):
        mkdir(home_dir)
        if ' ' in home_dir:
            try:
                import win32api
            except ImportError:
                print('Error: the path "%s" has a space in it' % home_dir)
                print('To handle these kinds of paths, the win32api module must be installed:')
                print('  http://sourceforge.net/projects/pywin32/')
                sys.exit(3)
            home_dir = win32api.GetShortPathName(home_dir)
        lib_dir = join(home_dir, 'Lib')
        inc_dir = join(home_dir, 'Include')
        bin_dir = join(home_dir, 'Scripts')
    elif is_jython:
        lib_dir = join(home_dir, 'Lib')
        inc_dir = join(home_dir, 'Include')
        bin_dir = join(home_dir, 'bin')
    elif is_pypy:
        lib_dir = home_dir
        inc_dir = join(home_dir, 'include')
        bin_dir = join(home_dir, 'bin')
    else:
        lib_dir = join(home_dir, 'lib', py_version)
        inc_dir = join(home_dir, 'include', py_version + abiflags)
        bin_dir = join(home_dir, 'bin')
    return home_dir, lib_dir, inc_dir, bin_dir


def change_prefix(filename, dst_prefix):
    prefixes = [sys.prefix]

    if sys.platform == "darwin":
        prefixes.extend((
            os.path.join("/Library/Python", sys.version[:3], "site-packages"),
            os.path.join(sys.prefix, "Extras", "lib", "python"),
            os.path.join("~", "Library", "Python", sys.version[:3], "site-packages")))

    if hasattr(sys, 'real_prefix'):
        prefixes.append(sys.real_prefix)
    prefixes = list(map(os.path.abspath, prefixes))
    filename = os.path.abspath(filename)
    for src_prefix in prefixes:
        if filename.startswith(src_prefix):
            _, relpath = filename.split(src_prefix, 1)
            assert relpath[0] == os.sep
            relpath = relpath[1:]
            return join(dst_prefix, relpath)
    assert False, "Filename %s does not start with any of these prefixes: %s" % \
        (filename, prefixes)

def copy_required_modules(dst_prefix):
    import imp
    for modname in REQUIRED_MODULES:
        if modname in sys.builtin_module_names:
            logger.info("Ignoring built-in bootstrap module: %s" % modname)
            continue
        try:
            f, filename, _ = imp.find_module(modname)
        except ImportError:
            logger.info("Cannot import bootstrap module: %s" % modname)
        else:
            if f is not None:
                f.close()
            dst_filename = change_prefix(filename, dst_prefix)
            copyfile(filename, dst_filename)
            if filename.endswith('.pyc'):
                pyfile = filename[:-1]
                if os.path.exists(pyfile):
                    copyfile(pyfile, dst_filename[:-1])


def install_python(home_dir, lib_dir, inc_dir, bin_dir, site_packages, clear):
    """Install just the base environment, no distutils patches etc"""
    if sys.executable.startswith(bin_dir):
        print('Please use the *system* python to run this script')
        return

    if clear:
        rmtree(lib_dir)
        ## FIXME: why not delete it?
        ## Maybe it should delete everything with #!/path/to/venv/python in it
        logger.notify('Not deleting %s', bin_dir)

    if hasattr(sys, 'real_prefix'):
        logger.notify('Using real prefix %r' % sys.real_prefix)
        prefix = sys.real_prefix
    else:
        prefix = sys.prefix
    mkdir(lib_dir)
    fix_lib64(lib_dir)
    fix_local_scheme(home_dir)
    stdlib_dirs = [os.path.dirname(os.__file__)]
    if sys.platform == 'win32':
        stdlib_dirs.append(join(os.path.dirname(stdlib_dirs[0]), 'DLLs'))
    elif sys.platform == 'darwin':
        stdlib_dirs.append(join(stdlib_dirs[0], 'site-packages'))
    if hasattr(os, 'symlink'):
        logger.info('Symlinking Python bootstrap modules')
    else:
        logger.info('Copying Python bootstrap modules')
    logger.indent += 2
    try:
        # copy required files...
        for stdlib_dir in stdlib_dirs:
            if not os.path.isdir(stdlib_dir):
                continue
            for fn in os.listdir(stdlib_dir):
                bn = os.path.splitext(fn)[0]
                if fn != 'site-packages' and bn in REQUIRED_FILES:
                    copyfile(join(stdlib_dir, fn), join(lib_dir, fn))
        # ...and modules
        copy_required_modules(home_dir)
    finally:
        logger.indent -= 2
    mkdir(join(lib_dir, 'site-packages'))
    import site
    site_filename = site.__file__
    if site_filename.endswith('.pyc'):
        site_filename = site_filename[:-1]
    elif site_filename.endswith('$py.class'):
        site_filename = site_filename.replace('$py.class', '.py')
    site_filename_dst = change_prefix(site_filename, home_dir)
    site_dir = os.path.dirname(site_filename_dst)
    writefile(site_filename_dst, SITE_PY)
    writefile(join(site_dir, 'orig-prefix.txt'), prefix)
    site_packages_filename = join(site_dir, 'no-global-site-packages.txt')
    if not site_packages:
        writefile(site_packages_filename, '')
    else:
        if os.path.exists(site_packages_filename):
            logger.info('Deleting %s' % site_packages_filename)
            os.unlink(site_packages_filename)

    if is_pypy or is_win:
        stdinc_dir = join(prefix, 'include')
    else:
        stdinc_dir = join(prefix, 'include', py_version + abiflags)
    if os.path.exists(stdinc_dir):
        copyfile(stdinc_dir, inc_dir)
    else:
        logger.debug('No include dir %s' % stdinc_dir)

    # pypy never uses exec_prefix, just ignore it
    if sys.exec_prefix != prefix and not is_pypy:
        if sys.platform == 'win32':
            exec_dir = join(sys.exec_prefix, 'lib')
        elif is_jython:
            exec_dir = join(sys.exec_prefix, 'Lib')
        else:
            exec_dir = join(sys.exec_prefix, 'lib', py_version)
        for fn in os.listdir(exec_dir):
            copyfile(join(exec_dir, fn), join(lib_dir, fn))

    if is_jython:
        # Jython has either jython-dev.jar and javalib/ dir, or just
        # jython.jar
        for name in 'jython-dev.jar', 'javalib', 'jython.jar':
            src = join(prefix, name)
            if os.path.exists(src):
                copyfile(src, join(home_dir, name))
        # XXX: registry should always exist after Jython 2.5rc1
        src = join(prefix, 'registry')
        if os.path.exists(src):
            copyfile(src, join(home_dir, 'registry'), symlink=False)
        copyfile(join(prefix, 'cachedir'), join(home_dir, 'cachedir'),
                 symlink=False)

    mkdir(bin_dir)
    py_executable = join(bin_dir, os.path.basename(sys.executable))
    if 'Python.framework' in prefix:
        if re.search(r'/Python(?:-32|-64)*$', py_executable):
            # The name of the python executable is not quite what
            # we want, rename it.
            py_executable = os.path.join(
                    os.path.dirname(py_executable), 'python')

    logger.notify('New %s executable in %s', expected_exe, py_executable)
    if sys.executable != py_executable:
        ## FIXME: could I just hard link?
        executable = sys.executable
        if sys.platform == 'cygwin' and os.path.exists(executable + '.exe'):
            # Cygwin misreports sys.executable sometimes
            executable += '.exe'
            py_executable += '.exe'
            logger.info('Executable actually exists in %s' % executable)
        shutil.copyfile(executable, py_executable)
        make_exe(py_executable)
        if sys.platform == 'win32' or sys.platform == 'cygwin':
            pythonw = os.path.join(os.path.dirname(sys.executable), 'pythonw.exe')
            if os.path.exists(pythonw):
                logger.info('Also created pythonw.exe')
                shutil.copyfile(pythonw, os.path.join(os.path.dirname(py_executable), 'pythonw.exe'))
        if is_pypy:
            # make a symlink python --> pypy-c
            python_executable = os.path.join(os.path.dirname(py_executable), 'python')
            logger.info('Also created executable %s' % python_executable)
            copyfile(py_executable, python_executable)

    if os.path.splitext(os.path.basename(py_executable))[0] != expected_exe:
        secondary_exe = os.path.join(os.path.dirname(py_executable),
                                     expected_exe)
        py_executable_ext = os.path.splitext(py_executable)[1]
        if py_executable_ext == '.exe':
            # python2.4 gives an extension of '.4' :P
            secondary_exe += py_executable_ext
        if os.path.exists(secondary_exe):
            logger.warn('Not overwriting existing %s script %s (you must use %s)'
                        % (expected_exe, secondary_exe, py_executable))
        else:
            logger.notify('Also creating executable in %s' % secondary_exe)
            shutil.copyfile(sys.executable, secondary_exe)
            make_exe(secondary_exe)

    if 'Python.framework' in prefix:
        logger.debug('MacOSX Python framework detected')

        # Make sure we use the the embedded interpreter inside
        # the framework, even if sys.executable points to
        # the stub executable in ${sys.prefix}/bin
        # See http://groups.google.com/group/python-virtualenv/
        #                              browse_thread/thread/17cab2f85da75951
        original_python = os.path.join(
            prefix, 'Resources/Python.app/Contents/MacOS/Python')
        shutil.copy(original_python, py_executable)

        # Copy the framework's dylib into the virtual
        # environment
        virtual_lib = os.path.join(home_dir, '.Python')

        if os.path.exists(virtual_lib):
            os.unlink(virtual_lib)
        copyfile(
            os.path.join(prefix, 'Python'),
            virtual_lib)

        # And then change the install_name of the copied python executable
        try:
            call_subprocess(
                ["install_name_tool", "-change",
                 os.path.join(prefix, 'Python'),
                 '@executable_path/../.Python',
                 py_executable])
        except:
            logger.fatal(
                "Could not call install_name_tool -- you must have Apple's development tools installed")
            raise

        # Some tools depend on pythonX.Y being present
        py_executable_version = '%s.%s' % (
            sys.version_info[0], sys.version_info[1])
        if not py_executable.endswith(py_executable_version):
            # symlinking pythonX.Y > python
            pth = py_executable + '%s.%s' % (
                    sys.version_info[0], sys.version_info[1])
            if os.path.exists(pth):
                os.unlink(pth)
            os.symlink('python', pth)
        else:
            # reverse symlinking python -> pythonX.Y (with --python)
            pth = join(bin_dir, 'python')
            if os.path.exists(pth):
                os.unlink(pth)
            os.symlink(os.path.basename(py_executable), pth)

    if sys.platform == 'win32' and ' ' in py_executable:
        # There's a bug with subprocess on Windows when using a first
        # argument that has a space in it.  Instead we have to quote
        # the value:
        py_executable = '"%s"' % py_executable
    cmd = [py_executable, '-c', 'import sys; print(sys.prefix)']
    logger.info('Testing executable with %s %s "%s"' % tuple(cmd))
    try:
        proc = subprocess.Popen(cmd,
                            stdout=subprocess.PIPE)
        proc_stdout, proc_stderr = proc.communicate()
    except OSError:
        e = sys.exc_info()[1]
        if e.errno == errno.EACCES:
            logger.fatal('ERROR: The executable %s could not be run: %s' % (py_executable, e))
            sys.exit(100)
        else:
          raise e

    proc_stdout = proc_stdout.strip().decode(sys.getdefaultencoding())
    proc_stdout = os.path.normcase(os.path.abspath(proc_stdout))
    if proc_stdout != os.path.normcase(os.path.abspath(home_dir)):
        logger.fatal(
            'ERROR: The executable %s is not functioning' % py_executable)
        logger.fatal(
            'ERROR: It thinks sys.prefix is %r (should be %r)'
            % (proc_stdout, os.path.normcase(os.path.abspath(home_dir))))
        logger.fatal(
            'ERROR: virtualenv is not compatible with this system or executable')
        if sys.platform == 'win32':
            logger.fatal(
                'Note: some Windows users have reported this error when they installed Python for "Only this user".  The problem may be resolvable if you install Python "For all users".  (See https://bugs.launchpad.net/virtualenv/+bug/352844)')
        sys.exit(100)
    else:
        logger.info('Got sys.prefix result: %r' % proc_stdout)

    pydistutils = os.path.expanduser('~/.pydistutils.cfg')
    if os.path.exists(pydistutils):
        logger.notify('Please make sure you remove any previous custom paths from '
                      'your %s file.' % pydistutils)
    ## FIXME: really this should be calculated earlier
    return py_executable

def install_activate(home_dir, bin_dir, prompt=None):
    if sys.platform == 'win32' or is_jython and os._name == 'nt':
        files = {'activate.bat': ACTIVATE_BAT,
                 'deactivate.bat': DEACTIVATE_BAT}
        if os.environ.get('OS') == 'Windows_NT' and os.environ.get('OSTYPE') == 'cygwin':
            files['activate'] = ACTIVATE_SH
    else:
        files = {'activate': ACTIVATE_SH}

        # suppling activate.fish in addition to, not instead of, the
        # bash script support.
        files['activate.fish'] = ACTIVATE_FISH

        # same for csh/tcsh support...
        files['activate.csh'] = ACTIVATE_CSH



    files['activate_this.py'] = ACTIVATE_THIS
    vname = os.path.basename(os.path.abspath(home_dir))
    for name, content in files.items():
        content = content.replace('__VIRTUAL_PROMPT__', prompt or '')
        content = content.replace('__VIRTUAL_WINPROMPT__', prompt or '(%s)' % vname)
        content = content.replace('__VIRTUAL_ENV__', os.path.abspath(home_dir))
        content = content.replace('__VIRTUAL_NAME__', vname)
        content = content.replace('__BIN_NAME__', os.path.basename(bin_dir))
        writefile(os.path.join(bin_dir, name), content)

def install_distutils(home_dir):
    distutils_path = change_prefix(distutils.__path__[0], home_dir)
    mkdir(distutils_path)
    ## FIXME: maybe this prefix setting should only be put in place if
    ## there's a local distutils.cfg with a prefix setting?
    home_dir = os.path.abspath(home_dir)
    ## FIXME: this is breaking things, removing for now:
    #distutils_cfg = DISTUTILS_CFG + "\n[install]\nprefix=%s\n" % home_dir
    writefile(os.path.join(distutils_path, '__init__.py'), DISTUTILS_INIT)
    writefile(os.path.join(distutils_path, 'distutils.cfg'), DISTUTILS_CFG, overwrite=False)

def fix_local_scheme(home_dir):
    """
    Platforms that use the "posix_local" install scheme (like Ubuntu with
    Python 2.7) need to be given an additional "local" location, sigh.
    """
    try:
        import sysconfig
    except ImportError:
        pass
    else:
        if sysconfig._get_default_scheme() == 'posix_local':
            local_path = os.path.join(home_dir, 'local')
            if not os.path.exists(local_path):
                os.symlink(os.path.abspath(home_dir), local_path)

def fix_lib64(lib_dir):
    """
    Some platforms (particularly Gentoo on x64) put things in lib64/pythonX.Y
    instead of lib/pythonX.Y.  If this is such a platform we'll just create a
    symlink so lib64 points to lib
    """
    if [p for p in distutils.sysconfig.get_config_vars().values()
        if isinstance(p, basestring) and 'lib64' in p]:
        logger.debug('This system uses lib64; symlinking lib64 to lib')
        assert os.path.basename(lib_dir) == 'python%s' % sys.version[:3], (
            "Unexpected python lib dir: %r" % lib_dir)
        lib_parent = os.path.dirname(lib_dir)
        assert os.path.basename(lib_parent) == 'lib', (
            "Unexpected parent dir: %r" % lib_parent)
        copyfile(lib_parent, os.path.join(os.path.dirname(lib_parent), 'lib64'))

def resolve_interpreter(exe):
    """
    If the executable given isn't an absolute path, search $PATH for the interpreter
    """
    if os.path.abspath(exe) != exe:
        paths = os.environ.get('PATH', '').split(os.pathsep)
        for path in paths:
            if os.path.exists(os.path.join(path, exe)):
                exe = os.path.join(path, exe)
                break
    if not os.path.exists(exe):
        logger.fatal('The executable %s (from --python=%s) does not exist' % (exe, exe))
        raise SystemExit(3)
    if not is_executable(exe):
        logger.fatal('The executable %s (from --python=%s) is not executable' % (exe, exe))
        raise SystemExit(3)
    return exe

def is_executable(exe):
    """Checks a file is executable"""
    return os.access(exe, os.X_OK)

############################################################
## Relocating the environment:

def make_environment_relocatable(home_dir):
    """
    Makes the already-existing environment use relative paths, and takes out
    the #!-based environment selection in scripts.
    """
    home_dir, lib_dir, inc_dir, bin_dir = path_locations(home_dir)
    activate_this = os.path.join(bin_dir, 'activate_this.py')
    if not os.path.exists(activate_this):
        logger.fatal(
            'The environment doesn\'t have a file %s -- please re-run virtualenv '
            'on this environment to update it' % activate_this)
    fixup_scripts(home_dir)
    fixup_pth_and_egg_link(home_dir)
    ## FIXME: need to fix up distutils.cfg

OK_ABS_SCRIPTS = ['python', 'python%s' % sys.version[:3],
                  'activate', 'activate.bat', 'activate_this.py']

def fixup_scripts(home_dir):
    # This is what we expect at the top of scripts:
    shebang = '#!%s/bin/python' % os.path.normcase(os.path.abspath(home_dir))
    # This is what we'll put:
    new_shebang = '#!/usr/bin/env python%s' % sys.version[:3]
    activate = "import os; activate_this=os.path.join(os.path.dirname(__file__), 'activate_this.py'); execfile(activate_this, dict(__file__=activate_this)); del os, activate_this"
    if sys.platform == 'win32':
        bin_suffix = 'Scripts'
    else:
        bin_suffix = 'bin'
    bin_dir = os.path.join(home_dir, bin_suffix)
    home_dir, lib_dir, inc_dir, bin_dir = path_locations(home_dir)
    for filename in os.listdir(bin_dir):
        filename = os.path.join(bin_dir, filename)
        if not os.path.isfile(filename):
            # ignore subdirs, e.g. .svn ones.
            continue
        f = open(filename, 'rb')
        lines = f.readlines()
        f.close()
        if not lines:
            logger.warn('Script %s is an empty file' % filename)
            continue
        if not lines[0].strip().startswith(shebang):
            if os.path.basename(filename) in OK_ABS_SCRIPTS:
                logger.debug('Cannot make script %s relative' % filename)
            elif lines[0].strip() == new_shebang:
                logger.info('Script %s has already been made relative' % filename)
            else:
                logger.warn('Script %s cannot be made relative (it\'s not a normal script that starts with %s)'
                            % (filename, shebang))
            continue
        logger.notify('Making script %s relative' % filename)
        lines = [new_shebang+'\n', activate+'\n'] + lines[1:]
        f = open(filename, 'wb')
        f.writelines(lines)
        f.close()

def fixup_pth_and_egg_link(home_dir, sys_path=None):
    """Makes .pth and .egg-link files use relative paths"""
    home_dir = os.path.normcase(os.path.abspath(home_dir))
    if sys_path is None:
        sys_path = sys.path
    for path in sys_path:
        if not path:
            path = '.'
        if not os.path.isdir(path):
            continue
        path = os.path.normcase(os.path.abspath(path))
        if not path.startswith(home_dir):
            logger.debug('Skipping system (non-environment) directory %s' % path)
            continue
        for filename in os.listdir(path):
            filename = os.path.join(path, filename)
            if filename.endswith('.pth'):
                if not os.access(filename, os.W_OK):
                    logger.warn('Cannot write .pth file %s, skipping' % filename)
                else:
                    fixup_pth_file(filename)
            if filename.endswith('.egg-link'):
                if not os.access(filename, os.W_OK):
                    logger.warn('Cannot write .egg-link file %s, skipping' % filename)
                else:
                    fixup_egg_link(filename)

def fixup_pth_file(filename):
    lines = []
    prev_lines = []
    f = open(filename)
    prev_lines = f.readlines()
    f.close()
    for line in prev_lines:
        line = line.strip()
        if (not line or line.startswith('#') or line.startswith('import ')
            or os.path.abspath(line) != line):
            lines.append(line)
        else:
            new_value = make_relative_path(filename, line)
            if line != new_value:
                logger.debug('Rewriting path %s as %s (in %s)' % (line, new_value, filename))
            lines.append(new_value)
    if lines == prev_lines:
        logger.info('No changes to .pth file %s' % filename)
        return
    logger.notify('Making paths in .pth file %s relative' % filename)
    f = open(filename, 'w')
    f.write('\n'.join(lines) + '\n')
    f.close()

def fixup_egg_link(filename):
    f = open(filename)
    link = f.read().strip()
    f.close()
    if os.path.abspath(link) != link:
        logger.debug('Link in %s already relative' % filename)
        return
    new_link = make_relative_path(filename, link)
    logger.notify('Rewriting link %s in %s as %s' % (link, filename, new_link))
    f = open(filename, 'w')
    f.write(new_link)
    f.close()

def make_relative_path(source, dest, dest_is_directory=True):
    """
    Make a filename relative, where the filename is dest, and it is
    being referred to from the filename source.

        >>> make_relative_path('/usr/share/something/a-file.pth',
        ...                    '/usr/share/another-place/src/Directory')
        '../another-place/src/Directory'
        >>> make_relative_path('/usr/share/something/a-file.pth',
        ...                    '/home/user/src/Directory')
        '../../../home/user/src/Directory'
        >>> make_relative_path('/usr/share/a-file.pth', '/usr/share/')
        './'
    """
    source = os.path.dirname(source)
    if not dest_is_directory:
        dest_filename = os.path.basename(dest)
        dest = os.path.dirname(dest)
    dest = os.path.normpath(os.path.abspath(dest))
    source = os.path.normpath(os.path.abspath(source))
    dest_parts = dest.strip(os.path.sep).split(os.path.sep)
    source_parts = source.strip(os.path.sep).split(os.path.sep)
    while dest_parts and source_parts and dest_parts[0] == source_parts[0]:
        dest_parts.pop(0)
        source_parts.pop(0)
    full_parts = ['..']*len(source_parts) + dest_parts
    if not dest_is_directory:
        full_parts.append(dest_filename)
    if not full_parts:
        # Special case for the current directory (otherwise it'd be '')
        return './'
    return os.path.sep.join(full_parts)



############################################################
## Bootstrap script creation:

def create_bootstrap_script(extra_text, python_version=''):
    """
    Creates a bootstrap script, which is like this script but with
    extend_parser, adjust_options, and after_install hooks.

    This returns a string that (written to disk of course) can be used
    as a bootstrap script with your own customizations.  The script
    will be the standard virtualenv.py script, with your extra text
    added (your extra text should be Python code).

    If you include these functions, they will be called:

    ``extend_parser(optparse_parser)``:
        You can add or remove options from the parser here.

    ``adjust_options(options, args)``:
        You can change options here, or change the args (if you accept
        different kinds of arguments, be sure you modify ``args`` so it is
        only ``[DEST_DIR]``).

    ``after_install(options, home_dir)``:

        After everything is installed, this function is called.  This
        is probably the function you are most likely to use.  An
        example would be::

            def after_install(options, home_dir):
                subprocess.call([join(home_dir, 'bin', 'easy_install'),
                                 'MyPackage'])
                subprocess.call([join(home_dir, 'bin', 'my-package-script'),
                                 'setup', home_dir])

        This example immediately installs a package, and runs a setup
        script from that package.

    If you provide something like ``python_version='2.4'`` then the
    script will start with ``#!/usr/bin/env python2.4`` instead of
    ``#!/usr/bin/env python``.  You can use this when the script must
    be run with a particular Python version.
    """
    filename = __file__
    if filename.endswith('.pyc'):
        filename = filename[:-1]
    f = open(filename, 'rb')
    content = f.read()
    f.close()
    py_exe = 'python%s' % python_version
    content = (('#!/usr/bin/env %s\n' % py_exe)
               + '## WARNING: This file is generated\n'
               + content)
    return content.replace('##EXT' 'END##', extra_text)

import os, subprocess

def after_install(options, home_dir):
    def call(*args):
        retcode = subprocess.call(*args)
        if retcode:
            sys.stderr.write("Exit status %d from command args %s\n" % (retcode, args))
    	    sys.exit(retcode)

    call([join(home_dir, 'bin', 'easy_install'), 'virtualenv>=1.6.1'])
    call([join(home_dir, 'bin', 'easy_install'), '--upgrade', 'pip'])
    call([join(home_dir, 'bin', 'easy_install'), 'paver'])

    source_root = os.path.dirname(__file__)
    pavement_file = join(source_root, 'obadmin', 'obadmin', 'pavement.py')
    call([join(home_dir, 'bin', 'paver'), '-f', pavement_file,  'post_bootstrap'])

    # link source code
    if not os.path.abspath(source_root).startswith(os.path.abspath(home_dir)):
        source_link = join(home_dir, 'src', 'openblock')
        print "symlinking openblock source in %s to %s" % (source_root, source_link)
        copyfile(source_root, source_link, symlink=True)


def adjust_options(options, args):
    # Sanity-checking Python version here b/c we want to do this early and
    # there's no more appropriate hook in a virtualenv bootstrap
    # script.
    import sys
    if not ((2, 6) <= sys.version_info[:2] < (3, 0)):
        raise EnvironmentError(
            "Incompatible Python version, we need Python >= 2.6"
            " and less than 3.0.")
    # assume build in place unless otherwise specified
    if len(args) == 0:
        args[:] = ['./']


def convert(s):
    b = base64.b64decode(s.encode('ascii'))
    return zlib.decompress(b).decode('utf-8')
    
##file site.py
SITE_PY = convert("""
eJzVPP1z2zaWv/OvwMqTIZXKdD66nR2n7o2TOK3v3MTbpLO5dT06SoIk1hTJEqQV7c3d337vAwAB
kvLHdvvDaTKxRAIPDw/vGw8YjUanZSnzhdgUiyaTQsmkmq9FmdRrJZZFJep1Wi0Oy6Sqd/B0fpOs
pBJ1IdROxdgqDoKnv/MTPBWf1qkyKMC3pKmLTVKn8yTLdiLdlEVVy4VYNFWar0Sap3WaZOk/oEWR
x+Lp78cgOM8FzDxLZSVuZaUArhLFUlzu6nWRi6gpcc7P4z8nL8cToeZVWtbQoNI4A0XWSR3kUi4A
TWjZKCBlWstDVcp5ukzntuG2aLKFKLNkLsV//RdPjZqGYaCKjdyuZSVFDsgATAmwSsQDvqaVmBcL
GQvxWs4THICft8QKGNoE10whGfNCZEW+gjnlci6VSqqdiGZNTYAIZbEoAKcUMKjTLAu2RXWjxrCk
tB5beCQSZg9/MsweME8cv885gOOHPPg5T79MGDZwD4Kr18w2lVymX0SCYOGn/CLnU/0sSpdikS6X
QIO8HmOTgBFQIktnRyUtx7d6hb47IqwsVyYwhkSUuTG/pB5xcF6LJFPAtk2JNFKE+Vs5S5McqJHf
wnAAEUgaDI2zSFVtx6HZiQIAVLiONUjJRolok6Q5MOuPyZzQ/luaL4qtGhMFYLWU+LVRtTv/aIAA
0NohwCTAxTKr2eRZeiOz3RgQ+ATYV1I1WY0CsUgrOa+LKpWKAABqOyG/ANITkVRSk5A508jthOhP
NElzXFgUMBR4fIkkWaarpiIJE8sUOBe44t2Hn8Tbs9fnp+81jxlgLLOrDeAMUGihHZxgAHHUqOoo
K0Cg4+AC/4hksUAhW+H4gFfb4OjelQ4imHsZd/s4Cw5k14urh4E51qBMaKyA+v03dJmoNdDnf+5Z
7yA43UcVmjh/264LkMk82UixTpi/kDOCbzWc7+KyXr8CblAIpwZSKVwcRDBFeEASl2ZRkUtRAotl
aS7HAVBoRm39VQRWeF/kh7TWHU4ACFWQw0vn2ZhGzCVMtA/rFeoL03hHM9NNArvOm6IixQH8n89J
F2VJfkM4KmIo/jaTqzTPESHkhSA8CGlgdZMCJy5icUGtSC+YRiJk7cUtUSQa4CVkOuBJ+SXZlJmc
sPiibr1bjdBgshZmrTPmOGhZk3qlVWunOsh7L+LPHa4jNOt1JQF4M/OEblkUEzEDnU3YlMmGxave
FsQ5wYA8USfkCWoJffE7UPRUqWYj7UvkFdAsxFDBssiyYgskOw4CIQ6wkTHKPnPCW3gH/wNc/D+T
9XwdBM5IFrAGhcjvA4VAwCTIXHO1RsLjNs3KXSWT5qwpimohKxrqYcQ+YsQf2BjnGrwvam3UeLq4
ysUmrVElzbTJTNni5WHN+vEVzxumAZZbEc1M05ZOG5xeVq6TmTQuyUwuURL0Ir2yyw5jBgNjki2u
xYatDLwDssiULciwYkGls6wlOQEAg4UvydOyyaiRQgYTCQy0KQn+JkGTXmhnCdibzXKAConN9xzs
D+D2DxCj7ToF+swBAmgY1FKwfLO0rtBBaPVR4Bt905/HB049X2rbxEMukzTTVj7Jg3N6eFZVJL5z
WWKviSaGghnmNbp2qxzoiGI+Go2CwLhDO2W+Fiqoq90xsIIw40ynsyZFwzedoqnXP1TAowhnYK+b
bWfhgYYwnd4DlZwuy6rY4Gs7t4+gTGAs7BEciEvSMpIdZI8TXyH5XJVemqZoux12FqiHgsufzt6d
fz77KE7EVavSJl19dg1jnuUJsDVZBGCqzrCtLoOWqPhS1H3iHZh3YgqwZ9SbxFcmdQO8C6h/qhp6
DdOYey+Ds/enry/Opj9/PPtp+vH80xkgCHZGBgc0ZTSPDTiMKgbhAK5cqFjb16DXgx68Pv1oHwTT
VE3LXbmDB2AogYWrCOY7ESE+nGobPE3zZRGOqfGv7ISfsFrRHtfV8dfX4uREhL8mt0kYgNfTNuVF
/JEE4NOulNC1hj9RocZBsJBLEJYbiSIVPSVPdswdgIjQstCW9dcizc175iN3CJL4iHoADtPpPEuU
wsbTaQikpQ4DH+gQszuMchJBx3Lndh1rVPBTSViKHLtM8L8BFJMZ9UM0GEW3i2kEAraZJ0pyK5o+
9JtOUctMp5EeEMSPeBxcJFYcoTBNUMtUKXiixCuodWaqyPAnwke5JZHBYAj1Gi6SDnbi2yRrpIqc
SQERo6hDRlSNqSIOAqciAtvZLt143KWm4RloBuTLCtB7VYdy+DkADwUUjAm7MDTjaIlphpj+O8cG
hAM4iSEqaKU6UFificuzS/Hy2YtDdEAgSlxY6njN0aameSPtwyWs1krWDsLcK5yQMIxduixRM+LT
47thbmK7Mn1WWOolruSmuJULwBYZ2Fll8RO9gVga5jFPYBVBE5MFZ6VnPL0EI0eePUgLWnug3oag
mPU3S3/A4bvMFagODoWJ1DpOZ+NVVsVtiu7BbKdfgnUD9YY2zrgigbNwHpOhEQMNAX5rjpTayhAU
WNWwi0l4I0jU8ItWFcYE7gJ16zV9vcmLbT7l2PUE1WQ0tqyLgqWZFxu0S3Ag3oHdACQLCMVaojEU
cNIFytYhIA/Th+kCZSkaAEBgmhUFWA4sE5zRFDnOw2ERxviVIOGtJFr4WzMEBUeGGA4kehvbB0ZL
ICSYnFVwVjVoJkNZM81gYIckPtddxBw0+gA6VIzB0EUaGjcy9Ls6BuUsLlyl5PRDG/r582dmG7Wm
jAgiNsNJo9FfknmLyx2YwhR0gvGhOL9CbLAFdxTANEqzpjj8KIqS/SdYz0st22C5IR6r6/L46Gi7
3cY6H1BUqyO1PPrzX7755i/PWCcuFsQ/MB1HWnRyLD6id+iDxt8aC/SdWbkOP6a5z40EK5LkR5Hz
iPh936SLQhwfjq3+RC5uDSv+b5wPUCBTMyhTGWg7ajF6og6fxC/VSDwRkds2GrMnoU2qtWK+1YUe
dQG2GzyNedHkdegoUiW+AusGMfVCzppVaAf3bKT5AVNFOY0sDxw+v0YMfM4wfGVM8RS1BLEFWnyH
9D8x2yTkz2gNgeRFE9WLd3fDWswQd/FwebfeoSM0ZoapQu5AifCbPFgAbeO+5OBHO6No9xxn1Hw8
Q2AsfWCYV7uCEQoO4YJrMXGlzuFq9FFBmrasmkHBuKoRFDS4dTOmtgZHNjJEkOjdmPCcF1a3ADp1
cn0mojerAC3ccXrWrssKjieEPHAintMTCU7tce/dM17aJssoBdPhUY8qDNhbaLTTBfBlZABMxKj6
ecQtTWDxobMovAYDwArO2iCDLXvMhG9cH3B0MBpgp57V39ebaTwEAhcp4uzRg6ATyic8QqVAmsrI
77mPxS1x+4PdaXGIqcwykUirPcLVVR6DQnWnYVqmOepeZ5HieVaAV2y1IjFS+953FihywcdDxkxL
oCZDSw6n0Ql5e54AhrodJrxWDaYG3MwJYrRJFVk3JNMa/gO3gjISlD4CWhI0C+ahUuZP7F8gc3a+
+sse9rCERoZwm+5zQ3oWQ8Mx7w8EklHnT0AKciBhXxjJdWR1kAGHOQvkCTe8lnulm2DECuTMsSCk
ZgB3eukFOPgkxj0LklCE/KVWshRfiREsX1dUH6a7/6VcatIGkdOAXAWdbzhxcxFOHuKkk5fwGdrP
SNDuRlkAB8/A5XFT8y6bG6a1aRJw1n3FbZECjUyZk9HYRfXaEMZN//7pxGnREssMYhjKG8jbhDEj
jQO73Bo0LLgB4615dyz92M1YYN8oLNQLufkC8V9YpWpeqBAD3F7uwv1orujTxmJ7kc5G8MdbgNH4
2oMkM52/wCzLPzFI6EEPh6B7k8W0yCKptmkekgLT9Dvxl6aHhyWlZ+SOPlI4dQQTxRzl0bsKBIQ2
K49AnFATQFQuQ6Xd/j7YO6c4snC5+8hzm6+OX173iTvZl+Gxn+GlOvtSV4nC1cp40VgocLX6BhyV
LkwuyXd6u1FvR2OYUBUKokjx4eNngYTgTOw22T1u6i3DIzb3zsn7GNRBr91Lrs7siF0AEdSKyChH
4eM58uHIPnZyd0zsEUAexTB3LIqBpPnkn4Fz10LBGIeLXY55tK7KwA+8/ubr6UBm1EXym69H94zS
IcaQ2EcdT9COTGUAYnDapkslk4x8DacTZRXzlndsm3LMCp3iP81k1wNOJ37Me2MyWvi95r3A0XwO
iB4QZhezXyFYVTq/dZukGSXlAY3DQ9RzJs7m1MEwPh6ku1HGnBR4LM8mg6GQunoGCxNyYD/uT0f7
Racm9zsQkJpPmag+Kgd6A77dP/I21d29w/2yP2ip/yCd9UhA3mxGAwR84BzM3ub//5mwsmJoWlmN
O1pfybv1vAH2AHW4x825ww3pD827WUvjTLDcKfEUBfSp2NKGNuXycGcCoCzYzxiAg8uot0XfNFXF
m5sk56WsDnHDbiKwlsd4GlQi1Adz9F7WiIltNqfcqFP5UQypzlBnO+1MwtZPHRbZdWFyJDK/TSvo
C1olCn/48ONZ2GcAPQx2GgbnrqPhkofbKYT7CKYNNXHCx/RhCj2myz8vVV1X2Seo2TM2GUhNtj5h
e4lHE7cOr8E9GQhvg5A3YjEinK/l/GYqaXMZ2RS7OknYN/gaMbF7zn6FkEqWVOYEM5lnDdKKHT2s
T1s2+Zzy8bUEe66LSbG4hLaMOd20zJKViKjzAlMdmhspG3KbVNrbKasCyxdFky6OVulCyN+aJMMw
Ui6XgAtuluhXMQ9PGQ/xlne9uaxNyXlTpfUOSJCoQu810Qa503C244lGHpK8rcAExC3zY/ERp43v
mXALQy4TjPoZdpwkxnnYwWwGInfRc3ifF1McdUpVoBNGqr8PTI+D7ggFABgBUJj/aKwzRf4bSa/c
DS1ac5eoqCU9UrqRbUEeB0KJxhhZ82/66TOiy1t7sFztx3J1N5arLparQSxXPparu7F0RQIX1iZJ
jCQMJUq6afTBigw3x8HDnCXzNbfD6kCsAgSIojQBnZEpLpL1Mim8n0RASG07G5z0sK2wSLnssCo4
5apBIvfjpokOHk15s9OZ6jV0Z56K8dn2VZn4fY/imIqJZtSd5W2R1EnsycUqK2YgthbdSQtgIroF
J5yby2+nM84mdizV6PI/P/3w4T02R1Ajs51O3XAR0bDgVKKnSbVSfWlqg40S2JFa+oUf1E0DPHhg
JodHOeD/3lJFATKO2NKOeCFK8ACo7sc2c6tjwrDzXJfR6OfM5Ly5cSJGeT1qJ7WHSKeXl29PP52O
KMU0+t+RKzCGtr50uPiYFrZB339zm1uKYx8Qap1LaY2fOyeP1i1H3G9jDdiO2/vsuvPgxUMM9mBY
6s/yD6UULAkQKtbJxscQ6sHBz+8KE3r0MYzYKw9zd3LYWbHvHNlzXBRH9IfS3N0B/M01jDGmQADt
QkUmMmiDqY7St+b1Doo6QB/o6/3uEKwbenUjGZ+idhIDDqBDWdtsv/vn7Quw0VOyfn32/fn7i/PX
l6effnBcQHTlPnw8eiHOfvwsqB4BDRj7RAluxddY+QKGxT0KIxYF/GswvbFoak5KQq+3Fxd6Z2CD
hyGwOhZtTgzPuWzGQuMcDWc97UNd74IYZTpAck6dUHkInUrBeGnDJx5UoSto6TDLDJ3VRode+jSR
OXVE+6gxSB80dknBILikCV5RnXNtosKKd5z0SZwBpLSNtoUIGeWgetvTzn6LyeZ7iTnqDE/azlrR
X4UuruF1rMoshUjuVWhlSXfDcoyWcfRDu6HKeA1pQKc7jKwb8qz3YoFW61XIc9P9xy2j/dYAhi2D
vYV555LKEahGF4upRIiNeOcglF/gq116vQYKFgw3lmpcRMN0Kcw+geBarFMIIIAn12B9MU4ACJ2V
8BPQx052QBZYDRC+2SwO/xpqgvitf/lloHldZYd/FyVEQYJLV8IBYrqN30LgE8tYnH14Nw4ZOSoF
FX9tsIAcHBLK8jnSTvUyvGM7jZTMlrqewdcH+EL7CfS6072SZaW7D7vGIUrAExWR1/BEGfqFWF5k
YU9wKuMOaKyNt5jhGTN329t8DsTHtcwyXRF9/vbiDHxHLNdHCeJ9njMYjvMluGWri734DFwHFG7o
wusK2bhCF5Y29Rex12wwM4siR729OgC7TpT97PfqpTqrJFUu2hFOm2GZgvMYWRnWwiwrs3anDVLY
bUMUR5lhlpheVlQw6fME8DI9TTgkglgJDwOYNDPvWqZ5bSrksnQOehRULijUCQgJEhdPvBHnFTkn
eotKmYMy8LDcVelqXWMyHTrHVKSPzX88/Xxx/p4K11+8bL3uAeacUCQw4aKFEyxJw2wHfHHLzJCr
ptMhntWvEAZqH/jTfcXVECc8QK8fJxbxT/cVn1Q6cSJBngEoqKbsigcGAE63IblpZYFxtXEwftyS
sxYzHwzlIvFghC4scOfX50TbsmNKKO9jXj5il2JZahpGprNbAtX96DkuS9xWWUTDjeDtkGyZzwy6
3vTe7Cu2cj89KcRDk4BRv7U/hqlG6jXV03GYbR+3UFirbewvuZMrddrNcxRlIGLkdh67TDashHVz
5kCvbLcHTHyr0TWSOKjKR7/kI+1heJhYYvfiFNORjk2QEcBMhtSnQxrwodAigAKhatPIkdzJ+OkL
b46ONbh/jlp3gW38ARShrv2kMwVFBZwIX35jx5FfEVqoR49F6HgqucwLW5eEn+0avcrn/hwHZYCS
mCh2VZKvZMSwJgbmVz6x96RgSdt6pL5Kr4cMizgH5/TLHg7vy8XwxolBrcMIvXY3ctdVRz55sMHg
0YM7CeaDr5It6P6yqSNeyWGRHz5ttR/q/RCx2g2a6s3eKMR0zG/hnvVpAQ9SQ8NCD++3gd0i/PDa
GEfW2sfOKZrQvtAe7LyC0KxWtC3jHF8zvqj1AlqDe9Ka/JF9qgtT7O+Bc0lOTsgC5cFdkN7cRrpB
J50w4uMxfLYwpfLr9vSGfreQtzIrwPWCqA6r63+11fXj2KZTBuuOfjd2l7vL3TBu9KbF7NiU/6Nn
pkpYvziX9RGiM5jxuQuzFhlc6l90SJLkN+Qlv/nb+US8ef8T/P9afoC4Co/HTcTfAQ3xpqggvuTz
nXTwHk8O1Bw4Fo3CM3QEjbYq+I4CdNsuPTrjtog+0uCfZbCaUmAVZ7XhizEARZ4gnXlu/QRTqA+/
zUmijjdqPMWhRRnpl0iD/Ycr8EDCkW4Zr+tNhvbCyZK0q3k1ujh/c/b+41lcf0EONz9HThbFLwDC
6eg94gr3wybCPpk3+OTacZx/kFk54DfroNMc1MCgU4QQl5Q20ORLFxIbXCQVZg5EuVsU8xhbAsvz
2bB6C4702Ikv7zX0npVFWNFY76K13jw+BmqIX7qKaAQNqY+eE/UkhJIZHlLix/Fo2BRPBKW24c/T
m+3CzYzr0yY0wS6m7awjv7vVhWums4ZnOYnwOrHLYA4gZmmiNrO5ezDtQy70nRmg5WifQy6TJquF
zEFyKcinywtA07tnyVhCmFXYnNEBK0rTZNtkp5xKm0SJEY46ovPXuCFDGUOIwX9Mbtge4CE30fBp
WYBOiFL8VDhdVTNfswRzSETUGyg82Kb5yxdhj8I8KEfI89aRhXmi28gYrWSt588PovHV87bSgbLS
c+8k6bwEq+eyyQGozvLp06cj8W/3ez+MSpwVxQ24ZQB70Gu5oNd7LLeenF2tvmdv3sTAj/O1vIIH
15Q9t8+bnFKTd3SlBZH2r4ER4tqElhlN+45d5qRdxRvN3II3rLTl+DlP6WYcTC1JVLb6giFMOxlp
IpYExRAmap6mIacpYD12RYOHwDDNqPlFfgGOTxHMBN/iDhmH2mv0MKlg03KPRedEjAjwiAqoeDQ6
RUvHoADP6eVOozk9z9O6Pb/wzN081afFa3vhjeYrkWxRMsw8OsRwzhN6rNp62MWdLOpFLMX8yk04
dmbJr+/DHVgbJK1YLg2m8NAs0ryQ1dyYU1yxdJ7WDhjTDuFwZ7rnh6xPHAygNAL1TlZhYSXavv2T
XRcX0w+0j3xoRtLlQ7W9O4mTQ0neqaKL43Z8SkNZQlq+NV/GMMp7SmtrT8AbS/xJJ1WxeN274sE9
R9fk+uoGrt9o73MAOHRdkFWQlh09HeHcUWXhM9PuuXABPxSiE263aVU3STbVNwRM0WGb2o11jac9
f3XnyULrrYCTX4AHfKhLxcFxMFU2SE+s9DRHAU7EUqcoYvdIk3/6pyzQy3vBvhL4FEiZxdQcxDVJ
pCvLrvaE4zO+gsBR8QjqK3Nq5iE2wZzd6B17cKcxoaKncNwt5ey1wg0WU5tvPe9uZPCoITuwfC/e
TLB7cYP47kREzyfiz51AbF7u8OohIMOTRfxkEfo+IXW9On7R2rl+4NuBsBfIy+tHTzdLZzS9cKjG
+v6+uugRA9ANyO4ylYvDJwqxY5x/L1QNpZ3Xfk6lGeMR7ANbdaVPH7dnMujo1Qyiim2r0BzVZvxf
O4g51qz1EJ8ARaXBFtCeWjeFL53iQ3uzGBYmavT8lUUpmQ5tjuE3vB0E3muCukK1d9NUl5FbsAM5
AX1WkLfA2oYDQeEjeCikm0xo0b7qbAv/kYvHlen7Nhd7WH7z9V14ugI+WJY/QFCPmE6rP5Cp9rLM
YxfmAfv19/Pfw3nvLr57NJV0r2FaYSiFhczrhN+gSWzKY5tqMCKJW0GRW96Gn/pm8OAHiyPqpvom
vGv63P+uuesWgZ252d3tzd0/4OXSQPfdzy9DNOAwTxPiQTXjrcAO6wJXjCe6qGA4Zak/SH63E850
j1a4D4wpYcAEKLGpxt5ozU0yd79jhcwh32Hqnucb1NWdafcOOHY5/iGKlqsB8Lk94kslHgvNgew3
0qVUUy4anMrVSk0TvBBtSsEGFbj0vEjjvr6j+6xkonbG68RbQwCE4SZdiuhWGwNjQEDDF7NyfYhz
PYSgoamK0inLVOmCM0jaxQVwMWeOqL/JTHJd5SiTmPBTTVVWEBWM9PWdXLgwVOvZAjWJjE2ibgzq
psdE3+aIQ3C1jDkDyPkqjjQ86gAh+GiQczcRFypPp/Yd8Muz9qxzOrEMIfNmI6ukbu/58LdJU/Gd
MwKd/MQFdlIVrWR2OMVFLLX84SCFyQL7/SvtZHtBxh0HnMdW6z2craiHToE95uy0Y3sMN6df7D1f
7v0yC7oV1jXytlnLffZuE1gKc2kV6UqdO+C3+iIdvp6RM5voJjh8BHLvnrvyy3OtWmMnxaLhPHMV
Q//mFDy6S7Z46EK0Hhf0rz7rOPp2fF9vWGbphQZ7GlsqatdqUPG0o43biBor6e6JqP1q6UdG1B78
B0bU+vo6MDgaH60PBuun7wm9WU24d8G1jAB9pkAk3Nnr3CRmTGbkViND2Jt+Gdm7WFlnOkecjJlA
juxfEkQg+M435ZZuencymXGHIlpfuujx9xcfXp9eEC2ml6dv/uP0e6pWwfRxx2Y9OOWQF4dM7UOv
LtZNP+gKg6HBW2wHLlfkwx0aQu99b3N2AMLwQZ6hBe0qMvf1vg69AxH9ToD43dPuQN2nsgch9/wz
XXzv1hV0ClgD/ZSrDc0vZ8vWPDI7FywO7c6Eed8mk7WM9nJt+xbOqfvrqxPtt+rr+PbkAce2+pRW
AHPIyF82hWyOEthEJTsq3RvyqWQWj2GZqyxACufSuVKNblNjULV/FX8Fyi7BfTB2GCf2Wltqx+ly
Ze9rxr2wuYwNQbxzUKP+/FxhX8hsDxWCgBWevjCMETH6T28w2e3YJ0pcHdKJy0NUNtf2F66ZdnL/
luKma20v3lFcucHbTtB42WTuRqrt0+tAzh9l54ulU+IPmu8I6NyKpwL2Rp+JFeJsJ0IIJPWGIVYN
Eh31rVkO8mg3HewNrZ6Jw33n8dzzaEI8399w0Tnypnu84B7qnh6qMaeeHAuM5Wv7DtqJ7wgyb+8I
umnHcz5wT1Ff8Apfb6+eH9tkK/I7vnYUCZXZjBzDfuWUqd15u5vTnZilmlAdE8ZszjFN3eLagco+
wb4Yp1ervycOMvu+DGnkvR8u8jE9vFurR11MLesdw5RE9ESNaVrO6QaNu30y7k+3VVt9IHxS4wFA
eioQYCGYnm50Kud2XP4aPdNR4ayhezHdjHvoSAVV0fgcwT2M79fi1+1OJywf1J1RNP25QZcD9ZKD
cLPvwK3GXkpkv0noTr3lgz0uAB9WHe7//AH9+/VdtvuLu/xq2+rl4AEp9mWxJBArJTokMo9jMDKg
NyPS1lhHbgQdL6Fo6egyVDs35At0/KjMEG+9pQCDnNmp9gCsUQj+D1/Qrqc=
""")

##file ez_setup.py
EZ_SETUP_PY = convert("""
eJzNWmtv49a1/a5fwSgwJGE0NN8PDzRFmkyBAYrcIo8CFx5XPk+LHYpUSWoctch/v+ucQ1KkZDrt
RT6UwcQ2ebjPfq6195G+/upwanZlMZvP538sy6ZuKnKwatEcD01Z5rWVFXVD8pw0GRbNPkrrVB6t
Z1I0VlNax1qM16qnlXUg7DN5EovaPLQPp7X192PdYAHLj1xYzS6rZzLLhXql2UEI2QuLZ5VgTVmd
rOes2VlZs7ZIwS3CuX5BbajWNuXBKqXZqZN/dzebWbhkVe4t8c+tvm9l+0NZNUrL7VlLvW58a7m6
sqwS/zhCHYtY9UGwTGbM+iKqGk5Qe59fXavfsYqXz0VeEj7bZ1VVVmurrLR3SGGRvBFVQRrRLzpb
utabMqzipVWXFj1Z9fFwyE9Z8TRTxpLDoSoPVaZeLw8qCNoPj4+XFjw+2rPZT8pN2q9Mb6wkCqs6
4vdamcKq7KDNa6OqtTw8VYQP42irZJi1zqtP9ey7D3/65uc//7T964cffvz4P99bG2vu2BFz3Xn/
6Ocf/qz8qh7tmuZwd3t7OB0y2ySXXVZPt21S1Lc39S3+63e7nVs3ahe79e/9nf8wm+15uOWkIRD4
Lx2xxfmNt9icum8PJ8/2bfH0tLizFknieYzI1HG90OFJkNA0jWgsvZBFImJksX5FStBJoXFKEhI4
vghCx5OUJqEQvnTTwI39kNEJKd5YlzAK4zhMeUIinkgWBE7skJQ7sRd7PE1fl9LrEsAAknA3SrlH
RRS5kvgeiUToiUAm3pRF/lgXSn2XOZLFfpqSyA/jNI1DRngqQ+JEbvKqlF4XPyEJw10eCcY9zwti
6capjDmJolQSNiElGOsSeU4QEi8QPBCuoCyOpXD8lJBARDIW4atSzn5h1CNuEkKPhBMmJfW4C30c
n/rUZcHLUthFvlBfejQM/ZRHiGss44DwOHU9CCKpk0xYxC7zBfZwweHJKOYe96QUbuA4qR8F0iPB
RKSZ64yVYXCHR2jIfeJ4YRSEEeLDXD9xHBI7qfO6mF6bMOZ4ETFKaeLEscfClIQ+SQLfJyHnk54x
YsJODBdBRFgCX6YxS9IwjD0RiiREOgqasPh1MVGvTSJQSURIJ4KDPCaiwA0gzYORcPhEtAEqY994
lAiCGnZ9jvdRRl4iYkpCGhJoxMXrYs6R4pGfypQ6EBawwAvS2PEDLpgnmMO8yUi5Y99EAUsD6VMZ
kxhZ6AuW+MKhHsIdByn1XhfT+4ZKknqu41COMHHUBCQJzn0EPgqcJJoQc4Ez0nGigMqIEI/G3IFa
8GyAxHYSN2beVKAucCZyIzf1hGB+KINYIGpuxHhEXA9SvXhKygXOSDcBQAF8uUSqEC9MWQop0uUx
jRM5gVbsAmeEI3gcRInH0jShksbwdOIgex3EPHangu2Pg0SokG4kOYdhYRi6QRK4LAZ+8TRJo3BK
ygVaUYemru8SRqjvOXAGcC6WQcBCAEXsylel9BYhSST2jHggqfRRUVSmQcQcuAqoJ6YSJhhblCi0
BvD7HuM0ZbFHmQwAX14kvYTIKbQKxxYJkUqeOFAHBYmMlb4ApocxAIMnbjQV6XBsEZHAKi7BKm7s
uELAuTHIKaQMhEeiKZQJL2KUcF9GAISAMUKS2A2QONyPKWPc5yGfkBKNLULBJGD5xHUjMFGSBLEH
EWDMMEhR2lPAGV2wGwsjIsOYwr/oHlANkQNDgsBHgYVkChuisUXUkwmJQw9kD9ilPkjaQai5CCVa
idCfkBJfwJ2DGMmUcOaTyA1F6LohyhAtRQIInMyX+IIJSCLTMAALcGC5I2kUM+lKD2HAI2+qAuKx
RQE4lgBvJVoGFGDgB67rSi4S38W/eEqX5KIbclQv5KXwSMrBHyoFAeCJ76jGynldSm8Ro8RPgA3o
OYLEZ47KWWQbnM3ALJM0kIwtcmPPjQFyCHTKmRs6YeqQMKG+QJ2n4VSk07FF0J0FDpoZV3mYBmkk
AiapcBLYypypSKcXyIAkQ2MHbvWThEdAJyKEEwG8WOQHU/1dK6W3SAqE1hchcWPqegxhYmHg0hjc
C+YXU0ySjvmIEZSNKxVqEk9wAJOb+mC2mIaphx4HUn6dDSYCjDf1rKlOd2bg2pF6l2e0m7fQu8/E
L0xg1Pio73xQI1G7Fg+H62ZcSGv7heQZun2xxa0ldNoWmAfXlhoAVnfagExa3X01M3bjgXmoLp5h
tmgwLigR+kV7J34xdzHfdcsgp1351aaXct+JfjjLUxfmLkyD79+r6aRuuKgw1y1HK9Q1Vya1FrTz
4Q2mMIIxjH9lWcu/lHWd0Xww/mGkw9/7P6zmV8JuejNHj1ajv5Q+4pesWXrmfoXgVoV2l3HoxXCo
F7Xj1eZimFv3am0pqcVmMNCtMSluMapuytpmxwq/mWTqX+AiJ6eNG87aIGFs/ObYlHv4gWG6PGEU
Lfhtb/bgpEDN9XvyGbHE8PwFriLKQXCeMu1Amp0Z5x9bpR+telcec66mWWJ8PZTWTebFcU9FZTU7
0lgYhHvBWpaagAvlXUti6u2VOhZcvyKsx5EjHi010i6fdxnbdbsLaK2OJow8a3G7WNlQ0njpUW2p
5AyOMXaiGh2QPGeYuek5EwRfIyNNgmuVixL+yCtB+OmsPvb4KAfqabfr7dqzCS2mabXU0qjQqrQO
0ScWrCx4bXzTqXEgSBTlVHhElVXWZAhd8TQ4zzARb+0vC6HPE8zZCDd6wallrnz44vmI0rI9bBCt
MH2WU5VH7CSMKqbOiLUXdU2ehDngOBfd46POl4pktbB+PNWN2H/4RfmrMIEoLNLgnjnZIFRBizJe
paAyxpx62F2G6p/PpN4aFIL9G2tx+Py0rURdHism6oVCGLX9vuTHXNTqlGQAoJePTU2g6jjyoHXb
cnVGEpVym3PRDOqy9dhFCXZlt74otDMGdEViw7OiapbOWm0yALkWqPud3g1Pd2h3zLdtA7PVwLxR
MkyAAOyXskYO0g9fQPj+pQ6Qhg5pH13vMBJtt8m1nJ81fr+Zv2ldtXrXyh6qMBbwV7Py27KQecaa
QRxgokFOBstluVzduw9DYhgmxX9KBPOfdufCmCiF5fvNTb3qy7wrb33K+akYc8GckWLRqGrrqwdw
ok72dPm0J3mqkI5FgSy3rb/kAsnTLb+Sp8pLVTmwScCWTkOZVXWzBmGoSllAwqnLCuvtzwPlF/aF
vE/Fp2L57bGqIA1IbwTcVBeUtgKhndNc2KR6qu+dh9fp7MWwfpchZzN6VBT7fdn8qQRwD3KI1PWs
LcR8/OZ6WKv3F5X+oF75Gk7RXFB+HtHpMHsNr75UxL83uapSR6aOWPW7FyhUFy05U4CVl8w0IBos
jQ1ZY86DdUPxX0qpBpDViX9Hqb/FqOqe2vWaTg3KP54ZcoIFS8N9HfUpCmHNkeRnI1pKGdNG94FC
BWahHjJrh3zMTdJ23enGGkDX25sanfZNrRrt+bAWLg68TeJD7pAplM+sN+OGsCZfBLTfoAE3FPD3
MiuWHWF0S424umJKnO6Kvwd3d420Qp/uddRd3dRLI3Z1p4rhmy9lphLoIIhix06dui+2EXqrS6ci
hyDljbrzUl4+jVap1lvFZfyuurDSfiZVsVR+fvv7XebzkBYrW3CuX8ryG50S6nOSpfgiCvUHzDlA
2dlO5AfV5X002TboNPpUQSui8l99krNUrpgB5dcWoGqmbu1RzoWAI/EK6lD1uQBd8awglmB4rWv9
9hDWNSjbs3ZLoHHb0Zx3hMq8y2Z7NlsCEcWd8rAWsydsp5orXgrDNTuEF0o0z2X1ud10bR0MYZS0
Ie2ncAopNErcAEwVisADTPfoegEknyuxrZxKtAQ0NMBe/Z5RRFKsr1JmALpX7ZPOsrWqpqvX0D/o
ZG0yNUe2bVIuxOGd+bG86LTG2dnBsKa6eq63uKAyXXItPtj4WR5Esbxa9rX1A1r82+cqawA+iDH8
q5trYPjntfog8FlFT3UArFJlCGhkZVUddXLk4kKYjvswPVTP3Qi9vsPE7mo/VJsauWGArcaP5Wqs
sUERbY3BivX8mc7hTjywtR1m6O5fwuinRsC7SwjABnd6F5aXtViuriCibu600OHzls060IKCufql
g63Zv3Mp/t4j05foQb6spxj7zLkfX/uIVHPsB3RL7aqOIF5qnS8+en6tbzajQo/VVxLPa14fJ/Rc
7lx3WeOhYTQz6Jip0hhMCqzc72GoPWoLu8Mb0o5f3dXGSLs4BxdoP6/eqLOVh5VO02exqHRaC0vR
+G+mirJU+fmCq5Ta1xyCRccC897nZW+WyGsxiMawF7e329Zb2621wQDo2I7tLv7jrv9/AfAaXNUU
TOsyF6jViUG46+NBJqZXv+rRK7Evv2i81ZEw33DQ8y6YowH05r+BuxfN92SX3RbVP8bNymDOGnY7
16PfvzG+4ecrzfzkjPZya/H/ScnXyqwX/JtSrrL5pbrryu1hPKFrZzsrJD6sUuyPwDGdKerJyxmq
dvmdHNCrrzU/+2W0pQ6gSvPl/Mertmi+7hBlDhB80kRUqcNeJCGapHNCz1cvCFwsf0A/Ne++jGMf
TuOJcm6+ZnP9TRR7tWjHreOhZ6huiKnPAP2zfmqpIqHHLG/emnNhyHxSs+JJYfIwj6t2AlLdVneO
3Is9u0R33ef+Wv2pVizPfbUW0rGhps1FRRfnZ/2xsnr3oT2Slh2tvngsLXu6M0OgIen7ufrjprrD
vzXQAgNE22ualqzbyAb97uvl6qF/2a5hcU+eBzVWzOdmVjA0PXQMQoAhsulmBv39oU13134SjSlb
dX85nKW3umfYbtu8713Sylhb2i3v2qaoc8C7S2P3pME8uIGedi1IxXbL+adi+P2fT8Xy/m+/PrxZ
/TrXDcpqOMjotwdo9AJmg8r1N7BySygc+Gp+XaYdJhpV8f/7Oy3Y1s330l09YBDTjnyjn5qHGF7x
6O7hZfMXz21OyLZB6lUfOGAGMzo/bjaL7VaV7Ha76D/1yJVEqKmr+L2nCbH7+959wDtv38JZplQG
BDaonX65d/fwEjNqlDjLVIvM9X+XVxF7
""")

##file distribute_setup.py
DISTRIBUTE_SETUP_PY = convert("""
eJztG2tz27jxu34FKo+HVELRdu768lQ3k0ucq+fSJBM7dx8SDw2RkMQzX8eHZd2v7+4CIEESkp1e
25nOVO05ErFYLPa9C/DoD8Wu3uTZZDqdfp/ndVWXvGBRDP/Gy6YWLM6qmicJr2MAmlyu2C5v2JZn
Natz1lSCVaJuijrPkwpgcbRkBQ/v+Fo4lRz0i53HfmmqGgDCpIkEqzdxNVnFCaKHH4CEpwJWLUVY
5+WObeN6w+LaYzyLGI8imoALImydFyxfyZU0/vPzyYTBZ1XmqUF9QOMsTou8rJHaoKOW4PuP3Nlo
h6X4tQGyGGdVIcJ4FYfsXpQVMANp6KZ6+B2gonybJTmPJmlclnnpsbwkLvGM8aQWZcaBpxqo27FH
i4YAFeWsytlyx6qmKJJdnK0nuGleFGVelDFOzwsUBvHj9na4g9tbfzK5RnYRf0NaGDEKVjbwvcKt
hGVc0PaUdInKYl3yyJSnj0oxUczLK/2t2rVf6zgV+vsqS3kdbtohkRZIQfubl/SzlVBTx6gycjTJ
15NJXe7OOylWMWqfHP50dfExuLq8vpiIh1AA6Zf0/AJZLKe0EGzB3uWZMLBpspslsDAUVSVVJRIr
FkjlD8I0cp/xcl3N5BT84E9A5sJ2ffEgwqbmy0R4M/achlq4EvhVZgZ6PwSOuoSNLRbsdLKX6CNQ
dGA+iAakGLEVSEESxF743/xbiTxivzZ5DcqEj5tUZDWwfgXLZ6CLHRg8QkwFmDsQkyL5DsB888Lp
ltRkIUKB25z1xxQeB/4Hxg3j42GDbc70uJo67BgBR3AKZjikNv25o4BYB1/UitXNUDp55VcFB6tz
4duH4OeXl9ceGzCNPTNl9vrizctPb6+Dny4+Xl2+fwfrTU/9P/lnf522Q58+vsXHm7ouzk9Oil0R
+1JUfl6uT5QTrE4qcFShOIlOOr90Mp1cXVx/+nD9/v3bq+DNyx8vXg8WCs/OphMT6MOPPwSX7968
x/Hp9MvkH6LmEa/5/Cfpjs7ZmX86eQd+9Nww4Uk7elxNrpo05WAV7AE+k7/nqZgXQCH9nrxsgPLS
/D4XKY8T+eRtHIqsUqCvhXQghBcfAEEgwX07mkwmpMbK17jgCZbw70zbgHiAmBOScpJ7l8M0WKcF
uEjYsvYmfnoX4Xfw1DgObsPf8jJznYsOCejAceV4arIEzJMo2EaACMS/FnW4jRSG1ksQFNjuBua4
5lSC4kSEdGF+Xois3UULE6h9qC32JvthklcCw0tnkOtcEYubbgNBCwD+RG4diCp4vfF/AXhFmIcP
E9Amg9bPpzez8UYklm6gY9i7fMu2eXlnckxDG1QqoWEYGuO4bAfZ61a3nZnpTrK87jkwR0dsWM5R
yJ2BB+kWuAIdhdAP+Lfgsti2zOFr1JRaV8zkxDcWHmARgqAFel6WgosGrWd8md8LPWkVZ4DHpgpS
c2ZaiZdNDA/Eeu3Cf55WVviSB8i6/+v0/4BOkwwpFmYMpGhB9H0LYSg2wnaCkPLuOLVPx+e/4t8l
+n5UG3o0x1/wpzQQPVEN5Q5kVNPaVYqqSeq+8sBSEljZoOa4eIClKxruVil5DCnq5XtKTVznVd4k
Ec0iTknbWa/RVpQVREC0ymFdlQ57bVYbLHkl9MaMx5FI+E6tiqwcqoGCd7owOT+u5sXuOPLh/8g7
ayIBn2PWUYFBXf2AiLPKQYcsD89uZk9njzILILjdi5Fx79n/PloHnz1c6vTqEYdDgJSzIfngD0VZ
u6ce6+Svst9+3WMk+Utd9ekAHVD6vSDTkPIe1Bhqx4tBijTgwMJIk6zckDtYoIo3pYUJi7M/eiCc
YMXvxOK6bETrXVNOJl41UJhtKXkmHeXLKk/QUJEXk24JQ9MABP91Te5teRVILgn0pk5xtw7ApChr
qyiJRf6medQkosJK6Uu7G6fjyhBw7Il7PwzR9NbrA0jl3PCK13Xp9gDBUILICLrWJBxnKw7as3Aa
6lfAQxDlHLrapYXYV9a0M2Xu/Xu8xX7m9ZjhqzLdnXYs+W4xfa5Wm1nIGu6ij0+lza/ybJXEYd1f
WoCWyNohJG/izsCfDAVnatWY9zgdQh1kJP62hELXHUFMr8mz07Yis+dg9Gbc7xbHULBArY+C5veQ
rlMl8yWbjvFhKyXkmVNjvalMHTBvN9gmoP6KagvAt7LJMLr47EMiQDxWfLp1wFmal0hqiCmaJnQV
l1XtgWkCGut0BxDvtMth80/GvhzfAv8l+5K5r5qyhFWSnUTMjssZIO/5f+FjFYeZw1iVpdDi2n3R
HxNJZbEP0EA2MDnDvj8P/MQNTsHITI2d/G5fMfs11vCkGLLPYqx63WYzsOq7vH6TN1n0u432UTJt
JI5SnUPuKghLwWsx9FYBbo4ssM2iMFwdiNK/N2bRxxK4VLxSXhjq4dddi681V4qrbSMRbC/JQypd
qM2pGB/XsnOXQSUvk8JbRfstqzaUmS2xHXnPk7iHXVte1qRLUYJFczLl1isQLmz/UdJLHZO2Dwla
QFMEu+3x45Zhj8MFHxFu9Ooii2TYxB4tZ86JM/PZreTJLa7Yy/3Bv4hS6BSy7XfpVUTkyz0SB9vp
ag/UYQ3zLKJeZ8Ex0C/FCt0NtjXDuuFJ13Gl/dVYSdW+FsN/JGHoxSISalNCFbykKCSwza36zWWC
ZdXEsEZrrDRQvLDNrde/BagO2PrpJcc+lmHr39ABKunLpnbZy1VRkOx5i0Xmf/xeAEv3pOAaVGWX
ZYjoYF+qtWpY6yBvlmhn58jzl/d5jFpdoOVGLTldhjMK6W3x0loP+fhq6uGW+i5bEqW45I6Gj9hH
waMTiq0MAwwkZ0A6W4LJ3XnYYd+iEmI0lK4FNDnMyxLcBVnfABnslrRa20uMZx21IHitwvqDTTlM
EMoQ9IFHg4xKspGIlszy2HS7nI6AVFqAyLqxkc9UkoC1LCkGEKBL9AE84LeEO1jUhO86pyRh2EtC
lqBkrCpBcNcVeK9l/uCumixEb6acIA2b49Re9dizZ3fb2YGsWDb/u/pETdeG8Vp7liv5/FDCPITF
nBkKaVuyjNTex7lsJY3a7Oan4FU1Ghiu5OM6IOjx83aRJ+BoYQHT/nkFHrtQ6YJF0hMSm27CGw4A
T87nh/P2y1DpjtaInugf1Wa1zJjuwwyyisCa1NkhTaU39VYpOlEVoG9w0Qw8cBfgAbK6C/k/U2zj
4V1TkLdYycRaZHJHENl1QCJvCb4tUDi0R0DEM9NrADfGsAu9dMehI/BxOG2nmWfpab3sQ5jtUrXr
Thu6WR8QGksBX0+AbBJjQ0DOgCiW+Zy5CTC0rWMLlsqtad7ZM8GVzQ+Rbk8MMcB6pncxRrRvwkNl
zTar0LSLG/Le4LFCNdqzRJCJrY7M+BSirOO/f/vaP67wSAtPR338M+rsfkR0MrhhIMllT1GSqHGq
Ji/WtvjTtY2qDeiHLbFpfg/JMphGYHbI3SLhodiAsgvdqR6E8bjCXuMYrE/9p+wOAmGv+Q6Jl9qD
MXe/fq2w7uj5H0xH9YUAoxFsJwWoVqfNvvrXxbme2Y95hh3DORYHQ3evFx95yyVI/85ky6pfHnUc
6DqklMKbh+bmugMGTEZaAHJCLRCJkEeyeVNj0oveY8t3nc3pOmeYsBns8ZhUfUX+QKJqvsGJzpkr
ywGygx6sdFW9CDKaJP2hmuExy3ml6mwrjo58e8cNMAU+dFEe61NjVaYjwLxliaidiqHit853yM9W
0RS/Uddcs4XnDZp/qoWPNxHwq8E9jeGQPBRM7zhs2GdWIINq1/Q2IyzjmG7TS3CqsnEPbNXEKk7s
aaM7V91FnshoEziDnfT98T5fM/TO++C0r+YrSKfbI2JcXzHFCGAI0t5YadvWrY10vMdyBTDgqRj4
/zQFIoJ8+YvbHTj6utddQEkIdZeMbI91GXrOTdL9NVN6LtckF1TSUkw95oYtwtbM0Y2FsQsiTu3u
iUdgcipSuU8+NZEVYbdRFYkNK1KHNlXnB2GBLz2dc/ddFfAkbV/h9AakjPyf5uXYAVo9jwQ/4HeG
PvwVyl9G8tGsLiVqHeThtMjqPglgf4okWVW3OdF+Vhky8mGCM0xKBlupNwZHu62ox49tpUeG0Skb
yuvx/T1mYkNP8wj4rJfPt0Gvy+mOVCiBCBTeoSrF+MuWX+9VUJkBX/zwwxxFiCEExCm/f4WCxqMU
9mCc3RcTnhpXDd/exdY9yT4Qn961fOs/OsiK2SOm/Sjn/is2ZbCiV3YobbFXHmpQ65fsU7YRbRTN
vpd9zL3hzHIypzBTszYoSrGKH1zt6bvg0gY5Cg3qUBLq73vjvN/YG/5WF+o04Gf9BaJkJB6MsPn8
7PymzaJo0NPX7kTWpKLk8kKe2TtBUHljVeZb83kJe5X3IOQmhgk6bAJw+LBmWVfYZkYlXmAYkXgs
jZk6L5RkaGaRxLXr4DoLZ/Z5PjidM1ig2WcupnANj4gkVVgaSiqsB64JaKa8Rfid5I+9h9Qjt/pM
kM8tVH4tpR2NwNymEqVDRwvd5Vh1VIhtXGvHxrZKO9tiGFIjR6o6VParkNOBonHuqK9H2mx378H4
oQ7VEdsKBywqBBIsQd7IbkEhjVs9US4kUyohUjxnMI9Hx10S+rlFc+mXCureEbJhvCEjDmFiCpO3
lY9ZW/9M3/8oz3sx2QavWIIz6pUn9sR9oC0U8xHDgty48riKc9e7Qoz4hq1K4yDp5YfLfzPhs64I
HCIEhewro3mby3y3wCxJZGFuF80Ri0Qt1K05DN54Et9GQNTUaJjDtsdwiyF5vh4a6rP5zoNR9Mil
Qbt1O8SyiuIFHSpIX4gKSb4wfiBiizK/jyMRydcf4pWCN1+0qIzmQ6Qu3KVed6ihO45mxdEPHDbK
7FJQ2ICh3pBgQCTPQmz3QMfaKm+EAy0bqD/21yi9NAysUsqxMq/rqS1ZNuGLLFJBg+6M7dlUNpe3
+Trh9ehA+97fR7NKVU9WpAEOm4e1NFWMC5/7SdqXMVlIOZxAKRLdffkn6ly/G/EVOejeJPRA83nA
m/68cfvZ1I326A7Nms6Xpfujs17D32diKNp+9v975Tmgl047M2E0zBPeZOGmS+G6J8NI+VGN9PaM
oY1tOLa28I0kCUEFv36jRUIVccFSXt7hWX7OOB3A8m7CsmmNp031zr+5wXThszMPzRvZlJ3hFZtE
zFULYC4e6P0lyJnnKc8gdkfOjRHiNMbTm7YfgE0zM8H83H/j4oY9b6dNNA66n2N9mablnnEpuRLJ
SjbOF1N/6rFU4MWBaoExpTuZURep6SBYQchjRroEUAK3JWvxZyivGOl7xHp/3YUG9Mn4rle+zbCq
TvMI3wqT/h+b/QRQiDKNq4pe0+qO7DSSGJSQGl4g86jy2S1uwGkvhuArWoB0JYiQ0TVqIFRxAL7C
ZLUjBz2xTE15QkSk+ModXRYBfhLJ1ADUeLDHrrQYNHa5Y2tRK1zurH+DQiVkYV7szN9QiEHGr24E
SobK6+QaQDG+uzZocgD04abNC7RYRvmAHsDYnKwmbfUBK5E/hIiiQHqVsxpW/e+BXzrShPXoURda
Kr4SKFUxONbvIH1eQAUauWqNvivTdC2IWz7+OQiI98mwb/Ptt3+h3CWMUxAfFU1A3+mfT0+NZCxZ
+Ur0GqdU/jan+CjQWgWrkPsmyabhmz099jfmvvDYtwaH0MZwvihdwHDmIZ4XM2u5EKYFwfjYJJCA
fnc6NWQbInUlZjtAKal3bUcPI0R3YrfQCujjcT+oL9LsIAHOzGMKm7w6rBkEmRtd9ABcrQW3Vouq
S+LAVG7IvIHSGeM9Iukc0NrW0ALvM2h0dk5SDjdAXCdjhXc2BmzofPEJgOEGdnYAUBUIpsX+C7de
pYri5AS4n0AVfDaugOlG8aC6tt1TIGRBtFy7oIRT5VrwTTa88CR0OEh5TDX3vcf2XPLrAsHloddd
SQUueLVTUNr5Hb7+r2L88OU2IC6m+y+YPAVUkQcBkhoE6l1KoruNmmfnN7PJPwERhOVk
""")

##file activate.sh
ACTIVATE_SH = convert("""
eJytVU1v4jAQPW9+xTT0ANVS1GsrDlRFAqmFqmG72m0rY5IJsRRslDiktNr/vuMQ8tFQpNU2B4I9
H36eeW/SglkgYvBFiLBKYg0LhCRGD1KhA7BjlUQuwkLIHne12HCNNpz5kVrBgsfBmdWCrUrA5VIq
DVEiQWjwRISuDreW5eE+CtodeLeAnhZEGKMGFXqAciMiJVcoNWx4JPgixDjzEj48QVeCfcqmtzfs
cfww+zG4ZfeD2ciGF7gCHaDMPM1jtvuHXAsPfF2rSGeOxV4iDY5GUGb3xVEYv2aj6WQ0vRseAlMY
G5DKsAawwnQUXt2LQOYlzZoYByqhonqoqfxZf4BLD97i4DukgXADCPgGgdOLTK5arYxZB1xnrc9T
EQFcHoZEAa1gSQioo/TPV5FZrDlxJA+NzwF+Ek1UonOzFnKZp6k5mgLBqSkuuAGXS4whJb5xz/xs
wXCHjiVerAk5eh9Kfz1wqOldtVv9dkbscfjgjKeTA8XPrtaNauX5rInOxaHuOReNtpFjo1/OxdFG
5eY9hJ3L3jqcPJbATggXAemDLZX0MNZRYjSDH7C1wMHQh73DyYfTu8a0F9v+6D8W6XNnF1GEIXW/
JrSKPOtnW1YFat9mrLJkzLbyIlTvYzV0RGXcaTBfVLx7jF2PJ2wyuBsydpm7VSVa4C4Zb6pFO2TR
huypCEPwuQjNftUrNl6GsYZzuFrrLdC9iJjQ3omAPBbcI2lsU77tUD43kw1NPZhTrnZWzuQKLomx
Rd4OXM1ByExVVkmoTwfBJ7Lt10Iq1Kgo23Bmd8Ib1KrGbsbO4Pp2yO4fpnf3s6MnZiwuiJuls1/L
Pu4yUCvhpA+vZaJvWWDTr0yFYYyVnHMqCEq+QniuYX225xmnzRENjbXACF3wkCYNVZ1mBwxoR9Iw
WAo3/36oSOTfgjwEEQKt15e9Xpqm52+oaXxszmnE9GLl65RH2OMmS6+u5acKxDmlPgj2eT5/gQOX
LLK0j1y0Uwbmn438VZkVpqlfNKa/YET/53j+99G8H8tUhr9ZSXs2
""")

##file activate.fish
ACTIVATE_FISH = convert("""
eJydVm1v4jgQ/s6vmA1wBxUE7X2stJVYlVWR2lK13d6d9laRk0yIr8HmbIe0++tvnIQQB9pbXT5A
Ys/LM55nZtyHx5RrSHiGsMm1gRAh1xhDwU0Kng8hFzMWGb5jBv2E69SDs0TJDdj3MxilxmzPZzP7
pVPMMl+q9bjXh1eZQ8SEkAZULoAbiLnCyGSvvV6SC7IoBcS4Nw0wjcFbvJDcjiuTswzFDpiIQaHJ
lQAjQUi1YRmUboC2uZJig8J4PaCnT5IaDcgsbm/CjinOwgx1KcUTMEhhTgV4g2B1fRk8Le8fv86v
g7v545UHpZB9rKnp+gXsMhxLunIIpwVQxP/l9c/Hq9Xt1epm4R27bva6AJqN92G4YhbMG2i+LB+u
grv71c3dY7B6WtzfLy9bePbp0taDTXSwJQJszUnnp0y57mvpPcrF7ZODyhswtd59+/jdgw+fwBNS
xLSscksUPIDqwwNmCez3PpxGeyBYg6HE0YdcWBxcKczYzuVJi5Wu915vn5oWePCCoPUZBN5B7IgV
MCi54ZDLG7TUZ0HweXkb3M5vFmSpFm/gthhBx0UrveoPpv9AJ9unIbQYdUoe21bKg2q48sPFGVwu
H+afrxd1qvclaNlRFyh1EQ2sSccEuNAGWQwysfVpz1tPajUqbqJUnEcIJkWo6OXDaodK8ZiLdbmM
L1wb+9H0D+pcyPSrX5u5kgWSygRYXCnJUi/KKcuU4cqsAyTKZBiissLc7NFwizvjxtieKBVCIdWz
fzilzPaYyljZN0cGN1v7NnaIPNCGmVy3GKuJaQ6iVjE1Qfm+36hglErwmnAD8hu0dDy4uICBA8ZV
pQr/q/+O0KFW2kjelu9Dgb9SDBsWV4F4x5CswgS0zBVlk5tDMP5bVtUGpslbm81Lu2sdKq7uNMGh
MVQ4fy9xhogC1lS5guhISa0DlBWv0O8odT6/LP+4WZzDV6FzIkEqC0uolGZSZoMnlpxplmD2euaT
O4hkTpPnbztDccey0bhjDaBIqaWQa0uwEtQEwtyU56i4fq54F9IE3ORR6mKriODM4XOYZwaVYLYz
7SPbKkz4i7VkB6/Ot1upDE3znNqYKpM8raa0Bx8vfvntJ32UENsM4aI6gJL+jJwhxhh3jVIDOcpi
m0r2hmEtS8XXXNBk71QCDXTBNhhPiHX2LtHkrVIlhoEshH/EZgdq53Eirqs5iFKMnkOmqZTtr3Xq
djvPTWZT4S3NT5aVLgurMPUWI07BRVYqkQrmtCKohNY8qu9EdACoT6ki0a66XxVF4f9AQ3W38yO5
mWmZmIIpnDFrbXakvKWeZhLwhvrbUH8fahhqD0YUcBDJjEBMQwiznE4y5QbHrbhHBOnUAYzb2tVN
jJa65e+eE2Ya30E2GurxUP8ssA6e/wOnvo3V78d3vTcvMB3n7l3iX1JXWqk=
""")

##file activate.csh
ACTIVATE_CSH = convert("""
eJx9U11vmzAUffevOCVRu+UB9pws29Kl0iq1aVWllaZlcgxciiViItsQdb9+xiQp+dh4QOB7Pu49
XHqY59IgkwVhVRmLmFAZSrGRNkdgykonhFiqSCRW1sJSmJg8wCDT5QrucRCyHn6WFRKhVGmhKwVp
kUpNiS3emup3TY6XIn7DVNQyJUwlrgthJD6n/iCNv72uhCzCpFx9CRkThRQGKe08cWXJ9db/yh/u
pvzl9mn+PLnjj5P5D1yM8QmXlzBkSdXwZ0H/BBc0mEo5FE5qI2jKhclHOOvy9HD/OO/6YO1mX9vx
sY0H/tPIV0dtqel0V7iZvWyNg8XFcBA0ToEqVeqOdNUEQFvN41SumAv32VtJrakQNSmLWmgp4oJM
yDoBHgoydtoEAs47r5wHHnUal5vbJ8oOI+9wI86vb2d8Nrm/4Xy4RZ8R85E4uTZPB5EZPnTaaAGu
E59J8BE2J8XgrkbLeXMlVoQxznEYFYY8uFFdxsKQRx90Giwx9vSueHP1YNaUSFG4vTaErNSYuBOF
lXiVyXa9Sy3JdClEyK1dD6Nos9mEf8iKlOpmqSNTZnYjNEWiUYn2pKNB3ttcLJ3HmYYXy6Un76f7
r8rRsC1TpTJj7f19m5sUf/V3Ir+x/yjtLu8KjLX/CmN/AcVGUUo=
""")

##file activate.bat
ACTIVATE_BAT = convert("""
eJyFUkEKgzAQvAfyhz0YaL9QEWpRqlSjWGspFPZQTevFHOr/adQaU1GaUzI7Mzu7ZF89XhKkEJS8
qxaKMMsvboQ+LxxE44VICSW1gEa2UFaibqoS0iyJ0xw2lIA6nX5AHCu1jpRsv5KRjknkac9VLVug
sX9mtzxIeJDE/mg4OGp47qoLo3NHX2jsMB3AiDht5hryAUOEifoTdCXbSh7V0My2NMq/Xbh5MEjU
ZT63gpgNT9lKOJ/CtHsvT99re3pX303kydn4HeyOeAg5cjf2EW1D6HOPkg9NGKhu
""")

##file deactivate.bat
DEACTIVATE_BAT = convert("""
eJxzSE3OyFfIT0vj4spMU0hJTcvMS01RiPf3cYkP8wwKCXX0iQ8I8vcNCFHQ4FIAguLUEgWIgK0q
FlWqXJpcICVYpGzx2BAZ4uHv5+Hv6wq1BWINXBTdKriEKkI1DhW2QAfhttcxxANiFZCBbglQSJUL
i2dASrm4rFz9XLgAwJNbyQ==
""")

##file distutils-init.py
DISTUTILS_INIT = convert("""
eJytV92L4zYQf/dfMU0ottuse7RvC6FQrg8Lxz2Ugz4si9HacqKuIxlJ2ST313dG8odkO9d7aGBB
luZLv/nNjFacOqUtKJMIvzK3cXlhWgp5MDBsqK5SNYftsBAGpLLA4F1oe2Ytl+9wUvW55TswCi4c
KibhbFDSglXQCFmDPXIwtm7FawLRbwtPzg2T9gf4gupKv4GS0N262w7V0NvpbCy8cvTo3eAus6C5
ETU3ICQZX1hFTw/dzR6V/AW1RCN4/XAtbsVXqIXmlVX6liS4lOzEYY9QFB2zx6LfoSNjz1a0pqT9
QOIfJWQ2E888NEVZNqLlZZnvIB0NpHkimlFdKn2iRRY7yGG/CCJb6Iz280d34SFXBS2yEYPNF0Q7
yM7oCjpWvbEDQmnhRwOs6zjThpKE8HogwRAgraqYFZgGZvzmzVh+mgz9vskT3hruwyjdFcqyENJw
bbMPO5jdzonxK68QKT7B57CMRRG5shRSWDTX3dI8LzRndZbnSWL1zfvriUmK4TcGWSnZiEPCrxXv
bM+sP7VW2is2WgWXCO3sAu3Rzysz3FiNCA8WPyM4gb1JAAmCiyTZbhFjWx3h9SzauuRXC9MFoVbc
yNTCm1QXOOIfIn/g1kGMhDUBN72hI5XCBQtIXQw8UEEdma6Jaz4vJIJ51Orc15hzzmu6TdFp3ogr
Aof0c98tsw1SiaiWotHffk3XYCkqdToxWRfTFXqgpg2khcLluOHMVC0zZhLKIomesfSreUNNgbXi
Ky9VRzwzkBneNoGQyyvGjbsFQqOZvpWIjqH281lJ/jireFgR3cPzSyTGWzQpDNIU+03Fs4XKLkhp
/n0uFnuF6VphB44b3uWRneSbBoMSioqE8oeF0JY+qTvYfEK+bPLYdoR4McfYQ7wMZj39q0kfP8q+
FfsymO0GzNlPh644Jje06ulqHpOEQqdJUfoidI2O4CWx4qOglLye6RrFQirpCRXvhoRqXH3sYdVJ
AItvc+VUsLO2v2hVAWrNIfVGtkG351cUMNncbh/WdowtSPtCdkzYFv6mwYc9o2Jt68ud6wectBr8
hYAulPSlgzH44YbV3ikjrulEaNJxt+/H3wZ7bXSXje/YY4tfVVrVmUstaDwwOBLMg6iduDB0lMVC
UyzYx7Ab4kjCqdViEJmDcdk/SKbgsjYXgfMznUWcrtS4z4fmJ/XOM1LPk/iIpqass5XwNbdnLb1Y
8h3ERXSWZI6rZJxKs1LBqVH65w0Oy4ra0CBYxEeuOMbDmV5GI6E0Ha/wgVTtkX0+OXvqsD02CKLf
XHbeft85D7tTCMYy2Njp4DJP7gWJr6paVWXZ1+/6YXLv/iE0M90FktiI7yFJD9e7SOLhEkkaMTUO
azq9i2woBNR0/0eoF1HFMf0H8ChxH/jgcB34GZIz3Qn4/vid+VEamQrOVqAPTrOfmD4MPdVh09tb
8dLLjvh/61lEP4yW5vJaH4vHcevG8agXvzPGoOhhXNncpTr99PTHx6e/UvffFLaxUSjuSeP286Dw
gtEMcW1xKr/he4/6IQ6FUXP+0gkioHY5iwC9Eyx3HKO7af0zPPe+XyLn7fAY78k4aiR387bCr5XT
5C4rFgwLGfMvJuAMew==
""")

##file distutils.cfg
DISTUTILS_CFG = convert("""
eJxNj00KwkAMhfc9xYNuxe4Ft57AjYiUtDO1wXSmNJnK3N5pdSEEAu8nH6lxHVlRhtDHMPATA4uH
xJ4EFmGbvfJiicSHFRzUSISMY6hq3GLCRLnIvSTnEefN0FIjw5tF0Hkk9Q5dRunBsVoyFi24aaLg
9FDOlL0FPGluf4QjcInLlxd6f6rqkgPu/5nHLg0cXCscXoozRrP51DRT3j9QNl99AP53T2Q=
""")

##file activate_this.py
ACTIVATE_THIS = convert("""
eJyNUlGL2zAMfvevEBlHEujSsXsL9GGDvW1jD3sZpQQ3Ua7aJXawnbT595Ocpe0dO5ghseVP+vRJ
VpIkn2cYPZknwAvWLXWYhRP5Sk4baKgOWRWNqtpdgTyH2Y5wpq5Tug406YAgKEzkwqg7NBPwR86a
Hk0olPopaK0NHJHzYQPnE5rI0o8+yBUwiBfyQcT8mMPJGiAT0A0O+b8BY4MKJ7zPcSSzHaKrSpJE
qeDmUgGvVbPCS41DgO+6xy/OWbfAThMn/OQ9ukDWRCSLiKzk1yrLjWapq6NnvHUoHXQ4bYPdrsVX
4lQMc/q6ZW975nmSK+oH6wL42a9H65U6aha342Mh0UVDzrD87C1bH73s16R5zsStkBZDp0NrXQ+7
HaRnMo8f06UBnljKoOtn/YT+LtdvSyaT/BtIv9KR60nF9f3qmuYKO4//T9ItJMsjPfgUHqKwCZ3n
xu/Lx8M/UvCLTxW7VULHxB1PRRbrYfvWNY5S8it008jOjcleaMqVBDnUXcWULV2YK9JEQ92OfC96
1Tv4ZicZZZ7GpuEpZbbeQ7DxquVx5hdqoyFSSmXwfC90f1Dc7hjFs/tK99I0fpkI8zSLy4tSy+sI
3vMWehjQNJmE5VePlZbL61nzX3S93ZcfDqznnkb9AZ3GWJU=
""")

if __name__ == '__main__':
    main()

## TODO:
## Copy python.exe.manifest
## Monkeypatch distutils.sysconfig

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

#
# OpenBlock documentation build configuration file, created by
# sphinx-quickstart on Mon Oct 25 10:49:32 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'OpenBlock'
copyright = u'2011 The OpenBlock Team, packages docs original copyright 2007-2009 Everyblock LLC; CC BY-SA 3.0 license'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#


# The full version, including alpha/beta/rc tags.
# OPENBLOCK NOTE:
# this can be populated by the openblock/misc/bin/make_release.sh script
release = '1.3dev'

# The short X.Y version.
# Automatically derived from release to make it easier to script releases.
import pkg_resources
version = []
for part in pkg_resources.parse_version(release):
    if part.startswith('*'):
        break
    version.append(part)
version = '.'.join(version)

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
#html_theme = 'default'
#html_theme = 'proBlue'
#html_theme_path = ['.']

html_theme = 'agogo'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
html_theme_options = {
    'textalign': 'left',
    'documentwidth': '650px',
    'sidebarwidth': '240px',
    'pagewidth': '900px',
}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%Y-%m-%d'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = False

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
# TODO, it's just not populated enough to be useful.
html_use_index = False

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'OpenBlockdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'OpenBlock.tex', u'OpenBlock Documentation',
   u'The OpenBlock Team', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'openblock', u'OpenBlock Documentation',
     [u'The OpenBlock Team'], 1)
]

# Handle Django model fields,
# from http://djangosnippets.org/snippets/2533/
THIS_DIR = os.path.dirname(__file__)
PROJECT_DIR = os.path.join(THIS_DIR, '..')
sys.path.append(PROJECT_DIR)

import inspect
#from django.conf import settings
from django.utils.html import strip_tags
from django.utils.encoding import force_unicode

def process_docstring(app, what, name, obj, options, lines):
    # This causes import errors if left outside the function
    from django.db import models

    # Only look at objects that inherit from Django's base model class
    if inspect.isclass(obj) and issubclass(obj, models.Model):
        # Grab the field list from the meta class
        fields = obj._meta._fields()
    
        for field in fields:
            # Decode and strip any html out of the field's help text
            help_text = strip_tags(force_unicode(field.help_text))
            
            # Decode and capitalize the verbose name, for use if there isn't
            # any help text
            verbose_name = force_unicode(field.verbose_name).capitalize()

            # Added by PW:
            # Remove the "_id" from ForeignKeys and the like,
            # since you typically use them without the _id.
            attname = field.attname
            typename = type(field).__name__
            if attname.endswith('_id') and typename in ('ForeignKey',
                                                        'OneToOneField',
                                                        'ManyToManyField'):
                attname = attname[:-3]

            if help_text:
                # Add the model field to the end of the docstring as a param
                # using the help text as the description
                lines.append(u':param %s: %s' % (attname, help_text))
            else:
                # Add the model field to the end of the docstring as a param
                # using the verbose name as the description
                lines.append(u':param %s: %s' % (attname, verbose_name))
                
            # Add the field's type to the docstring
            if not field.blank:
                from django.db.models.fields import NOT_PROVIDED
                if not isinstance(field.default, NOT_PROVIDED):
                    # TODO: display the default somehow?
                    typename += ', required'
            lines.append(u':type %s: %s' % (attname, typename))
    
    # Return the extended docstring
    return lines  
  
def setup(app):
    # Register the docstring processor with sphinx
    app.connect('autodoc-process-docstring', process_docstring)  

print "NOTE: ignore AttributeErrors on Django model fields."
print "They're harmless, and I can't figure out how to silence them."


########NEW FILE########
__FILENAME__ = auto_purge
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.blobs.models import Page, IgnoredDateline
from ebdata.nlp.datelines import guess_datelines
from ebpub.streets.models import Suburb
import re

def dateline_should_be_purged(dateline):
    dateline = dateline.upper()
    try:
        IgnoredDateline.objects.get(dateline=dateline)
        return True
    except IgnoredDateline.DoesNotExist:
        pass
    try:
        Suburb.objects.get(normalized_name=dateline)
        return True
    except Suburb.DoesNotExist:
        pass
    return False

def all_relevant_datelines():
    """
    Prints all datelines that are in articles but not in ignored_datelines,
    for all unharvested Pages in the system.
    """
    seen = {}
    for page in Page.objects.filter(has_addresses__isnull=True, is_pdf=False):
        for bit in page.mine_page():
            for dateline in guess_datelines(bit):
                dateline = dateline.upper()
                if dateline not in seen and not dateline_should_be_purged(dateline):
                    print dateline
                    seen[dateline] = 1

def page_should_be_purged(paragraph_list):
    """
    Returns a tuple of (purge, reason). purge is True if the given list of
    strings can be safely purged. reason is a string.
    """
    datelines = []
    for para in paragraph_list:
        datelines.extend(guess_datelines(para))
    if datelines:
        dateline_text = ', '.join([str(d) for d in datelines])
        if not [d for d in datelines if not dateline_should_be_purged(d)]:
            return (True, 'Dateline(s) %s safe to purge' % dateline_text)
        else:
            return (False, 'Dateline(s) %s found but not safe to purge' % dateline_text)
    return (False, 'No datelines')

########NEW FILE########
__FILENAME__ = create_seeds
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.blobs.models import Seed
from ebpub.db.models import Schema

def create_rss_seed(url, base_url, rss_full_entry, pretty_name, guess_article_text=True, strip_noise=False):
    if rss_full_entry:
        guess_article_text = strip_noise = False
    if 'www.' in base_url:
        normalize_www = 2
    else:
        normalize_www = 1
    Seed.objects.create(
        url=url,
        base_url=base_url,
        delay=3,
        depth=1,
        is_crawled=False,
        is_rss_feed=True,
        is_active=True,
        rss_full_entry=rss_full_entry,
        normalize_www=normalize_www,
        pretty_name=pretty_name,
        schema=Schema.objects.get(slug='news-articles'),
        autodetect_locations=True,
        guess_article_text=guess_article_text,
        strip_noise=strip_noise,
        city='',
    )

########NEW FILE########
__FILENAME__ = geotagging
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from ebdata.blobs.auto_purge import page_should_be_purged
from ebdata.blobs.models import Page
from ebdata.nlp.addresses import parse_addresses
from ebpub.db.models import NewsItem, SchemaField, Lookup
from ebpub.geocoder import SmartGeocoder, AmbiguousResult, DoesNotExist, InvalidBlockButValidStreet
from ebpub.geocoder.parser.parsing import normalize, ParsingError
from ebpub.streets.models import Suburb
from ebpub.utils.text import slugify, smart_excerpt
import datetime
import time


def save_locations_for_page(p):
    """
    Given a Page object, this function parses the text, finds all valid
    locations and creates a NewsItem for each location.
    """
    paragraph_list = p.auto_excerpt()
    do_purge, no_purge_reason = page_should_be_purged(paragraph_list)
    robot_report = [no_purge_reason]
    if do_purge:
        p.set_no_locations(geocoded_by='confidentrobot')
    else:
        if p.seed.autodetect_locations:
            if not p.article_headline:
                return
            if not p.article_date:
                return

            # Add a paragraph of the article's headline so that we find any/all
            # addresses in the headline, too.
            paragraph_list = [p.article_headline] + paragraph_list

            locations, location_report = auto_locations(paragraph_list, p.seed.city)
            if location_report:
                robot_report.append(location_report)

            if locations:
                # Check for existing NewsItems with this exact pub_date,
                # headline, location_name and source.
                do_geotag = True
                try:
                    source_schemafield = SchemaField.objects.get(schema__id=p.seed.schema_id, name='source')
                except SchemaField.DoesNotExist:
                    pass
                else:
                    existing_newsitems = NewsItem.objects.filter(schema__id=p.seed.schema_id,
                        pub_date=p.article_date, title=p.article_headline,
                        location_name=locations[0][0]).by_attribute(source_schemafield, p.seed.pretty_name, is_lookup=True).count()
                    if existing_newsitems:
                        robot_report.append('article appears to exist already')
                        do_geotag = False
                if do_geotag:
                    geotag_page(p.id, p.seed.pretty_name, p.seed.schema, p.url,
                        locations, p.article_headline, p.article_date)
            p.has_addresses = bool(locations)
            p.when_geocoded = datetime.datetime.now()
            p.geocoded_by = 'robot'
        p.robot_report = '; '.join(robot_report)[:255]
    p.save()

def geotag_page(page_id, source, schema, url, data_tuples, article_headline, article_date):
    """
    Given a Page ID and a list of (location, wkt, excerpt, block) tuples
    representing the addresses in the page, creates a NewsItem for each
    address. Returns a list of all created NewsItems.
    """
    if not data_tuples:
        return
    if not source:
        raise ValueError('Provide a source')
    if not url:
        raise ValueError('Provide a URL')
    if not article_headline:
        raise ValueError('Provide an article headline')
    if not article_date:
        raise ValueError('Provide an article date')
    if not isinstance(article_date, datetime.date):
        article_date = datetime.date(*time.strptime(article_date, '%Y-%m-%d')[:3])

    # If this schema has a "source" SchemaField, then get or create it.
    try:
        sf = SchemaField.objects.get(schema__id=schema.id, name='source')
    except SchemaField.DoesNotExist:
        source = None
    else:
        try:
            source = Lookup.objects.get(schema_field__id=sf.id, code=source)
        except Lookup.DoesNotExist:
            source = Lookup.objects.create(
                schema_field_id=sf.id,
                name=source,
                code=source,
                slug=slugify(source)[:32],
                description=''
            )
    ni_list = []
    for location, wkt, excerpt, block in data_tuples:
        description = excerpt = excerpt.replace('\n', ' ')
        if source is not None:
            # u'\u2014' is an em dash.
            description = u'%s \u2014 %s' % (source.name, description)
        ni = NewsItem.objects.create(
            schema=schema,
            title=article_headline,
            description=description,
            url=url,
            pub_date=article_date,
            item_date=article_date,
            location=wkt,
            location_name=location,
            block=block,
        )
        atts = {'page_id': page_id, 'excerpt': excerpt}
        if source is not None:
            atts['source'] = source.id
        ni.attributes = atts
        ni_list.append(ni)
    return ni_list

def auto_locations(paragraph_list, default_city=''):
    """
    Given a list of strings, detects all valid, unique addresses and returns a
    tuple (result, report), where result is a list of tuples in the format
    (address, wkt, excerpt, block) and report is a string of what happened.

    If default_city is given, it will be used in the geocoding for detected
    addresses that don't specify a city.
    """
    result, report = [], []
    addresses_seen = set()
    geocoder = SmartGeocoder()
    for para in paragraph_list:
        for addy, city in parse_addresses(para):
            # Skip addresses if they have a city that's a known suburb.
            if city and Suburb.objects.filter(normalized_name=normalize(city)).count():
                report.append('got suburb "%s, %s"' % (addy, city))
                continue

            # Try geocoding the address. If a city was provided, first try
            # geocoding with the city, then fall back to just the address
            # (without the city).
            point = None
            attempts = [addy]
            if default_city:
                attempts.insert(0, '%s, %s' % (addy, default_city))
            if city and city.lower() != default_city.lower():
                attempts.insert(0, '%s, %s' % (addy, city))
            for attempt in attempts:
                try:
                    point = geocoder.geocode(attempt)
                    break
                except AmbiguousResult:
                    report.append('got ambiguous address "%s"' % attempt)
                    # Don't try any other address attempts, because they only
                    # get *more* ambiguous. Plus, the subsequent attempts could
                    # be incorrect. For example, with this:
                    #    addy = '100 Broadway'
                    #    city = 'Manhattan'
                    #    default_city = 'Brooklyn'
                    # There are multiple "100 Broadway" addresses in Manhattan,
                    # so geocoding should fail at this point. It should not
                    # roll back to try the default_city (Brooklyn).
                    break
                except (DoesNotExist, InvalidBlockButValidStreet):
                    report.append('got nonexistent address "%s"' % attempt)
                except ParsingError:
                    report.append('got parsing error "%s"' % attempt)
            if point is None:
                continue # This address could not be geocoded.

            if point['address'] in addresses_seen:
                continue
            if len(para) > 300:
                try:
                    excerpt = smart_excerpt(para, addy)
                except ValueError:
                    excerpt = para
            else:
                excerpt = para
            result.append((addy, point['point'], excerpt, point['block']))
            addresses_seen.add(point['address'])
    return (result, '; '.join(report))

def save_locations_for_ungeocoded_pages():
    for p in Page.objects.filter(when_geocoded__isnull=True).iterator():
        save_locations_for_page(p)

if __name__ == "__main__":
    from ebdata.retrieval import log_debug
    save_locations_for_ungeocoded_pages()

########NEW FILE########
__FILENAME__ = manual
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Helper functions for manually adding news article NewsItems.
"""

from ebdata.blobs.models import Seed, Page
from ebdata.retrieval import UnicodeRetriever
from ebpub.db.models import Schema
from ebpub.geocoder import SmartGeocoder
from geotagging import geotag_page # relative import
import datetime

def add_newsitem(seed_url, seed_name, url, article_headline, article_date, name_excerpts):
    schema = Schema.objects.get(slug='news-articles')
    geocoder = SmartGeocoder()
    try:
        s = Seed.objects.get(url=seed_url)
    except Seed.DoesNotExist:
        s = Seed.objects.create(
            url=seed_url,
            base_url=seed_url,
            delay=0,
            depth=0,
            is_crawled=False,
            is_rss_feed=False,
            is_active='t',
            rss_full_entry=False,
            normalize_www=3,
            pretty_name=seed_name,
            schema=schema,
            autodetect_locations=True,
            guess_article_text=False,
            strip_noise=False,
            city='',
        )
    try:
        p = Page.objects.get(url=url)
    except Page.DoesNotExist:
        html = UnicodeRetriever().fetch_data(url)
        p = Page.objects.create(
            seed=s,
            url=url,
            scraped_url=url,
            html=html,
            when_crawled=datetime.datetime.now(),
            is_article=True,
            is_pdf=False,
            is_printer_friendly=False,
            article_headline=article_headline,
            article_date=article_date,
            has_addresses=None,
            when_geocoded=None,
            geocoded_by='',
            times_skipped=0,
            robot_report=''
        )
    data_tuples = []
    for location_name, excerpt in name_excerpts:
        point = geocoder.geocode(location_name) # Let exceptions bubble up.
        data_tuples.append((location_name, point['point'], excerpt, point['block']))
    return geotag_page(p.id, seed_name, schema, url, data_tuples, article_headline, article_date)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    depends_on = (
            ("db", "0001_initial"),
            ("streets", "0001_initial")
        )

    def forwards(self, orm):

        # Adding model 'Seed'
        db.create_table('blobs_seed', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('url', self.gf('django.db.models.fields.CharField')(max_length=512)),
            ('base_url', self.gf('django.db.models.fields.CharField')(max_length=512)),
            ('delay', self.gf('django.db.models.fields.SmallIntegerField')()),
            ('depth', self.gf('django.db.models.fields.SmallIntegerField')()),
            ('is_crawled', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('is_rss_feed', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('is_active', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('rss_full_entry', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('normalize_www', self.gf('django.db.models.fields.SmallIntegerField')()),
            ('pretty_name', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('schema', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Schema'])),
            ('autodetect_locations', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('guess_article_text', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('strip_noise', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('city', self.gf('django.db.models.fields.CharField')(max_length=64, blank=True)),
        ))
        db.send_create_signal('blobs', ['Seed'])

        # Adding model 'Page'
        db.create_table('blobs_page', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('seed', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['blobs.Seed'])),
            ('url', self.gf('django.db.models.fields.CharField')(max_length=512, db_index=True)),
            ('scraped_url', self.gf('django.db.models.fields.CharField')(max_length=512)),
            ('html', self.gf('django.db.models.fields.TextField')()),
            ('when_crawled', self.gf('django.db.models.fields.DateTimeField')()),
            ('is_article', self.gf('django.db.models.fields.NullBooleanField')(null=True, blank=True)),
            ('is_pdf', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('is_printer_friendly', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('article_headline', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
            ('article_date', self.gf('django.db.models.fields.DateField')(null=True, blank=True)),
            ('has_addresses', self.gf('django.db.models.fields.NullBooleanField')(null=True, blank=True)),
            ('when_geocoded', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('geocoded_by', self.gf('django.db.models.fields.CharField')(max_length=32, blank=True)),
            ('times_skipped', self.gf('django.db.models.fields.SmallIntegerField')()),
            ('robot_report', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
        ))
        db.send_create_signal('blobs', ['Page'])

        # Adding model 'IgnoredDateline'
        db.create_table('blobs_ignoreddateline', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('dateline', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
        ))
        db.send_create_signal('blobs', ['IgnoredDateline'])


    def backwards(self, orm):
        
        # Deleting model 'Seed'
        db.delete_table('blobs_seed')

        # Deleting model 'Page'
        db.delete_table('blobs_page')

        # Deleting model 'IgnoredDateline'
        db.delete_table('blobs_ignoreddateline')


    models = {
        'blobs.ignoreddateline': {
            'Meta': {'object_name': 'IgnoredDateline'},
            'dateline': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'blobs.page': {
            'Meta': {'object_name': 'Page'},
            'article_date': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'article_headline': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'geocoded_by': ('django.db.models.fields.CharField', [], {'max_length': '32', 'blank': 'True'}),
            'has_addresses': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'html': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_article': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'is_pdf': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_printer_friendly': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'robot_report': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'scraped_url': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'seed': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['blobs.Seed']"}),
            'times_skipped': ('django.db.models.fields.SmallIntegerField', [], {}),
            'url': ('django.db.models.fields.CharField', [], {'max_length': '512', 'db_index': 'True'}),
            'when_crawled': ('django.db.models.fields.DateTimeField', [], {}),
            'when_geocoded': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'})
        },
        'blobs.seed': {
            'Meta': {'object_name': 'Seed'},
            'autodetect_locations': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'base_url': ('django.db.models.fields.CharField', [], {'max_length': '512'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '64', 'blank': 'True'}),
            'delay': ('django.db.models.fields.SmallIntegerField', [], {}),
            'depth': ('django.db.models.fields.SmallIntegerField', [], {}),
            'guess_article_text': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_crawled': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_rss_feed': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'normalize_www': ('django.db.models.fields.SmallIntegerField', [], {}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'rss_full_entry': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'strip_noise': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'url': ('django.db.models.fields.CharField', [], {'max_length': '512'})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        }
    }

    complete_apps = ['blobs']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebpub.db.models import Schema
from django.db import models
import datetime

class Seed(models.Model):
    url = models.CharField(max_length=512)
    base_url = models.CharField(max_length=512) # e.g., 'http://www.suntimes.com/'
    delay = models.SmallIntegerField()
    depth = models.SmallIntegerField()
    is_crawled = models.BooleanField()
    is_rss_feed = models.BooleanField()
    is_active = models.BooleanField()
    rss_full_entry = models.BooleanField() # If True, then an RSS <entry> contains the whole article.
    normalize_www = models.SmallIntegerField() # 1 = Remove www, 2 = Add www, 3 = Ignore subdomain
    pretty_name = models.CharField(max_length=128) # e.g., 'Chicago Sun-Times'
    schema = models.ForeignKey(Schema) # news-articles, missed-connections, etc.

    # If True, then Pages from this Seed will be automatically address-detected.
    autodetect_locations = models.BooleanField()

    # If True, then robot will use templatemaker.articletext.article_text() to
    # determine Page excerpts.
    guess_article_text = models.BooleanField()

    # If True, then robot will use templatemaker.clean.strip_template() to
    # determine Page excerpts.
    strip_noise = models.BooleanField()

    # An uppercase string of the city that this seed covers -- e.g., 'BROOKLYN'.
    # If given, this city will be used to disambiguate addresses in automatic
    # geocoding.
    city = models.CharField(max_length=64, blank=True)

    def __unicode__(self):
        return self.url

class PageManager(models.Manager):
    def increment_skip(self, page_id):
        # Use this to increment the 'times_skipped' column atomically.
        # I.e., it's better to use this than to call save() on Page objects,
        # because that introduces the possibility of clashes.
        from django.db import connection
        cursor = connection.cursor()
        cursor.execute("UPDATE %s SET times_skipped = times_skipped + 1 WHERE id = %%s" % Page._meta.db_table, (page_id,))
        connection._commit()

    def next_ungeocoded(self, seed_id):
        "Returns the next ungeocoded Page for the given seed_id."
        try:
            return self.select_related().filter(has_addresses__isnull=True, is_article=True, seed__id=seed_id).order_by('times_skipped', 'when_crawled')[0]
        except IndexError:
            raise self.model.DoesNotExist

class Page(models.Model):
    seed = models.ForeignKey(Seed)

    # The publicly displayed URL for this page.
    url = models.CharField(max_length=512, db_index=True)

    # The URL that we actually scraped for this page (possibly a
    # printer-friendly version).
    scraped_url = models.CharField(max_length=512)

    html = models.TextField()
    when_crawled = models.DateTimeField()

    # Whether this page is an "article," as opposed to some sort of index page.
    is_article = models.NullBooleanField()

    # Whether this page is the extracted text of a PDF.
    is_pdf = models.BooleanField()

    # Whether this page is the printer-friendly version.
    is_printer_friendly = models.BooleanField()

    article_headline = models.CharField(max_length=255, blank=True)
    article_date = models.DateField(blank=True, null=True)

    # True = addresses were found
    # False = addresses were not found
    # None = page has not yet been examined
    has_addresses = models.NullBooleanField()

    when_geocoded = models.DateTimeField(blank=True, null=True)
    geocoded_by = models.CharField(max_length=32, blank=True)

    # The number of times this page has been "skipped" in the blob geocoder.
    times_skipped = models.SmallIntegerField()

    robot_report = models.CharField(max_length=255, blank=True)

    objects = PageManager()

    def __unicode__(self):
        return u'%s scraped %s' % (self.url, self.when_crawled)

    def set_no_locations(self, geocoded_by='robot'):
        """
        Marks this Page as geocoded with no locations. Does NOT save it.
        """
        self.has_addresses = False
        self.when_geocoded = datetime.datetime.now()
        self.geocoded_by = geocoded_by
    set_no_locations.alters_data = True

    def mine_page(self):
        """
        Runs templatemaker on this Page and returns the raw mined content, as
        a list of strings.
        """
        from ebdata.templatemaker.webmining import mine_page
        try:
            other_page = self.companion_page()
        except IndexError:
            return [self.html]
        return mine_page(self.html, [other_page.html])

    def auto_excerpt(self):
        """
        Attempts to detect the text of this page (ignoring all navigation and
        other clutter), returning a list of strings. Each string represents a
        paragraph.
        """
        from ebdata.textmining.treeutils import make_tree
        tree = make_tree(self.html)
        if self.seed.rss_full_entry:
            from ebdata.templatemaker.textlist import html_to_paragraph_list
            paras = html_to_paragraph_list(tree)
        else:
            if self.seed.strip_noise:
                from ebdata.templatemaker.clean import strip_template
                try:
                    html2 = self.companion_page().html
                except IndexError:
                    pass
                else:
                    tree2 = make_tree(html2)
                    strip_template(tree, tree2)
            if self.seed.guess_article_text:
                from ebdata.templatemaker.articletext import article_text
                paras = article_text(tree)
            else:
                from ebdata.templatemaker.textlist import html_to_paragraph_list
                paras = html_to_paragraph_list(tree)
        return paras

    def companion_page(self):
        """
        Returns another Page for self.seed, for use in a templatemaker
        duplicate-detection algorithm. Raises IndexError if none exist.
        """
        # To avoid the problem of site redesigns affecting the layout, get an
        # example page that was crawled *just before* the current Page.
        try:
            return Page.objects.filter(seed__id=self.seed_id, is_article=True,
                when_crawled__lt=self.when_crawled, is_pdf=False).order_by('-when_crawled')[0]
        except IndexError:
            # If no pages were crawled directly before this one, then get the page
            # that was crawled directly *after* this one.
            return Page.objects.filter(seed__id=self.seed_id, is_article=True,
                when_crawled__gt=self.when_crawled, is_pdf=False).order_by('when_crawled')[0]

    def newsitems(self):
        """
        Returns a list of {excerpt, location_name} dictionaries for every
        location found in this Page, or an empty list if it has no addresses.
        """
        from ebpub.db.models import Attribute, SchemaField
        if not self.has_addresses:
            return []
        # First, figure out the SchemaFields.
        real_names = dict([(sf.name, sf.real_name.encode('utf8')) for sf in SchemaField.objects.filter(schema__id=self.seed.schema_id, name__in=('excerpt', 'page_id'))])
        return [{'id': att.news_item_id, 'url': att.news_item.item_url_with_domain(), 'excerpt': getattr(att, real_names['excerpt']), 'location_name': att.news_item.location_name} \
            for att in Attribute.objects.select_related().filter(**{real_names['page_id']: self.id, 'schema__id': self.seed.schema_id})]

# Datelines that should be ignored by the blob updater.
class IgnoredDateline(models.Model):
    dateline = models.CharField(max_length=255, unique=True)

    def __unicode__(self):
        return self.dateline

########NEW FILE########
__FILENAME__ = scrapers
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Generic scrapers that create Pages based on some common Web site patterns.
"""

from django.conf import settings
from django.utils.html import strip_tags
from ebdata.blobs.geotagging import save_locations_for_page
from ebdata.blobs.models import Seed, Page
from ebdata.retrieval import UnicodeRetriever, RetrievalError
from ebdata.retrieval import log # Register the logging hooks.
from ebpub.utils.dates import parse_date
import datetime
import logging

class NoPagesYet(Exception):
    pass

class NoSeedYet(Exception):
    pass

class SpecializedCrawler(object):
    """
    Base class for Page crawlers.
    """

    schema = None
    seed_url = None
    date_headline_re = None
    date_format = None
    retriever = None

    def __init__(self):
        try:
            self.seed = Seed.objects.get(url=self.seed_url)
        except Seed.DoesNotExist:
            raise NoSeedYet('You need to add a Seed with the URL %r' % self.seed_url)
        self.logger = logging.getLogger('eb.retrieval.%s.%s' % (settings.SHORT_NAME, self.schema))
        if self.retriever is None:
            self.retriever = UnicodeRetriever(cache=None, sleep=self.seed.delay)

    def save_page(self, unique_id):
        """
        Downloads the page with the given unique ID (possibly a numeric ID, or
        a URL) and saves it as a Page object. Returns the Page object, or None
        if the page couldn't be found.

        The page won't be retrieved/saved if it's already in the database. In
        this case, the existing Page object will be returned.
        """
        self.logger.debug('save_page(%s)', unique_id)
        retrieval_url = self.retrieval_url(unique_id)
        public_url = self.public_url(unique_id)

        try:
            p = Page.objects.get(seed__id=self.seed.id, url=public_url)
        except Page.DoesNotExist:
            pass
        else:
            self.logger.debug('Skipping already-saved URL %s', public_url)
            return p

        try:
            html = self.retriever.fetch_data(retrieval_url).strip()
        except (RetrievalError, UnicodeDecodeError):
            return None
        if not html:
            self.logger.debug('Got empty page for %s', retrieval_url)
            return None
        self.logger.debug('Got VALID page for %s', retrieval_url)

        m = self.date_headline_re.search(html)
        if not m:
            self.logger.debug('Could not find date/headline on %s', retrieval_url)
            return None
        article_date, article_headline = m.groupdict()['article_date'], m.groupdict()['article_headline']
        try:
            article_date = parse_date(article_date, self.date_format)
        except ValueError:
            self.logger.debug('Got unparseable date %r on %s', article_date, retrieval_url)
            return None
        article_headline = strip_tags(article_headline)
        if len(article_headline) > 255:
            article_headline = article_headline[:252] + '...'

        p = Page.objects.create(
            seed=self.seed,
            url=public_url,
            scraped_url=retrieval_url,
            html=html,
            when_crawled=datetime.datetime.now(),
            is_article=True,
            is_pdf=False,
            is_printer_friendly=False,
            article_headline=article_headline,
            article_date=article_date,
            has_addresses=None,
            when_geocoded=None,
            geocoded_by='',
            times_skipped=0,
            robot_report='',
        )
        self.logger.debug('Created Page ID %s' % p.id)
        save_locations_for_page(p)
        return p

    ######################################
    # METHODS SUBCLASSES SHOULD OVERRIDE #
    ######################################

    def public_url(self, unique_id):
        "Given the ID value, returns the URL that we should publish."
        raise NotImplementedError()

    def retrieval_url(self, unique_id):
        "Given the ID value, returns the URL that we should scrape."
        return self.public_url(unique_id)

class IncrementalCrawler(SpecializedCrawler):
    """
    Crawler that populates the blobs.Page table by incrementing IDs.

    This is a very "dumb" but effective technique for crawling sites such
    as cityofchicago.org whose pages have incremental ID numbers.

    LIMITATIONS/ASSUMPTIONS:

    * This assumes that the URL for each retrieved page is in the same format,
      such that ordering by the URL will result in the highest ID.
    * This assumes that a Seed exists with url=self.seed_url.
    * Before running update(), at least one Page with the given seed must
      exist. Otherwise the retriever won't know what the latest page is!
    """

    max_blanks = 10

    ##################################################
    # METHODS SUBCLASSES SHOULD NOT HAVE TO OVERRIDE #
    ##################################################

    def max_id(self):
        "Returns the ID of the latest page we've already crawled."
        try:
            latest_page = Page.objects.filter(seed__id=self.seed.id).order_by('-url')[0]
        except IndexError:
            raise NoPagesYet('Seed ID %s has no pages yet' % self.seed.id)
        return int(self.id_for_url(latest_page.url))

    def update(self):
        """
        Determines the ID of the latest page we've already crawled, and crawls
        until self.max_blanks blank pages are reached.
        """
        current_id = self.max_id()
        num_blanks = 0
        while num_blanks < self.max_blanks:
            current_id += 1
            page = self.save_page(current_id)
            if page:
                num_blanks = 0
            else:
                num_blanks += 1

    def save_id_range(self, first_id, last_id):
        """
        Downloads and saves Pages for the given ID range, inclusive. Pages
        won't be saved if they're already in the database.
        """
        for id_value in range(int(first_id), int(last_id)+1):
            self.save_page(id_value)

    ######################################
    # METHODS SUBCLASSES SHOULD OVERRIDE #
    ######################################

    def id_for_url(self, url):
        "Given a URL, returns its ID value. This can be either a string or int."
        raise NotImplementedError()

class PageAreaCrawler(SpecializedCrawler):
    """
    Crawler that finds specific links on a given index page (seed_url)
    and creates a blobs.Page for each link that hasn't yet been created.
    """

    ##################################################
    # METHODS SUBCLASSES SHOULD NOT HAVE TO OVERRIDE #
    ##################################################

    def update(self):
        seed_html = self.retriever.fetch_data(self.seed_url)
        for url in self.get_links(seed_html):
            self.save_page(url)

    def public_url(self, unique_id):
        return unique_id

    ######################################
    # METHODS SUBCLASSES SHOULD OVERRIDE #
    ######################################

    def get_links(self, html):
        """
        Given the seed HTML, returns the list of links.
        """
        raise NotImplementedError()

########NEW FILE########
__FILENAME__ = update_feeds
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
RSS-feed retriever
"""

# The normalize_url() function is derived from code that is subject to this
# license:
# Copyright (c) 1999-2002 Mark Nottingham <mnot@pobox.com>
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from ebdata.blobs.geotagging import save_locations_for_page
from ebdata.blobs.models import Seed, Page
from ebdata.retrieval import UnicodeRetriever
from ebdata.retrieval import log # Register the logging hooks.
from ebdata.templatemaker.htmlutils import printer_friendly_link
from ebdata.textmining.treeutils import make_tree
from ebpub.utils.dates import parse_date
import feedparser
import cgi
import datetime
import logging
import re
import time
import urllib
import urlparse

strip_tags = lambda x: re.sub(r'<[^>]*>', ' ', x).replace('&nbsp;', ' ')
server_authority_re = re.compile('^(?:([^\@]+)\@)?([^\:]+)(?:\:(.+))?$')
url_collapse_re = re.compile('([^/]+/\.\./?|/\./|//|/\.$|/\.\.$)')

def remove_query_string(url):
    bits = urlparse.urlparse(url)
    return urlparse.urlunparse(bits[:4] + ('',) + bits[5:])

def add_query_string(url, new_values):
    bits = urlparse.urlparse(url)
    qs = cgi.parse_qs(bits[4], keep_blank_values=True)
    qs.update(new_values)
    return urlparse.urlunparse(bits[:4] + (urllib.urlencode(qs, doseq=True),) + bits[5:])

def normalize_url(base_href, url, normalize_www_flag):
    """
    Normalizes the given URL:

    * Joins it with base_href if it doesn't already have a domain.
    * Lowercases the scheme (WWW.GOOGLE.COM -> www.google.com).
    * Removes the port (80 or 443) if it's default.
    * Collapses '../' and './'.
    * Alphabetizes the query string by its keys.
    * If it ends in '/index.html', removes the 'index.html'.
    * Normalizes the 'www.' subdomain according to normalize_www_flag.

    Returns None if the URL is invalid.

    ``normalize_www_flag`` should be either 1, 2 or 3:

    * 1 = Remove the 'www.' subdomain, if it exists.
    * 2 = Add a 'www.' subdomain, if a subdomain doesn't exist.
    * 3 = Don't touch the subdomain.

    """
    # Derived from code at http://www.mnot.net/python/urlnorm.py
    # See copyright at top of this file.
    url = urlparse.urljoin(base_href, url)
    scheme, authority, path, parameters, query, fragment = urlparse.urlparse(url)
    scheme = scheme.lower()
    if '.' not in authority:
        return None
    if authority:
        userinfo, host, port = server_authority_re.match(authority).groups()
        if host[-1] == '.':
            host = host[:-1]

        # Normalize the www subdomain, if necessary.
        if normalize_www_flag == 1 and host.startswith('www.'):
            host = host[4:]
        elif normalize_www_flag == 2 and host.count('.') == 1:
            host = 'www.' + host

        authority = host.lower()
        if userinfo:
            authority = "%s@%s" % (userinfo, authority)
        if port and port != {'http': '80', 'https': '443'}.get(scheme):
            authority = "%s:%s" % (authority, port)

    if scheme.startswith('http'):
        last_path = path
        while 1:
            path = url_collapse_re.sub('/', path, 1)
            if last_path == path:
                break
            last_path = path
    if not path:
        path = '/'
    if path.endswith('/index.html'):
        path = path[:-10] # Trim trailing "index.html".
    if query:
        # Reorder the query string to alphabetize the keys.
        query_bits = sorted(cgi.parse_qsl(query, keep_blank_values=True))
        query = '&'.join(['%s=%s' % (k, v) for k, v in query_bits])
    return urlparse.urlunparse((scheme, authority, path, parameters, query, ''))


class FeedUpdater(object):
    def __init__(self, seed, retriever, logger):
        self.seed = seed
        self.retriever = retriever
        self.logger = logger

    def update(self):
        try:
            feed = feedparser.parse(self.seed.url)
        except UnicodeDecodeError:
            self.logger.info('UnicodeDecodeError on %r', self.seed.url)
            return
        for entry in feed['entries']:
            if 'feedburner_origlink' in entry:
                url = entry['feedburner_origlink']
            elif 'pheedo_origLink' in entry:
                url = entry['pheedo_origLink']
            elif 'link' in entry:
                url = entry['link']
            else:
                continue # Skip entries with no link.

            try:
                url = normalize_url(self.seed.base_url, url, self.seed.normalize_www)
            except Exception:
                self.logger.warn('Problem normalizing URL: %r, %r, %r', self.seed.base_url, url, self.seed.normalize_www)
                continue

            if not url:
                self.logger.info('Skipping article with empty URL: %r, %r', self.seed.base_url, url)
                continue

            if len(url) > 512:
                self.logger.warning('Skipping long URL %s', url)
                continue

            article_date = entry.get('updated_parsed') and datetime.date(*entry['updated_parsed'][:3]) or None
            if article_date and article_date > datetime.date.today():
                # Skip articles in the future, because sometimes articles show
                # up in the feed before they show up on the site, and we don't
                # want to retrieve the article until it actually exists.
                self.logger.info('Skipping article_date %s, which is in the future', article_date)
                continue

            url = self.normalize_url(url)

            try:
                title = entry['title']
            except KeyError:
                self.logger.debug('Skipping %s due to missing title', url)
                continue

            if not self.download_page(url, title):
                self.logger.debug('Skipping %s due to download_page()', url)
                continue

            # If we've already retrieved the page, there's no need to retrieve
            # it again.
            try:
                Page.objects.filter(url=url)[0]
            except IndexError:
                pass
            else:
                self.logger.debug('URL %s has already been retrieved', url)
                continue

            # If this seed contains the full content in the RSS feed <summary>,
            # then we just use it instead of downloading the contents.
            if self.seed.rss_full_entry:
                is_printer_friendly = False
                try:
                    html = entry['summary']
                except KeyError:
                    html = entry['description']
            else:
                is_printer_friendly = False
                html = None
                time.sleep(self.seed.delay)

                # First, try deducing for the printer-friendly page, given the URL.
                print_url = self.get_printer_friendly_url(url)
                if print_url is not None:
                    try:
                        html = self.get_article_page(print_url)
                        is_printer_friendly = True
                    except Exception, e:
                        self.logger.info('Error retrieving supposedly accurate printer-friendly page %s: %s', print_url, e)

                # If a printer-friendly page didn't exist, get the real page.
                if html is None:
                    try:
                        html = self.get_article_page(url)
                    except Exception, e:
                        self.logger.info('Error retrieving %s: %s', url, e)
                        continue

                    # If a page was downloaded, try looking for a printer-friendly
                    # link, and download that.
                    print_page = self.get_printer_friendly_page(html, url)
                    if print_page is not None:
                        is_printer_friendly = True
                        html = print_page

                new_html = self.scrape_article_from_page(html)
                if new_html is not None:
                    html = new_html

                if article_date is None:
                    article_date = self.scrape_article_date_from_page(html)

            if not html.strip():
                self.logger.debug('Got empty HTML page')
                continue

            article_headline = strip_tags(title)
            if len(article_headline) > 252:
                article_headline = article_headline[252:] + '...'
            p = Page.objects.create(
                seed=self.seed,
                url=url,
                scraped_url=(is_printer_friendly and print_url or url),
                html=html,
                when_crawled=datetime.datetime.now(),
                is_article=True,
                is_pdf=False,
                is_printer_friendly=is_printer_friendly,
                article_headline=article_headline,
                article_date=article_date,
                has_addresses=None,
                when_geocoded=None,
                geocoded_by='',
                times_skipped=0,
                robot_report='',
            )
            self.logger.info('Created %s story %r', self.seed.base_url, article_headline)
            save_locations_for_page(p)

    def normalize_url(self, url):
        """
        Given the article URL, returns a normalized version of the URL.
        """
        return url

    def download_page(self, url, article_headline):
        """
        Given the URL and headline from RSS, returns True if this page should
        be downloaded, and False if it can be skipped.
        """
        return True

    def get_article_page(self, url):
        return self.retriever.fetch_data(url)

    def get_printer_friendly_url(self, url):
        """
        Given a story URL, returns the printer-friendly URL, or None if it
        can't be determined.
        """
        return None

    def get_printer_friendly_page(self, html, url):
        """
        Parses the given detail page and returns the printer-friendly page, or
        None if not found.
        """
        print_link = printer_friendly_link(make_tree(html))
        if print_link:
            print_link = urlparse.urljoin(url, print_link)
            try:
                return self.get_article_page(print_link)
            except Exception, e:
                self.logger.debug('Error retrieving printer-friendly page %s: %s', url, e)
                return None
        else:
            return None

    def scrape_article_from_page(self, html):
        """
        Parses the given detail page and returns the article as a string, or
        None if it can't be found.
        """
        return html

    def scrape_article_date_from_page(self, html):
        """
        Parses the given detail page and returns the article date as a
        datetime.date, or None if it can't be found.
        """
        return None

def update(seed_id=None):
    """
    Retrieves and saves every new item for every Seed that is an RSS feed.
    """
    retriever = UnicodeRetriever(cache=None)
    logger = logging.getLogger('eb.retrieval.blob_rss')
    qs = Seed.objects.filter(is_rss_feed=True, is_active=True)
    if seed_id is not None:
        qs = qs.filter(id=seed_id)
    for seed in qs:
        updater = FeedUpdater(seed, retriever, logger)
        updater.update()

if __name__ == "__main__":
    from ebdata.retrieval import log_debug
    update()

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

# There are no models, but this is needed for `manage.py test` to find
# our tests.


########NEW FILE########
__FILENAME__ = tests
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#


########NEW FILE########
__FILENAME__ = urls
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf.urls.defaults import *
from ebdata.geotagger import views

urlpatterns = patterns('',
    url(r'^api/geocode/$', views.geocode, name='ebdata-geocode'),
    url(r'^api/geotag/$', views.geotag, name='ebdata-geotag'),
)

########NEW FILE########
__FILENAME__ = views
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from django.http import HttpResponse
import re
from django.utils import simplejson as json 

from ebdata.nlp.addresses import tag_addresses
from ebdata.nlp.places import place_tagger, location_tagger
from ebpub.geocoder.base import DoesNotExist, full_geocode

def geocode(request): 
    """
    parameters:
    q - query string ostensibly containing a single address 
    or location to be geocoded
    """
    query = request.REQUEST.get('q', '').strip()
    if query:
        try:
            results = _build_geocoder_results(query)
        except:
            results = ()
    else:
        results = ()

    response = {'results': results}
    return HttpResponse(json.dumps(response), mimetype="application/json")

def geotag(request):
    """
    accepts a block of text, extracts addresses, locations 
    and places and geocodes them. 
    """
    # XXX this is very brutal and wacky looking... 
    # it re-uses as much of the existing way of doing things 
    # as possible without regard to time costs or instanity of 
    # interface.  Once this has a more clear form, a more 
    # optimized way of attacking this could be devised if needed.
    
    text = request.REQUEST.get('q', '').strip()
    
    pre = '<geotagger:location>'
    post = '</geotagger:location>'
    text = tag_addresses(text, pre=pre, post=post)
    text = location_tagger(pre=pre, post=post)(text)
    text = place_tagger(pre=pre, post=post)(text)

    all_pat = re.compile('%s(.*?)%s' % (pre, post))
    results = []
    all_locations = []
    for loc in all_pat.findall(text):
        try:
            all_locations.append(loc)
            results += _build_geocoder_results(loc)
        except DoesNotExist:
            pass

    response = {'locations': results, 'searched': all_locations}
    return HttpResponse(json.dumps(response, indent=2),
                        mimetype="application/json")


def _build_geocoder_results(query):
    results = full_geocode(query)
    if results['type'] == 'block':
        return []

    if results['ambiguous'] == True:
        rs = results['result']
    else:
        rs = [results['result']]
        
    return [_build_json_result(query, r, results) for r in rs]

def _build_json_result(query, result, results):

    if results['type'] == 'address': 
        return {
            'query': query,
            'type': 'address',
            'address': result.get('address'),
            'city': result.get('city'),
            'state': result.get('state'),
            'zip': result.get('zip'),
            'latlng': [result.lat, result.lng]
        }
    if results['type'] == 'location':
        return {
            'query': query,
            'type': result.location_type.name,
            'name': result.name,
            'city': result.city,
            'latlng': [result.location.centroid.y, result.location.centroid.x]
        }
    if results['type'] == 'place': 
        return {
            'query': query,
            'type': 'place',
            'name': result.pretty_name,
            'address': result.address, 
            'latlng': [result.location.y, result.location.x]
        }

########NEW FILE########
__FILENAME__ = addresses
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

import re

# Regex notes:
#   * This is *not* a case-insensitive regex, because we assume
#     capitalized words are special (street names).
#   * All data matched by capturing parentheses is concatenated together, so
#     if you don't want to include something in the resulting string, don't
#     capture it.

# STREET_NAME is a fragment of a regular expression that is used in several
# places in our "real" regular expression (ADDRESSES_RE) below. The one tricky
# thing about it is that it includes a "CAPTURE_START" placeholder instead of
# a capturing opening parenthesis. This lets us create two versions of the
# regex -- STREET_NAME_CAPTURE and STREET_NAME_NOCAPTURE.


STREET_NAME = r"""
    # Here, we define some common false positives and tell the regex to ignore them.
    (?!
        [Aa][Ss][Ss][Oo][Cc][Ii][Aa][Tt][Ee][Dd]\ [Pp][Rr][Ee][Ss][Ss] # associated press
        |
        [Uu][Nn][Ii][Vv][Ee][Rr][Ss][Ii][Tt][Yy]\ [Oo][Ff]             # university of
    )
    # DIRECTION
    %(CAPTURE_START)s
        (?:
            [NSEWnsew]\.?
            |
            (?:
                [Nn][Oo][Rr][Tt][Hh] |
                [Ss][Oo][Uu][Tt][Hh] |
                [Ee][Aa][Ss][Tt] |
                [Ww][Ee][Ss][Tt] |
                [Nn][Oo][Rr][Tt][Hh][Ee][Aa][Ss][Tt] |
                [Nn][Oo][Rr][Tt][Hh][Ww][Ee][Ss][Tt] |
                [Ss][Oo][Uu][Tt][Hh][Ee][Aa][Ss][Tt] |
                [Ss][Oo][Uu][Tt][Hh][Ww][Ee][Ss][Tt]
            )
            |
            (?:
                N\.?W | S\.?W | N\.?E | S\.?E
            )\.?
        )
        \ +                                        # space (but not newline)
    )?
    (?:
        # STREET NAME
        %(CAPTURE_START)s
            # Numbered street names with a suffix ("3rd", "4th").
            \d+(?:st|ST|nd|ND|rd|RD|th|TH|d|D)

            |

            # Or, numbered street names without a suffix ("3", "4")
            # but with a street type.  (Suffix is captured later, so
            # we use a lookahead here.)
            \d+
            (?=
                \ +
                (?:Ave|Avenue|Blvd|Boulevard|Bvd|Cir|Circle|Court|Ct|Dr|Drive|
                   Lane|Ln|Parkway|Pkwy|Place|Plaza|Pl|Plz|Point|Pt|Pts|Rd|Rte|
                   Sq|Sqs|Street|Streets|St|Sts|Terrace|Ter|Terr|Trl|Way|Wy
                )
                \b
            )

            |

            # Or, street names that don't start with numbers.
            (?:
                # Optional prefixes --
                # "St", as in "St Louis"
                # "Dr. Martin", as in "Dr. Martin Luther King"
                (?:
                    [Ss][Tt]\.?
                    |
                    [Dd][Rr]\.?\ [Mm][Aa][Rr][Tt][Ii][Nn]
                )
                \ +
            )?
            (?:
                Mass\.(?=\ +[Aa]ve)  # Special case: "Mass." abbr. for "Massachussetts Ave."
                                     # Needs to be special-cased because of the period.
                |
                (?:Avenue|Ave\.?)\ +[A-Z]       # Special case: "Avenue X"
                |
                [A-Z][a-z][A-Za-z]*  # One initial-capped word
                |
                [A-Z]\b              # Single-letter street name (e.g., K St. in DC)
                (?!\.\w)             # Avoid '20 U.S.A.'
            )
        )
        (?:
            # Here, we list the options with street suffixes first, so that
            # the suffix abbreviations are treated as the last part of the
            # street name, to avoid overeagerly capturing "123 Main St. The".
            %(CAPTURE_START)s
                \ +(?:Ave|Blvd|Bvd|Cir|Ct|Dr|Ln|Pkwy|Pl|Plz|Pt|Pts|Rd|Rte|Sq|Sqs|St|Sts|Ter|Terr|Trl|Wy)\.
                |
                \ +[A-Z][a-z][A-Za-z]*\ (?:Ave|Blvd|Bvd|Cir|Ct|Dr|Ln|Pkwy|Pl|Plz|Pt|Pts|Rd|Rte|Sq|Sqs|St|Sts|Ter|Terr|Trl|Wy)\.
                |
                (?:,?\ Jr\.?,?|\ +[A-Z][a-z][A-Za-z]*){2}\ +(?:Ave|Blvd|Bvd|Cir|Ct|Dr|Ln|Pkwy|Pl|Plz|Pt|Pts|Rd|Rte|Sq|Sqs|St|Sts|Ter|Terr|Trl|Wy)\.
                |
                (?:,?\ Jr\.?,?|\ +[A-Z][a-z][A-Za-z]*){3}\ +(?:Ave|Blvd|Bvd|Cir|Ct|Dr|Ln|Pkwy|Pl|Plz|Pt|Pts|Rd|Rte|Sq|Sqs|St|Sts|Ter|Terr|Trl|Wy)\.
                |
                (?:,?\ Jr\.?,?|\ +[A-Z][a-z][A-Za-z]*){4}\ +(?:Ave|Blvd|Bvd|Cir|Ct|Dr|Ln|Pkwy|Pl|Plz|Pt|Pts|Rd|Rte|Sq|Sqs|St|Sts|Ter|Terr|Trl|Wy)\.
                |
                (?:,?\ Jr\.?,?|\ +[A-Z][a-z][A-Za-z]*){5}\ +(?:Ave|Blvd|Bvd|Cir|Ct|Dr|Ln|Pkwy|Pl|Plz|Pt|Pts|Rd|Rte|Sq|Sqs|St|Sts|Ter|Terr|Trl|Wy)\.
                |
                (?:,?\ Jr\.?,?|\ +[A-Z][a-z][A-Za-z]*){1,5}
            )?
            # OPTIONAL POST-DIR
            (?:
                # Standard post-dir format
                %(CAPTURE_START)s
                    ,?\s(?:N\.?E|S\.?E|N\.?W|S\.?W|N|S|E|W)\.?
                )
                # Avoid greedily capturing more letters, like
                # '123 Main St, New England' to '123 Main St, N'
                (?![A-Za-z])

                |

                # Or, a special-case for DC quadrants, to find stuff like:
                # "600 H Street in NE Washington"
                # "600 H Street in the NE quadrant"
                # "600 H Street in northeast DC"

                # Note that this is NOT captured, so that it's excluded from
                # the final output.
                ,?
                \s in
                %(CAPTURE_START)s
                    \s
                )
                (?:
                    (?:the|far) \s
                )?

                %(CAPTURE_START)s
                    (?:NE|SE|NW|SW|[Nn]ortheast|[Ss]outheast|[Nn]orthwest|[Ss]outhwest)
                    (?=
                        \s (?:quadrant|D\.?C\.?|Washington)
                    )
                )
            )?
        )?
    )
"""
STREET_NAME_CAPTURE = STREET_NAME % {'CAPTURE_START': '('}
STREET_NAME_NOCAPTURE = STREET_NAME % {'CAPTURE_START': '(?:'}

ADDRESSES_RE = r"""(?x)
    (?<!-|/|:|,|\.|\$) # These various characters are not allowed before an address/intersection.
    \b

    # Ignore things that look like dates -- e.g., "21 May 2009".
    # This is a problem e.g. in cases where there's a May Street.
    (?!
        \d+\s+
        (?:January|February|March|April|May|June|July|August|September|October|November|December)
        ,?\s+
        \d\d\d\d
    )

    # Ignore intersections that are prefixed by "University of", like
    # "University of Texas at Austin". This is a common false positive.
    (?<!
        [Uu][Nn][Ii][Vv][Ee][Rr][Ss][Ii][Tt][Yy]\s[Oo][Ff]\s
    )

    (?:
        # SEGMENT ("FOO BETWEEN BAR AND BAZ")
        (?:
            %(STREET_NAME_CAPTURE)s (,?\ + between \ +) %(STREET_NAME_CAPTURE)s (,?\ + and \ +) %(STREET_NAME_CAPTURE)s
            |
            %(STREET_NAME_CAPTURE)s (,?\ + from \ +) %(STREET_NAME_CAPTURE)s (,?\ + to \ +) %(STREET_NAME_CAPTURE)s
        )

        |

        # BLOCK/ADDRESS
        (?:
            (
                (?:
                    (?:\d+|[Ff][Ii][Rr][Ss][Tt])[-\ ]
                        (?:(?:[Nn][Oo][Rr][Tt][Hh]|[Ss][Oo][Uu][Tt][Hh]|[Ee][Aa][Ss][Tt]|[Ww][Ee][Ss][Tt])\ )?
                    [Bb][Ll][Oo][Cc][Kk]\ [Oo][Ff]
                    |
                    \d+\ *-\ *\d+
                    |
                    \d+
                )
                \ +
            )
            %(STREET_NAME_CAPTURE)s

            # ignore the intersection in parenthesis so that it's not picked
            # up as a separate location. We do this by consuming the string
            # but *not* capturing it.
            (?:
                \ +
                \(?
                between
                \ +
                %(STREET_NAME_NOCAPTURE)s
                \ +
                and
                \ +
                %(STREET_NAME_NOCAPTURE)s
                \)?
            )?
        )

        |

        # INTERSECTION
        (?:
            # Common intersection prefixes. They're included here so that the
            # regex doesn't include them as part of the street name.
            (?:
                (?:
                    [Nn]ear |
                    [Aa]t |
                    [Oo]n |
                    [Tt]o |
                    [Aa]round |
                    [Ii]ntersection\ of |
                    [Cc]orner\ of |
                    [Aa]rea\ of |
                    [Aa]reas?\ surrounding |
                    vicinity\ of |
                    ran\ down |
                    running\ down |
                    crossed
                )
                \ +
            )?
            \b
            (?:%(STREET_NAME_CAPTURE)s)
            (\ +)
            (
                (?:
                    [Aa][Nn][Dd] |
                    [Aa][Tt] |
                    [Nn][Ee][Aa][Rr] |
                    & |
                    [Aa][Rr][Oo][Uu][Nn][Dd] |
                    [Tt][Oo][Ww][Aa][Rr][Dd][Ss]? |
                    [Oo][Ff][Ff] |
                    (?:[Jj][Uu][Ss][Tt]\ )?(?:[Nn][Oo][Rr][Tt][Hh]|[Ss][Oo][Uu][Tt][Hh]|[Ee][Aa][Ss][Tt]|[Ww][Ee][Ss][Tt])\ [Oo][Ff] |
                    (?:[Jj][Uu][Ss][Tt]\ )?[Pp][Aa][Ss][Tt]
                )
                \ +
            )
            (?:%(STREET_NAME_CAPTURE)s)
        )
    )

    # OPTIONAL CITY SUFFIX
    (?:
        (?:
            ,?\s+in |
            ,
        )
        \s+

        # CITY NAME
        (
            [A-Z][a-z][A-Za-z]*                   # One initial-capped word
            (?:
                ,?\ Jr\.?,?
                |
                \ [A-Z][a-z][A-Za-z]*
                |
                -[A-Za-z]+                        # Hyphenated words (e.g. "Croton-on-Hudson" in NY)
            ){0,4}  # Initial-capped words
        )
    )?
    """ % {'STREET_NAME_CAPTURE': STREET_NAME_CAPTURE, 'STREET_NAME_NOCAPTURE': STREET_NAME_NOCAPTURE}

ADDRESSES_RE_COMPILED = re.compile(ADDRESSES_RE)

def parse_addresses(text):
    """
    Returns a list of all addresses found in the given string, as tuples in the
    format (address, city).
    """
    # This assumes the last parenthetical grouping in ADDRESSES_RE is the city.
    return [(''.join(bits[:-1]), bits[-1]) for bits in ADDRESSES_RE_COMPILED.findall(text)]

def tag_addresses(text, pre='<addr>', post='</addr>'):
    """
    "Tags" any addresses in the given string by surrounding them with pre and post.
    Returns the resulting string.

    Note that only the addresses are tagged, not the cities (if cities exist).
    """
    def _re_handle_address(m):
        bits = m.groups()
        return pre + ''.join(filter(None, bits[:-1])) + (bits[-1] and (', %s' % bits[-1]) or '') + post
    return ADDRESSES_RE_COMPILED.sub(_re_handle_address, text)

########NEW FILE########
__FILENAME__ = datelines
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

import re

dateline_re = re.compile(ur"""
    (?:
        (?:                                                     # Either a newline, or a
            ^                                                   # <p> / <div>, followed by tags/space
            |
            </?\s*(?:[Pp]|[Dd][Ii][Vv])[^>]*>
        )
        (?:<[^>]*>|\s)*                                         # The start of a line
    )
    (?:\(\d\d?-\d\d?\)\s+\d\d?:\d\d\s+[PMCE][SD]T\s+)?          # Optional timestamp -- e.g., "(07-17) 13:09 PDT"
    ([A-Z][A-Z.]*[A-Z.,](?:\s*[A-Z][A-Za-z.]*[A-Za-z.,]){0,4})  # The dateline itself
    (?:                                                         # Optional parenthetical news outlet
        \s+
        \(
            [-A-Za-z0-9]{1,15}
            (?:\s+[-A-Za-z0-9]{1,15}){0,4}
        \)
    )?
    \s*                                                         # Optional space before dash
    (?:\xa0--\xa0|--|\x97|\u2014|\u2015|&\#8213;|&\#151;|&\#x97;)     # Dash (or emdash)
    """, re.MULTILINE | re.VERBOSE)

# That dash/emdash regex bears some explaining as i'm guessing it was added to piecemeal:
#
# \xa0 =  non-breaking space in cp1252
# \x97 = em dash in cp1252
# \u2014 = em dash in unicode (assuming we've already decoded)
# \u2015 = 'horizontal bar' in unicode (assuming we've already decoded)
# &#8213; = 'horizontal bar' as HTML char ref, numeric
# &#x2015; = 'horizontal bar' as HTML char ref, hex
# &#151; = em dash as HTML char ref, numeric
# &#x97; = em dash as HTML char ref, hex

def guess_datelines(text):
    """
    Given some text (with or without HTML), returns a list of the dateline(s)
    in it. Returns an empty list if none are found.
    """
    return dateline_re.findall(text)

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

# There are no models, but this is needed for `manage.py test` to find
# our tests.


########NEW FILE########
__FILENAME__ = places
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

import re
from ebpub.db.models import Location, LocationSynonym
from ebpub.streets.models import Place, PlaceSynonym

"""
Factories that return 'grabber' and 'tagger' functions, for finding
and marking up text that looks like...  well, anything, but in this
context we are typically looking for names of db.Locations and
db.Places.

In each case, the factory is passed a list of strings to treat as
phrases to match, and returns a function that takes a ``text`` argument.

'Tagger' functions return text where each matched phrase is replaced
by itself wrapped in the ``pre`` and ``post`` arguments.

'Grabber' functions return a list of 3-tuples, each of the form
(start, end, phrase), where ``phrase``v is the text that was matched,
and ``start`` and ``end`` are the indexes of where that text was found
in the original text.

'paranoid' means whether you care about avoiding nested tags.
e.g. you might not want to create <span>South<span>Boston</span></span>.
Longer phrases will be matched before shorter phrases.

TODO: docstrings for each of these
"""

def loose_phrase_grabber(phrases):
    """
    Given a list of strings ('phrases'), returns a phrase grabber
    function that does not care about markup around phrases.
    """
    def grab_phrases(text):
        phrases.sort(key=len, reverse=True)
        tags = []
        def handle_match(m):
            # Note the start & end positions,
            # and take care to preserve the length of the input
            # by replacing the match with whitespace.
            tags.append((m.start(), m.end(), m.group()))
            return ' '*(m.end() - m.start())

        for phrase in phrases:
            # don't bother buiding and exhaustively searching unless
            # we at least weakly see this phrase in the text, 
            # re compiling and searching is not cheap added up 
            # over all locations.
            if phrase in text:
                text = re.sub(r'\b%s\b' % phrase, handle_match, text)

            # TODO: we could actually do this in linear time entirely without
            # regexes. (str.find is average linear)
            # something like (UNTESTED):
            # start = 0
            # while True:
            #     start = text.find(phrase, start)
            #     if start == -1:
            #         break
            #     end = start + len(phrase)
            #     tags.append((start, end, phrase))
            #     start += 1
            # text = text.replace(phrase, ' ' * len(phrase))
            # Would need to profile that though.
        tags.sort()
        return tags

    return grab_phrases

def paranoid_phrase_grabber(phrases, pre, post):
    """
    Returns a phrase grabber function that ignores occurrences of the phrases
    within the pre / post tags.
    """
    def handle_match(m):
        # Unlike a normal re.sub(), this allows the replacement to have
        # dynamic length.
        return ' ' * len(m.group())
    nuke_tags = re.compile('%s.*?%s' % (re.escape(pre), re.escape(post)))
    loose_grabber = loose_phrase_grabber(phrases)

    def grab_phrases(text):
        text = nuke_tags.sub(handle_match, text)
        return loose_grabber(text)

    return grab_phrases

def phrase_tagger(phrases, pre='<span>', post='</span>', paranoid=True):
    """Returns a phrase tagger function.
    If ``paranoid==True``, avoids tagging inside existing tags.
    """
    if paranoid:
        grabber = paranoid_phrase_grabber(phrases, pre, post)
    else: 
        grabber = loose_phrase_grabber(phrases)

    def tag_phrases(text):
        out_text = []
        curpos = 0
        for tag in grabber(text):
            out_text += [text[curpos:tag[0]], pre, tag[2], post]
            curpos = tag[1]
        out_text.append(text[curpos:])
        return ''.join(out_text)

    return tag_phrases

def place_tagger(pre='<addr>', post='</addr>', paranoid=True):
    """
    Returns a phrase tagger function where the phrases are the names of all
    Places and PlaceSynonyms in the database.
    """
    phrases = [p['pretty_name'] for p in Place.objects.filter(place_type__is_geocodable=True).values('pretty_name').order_by('-pretty_name')]
    synonyms = [m['pretty_name'] for m in PlaceSynonym.objects.values('pretty_name').order_by('-pretty_name')]
    return phrase_tagger(phrases + synonyms, pre, post, paranoid)

def location_tagger(pre='<addr>', post='</addr>', paranoid=True,
                    ignore_location_types=('boroughs', 'cities')):
    """
    Returns a phrase tagger function where the phrases are the names of all
    Locations and LocationSynonyms in the database.
    """
    location_qs = Location.objects.values('name').order_by('-name').exclude(location_type__slug__in=ignore_location_types)
    locations = [p['name'] for p in location_qs]
    synonyms = [m['pretty_name'] for m in LocationSynonym.objects.values('pretty_name').order_by('-pretty_name')]
    return phrase_tagger(locations + synonyms, pre, post, paranoid)

def place_grabber():
    """
    Returns a phrase grabber function where the phrases are the names of all
    Places and PlaceSynonyms in the database.
    """
    phrases = [p['pretty_name'] for p in Place.objects.filter(place_type__is_geocodable=True).values('pretty_name').order_by('-pretty_name')]
    synonyms = [m['pretty_name'] for m in PlaceSynonym.objects.values('pretty_name').order_by('-pretty_name')]
    return loose_phrase_grabber(phrases + synonyms)

def location_grabber(ignore_location_types=('boroughs', 'cities')):
    """
    Returns a phrase grabber function where the phrases are the names of all
    Locations and LocationSynonyms in the database.
    """
    location_qs = Location.objects.values('name').order_by('-name').exclude(location_type__slug__in=ignore_location_types)
    locations = [p['name'] for p in location_qs]
    synonyms = [m['pretty_name'] for m in LocationSynonym.objects.values('pretty_name').order_by('-pretty_name')]
    return loose_phrase_grabber(locations + synonyms)

########NEW FILE########
__FILENAME__ = tests
# -*- coding: utf-8 -*-
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.nlp.addresses import parse_addresses
from ebdata.nlp.places import phrase_tagger
from ebdata.nlp.places import loose_phrase_grabber
from ebdata.nlp.places import paranoid_phrase_grabber

import unittest

class AddressParsing(unittest.TestCase):
    def assertParses(self, text, expected):
        self.assertEqual(parse_addresses(text), expected)

class MixedCaseAddressParsing(AddressParsing):
    def test_empty(self):
        self.assertParses('', [])

    def test_nomatch1(self):
        self.assertParses('Hello there', [])

    def test_nomatch2(self):
        self.assertParses('Call 321-FUN-TIMES', [])

    def test_nomatch3(self):
        self.assertParses('Call 321-Fun-Times', [])

    def test_nomatch4(self):
        self.assertParses('Call 321-Fun Times', [])

    def test_address_basic(self):
        self.assertParses('123 Main St.', [('123 Main St.', '')])

    def test_address_basic_in_sentence(self):
        self.assertParses('I live at 123 Main St., you know.', [('123 Main St.', '')])

    def test_address_basic_with_followup_sentence(self):
        self.assertParses('I live at 123 Main St. The other person lives elsewhere.', [('123 Main St.', '')])

    def test_address_no_suffix(self):
        self.assertParses('123 Main', [('123 Main', '')])

    def test_address_no_suffix_period(self):
        self.assertParses('Lives at 123 Main.', [('123 Main', '')])

    def test_address_multiple_spaces1(self):
        self.assertParses('123  Main St.', [('123  Main St.', '')])

    def test_address_multiple_spaces2(self):
        self.assertParses('123 Main  St.', [('123 Main  St.', '')])

    def test_address_dir_n(self):
        self.assertParses('123 N. Main St.', [('123 N. Main St.', '')])

    def test_address_dir_s(self):
        self.assertParses('123 S. Main St.', [('123 S. Main St.', '')])

    def test_address_dir_e(self):
        self.assertParses('123 E. Main St.', [('123 E. Main St.', '')])

    def test_address_dir_w(self):
        self.assertParses('123 W. Main St.', [('123 W. Main St.', '')])

    def test_address_dir_ne(self):
        self.assertParses('123 NE. Main St.', [('123 NE. Main St.', '')])

    def test_address_dir_nw(self):
        self.assertParses('123 NW. Main St.', [('123 NW. Main St.', '')])

    def test_address_dir_se(self):
        self.assertParses('123 SE. Main St.', [('123 SE. Main St.', '')])

    def test_address_dir_sw(self):
        self.assertParses('123 SW. Main St.', [('123 SW. Main St.', '')])

    def test_address_dir_ne_no_period(self):
        self.assertParses('123 NE Main St.', [('123 NE Main St.', '')])

    def test_address_dir_nw_no_period(self):
        self.assertParses('123 NW Main St.', [('123 NW Main St.', '')])

    def test_address_dir_se_no_period(self):
        self.assertParses('123 SE Main St.', [('123 SE Main St.', '')])

    def test_address_dir_sw_no_period(self):
        self.assertParses('123 SW Main St.', [('123 SW Main St.', '')])

    def test_address_dir_northeast(self):
        self.assertParses('123 Northeast Main St.', [('123 Northeast Main St.', '')])

    def test_address_dir_northwest(self):
        # There was a typo in the regex for this, but mysteriously it
        # still worked. "fixed" in commit f1457ee5546acce5cbb84b362b70c93cf2101b3a
        self.assertParses('123 Northwest Main St.', [('123 Northwest Main St.', '')])

    def test_address_dir_southeast(self):
        self.assertParses('123 Southeast Main St.', [('123 Southeast Main St.', '')])

    def test_address_dir_southwest(self):
        self.assertParses('123 Southwest Main St.', [('123 Southwest Main St.', '')])

    def test_address_dir_no_period(self):
        self.assertParses('123 N Main St.', [('123 N Main St.', '')])

    def test_address_coincidence(self):
        # Um, should't we assert that this does NOT match?
        # maybe need some stop-words for street name?
        self.assertParses('My Favorite Number Is 123 And I Love It.', [('123 And', '')])

    def test_block_basic(self):
        self.assertParses('100 block of Main Street', [('100 block of Main Street', '')])

    def test_block_zero(self):
        self.assertParses('0 block of Main Street', [('0 block of Main Street', '')])

    def test_block_first(self):
        self.assertParses('first block of Main Street', [('first block of Main Street', '')])

    def test_block_first_cap(self):
        self.assertParses('First block of Main Street', [('First block of Main Street', '')])

    def test_block_with_direction_first_north(self):
        self.assertParses('800 North Block of Lawrence Avenue', [('800 North Block of Lawrence Avenue', '')])

    def test_block_with_direction_first_south(self):
        self.assertParses('800 South Block of Lawrence Avenue', [('800 South Block of Lawrence Avenue', '')])

    def test_block_with_direction_first_east(self):
        self.assertParses('800 East Block of Lawrence Avenue', [('800 East Block of Lawrence Avenue', '')])

    def test_block_with_direction_first_west(self):
        self.assertParses('800 West Block of Lawrence Avenue', [('800 West Block of Lawrence Avenue', '')])

    def test_block_no_suffix(self):
        self.assertParses('1000 block of Western', [('1000 block of Western', '')])

    def test_block_cap(self):
        self.assertParses('100 Block of Main Street', [('100 Block of Main Street', '')])

    def test_block_hyphen(self):
        self.assertParses('5700-block of South Indiana', [('5700-block of South Indiana', '')])

    def test_block_period_not_included(self):
        self.assertParses('It happened on the 1000 block of Western.', [('1000 block of Western', '')])

    def test_block_comma_not_included(self):
        self.assertParses('It happened on the 1000 block of Western, officials said', [('1000 block of Western', '')])

    def test_block_quote_not_included(self):
        self.assertParses('"It happened on the 1000 block of Western" they said.', [('1000 block of Western', '')])

    def test_block_no_double_zeroes(self):
        self.assertParses('Henry lives on the 140 block of Park Hill Avenue, right?', [('140 block of Park Hill Avenue', '')])

    def test_block_direction(self):
        self.assertParses('100 Block of N. Main Street', [('100 Block of N. Main Street', '')])

    def test_suffix_period_included(self):
        self.assertParses('The event at 1358 W. Leland Ave. was fun.', [('1358 W. Leland Ave.', '')])

    def test_multi_word_street_name(self):
        self.assertParses('Residents of 3200 N. Lake Shore Drive were happy.', [('3200 N. Lake Shore Drive', '')])

    def test_prefix_mc(self):
        self.assertParses('I live at 926 E. McLemore.', [('926 E. McLemore', '')])

    def test_prefix_st(self):
        self.assertParses('I live at 926 N. St. Louis.', [('926 N. St. Louis', '')])

    def test_prefix_st_no_period(self):
        self.assertParses('I live at 926 N. St Louis.', [('926 N. St Louis', '')])

    def test_prefix_st_no_period_suffix(self):
        self.assertParses('I live at 926 N. St Louis St.', [('926 N. St Louis St.', '')])

    def test_prefix_saint(self):
        self.assertParses('I live at 926 N. Saint Louis St.', [('926 N. Saint Louis St.', '')])

    def test_newlines_excluded1(self):
        self.assertParses('The number 926\nIs cool', [])

    def test_newlines_excluded2(self):
        self.assertParses('I live at 123\nMain St.', [])

    def test_address_range1(self):
        self.assertParses('10-12 Main St.', [('10-12 Main St.', '')])

    def test_address_range2(self):
        self.assertParses('10-12 N. Main St.', [('10-12 N. Main St.', '')])

    def test_address_range3(self):
        self.assertParses('0-100 Main St.', [('0-100 Main St.', '')])

    def test_address_range4(self):
        self.assertParses('0-100 N. Main St.', [('0-100 N. Main St.', '')])

    def test_pre_number_quote(self):
        self.assertParses('The address is "123 Main St."', [('123 Main St.', '')])

    def test_pre_number_dash(self):
        self.assertParses('I-90 Edens', [])

    def test_pre_number_dollar_sign(self):
        self.assertParses('Hawaii Gas Passes $5 Mark', [])

    def test_pre_number_letter(self):
        self.assertParses('A123 Main St.', [])

    def test_pre_number_slash(self):
        self.assertParses('Chicago 24/7 Crime', [])

    def test_pre_number_colon(self):
        self.assertParses('Happened at about 6:30 Wednesday night', [])

    def test_pre_number_comma(self):
        self.assertParses('That is worth more than $3,000 American dollars', [])

    def test_pre_number_period(self):
        self.assertParses('He received a 3.0 Grade Point Average', [])

    def test_mlk1(self):
        self.assertParses('3624 S. Dr. Martin Luther King Jr. Memorial Drive', [('3624 S. Dr. Martin Luther King Jr. Memorial Drive', '')])

    def test_mlk2(self):
        self.assertParses('3624 S. Dr. Martin Luther King, Jr., Memorial Drive', [('3624 S. Dr. Martin Luther King, Jr., Memorial Drive', '')])

    def test_mlk3(self):
        self.assertParses('3624 S. Dr. Martin Luther King, Jr. Memorial Drive', [('3624 S. Dr. Martin Luther King, Jr. Memorial Drive', '')])

    def test_mlk4(self):
        self.assertParses('3624 S. Martin Luther King, Jr., Memorial Drive', [('3624 S. Martin Luther King, Jr., Memorial Drive', '')])

    def test_mlk5(self):
        self.assertParses('3624 S. Dr. Martin Luther King Drive', [('3624 S. Dr. Martin Luther King Drive', '')])

    def test_mlk6(self):
        self.assertParses('3624 S. Dr. Martin Drive', [('3624 S. Dr. Martin Drive', '')])

    def test_junior1(self):
        self.assertParses('3624 S. John Hancock Jr. Road', [('3624 S. John Hancock Jr. Road', '')])

    def test_junior2(self):
        self.assertParses('3624 S. John Hancock, Jr., Road', [('3624 S. John Hancock, Jr., Road', '')])

    def test_numeric_street1(self):
        self.assertParses('330 West 95th Street', [('330 West 95th Street', '')])

    def test_numeric_street2(self):
        self.assertParses('the Continental, located at 330 West 95th Street.', [('330 West 95th Street', '')])

    def test_suffix_ave(self):
        self.assertParses('The man at 123 Main Ave. was cool.', [('123 Main Ave.', '')])

    def test_suffix_blvd(self):
        self.assertParses('The man at 123 Main Blvd. was cool.', [('123 Main Blvd.', '')])

    def test_suffix_bvd(self):
        self.assertParses('The man at 123 Main Bvd. was cool.', [('123 Main Bvd.', '')])

    def test_suffix_cir(self):
        self.assertParses('The man at 123 Main Cir. was cool.', [('123 Main Cir.', '')])

    def test_suffix_ct(self):
        self.assertParses('The man at 123 Main Ct. was cool.', [('123 Main Ct.', '')])

    def test_suffix_dr(self):
        self.assertParses('The man at 123 Main Dr. was cool.', [('123 Main Dr.', '')])

    def test_suffix_ln(self):
        self.assertParses('The man at 123 Main Ln. was cool.', [('123 Main Ln.', '')])

    def test_suffix_pkwy(self):
        self.assertParses('The man at 123 Main Pkwy. was cool.', [('123 Main Pkwy.', '')])

    def test_suffix_pl(self):
        self.assertParses('The man at 123 Main Pl. was cool.', [('123 Main Pl.', '')])

    def test_suffix_plz(self):
        self.assertParses('The man at 123 Main Plz. was cool.', [('123 Main Plz.', '')])

    def test_suffix_pt(self):
        self.assertParses('The man at 123 Main Pt. was cool.', [('123 Main Pt.', '')])

    def test_suffix_pts(self):
        self.assertParses('The man at 123 Main Pts. was cool.', [('123 Main Pts.', '')])

    def test_suffix_rd(self):
        self.assertParses('The man at 123 Main Rd. was cool.', [('123 Main Rd.', '')])

    def test_suffix_rte(self):
        self.assertParses('The man at 123 Main Rte. was cool.', [('123 Main Rte.', '')])

    def test_suffix_sq(self):
        self.assertParses('The man at 123 Main Sq. was cool.', [('123 Main Sq.', '')])

    def test_suffix_sqs(self):
        self.assertParses('The man at 123 Main Sqs. was cool.', [('123 Main Sqs.', '')])

    def test_suffix_st(self):
        self.assertParses('The man at 123 Main St. was cool.', [('123 Main St.', '')])

    def test_suffix_sts(self):
        self.assertParses('The man at 123 Main Sts. was cool.', [('123 Main Sts.', '')])

    def test_suffix_ter(self):
        self.assertParses('The man at 123 Main Ter. was cool.', [('123 Main Ter.', '')])

    def test_suffix_terr(self):
        self.assertParses('The man at 123 Main Terr. was cool.', [('123 Main Terr.', '')])

    def test_suffix_trl(self):
        self.assertParses('The man at 123 Main Trl. was cool.', [('123 Main Trl.', '')])

    def test_suffix_wy(self):
        self.assertParses('The man at 123 Main Wy. was cool.', [('123 Main Wy.', '')])

    def test_suffix_unknown_no_period(self):
        # If the suffix is unknown, the period isn't included
        self.assertParses('The man at 123 Main Wacky. was cool.', [('123 Main Wacky', '')])

    def test_postdir_n(self):
        self.assertParses('It happened at the garden, 1075 Lake Blvd. N.', [('1075 Lake Blvd. N.', '')])

    def test_postdir_s(self):
        self.assertParses('It happened at the garden, 1075 Lake Blvd. S.', [('1075 Lake Blvd. S.', '')])

    def test_postdir_e(self):
        self.assertParses('It happened at the garden, 1075 Lake Blvd. E.', [('1075 Lake Blvd. E.', '')])

    def test_postdir_w(self):
        self.assertParses('It happened at the garden, 1075 Lake Blvd. W.', [('1075 Lake Blvd. W.', '')])

    def test_postdir_nw(self):
        self.assertParses('It happened at the garden, 1075 Lake Blvd. NW.', [('1075 Lake Blvd. NW.', '')])

    def test_postdir_ne(self):
        self.assertParses('It happened at the garden, 1075 Lake Blvd. NE.', [('1075 Lake Blvd. NE.', '')])

    def test_postdir_sw(self):
        self.assertParses('It happened at the garden, 1075 Lake Blvd. SW.', [('1075 Lake Blvd. SW.', '')])

    def test_postdir_se(self):
        self.assertParses('It happened at the garden, 1075 Lake Blvd. SE.', [('1075 Lake Blvd. SE.', '')])

    def test_postdir_period_nw(self):
        self.assertParses('It happened at the garden, 1075 Lake Blvd. N.W.', [('1075 Lake Blvd. N.W.', '')])

    def test_postdir_period_ne(self):
        self.assertParses('It happened at the garden, 1075 Lake Blvd. N.E.', [('1075 Lake Blvd. N.E.', '')])

    def test_postdir_period_sw(self):
        self.assertParses('It happened at the garden, 1075 Lake Blvd. S.W.', [('1075 Lake Blvd. S.W.', '')])

    def test_postdir_period_se(self):
        self.assertParses('It happened at the garden, 1075 Lake Blvd. S.E.', [('1075 Lake Blvd. S.E.', '')])

    def test_postdir_one_word_street(self):
        self.assertParses('9421 Wabash SW', [('9421 Wabash SW', '')])

    def test_postdir_one_word_street_numbered(self):
        self.assertParses('9421 18th SW', [('9421 18th SW', '')])

    def test_postdir_two_word_street(self):
        self.assertParses('9421 Home Run SW', [('9421 Home Run SW', '')])

    def test_postdir_two_word_street_numbered(self):
        self.assertParses('9421 18th St. SW', [('9421 18th St. SW', '')])

    def test_postdir_central_park_w(self):
        self.assertParses('It happened at 32 West Central Park Avenue W.', [('32 West Central Park Avenue W.', '')])

    def test_postdir_with_in_prefix_washington_dc01(self):
        self.assertParses('It happened on the 600 block of H Street in northeast D.C. and stuff.', [('600 block of H Street northeast', '')])

    def test_postdir_with_in_prefix_washington_dc02(self):
        self.assertParses('It happened on the 600 block of H Street in northeast Washington.', [('600 block of H Street northeast', '')])

    def test_postdir_with_in_prefix_washington_dc03(self):
        self.assertParses('It happened on the 600 block of H Street in NE Washington.', [('600 block of H Street NE', '')])

    def test_postdir_with_in_prefix_washington_dc04(self):
        self.assertParses('It happened on the 600 block of H Street in the NE quadrant', [('600 block of H Street NE', '')])

    def test_postdir_with_in_prefix_washington_dc05(self):
        self.assertParses('It happened on the 600 block of H Street in the NE quadrant', [('600 block of H Street NE', '')])

    def test_postdir_with_in_prefix_washington_dc06(self):
        self.assertParses('It happened on the 600 block of H Street, in northeast D.C. and stuff.', [('600 block of H Street northeast', '')])

    def test_postdir_with_in_prefix_washington_dc07(self):
        self.assertParses('It happened on the 600 block of H Street, in northeast Washington.', [('600 block of H Street northeast', '')])

    def test_postdir_with_in_prefix_washington_dc08(self):
        self.assertParses('It happened on the 600 block of H Street, in NE Washington.', [('600 block of H Street NE', '')])

    def test_postdir_with_in_prefix_washington_dc09(self):
        self.assertParses('It happened on the 600 block of H Street, in the NE quadrant', [('600 block of H Street NE', '')])

    def test_postdir_with_in_prefix_washington_dc10(self):
        self.assertParses('It happened on the 600 block of H Street, in the NE quadrant', [('600 block of H Street NE', '')])

    def test_postdir_with_in_prefix_washington_dc11(self):
        self.assertParses('It happened on the 600 block of H Street, in far northeast Washington.', [('600 block of H Street northeast', '')])

    def test_postdir_seattle(self):
        self.assertParses('Sunday, August 24 at Camp Long, 5200 35th Ave. SW.', [('5200 35th Ave. SW.', '')])

    def test_postdir_comma(self):
        self.assertParses('It happened at 123 Main St., NE, yesterday.', [('123 Main St., NE', '')])

    def test_postdir_not_greedy1(self):
        self.assertParses('at 1620 S. Jackson St. Executive Director Hilary Stern said', [('1620 S. Jackson St.', '')])

    def test_postdir_not_greedy2(self):
        # False positive: fix this?
        self.assertParses('at 1620 S. Jackson St., Executive Director Hilary Stern said', [('1620 S. Jackson St.', 'Executive Director Hilary Stern')])

    def test_postdir_neighborhood(self):
        # False positives: fix?
        self.assertParses('Start at Prezza, 24 Fleet St., North End, 6:30 p.m. $50.', [('Start at Prezza', ''), ('24 Fleet St.', 'North End')])

    def test_one_letter_street(self):
        self.assertParses('It happened at 77 K St.', [('77 K St.', '')])

    def test_one_letter_street_postdir(self):
        self.assertParses('It happened at 77 K St. NE.', [('77 K St. NE.', '')])

    def test_one_letter_street_avenue_x(self):
        self.assertParses('It happened at 1823 Avenue X.', [('1823 Avenue X', '')])

    def test_one_letter_street_avenue_x_abbreviated1(self):
        self.assertParses('It happened at 1823 Ave. X.', [('1823 Ave. X', '')])

    def test_one_letter_street_avenue_x_abbreviated2(self):
        self.assertParses('It happened at 1823 Ave X.', [('1823 Ave X', '')])

    def test_one_letter_street_avenue_x_control(self):
        self.assertParses('It happened at 1823 Main Ave. X marks the spot.', [('1823 Main Ave.', '')])

    def test_one_letter_sanity_check(self):
        self.assertParses('More than 77 ATLASES.', [])

    def test_one_letter_sanity_check2(self):
        self.assertParses('Home prices in 20 U.S. metropolitan areas dropped 15.8 percent in May', [])

    def test_abbreviation_mass(self):
        self.assertParses('It happened at 472 Mass. Ave.', [('472 Mass. Ave.', '')])


class FalsePositives(AddressParsing):
    """These are common false positives that the parser is supposed to
    filter out.
    """

    def test_false_positive_st(self):
        # FIXME: why do we want this result?
        self.assertParses('Copyright 2004-2007 Gothamist', [('2004-2007 Gothamist', '')])

    def test_associated_press(self):
        self.assertParses('Copyright 2008 Associated Press', [])

    def test_university_of_texas1(self):
        self.assertParses('She attends University of Texas at Austin.', [])

    def test_university_of_texas2(self):
        # FIXME: this fails, although it looks like it should work.
        # AFAICT it is matching this as an intersection: 'Of Texas'
        # ('Of' is street name, 'Texas' is suffix'), and 'Austin'.
        self.assertParses('She attends University Of Texas at Austin.', [])

    def test_university_of_texas3(self):
        self.assertParses('She attends UNIVERSITY OF TEXAS at Austin.', [])

    def test_date1(self):
        self.assertParses('Posted: Friday, 22 May 2009 1:45PM', [])

    def test_date2(self):
        self.assertParses('Posted: Friday, 22 May, 2009 1:45PM', [])

    def test_date3(self):
        self.assertParses('It is scheduled for 22 May 2009.', [])

    def test_date4(self):
        self.assertParses('It is scheduled for 22 October 2009.', [])

class NumberedStreets(AddressParsing):
    def test_block(self):
        self.assertParses('1500 block of 16th Avenue', [('1500 block of 16th Avenue', '')])

    def test_address(self):
        self.assertParses('1500 16th Avenue', [('1500 16th Avenue', '')])

    def test_street_dir1(self):
        self.assertParses('1500 N. 16th Avenue', [('1500 N. 16th Avenue', '')])

    def test_street_number_only(self):
        self.assertParses('327 E. 93 St.', [('327 E. 93 St.', '')])

    def test_suffix_missing1(self):
        self.assertParses('327 E. 93rd', [('327 E. 93rd', '')])

    def test_suffix_missing2(self):
        self.assertParses('327 East 93rd', [('327 East 93rd', '')])

    def test_suffix_missing_plus_period(self):
        self.assertParses('I live at 327 E. 93rd. Where do you live?', [('327 E. 93rd', '')])

    def test_suffix_no_dir(self):
        self.assertParses('327 93rd', [('327 93rd', '')])

    def test_d_suffix(self):
        self.assertParses('327 93d', [('327 93d', '')])

    def test_street_number_only_no_dir(self):
        self.assertParses('327 93 St.', [('327 93 St.', '')])

    def test_street_number_only_suffix_missing(self):
        self.assertParses('327 E. 93', [('327 E. 93', '')])

    def test_false_positive1(self):
        self.assertParses('150 61 Year Olds', [('61 Year Olds', '')])


class Intersections(AddressParsing):
    def test_and(self):
        self.assertParses('Near Ashland Ave. and Division St.', [('Ashland Ave. and Division St.', '')])

    def test_at(self):
        self.assertParses('Near Ashland Ave. at Division St.', [('Ashland Ave. at Division St.', '')])

    def test_prefix_at(self):
        self.assertParses('At Ashland Ave. and Division St.', [('Ashland Ave. and Division St.', '')])

    def test_prefix_on(self):
        self.assertParses('building on Ashland Ave. and Division St.', [('Ashland Ave. and Division St.', '')])

    def test_prefix_around(self):
        self.assertParses('Around Ashland Ave. and Division St.', [('Ashland Ave. and Division St.', '')])

    def test_prefix_corner_of(self):
        self.assertParses('At the corner of Ashland Ave. and Division St.', [('Ashland Ave. and Division St.', '')])

    def test_area_of(self):
        self.assertParses('In the area of Ashland Ave. and Division St.', [('Ashland Ave. and Division St.', '')])

    def test_prefix_area_surrounding(self):
        self.assertParses('In the area surrounding Ashland Ave. and Division St.', [('Ashland Ave. and Division St.', '')])

    def test_prefix_areas_surrounding(self):
        self.assertParses('In the areas surrounding Ashland Ave. and Division St.', [('Ashland Ave. and Division St.', '')])

    def test_prefix_located_on(self):
        self.assertParses('Holy Family Parish located on Roosevelt and May streets', [('Roosevelt and May', '')])

    def test_prefix_vicinity_of(self):
        self.assertParses('Holy Family Parish located at the vicinity of Roosevelt and May streets', [('Roosevelt and May', '')])

    def test_prefix_ran_down(self):
        self.assertParses('The man punched the people as he ran down Washington Street near Dearborn Street, said police.', [('Washington Street near Dearborn Street', '')])

    def test_prefix_running_down(self):
        self.assertParses('The man punched the people while running down Washington Street near Dearborn Street, said police.', [('Washington Street near Dearborn Street', '')])

    def test_to(self):
        self.assertParses('On November 28th, at 10:31pm, officers from District 2 responded to George Street and Langdon Street for a report of a person shot.', [('George Street and Langdon Street', '')])

    def test_that(self):
        self.assertParses('The firm that Microsoft and Apple both tried to buy.', [('Microsoft and Apple', '')])

    def test_directionals1(self):
        self.assertParses('Near N. Ashland Ave. at W. Division St.', [('N. Ashland Ave. at W. Division St.', '')])

    def test_directionals2(self):
        self.assertParses('Near N Ashland Ave. at W Division St.', [('N Ashland Ave. at W Division St.', '')])

    def test_directionals3(self):
        self.assertParses('The el station at N Ashland Ave. at W Division St.', [('N Ashland Ave. at W Division St.', '')])

    def test_address_confusion(self):
        self.assertParses('Around 1200 N. Ashland Ave. at Division St.', [('1200 N. Ashland Ave.', '')])

    def test_intersection1(self):
        self.assertParses('at the intersection of Ashland Ave. and Division St. earlier today', [('Ashland Ave. and Division St.', '')])

    def test_intersection2(self):
        self.assertParses('at the intersection of Ashland Ave. & Division St. earlier today', [('Ashland Ave. & Division St.', '')])

    def test_intersection3(self):
        self.assertParses('at the intersection of Ashland Ave. at Division St. earlier today', [('Ashland Ave. at Division St.', '')])

    def test_intersection4(self):
        self.assertParses('at the intersection of Ashland and Division.', [('Ashland and Division', '')])

    def test_intersection5(self):
        self.assertParses('at the intersection of Ashland near Division.', [('Ashland near Division', '')])

    def test_toward(self):
        self.assertParses('running on Ashland toward Division.', [('Ashland toward Division', '')])

    def test_toward2(self):
        self.assertParses('running on Ashland towards Division.', [('Ashland towards Division', '')])

    def test_north_of(self):
        self.assertParses('on Pulaski Road north of West Lake Street about 3:30 p.m.', [('Pulaski Road north of West Lake Street', '')])

    def test_south_of(self):
        self.assertParses('on Pulaski Road south of West Lake Street about 3:30 p.m.', [('Pulaski Road south of West Lake Street', '')])

    def test_east_of(self):
        self.assertParses('on Pulaski Road east of West Lake Street about 3:30 p.m.', [('Pulaski Road east of West Lake Street', '')])

    def test_west_of(self):
        self.assertParses('on Pulaski Road west of West Lake Street about 3:30 p.m.', [('Pulaski Road west of West Lake Street', '')])

    def test_just_north_of(self):
        self.assertParses('on Pulaski Road just north of West Lake Street about 3:30 p.m.', [('Pulaski Road just north of West Lake Street', '')])

    def test_just_south_of(self):
        self.assertParses('on Pulaski Road just south of West Lake Street about 3:30 p.m.', [('Pulaski Road just south of West Lake Street', '')])

    def test_just_east_of(self):
        self.assertParses('on Pulaski Road just east of West Lake Street about 3:30 p.m.', [('Pulaski Road just east of West Lake Street', '')])

    def test_just_west_of(self):
        self.assertParses('on Pulaski Road just west of West Lake Street about 3:30 p.m.', [('Pulaski Road just west of West Lake Street', '')])

    def test_past(self):
        self.assertParses('on Pulaski Road past West Lake Street about 3:30 p.m.', [('Pulaski Road past West Lake Street', '')])

    def test_just_past(self):
        self.assertParses('on Pulaski Road just past West Lake Street about 3:30 p.m.', [('Pulaski Road just past West Lake Street', '')])

    def test_around(self):
        self.assertParses('on Pulaski Road around West Lake Street about 3:30 p.m.', [('Pulaski Road around West Lake Street', '')])

    def test_crossed(self):
        self.assertParses('as she crossed 122nd Street at Broadway at 3 p.m. while driving', [('122nd Street at Broadway', '')])

    def test_off(self):
        self.assertParses('waiting for a bus on Woodland Road off Eastway Drive late Saturday', [('Woodland Road off Eastway Drive', '')])

    def test_postdir1(self):
        self.assertParses('at Ashland and Division NE', [('Ashland and Division NE', '')])

    def test_postdir2(self):
        self.assertParses('at the corner of 12th St and Maryland Avenue, NE, one block away.', [('12th St and Maryland Avenue, NE', '')])

    def test_postdir3(self):
        self.assertParses('It is Rain City Yoga on Roosevelt and 50th. Earlier this year, the cafe closed.', [('Roosevelt and 50th', '')])

    def test_list_of_intersections(self):
        self.assertParses('The testing will occur in the areas of 18th St & Mission, 22nd St. & Valencia, 23rd St and Folsom, and 18th St and Bryant.', [('18th St & Mission', ''), ('22nd St. & Valencia', ''), ('23rd St and Folsom', ''), ('18th St and Bryant', '')])

    def test_address_multiple_spaces(self):
        self.assertParses('In the area of 18th  St and Mission  Rd', [('18th  St and Mission  Rd', '')])

    def test_one_letter_street_avenue_x(self):
        self.assertParses('At the intersection of Avenue X and Avenue Y.', [('Avenue X and Avenue Y', '')])

    def test_one_letter_street_avenue_x_abbreviated(self):
        self.assertParses('At the intersection of Ave. X and Ave. Y.', [('Ave. X and Ave. Y', '')])

    def test_ignore_intersection_after_between1(self):
        self.assertParses('1060 E 47th St between Ellis and Greenwood Aves', [('1060 E 47th St', '')])

    def test_ignore_intersection_after_between2(self):
        self.assertParses('1060 E 47th St (between Ellis and Greenwood Aves)', [('1060 E 47th St', '')])

    def test_ignore_intersection_after_between_control(self):
        self.assertParses('E 47th St between Ellis and Greenwood Aves', [('E 47th St between Ellis and Greenwood Aves', '')])

class SegmentParsing(AddressParsing):
    def test_basic01(self):
        self.assertParses('Wabash between Adams and Jackson', [('Wabash between Adams and Jackson', '')])

    def test_basic02(self):
        self.assertParses('Wabash from Adams to Jackson', [('Wabash from Adams to Jackson', '')])

    def test_comma01(self):
        self.assertParses('Wabash, between Adams and Jackson', [('Wabash, between Adams and Jackson', '')])

    def test_comma02(self):
        self.assertParses('Wabash, from Adams to Jackson', [('Wabash, from Adams to Jackson', '')])

    def test_comma03(self):
        self.assertParses('Wabash, between Adams, and Jackson', [('Wabash, between Adams, and Jackson', '')])

    def test_comma04(self):
        self.assertParses('Wabash, from Adams, to Jackson', [('Wabash, from Adams, to Jackson', '')])

    def test_withcity01(self):
        self.assertParses('Wabash between Adams and Jackson, Chicago', [('Wabash between Adams and Jackson', 'Chicago')])

    def test_withcity02(self):
        self.assertParses('Wabash between Adams and Jackson in Chicago', [('Wabash between Adams and Jackson', 'Chicago')])

class CityAddressParsing(AddressParsing):
    def test_comma1(self):
        self.assertParses('3000 S. Wabash Ave., Chicago', [('3000 S. Wabash Ave.', 'Chicago')])

    def test_comma2(self):
        self.assertParses('3000 Wabash Ave., Chicago', [('3000 Wabash Ave.', 'Chicago')])

    def test_comma3(self):
        self.assertParses('3000 Wabash Ave.,    Chicago', [('3000 Wabash Ave.', 'Chicago')])

    def test_in1(self):
        self.assertParses('3000 S. Wabash Ave. in Chicago', [('3000 S. Wabash Ave.', 'Chicago')])

    def test_in2(self):
        self.assertParses('3000 Wabash Ave. in Chicago', [('3000 Wabash Ave.', 'Chicago')])

    def test_in_comma1(self):
        self.assertParses('3000 Wabash Ave., in Chicago', [('3000 Wabash Ave.', 'Chicago')])

    def test_in_comma2(self):
        self.assertParses('3000 Wabash Ave.,    in Chicago', [('3000 Wabash Ave.', 'Chicago')])

    def test_multiple(self):
        self.assertParses('3000 Wabash Ave. in Chicago and 123 Main St. in Boston', [('3000 Wabash Ave.', 'Chicago'), ('123 Main St.', 'Boston')])

    def test_intersection1(self):
        self.assertParses('at Adams and Wabash in Chicago', [('Adams and Wabash', 'Chicago')])

    def test_intersection2(self):
        self.assertParses('at Adams and Wabash, Chicago', [('Adams and Wabash', 'Chicago')])

    def test_postdir_comma1(self):
        self.assertParses('3000 Wabash Ave., SW, Chicago', [('3000 Wabash Ave., SW', 'Chicago')])

    def test_postdir_comma2(self):
        self.assertParses('3000 Wabash Ave., SW, in Chicago', [('3000 Wabash Ave., SW', 'Chicago')])

    def test_abbreviation_mass(self):
        self.assertParses('It happened at 472 Mass. Ave. in Cambridge', [('472 Mass. Ave.', 'Cambridge')])

    def test_hyphen(self):
        self.assertParses('Happened at 121 Maple Street, Croton-on-Hudson', [('121 Maple Street', 'Croton-on-Hudson')])

    def test_uppercase_named_street(self):
        # Not very likeyl to fix this.
        # It's possible to fix by changing
        #[A-Z]\b              # Single-letter street name (e.g., K St. in DC)
        # to:
        #[A-Z]+\b              # Single-letter street name (e.g., K St. in DC)
        # ... around line 86 of addresses.py, but that breaks 
        # test_one_letter_sanity_check()
        self.assertParses('2826 S. WENTWORTH', [('2826 S. WENTWORTH', '')])


class TestPhraseGrabber(unittest.TestCase):

    def test_loose_phrase_grabber(self):
        text = 'on the South Chicago Ave on the 7400 block in Chicago, IL'
        phrases = ['Chicago', 'South Chicago']
        grabber = loose_phrase_grabber(phrases)
        self.assertEqual(grabber(text),
                         [(7, 20, 'South Chicago'), (46, 53, 'Chicago')])

    def test_paranoid_phrase_grabber(self):
        text = 'on the <x>South Chicago Ave</x> on the 7400 block in <x>Chicago, IL</x> ... but <a>Chicago is OK</a>'
        phrases = ['Chicago', 'South Chicago']
        grabber = paranoid_phrase_grabber(phrases, '<x>', '</x>')
        self.assertEqual(grabber(text),
                         [(83, 90, 'Chicago')])



class TestPhraseTagger(unittest.TestCase):
    def test_double_matching(self):
        # Make sure matching behaves as greedily as possible
        places = ['Lake View', 'Lake View East']
        text = 'In Lake View East today, a Lake View man...'
        tag = phrase_tagger(places)
        self.assertEqual(tag(text), 'In <span>Lake View East</span> today, a <span>Lake View</span> man...')

    def test_empty_phrases(self):
        # Make sure an empty phrase list doesn't result in matching everything
        phrases = []
        text = 'In Lake View East today, a Lake View man...'
        tag = phrase_tagger(phrases)
        self.assertEqual(tag(text), text)

    def test_matched_phrases_begin(self):
        # Don't try to re-highlight things that have already been highlighted
        phrases = ['South Chicago']
        text = 'on the <addr>South Chicago Ave on the 7400 block</addr>...'
        tag = phrase_tagger(phrases, pre='<addr>', post='</addr>')
        self.assertEqual(tag(text), text)

    def test_matched_phrases_end(self):
        # Don't try to re-highlight things that have already been highlighted
        phrases = ['South Chicago']
        text = 'on the <addr>7400 block of South Chicago</addr>...'
        tag = phrase_tagger(phrases, pre='<addr>', post='</addr>')
        self.assertEqual(tag(text), text)

    def test_matched_phrases_middle(self):
        # Don't try to re-highlight things that have already been highlighted
        phrases = ['South Chicago']
        text = 'on the <addr>7400 block of South Chicago Ave</addr>...'
        tag = phrase_tagger(phrases, pre='<addr>', post='</addr>')
        self.assertEqual(tag(text), text)

    def test_matched_phrases_middle__loose(self):
        # DO tag things already tagged if paranoid=False.
        phrases = ['South Chicago']
        text = 'on the <addr>7400 block of South Chicago Ave</addr>...'
        tag = phrase_tagger(phrases, pre='<addr>', post='</addr>', paranoid=False)
        self.assertEqual(
            tag(text),
            'on the <addr>7400 block of <addr>South Chicago</addr> Ave</addr>...'
            )


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_datelines
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.nlp.datelines import guess_datelines
import unittest

class DatelineTestCase(unittest.TestCase):
    def assertDatelines(self, text, expected):
        self.assertEqual(guess_datelines(text), expected)

    def test_basic1(self):
        self.assertDatelines('CHICAGO -- Something happened', ['CHICAGO'])

    def test_basic2(self):
        self.assertDatelines('CHICAGO-- Something happened', ['CHICAGO'])

    def test_basic3(self):
        self.assertDatelines('CHICAGO --Something happened', ['CHICAGO'])

    def test_basic4(self):
        self.assertDatelines('CHICAGO--Something happened', ['CHICAGO'])

    def test_lowercase1(self):
        self.assertDatelines('chicago -- Something happened', [])

    def test_lowercase2(self):
        self.assertDatelines('That was in Chicago -- where something happened', [])

    def test_emdash1(self):
        self.assertDatelines('CHICAGO\x97Something happened', ['CHICAGO'])

    def test_emdash2(self):
        self.assertDatelines('CHICAGO \x97Something happened', ['CHICAGO'])

    def test_emdash3(self):
        self.assertDatelines('CHICAGO  \x97Something happened', ['CHICAGO'])

    def test_emdash4(self):
        self.assertDatelines(u'CHICAGO \u2015 Something happened', ['CHICAGO'])

    def test_emdash5(self):
        self.assertDatelines(u'CHICAGO\xa0--\xa0Something happened', ['CHICAGO'])

    def test_emdash6(self):
        self.assertDatelines(u'CHICAGO \xa0--\xa0 Something happened', ['CHICAGO'])

    def test_html_entity_dash1(self):
        self.assertDatelines('CHICAGO &#8213; Something happened', ['CHICAGO'])

    def test_html_entity_dash2(self):
        self.assertDatelines('CHICAGO &#151; Something happened', ['CHICAGO'])

    def test_html_entity_dash3(self):
        self.assertDatelines('CHICAGO &#x97; Something happened', ['CHICAGO'])

    def test_multi_word_dateline1(self):
        self.assertDatelines('SAN FRANCISCO -- Something happened', ['SAN FRANCISCO'])

    def test_multi_word_dateline2(self):
        self.assertDatelines('SOUTH SAN FRANCISCO -- Something happened', ['SOUTH SAN FRANCISCO'])

    def test_comma_periods(self):
        self.assertDatelines('CHESTERFIELD, S.C. -- Something happened', ['CHESTERFIELD, S.C.'])

    def test_comma_no_space(self):
        self.assertDatelines('CHESTERFIELD,S.C. -- Something happened', ['CHESTERFIELD,S.C.'])

    def test_lowercase(self):
        self.assertDatelines('Lowercase -- Something happened', [])

    def test_start_of_line1(self):
        self.assertDatelines('blah blah\nCHICAGO -- Something happened', ['CHICAGO'])

    def test_start_of_line2(self):
        self.assertDatelines('blah blah\n<b>CHICAGO -- Something happened', ['CHICAGO'])

    def test_start_of_line_p(self):
        self.assertDatelines('<div>BY ASSOCIATED PRESS</div><p>CHICAGO -- Something happened', ['CHICAGO'])
        self.assertDatelines('<div>BY ASSOCIATED PRESS</div><p>CHICAGO -- Something happened', ['CHICAGO'])

    def test_start_of_line_div(self):
        self.assertDatelines('<div>BY ASSOCIATED PRESS</div><div>CHICAGO -- Something happened', ['CHICAGO'])

    def test_start_of_line_div_then_more1(self):
        self.assertDatelines('<div><span>CHICAGO -- </span>Something happened', ['CHICAGO'])

    def test_start_of_line_div_then_more2(self):
        self.assertDatelines('<br><div><span>CHICAGO -- </span>Something happened', ['CHICAGO'])

    def test_start_of_line_div_then_more3(self):
        self.assertDatelines('<div> Reporting<br>Rafael Romo </div> <span> CHICAGO -- </span> Something happened', ['CHICAGO'])

    def test_second_word_lowercase(self):
        self.assertDatelines('Associated Press Writer<br><br><div>KANDAHAR, Afghanistan -- Something happened', ['KANDAHAR, Afghanistan'])

    def test_news_outlet_1(self):
        self.assertDatelines('CHICAGO (Aurora Beacon News) -- Something happened', ['CHICAGO'])

    def test_news_outlet_2(self):
        self.assertDatelines('CHICAGO (STNG) -- Something happened', ['CHICAGO'])

    def test_news_outlet_3(self):
        self.assertDatelines('CHICAGO (CBS) -- Something happened', ['CHICAGO'])

    def test_news_outlet_4(self):
        self.assertDatelines('CHICAGO (ABC) -- Something happened', ['CHICAGO'])

    def test_news_outlet_5(self):
        self.assertDatelines('CHICAGO (FOX) -- Something happened', ['CHICAGO'])

    def test_news_outlet_6(self):
        self.assertDatelines('CHICAGO (AP) -- Something happened', ['CHICAGO'])

    def test_news_outlet_7(self):
        self.assertDatelines('CHICAGO (Associated Press) -- Something happened', ['CHICAGO'])

    def test_news_outlet_8(self):
        self.assertDatelines('CHICAGO (Post-Tribune) -- Something happened', ['CHICAGO'])

    def test_news_outlet_9(self):
        self.assertDatelines('CHICAGO (Chicago Sun-Times) -- Something happened', ['CHICAGO'])

    def test_news_outlet_10(self):
        self.assertDatelines('CHICAGO (Chicago Tribune) -- Something happened', ['CHICAGO'])

    def test_news_outlet_11(self):
        self.assertDatelines('CHICAGO (Sports Network) -- Something happened', ['CHICAGO'])

    def test_news_outlet_12(self):
        self.assertDatelines('CHICAGO (BCN) -- Something happened', ['CHICAGO'])

    def test_timestamp_prefix1(self):
        self.assertDatelines('(07-17) 13:09 PDT BERKELEY -- Something happened', ['BERKELEY'])

    def test_timestamp_prefix2(self):
        self.assertDatelines('(07-17) 13:09 MDT BERKELEY -- Something happened', ['BERKELEY'])

    def test_timestamp_prefix3(self):
        self.assertDatelines('(07-17) 13:09 CDT BERKELEY -- Something happened', ['BERKELEY'])

    def test_timestamp_prefix4(self):
        self.assertDatelines('(07-17) 13:09 EDT BERKELEY -- Something happened', ['BERKELEY'])

    def test_timestamp_prefix5(self):
        self.assertDatelines('(07-17) 13:09 PST BERKELEY -- Something happened', ['BERKELEY'])

    def test_timestamp_prefix6(self):
        self.assertDatelines('(07-17) 13:09 MST BERKELEY -- Something happened', ['BERKELEY'])

    def test_timestamp_prefix7(self):
        self.assertDatelines('(07-17) 13:09 CST BERKELEY -- Something happened', ['BERKELEY'])

    def test_timestamp_prefix8(self):
        self.assertDatelines('(07-17) 13:09 EST BERKELEY -- Something happened', ['BERKELEY'])

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = dbf
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Functions that deal with DBF files.
"""

import struct, datetime, decimal, itertools

# From http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/362715
def reader(f, strip_values=False):
    """Returns an iterator over records in a Xbase DBF file.

    The first row returned contains the field names.
    The second row contains field specs: (type, size, decimal places).
    Subsequent rows contain the data records.
    If a record is marked as deleted, it is skipped.

    File should be opened for binary reads.

    If strip_values is True, then all string values will be stripped of leading
    and trailing whitespace.

    Example usage::

        f = open('/path/to/somefile.dbf', 'rb')
        db = list(reader(f))
        f.close()
        for record in db:
            print record
        fieldnames, fieldspecs, records = db[0], db[1], db[2:]
    """
    # See DBF format spec at:
    #     http://www.pgts.com.au/download/public/xbase.htm#DBF_STRUCT

    numrec, lenheader = struct.unpack('<xxxxLH22x', f.read(32))    
    numfields = (lenheader - 33) // 32

    fields = []
    for fieldno in xrange(numfields):
        name, typ, size, deci = struct.unpack('<11sc4xBB14x', f.read(32))
        name = name.replace('\0', '')       # eliminate NULs from string   
        fields.append((name, typ, size, deci))
    yield [field[0] for field in fields]
    yield [tuple(field[1:]) for field in fields]

    terminator = f.read(1)
    if terminator != '\r':
        raise ValueError('Got unhandled terminator %r' % terminator)

    fields.insert(0, ('DeletionFlag', 'C', 1, 0))
    fmt = ''.join(['%ds' % fieldinfo[2] for fieldinfo in fields])
    fmtsiz = struct.calcsize(fmt)
    for i in xrange(numrec):
        record = struct.unpack(fmt, f.read(fmtsiz))
        if record[0] != ' ':
            continue                        # deleted record
        result = []
        for (name, typ, size, deci), value in itertools.izip(fields, record):
            if name == 'DeletionFlag':
                continue
            if typ == "N":
                value = value.replace('\0', '').lstrip()
                if value == '':
                    value = 0
                elif deci:
                    value = decimal.Decimal(value)
                else:
                    value = int(value)
            elif typ == 'D':
                try:
                    y, m, d = int(value[:4]), int(value[4:6]), int(value[6:8])
                except ValueError:
                    value = None
                else:
                    value = datetime.date(y, m, d)
            elif typ == 'L':
                value = (value in 'YyTt' and 'T') or (value in 'NnFf' and 'F') or '?'
            elif strip_values:
                value = value.strip()
            result.append(value)
        yield result

def dict_reader(f, strip_values=False):
    """
    Returns an iterator that yields a dictionary for every record in the given
    file-like object.
    
    Make sure the given object is a DBF file and was opened in binary mode --
    open('foo', 'rb').
    """
    r = reader(f, strip_values)
    fields = r.next()
    specs = r.next()
    for record in r:
        yield dict(zip(fields, record))

def writer(f, fieldnames, fieldspecs, records):
    """ Return a string suitable for writing directly to a binary dbf file.

    File f should be open for writing in a binary mode.

    Fieldnames should be no longer than ten characters and not include \x00.
    Fieldspecs are in the form (type, size, deci) where:

    * type is one of:

     -  C for ascii character data

     -  M for ascii character memo data (real memo fields not supported)

     -  D for datetime objects

     -  N for ints or decimal objects

     -  L for logical values 'T', 'F', or '?'

    * size is the field width

    * deci is the number of decimal places in the provided decimal object

    Records can be an iterable over the records (sequences of field values).
    """
    # header info
    ver = 3
    now = datetime.datetime.now()
    yr, mon, day = now.year-1900, now.month, now.day
    numrec = len(records)
    numfields = len(fieldspecs)
    lenheader = numfields * 32 + 33
    lenrecord = sum(field[1] for field in fieldspecs) + 1
    hdr = struct.pack('<BBBBLHH20x', ver, yr, mon, day, numrec, lenheader, lenrecord)
    f.write(hdr)
                      
    # field specs
    for name, (typ, size, deci) in itertools.izip(fieldnames, fieldspecs):
        name = name.ljust(11, '\x00')
        fld = struct.pack('<11sc4xBB14x', name, typ, size, deci)
        f.write(fld)

    # terminator
    f.write('\r')

    # records
    for record in records:
        f.write(' ')                        # deletion flag
        for (typ, size, deci), value in itertools.izip(fieldspecs, record):
            if value is None:
                value = ' ' * size
            elif typ == "N":
                value = str(value).rjust(size, ' ')
            elif typ == 'D':
                value = value.strftime('%Y%m%d')
            elif typ == 'L':
                value = str(value)[0].upper()
            else:
                value = str(value)[:size].ljust(size, ' ')
            assert len(value) == size
            f.write(value)

    # End of file
    f.write('\x1A')

if __name__ == "__main__":
    import sys
    from pprint import pprint
    f = open(sys.argv[1], 'rb')
    for record in dict_reader(f, True):
        pprint(record)

########NEW FILE########
__FILENAME__ = excel
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Utilities for reading Microsoft Excel files.

Only handles old-style excel files.

TODO: use http://packages.python.org/openpyxl/ to handle new-style
xslx files.
"""

import xlrd
import datetime

class ExcelDictReader(object):
    """
    Provides an API that lets you iterate over every row in an Excel worksheet,
    much like csv.DictReader. This assumes that the worksheet is a simple table
    with a single header row at the top.

    header_row_num is the zero-indexed row number of the headers. (Note that
    you can specify the headers manually by using the "custom_headers"
    argument.)

    start_row_num is the zero-indexed row number of where the data starts.

    use_last_header_if_duplicate, either True or False, dictates the behavior
    to use in the case of duplicate column headers. If True, then the *last*
    column's value will be used. If False, then the *first* column's value will
    be used. Note that there's no way to access the other column, either way.

    custom_headers, if given, will be used instead of the values in
    header_row_num. If you provide custom_headers, the value of header_row_num
    will be ignored.

    Example usage::

        reader = ExcelDictReader('/path/to/my.xls', 0, 0, 1)
        for row in reader:
            print row

    This yields dictionaries like::

        {'header1': 'value1', 'header2': 'value2'}

    The first argument can be either a path, or an open file-like object.
    """
    def __init__(self, filename, sheet_index=0, header_row_num=0, start_row_num=0,
            use_last_header_if_duplicate=True, custom_headers=None):

        if hasattr(filename, 'read'):
            self.workbook = xlrd.open_workbook(file_contents=filename.read())
        else:
            self.workbook = xlrd.open_workbook(filename)
        self.sheet_index = sheet_index
        if not start_row_num and not custom_headers:
            # Like csv.DictReader, assume first row is headers.
            start_row_num = header_row_num + 1
        self.header_row, self.start_row = header_row_num, start_row_num
        self.use_last_header_if_duplicate = use_last_header_if_duplicate
        self.custom_headers = custom_headers
        self._fieldnames = custom_headers

    # For consistency with csv.DictReader
    @property
    def fieldnames(self):
        if self._fieldnames is None:
            worksheet = self.workbook.sheet_by_index(self.sheet_index)
            self._fieldnames = [v.value.strip() for v in worksheet.row(self.header_row)]
        return self._fieldnames

    def __iter__(self):
        worksheet = self.workbook.sheet_by_index(self.sheet_index)
        headers = self.fieldnames
        for row_num in xrange(self.start_row, worksheet.nrows):
            data_dict = {}
            for i, cell in enumerate(worksheet.row(row_num)):
                value = cell.value

                # Clean up the value. The xlrd library doesn't convert date
                # values to Python objects automatically, so we have to do that
                # here. Also, strip whitespace from any text field.
                # cell.ctype is documented here:
                # http://www.lexicon.net/sjmachin/xlrd.html#xlrd.Cell-class
                if cell.ctype == 3:
                    try:
                        value = datetime.datetime(*xlrd.xldate_as_tuple(value, self.workbook.datemode))
                    except ValueError:
                        # The datetime module raises ValueError for invalid
                        # dates, like the year 0. Rather than skipping the
                        # value (which would lose data), we just keep it as
                        # a string.
                        pass
                elif cell.ctype == 1:
                    value = value.strip()

                # Only append the value to the dictionary if 
                if self.use_last_header_if_duplicate or headers[i] not in data_dict:
                    data_dict[headers[i]] = value

            yield data_dict

########NEW FILE########
__FILENAME__ = mdb
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Utilities for reading data from Microsoft Access MDB files.

These require the mdbtools binaries, available here:
    http://mdbtools.sourceforge.net/
    http://prdownloads.sourceforge.net/mdbtools/mdbtools-0.5.tar.gz
    sudo apt-get install mdbtools
"""

import csv
from subprocess import Popen, PIPE

def list_tables(filename):
    """
    Returns a list of all the table names in the given MDB filename.
    """
    # Tell it to delimit the names with the pipe character.
    output = Popen(["mdb-tables", "-d", '|', "-t", "table", filename], stdout=PIPE).communicate()[0]
    return [t.strip() for t in output.split('|') if t.strip()]

class TableReader(csv.DictReader):
    """
    Like csv.DictReader, but it takes the MDB filename and table name.
    
    Example usage:
        for row in TableReader('mydb.mdb', 'some_table'):
            print row
    """
    def __init__(self, filename, table_name):
        f = Popen(['mdb-export', '-D', '%Y-%m-%d', filename, table_name], stdout=PIPE).stdout
        csv.DictReader.__init__(self, f)

########NEW FILE########
__FILENAME__ = pdftotext
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Utilities for reading data from PDF files.

These require the pdftotext binary, available in the Xpdf package:
    http://www.foolabs.com/xpdf/download.html
"""

import os

PDFTOTEXT_BINARY = 'pdftotext'

def pdf_to_text(filename, keep_layout=True, raw=False):
    """
    Returns the text of the PDF with the given filename on the local filesystem.
    """
    if keep_layout and raw:
        raise ValueError('The "keep_layout" and "raw" arguments may not be used together')
    options = []
    if keep_layout:
        options.append('-layout')
    if raw:
        options.append('-raw')
    cmd = "%s %s '%s' -" % (PDFTOTEXT_BINARY, ' '.join(options), filename)
    return os.popen(cmd).read()

def pdfstring_to_text(pdf_string, keep_layout=True, raw=False):
    """
    Returns the text of the given PDF (provided as a string).
    """
    import os
    from tempfile import mkstemp
    fd, name = mkstemp()
    fp = os.fdopen(fd, 'wb')
    fp.write(pdf_string)
    fp.close()
    try:
        result = pdf_to_text(name, keep_layout, raw)
    finally:
        os.unlink(name)
    return result

########NEW FILE########
__FILENAME__ = unicodecsv
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Support for reading CSV as Unicode objects.

This module is necessary because Python's csv library doesn't support reading
Unicode strings.  STILL true as of Python 2.7.
"""

# This code is derived from code in the Python documentation:
# http://www.python.org/doc/2.5.2/lib/csv-examples.html
# The changes we've made are to implement a DictReader instead of a normal
# Reader.
# 
# The code is Copyright (c) 2001, 2002, 2003, 2004, 2005, 2006 Python Software
# Foundation; All Rights Reserved
# See the full license at http://www.python.org/psf/license/

import csv
import codecs

class UTF8Recoder(object):
    """
    Iterator that reads an encoded stream and reencodes the input to UTF-8.
    """
    def __init__(self, f, encoding):
        self.reader = codecs.getreader(encoding)(f)

    def __iter__(self):
        return self

    def next(self):
        return self.reader.next().encode('utf-8')


class UnicodeReader(object):
    """
    A CSV reader which will iterate over lines in the CSV file "f",
    which is encoded in the given encoding. Results will always be Unicode
    objects instead of bytestrings.
    """

    def __init__(self, f, dialect=csv.excel, encoding='utf-8', **kwargs):
        f = UTF8Recoder(f, encoding)
        self.reader = csv.reader(f, dialect=dialect, **kwargs)

    def next(self):
        row = self.reader.next()
        row = [unicode(s, 'utf-8') for s in row]
        return row

    def __iter__(self):
        return self


class UnicodeDictReader(UnicodeReader):
    """
    A CSV dict reader which will iterate over lines in the CSV file "f",
    which is encoded in the given encoding. Results will always be Unicode
    objects instead of bytestrings.
    """

    def __init__(self, f, fieldnames=None, dialect=csv.excel, encoding='utf-8', **kwargs):
        super(UnicodeDictReader, self).__init__(
            f, dialect=dialect, encoding=encoding, **kwargs)
        if fieldnames:
            self.fieldnames = fieldnames
        else:
            throwaway_reader = csv.DictReader(f)
            self.fieldnames = throwaway_reader.fieldnames
            del(throwaway_reader)
            # Note we are relying on a side effect here:
            # csv.DictReader(f) advanced f to the next line.

    def next(self):
        row = super(UnicodeDictReader, self).next()
        return dict(zip(self.fieldnames, row))

########NEW FILE########
__FILENAME__ = log
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

# This module is registered by ebdata.retrieval.__init__ so that
# client code can simply use 'import logging' instead of having to set up
# the logging infrastructure on a case-by-case basis.
#
# Client code should use this like so:
#     import logging
#     # logger name should start with 'eb.retrieval.' to use this.
#     logger = logging.getLogger('eb.retrieval.scrapers.chicago.crime')
#     logger.warn('...')
#     logger.info('...')


"""
Logging setup for ebdata scrapers.

Warning, this gets done as an import-time side-effect!
"""

from django.conf import settings
import logging
import logging.handlers

# Set up the file handler.
logfile = logging.FileHandler(settings.SCRAPER_LOGFILE_NAME)
logfile.setLevel(logging.INFO)
formatter = logging.Formatter('%(asctime)s %(name)-12s: %(levelname)-8s %(message)s')
logfile.setFormatter(formatter)

# Set up the e-mail handler.
class EbdataSMTPHandler(logging.handlers.SMTPHandler):
    def getSubject(self, record):
        return '%s[Log error]: %s' % (settings.EMAIL_SUBJECT_PREFIX, record.name)

emailer = EbdataSMTPHandler(settings.EMAIL_HOST, "example@example.com",
    [a[1] for a in settings.ADMINS], '')
emailer.setLevel(logging.WARNING)

# Add the handler to the 'eb.retrieval' logger. This means that only loggers
# whose names begin with 'eb.retrieval.' will get this functionality.

eb_root_logger = logging.getLogger('eb.retrieval')
if logfile not in eb_root_logger.handlers:
    eb_root_logger.addHandler(logfile)
if settings.SCRAPER_LOG_DO_EMAIL_ERRORS and emailer not in eb_root_logger.handlers:
    eb_root_logger.addHandler(emailer)

# Set the logger's threshold. By default, it seems to ignore everything
# under the level WARNING.
eb_root_logger.setLevel(logging.INFO)

########NEW FILE########
__FILENAME__ = log_debug
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Import this file to send all 'eb.retrieval' messages (of any level, including
logger.DEBUG) to the console. This is convenient for debugging.
"""

from ebdata.retrieval import log
import logging

# Send all DEBUG (and above) messages to the console.
printer = logging.StreamHandler()
printer.setLevel(logging.DEBUG)
printer.setFormatter(logging.Formatter("%(levelname)s %(message)s"))

eb_root_logger = logging.getLogger('eb.retrieval')
eb_root_logger.setLevel(logging.DEBUG)
eb_root_logger.addHandler(printer)

# ... but don't log to console more than once, which happens if a
# parent logger is already set up with a StreamHandler.
_logger = eb_root_logger.parent
while _logger is not None:
    to_remove = []
    for handler in _logger.handlers:
        if isinstance(handler, logging.StreamHandler) \
                and handler.stream.name == '<stderr>':
            to_remove.append(handler)
    for handler in to_remove:
        _logger.removeHandler(handler)
    _logger = _logger.parent

# Remove the e-mail handler.
eb_root_logger.removeHandler(log.emailer)

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from django.db import models
from ebpub.db.models import NewsItem, Schema

LIST_PAGE = 1
DETAIL_PAGE = 2
PAGE_TYPE_CHOICES = (
    (LIST_PAGE, 'list'),
    (DETAIL_PAGE, 'detail')
)

class ScrapedPage(models.Model):
    page_type = models.SmallIntegerField(choices=PAGE_TYPE_CHOICES)
    schema = models.ForeignKey(Schema)
    when_crawled = models.DateTimeField()
    url = models.URLField()
    html = models.TextField()

    def __unicode__(self):
        return u'HTML from %s - %s' % (self.url, self.when_crawled)

class NewsItemHistoryManager(models.Manager):
    def save_page_if_needed(self, page):
        """Call save() on a Page object if it hasn't already been saved."""
        if page is not None and page.pk is None:
            page.save()

    def record_history(self, news_item, page):
        """Associates a page with a NewsItem."""
        self.save_page_if_needed(page)
        self.create(news_item=news_item, page=page)

class NewsItemHistory(models.Model):
    """Essentially a ManyToMany relation between ScrapedPage and NewsItem"""
    news_item = models.ForeignKey(NewsItem)
    page = models.ForeignKey(ScrapedPage)
    objects = NewsItemHistoryManager()

########NEW FILE########
__FILENAME__ = retrievers
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Retriever classes.

A Retriever class simply knows how to retrieve a resource off of the Web. It
knows nothing about *scraping*, i.e., parsing the contents of Web pages.
"""

import os
import httplib2
from Cookie import SimpleCookie, CookieError
from urllib import urlencode
from urlparse import urljoin
import logging
import time
import socket

class RetrievalError(Exception):
    "Couldn't retrieve data"
    pass

class PageNotFoundError(RetrievalError):
    "Couldn't retrieve data"
    pass


class Default:
    # Used to determine whether a default argument was given to Retriever.__init__().
    pass

LOG_ENTRY_FMT = "%(timestamp)s\t%(method)s\t%(uri)s\t%(status)s\t%(elapsed)s\t%(size)s"

class Retriever(object):
    'HTTP client.'
    def __init__(self, user_agent=None, cache=Default, timeout=20, sleep=0):
        # Use cache=None to explicitly turn off caching.
        # If you don't provide cache, then it will cache in
        # settings.HTTP_CACHE, or '/tmp/eb_scraper_cache' if
        # the setting is undefined.
        # sleep should be the number of seconds to sleep between requests.
        from django.conf import settings
        if cache is Default:
            cache = getattr(settings, 'HTTP_CACHE', '/tmp/eb_scraper_cache')
        self.cache_hit = False
        self.h = httplib2.Http(cache, timeout=timeout)
        self.h.force_exception_to_status_code = False
        self.h.follow_redirects = False
        self.user_agent = user_agent or 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.0)'
        self._cookies = SimpleCookie()
        self.logger = logging.getLogger('eb.retrieval.retriever')
        self.sleep = sleep

        # Keep track of whether we've downloaded any pages yet.
        # This makes sure we don't sleep before the very first requested page.
        self.page_downloaded = False

    def clear_cookies(self):
        self._cookies = SimpleCookie()

    def fetch_data_and_headers(self, uri, data=None, headers=None, send_cookies=True, follow_redirects=True, raise_on_error=True):
        "Retrieves the resource and returns a tuple of (content, header dictionary)."
        self.cache_hit = False
        # Sleep, if necessary, but only if a page has already been downloaded
        # with this retriever. (We don't want to sleep before the very first
        # request that a retriever makes, because that would be unnecessary.)
        if self.sleep and self.page_downloaded:
            self.logger.debug('Sleeping for %s seconds', self.sleep)
            time.sleep(self.sleep)
        self.page_downloaded = True

        # Prepare the request.
        if not headers:
            headers = {}
        headers['user-agent'] = headers.get('user-agent', self.user_agent)
        if send_cookies and self._cookies:
            # Some broken ASP.NET servers put "\r\n" in there, so we replace
            # that with semicolon to get proper behavior.
            headers['Cookie'] = self._cookies.output(attrs=[], header='').strip().replace('\r\n', ';')
        method = data and "POST" or "GET"
        body = data and urlencode(data) or None
        if method == "POST" and body:
            headers.setdefault('Content-Type', 'application/x-www-form-urlencoded')

        # Get the response.
        resp_headers = None
        for attempt_number in range(3):
            self.logger.debug('Attempt %s: %s %s', attempt_number + 1, method, uri)
            if data:
                self.logger.debug('%r', data)
            try:
                resp_headers, content = self.h.request(uri, method, body=body, headers=headers)
                if resp_headers['status'] == '500':
                    self.logger.debug("Request got a 500 error: %s %s", method, uri)
                    continue # Try again.
                if resp_headers.fromcache:
                    self.cache_hit = True
                break
            except socket.timeout:
                self.logger.debug("Request timed out after %s seconds: %s %s", self.h.timeout, method, uri)
                continue # Try again.
            except socket.error, e:
                self.logger.debug("Got socket error: %s", e)
                continue # Try again.
            except AttributeError, e:
                self.logger.debug("Got httplib bug where socket is None: %s", e)
                continue # Try again
            except httplib2.ServerNotFoundError:
                raise RetrievalError("Could not %s %r: server not found" % (method, uri))
        if resp_headers is None:
            raise RetrievalError("Request timed out 3 times: %s %s" % (method, uri))

        # Raise RetrievalError if necessary.
        if raise_on_error and resp_headers['status'] in ('400', '408', '500'):
            raise RetrievalError("Could not %s %r: HTTP status %s" % (method, uri, resp_headers['status']))
        if raise_on_error and resp_headers['status'] == '404':
            raise PageNotFoundError("Could not %s %r: HTTP status %s" % (method, uri, resp_headers['status']))

        # Set any received cookies.
        if 'set-cookie' in resp_headers:
            try:
                self._cookies.load(resp_headers['set-cookie'])
            except CookieError:
                # Skip invalid cookies.
                pass

        # Handle redirects that weren't caught by httplib2 for whatever reason.
        if follow_redirects and resp_headers['status'] in ('301', '302', '303'):
            try:
                new_location = resp_headers['location']
            except KeyError:
                raise RetrievalError('Got redirect, but the response was missing a "location" header. Headers were: %r' % resp_headers)
            self.logger.debug('Got %s redirect', resp_headers['status'])

            # Some broken Web apps send relative URLs in their "Location"
            # headers in redirects. Detect that and use urljoin() to get a full
            # URL.
            if not new_location.startswith('http://') and not new_location.startswith('https://'):
                new_location = urljoin(uri, new_location)
            # Clear the POST data, if any, so that we do a GET request.
            if data:
                data = {}
                del headers['Content-Type']
            return Retriever.fetch_data_and_headers(self, new_location, data, headers, send_cookies)

        return content, resp_headers

    def fetch_data(self, uri, data=None, headers=None, send_cookies=True, follow_redirects=True, raise_on_error=True):
        "Retrieves the resource and returns it as a raw string."
        return self.fetch_data_and_headers(uri, data, headers, send_cookies, follow_redirects, raise_on_error)[0]

    def get_html(self, *args, **kwargs):
        """Alias for fetch_data, for backward compatibility.
        """
        return self.fetch_data(*args, **kwargs)

    def cached_get_to_file(self, uri, filename):
        """
        Downloads the given URI and saves it to a temporary file. Returns the
        full filename of the temporary file.
        """
        fp = open(filename, 'wb')
        fp.write(self.fetch_data(uri))
        fp.close()
        return filename

    def get_to_tempfile(self, *args, **kwargs):
        """
        Downloads the given URI and saves it to a temporary file. Passes
        all options on to fetch_data(). Returns the full filename of the
        temporary file.
        """
        from tempfile import mkstemp
        fd, name = mkstemp()
        fp = os.fdopen(fd, 'wb')
        fp.write(self.fetch_data(*args, **kwargs))
        fp.close()
        return name

class UnicodeRetriever(Retriever):
    """
    Like Retriever, but fetch_data() returns a Unicode object instead of a
    bytestring. It uses the chardet module to determine the encoding to use.
    """
    def __init__(self, *args, **kwargs):
        # errors can be 'strict', 'ignore' or 'replace'. See Python docs.
        self.error_handling = kwargs.pop('errors', 'strict')
        Retriever.__init__(self, *args, **kwargs)

    def fetch_data_and_headers(self, *args, **kwargs):
        encoding, content, headers = self.fetch_encoding_data_and_headers(*args, **kwargs)
        return content.decode(encoding, self.error_handling), headers

    def fetch_encoding_data_and_headers(self, *args, **kwargs):
        """
        Returns a tuple of (encoding, bytestring, headers).

        This is useful if you don't know whether you want to decode the string
        until *after* calling this method. (Perhaps you want to inspect the
        headers.)
        """
        import chardet
        content, headers = Retriever.fetch_data_and_headers(self, *args, **kwargs)
        guess = chardet.detect(content)
        # Maybe this should take into account guess['confidence']?
        return guess['encoding'], content, headers

########NEW FILE########
__FILENAME__ = base
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from django.db import transaction
from ebdata.nlp.addresses import parse_addresses
from ebdata.retrieval import Retriever
from ebdata.retrieval.utils import convert_entities
from ebpub.db.models import NewsItem
from ebpub.geocoder.base import full_geocode, GeocodingException, ParsingError
from ebpub.utils.text import address_to_block

import datetime
import logging
import pytz
import traceback

local_tz = pytz.timezone(settings.TIME_ZONE)

class ScraperBroken(Exception):
    "Something changed in the underlying data format and broke the scraper."
    pass

class BaseScraper(object):
    """
    Base class for all scrapers in ebdata.retrieval.scrapers.
    """
    logname = 'basescraper'
    sleep = 0
    timeout = 20

    def __init__(self, use_cache=True):
        if not use_cache:
            self.retriever = Retriever(cache=None, sleep=self.sleep, timeout=self.timeout)
        else:
            self.retriever = Retriever(sleep=self.sleep, timeout=self.timeout)
        self.logger = logging.getLogger('eb.retrieval.%s' % self.logname)
        self.start_time = datetime.datetime.now()
        self.num_added = 0
        self.num_changed = 0
        self.num_skipped = 0


    def geocode(self, location_name, **kwargs):
        """
        Tries to geocode the given location string, returning a Point object
        or None.

        Override this if you want to replace with (or fall back to) an
        external geocoding service.

        If the result is ambiguous -- multiple matches -- then tries
        to use optional args to resolve the ambiguity, and if still
        ambiguous, returns the first remaining result.
        """
        try:
            result = full_geocode(location_name, guess=True, **kwargs)
            if result['result']:
                if result['type'] == 'block' and result.get('ambiguous'):
                    self.logger.debug("Invalid Block but valid street for %r; results unlikely to be useful, giving up" % location_name)
                    return None

                return result['result']
        except (GeocodingException, ParsingError):
            self.logger.debug(
                "Could not geocode location: %s: %s" %
                (location_name, traceback.format_exc()))
        return None

    def geocode_if_needed(self, point, location_name, address_text='',
                          **kwargs):
        """
        If either ``point`` or ``location_name`` is not set, try to
        geocode / reverse-geocode as needed to derive one from the
        other.  Returns (point, location_name).

        If neither one is set, try to parse addresses out of
        ``address_text`` and derive both.

        Either value may be None if it can't be determined.

        Any other keyword args are passed to ``full_geocode()``.
        """
        if not point:
            text = convert_entities(location_name or address_text)
            self.logger.debug("...Falling back on geocoding from '%s...'" % text[:50])
            addrs = parse_addresses(text)
            for addr, unused in addrs:
                try:
                    result = self.geocode(addr, **kwargs)
                    if result is not None:
                        point = result['point']
                        self.logger.debug("internally geocoded %r" % addr)
                        # TODO: what if it's a Place?
                        if not location_name:
                            location_name = result['address']
                        break
                except:
                    self.logger.exception('uncaught geocoder exception on %r\n' % addr)
                    continue

        if point and not location_name:
            # Fall back to reverse-geocoding.
            from ebpub.geocoder import reverse
            try:
                block, distance = reverse.reverse_geocode(point)
                self.logger.debug(" Reverse-geocoded point to %r" % block.pretty_name)
                location_name = block.pretty_name
            except reverse.ReverseGeocodeError:
                location_name = None

        return (point, location_name)

    def update(self):
        'Run the scraper.'
        raise NotImplementedError()  # pragma: no cover


    def fetch_data(self, *args, **kwargs):
        return self.retriever.fetch_data(*args, **kwargs)


    def get_html(self, *args, **kwargs):
        """An alias for fetch_data().
        For backward compatibility.
        """
        return self.fetch_data(*args, **kwargs)


    @classmethod
    def parse_html(cls, html):
        from lxml import etree
        from cStringIO import StringIO
        return etree.parse(StringIO(html), etree.HTMLParser())


    @transaction.commit_on_success
    def create_newsitem(self, attributes, **kwargs):
        """
        Creates and saves a NewsItem with the given kwargs. Returns the new
        NewsItem.

        kwargs MUST have the following keys:
        *   title
        *   item_date
        *   location_name AND/OR location

        For any other kwargs whose values aren't provided, this will use
        sensible defaults.

        ``attributes`` is a dictionary to use to populate this
        NewsItem's Attribute objects.

        kwargs MAY have the following keys:

            zipcode, city, and/or state

              used to disambiguate geocoded locations.

            convert_to_block

              convert the given kwargs['location_name']
              to a block level but will try to use the real
              (non-block-level) address for geocoding.
              Default False.

        """

        convert_to_block = kwargs.pop('convert_to_block', False)
        location, location_name = self.geocode_if_needed(
            kwargs.get('location', None),
            kwargs.get('location_name', None),
            zipcode=kwargs.pop('zipcode', None),
            city=kwargs.pop('city', None),
            state=kwargs.pop('state', None),
            convert_to_block=convert_to_block,
            )

        assert location or location_name, "At least one of location or location_name must be provided"

        if convert_to_block:
            location_name = address_to_block(location_name)

        kwargs['location_name'] = location_name
        kwargs['location'] = location

        # Normally we'd just use "schema = kwargs.get('schema', self.schema)",
        # but self.schema will be evaluated even if the key is found in
        # kwargs, which raises an error when using multiple schemas.
        schema = kwargs.get('schema', None) or self.schema

        ni = NewsItem.objects.create(
            schema=schema,
            title=kwargs['title'],
            description=kwargs.get('description', ''),
            url=kwargs.get('url', ''),
            pub_date=kwargs.get('pub_date', self.start_time),
            item_date=kwargs['item_date'],
            location=location,
            location_name=location_name,
            location_object=kwargs.get('location_object', None),
        )
        if attributes is not None:
            ni.attributes = attributes
        self.num_added += 1
        self.logger.info(u'Created NewsItem %s: %s (total created in this scrape: %s)', schema.slug, ni.id, self.num_added)
        return ni


    @transaction.commit_on_success
    def update_existing(self, newsitem, new_values, new_attributes):
        """
        Given an existing NewsItem and dictionaries new_values and
        new_attributes, determines which values and attributes have changed
        and saves the object and/or its attributes if necessary.

        Returns the NewsItem.
        """
        newsitem_updated = False
        # First, check the NewsItem's values.
        for k, v in new_values.items():
            if isinstance(v, datetime.datetime) and v.tzinfo is not None:
                # Django datetime fields are not timezone-aware, so we
                # can't compare them without stripping the zone.
                v = v.astimezone(local_tz).replace(tzinfo=None)
            if getattr(newsitem, k) != v:
                self.logger.debug('ID %s %s changed from %r to %r' % (newsitem.id, k, getattr(newsitem, k), v))
                setattr(newsitem, k, v)
                newsitem_updated = True
        if newsitem_updated:
            newsitem.save()
        else:
            self.logger.debug("No change to %s <%s>" % (newsitem.id, newsitem))
        # Next, check the NewsItem's attributes.
        for k, v in new_attributes.items():
            if isinstance(v, datetime.datetime) and v.tzinfo is not None:
                # Django datetime fields are not timezone-aware, so we
                # can't compare them without stripping the zone.
                v = v.astimezone(local_tz).replace(tzinfo=None)
            if newsitem.attributes.get(k) == v:
                continue
            elif k not in newsitem.attributes:
                self.logger.debug('ID %s %s was missing, setting to %r' %
                                 (newsitem.id, k, v))
            elif newsitem.attributes.get(k) != v:
                self.logger.debug('ID %s %s changed from %r to %r' %
                                 (newsitem.id, k, newsitem.attributes[k], v))
            newsitem.attributes[k] = v
            newsitem_updated = True
        if newsitem_updated:
            self.num_changed += 1
            self.logger.debug('Total changed in this scrape: %s', self.num_changed)
        else:
            self.logger.debug('No changes to NewsItem %s detected', newsitem.id)
            self.num_skipped += 1
        return newsitem


    def create_or_update(self, old_record, attributes, **kwargs):
        """unified API for updating or creating a NewsItem.
        """
        if old_record:
            return self.update_existing(old_record, kwargs, attributes or {})
        else:
            return self.create_newsitem(attributes=attributes, **kwargs)


########NEW FILE########
__FILENAME__ = list_detail
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from base import BaseScraper, ScraperBroken


class SkipRecord(Exception):
    "Exception that signifies a detail record should be skipped over."
    pass

class StopScraping(Exception):
    "Exception that signifies scraping should stop."
    pass

class ListDetailScraper(BaseScraper):
    """
    A screen-scraper optimized for list-detail types of sites.

    A list-detail site is a site that displays a list of records, which might
    be paginated. Each record might have its own page -- a "detail" page -- or
    the list page might display all available information for that record.

    To use this class, subclass it and implement the following:

        * list_pages()
        * Either parse_list() or parse_list_re
        * existing_record()
        * save()

    If the scraped site does not have detail pages, implement the following:

        * has_detail = False

    If the scraped site has detail pages, implement the following:

        * detail_required()
        * get_detail()
        * Either parse_detail() or parse_detail_re

    These are additional, optional hooks:

        * clean_list_record()
        * clean_detail_record()
    """

    ################################
    # MAIN METHODS FOR OUTSIDE USE #
    ################################

    def display_data(self):
        """
        Retrieves all pages, parses them and prints the data as Python
        dictionaries to standard output.

        This is mainly useful for debugging.
        """
        from pprint import pprint
        for d in self.raw_data():
            pprint(d)

    def raw_data(self):
        """
        Iterator that yields current raw data for this scraper.
        Works like update() but doesn't save anything.

        Each record is represented as a {'list', 'detail'} dictionary,
        where `list` is the clean list record and `detail` is the clean
        detail record.
        """
        for page in self.list_pages():
            try:
                for data in self._raw_data(page):
                    yield data
            except StopScraping:
                break

    def _raw_data(self, page):
        for list_record in self.parse_list(page):
            try:
                list_record = self.clean_list_record(list_record)
            except SkipRecord:
                continue
            if self.has_detail:
                try:
                    page = self.get_detail(list_record)
                    detail_record = self.parse_detail(page, list_record)
                    detail_record = self.clean_detail_record(detail_record)
                except SkipRecord:
                    continue
            else:
                detail_record = None
            yield {'list': list_record, 'detail': detail_record}

    def xml_data(self):
        """
        Iterator that yields current raw data for this scraper, as
        serialized XML.
        """
        from xml.sax.saxutils import escape
        yield u'<data>'
        for d in self.raw_data():
            yield u'<object>'
            for datatype in ('list', 'detail'):
                for k, v in d[datatype].items():
                    if not isinstance(v, basestring):
                        v = str(v)
                    yield u'  <att name="%s-%s">%s</att>' % (datatype[0], k, escape(v))
            yield u'</object>'
        yield u'</data>'

    def update(self):
        """
        The main scraping method. This retrieves all pages, parses
        them, calls cleaning hooks, and saves the data.

        Subclasses should not have to override this method.
        """
        self.num_skipped = 0

        self.logger.info("update() in %s started" % str(self.__class__))
        try:
            for page in self.list_pages():
                self.update_from_string(page)
        except StopScraping:
            pass
        finally:
            self.logger.info("update() finished")

    def update_from_string(self, page):
        """
        Runs the equivalent of update() on the given string.

        This is useful if you've got cached versions of content that
        you want to parse; also, update() calls it under the hood.

        Subclasses should not have to override this method.
        """
        for list_record in self.parse_list(page):
            try:
                list_record = self.clean_list_record(list_record)
            except SkipRecord, e:
                self.num_skipped += 1
                self.logger.debug(u"Skipping list record for %r: %s " % (list_record, e))
                continue
            except ScraperBroken, e:
                # Re-raise the ScraperBroken with some addtional helpful information.
                raise ScraperBroken('%r -- %s' % (list_record, e))
            self.logger.debug("Clean list record: %r" % list_record)

            old_record = self.existing_record(list_record)
            self.logger.debug("Existing record: %r" % old_record)

            if self.has_detail and self.detail_required(list_record, old_record):
                self.logger.debug("Detail page is required")
                try:
                    page = self.get_detail(list_record)
                    detail_record = self.parse_detail(page, list_record)
                    detail_record = self.clean_detail_record(detail_record)
                except SkipRecord, e:
                    self.num_skipped += 1
                    self.logger.debug("Skipping detail record for list %r: %s" % (list_record, e))
                    continue
                except ScraperBroken, e:
                    # Re-raise the ScraperBroken with some additional helpful information.
                    raise ScraperBroken('%r -- %s' % (list_record, e))
                self.logger.debug("Clean detail record: %r" % detail_record)
            else:
                self.logger.debug("Detail page is not required")
                detail_record = None

            try:
                self.save(old_record, list_record, detail_record)
            except SkipRecord, e:
                self.logger.debug(u"Skipping list record during save: %r " % e)
                self.num_skipped += 1

    def update_from_dir(self, dirname):
        """
        For scrapers with has_detail=False, runs the equivalent of update() on
        every file in the given directory, in sorted order.

        This is useful if you've got cached versions of HTML that you want to
        parse.

        Subclasses should not have to override this method.
        """
        import os
        filenames = os.listdir(dirname)
        filenames.sort()
        for filename in filenames:
            full_name = os.path.join(dirname, filename)
            self.logger.info("Reading from file %s" % full_name)
            page = open(full_name).read()
            self.update_from_string(page)

    ####################################################
    # INTERNAL METHODS THAT SUBCLASSES SHOULD OVERRIDE #
    ####################################################

    parse_list_re = None
    parse_detail_re = None
    has_detail = True

    def list_pages(self):
        """
        Iterator that yields list pages, as strings.

        Usually, this will only yield a single string, but it might yield
        multiple pages if the list is paginated.

        Subclasses need to override this.
        """
        raise NotImplementedError()

    def parse_list(self, page):
        """
        Given the full HTML (or XML, or whatever) of a list page,
        yields a dictionary of data for each record on the page.

        You must either override this method, or define a parse_list_re
        attribute. If you define a parse_list_re attribute, it should be set
        to a compiled regular-expression that finds all the records on a list
        page and uses named groups.
        """
        if self.parse_list_re is not None:
            count = 0
            for record in self.parse_list_re.finditer(page):
                yield record.groupdict()
                count += 1
            if count == 0:
                self.logger.info('%s.parse_list_re found NO records', self.__class__.__name__)
        else:
            raise NotImplementedError()

    def call_cleaners(self, record):
        """
        Given a dictionary returned by parse_list() or parse_detail(),
        calls any method defined whose name match a pattern based on a
        key in dictionary. The value at the key and the entire record
        are passed in as positional arguments. The patten is
        "_clean_KEY".

        For example, if the record contains a key "restaurant",
        call_cleaners() will call a method _clean_restaurant() if it
        exists.

        The _clean_KEY() callable should return a value that will
        replace the value at the key in the dictionary.

        It is up to the subclass's clean_list_record() and
        clean_detail_record() to call call_cleaners().
        """
        for key, value in record.items():
            meth_name = "_clean_%s" % key
            if hasattr(self, meth_name):
                method = getattr(self, meth_name)
                if callable(method):
                    record[key] = method(value, record)
        return record

    def clean_list_record(self, record):
        """
        Given a dictionary as returned by parse_list(), performs any
        necessary cleanup of the data and returns a dictionary.

        For example, this could convert date strings to datetime objects.
        """
        return record

    def existing_record(self, record):
        """
        Given a *cleaned* list record as returned by clean_list_record(), returns
        the existing record from the data store, if it exists.

        If an existing record doesn't exist, this should return None.

        Subclasses must override this.
        """
        raise NotImplementedError()

    def detail_required(self, list_record, old_record):
        """
        Given a cleaned list record and the old record (which might be None),
        returns True if the scraper should download the detail page for this
        record.

        If has_detail is True, subclasses must override this.
        """
        raise NotImplementedError()

    def get_detail(self, record):
        """
        Given a cleaned list record as returned by clean_list_record, retrieves
        and returns the HTML for the record's detail page.

        If has_detail is True, subclasses must override this.
        """
        raise NotImplementedError()

    def parse_detail(self, page, list_record):
        """
        Given the full HTML of a detail page, returns a dictionary of data for
        the record represented on that page.

        If has_detail is True, you must either implement this method
        or define a parse_detail_re attribute. If you define a
        parse_detail_re attribute, it should be set to a compiled
        regular-expression that parses the record on a detail page and
        uses named groups.
        """
        if self.parse_detail_re is not None:
            m = self.parse_detail_re.search(page)
            if m:
                self.logger.debug('Got a match for parse_detail_re')
                return m.groupdict()
            self.logger.debug('Did not get a match for parse_detail_re')
            return {}
        else:
            raise NotImplementedError()

    def clean_detail_record(self, record):
        """
        Given a dictionary as returned by parse_detail(), performs any
        necessary cleanup of the data and returns a dictionary.

        For example, this could convert date strings to datetime objects.

        Overriding is optional; the default does nothing.
        """
        return record

    def get_location(self, list_record):
        """Optional convenience method for extracting a geometry from
        a record.

        If a subclass implements this, it should return either an
        instance of django.contrib.gis.geos.geometry.GEOSGeometry (or
        a subclass), or None if no geometries are found.

        Implementing this is optional; scrapers that define it must
        call it explicitly.
        """
        raise NotImplementedError()

    def save(self, old_record, list_record, detail_record):
        """
        Saves the given record to storage.
        Subclasses must override this.

        list_record and detail_record are both dictionaries representing the
        data from the list page and detail page, respectively. If the scraped
        site does not have detail pages, detail_record will be None.

        old_record is the existing record, as returned by existing_record(). It
        will be None if there is no existing record.

        Subclasses are responsible for actually saving the data,
        or choosing not to save (eg. if old_record exists).
        """
        raise NotImplementedError()


class RssListDetailScraper(ListDetailScraper):
    """
    A ListDetailScraper for sites whose lists are RSS feeds.

    Subclasses should not have to implement parse_list() or get_detail().
    """

    def parse_list(self, page):
        # The page is an RSS feed, so use feedparser to parse it.
        import feedparser
        self.logger.debug("Parsing RSS feed with feedparser")
        feed = feedparser.parse(page)
        if not len(feed['entries']):
            # We might be parsing a paginated feed, and typically
            # there's no way to know how many pages there are, except
            # to keep incrementing the page number and stop when you
            # hit an empty page.
            raise StopScraping("No more entries to scrape")
        for entry in feed['entries']:
            yield entry

    def get_detail(self, record):
        # Assume that the detail page is accessible via the <link> for this
        # entry.
        return self.fetch_data(record['link'])

    def get_location(self, record):
        """Try to get a point from the record, trying both georss,
        geo, and some non-standard conventions.

        Returns a Point or None.

        This is not called automatically; if you want to use it, your
        scraper should do ``newsitem.location = self.get_location(record)``
        sometime prior to ``self.save()``.
        """
        from ebdata.retrieval.utils import get_point
        return get_point(record)

    def get_location_name(self, record):
        """Try to get a location name from the record, via any of
        georss, xcal, or ev.

        This is not called automatically; if you want to use it, your
        scraper should do something like ``newsitem.location_name =
        self.get_location_name(record)`` sometime prior to
        ``self.save()``.
        """
        for key in ('xCal_x-calconnect-street',
                    'x-calconnect-street',
                    'georss_featurename',
                    'featurename',
                    'ev-location',
                    'location'):
            val = record.get(key)
            if val:
                return val
        return None


    def get_point_and_location_name(self, record, address_text=None):
        """Try to get and return a (Point, location_name) pair, using
        any standards supported by get_location() and
        get_location_name(); if either can't be determined, fall back
        to using geocoding or reverse geocoding as needed.

        If *neither* can be determined, use address extraction from
        ebdata.nlp on ``address_text`` if passed, or if it's not passed,
        on *everything* in ``record`` that looks like text,
        and try to geocode the resulting addresses.

        Either returned value may be None if it can't be determined.

        This is not called automatically; if you want to use it, your
        scraper should do something like this prior to ``self.save()``::

           point, location_name = self.get_point_and_location_name(record)
           newsitem.location = point
           newsitem.location_name = location_name

        """
        location_name = self.get_location_name(record)
        point = self.get_location(record)
        if not point:
            # Fall back to geocoding.
            if not location_name:
                # Just smush all string values together and try it.
                if not address_text:
                    address_text = u'\n'.join(
                        [v for k, v in record.items()
                         if (isinstance(v, basestring)
                             and k not in ('updated', 'link',))
                         ])
        point, location_name = self.geocode_if_needed(point, location_name, address_text)
        return (point, location_name)

    @staticmethod
    def ns_get(entry, element):
        """Utility to work around feedparser unpredictability
        re. namespaced elements.  It has more than one back-end
        parser, and they treat namespaces differently; <foo:bar> might
        show up as 'foo_bar' or 'bar'.

        Usage:  ns_get(entry=some_dictionary, element='foo:bar')

        """
        namespace, element = element.split(':')
        result = entry.get('%s_%s' % (namespace, element))
        if result is None:
            result = entry.get(element)
        return result

########NEW FILE########
__FILENAME__ = newsitem_list_detail
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from ebdata.retrieval.scrapers.list_detail import ListDetailScraper
from ebdata.retrieval.utils import locations_are_close
from ebpub.db.models import Schema, NewsItem, Lookup, DataUpdate, field_mapping
from ebpub.geocoder import SmartGeocoder, GeocodingException, ParsingError, AmbiguousResult
from ebpub.geocoder.reverse import reverse_geocode

import datetime
import pytz

local_tz = pytz.timezone(settings.TIME_ZONE)

class NewsItemListDetailScraper(ListDetailScraper):
    """
    A ListDetailScraper that saves its data into the NewsItem table.

    Subclasses are required to set the `schema_slugs` attribute.

    Once you've set schema_slugs, there are a number of properties for
    conveniently accessing the relevant Schemas and SchemaFields:

    self.schemas lazily loads the list of Schema objects the first time it's
    accessed. It is a dictionary in the format {slug: Schema}.

    self.schema is available if schema_slugs has only one element. It's the
    Schema object.

    self.lookups lazily loads a dictionary of all SchemaFields with
    lookup=True. The dictionary is in the format {name: schemafield}.
    If schema_slugs has more than one element, self.lookups is a
    dictionary in the format {schema_slug: {name: schemafield}}.

    self.schema_fields lazily loads a dictionary of each SchemaField,
    mapping the name to the SchemaField object.
    If schema_slugs has more than one element, self.schema_fields is a
    dictionary in the format {schema_slug: {name: schema_field}}.

    self.schema_field_mapping lazily loads a dictionary of each
    SchemaField, mapping the name to the real_name.
    If schema_slugs has more than one element, self.schema_field_mapping
    is a dictionary in the format {schema_slug: {name: real_name}}.
    """
    schema_slugs = None
    logname = None

    def __init__(self, *args, **kwargs):
        if self.logname is None:
            self.logname = '%s.%s' % (settings.SHORT_NAME, self.schema_slugs[0])
        super(NewsItemListDetailScraper, self).__init__(*args, **kwargs)
        self._schema_cache = None
        self._schemas_cache = None
        self._lookups_cache = None
        self._schema_fields_cache = None
        self._schema_field_mapping_cache = None

    # schemas, schema, lookups and schema_field_mapping are all lazily loaded
    # so that this scraper can be run (in raw_data(), xml_data() or
    # display_data()) without requiring a valid database to be set up.

    @property
    def schemas(self):
        if self._schemas_cache is None:
            self._schemas_cache = dict([(s, Schema.objects.get(slug=s)) for s in self.schema_slugs])
        return self._schemas_cache

    @property
    def schema(self):
        if self._schema_cache is None:
            if len(self.schema_slugs) > 1:
                raise AttributeError('self.schema is only available if len(schema_slugs) == 1')
            self._schema_cache = self.schemas[self.schema_slugs[0]]
        return self._schema_cache

    @property
    def lookups(self):
        if self._lookups_cache is None:
            lc = dict([(s.slug, dict([(sf.name, sf) for sf in s.schemafield_set.filter(is_lookup=True)])) for s in self.schemas.values()])
            if len(self.schema_slugs) == 1:
                lc = lc[self.schema_slugs[0]]
            self._lookups_cache = lc
        return self._lookups_cache

    @property
    def schema_fields(self):
        if self._schema_fields_cache is None:
            sfs = dict([(s.slug, dict([(sf.name, sf)
                                       for sf in s.schemafield_set.all()]))
                        for s in self.schemas.values()])
            if len(self.schema_slugs) == 1:
                sfs = sfs[self.schema_slugs[0]]
            self._schema_fields_cache = sfs
        return self._schema_fields_cache

    @property
    def schema_field_mapping(self):
        if self._schema_field_mapping_cache is None:
            schema_objs = self.schemas.values()
            mapping = field_mapping([s.id for s in schema_objs])
            fm = dict([(s.slug, mapping[s.id]) for s in schema_objs])
            if len(self.schema_slugs) == 1:
                fm = fm[self.schema_slugs[0]]
            self._schema_field_mapping_cache = fm
        return self._schema_field_mapping_cache


    def get_or_create_lookup(self, schema_field_name, name, code, description='', schema=None, make_text_slug=True):
        """
        Returns the Lookup instance matching the given Schema slug, SchemaField
        name and Lookup.code, creating it (with the given name/code/description)
        if it doesn't already exist.

        If make_text_slug is True, then a slug will be created from the given
        name. If it's False, then the slug will be the Lookup's ID.
        """
        if len(self.schema_slugs) > 1:
            sf = self.lookups[schema][schema_field_name]
        else:
            sf = self.lookups[schema_field_name]
        return Lookup.objects.get_or_create_lookup(sf, name, code, description, make_text_slug, self.logger)



    def update(self):
        """
        Updates the Schema.last_updated fields after scraping is done.
        """
        self.num_added = 0
        self.num_changed = 0
        update_start = datetime.datetime.now()

        # We use a try/finally here so that the DataUpdate object is created
        # regardless of whether the scraper raised an exception.
        try:
            got_error = True
            super(NewsItemListDetailScraper, self).update()
            got_error = False
        finally:
            # Rollback, in case the database is in an aborted
            # transaction. This avoids the "psycopg2.ProgrammingError:
            # current transaction is aborted, commands ignored until
            # end of transaction block" error.
            from django.db import connection
            connection._rollback()

            update_finish = datetime.datetime.now()

            # Clear the Schema cache, in case the schemas have been
            # updated in the database since we started the scrape.
            self._schemas_cache = self._schema_cache = None

            for s in self.schemas.values():
                s.last_updated = datetime.date.today()
                s.save()
                DataUpdate.objects.create(
                    schema=s,
                    update_start=update_start,
                    update_finish=update_finish,
                    num_added=self.num_added,
                    num_changed=self.num_changed,
                    # None of our scrapers delete records yet, but we have the
                    # plumbing in place here in case future scrapers need to do
                    # that.
                    num_deleted=0,
                    num_skipped=self.num_skipped,
                    got_error=got_error,
                )


    def safe_location(self, location_name, geom, max_distance=200):
        """
        Returns a location (geometry) to use, given a location_name and
        geometry. This is used for data sources that publish both a geometry
        and a location_name -- we double-check that the geometry is within
        a certain `max_distance` from the geocoded location_name.

        If there's a discrepancy or if the location_name can't be geocoded,
        this returns None.
        """
        location = self.geocode(location_name)
        if location is None:
            return None
        location_point = location['point']
        if not location_point:
            return None
        location_point.srid = 4326
        is_close, distance = locations_are_close(location_point, geom, max_distance)
        if not is_close:
            return None
        return geom

    def last_updated_time(self, schema=None):
        """
        Returns a DateTime representing the last time we started
        scraping our schema(s).  (We use start time rather than end
        time on the assumption that a few overlaps are preferable to
        missing updates.)
        """
        schema = schema or self.schema
        try:
            last_update = DataUpdate.objects.order_by('update_start')[0]
            return last_update.update_start
        except IndexError:
            # Use the unix epoch (1970) as a stand-in for "never updated".
            return datetime.datetime.fromtimestamp(0)



########NEW FILE########
__FILENAME__ = tests
#   Copyright 2012 OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

import datetime
import django.test
import mock
import os
HERE = os.path.abspath(os.path.dirname(__file__))


class TestBaseScraper(django.test.TestCase):

    def _make_scraper(self):
        from ebdata.retrieval.scrapers.base import BaseScraper
        scraper = BaseScraper(use_cache=False)
        # Be quiet!
        scraper.logger = mock.Mock()
        return scraper

    @mock.patch('ebdata.retrieval.scrapers.base.full_geocode')
    def test_geocode__ok(self, mock_full_geocode):
        mock_full_geocode.return_value = {'result': 'something', 'type': 'address'}
        scraper = self._make_scraper()
        self.assertEqual(scraper.geocode('somewhere'),
                         'something')

    @mock.patch('ebdata.retrieval.scrapers.base.full_geocode')
    def test_geocode__error(self, mock_full_geocode):
        from ebpub.geocoder.base import GeocodingException, ParsingError

        mock_full_geocode.side_effect = GeocodingException()
        scraper = self._make_scraper()
        self.assertEqual(scraper.geocode('somewhere'), None)

        mock_full_geocode.side_effect = ParsingError()
        scraper = self._make_scraper()
        self.assertEqual(scraper.geocode('somewhere'), None)

    @mock.patch('ebdata.retrieval.scrapers.base.parse_addresses')
    @mock.patch('ebdata.retrieval.scrapers.base.full_geocode')
    def test_geocode_if_needed__geocode_errors(self, mock_full_geocode, mock_parse):
        mock_full_geocode.side_effect = Exception()
        mock_parse.return_value = [('somewhere', None)]
        scraper = self._make_scraper()
        result = scraper.geocode_if_needed(None, 'somewhere')
        self.assertEqual(result, (None, 'somewhere'))

    @mock.patch('ebpub.geocoder.reverse.reverse_geocode')
    def test_geocode_if_needed__reverse_errors(self, mock_reverse):
        from ebpub.geocoder.reverse import ReverseGeocodeError
        mock_reverse.side_effect = ReverseGeocodeError()
        scraper = self._make_scraper()
        mock_point = mock.Mock()
        result = scraper.geocode_if_needed(mock_point, None)
        self.assertEqual(result, (mock_point, None))

    @mock.patch('ebpub.geocoder.reverse.reverse_geocode')
    def test_geocode_if_needed__point_only(self, mock_reverse):
        scraper = self._make_scraper()
        mock_block = mock.Mock(pretty_name='123 Anywhere St')
        mock_reverse.return_value = (mock_block, 0.0)
        mock_point = mock.Mock()
        result = scraper.geocode_if_needed(mock_point, None)
        self.assertEqual(result,  (mock_point, '123 Anywhere St'))

    @mock.patch('ebdata.retrieval.scrapers.base.BaseScraper.geocode')
    def test_geocode_if_needed__name_only(self, mock_geocode):
        scraper = self._make_scraper()
        mock_point = object()
        mock_geocode.return_value = {'point': mock_point}
        result = scraper.geocode_if_needed(None, '123 Anywhere St')
        self.assertEqual(result,  (mock_point, '123 Anywhere St'))

    @mock.patch('ebdata.retrieval.scrapers.base.BaseScraper.geocode')
    def test_geocode_if_needed__name_and_text(self, mock_geocode):
        scraper = self._make_scraper()
        mock_point = object()
        mock_geocode.return_value = {'point': mock_point}
        result = scraper.geocode_if_needed(None, '123 Anywhere St', 'Unused')
        self.assertEqual(result,  (mock_point, '123 Anywhere St'))

    @mock.patch('ebdata.retrieval.scrapers.base.BaseScraper.geocode')
    def test_geocode_if_needed__text_only(self, mock_geocode):
        scraper = self._make_scraper()
        mock_point = object()
        mock_geocode.return_value = {'point': mock_point,
                                     'address': 'The Real Address'}
        result = scraper.geocode_if_needed(None, None, '123 Anywhere St')
        self.assertEqual(result,  (mock_point, 'The Real Address'))

    def test_parse_html(self):
        html = '''
           <html><head><title>Hello</title></head>
              <body><h1>Yes.</h1></body>
           </html>
        '''
        scraper = self._make_scraper()
        parsed = scraper.parse_html(html)
        self.assertEqual(parsed.find('//h1').text, 'Yes.')


    def test_fetch_data(self):
        scraper = self._make_scraper()
        scraper.retriever = mock.Mock()
        args=('arg1',)
        kwargs={'arg2': 'val2'}
        scraper.fetch_data(*args, **kwargs)
        self.assertEqual(scraper.retriever.fetch_data.call_count, 1)
        self.assertEqual(scraper.retriever.fetch_data.call_args,
                         (args, kwargs))
        scraper.get_html(*args, **kwargs)
        self.assertEqual(scraper.retriever.fetch_data.call_count, 2)
        self.assertEqual(scraper.retriever.fetch_data.call_args,
                         (args, kwargs))


class TestCreateNewsitem(django.test.TestCase):

    # Use hardcoded path so I don't have to make this into an app
    # or mess with settings just to get a test fixture.
    fixtures = (os.path.join(HERE, 'fixtures', 'test_scraper_fixtures.json')
                ,)

    def _make_scraper(self):
        from ebdata.retrieval.scrapers.base import BaseScraper
        scraper = BaseScraper(use_cache=False)
        # Be quiet!
        scraper.logger = mock.Mock()
        return scraper

    def _get_schema(self):
        from ebpub.db.models import Schema
        schema = Schema.objects.get(
            slug='scrapertest-news'
            )
        return schema

    def test_create_newsitem(self):
        scraper = self._make_scraper()
        schema = self._get_schema()
        item = scraper.create_newsitem({'attr1': 'value 1'},
                                       title=u'Test Title',
                                       item_date=datetime.date(2012, 2, 1),
                                       location_name='123 Anywhere',
                                       schema=schema)
        self.assert_(item.id)
        self.assertEqual(item.title, u'Test Title')
        self.assertEqual(item.location, None)
        self.assertEqual(item.attributes['attr1'], 'value 1')

    def test_update_existing(self):
        scraper = self._make_scraper()
        schema = self._get_schema()
        item = scraper.create_newsitem({'attr1': 'value 1'},
                                       title=u'Test Title',
                                       item_date=datetime.date(2012, 2, 1),
                                       location_name='123 Anywhere',
                                       schema=schema)

        # No update... passes silently.
        scraper.update_existing(item, {}, {})
        # Update with data.
        scraper.update_existing(item, {'title': u'New Title'}, {'attr1': u'New Value'})
        self.assertEqual(item.title, u'New Title')
        self.assertEqual(item.attributes['attr1'], u'New Value')

    def test_create_or_update(self):
        from ebpub.db.models import NewsItem
        scraper = self._make_scraper()
        schema = self._get_schema()
        kwargs = {'title': 'Veeblefetzer',
                  'location_name': 'Potrzebie',
                  'item_date': datetime.date(2012, 01, 01),
                  'schema': schema}
        attrs = {'attr1': 'Potrzebie'}
        # Create.
        self.assertEqual(NewsItem.objects.filter(title=kwargs['title']).count(),
                         0)
        scraper.create_or_update(None, attrs, **kwargs)

        self.assertEqual(NewsItem.objects.filter(title=kwargs['title']).count(),
                         1)
        item = NewsItem.objects.get(**kwargs)

        # Update.
        scraper.create_or_update(item, attrs, title='Kurtzman')
        self.assertEqual(item.title, 'Kurtzman')



########NEW FILE########
__FILENAME__ = config
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Sample config file for the updaterdaemon.

Also contains useful callback generators that check whether to handle
a particular datetime.
"""

import datetime


def multiple_hourly(*minutes):
    """
    Returns a checker that matches datetimes every hour, at the given
    minute(s).
    """
    def handle(dt):
        return dt.minute in minutes
    return handle

def multiple_daily(*hour_minutes):
    """
    Returns a checker that matches multiple times every day, at the
    given (hour, minute) time(s).
    """
    hour_minutes = set(hour_minutes)
    def handle(dt):
        return (dt.hour, dt.minute) in hour_minutes
    return handle

def daily(hour, minute):
    """
    Returns a checker that matches once a day at the given hour & minute.
    """
    def handle(dt):
        return dt.hour == hour and dt.minute == minute
    return handle

def weekly(weekday, hour, minute):
    """
    Returns a checker that matches datetimes once a week, at the given
    weekday (0=sunday), hour, and minute.
    """
    def handle(dt):
        return dt.weekday() == weekday and dt.hour == hour and dt.minute == minute
    return handle

def once(*args):
    """Useful for testing: returns a checker that matches the first
    datetime that's passed to it, and then returns False forever
    after.  (Note that reloading config defeats this.)
    """
    class OneShotHandler:
        has_run = False
        def handle(self, dt):
            if not self.has_run:
                self.has_run = True
                return True
            return False
    return OneShotHandler().handle



TASKS = (
    # Tuples like (time_callback, function_to_run, {keyword args}, {environ})
    #
    # The time_callback should take a datetime instance and return True
    # if the function_to_run should be run, and False otherwise.
    #
    # The environ should include DJANGO_SETTINGS_MODULE.
    #
    # Example:
    # (daily(12, 0), run_some_function, {'arg': 'foo'}, {'DJANGO_SETTINGS_MODULE': 'foo.settings'})
)


########NEW FILE########
__FILENAME__ = runner
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.utils.daemon import Daemon
import datetime
import os
import sys
import time

class EveryMinuteDaemon(Daemon):
    """
    A daemon that calls handle_time() every minute.
    """
    def run(self):
        while 1:
            # Calculate the next minute. We don't care about handling the
            # current minute, because if we did that, it would be handled
            # twice if this program were stopped and restarted during that
            # minute.
            next_minute = datetime.datetime.now() + datetime.timedelta(minutes=1)
            next_minute = next_minute.replace(second=0, microsecond=0)

            # Sleep until the next minute. Add 5 seconds to the sleep time to
            # avoid edge cases and off-by-one errors. Messy but effective.
            sleep_delta = next_minute - datetime.datetime.now()
            time.sleep(sleep_delta.seconds + 5)

            # Call the hook.
            self.handle_time(next_minute)

    def handle_time(self, timestamp):
        pass

class EveryTwoSecondsDaemon(Daemon):
    """
    A daemon that calls handle_time() every two seconds.

    This is useful for debugging -- just replace EveryMinuteDaemon with
    EveryTwoSecondsDaemon in your subclass.
    """
    def run(self):
        while 1:
            self.handle_time(datetime.datetime.now())
            time.sleep(2)

    def handle_time(self, timestamp):
        pass

class UpdaterDaemon(EveryMinuteDaemon):
    """
    A (deprecated) daemon for running OpenBlock scrapers based on a config file.

    We now recommend just using cron or your preferred scheduling tool instead.
    """

    def __init__(self, *args, **kwargs):
        import warnings
        warnings.warn("UpdaterDaemon is deprecated, see http://openblockproject.org/docs/main/running_scrapers.html",
                      DeprecationWarning)

        super(UpdaterDaemon, self).__init__(*args, **kwargs)
        self.parser.add_option("-c", "--config",
                               help="path to configuration file (python).",
                               action="store", default=None)
        self.parser.add_option("--error-log",
                               help="path to error log.",
                               action="store", default="/tmp/updaterdaemon.log")
        self.parser.add_option("--log-file",
                               help="path to log file.",
                               action="store", default="/tmp/updaterdaemon.err")

    def parse_args(self, argv):
        """Given sys.argv, parses the command-line arguments.
        """
        super(UpdaterDaemon, self).parse_args(argv)

        self.stdout = self.options.log_file
        self.stderr = self.options.error_log

        config = self.options.config
        if config is None:
            config = os.path.join(os.path.dirname(__file__), 'config.py')
        config = os.path.normpath(os.path.abspath(config))
        configdir, configfile = os.path.split(config)
        configfile, ext = os.path.splitext(configfile)
        if configdir not in sys.path:
            sys.path.insert(0, configdir)
        self.config = __import__(configfile)

    def handle_time(self, timestamp):
        # Get the tasks for the given timestamp, and run any that need to be
        # run. Reload the config to take into account any changes that might
        # have been made.
        reload(self.config)
        for check, func, kwargs, env in self.config.TASKS:
            if check(timestamp):
                # Fork a child process and grandchild process, and kill the
                # child process immediately so that it doesn't block.
                # For more on this technique, see the final paragraph at
                # http://www.faqs.org/faqs/unix-faq/faq/part3/section-13.html
                try:
                    pid = os.fork()
                except OSError, e:
                    sys.stderr.write("fork failed: %d (%s)\n" % (e.errno, e.strerror))
                    os._exit(1)
                if pid == 0: # child
                    try:
                        pid2 = os.fork()
                    except OSError, e:
                        sys.stderr.write("inner fork failed: %d (%s)\n" % (e.errno, e.strerror))
                        os._exit(1)
                    if pid2 == 0: # child
                        os.environ.update(env)
                        # Log the function call and PID.
                        # TODO: use logging module.
                        sys.stdout.write('%s\t%s\t%r\t%s\n' % (datetime.datetime.now(), func.func_name, kwargs, os.getpid()))
                        sys.stdout.flush()

                        try:
                            func(**kwargs)
                        except Exception, e:
                            from django.core.mail import mail_admins
                            import traceback
                            traceback_string = '\n'.join(traceback.format_exception(*sys.exc_info()))
                            sys.stderr.write("ERROR AT %s\n" % datetime.datetime.now())
                            sys.stderr.write(traceback_string)
                            sys.stderr.write("\n========================================\n")
                            subject = '%s %s' % (func.func_name, str(kwargs).replace('\n', ' '))
                            try:
                                mail_admins(subject, traceback_string)
                            except Exception, e:
                                sys.stderr.write("Got error mailing admins: %s\n" % e)
                            # Don't call sys.exit() for this,
                            # because we're in a child process.
                            os._exit(1)
                        sys.stdout.flush()
                    os._exit(0)
                else: # parent
                    os.waitpid(pid, 0)

if __name__ == "__main__":
    daemon = UpdaterDaemon('/tmp/updaterdaemon.pid')
    daemon.run_from_command_line(sys.argv[1:])

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#


"""
Utilities useful for scraping.
"""

# The convert_entities() function is derived from Copyright © 1995-2008
# Fredrik Lundh. It is used under the terms of the Python-style license
# specified at http://effbot.org/zone/copyright.htm.
# 
# Copyright (c) 1995-2008 by Fredrik Lundh
# 
# By obtaining, using, and/or copying this software and/or its associated
# documentation, you agree that you have read, understood, and will comply
# with the following terms and conditions:
# 
# Permission to use, copy, modify, and distribute this software and its
# associated documentation for any purpose and without fee is hereby granted,
# provided that the above copyright notice appears in all copies, and that
# both that copyright notice and this permission notice appear in supporting
# documentation, and that the name of Secret Labs AB or the author not be
# used in advertising or publicity pertaining to distribution of the software
# without specific, written prior permission.
# 
# SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
# SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
# IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR ANY SPECIAL,
# INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
# LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
# OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
# PERFORMANCE OF THIS SOFTWARE.


from django.contrib.gis.geos import GEOSGeometry
from django.contrib.gis.geos import Point
from ebpub.utils.geodjango import smart_transform
import htmlentitydefs
import logging
import re

logger = logging.getLogger('ebdata.retrieval.utils')

multispace_re = re.compile(r'\s\s+')

def norm_dict_space(d, *keys):
    """
    Replaces 2 or more spaces with a single space, in dict values,
    and strips leading/trailing space.
    (Keys are not changed.)

    >>> d = {'name': '  john  smith ',
    ...      'address': '  123  main st ',
    ...      ' address': ' 123  main st'}
    >>> norm_dict_space(d, 'name', 'address')
    >>> sorted(d.items())
    [(' address', ' 123  main st'), ('address', '123 main st'), ('name', 'john smith')]
    """
    for key in keys:
        d[key] = multispace_re.sub(' ', d[key]).strip()

def obj_dict_merge(obj, update_dict, ignore_attrs=None):
    """Updates the attributes of obj with the values in update_dict.

    Takes a list of attributes to ignore.

    Returns True if any of obj's attributes were updated, False otherwise.
    """
    if not ignore_attrs:
        ignore_attrs = []
    changed = False
    for attr in obj.__dict__.keys():
        if attr not in ignore_attrs and update_dict.has_key(attr):
            update_val = update_dict[attr]
            if getattr(obj, attr) != update_val:
                setattr(obj, attr, update_val)
                changed = True
    return changed, obj

# From http://effbot.org/zone/re-sub.htm#unescape-html
# See copyright at top of this file.

def convert_entities(text):
    """
    Converts HTML entities in the given string (e.g., '&#28;' or '&nbsp;') to
    their corresponding characters.

    Note this does NOT do the same thing as xml.sax.saxutils.unescape();
    for that you'd have to pass in an exhaustive dictionary of
    entity -> replacement pairs.
    """
    NAMED_ENTITY_SPECIAL_CASES = {
        'apos': u"'",
    }
    def fixup(m):
        text = m.group(0)
        if text[:2] == "&#":
            # character reference
            try:
                if text[:3] == "&#x":
                    return unichr(int(text[3:-1], 16))
                else:
                    return unichr(int(text[2:-1]))
            except ValueError:
                pass
        else:
            # named entity
            entity = text[1:-1]
            try:
                text = unichr(htmlentitydefs.name2codepoint[entity])
            except KeyError:
                try:
                    return NAMED_ENTITY_SPECIAL_CASES[entity]
                except KeyError:
                    pass
        return text # leave as is
    return re.sub("&#?\w+;", fixup, text)


def locations_are_close(geom_a, geom_b, max_distance=200):
    """
    Verifies that two locations are within a certain distance from
    each other. Returns a tuple of (is_close, distance), where
    is_close is True only if the locations are within max_distance.

    Assumes max_distance is in meters.
    """
    # Both geometries must be GEOSGeometry for the distance method.
    if not (isinstance(geom_a, GEOSGeometry) and isinstance(geom_b, GEOSGeometry)):
        raise ValueError, 'both geometries must be GEOSGeometry instances'
    carto_srid = 3395 # SRS in meters
    geom_a = smart_transform(geom_a, carto_srid)
    geom_b = smart_transform(geom_b, carto_srid)
    distance = geom_a.distance(geom_b)
    return (distance < max_distance), distance


def get_point(record):
    """
    Given a dict, eg. a record as returned by feedparser, tries to
    find either flavor of georss or geo attributes, as well as some
    other common non-standard conventions.

    Returns a Point or None.

    Locations with both lat = 0 and lon = 0 are assumed to be bad; we
    return None for those.
    """
    # This tries to work around feedparser bugs where depending on
    # whether you get a loose or strict parser, you might or might
    # not see the namespace prefix on the attribute name.

    # TODO: support other georss geometry types as per
    # http://www.georss.org/simple ... so far only handles Point.

    # TODO: support xCal geometries
    # https://tools.ietf.org/html/rfc6321#section-3.4.1.2

    if 'gml_pos' in record:
        # Looks like georss gml.
        lat, lon = record['gml_pos'].split()
    elif 'point' in record:
        # Unfortunately, with broken namespace handling, this
        # might be georss_simple or georss gml. Try both.
        if 'where' in record and 'pos' in record:
            # It's GML.
            lat, lon = record['pos'].strip().split()
        else:
            lat, lon = record['point'].strip().split()
    elif 'georss_point' in record:
        # It's georss simple.
        lat, lon = record['georss_point'].strip().split()
    elif 'geo_lat' in record:
        # It's the rdf geo namespace.
        lat, lon = record['geo_lat'], record['geo_lon']
    elif 'lat' in record:
        lat = record['lat']
        # 'lon' = geo with broken namespace handling.
        # The others are non-standard, but I've seen 'lng' in eg.
        # seeclickfix issues json.
        lon = record.get('lng') or record.get('lon') or record.get('long')
        if lon is None:
            logger.debug("Found lat %r, but nothing like a longitude" % lat)
            return None
    elif 'latitude' in record:
        # Another common non-standard convention.
        lat, lon = record['latitude'], record['longitude']
    elif 'xCal_latitude' in record:
        # Looks like xCal.
        # Not sure about capitalization of namespace?
        lat, lon = record['xCal_latitude'], record['xCal_longitude']
    else:
        logger.debug("no known geometry types found in record %s" % record)
        return None
    lat, lon = float(lat), float(lon)
    if (lat, lon) == (0.0, 0.0):
        logger.warn("Ignoring location with bad coordinates (0, 0)")
        return None
    return Point(lon, lat)

########NEW FILE########
__FILENAME__ = flickr_retrieval
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#


# NOTES BASED ON TEMPLATE:
# slug = 'photos'
# attributes:
#   photo_href = the 75x75 small square
#   username
#   user_id
#   sourcename  ... either 'Flickr' or 'Panoramio'


"""
An OpenBlock scraper for Flickr photos.

NOTE, to use this you must comply with the Flickr terms of service:
https://secure.flickr.com/services/api/tos/
"""

from django.conf import settings
from django.contrib.gis.geos import Point
from django.utils import simplejson
from ebdata.retrieval.scrapers.list_detail import StopScraping, SkipRecord
from ebdata.retrieval.scrapers.newsitem_list_detail import NewsItemListDetailScraper
from ebpub.db.models import NewsItem
from ebpub.geocoder.reverse import reverse_geocode, ReverseGeocodeError
from ebpub.utils.dates import parse_date
from ebpub.utils.geodjango import get_default_bounds
import datetime
import flickrapi
import logging
import pytz
import time

# Note there's an undocumented assumption in ebdata that we want to
# unescape html before putting it in the db.
from ebdata.retrieval.utils import convert_entities

local_tz = pytz.timezone(settings.TIME_ZONE)
utc = pytz.timezone('utc')

logger = logging.getLogger('eb.retrieval.flickr')

class FlickrScraper(NewsItemListDetailScraper):

    logname = 'flickr_retrieval'
    has_detail = False
    max_photos_per_scrape = 2000

    def __init__(self, options):
        self.api_key = settings.FLICKR_API_KEY
        self.api_secret = settings.FLICKR_API_SECRET
        self.options = options
        self.schema_slugs = [options.schema]
        self.records_seen = 0
        if options.end_date:
            end_date = parse_date(options.end_date, '%Y/%m/%d')
        else:
            end_date = datetime.date.today()
        # We want midnight at the *end* of the day.
        end_date += datetime.timedelta(days = 1)
        self.max_timestamp = time.mktime(end_date.timetuple())
        start_date = end_date - datetime.timedelta(days=options.days)
        self.min_timestamp = time.mktime(start_date.timetuple())


        super(FlickrScraper, self).__init__()

    def list_pages(self):
        """generate page strings."""

        # XXX argh we apparently need the api_secret, and thus the token / frob dance?
        # even though this method doesn't need authentication???
        flickr = flickrapi.FlickrAPI(self.api_key, self.api_secret)
        extent = ','.join([str(coord) for coord in get_default_bounds().extent])

        # Result of each iteration is a JSON string.
        pagenum = 0
        pages = float('inf')
        while pagenum < pages:
            pagenum += 1
            page = flickr.photos_search(has_geo=1, bbox=extent, safe_search='1',
                                        min_taken_date=self.min_timestamp,
                                        max_taken_date=self.max_timestamp,
                                        per_page='400',
                                        page=str(pagenum),
                                        extras='date_taken,date_upload,url_sq,description,geo,owner_name',
                                        format='json',
                                        content_type='1', # photos only.
                                        nojsoncallback='1',
                                        )

            # Ugh, we need to find out how many pages there are, so we parse here
            # and also in parse_list().
            adict = simplejson.loads(page)
            try:
                pages = int(adict['photos']['pages'])
            except KeyError:
                if adict.get('stat') == 'fail':
                    self.logger.error("Flickr error code %r: %s" % (adict['code'], adict['message']))
                else:
                    self.logger.error("Page content:\n%s" %page)
                raise StopScraping("Parsing error, missing 'photos' or 'pages', see above.")
            yield page

    def parse_list(self, page):
        # parse a single detail string page into record dicts
        for photo in simplejson.loads(page)['photos']['photo']:
            if self.records_seen > self.max_photos_per_scrape:
                raise StopScraping("We've reached %d records" % self.max_photos_per_scrape)
            self.records_seen += 1
            yield photo

    def clean_list_record(self, record):
        # clean up a record dict
        # Item date, in timezone of the photo owner.
        # Not sure how to determine what that is, so we'll leave it.
        cleaned = {}
        cleaned['item_date'] = datetime.datetime.strptime(record['datetaken'],
                                                          '%Y-%m-%d %H:%M:%S')
        cleaned['item_date'] = cleaned['item_date'].date()
        # Posted date, UTC timestamp.
        pub_date = datetime.datetime.fromtimestamp(
            float(record['dateupload']), utc)
        cleaned['pub_date'] = pub_date.astimezone(local_tz)

        description = record['description']['_content']
        cleaned['description'] = convert_entities(description.strip())

        cleaned['title'] = convert_entities(record['title'])
        x, y = record['longitude'], record['latitude']
        cleaned['location'] = Point((float(x), float(y)))

        # Possibly we could figure out flickr's geo API and resolve
        # the photo's place_id and/or woeid to the place name?  But
        # those are probably not specific enough; reverse-geocode
        # instead.
        try:
            block, distance = reverse_geocode(cleaned['location'])
            cleaned['location_name'] = block.pretty_name
        except ReverseGeocodeError:
            raise SkipRecord("Could not geocode location %s, %s" % (x, y))

        # Don't think any of the urls returned by the API's "extras"
        # correspond to the page? not sure.
        cleaned['url'] = 'http://www.flickr.com/photos/%(owner)s/%(id)s' % record

        attributes = {}
        attributes['sourcename'] = 'Flickr'
        #attributes['photo_id'] = record['id']
        attributes['user_id'] = record['owner']
        attributes['username'] = record['ownername']
        # Thumbnail. 'Small square' photos are 75x75.
        attributes['photo_href'] = record['url_sq']
        cleaned['_attributes'] = attributes
        return cleaned


    def existing_record(self, record):
        # check if the CLEANED record dict matches a NewsItem
        try:
            item = NewsItem.objects.get(schema=self.schema, url=record['url'])
            return item
        except NewsItem.DoesNotExist:
            return None

    def save(self, old_record, list_record, detail_record):
        attributes = list_record.pop('_attributes')
        self.create_or_update(old_record, attributes, **list_record)


def main(argv=None):
    import sys
    if argv is None:
        argv = sys.argv[1:]
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option(
        '-d', "--days",
        help="How many days (prior to stop date) to search. Default is 30 days.",
        action='store', default=30, type='int',
        )
    parser.add_option(
        '-e', "--end-date",
        help="Stop date for photo search, format YYYY/MM/DD. Default is now.",
        action='store', default=None,
        )
    parser.add_option(
        "--schema", help="Slug of schema to use. Default is 'photos'.",
        action='store', default='photos',
        )

    from ebpub.utils.script_utils import add_verbosity_options, setup_logging_from_opts
    add_verbosity_options(parser)

    options, args = parser.parse_args(argv)
    setup_logging_from_opts(options, logger)
    scraper = FlickrScraper(options)
    scraper.update()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = retrieval
#!/usr/bin/env python
# encoding: utf-8

#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#


"""A scraper for RSS feeds with GeoRSS or other location info.
"""

import datetime
import ebdata.retrieval.log  # sets up base handlers.

from django.contrib.gis.geos import Point
from ebdata.retrieval.scrapers.list_detail import RssListDetailScraper
from ebdata.retrieval.scrapers.list_detail import SkipRecord, StopScraping
from ebdata.retrieval.scrapers.newsitem_list_detail import NewsItemListDetailScraper
from ebpub.db.models import NewsItem
from ebpub.utils.geodjango import intersects_metro_bbox


# Note there's an undocumented assumption in ebdata that we want to
# unescape html before putting it in the db.
from ebdata.retrieval.utils import convert_entities

class RssScraper(RssListDetailScraper, NewsItemListDetailScraper):
    """
    A generic RSS scraper. Suitable for use with any Schema that
    doesn't have any associated SchemaFields (that is, no extended
    attributes, just the core NewsItem stuff.)
    """

    has_detail = False
    logname = 'georss'

    def __init__(self, *args, **kwargs):
        self.url = kwargs.pop('url', None)
        self.schema_slugs = (kwargs.pop('schema_slug', None) or 'local-news',)
        super(RssScraper, self).__init__(*args, **kwargs)

    def list_pages(self):
        result = self.fetch_data(self.url)
        if self.retriever.cache_hit:
            self.logger.info("HTTP cache hit, nothing new to do")
            raise StopScraping()
        yield result

    def existing_record(self, record):
        url = record.get('id', '') or record.link
        qs = list(NewsItem.objects.filter(schema__id=self.schema.id, url=url))
        if not qs:
            return None

        if len(qs) > 1:
            self.logger.warn("Multiple entries matched url %r and schema %r. Expected unique! Using first one." % (url, qs[0].schema.slug))
        return qs[0]

    def clean_list_record(self, record):
        record.title = convert_entities(record['title'])
        record.description = convert_entities(record['description'])
        # Don't know why, but some feeds have 'id' *instead* of 'link'.
        if record.get('id', '').startswith('http'):
            record['link'] = record['id']

        # This tries GeoRSS, RDF Geo, xCal, ...
        point, location_name = self.get_point_and_location_name(record)

        _short_title = record['title'][:30] + '...'

        if not point:
            raise SkipRecord("couldn't geocode any addresses in item '%s...'"
                             % _short_title)

        if not location_name:
            raise SkipRecord(
                "Skip, no location name and failed to reverse geocode %s for %r" % (point.wkt, _short_title))

        if not intersects_metro_bbox(point):
            # Check if latitude, longitude seem to be reversed; I've
            # seen that in some bad feeds!
            reversed_loc = Point(point.y, point.x)
            if intersects_metro_bbox(reversed_loc):
                self.logger.info(
                    "Got points in apparently reverse order, flipping them")
                point = reversed_loc
            else:
                raise SkipRecord("Skipping %r as %s,%s is out of bounds" %
                                 (_short_title, point.y, point.x))

        record['location_name'] = location_name
        record['location'] = point
        return record


    def update(self, *args, **kwargs):
        self.logger.info("Retrieving %s" % self.url)
        result = super(RssScraper, self).update(*args, **kwargs)
        self.logger.info("Added: %d; Updated: %d; Skipped: %d" %
                         (self.num_added, self.num_changed, self.num_skipped))
        return result


    def save(self, old_record, list_record, detail_record):
        item_date = datetime.datetime(*list_record.updated_parsed[:6])
        pub_date = item_date

        kwargs = dict(location_name=list_record['location_name'],
                      location=list_record['location'],
                      item_date=item_date,
                      pub_date=pub_date,
                      title=list_record['title'],
                      description=list_record['description'],
                      url=list_record['link'],
                      )
        attributes = None
        self.create_or_update(old_record, attributes, **kwargs)


def main(argv=None, default_url=None):
    import sys
    if argv is None:
        argv = sys.argv[1:]

    from optparse import OptionParser
    usage = "usage: %prog [options] <feed url>"
    parser = OptionParser(usage=usage)

    parser.add_option(
        "--schema", help="Slug of the news item type to create when scraping",
        default="local-news"
        )
    # parser.add_option(
    #     "--http-cache", help='location to use as an http cache.  If a cached value is seen, no update is performed.', 
    #     action='store'
    #     )

    from ebpub.utils.script_utils import add_verbosity_options, setup_logging_from_opts
    add_verbosity_options(parser)

    options, args = parser.parse_args(argv)
    if len(args) >= 1:
        url = args[0]
    else:
        if default_url:
            url = default_url
        else:
            parser.print_usage()
            sys.exit(0)

    scraper = RssScraper(url=url, schema_slug=options.schema)
    setup_logging_from_opts(options, scraper.logger)
    scraper.update()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = meetup_retrieval
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from BeautifulSoup import UnicodeDammit
from django.conf import settings
from django.contrib.gis.geos import Point
from django.utils import simplejson
from ebdata.retrieval.scrapers.list_detail import StopScraping, SkipRecord
from ebdata.retrieval.scrapers.newsitem_list_detail import NewsItemListDetailScraper, local_tz
from ebdata.textmining.treeutils import text_from_html

from ebpub.db.models import NewsItem
import datetime
from ebpub.metros.allmetros import get_metro
api_key = settings.MEETUP_API_KEY

# docs at http://www.meetup.com/meetup_api/docs/2/open_events/

class MeetupScraper(NewsItemListDetailScraper):

    logname = 'meetup_retrieval'
    has_detail = False

    def __init__(self, options):
        self.api_key = settings.MEETUP_API_KEY
        self.options = options
        self.schema_slugs = [options.schema]
        self.records_seen = 0
        super(MeetupScraper, self).__init__()

    def list_pages(self):
        """generate page ... well, not strings, but decoded JSON structures."""
        # TODO: This fetches a ton of data, which is maybe useful for
        # bootstrapping but very inefficient for getting updates.
        # For that we should support meetup's streaming API,
        # which allows passing a start time.

        # Result of each iteration is a JSON structure.
        # Normally in list_detail scrapers we return a string,
        # and leave parsing to parse_list(); but here we need to
        # parse to figure out pagination.
        from ebpub.db.models import Location
        metro = get_metro()
        city, state = metro['city_name'], metro['state']
        # We rotate among zip codes, fetching one page at a time for
        # each, since it's possible/likely that we will hit a rate
        # limit; this way, all the zip codes should get *something*.
        zipcode_state = {}
        ratelimit_remaining = 99999
        while True:
            for zipcode in Location.objects.filter(location_type__slug='zipcodes'):
                zipcode = zipcode.slug
                zipcode_state.setdefault(zipcode, {'page': int(self.options.start_page),
                                                   'done': False})
                if zipcode_state[zipcode]['done']:
                    continue
                try:
                    int(zipcode)
                except ValueError:
                    # meetup will barf on these.
                    self.logger.info("Skipping %s, doesn't look like a valid US zip code" % zipcode)
                    continue

                params = dict(zip=zipcode, key=api_key, city=city, state=state,
                              country='US',
                              time='-1m,2m',
                              )
                pagenum = zipcode_state[zipcode]['page']
                self.logger.info("Page %s for zip code %s" % (pagenum, zipcode))
                params['offset'] = pagenum
                url = 'https://api.meetup.com/2/open_events?key=%(key)s&state=%(state)s&city=%(city)s&country=%(country)s&zip=%(zip)s&page=200&offset=%(offset)s' % params
                page, headers = self.retriever.fetch_data_and_headers(url,
                                                                      raise_on_error=False
)
                ratelimit_remaining = int(headers.get('x-ratelimit-remaining', '9999'))
                while ratelimit_remaining <= 1:
                    # Apparently meetup says you have 1 hit remaining
                    # when they actually mean "this is the last one."
                    # This either raises an exception, or eventually returns new data.
                    ratelimit_reset = int(headers.get('x-ratelimit-reset', 0))
                    page, headers = self.handle_ratelimit_exceeded(url, ratelimit_reset)
                    ratelimit_remaining = int(headers.get('x-ratelimit-remaining', 0))
                    break
                while int(headers.get('status')) >= 400:
                    try:
                        body = simplejson.loads(page)
                        problem, code = body.get('problem'), body.get('code')
                    except simplejson.JSONDecodeError:
                        problem = page
                        code = ''
                    if code == 'limit':
                        # This either raises an exception, or eventually returns new data.
                        page, headers = self.handle_ratelimit_exceeded(url)
                        break
                    else:
                        msg = "Error %s. %s: %s" % (headers.get('status'), code, problem)
                        self.logger.error(msg)
                        raise StopScraping(msg)
                zipcode_state[zipcode]['page'] += 1
                # Parse.
                encoding = headers.get('content-type', '').split('charset=')[-1]
                try:
                    decoded = page.decode(encoding)
                except LookupError:
                    decoded = UnicodeDammit(page, smartQuotesTo='html').unicode
                parsed = simplejson.loads(decoded)
                # Are there more pages?
                if not parsed['meta'].get('next'):
                    zipcode_state[zipcode]['done'] = True
                    self.logger.info("Finished zip code %s" % zipcode)
                yield parsed

            if not False in [value['done'] for value in zipcode_state.values()]:
                self.logger.info("Finished all zip codes")
                break


    def handle_ratelimit_exceeded(self, url, reset_time=None):
        """
        Either sleep until rate limit expires, and retry the url;
        or raise StopScraping, depending on options.
        """
        import time
        if reset_time is None:
            reset_time = time.time() + 3600
        msg = ("Hit rate limit. Resets at %s" %
               datetime.datetime.fromtimestamp(reset_time).ctime())
        sleep_time = reset_time - time.time()
        self.logger.info(msg)
        if self.options.wait_for_rate_limit:
            self.logger.info("Sleeping %.2f seconds" % sleep_time)
            time.sleep(sleep_time)
            self.logger.info("Wait limit should be expired, resuming")
        else:
            raise StopScraping(msg)
        page, headers = self.retriever.fetch_data_and_headers(url, raise_on_error=False)
        return page, headers

    def parse_list(self, page):
        # NOrmally we'd get a string here, but it's easier
        # to do pagination if list_pages does its own parsing.
        results = page.get('results', [])
        for result in results:
            self.records_seen += 1
            yield result

    def clean_list_record(self, record):
        # clean up a record dict
        venue = record.get('venue', {})
        if not venue:
            raise SkipRecord("No venue")
        location_name_parts = [venue.get(key, '').strip() for key in
                               ('address_1', 'address_2', 'city', 'state', 'zip')]
        location_name = ', '.join([p for p in location_name_parts if p])
        event_time = datetime.datetime.fromtimestamp(record['time'] / 1000.0, local_tz)

        cleaned = {'title': text_from_html(record['name']),
                   'description': text_from_html(record.get('description', '')),
                   'location_name': location_name,
                   'location': Point(venue['lon'],
                                     venue['lat']),
                   'url': record['event_url'],
                   'item_date': event_time.date(),
                   }
        attributes = {'venue_phone': venue.get('phone', ''),
                      'venue_name': text_from_html(venue.get('name', '')),
                      'start_time': event_time.time(),
                      'group_name': record['group']['name'],
                      }
        cleaned['_attributes'] = attributes
        return cleaned


    def existing_record(self, record):
        # check if the CLEANED record dict matches a NewsItem
        try:
            item = NewsItem.objects.get(schema=self.schema, url=record['url'])
            return item
        except NewsItem.DoesNotExist:
            return None

    def save(self, old_record, list_record, detail_record):
        attributes = list_record.pop('_attributes')
        self.create_or_update(old_record, attributes, **list_record)

from optparse import OptionParser
parser = OptionParser()
parser.add_option(
    "--schema", help="Slug of schema to use. Default is 'meetups'.",
    action='store', default='meetups',
    )

parser.add_option(
    '-p', '--start-page',
    help="Page of results to start from. Default is zero.",
    default=0
    )
parser.add_option(
    "-n", "--no-wait-for-rate-limit",
    help="If we hit rate limit, exit instead of waiting until it resets (typically 1 hour). Default is to wait.",
    dest="wait_for_rate_limit", action='store_false', default=True,
    )


from ebpub.utils.script_utils import add_verbosity_options, setup_logging_from_opts
add_verbosity_options(parser)

def main(argv=None):
    import sys
    if argv is None:
        argv = sys.argv[1:]
    options, args = parser.parse_args(argv)
    scraper = MeetupScraper(options)
    setup_logging_from_opts(options, scraper.logger)
    scraper.update()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = georeportv2
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

# TODO: Rewrite using https://github.com/codeforamerica/three ?
# Looks much simpler, if it works well.

from django.contrib.gis.geos import Point
from ebpub.utils.geodjango import get_default_bounds
from ebpub.db.models import Schema, SchemaField, NewsItem, Lookup
from ebpub.geocoder.reverse import reverse_geocode
from httplib2 import Http
from lxml import etree
import datetime
import pyrfc3339
import socket
import sys
import time
import traceback
import urllib

import logging
log = logging.getLogger('eb.retrieval.georeportv2')

class GeoReportV2Scraper(object): 

    def __init__(self, api_url, api_key=None, jurisdiction_id=None, 
                 schema_slug='open311-service-requests', http_cache=None,
                 seconds_between_requests=2.0, days_prior=90,
                 timeout=60,
                 bounds=None,
                 html_url_template=None):
        """
        If ``bounds`` is passed, it should be a geometry; news items
        that don't intersect with that geometry will be skipped.
        Default bounds is the extent defined in settings.METRO_LIST.

        If ``html_url_template`` is given, the service_request id is 
        replaced into the string to form the news item's url. eg
        http://somewhere/%s.html.  This is not really part of the GeoReport v2 API, but
        in some cases, like SeeClickFix, there is a well known location based on 
        the identifier for an item.
        """
        self.api_url = api_url
        if not self.api_url.endswith('/'): 
            self.api_url += '/'
 
        self.days_prior = days_prior
        self.seconds_between_requests = seconds_between_requests
        self.schema_slug = schema_slug
        self.schema = Schema.objects.get(slug=self.schema_slug)
        self.service_request_id_field = SchemaField.objects.get(schema=self.schema, name='service_request_id')
        
        self.standard_params = {}
        if api_key is not None: 
            self.standard_params['api_key'] = api_key
        if jurisdiction_id is not None: 
            self.standard_parms['jurisdiction_id'] = jurisdiction_id
        
        self.http = Http(http_cache, timeout=timeout)
        self.bounds = bounds
        if bounds is None:
            log.info("Calculating geographic boundaries from the extent in settings.METRO_LIST")
            self.bounds = get_default_bounds()
            try:
                # Make sure it's a geos geometry, not an ogr/gdal geometry,
                # so we can test for intersecting geos Points.
                self.bounds = self.bounds.geos
            except AttributeError:
                pass
        self.html_url_template = html_url_template

    def service_requests_url(self, start_date, end_date):
        params = dict(self.standard_params)
        params['start_date'] = pyrfc3339.generate(start_date, utc=True, accept_naive=True)
        params['end_date'] = pyrfc3339.generate(end_date, utc=True, accept_naive=True)
        return self.api_url + 'requests.xml?' + urllib.urlencode(params)
    
    def update(self, min_date=None, request_granularity=datetime.timedelta(days=1)):
        now = datetime.datetime.utcnow()
        if min_date is None:
            # default is midnight 90 days ago.
            # use midnight so progressive request urls will 
            # be the same over time, and theoretically should
            # be cacheable.
            start_date = now - datetime.timedelta(days=self.days_prior)
            start_date = datetime.datetime(start_date.year, 
                                           start_date.month,
                                           start_date.day,
                                           0,0,0)
        else:
            start_date = min_date

        while (start_date < now):
            end_date = start_date + request_granularity
            log.info("Fetching from %s - %s" % (start_date, end_date))
            url = self.service_requests_url(start_date, end_date)
            # Pagination is not officially part of the v2 spec, but
            # some endpoints support it, eg. seeclickfix has a non-compliant
            # page size of 20.
            page = 1
            while True:
                items_on_page = self._update(url + '&page=%d' % page)
                time.sleep(self.seconds_between_requests)
                if not items_on_page:
                    break
                page += 1
            start_date = end_date

    def _update(self, url):
        """Make an HTTP request to url, create newsitems,
        return number of items found (not created)
        """
        # make http request to api
        try: 
            log.debug("Requesting %s" % url)
            # User-Agent is a lame workaround for SeeClickFix blocking httplib2
            # (they had too many bots hitting them).
            response, content = self.http.request(url, headers={'User-Agent': 'openblock-georeport-scraper'})
            if response.status != 200:
                log.error("Error retrieving %s: status was %d" % (url, response.status))
                log.error(content)
                return 0
        except socket.error:
            log.error("Couldn't connect to %s" % url)
        except:
            log.error("Unhandled error retrieving %s: %s" % (url, traceback.format_exc()))
            return 0
        log.info("Got %s OK" % url)

        # parse the response
        try: 
            root = etree.XML(content)
        except: 
            log.error("Error parsing response from %s (%s): %s" % (url, content, traceback.format_exc()))
            return
            
        # iterate through the service requests in the response
        reqs = root.findall('.//request')
        if not reqs:
            log.info("No request elements found")
        if response.fromcache:
            log.info("Requests from this time period are unchanged since last update (cached)")
        else:
            for req in reqs:
                self._update_service_request(req)
        return len(list(reqs))

    def _update_service_request(self, sreq):
        service_request_id = self._get_request_field(sreq, 'service_request_id')

        if not service_request_id:
            log.info("Skipping request with no request id (may be in progress)!")
            return


        # pull out the location first, if we can't do this, we don't want it.
        try:
            point = Point(float(sreq.find('long').text), 
                          float(sreq.find('lat').text),
                          srid=4326)
        except: 
            log.debug("Skipping request with invalid location (%s)" % service_request_id)
            return
        if self.bounds is not None:
            if not self.bounds.intersects(point):
                log.debug("Skipping request at %s, outside bounds" % point)
                return
        try:
            ni = NewsItem.objects.filter(schema=self.schema).by_attribute(self.service_request_id_field, 
                                                                          service_request_id).all()[0]
            log.info('updating existing request %s' % service_request_id)
        except IndexError:
            # create the NewsItem
            ni = NewsItem(schema=self.schema)
            log.info('created new service request %s' % service_request_id)

        ni.title = self._get_request_field(sreq, 'service_name')
        ni.description = self._get_request_field(sreq, 'description')
        ni.location = point
        ni.location_name = self._get_request_field(sreq, 'address')
        # try to reverse geocde this point
        if not ni.location_name:
            try:
                block, distance = reverse_geocode(ni.location)
                ni.location_name = block.pretty_name
            except:
                log.debug("Failed to reverse geocode item %s" % service_request_id)

        # try to pull the requested_datetime into pubdate/itemdate
        # default to now.
        try: 
            ni.pub_date = pyrfc3339.parse(sreq.find('requested_datetime').text)
        except:
            ni.pub_date = datetime.datetime.utcnow()
            log.info("Filling in current time for pub_date on item with no requested_datetime (%s)" % service_request_id)
        ni.item_date = datetime.date(ni.pub_date.year, ni.pub_date.month, ni.pub_date.day)

        if self.html_url_template:
            ni.url = self.html_url_template.replace('{id}', service_request_id)
            log.info('Assigning html url "%s" to %s' % (ni.url, service_request_id))

        ni.save()

        ni.attributes['service_request_id'] = service_request_id

        # varchar fields
        for fieldname in ('request_id', 'service_code', 'address_id',
                          'media_url', 'status_notes', 'service_notice'):
            val = self._get_request_field(sreq, fieldname)
            if val != '':
                if len(val) < 4096:
                    ni.attributes[fieldname] = val
                else: 
                    log.info("truncating value for %s (%s)" % (fieldname, val))
                    ni.attributes[fieldname] = val[0:4096]

        # text fields
        for fieldname in ('service_notice'):
            val = self._get_request_field(sreq, fieldname)
            if val != '':
                ni.attributes[fieldname] = val

        
        # datetime fields
        for fieldname in ('expected_datetime', 'requested_datetime'):
            val = self._get_request_field(sreq, fieldname)
            if val == '':
                continue

            # try to parse it
            try:
                ni.attributes[fieldname] = pyrfc3339.parse(val) 
            except ValueError: 
                # invalid date, just omit
                log.info('Omitting invalid datetime field %s = %s' % (fieldname, val))
                pass
        
        # lookups 
        for fieldname in ('service_name', 'agency_responsible', 'status'):
            val = self._get_request_field(sreq, fieldname)
            if val == '': 
                ni.attributes[fieldname] = self._lookup_for(fieldname, 'Unknown')
            ni.attributes[fieldname] = self._lookup_for(fieldname, val)
            
    def _get_request_field(self, request, fieldname):
        val = request.find(fieldname)
        if val is None: 
            return ''
        return (val.text or '').strip()
        
    def _lookup_for(self, fieldname, value):
        sf = SchemaField.objects.get(schema=self.schema, name=fieldname)
        lo = Lookup.objects.get_or_create_lookup(sf, value, make_text_slug=False)
        return lo.slug

def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    from optparse import OptionParser
    usage = "usage: %prog [options] <api url>"
    parser = OptionParser(usage=usage)
    parser.add_option(
        "-k", "--api-key", help='GeoReport V2 API key', action='store',
        )
    parser.add_option(
        "--html-url-template",
        help='template for creating html urls for items based on their identifiers, eg http://example.com/{id}.html',
        action='store'
        )
    parser.add_option(
        "--days-prior", help='how many days ago to start scraping', type="int",
        default=90
        )
    parser.add_option(
        "--schema", help="slug of news item type to use",
        default="open311-service-requests"
        )
    parser.add_option(
        "--http-cache", help='location to use as an http cache.  If a cached value is seen, no update is performed.', 
        action='store'
        )
    parser.add_option(
        "--jurisdiction-id", help='jurisdiction identifier to provide to api',
        action='store'
        )

    from ebpub.utils.script_utils import add_verbosity_options, setup_logging_from_opts
    add_verbosity_options(parser)

    options, args = parser.parse_args(argv)
    setup_logging_from_opts(options, log)

    if len(args) < 1:
        parser.print_usage()
        return 1
    
    scraper = GeoReportV2Scraper(api_url=args[0], api_key=options.api_key,
                                 jurisdiction_id=options.jurisdiction_id,
                                 schema_slug=options.schema,
                                 days_prior=options.days_prior,
                                 http_cache=options.http_cache,
                                 html_url_template=options.html_url_template)
    scraper.update()
    return 0


if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = seeclickfix_retrieval
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.retrieval.scrapers.list_detail import RssListDetailScraper
from ebdata.retrieval.scrapers.list_detail import SkipRecord
from ebdata.retrieval.scrapers.newsitem_list_detail import NewsItemListDetailScraper
from ebpub.db.models import NewsItem

import datetime
import math

#BASE_URL = 'https://seeclickfix.com/api/'
# This one is load-balanced, as requested by the SeeClickFix guys.
BASE_URL = 'http://seeclicktest.com/api/'


class SeeClickFixNewsFeedScraper(RssListDetailScraper, NewsItemListDetailScraper):
    """
    For all of these methods, see docstrings in
    ebdata.retrieval.scrapers.list_detail.ListDetailScraper
    """

    schema_slugs = ('issues',)
    has_detail = True
    logname = 'seeclickfix'
    sleep = 2

    def __init__(self, *args, **kwargs):
        self.city = kwargs.pop('city', None)
        if self.city:
            self.city = self.city.replace(' ', '+')
        self.state = kwargs.pop('state', None)
        super(SeeClickFixNewsFeedScraper, self).__init__(*args, **kwargs)

    def list_pages(self):
        # Fetch the feed, paginating if necessary.
        # See API docs at http://help.seeclickfix.com/faqs/api/listing-issues
        max_per_page = 500
        max_pages = 4
        url = BASE_URL + 'issues.rss?sort=issues.created_at&direction=DESC'
        if self.city and self.state:
            url = '%s&at=%s,+%s' %  (url, self.city, self.state)

        # First, figure out how long it's been since the last scrape;
        # seeclickfix has a 'start' option in hours.  The idea is not
        # to be precise, but to get everything we haven't seen yet and
        # not much that we have seen. So we'll discard microseconds
        # and round up.
        delta = datetime.datetime.now() - self.last_updated_time()
        hours_ago = math.ceil((delta.seconds / 3600.0) + (delta.days * 24))
        for page in range(1, max_pages + 1):
            feed_url = url + '&start=%d&page=%d&num_results=%d' % (
                hours_ago, page, max_per_page)
            self.logger.info("Fetching %s" % feed_url)
            yield self.fetch_data(feed_url)

    def existing_record(self, cleaned_list_record):
        url = cleaned_list_record['id'].replace('http://seeclicktest.com/', 'http://seeclickfix.com/')
        qs = NewsItem.objects.filter(schema__id=self.schema.id, url=url)
        try:
            return qs[0]
        except IndexError:
            return None

    def detail_required(self, list_record, old_record):
        # Always fetch detail pages.
        return True

    def get_detail(self, record):
        # There's no direct link to the JSON detail page,
        # but we can construct one by munging the GUID link.
        url = record['guid'].replace('.html', '.json')
        return self.fetch_data(url)

    def parse_detail(self, page, list_record):
        from django.utils import simplejson
        return simplejson.loads(page)[0]

    def get_location(self, record):
        from django.contrib.gis.geos import Point
        lon = record['lng']
        lat = record['lat']
        return Point(lon, lat)

    def clean_detail_record(self, record):
        location = self.get_location(record)
        # TODO: try self.safe_location? see newsitem_list_detail

        # This is a common error in some data sources we've seen...
        if location and (location.x == 0.0 and location.y == 0.0):
            self.logger.warn("skipping %r as it has bad location 0,0" % record['summary'])
            raise SkipRecord

        item_date = datetime.datetime.strptime(record['created_at'],
                                               '%m/%d/%Y at %I:%M%p')
        item_date = item_date.date()

        url = 'http://seeclickfix.com/issues/%d.html' % record['issue_id']
        attributes = {'rating': record['rating'],
                      }

        result = dict(title=record['summary'],
                      description=record['description'] or u'',
                      item_date=item_date,
                      location=location,
                      location_name=record['address'] or u'', # maybe fall back to reverse-geocoding? Maybe the framework should do that?
                      url=url,
                      attributes=attributes,
                      )
        return result

    def save(self, old_record, list_record, detail_record):
        attributes = detail_record.pop('attributes', None)
        self.create_or_update(old_record, attributes, **detail_record)


def main(argv=None):
    from ebpub.utils.script_utils import add_verbosity_options, setup_logging_from_opts
    import ebdata.retrieval.log # Sets up standard handlers.
    import sys
    if argv is None:
        argv = sys.argv[1:]

    from optparse import OptionParser
    usage = "usage: %prog [options] city state"
    parser = OptionParser(usage=usage)
    add_verbosity_options(parser)

    options, args = parser.parse_args(argv)
    if len(args) != 2:
        parser.print_usage()
        sys.exit(0)
    city, state = args
    scraper = SeeClickFixNewsFeedScraper(city=city.title(), state=state.upper())
    setup_logging_from_opts(options, scraper.logger)

    TESTING = False
    if TESTING:
        from ebdata.retrieval import log_debug
        scraper.display_data()
    else:
        scraper.update()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = retrieval
#   Copyright 2012 OpenPlans and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.


from cStringIO import StringIO
from ebdata.parsing import unicodecsv
from ebdata.parsing import excel
from ebdata.retrieval.scrapers.newsitem_list_detail import NewsItemListDetailScraper
from ebdata.retrieval.scrapers.list_detail import SkipRecord
from ebpub.utils.dates import now, today
from ebpub.db.models import Lookup
import mimetypes
import re
import urllib2


def get_default_unique_field_names():
    """
    Which fields of NewsItem uniquely identify a particular NewsItem.
    """
    # Don't use dates
    blacklist = ('item_date', 'pub_date', 'id', 'schema', 'last_modification',
                 )
    from ebpub.db.models import NewsItem
    return sorted(
        [f.name for f in NewsItem._meta.fields if f.name not in blacklist]
        )

def get_dictreader(items_sheet, items_type='text/csv', map_sheet=None, map_type='text/csv'):
    """
    Given one or two spreadsheets as File objects, or bytestrings,
    return a DictReader that can be used to retrieve rows from
    ``items_sheet``.

    If no ``map_sheet`` is passed, assume that ``items_sheet`` includes headers,
    and return a normal DictReader.

    If ``map_sheet`` is passed, assume it describes which columns from
    ``items_sheet`` should be used for which fields of the output
    dicts.

    Examples follow. First with no map_sheet::

      >>> rows = [['attendee', 'unused', 'event'],
      ...         ['Bob', 'xyz', 'film premiere'],
      ...         ['Carol', 'pdq', 'workshop']]
      >>> csv = '\\n'.join([','.join(map(str, r)) for r in rows])
      >>> reader = get_dictreader(csv)
      >>> import pprint
      >>> pprint.pprint(list(reader))
      [{'attendee': u'Bob', 'event': u'film premiere', 'unused': u'xyz'},
       {'attendee': u'Carol', 'event': u'workshop', 'unused': u'pdq'}]

    If ``map_sheet`` is passed and has *two* rows, then each column
    desribes an old key and a new key for use in re-mapping the output
    dictionaries from items_sheet. Each key of the mapping (from row 1
    of map_sheet) represents the original key from the ``items_sheet``
    header; each value (from row 2 of map_sheet) represents a new key
    for use in the output dict.  Columns whose headers do not appear
    in ``mapping`` are dropped from the output. Example::

      >>> rows = [['attendee', 'unused', 'event'],
      ...         ['Bob', 'xyz', 'film premiere'],
      ...         ['Carol', 'pdq', 'workshop']]
      >>> csv = '\\n'.join([','.join(map(str, r)) for r in rows])
      >>> mapping = {'event': 'where', 'attendee': 'who'}
      >>> map_sheet = 'attendee,event\\nwho,where'
      >>> reader = get_dictreader(csv, map_sheet=map_sheet)
      >>> reader.mapping == mapping
      True
      >>> pprint.pprint(list(reader))
      [{u'where': u'film premiere', u'who': u'Bob'},
       {u'where': u'workshop', u'who': u'Carol'}]


    If ``map_sheet`` is passed and has **one** row, then assume
    ``items_sheet`` has no header; use the row from ``map_sheet`` as a list of
    fieldnames to set in each output dict. The index of each fieldname
    determines the column number of items_sheet that contains that
    field.::

      >>> fieldnames = ['animal', 'color', 'number']
      >>> map_sheet = ','.join(fieldnames)
      >>> rows = [['cat', 'purple', 3], ['dog', 'white', 0], ['bird', 'yellow']]
      >>> csv = '\\n'.join([','.join(map(str, r)) for r in rows])
      >>> reader = get_dictreader(csv, map_sheet=map_sheet)
      >>> pprint.pprint(list(reader))
      [{'animal': u'cat', 'color': u'purple', 'number': u'3'},
       {'animal': u'dog', 'color': u'white', 'number': u'0'},
       {'animal': u'bird', 'color': u'yellow'}]

    If ``map_sheet`` has more than two rows, it's an error::

      >>> map_sheet = 'one,two,three\\nfour,five,six\\n7,8,9\\n'
      >>> get_dictreader(csv, map_sheet=map_sheet) # doctest: +ELLIPSIS
      Traceback (most recent call last):
      ...
      ValueError: Too many rows...

    A map_sheet with zero rows is the same as not passing one at all:

      >>> reader1 = get_dictreader(csv)
      >>> reader2 = get_dictreader(csv, map_sheet='\\n')
      >>> list(reader2) == list(reader1)
      True

    The sheets can be file objects:

      >>> import StringIO
      >>> reader3 = get_dictreader(csv)
      >>> reader4 = get_dictreader(StringIO.StringIO(csv))
      >>> list(reader3) == list(reader4)
      True

    You can pass an old-style Excel spreadsheet (we should probably test with a real one):

      >>> import mock
      >>> with mock.patch('ebdata.scrapers.general.spreadsheet.retrieval.excel.ExcelDictReader') as mock_factory:
      ...     mock_factory.return_value = 'yup it was excel'
      ...     print get_dictreader("blah", items_type='application/vnd.ms-excel')
      yup it was excel

    """

    factory_map = {
        'text/plain': unicodecsv.UnicodeDictReader,
        'text/csv': unicodecsv.UnicodeDictReader,
        'application/vnd.ms-excel': excel.ExcelDictReader,
        'application/msexcel': excel.ExcelDictReader,
    }
    # TODO: use http://packages.python.org/openpyxl/ to handle new-style
    # xslx files. Would require a DictReader-like facade to be written.
    reader_factory = factory_map.get(items_type, unicodecsv.UnicodeDictReader)
    map_reader_factory = factory_map.get(map_type, unicodecsv.UnicodeDictReader)

    if isinstance(items_sheet, basestring):
        items_sheet = StringIO(items_sheet)
    if map_sheet is None:
        # Assume items_sheet is properly set up to just use with a DictReader.
        return reader_factory(items_sheet)
    if isinstance(map_sheet, basestring):
        map_sheet = StringIO(map_sheet)
    mapping = map_reader_factory(map_sheet)
    map_rows = [row for row in list(mapping) if row]
    if len(map_rows) == 0:
        return reader_factory(items_sheet, fieldnames=mapping.fieldnames)
    elif len(map_rows) == 1:
        return RemappingDictReader(items_sheet, map_rows[0], reader_factory)
    else:
        raise ValueError("Too many rows in map_sheet, you can only have 1 or 2")


class RemappingDictReader(object):

    """Wraps another Reader instance and remaps its column names
    according to the ``mapping`` argument.
    """

    def __init__(self, f, mapping, readerclass, **kwargs):
        self.mapping = mapping
        self.reader = readerclass(f, **kwargs)

    def __iter__(self):
        for row in self.reader:
            result = {}
            for oldkey, newkey in self.mapping.items():
                result[newkey] = row.get(oldkey)
            yield result


class SpreadsheetScraper(NewsItemListDetailScraper):
    """General-purpose CSV file scraper.

    You should set ``unique_fields`` to a list of the fields that can
    be used to uniquely identify a row in the input file.
    (TODO: this currently doesn't support Attributes, only core
    NewsItem fields.)

    If you don't set ``unique_fields``, the default is to assume
    that all non-date fields must be unique.
    """

    has_detail = False
    schema_slugs = None
    unique_fields = ()
    get_location_name_from_all_fields = True

    def __init__(self, items_sheet_file, map_sheet_file, *args, **kwargs):
        self.schema_slugs = [kwargs.pop('schema_slug', None)]
        self.unique_fields = kwargs.pop('unique_fields', self.unique_fields)

        super(SpreadsheetScraper, self).__init__(*args, **kwargs)
        self.items_sheet_file = items_sheet_file
        if items_sheet_file:
            self.items_sheet, self.items_type = open_url(items_sheet_file)
            self.items_sheet = self.items_sheet.read()
        else:
            # In this case you'll have to manually set it after __init__.
            self.items_sheet = self.items_type = None
        if map_sheet_file:
            self.map_sheet, self.map_type = open_url(map_sheet_file)
            self.map_sheet = self.map_sheet.read()
        else:
            self.map_sheet = self.map_type = None

    def list_pages(self):
        return [self.items_sheet]

    def parse_list(self, page):
        reader = get_dictreader(page, items_type=self.items_type,
                                map_sheet=self.map_sheet,
                                map_type=self.map_type)
        # DictReaders are iterable and yield dicts, so, we're done.
        return reader


    def existing_record(self, record):
        """
        Uses the fields named in self.unique_fields.
        If self.unique_fields isn't set, use all non-date core fields
        of NewsItem.
        """
        from ebpub.db.models import NewsItem
        query_args = {}
        unique_fields = self.unique_fields or get_default_unique_field_names()
        for field in unique_fields:
            arg = record.get(field)
            if arg:
                query_args[field] = arg

        if not query_args:
            return None
        qs = list(NewsItem.objects.filter(schema__id=self.schema.id, **query_args))
        if not qs:
            return None
        if len(qs) > 1:
            self.logger.warn("Multiple entries matched args %r. Expected unique! Using first one." % str(query_args))
        return qs[0]


    def clean_list_record(self, list_record):
        """
        Given a dict, prepare it for saving as a newsitem.
        Result will be a dictionary of anything from list_record
        that looks like a known field of the NewsItem model.

        Anything that looks like a known SchemaField of the item's Schema
        will be set as an item in an 'attributes' sub-dictionary.

        Unrecognized keys will be ignored (and logged).

        Locations are found heuristically:
         - If there's a 'location' key, try to split the value into (lat, lon) points
         - If there's keys like 'latitude'/'lat' and 'longitude'/'lon'/'long'/'lng', use those
         - If there's a 'location_name', geocode if needed
         - If there's no 'location_name', reverse-geocode if possible

        """
        from ebpub.db.models import NewsItem
        fieldnames = [f.name for f in NewsItem._meta.fields]
        core_fields = {}
        from ebdata.retrieval.utils import get_point
        if 'location' in list_record:
            # If there's a comma- or space-separated location in the
            # orginal, this gives us a way to use it by mapping it to
            # "location"
            try:
                lat, lon = re.split(r'[\s,]+', str(list_record.pop('location')))
                list_record.setdefault('lat', lat)
                list_record.setdefault('lon', lon)
            except ValueError:
                pass
        # Now try all the field names recognized by get_point(), eg
        # lat, latitude, lon, long, lng, georss_point, etc.
        point = get_point(list_record)
        for fieldname in fieldnames:
            if fieldname in list_record:
                # TODO: coerce types? Or maybe Django's implicit conversion is OK.
                core_fields[fieldname] = list_record.pop(fieldname)

        # Try to ensure we have both point and location_name;
        # fall back to address extraction from *all* fields.
        address_text = core_fields.get('location_name')
        if self.get_location_name_from_all_fields and not address_text:
            address_text = '\n'.join([unicode(s) for s in list_record.values()])
        point, location_name = self.geocode_if_needed(point, address_text)
        core_fields['location'] = point
        core_fields['location_name'] = location_name

        # Attributes.
        attributes = list_record.get('attributes', {})
        schemafields = self.schema.schemafield_set.all()
        for sf in schemafields:
            if sf.name in list_record:
                # TODO: coerce types? Or maybe Django's implicit conversion is OK.
                value = list_record.pop(sf.name)
                if sf.is_many_to_many_lookup():
                    # Passed value needs to be a list of strings.
                    if isinstance(value, basestring):
                        value = [value]
                    lookups = [
                        Lookup.objects.get_or_create_lookup(
                            sf, name=v, code=v, make_text_slug=False
                        )
                        for v in value]
                    value = ','.join([str(lookup.id) for lookup in lookups])

                elif sf.is_lookup:
                    # Need an int id.
                    value = unicode(value)
                    value = Lookup.objects.get_or_create_lookup(
                        sf, name=value, code=value, make_text_slug=False)
                    value = value.id
                else:
                    # TODO: handle other types?
                    value = unicode(value)
                attributes[sf.name] = value
        core_fields['attributes'] = attributes
        if len(list_record):
            self.logger.debug("Unused stuff from list_record: %s" % list_record)
        return core_fields

    def save(self, old_record, list_record, detail_record):
        attributes = list_record.pop('attributes', {})
        list_record.setdefault('schema', self.schema.id)
        if not old_record:
            list_record.setdefault('item_date', today())
            list_record.setdefault('pub_date', now())
        from ebpub.db.forms import NewsItemForm
        form = NewsItemForm(list_record, instance=old_record)
        if form.is_valid():
            return self.create_or_update(old_record, attributes,
                                         **form.cleaned_data)
        else:
            self.logger.info("Skipping due to validation failures:")
            for key, val in form.errors.items():
                self.logger.info("%s: %s" % (key, val.as_text()))
            raise SkipRecord(form.errors)


    def update(self, *args, **kwargs):
        self.logger.info("Retrieving %s" % self.items_sheet_file)
        result = super(SpreadsheetScraper, self).update(*args, **kwargs)
        self.logger.info("Added: %d; Updated: %d; Skipped: %d" %
                         (self.num_added, self.num_changed, self.num_skipped))
        return result


def open_url(url):
    """maybe it's a URI, maybe a local file.
    Either way, return a file-like object and a mimetype.
    """
    try:
        return (file(url), mimetypes.guess_type(url)[0])
    except IOError:
        return (urllib2.urlopen(url), mimetypes.guess_type(url)[0])


def main(argv=None):
    import sys
    if argv is None:
        argv = sys.argv[1:]
    from optparse import OptionParser
    usage = "usage: %prog [options] <spreadsheet> [<mapping spreadsheet>]"
    usage += "\n\nSpreadsheet arguments can be local files or URLs."
    usage += "\n\nSee http://openblockproject.org/docs/packages/ebdata.html#spreadsheets-scrapers-general-spreadsheet for more."
    parser = OptionParser(usage=usage)

    parser.add_option(
        "--schema", help="slug of news item type to create when scraping",
        default="local-news"
        )

    parser.add_option(
        "--unique-fields", help="Which NewsItem fields identify a unique record in this data source. Comma-separated, eg. --unique-fields='url,location_name,title",
        action="store", default=None
        )

    from ebpub.utils.script_utils import add_verbosity_options, setup_logging_from_opts
    add_verbosity_options(parser)

    options, args = parser.parse_args(argv)
    if len(args) >= 1:
        items_sheet = args[0]
        if len(args) >= 2:
            map_sheet = args[1]
        else:
            map_sheet = None
    else:
        parser.print_usage()
        sys.exit(0)

    if options.unique_fields:
        unique_fields = [s.strip() for s in options.unique_fields.split(',')]
    else:
        unique_fields = []
    scraper = SpreadsheetScraper(items_sheet, map_sheet,
                                 schema_slug=options.schema,
                                 unique_fields=unique_fields)
    setup_logging_from_opts(options, scraper.logger)
    scraper.update()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = tests
#   Copyright 2012 OpenPlans and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.


import django.test
import mock
import os
import unittest
from ebdata.retrieval.scrapers.tests import HERE

class TestCsvScraper(django.test.TestCase):

    fixtures = (os.path.join(HERE, 'fixtures', 'test_scraper_fixtures.json')
                ,)

    def _get_schema(self):
        from ebpub.db.models import Schema
        schema = Schema.objects.get(
            slug='scrapertest-news'
            )
        return schema

    def _make_scraper(self):
        from ..spreadsheet import retrieval
        schema = self._get_schema()
        scraper = retrieval.SpreadsheetScraper(
            None, None, use_cache=False, schema_slug=schema.slug)
        # Be quiet!
        scraper.logger = mock.Mock()
        return scraper

    def test_clean_list_record__no_info(self):
        scraper = self._make_scraper()
        cleaned = scraper.clean_list_record({})
        self.assertEqual(cleaned,
                         {'attributes': {},
                          'location': None, 'location_name': ''})

    def test_clean_list_record__ok(self):
        scraper = self._make_scraper()
        cleaned = scraper.clean_list_record({'title': 't1', 'description': 'd1'})
        self.assertEqual(cleaned, {'title': 't1',
                                   'description': 'd1',
                                   'location': None,
                                   'location_name': '',
                                   'attributes': {}})

        cleaned = scraper.clean_list_record({'title': 't2', 'unknown': 'blah'})
        self.assertEqual(cleaned, {'title': 't2',
                                   'location': None,
                                   'location_name': u'blah',
                                   'attributes': {}})

        cleaned = scraper.clean_list_record({'title': 't3', 'attr1': 'a1'})
        self.assertEqual(cleaned, {'title': 't3',
                                   'location': None,
                                   'location_name': u'a1',
                                   'attributes': {u'attr1': 'a1'}})

    def test_clean_list_record__locations(self):
        scraper = self._make_scraper()
        cleaned = scraper.clean_list_record({'title': 't3', 'location': '1.1 2.2'})
        self.assertEqual(cleaned['location'].x, 2.2)
        self.assertEqual(cleaned['location'].y, 1.1)

        cleaned = scraper.clean_list_record({'title': 't3', 'location': '1.1, 2.2'})
        self.assertEqual(cleaned['location'].x, 2.2)
        self.assertEqual(cleaned['location'].y, 1.1)

        scraper = self._make_scraper()
        cleaned = scraper.clean_list_record({'title': 't3', 'lat': -9.0, 'lon': 3.3})
        self.assertEqual(cleaned['location'].x, 3.3)
        self.assertEqual(cleaned['location'].y, -9.0)


    @mock.patch('ebpub.db.models.logger')
    def test_save__no_info(self, mock_logger):
        scraper = self._make_scraper()
        from ebdata.retrieval.scrapers.list_detail import SkipRecord
        with self.assertRaises(SkipRecord) as e:
            scraper.save(None, {}, None)
        self.assertEqual(e.exception.message['location_name'],
                          [u'This field is required.'])
        with self.assertRaises(SkipRecord) as e:
            scraper.save(None, {'blah': 'blech'}, None)
        self.assertEqual(e.exception.message['location_name'],
                          [u'This field is required.'])


    @mock.patch('ebpub.db.models.logger')
    def test_save__not_enough_info(self, mock_logger):
        from ebdata.retrieval.scrapers.list_detail import SkipRecord
        info = {'title': 't1', 'description': 'd1', 'attr1': 'a1', 'bad': 'b1'}
        scraper = self._make_scraper()
        with self.assertRaises(SkipRecord) as e:
            scraper.save(None, info, None)
        self.assertEqual(e.exception.message['location_name'],
                         [u'This field is required.'])


    @mock.patch('ebpub.db.models.logger')
    def test_save__ok(self, mock_logger):
        info = {'title': 't1', 'description': 'd1', 'location_name': 'somewhere',
                'attributes': {'attr1': 'a1', 'bad1': 'b1'},
                'bad2': 'b2'}
        scraper = self._make_scraper()
        item = scraper.save(None, info, None)
        self.assertEqual(item.attributes['attr1'], 'a1')
        self.assertEqual(item.title, 't1')
        self.assertEqual(item.description, 'd1')
        self.failIf('bad1' in item.attributes)
        self.failIf(hasattr(item, 'bad2'))


    @mock.patch('ebdata.scrapers.general.spreadsheet.retrieval.open_url')
    def test_init_opens_files(self, mock_opener):
        from ..spreadsheet import retrieval
        schema = self._get_schema()
        mock_opener.return_value = (mock.Mock(), 'text/csv')
        retrieval.SpreadsheetScraper(
            'foo.txt', 'bar.txt', use_cache=False, schema_slug=schema.slug)
        self.assertEqual(mock_opener.call_count, 2)
        self.assertEqual(mock_opener.call_args_list,
                         [(('foo.txt',),),
                          (('bar.txt',),)])


    def test_existing_record__default_unique_fields(self):
        scraper = self._make_scraper()
        record = {'title': 't1', 'location_name': 'ln1', 'description': 'd1',
                  'schema': self._get_schema(),
                  }
        from ebpub.db.models import NewsItem
        self.assertEqual(scraper.unique_fields, ())
        self.assertEqual(scraper.existing_record(record), None)
        ni = NewsItem.objects.create(**record)
        try:
            self.assertEqual(scraper.existing_record(record), ni)
        finally:
            ni.delete()

    def test_existing_record__unknown_field(self):
        scraper = self._make_scraper()
        record = {'title': 't1', 'location_name': 'ln1', 'description': 'd1',
                  'schema': self._get_schema(),
                  }
        from ebpub.db.models import NewsItem
        scraper.unique_fields = ('No Such Thing',)
        ni = NewsItem.objects.create(**record)
        try:
            self.assertEqual(scraper.existing_record(record), None)
        finally:
            ni.delete()

    def test_existing_record__changed_value(self):
        scraper = self._make_scraper()
        record = {'title': 't1', 'location_name': 'ln1', 'description': 'd1',
                  'schema': self._get_schema(),
                  }
        from ebpub.db.models import NewsItem
        scraper.unique_fields = ('location_name',)
        ni = NewsItem.objects.create(**record)
        try:
            self.assertEqual(scraper.existing_record(record), ni)
            record['location_name'] = 'ln2'
            self.assertEqual(scraper.existing_record(record), None)
        finally:
            ni.delete()

    def test_existing_record__dates(self):
        scraper = self._make_scraper()
        record = {'title': 't1', 'location_name': 'ln1', 'description': 'd1',
                  'schema': self._get_schema(),
                  'item_date': '2011-12-31', 'pub_date': '2011-12-31 11:59:59',
                  }
        from ebpub.db.models import NewsItem
        scraper.unique_fields = ('location_name',)
        ni = NewsItem.objects.create(**record)
        try:
            self.assertEqual(scraper.existing_record(record), ni)
            # Still works if you change dates.
            record['item_date'] = '2012-01-01'
            self.assertEqual(scraper.existing_record(record), ni)
            record['pub_date'] = '2012-01-01 12:01:01'
            self.assertEqual(scraper.existing_record(record), ni)
        finally:
            ni.delete()


def suite():
    import doctest
    from ..spreadsheet import retrieval
    suite = unittest.TestLoader().loadTestsFromTestCase(TestCsvScraper)
    suite.addTest(doctest.DocTestSuite(retrieval, optionflags=doctest.ELLIPSIS))
    return suite

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = retrieval
#   Copyright 2007,2008,2009 Everyblock LLC
#
#   This file is part of everyblock
#
#   everyblock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   everyblock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with everyblock.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Screen scraper for Boston building permits.
http://www.cityofboston.gov/isd/building/asofright/default.asp
"""

from ebdata.retrieval.scrapers.newsitem_list_detail import NewsItemListDetailScraper
from ebpub.db.models import NewsItem
from ebpub.utils.dates import parse_date
from ebpub.utils.text import smart_title
import re
import urllib

# These are the neighborhoods that can be searched-by at
# http://www.cityofboston.gov/isd/building/asofright/default.asp
NEIGHBORHOODS = (
    'Allston',
    'Back Bay',
    'Beacon Hill',
    'Brighton',
    'Charlestown',
    'Chinatown',
    'Dorchester',
    'Dorchester (Lower Mills)',
    'Dorchester (Meeting House Hill)',
    'Dorchester (Neponset, Cedar Grove)',
    'Dorchester (Savin Hill)',
    'East Boston',
    'Fenway',
    'Financial District',
    'Hyde Park',
    'Jamaica Plain',
    'Mattapan',
    'Mission Hill',
    'North Dorchester',
    'NorthEnd',
    'Roslindale',
    'Roxbury',
    'South Boston',
    'South End',
    'West End',
    'West Roxbury',
)

class PermitScraper(NewsItemListDetailScraper):
    schema_slugs = ('building-permits',)
    has_detail = False
    parse_list_re = re.compile(r'<tr[^>]*><td[^>]*>(?P<permit_date>\d\d?/\d\d/\d{4})\s*</td><td[^>]*>(?P<address>[^<]*)<br/>(?P<neighborhood>[^<]*)</td><td[^>]*>(?P<owner>[^<]*)</td><td[^>]*>(?P<description>[^<]*)</td></tr>', re.IGNORECASE | re.DOTALL)

    url = 'http://www.cityofboston.gov/isd/building/asofright/default.asp?ispostback=true&nhood'
    def list_pages(self):
        for name in NEIGHBORHOODS:
            url = '%s=%s' % (self.url, urllib.quote_plus(name))
            # FIXME: see ticket 172
            yield self.get_html(url)

    def clean_list_record(self, record):
        record['permit_date'] = parse_date(record['permit_date'], '%m/%d/%Y')
        record['description'] = re.sub(r'[\r\n]+', ' ', record['description']).strip()
        record['description'] = record['description'].decode('iso-8859-1') # Avoid database-level encoding errors
        record['clean_address'] = smart_title(record['address'])
        return record

    def existing_record(self, record):
        try:
            qs = NewsItem.objects.filter(schema__id=self.schema.id, item_date=record['permit_date'])
            qs = qs.by_attribute(self.schema_fields['raw_address'], record['address'])
            return qs[0]
        except IndexError:
            return None

    def save(self, old_record, list_record, detail_record):
        if old_record is not None:
            self.logger.debug('Record already exists')
            return

        attributes = {
            'raw_address': list_record['address'],
            'description': list_record['description'],
            'owner': list_record['owner'],
        }
        self.create_newsitem(
            attributes,
            title='Building permit issued at %s' % list_record['clean_address'],
            description=list_record['description'],
            item_date=list_record['permit_date'],
            location_name=list_record['clean_address'],
        )

if __name__ == "__main__":
    from ebdata.retrieval import log_debug
    PermitScraper().update()


########NEW FILE########
__FILENAME__ = retrieval
#   Copyright 2007,2008,2009 Everyblock LLC
#
#   This file is part of everyblock
#
#   everyblock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   everyblock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with everyblock.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Scraper for Boston building permits.

http://www.cityofboston.gov/cityclerk/search_reply.asp
"""

from ebdata.retrieval.scrapers.list_detail import SkipRecord
from ebdata.retrieval.scrapers.newsitem_list_detail import NewsItemListDetailScraper
from ebpub.db.models import NewsItem
from ebpub.utils.dates import parse_date
from ebpub.utils.text import smart_title
from urllib import urlencode
import datetime
import re

# An opt-out list of businesses to ignore for privacy reasons.
BUSINESS_NAMES_TO_IGNORE = set([
    ('THINK COOL COSMETICS', '176 WASHINGTON ST'),
])

class Scraper(NewsItemListDetailScraper):
    schema_slugs = ['business-licenses']
    has_detail = False
    parse_list_re = re.compile(r'(?s)<div class="mainColTextBlueBold">(?P<name>.*?)</div><br>\s+?<b>Date:</b>(?P<date>.*?)<br>\s+?<b>Type:</b>(?P<business_type>.*?)<br>\s+?<b>Business Address:</b>(?P<location>.*?)<br>\s+?<b>File #:</b>(?P<file_number>.*?)<br>')
    sleep = 1
    uri = 'http://www.cityofboston.gov/cityclerk/search_reply.asp'

    def __init__(self, *args, **kwargs):
        self.start_date = kwargs.pop('start_date', None)
        super(Scraper, self).__init__(*args, **kwargs)

    def find_next_page_url(self, html, current_page_number):
        pattern = r"<a href='(.*?)'>%s</a>" % (current_page_number + 1)
        print pattern
        m = re.search(pattern, html)
        if m is None:
            return None
        return "http://www.cityofboston.gov%s" % m.group(1)

    def list_pages(self):
        if not self.start_date:
            date = datetime.date.today() - datetime.timedelta(days=7)
        else:
            date = self.start_date
        while date <= datetime.date.today():
            page_number = 1
            while 1:
                params = {
                    'whichpage': str(page_number),
                    'pagesize': '10',
                    'name_fold': '',
                    'name_doc': date.strftime('%Y-%m-%d'),
                    'index1': '',
                    'index2': '',
                    'index3': '',
                    'index4': '',
                    'index6': '',
                    'tempday': date.strftime('%d'),
                    'tempmonth': date.strftime('%m'),
                    'tempyear': date.strftime('%Y'),
                }
                html = self.get_html(self.uri + '?' + urlencode(params))
                try:
                    max_pages = int(re.search(r'Page \d+ of (\d+)', html).group(1))
                except AttributeError:
                    break
                yield html
                page_number += 1
                if page_number > max_pages:
                    break
            date = date + datetime.timedelta(days=1)

    def clean_list_record(self, record):
        notes = []
        notes_pats = [r'(?P<value>.*?)\s*\-*\s*(?P<notes>\(?\s*w\/d.*)',
                      r'(?P<value>.*?)\s*\-*\s*(?P<notes>\(?\s*withd.*)', 
                      r'(?P<value>.*?)\s*\-*\s*(?P<notes>\(?\s*ch\s+227\s+sec\s*5A.*)',
                      r'(?P<value>.*?)\s*\-*\s*(?P<notes>\(?\s*ch\s+bus\s+.*)',
                      r'(?P<value>.*?)\s*\-*\s*(?P<notes>\(?\s*c\/l.*)',
                      ]

        # strip notes off of several cruft-prone fields
        for field in ['name', 'business_type', 'location']:
            val = record.get(field, '').strip()
            for pat in notes_pats: 
                m = re.match(pat, val, re.I|re.M)
                if m is not None: 
                    results = m.groupdict()
                    val = results['value']
                    notes.append(results['notes'])
            record[field] = val.strip()

        record['notes'] = notes
        record['location'] = smart_title(record['location'].strip())
        record['date'] = parse_date(record['date'].strip(), '%Y-%m-%d')
        if (record['name'].upper(), record['location'].upper()) in BUSINESS_NAMES_TO_IGNORE:
            raise SkipRecord('Skipping %s (explicitly ignored)' % record['name'])
        if (record['location'] == ''):
            raise SkipRecord('Skipping %s (no location)' % record['name'])
        return record

    def existing_record(self, list_record):
        qs = NewsItem.objects.filter(schema__id=self.schema.id, item_date=list_record['date'])
        qs = qs.by_attribute(self.schema_fields['name'], list_record['name'])
        try:
            return qs[0]
        except IndexError:
            return None

    def save(self, old_record, list_record, detail_record):
        if old_record is not None:
            return
        if list_record['name'].upper() in ['NONE', '']:
            return
        business_type_lookup = self.get_or_create_lookup('business_type', list_record['business_type'], list_record['business_type'], make_text_slug=False)
        attributes = {
            'name': list_record['name'],
            'file_number': list_record['file_number'],
            'business_type': business_type_lookup.id,
            'notes': ','.join(list_record['notes'])[0:255]
        }
        self.create_newsitem(
            attributes,
            title=list_record['name'],
            item_date=list_record['date'],
            location_name=list_record['location']
        )

def main(argv=None):
    import sys
    from ebpub.utils.script_utils import add_verbosity_options, setup_logging_from_opts
    from optparse import OptionParser
    if argv is None:
        argv = sys.argv[1:]
    optparser = OptionParser()
    optparser.add_option('-s', '--start-date',
                         help='Date to start scraping, in YYYY/MM/DD format. If not passed, default is 7 days ago.'
                         )
    add_verbosity_options(optparser)
    opts, args = optparser.parse_args(argv)
    if opts.start_date:
        from ebpub.utils.dates import parse_date
        start_date = parse_date(opts.start_date, '%Y/%m/%d')
    else:
        start_date = None
    scraper = Scraper(start_date=start_date)
    setup_logging_from_opts(opts, scraper.logger)
    scraper.update()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = retrieval
#!/usr/bin/env python
# encoding: utf-8

#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

#pylint: disable-msg=E1101
#pylint: disable-msg=W0142

"""
add_events.py

Created by Don Kukral <don_at_kukral_dot_org>

Downloads calendar entries from RSS feed at boston.com 
and updates the database
"""

from django.conf import settings
from django.contrib.gis.geos import Point
from ebpub.db.models import NewsItem, Schema
from ebpub.utils.script_utils import add_verbosity_options, setup_logging_from_opts
from optparse import OptionParser
import dateutil.parser
import ebdata.retrieval.log  # sets up base handlers.
import logging
import pytz
import sys, feedparser, datetime

# Note there's an undocumented assumption in ebdata that we want to
# put unescape html before putting it in the db.  Maybe wouldn't have
# to do this if we used the scraper framework in ebdata?
from ebdata.retrieval.utils import convert_entities

logger = logging.getLogger('eb.retrieval.boston.events')

local_tz = pytz.timezone(settings.TIME_ZONE)

class EventsCalendarScraper(object):

    url = "http://calendar.boston.com/search?commit=Search&new=n&rss=1&search=true&srad=50&srss=&st=event&st_select=event&svt=text&swhat=&swhen=&swhere="

    def __init__(self, schema_slug='events'):
        try:
            self.schema = Schema.objects.get(slug=schema_slug)
        except Schema.DoesNotExist:
            logger.error("Schema (%s): DoesNotExist" % schema_slug)
            sys.exit(1)
        
    def update(self):
        """ Download Calendar RSS feed and update database """
        logger.info("Starting EventsCalendarScraper")
        
        feed = feedparser.parse(self.url)
        seencount = addcount = updatecount = 0
        for entry in feed.entries:

            def ns_get(element):
                # work around feedparser unpredictability.
                namespace, element = element.split(':')
                result = entry.get('%s_%s' % (namespace, element))
                if result is None:
                    result = entry.get(element)
                return result

            seencount += 1
            title = convert_entities(entry.title)
            try:
                item = NewsItem.objects.get(title=title,
                                            schema__id=self.schema.id)
                status = "updated"
            except NewsItem.DoesNotExist:
                item = NewsItem()
                status = "added"
            except NewsItem.MultipleObjectsReturned:
                logger.warn("Multiple entries matched title %r, event titles are not unique?" % title)
                continue
            try:
                item.location_name = '%s %s' % (ns_get('xcal:x-calconnect-venue-name'),
                                                ns_get('xcal:x-calconnect-street'))
                item.location_name = item.location_name.strip()
                item.schema = self.schema
                item.title = title
                item.description = convert_entities(entry.description)
                item.url = entry.link
                start_dt = ns_get('xcal:dtstart')
                start_dt = dateutil.parser.parse(start_dt)
                # Upstream bug: They provide a UTC offset of +0000 which
                # means times in UTC, but they're actually times in
                # US/Eastern, so do *not* fix the zone.
                #start_dt = start_dt.astimezone(local_tz)
                item.item_date = start_dt.date()
                item.pub_date = datetime.datetime(*entry.updated_parsed[:6])
                item.location = Point((float(ns_get('geo:long')),
                                       float(ns_get('geo:lat'))))
                if (item.location.x, item.location.y) == (0.0, 0.0):
                    logger.warn("Skipping %r, bad location 0,0" % item.title)
                    continue

                if not item.location_name:
                    # Fall back to reverse-geocoding.
                    from ebpub.geocoder import reverse
                    try:
                        block, distance = reverse.reverse_geocode(item.location)
                        logger.info(" Reverse-geocoded point to %r" % block.pretty_name)
                        item.location_name = block.pretty_name
                    except reverse.ReverseGeocodeError:
                        logger.debug(" Failed to reverse geocode %s for %r" % (item.location.wkt, item.title))
                        item.location_name = u''

                item.save()
                item.attributes['start_time'] = start_dt.time()
                end_dt = ns_get('xcal:dtend') or u''
                if end_dt.strip():
                    end_dt = dateutil.parser.parse(end_dt.strip())
                    #end_dt = end_dt.astimezone(local_tz)
                    item.attributes['end_time'] = end_dt.time()
                if status == 'added':
                    addcount += 1
                else:
                    updatecount += 1
                logger.info("%s: %s" % (status, item.title))
            except Exception as e:
                logger.exception("unexpected error: %s" % e)
        logger.info("EventsCalendarScraper finished: %d added, %d updated of %s total" % (addcount, updatecount, seencount))

def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]
    optparser = OptionParser()
    add_verbosity_options(optparser)
    opts, args = optparser.parse_args(argv)
    setup_logging_from_opts(opts, logger)
    EventsCalendarScraper().update()

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = retrieval
#   Copyright 2011,2012 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

"""

Boston police reports scraper.
http://www.bpdnews.com/

"""

from ebdata.retrieval.scrapers.list_detail import RssListDetailScraper
from ebdata.retrieval.scrapers.list_detail import SkipRecord
from ebdata.retrieval.scrapers.newsitem_list_detail import NewsItemListDetailScraper
from ebdata.textmining.treeutils import text_from_html
from ebpub.db.models import NewsItem
import datetime


class BPDNewsFeedScraper(RssListDetailScraper, NewsItemListDetailScraper):

    schema_slugs = ('police-reports',)
    has_detail = False
    logname = 'boston.police_reports'

    # Can't find a way to specify number of items.
    url = 'http://www.bpdnews.com/feed/'

    def list_pages(self):
        yield self.fetch_data(self.url)

    def existing_record(self, cleaned_record):
        url = cleaned_record['url']
        qs = NewsItem.objects.filter(schema__id=self.schema.id, url=url)
        try:
            return qs[0]
        except IndexError:
            return None

    def clean_list_record(self, record):
        if record['title'].startswith(u'Boston 24'):
            # We don't include the summary posts.
            # TODO: the 'Boston 24' tag indicates posts with aggregate
            # daily stats.  Make a separate schema for the aggregates,
            # with attributes like those used in
            # everyblock/everyblock/cities/nyc/crime_aggregate/retrieval.py.
            # Or maybe not: these are citywide, not by precinct.
            # So what would be the Location?  Whole city??
            self.logger.info("boston daily crime stats, we don't know how to "
                             "handle these yet")
            raise SkipRecord

        date = datetime.date(*record['updated_parsed'][:3])
        description = record['summary']

        # This feed doesn't provide geographic data; we'll try to
        # extract addresses from the text, and stop on the first
        # one that successfully geocodes.
        full_description = record['content'][0]['value']
        full_description = text_from_html(full_description)
        location, location_name = self.get_point_and_location_name(
            record, address_text=full_description)

        if not (location or location_name):
            raise SkipRecord("No location or location_name")

        # Get the precinct from the tags.
        precincts = ['A1', 'A15', 'A7', 'B2', 'B3', 'C11', 'C6', 'D14', 'D4',
                     'E13', 'E18', 'E5']
        tags = [t['term'] for t in record['tags']]
        precinct = None
        for tag in tags:
            if tag in precincts:
                # TODO: we need a LocationType for precincts, and shapes; and
                # then we could set newsitem.location_object to the Location
                # for this precinct. For now we just save it as an attribute.
                precinct = tag
                break

        attributes = {}
        if precinct:
            precinct = self.get_or_create_lookup('precinct', precinct, precinct)
            attributes['precinct'] = precinct.id
        else:
            raise SkipRecord("no precinct found in tags %r" % tags)

        cleaned = dict(item_date=date,
                       location=location,
                       location_name=location_name,
                       title=record['title'],
                       description=description,
                       url=record['link'],
                       attributes=attributes,
                       )

        return cleaned


    def save(self, old_record, list_record, detail_record):
        attributes = list_record.pop('attributes', None)
        # We don't use detail_record
        kwargs = list_record
        self.create_or_update(old_record, attributes, **kwargs)


def main(argv=None):
    import sys
    from ebpub.utils.script_utils import add_verbosity_options, setup_logging_from_opts
    from optparse import OptionParser
    if argv is None:
        argv = sys.argv[1:]
    optparser = OptionParser()
    add_verbosity_options(optparser)
    scraper = BPDNewsFeedScraper()
    opts, args = optparser.parse_args(argv)
    setup_logging_from_opts(opts, scraper.logger)
    scraper.update()

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = retrieval
#   Copyright 2007,2008,2009 Everyblock LLC
#
#   This file is part of everyblock
#
#   everyblock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   everyblock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with everyblock.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Screen scraper for Boston restaurant inspections.

http://www.cityofboston.gov/isd/health/mfc/search.asp
"""

from django.core.serializers.json import DjangoJSONEncoder
from ebdata.retrieval.scrapers.base import ScraperBroken
from ebdata.retrieval.scrapers.newsitem_list_detail import NewsItemListDetailScraper
from ebpub.db.models import NewsItem
from ebpub.utils.dates import parse_date
from ebpub.utils.text import smart_title
import re

parse_main_re = re.compile(r"<tr[^>]*><td[^>]*><a href='insphistory\.asp\?licno=(?P<restaurant_id>\d+)'>(?P<restaurant_name>[^<]*)</a></td><td[^>]*>(?P<address>[^<]*)</td><td[^>]*>(?P<neighborhood>[^<]*)</td></tr>")
detail_violations_re = re.compile(r"<tr[^>]*><td[^>]*><span[^>]*>(?P<stars>\*+)</span></td><td[^>]*><span[^>]*>(?P<status>[^<]*)</span></td><td[^>]*><span[^>]*>(?P<code>[^<]*)</span></td><td[^>]*><span[^>]*>(?P<description>[^<]*)<p><i>Comments:<br></i>(?P<comment>[^<]*)</p></span></td><td[^>]*><span[^>]*>(?P<location>.*?)</span></td></tr>", re.DOTALL)
detail_url = lambda inspection_id: 'http://www.cityofboston.gov/isd/health/mfc/viewinsp.asp?inspno=%s' % inspection_id

strip_tags = lambda x: re.sub(r'(?s)</?[^>]*>', '', x).replace('&nbsp;', ' ').strip()

class RestaurantScraper(NewsItemListDetailScraper):

    logname = 'us.ma.boston.restaurants'

    # Sadly, there appears to be no way to query by date;
    # we have no choice but to crawl the entire site every time.

    schema_slugs = ('restaurant-inspections',)
    detail_address_re = re.compile(r"View Inspections[^<]*</div>[^<]*<br/?>?<b>(?P<restaurant_name>[^<]*)</b>[^<]*<br/>(?P<address_1>[^<]*)<br/>(?P<address_2>[^<]*)(?P<zipcode>\d\d\d\d\d)[^<]*<br/>")
    parse_list_re = re.compile(r" href='viewinsp\.asp\?inspno=(?P<inspection_id>\d+)'>(?P<inspection_date>[^<]*)</a></span></td><td[^>]*><span[^>]*>(?P<result>[^<]*)</span>")
    parse_detail_re = re.compile(r"<th[^>]*>Status</th><th[^>]*>Code Violation</th><th[^>]*>Description</th><th[^>]*>Location</th></tr>(?P<body>.*?)</table>", re.DOTALL)
    sleep = 4

    def __init__(self, name_start=''):
        # name_start, if given, should be a string of the first restaurant name
        # to start scraping, alphabetically. This is useful if you've run the
        # scraper and it's broken several hours into it -- you can pick up
        # around where it left off.
        NewsItemListDetailScraper.__init__(self)
        self.name_start = (name_start or u'').lower().strip()


    def update(self, *args, **kwargs):
        self.logger.info("This is a VERY slow scraper, it typically takes hours!")
        import time
        start = time.time()
        super(RestaurantScraper, self).update(*args, **kwargs)
        elapsed = time.time() - start
        hours, elapsed = divmod(elapsed, 3600)
        mins, secs = divmod(elapsed, 60)
        self.logger.info("Done scraping restaurants in %02d:%02d:%02d" % (hours, mins, secs))
        
    def list_pages(self):
        # Submit the search form with ' ' as the neighborhood to get *every*
        # restaurant in the city.
        #
        # Note that this site is technically *three* levels deep -- there's a
        # main list of all restaurants, then a list of inspections for each
        # restaurant, then a page for each inspection. Because this is slightly
        # different than a strict list-detail site, list_pages() yields the
        # inspection pages, not the main page.
        url = 'http://www.cityofboston.gov/isd/health/mfc/search.asp'
        html = self.get_html(url, {'ispostback': 'true', 'restname': '', 'cboNhood': ' '}).decode('ISO-8859-2')
        for record in parse_main_re.finditer(html):
            record = record.groupdict()
            if self.name_start and record['restaurant_name'].lower() < self.name_start:
                self.logger.info('Skipping %r due to name_start %r', record['restaurant_name'], self.name_start)
                continue
            self.logger.info('Getting inspections for %s' % record['restaurant_name'])
            url = 'http://www.cityofboston.gov/isd/health/mfc/insphistory.asp?licno=%s' % record['restaurant_id']
            # Normally we'd just yield the html, but we want the
            # record dict for use in parse_list().
            yield (record, self.get_html(url))

    def parse_list(self, record_html):
        # Normally this method gets passed raw html,
        # but we return both the html and the list_record from list_pages().
        list_record, html = record_html
        # a better version of the restaurant address is available on this page,
        # attempt to extract additional location details to resolve ambiguities.
        try:
            info = self.detail_address_re.search(html).groupdict()
            list_record['zipcode'] = info['zipcode']
        except:
            self.logger.info("Could not get detailed address information for record %s: %s" % (list_record['restaurant_id'], list_record['restaurant_name']))

        for record in NewsItemListDetailScraper.parse_list(self, html):
            yield dict(list_record, **record)

    def clean_list_record(self, record):
        record['inspection_date'] = parse_date(record['inspection_date'], '%m/%d/%Y')
        record['address'] = smart_title(record['address'])
        record['restaurant_name'] = smart_title(record['restaurant_name'])
        record['result'] = smart_title(record['result'])
        return record

    def existing_record(self, record):
        try:
            qs = NewsItem.objects.filter(schema__id=self.schema.id)
            qs = qs.by_attribute(self.schema_fields['inspection_id'], record['inspection_id'])
            return qs[0]
        except IndexError:
            return None

    def detail_required(self, list_record, old_record):
        return old_record is None

    def get_detail(self, record):
        return self.get_html(detail_url(record['inspection_id'])).decode('ISO-8859-2')

    def clean_detail_record(self, record):
        body = record.pop('body')
        violations = [m.groupdict() for m in detail_violations_re.finditer(body)]
        if not violations and not 'There are no violations for this inspection' in body:
            raise ScraperBroken('Could not find violations')
        for vio in violations:
            vio['severity'] = {1: 'Non critical', 2: 'Critical', 3: 'Critical foodborne illness'}[vio.pop('stars').count('*')]
            vio['comment'] = strip_tags(vio['comment']).strip()
            vio['location'] = strip_tags(vio['location']).strip()
            vio['description'] = strip_tags(vio['description']).strip()
            vio['status'] = strip_tags(vio['status']).strip()
        record['violation_list'] = violations
        return record

    def save(self, old_record, list_record, detail_record):
        if old_record is not None:
            return # We already have this inspection.

        result = self.get_or_create_lookup('result', list_record['result'], list_record['result'])
        violation_lookups = [self.get_or_create_lookup('violation', v['description'], v['code'], make_text_slug=False) for v in detail_record['violation_list']]

        violation_lookup_text = ','.join([str(v.id) for v in violation_lookups])
        if len(violation_lookup_text) > 4096:
            # This is an ugly hack to work around the fact that
            # many-to-many Lookups are themselves an ugly hack.
            # See http://developer.openblockproject.org/ticket/143
            violation_lookup_text = violation_lookup_text[0:4096]
            violation_lookup_text = violation_lookup_text[0:violation_lookup_text.rindex(',')]
            self.logger.warning('Restaurant %r had too many violations to store, skipping some!', list_record['restaurant_name'])

        # There's a bunch of data about every particular violation, and we
        # store it as a JSON object. Here, we create the JSON object.
        v_lookup_dict = dict([(v.code, v) for v in violation_lookups])
        v_list = [{'lookup_id': v_lookup_dict[v['code']].id, 'comment': v['comment'], 'location': v['location'], 'severity': v['severity'], 'status': v['status']} for v in detail_record['violation_list']]
        violations_json = DjangoJSONEncoder().encode(v_list)

        title = '%s inspected: %s' % (list_record['restaurant_name'], result.name)
        attributes = {
            'restaurant_id': list_record['restaurant_id'],
            'inspection_id': list_record['inspection_id'],
            'restaurant_name': list_record['restaurant_name'],
            'result': result.id,
            'violation': violation_lookup_text,
            'details': violations_json,
        }
        try: 
            self.create_newsitem(
                attributes,
                title=title,
                url=detail_url(list_record['inspection_id']),
                item_date=list_record['inspection_date'],
                location_name=list_record['address'],
                zipcode=list_record.get('zipcode')
            )
        except:
            import traceback;
            self.logger.error("Error storing inspection for %s: %s" % (list_record.get('restaurant_name', 'Unknown'), traceback.format_exc())) 


def main(argv=None):
    from ebpub.utils.script_utils import add_verbosity_options, setup_logging_from_opts
    import sys
    if argv is None:
        argv = sys.argv[1:]
    from optparse import OptionParser
    parser = OptionParser()
    add_verbosity_options(parser)
    parser.add_option('-n', '--name-start', help='Name of first restaurant to start with.'
                      ' This is useful if you\'ve run the scraper and it\'s broken '
                      'several hours into it; you can pick up around where it left off.')

    options, args = parser.parse_args(argv)

    scraper = RestaurantScraper(name_start=options.name_start)
    setup_logging_from_opts(options, scraper.logger)

    scraper.update()


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = articletext
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.retrieval.utils import convert_entities
from lxml import etree
import decimal
import re

is_punctuated = re.compile(ur"""
    [\.\!\?]
    (?:\s+|"|'|\xe2\x80\x9d|\u201d|\u2019|\)){0,3}
    \s*
    $
""", re.VERBOSE).search

def article_text_sections(tree):
    """
    Given an HTML tree of a news article (or blog entry permalink), deduces
    which part of it is text and returns a list of lists of strings, with each
    string representing a paragraph and each list of strings representing a
    "section" of the page.
    """

    # The basic algorithm here is to combine all text within the same block
    # (e.g., a <div>).

    MIN_NUM_PARAGRAPHS = 3
    MIN_NUM_PUNCTUATED = 3

    # In order for a paragraph to be counted toward MIN_NUM_PUNCTUATED, it must
    # have this number of characters.
    MIN_CHARS_IN_PARAGRAPH = 30

    # If this many paragraphs with MIN_CHARS_IN_PARAGRAPH are included in the
    # section, then the section will be included, regardless of failing
    # MIN_PERCENTAGE_PUNCTUATED.
    NUM_PARAGRAPHS_SAFE_GUESS = 6

    # In order for a section to be included in the result, at least this
    # percentage of paragraphs in the section must be punctuated.
    MIN_PERCENTAGE_PUNCTUATED = decimal.Decimal('.5')

    block_tags = set(['blockquote', 'dd', 'div', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'h7', 'h8', 'li', 'p', 'td', 'th', 'tr'])
    drop_tags_only = set(['a', 'abbr', 'acronym', 'b', 'center', 'dir', 'dl', 'em', 'font', 'form', 'hr', 'i', 'label', 'menu', 'ol', 'pre', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'tfoot', 'thead', 'topic', 'u', 'ul', 'wbr'])
    drop_tags_and_contents = set(['applet', 'area', 'button', 'embed', 'img', 'iframe', 'head', 'input', 'link', 'map', 'meta', 'noscript', 'object', 'option', 'script', 'select', 'spacer', 'style', 'textarea', 'title'])
    layout_tags = set(['div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'h7', 'h8', 'td', 'th', 'tr'])
    is_open_tag = re.compile('^<[^/][^>]+>$').search
    is_close_tag = re.compile('^</[^>]+>$').search
    ignored_paragraphs = set(['del.icio.us', 'digg', 'email', 'e-mail editor', 'e-mail story', 'no comments', 'print', 'print article', 'printer-friendly', 'printer version', 'reprints'])

    elements_to_drop = []
    for element in tree.getiterator():
        if not isinstance(element.tag, basestring): # If it's a comment...
            element.drop_tag()
            continue
        if element.text and '\n' in element.text:
            element.text = element.text.replace('\n', ' ')
        if element.tail and '\n' in element.tail:
            element.tail = element.tail.replace('\n', ' ')
        if element.tag in block_tags:
            element.text = '\n' + (element.text or '')
            element.tail = '\n' + (element.tail or '')
        elif element.tag == 'br':
            element.tail = '\n' + (element.tail or '')
            element.drop_tag()
        elif element.tag in drop_tags_only:
            element.drop_tag()
        elif element.tag in drop_tags_and_contents:
            elements_to_drop.append(element)
        elif element.tag not in ('html', 'body'): # Unknown tag!
            element.drop_tag()
    for e in elements_to_drop:
        e.drop_tree()

    for element in tree.getiterator():
        if element.tag in block_tags:
            if element.tag in layout_tags:
                element.text = '\n<%s>\n%s\n' % (element.tag, (element.text or ''))
                element.tail = '\n</%s>\n%s\n' % (element.tag, (element.tail or ''))
            element.drop_tag()

    try:
        tree.body
    except IndexError:
        # In some cases, the article is missing a <body> tag, and tree.body
        # will result in an IndexError. Just skip these.
        return []

    new_html = etree.tostring(tree.body, method='html')
    new_html = convert_entities(new_html)
    lines = re.split(r'\s*\n+\s*', new_html.strip())
    result = []
    sections = []
    for line in lines:
        if is_open_tag(line):
            result.append([])
        elif is_close_tag(line):
            last_bit = result.pop()
            if len(last_bit) >= MIN_NUM_PARAGRAPHS:
                sections.append(last_bit)
        else: # It's text, not a tag.
            try:
                result[-1].append(line)
            except IndexError: # No tags seen yet.
                result.append([line])

    # Cut out the sections that don't contain enough punctuated sentences.
    final_sections = []
    for section in sections:
        count = 0
        to_delete = []
        for i, paragraph in enumerate(section):
            if paragraph.lower() in ignored_paragraphs:
                to_delete.append(i)
            elif is_punctuated(paragraph) and len(paragraph) >= MIN_CHARS_IN_PARAGRAPH:
                count += 1
        percent_punctuated = decimal.Decimal(count) / decimal.Decimal(len(section))
        if count >= NUM_PARAGRAPHS_SAFE_GUESS or (count >= MIN_NUM_PUNCTUATED and percent_punctuated >= MIN_PERCENTAGE_PUNCTUATED):
            for i in reversed(to_delete): # Delete in reverse so that index order is preserved.
                del section[i]
            final_sections.append(section)
    return final_sections

def article_text(tree):
    """
    Simple wrapper around article_text_sections() that "flattens" sections into
    a single section.
    """
    result = []
    for section in article_text_sections(tree):
        result.extend(section)
    return result

if __name__ == "__main__":
    from ebdata.retrieval import UnicodeRetriever
    from ebdata.textmining.treeutils import make_tree
    import sys
    html = UnicodeRetriever().fetch_data(sys.argv[1])
    lines = article_text(make_tree(html))
    print lines

########NEW FILE########
__FILENAME__ = brain
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from listdiff import Hole # relative import
import re

class Brain(list):

    # This would have been a good place for a docstring
    # mentioning something about what the heck a Brain is for.
    # Thanks guys.

    def _each_member(self):
        for s in self:
            yield isinstance(s, Hole), s

    def as_text(self, custom_marker='{{ HOLE }}'):
        """
        Returns a display-friendly version of the Brain, using the
        given custom_marker to mark template holes.
        """
        output = []
        for is_hole, member in self._each_member():
            if is_hole:
                output.append(custom_marker)
            else:
                output.append(member)
        return ''.join(output)

    def concise(self):
        """
        Returns the brain as a list with all consecutive strings combined into
        a single string.
        """
        last_one_was_string = False
        output = []
        for is_hole, member in self._each_member():
            if is_hole:
                output.append(member)
            else:
                if last_one_was_string:
                    output[-1] += member
                else:
                    output.append(member)
            last_one_was_string = not is_hole
        return output

    def num_holes(self):
        """
        Returns the number of holes in this Brain.
        """
        return len([member for is_hole, member in self._each_member() if is_hole])

    def match_regex(self):
        """
        Returns a regular expression (as a string) that matches strings
        formatted with this Brain.
        """
        regex = ['^(?s)']
        for is_hole, member in self._each_member():
            if is_hole:
                regex.append(member.regex())
            else:
                regex.append(re.escape(member))
        regex.append('$')
        return ''.join(regex)

    def serialize(self):
        """
        Returns a serialized string representing this Brain.
        """
        import cPickle as pickle
        import base64
        return base64.encodestring(pickle.dumps(self, protocol=2))

    def from_serialized(cls, serialized_string):
        """
        Class method that returns a Brain instance for the given serialized
        string (as returned by Brain.serialize()).
        """
        import cPickle as pickle
        import base64
        return pickle.loads(base64.decodestring(serialized_string))
    from_serialized = classmethod(from_serialized)

########NEW FILE########
__FILENAME__ = clean
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.textmining.treeutils import make_tree_and_preprocess
from listdiff import longest_common_substring # relative import
from lxml import etree

elements_with_ids = etree.XPath('//*[normalize-space(@id)!=""]')

def identical_elements(list1, list2, debug):
    """
    Returns a list of (elements_to_delete, elements_whose_tail_should_be_removed)
    tuples.

    list1 and list2 should both be lists of etree Elements.
    """
    # list1 and list2 are lists of etree Elements.
    if list1 == list2 == []:
        if debug:
            print "identical_elements() got empty lists"
        return []
    hash_list1 = [(el.tag, el.attrib.get('id'), el.attrib.get('class')) for el in list1]
    hash_list2 = [(el.tag, el.attrib.get('id'), el.attrib.get('class')) for el in list2]
    best_size, offset1, offset2 = longest_common_substring(hash_list1, hash_list2)
    if debug:
        print "Got these two lists:\n  %r\n  %r\nMatch:\n  %r" % (hash_list1, hash_list2, hash_list1[offset1:offset1+best_size])
    if best_size == 0:
        return []
    result = []
    if offset1 > 0 and offset2 > 0:
        # There's leftover stuff on the left side of BOTH lists.
        if debug:
            print "Leftovers on left of BOTH"
        result.extend(identical_elements(list1[:offset1], list2[:offset2], debug))
    for i in range(best_size):
        child1, child2 = list1[offset1+i], list2[offset2+i]
        if debug:
            print "Children:\n  %r\n  %r" % (child1, child2)
            print '%r    %r' % (etree.tostring(child1, method='html'), etree.tostring(child2, method='html'))
        if child1.tag == child2.tag and dict(child1.attrib) == dict(child2.attrib) and child1.text == child2.text and list(child1) == list(child2):
            if debug:
                print "Identical!"
            tail_removals = []
            if child1.tail == child2.tail:
                tail_removals.append(child1)
            # If the previous sibling's tails are equal, remove those.
            if i > 0 and list1[offset1+i-1].tail == list2[offset2+i-1].tail:
                tail_removals.append(list1[offset1+i-1])
            result.append(([child1, child2], tail_removals))
        else:
            if debug:
                print "No matches; descending into children"
            result.extend(identical_elements(list(child1), list(child2), debug))
    if (offset1 + best_size < len(list1)) and (offset2 + best_size < len(list2)):
        # There's leftover stuff on the right side of BOTH lists.
        if debug:
            print "Leftovers on right of BOTH"
        result.extend(identical_elements(list1[offset1+best_size:], list2[offset2+best_size:], debug))
    return result

def strip_template(tree1, tree2, check_ids=True, debug=False):
    """
    Given two etree trees, determines the duplicate/redundant elements in
    both and strips those redundancies from both trees (in place).

    If check_ids is True, then this will also check for duplicate elements
    by ID. This helps to find duplicates at different levels of the tree --
    by default (without check_ids), this function only finds duplicates if
    they're at the same position in the HTML tree.

    Returns the number of redundant elements that have been removed.
    """
    # TODO:
    #    Solve the sidebar problem -- delete them

    # Assemble a list of trees to compare. Obviously, first we just compare the
    # given trees -- but if check_ids is True, then we also compare the
    # subtrees containing "id" attributes.
    tree_pairs = [(tree1, tree2)]
    if check_ids:
        ids2 = dict([(el.get('id'), el) for el in elements_with_ids(tree2)])
        other_pairs = [(el.getparent(), ids2[el.get('id')].getparent()) for el in elements_with_ids(tree1) if el.get('id') in ids2]
        tree_pairs.extend(other_pairs)

    # Run the algorithm multiple times until no similarities remain. This is
    # sort of inelegant, but it works.
    num_removed = 0
    for tree1, tree2 in tree_pairs:
        if debug:
            print 'NEW TREE PAIR:\n  %r\n  %r' % (tree1, tree2)
        while 1:
            if debug:
                print 'New round'
            if tree1 is None and tree2 is None:
                break
            result = identical_elements(list(tree1), list(tree2), debug)
            if debug:
                print "strip_template() result:\n%r" % result
            if not result:
                break
            for drops, tail_removals in result:
                for removal in tail_removals:
                    removal.tail = ''
                for drop in drops:
                    drop.drop_tree()
            num_removed += len(result)
    return num_removed

def clean_page(html, other_page):
    """
    Wrapper around the various cleaning functions. This accepts and returns
    strings instead of trees.
    """
    tree1 = make_tree_and_preprocess(html)
    tree2 = make_tree_and_preprocess(other_page)
    strip_template(tree1, tree2)
    # drop_useless_tags(tree1)
    # remove_empty_tags(tree1, ('div', 'span', 'td', 'tr', 'table'))
    return etree.tostring(tree1, method='html'), etree.tostring(tree2, method='html')

########NEW FILE########
__FILENAME__ = hole
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

import re

class Hole(object):

    # This would have been a good place for a docstring
    # mentioning something about what the heck a Hole is for.
    # Thanks guys.

    capture = True # Designates whether the Hole captures something in regex().
    def __eq__(self, other):
        "A Hole is equal to any other Hole (but not subclasses)."
        return type(other) is self.__class__

    def __repr__(self):
        return '<%s>' % self.__class__.__name__

    def regex(self):
        return '(.*?)'

class OrHole(Hole):
    "A Hole that can contain one of a set of values."
    capture = True
    def __init__(self, *choices):
        self.choices = choices

    def __eq__(self, other):
        "An OrHole is equal to another one if its choices are the same."
        return type(other) is self.__class__ and self.choices == other.choices

    def __repr__(self):
        return '<%s: %r>' % (self.__class__.__name__, self.choices)

    def regex(self):
        return '(%s)' % '|'.join(re.escape(choice) for choice in self.choices)

class RegexHole(Hole):
    """
    A Hole that contains data that matches the given regex. It's up to the
    caller to determine whether the data should be grouped.
    """
    def __init__(self, regex_string, capture):
        self.regex_string = regex_string
        self.capture = capture

    def __eq__(self, other):
        "A RegexHole is equal to another one if its regex_string is the same."
        return type(other) is self.__class__ and self.regex_string == other.regex_string and self.capture == other.capture

    def __repr__(self):
        return '<%s: %s>' % (self.__class__.__name__, self.regex_string)

    def regex(self):
        return self.regex_string

class IgnoreHole(Hole):
    """
    A Hole that contains an arbitrary amount of data but should be ignored.
    I.e., its contents are *not* included in extract().
    """
    capture = False
    def regex(self):
        return '.*?' # No parenthesis!

########NEW FILE########
__FILENAME__ = htmlutils
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Utilities for manipulating lxml.html trees.
"""

import re
from lxml import etree
from lxml.html import Element, builder as E

# All text that isn't within an <a> tag.
non_linked_text = etree.XPath("descendant-or-self::*[name()!='a']/text()")

# All text that's within an <a> tag.
linked_text = etree.XPath("descendant-or-self::*[name()='a']/text()")

# All <a> elements whose href and text contain the string 'print'.
# The "translate(x, 'PRINT', 'print')
printer_links = etree.XPath("//a[contains(translate(@href, 'PRINT', 'print'), 'print') or contains(@href, 'pf')][contains(translate(text(), 'PRINT', 'print'), 'print')]")

def percent_linked_text(tree):
    """
    Returns a float representing the percentage of all text within this tree
    that is linked (e.g., is within an <a> tag).
    """
    links_yes = len(''.join([bit.strip() for bit in linked_text(tree) if bit.strip()]))
    links_no = len(''.join([bit.strip() for bit in non_linked_text(tree) if bit.strip()]))
    try:
        return 1.0 * links_yes / (links_yes + links_no)
    except ZeroDivisionError:
        return 0.0

def is_printer_link(href, link_text):
    """
    Helper function that picks up some of the logic that the `printer_links`
    XPath expression can't handle. Returns True if the given URL and link text
    probably are a print link.
    """
    if not re.search(r'(?i)\b(?:print|printer)\b', link_text):
        return False
    if re.search(r'(?i)print[\s-]*(?:edition|advertising|ads)\b', link_text):
        return False
    if re.search(r'(?i)\s*javascript:', href):
        return False
    return True

def printer_friendly_link(tree):
    """
    Returns the 'printer-friendly' URL for the given HTML tree.

    This works by looking for any link that has 'print' in both the link text
    and the URL.

    Returns None if it can't find such a link.
    """
    a_tags = [a for a in printer_links(tree) if is_printer_link(a.attrib['href'], a.text_content())]
    if a_tags:
        # GOTCHA: If there are multiple links, we use the first one.
        link = a_tags[0].attrib['href'].strip()
        if not link.startswith('javascript:'):
            return link
    return None

def remove_empty_tags(tree, ignore_tags):
    """
    Removes all empty tags in the given etree, editing it in place. A tag is
    considered empty if it has no contents (text or tags).

    This works in a reductive manner. If the removal of an empty tag causes its
    parent to become empty, then the parent will be removed, too, recursively.

    ignore_tags should be a tuple of tag names to ignore (i.e., any empty
    tag with a tag name in ignore_tags will not be removed). Each tag name in
    this list should be lowercase.

    The <body> and <html> tags are never removed.
    """
    ignore_tags += ('body', 'html')
    child_removed = False
    for element in tree:
        # The "element.getparent() is not None" check ensures that we don't
        # cause the AssertionError in drop_tree().
        if element.tag not in ignore_tags and (element.text is None or not element.text.strip()) \
                and not list(element) and element.getparent() is not None:
            element.drop_tree()
            child_removed = True
        else:
            remove_empty_tags(element, ignore_tags)
    if child_removed:
        parent = tree.getparent()
        if parent is not None:
            remove_empty_tags(parent, ignore_tags)

def brs_to_paragraphs(tree, inline_tags=None):
    """
    Return an lxml tree with all <br> elements stripped and paragraphs put in
    place where necessary.
    """
    # add these tags to p's that we're currently building, any other tags will
    # close the current p
    inline_tags = inline_tags or ['a']

    # if this tree doesn't have any child elements, just return it as is
    if len(tree) == 0:
        return tree

    # if this tree doesn't contain any <br> tags, we don't need to touch it
    if tree.find('.//br') is None:
        return tree

    # XXX: We're building a whole new tree here and leaving out any attributes.
    # A) That might be a little slower and more memory intensive than modifying
    # the tree in place, and B) we're dropping any attributes on block elements.
    # The latter is probably fine for current use, but certainly not ideal.
    new_tree = Element(tree.tag)

    # if this tree starts out with text, create a new paragraph for it, and
    # add it to the tree
    if tree.text:
        p = E.P()
        p.text = tree.text
        new_tree.append(p)

    for e in tree:
        if e.tag == 'br':
            # avoid adding empty p elements
            if e.tail is None:
                continue
            # start a new p
            p = E.P()
            p.text = e.tail
            new_tree.append(p)
        # if this is a block tag, and it has trailing text, that text needs to
        # go into a new paragraph... only if the tail has actual content and
        # not just whitespace though.
        elif e.tail and re.match('[^\s]', e.tail) and e.tag not in inline_tags:
            p = E.P()
            p.text = e.tail
            e.tail = ''
            new_tree.append(e)
            new_tree.append(p)
        # keep inline tags inside the current paragraph
        elif e.tag in inline_tags:
            p.append(e)
        else:
            new_tree.append(brs_to_paragraphs(e))

    return new_tree

########NEW FILE########
__FILENAME__ = listdiff
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from hole import Hole

def listdiff(list1, list2):
    """
    Given two lists, returns a "diff" list, with Hole instances inserted
    as necessary.
    """
    hole = Hole()

    # Special case.
    if list1 == list2 == []:
        return []

    best_size, offset1, offset2 = longest_common_substring(list1, list2)

    result = []

    if best_size == 0:
        result.append(hole)
    if offset1 > 0 and offset2 > 0:
        # There's leftover stuff on the left side of BOTH lists.
        result.extend(listdiff(list1[:offset1], list2[:offset2]))
    elif offset1 > 0 or offset2 > 0:
        # There's leftover stuff on the left side of ONLY ONE of the lists.
        result.append(hole)
    if best_size > 0:
        result.extend(list1[offset1:offset1+best_size])
        if (offset1 + best_size < len(list1)) and (offset2 + best_size < len(list2)):
            # There's leftover stuff on the right side of BOTH lists.
            result.extend(listdiff(list1[offset1+best_size:], list2[offset2+best_size:]))
        elif (offset1 + best_size < len(list1)) or (offset2 + best_size < len(list2)):
            # There's leftover stuff on the right side of ONLY ONE of the lists.
            result.append(hole)
    return result

# NOTE: This is a "longest common substring" algorithm, not a
# "longest common subsequence" algorithm. The difference is that longest common
# subsequence does not require the bits to be contiguous.
#
# The longest common subsequence of "foolish" and "fools" is "fools".
# The longest common substring of "foolish" and "fools" is "fool".
try:
    from listdiffc import longest_common_subsequence as longest_common_substring
except ImportError:
    def longest_common_substring(seq1, seq2):
        """
        Given two sequences, calculates the longest common substring and returns
        a tuple of:
            (LCS length, LCS offset in seq1, LCS offset in seq2)
        """
        best_size, offset1, offset2 = half_longest_match(seq1, seq2)
        best_size, offset2, offset1 = half_longest_match(seq2, seq1, best_size, offset2, offset1)
        return best_size, offset1, offset2

    def half_longest_match(seq1, seq2, best_size=0, offset1=-1, offset2=-1):
        """
        Implements "one half" of the longest common substring algorithm.
        """
        len1 = len(seq1)
        len2 = len(seq2)
        i = 0 # seq2 index
        current_size = 0
        while i < len2:
            if best_size >= len2 - i:
                break # Short circuit
            j = i
            k = 0
            while k < len1 and j < len2:
                if seq1[k] == seq2[j]:
                    current_size += 1
                    if current_size >= best_size:
                        new_offset1 = k - current_size + 1
                        new_offset2 = j - current_size + 1
                        if current_size > best_size or (new_offset1 <= offset1 and new_offset2 <= offset2):
                            offset1 = new_offset1
                            offset2 = new_offset2
                        best_size = current_size
                else:
                    current_size = 0
                j += 1
                k += 1
            i += 1
            current_size = 0
        return best_size, offset1, offset2

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

# There are no models, but `manage.py test` needs a models.py to find tests.

########NEW FILE########
__FILENAME__ = sst
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Template implementation that uses the Site Style Tree concept, as described
in this paper:

    L. Yi and B. Liu. Eliminating noisy information in web pages for data mining.
    In ACM Conf. on Knowledge Discovery and Data Mining (SIGKDD), 2003.
    http://citeseer.ist.psu.edu/yi03eliminating.html
"""

from ebdata.templatemaker.listdiff import longest_common_substring
from ebdata.textmining.treeutils import make_tree_and_preprocess
from lxml import etree
import time

class NoMatch(Exception):
    pass

def element_hash_strict(el):
    """
    Returns a hash of the given etree Element, such that it can be used
    in a longest_common_substring comparison against another tree.
    """
    # <br> tags should never be marked as the same as other <br> tags, so use
    # the current time to introduce enough entropy. Note that we use '%.10f'
    # instead of str(time.time()) because str() rounds the number to two
    # decimal places, resulting in identical results for subsequent tags.
    if el.tag == 'br':
        return '%.10f' % time.time()

    attrs = sorted(dict(el.attrib).items())
    return (el.tag, attrs, el.text, el.tail)

def element_hash_loose(el):
    if el.tag == 'br':
        return '%.10f' % time.time()
    if el.tag in ('h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'a', 'title'):
        return el.tag
    return (el.tag, el.text)

def tree_diff_children(list1, list2, hash_func, algorithm):
    # list1 and list2 are lists of etree Elements.
    if list1 == list2 == []:
        return []
    # Try to find the longest common substring, according to hash_func().
    # First we use element_hash_strict(), but then we use element_hash_loose()
    # as a fallback.
    best_size, offset1, offset2 = longest_common_substring([hash_func(el) for el in list1], [hash_func(el) for el in list2])
    result = []
    if best_size == 0:
        if hash_func == element_hash_strict:
            result.extend(tree_diff_children(list1, list2, element_hash_loose, algorithm))
        else:
            result.append(etree.Element('MULTITAG_HOLE'))
    if offset1 > 0 and offset2 > 0:
        # There's leftover stuff on the left side of BOTH lists.
        result.extend(tree_diff_children(list1[:offset1], list2[:offset2], element_hash_strict, algorithm))
    elif offset1 > 0 or offset2 > 0:
        # There's leftover stuff on the left side of ONLY ONE of the lists.
        result.append(etree.Element('MULTITAG_HOLE'))
    if best_size > 0:
        for i in range(best_size):
            child = tree_diff(list1[offset1+i], list2[offset2+i], algorithm)
            result.append(child)
        if (offset1 + best_size < len(list1)) and (offset2 + best_size < len(list2)):
            # There's leftover stuff on the right side of BOTH lists.
            result.extend(tree_diff_children(list1[offset1+best_size:], list2[offset2+best_size:], element_hash_strict, algorithm))
        elif (offset1 + best_size < len(list1)) or (offset2 + best_size < len(list2)):
            # There's leftover stuff on the right side of ONLY ONE of the lists.
            result.append(etree.Element('MULTITAG_HOLE'))
    return result

def tree_diff(tree1, tree2, algorithm=1):
    """
    Returns a "diff" of the two etree objects, using these placeholders in case
    of differences:

    TEXT_HOLE
       used when the 'text' differs
    TAIL_HOLE
       used when the 'tail' differs
    ATTRIB_HOLE
       used when an attribute value (or existence) differs
    MULTITAG_HOLE
       used when an element's children differ

    This assumes tree1 and tree2 share the same root tag, e.g. "<html>".
    """
    # Copy the element (but not its children).
    result = etree.Element(tree1.tag)
    result.text = (tree1.text != tree2.text) and 'TEXT_HOLE' or tree1.text
    result.tail = (tree1.tail != tree2.tail) and 'TAIL_HOLE' or tree1.tail
    attrs1, attrs2 = dict(tree1.attrib), dict(tree2.attrib)
    for k1, v1 in attrs1.items():
        if attrs2.pop(k1, None) == v1:
            result.attrib[k1] = v1
        else:
            result.attrib[k1] = 'ATTRIB_HOLE'
    for k2 in attrs2.keys():
        result.attrib[k2] = 'ATTRIB_HOLE'
    if algorithm == 1:
        for child in tree_diff_children(list(tree1), list(tree2), element_hash_strict, algorithm):
            result.append(child)
    elif algorithm == 2:
        if [child.tag for child in tree1] == [child.tag for child in tree2]:
            for i, child in enumerate(tree1):
                diff_child = tree_diff(child, tree2[i], algorithm)
                result.append(diff_child)
        else:
            result.append(etree.Element('MULTITAG_HOLE'))
    else:
        raise ValueError('Got invalid algorithm: %r' % algorithm)
    return result

def tree_extract_children(list1, list2, hash_func, algorithm):
    # list1 and list2 are lists of etree Elements.
    if list1 == list2 == []:
        return []
    best_size, offset1, offset2 = longest_common_substring([hash_func(el) for el in list1], [hash_func(el) for el in list2])
    result = []
    if best_size == 0:
        if [el.tag for el in list1] == ['MULTITAG_HOLE']:
            data = ''.join([etree.tostring(child, method='html') for child in list2])
            result.append({'type': 'multitag', 'value': data, 'tag': None})
        elif hash_func == element_hash_strict:
            result.extend(tree_extract_children(list1, list2, element_hash_loose, algorithm))
        else:
            raise NoMatch('Brain tag had children %r, but sample had %r' % (list1, list2))
    if offset1 > 0 and offset2 > 0:
        # There's leftover stuff on the left side of BOTH lists.
        result.extend(tree_extract_children(list1[:offset1], list2[:offset2], element_hash_strict, algorithm))
    elif offset1 > 0:
        # There's leftover stuff on the left side of ONLY the brain.
        if [el.tag for el in list1[:offset1]] == ['MULTITAG_HOLE']:
            result.append({'type': 'multitag', 'value': '', 'tag': None})
        else:
            raise NoMatch('Brain tag had children %r, but sample had %r' % (list1[:offset1], list2))
    elif offset2 > 0:
        # There's leftover stuff on the left side of ONLY the sample.
        raise NoMatch('Brain tag had children %r, but sample had %r' % (list1, list2))
    if best_size > 0:
        for i in range(best_size):
            child_result = tree_extract(list1[offset1+i], list2[offset2+i], algorithm)
            result.extend(child_result)
        if (offset1 + best_size < len(list1)) or (offset2 + best_size < len(list2)):
            # There's leftover stuff on the right side of EITHER list.
            child_result = tree_extract_children(list1[offset1+best_size:], list2[offset2+best_size:], element_hash_strict, algorithm)
            result.extend(child_result)
    return result

def tree_extract(brain, sample, algorithm):
    """
    Given two etrees -- a brain (the result of a tree_diff()) and a sample
    to extract from -- this returns a list of raw data from the sample.

    Each element in the resulting list is a dict of {type, value}, where:
        type is either 'attrib', 'text', 'multitag' or 'tail'
        value is a string of the raw data
    """
    result = []

    # Extract ATTRIB_HOLE.
    brain_attrs = sorted(dict(brain.attrib).items()) # Sort, to be deterministic in output.
    sample_attrs = dict(sample.attrib)
    for k, brain_value in brain_attrs:
        if brain_value == 'ATTRIB_HOLE':
            result.append({'type': 'attrib', 'value': sample_attrs.pop(k, ''), 'tag': brain.tag})
        else:
            sample_value = sample_attrs.pop(k, None)
            if brain_value != sample_value:
                raise NoMatch('<%s> %r attribute had different values: %r and %r' % (brain.tag, k, brain_value, sample_value))
    if sample_attrs:
        # If any attributes are left in sample_attrs, they weren't in the brain.
        raise NoMatch('<%s> attributes exist in sample but not in brain: %r' % (brain.tag, sample_attrs))

    # Extract TEXT_HOLE.
    if brain.text == 'TEXT_HOLE':
        result.append({'type': 'text', 'value': sample.text, 'tag': brain.tag})
    elif brain.text != sample.text:
        raise NoMatch('<%s> text had different values: %r and %r' % (brain.tag, brain.text, sample.text))

    # Extract MULTITAG_HOLE.
    brain_children = [child.tag for child in brain]
    sample_children = [child.tag for child in sample]
    if 'MULTITAG_HOLE' in brain_children:
        if algorithm == 1:
            multitag_result = tree_extract_children(list(brain), list(sample), element_hash_strict, algorithm)
            result.extend(multitag_result)
        elif algorithm == 2:
            data = ''.join([etree.tostring(child) for child in sample])
            result.append({'type': 'multitag', 'value': data, 'tag': None})
        else:
            ValueError('Got invalid algorithm: %r' % algorithm)
    elif brain_children == sample_children:
        for i, child in enumerate(brain):
            child_result = tree_extract(child, sample[i], algorithm)
            result.extend(child_result)
    else:
        raise NoMatch('Brain <%s> tag had children %r, but sample had %s' % \
            (brain.tag, brain_children, sample_children))

    # Extract TAIL_HOLE.
    if brain.tail == 'TAIL_HOLE':
        # Note that we use brain.getparent() here to get the tag that contains the tail text.
        result.append({'type': 'tail', 'value': sample.tail, 'tag': brain.getparent().tag})
    elif brain.tail != sample.tail:
        raise NoMatch('<%s> tail had different values: %r and %r' % (brain.tag, brain.tail, sample.tail))

    return result

class Template(object):
    def __init__(self, algorithm=1):
        # algorithm can be either 1 or 2.
        #     1 -- Smarter algorithm that removes more noise, but might fail.
        #     2 -- Dumber algorithm that doesn't remove as much noise, but it
        #          never fails.
        self.htmltree = None
        self.algorithm = algorithm

    def learn(self, html):
        tree = make_tree_and_preprocess(html)
        if self.htmltree is None:
            self.htmltree = tree
        else:
            self.htmltree = tree_diff(self.htmltree, tree, self.algorithm)

    def as_text(self):
        return etree.tostring(self.htmltree, method='html')

    def extract(self, html):
        tree = make_tree_and_preprocess(html)
        if self.htmltree is None:
            raise ValueError('This template has not learned anything yet.')
        return tree_extract(self.htmltree, tree, self.algorithm)

def extract(html, other_pages):
    """
    Given an HTML page string and list of other pages, creates a Template
    and extracts the data from the page.
    """
    # First try algorithm 1, because it's more effective. But if it fails,
    # fall back to algorithm 2.
    for algorithm in (1, 2):
        t = Template(algorithm=algorithm)
        for sample in [html] + other_pages:
            t.learn(sample)
        try:
            return t.extract(html)
        except NoMatch:
            if algorithm == 1:
                continue
            else:
                raise
    raise NoMatch('Reached end of extract() without having gotten a match')

########NEW FILE########
__FILENAME__ = template
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from brain import Brain # relative import
from listdiff import listdiff # relative import
import re

class NoMatch(Exception):
    pass

class Template(object):
    def __init__(self, brain=None):
        if isinstance(brain, str):
            self.brain = Brain.from_serialized(brain)
        else:
            self.brain = brain

    def tokenize(self, text):
        """
        Returns a list of tokens for the given text. This list may include
        Hole instances.
        """
        return list(text)

    def learn(self, *texts):
        """
        Learns the given Sample String(s).
        """
        brain = self.brain
        for text in texts:
            tokens = self.tokenize(text)
            if brain is None:
                brain = Brain(tokens)
            else:
                brain = Brain(listdiff(brain, tokens))
        self.brain = brain

    def as_text(self, custom_marker='{{ HOLE }}'):
        """
        Returns a display-friendly version of the template, using the
        given custom_marker to mark template holes.
        """
        return self.brain.as_text(custom_marker)

    def num_holes(self):
        """
        Returns the number of holes in this template.
        """
        return self.brain.num_holes()

    def extract(self, text):
        """
        Given a bunch of text that is marked up using this template, extracts
        the data.

        Returns a tuple of the raw data, in the order in which it appears in
        the template. If the text doesn't match the template, raises NoMatch.
        """
        regex = self.brain.match_regex()
        m = re.search(regex, text)
        if m:
            return m.groups()
        raise NoMatch()

########NEW FILE########
__FILENAME__ = articletext
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.templatemaker.articletext import is_punctuated
import os.path
import unittest

class AutoTestMetaclass(type):
    """
    Metaclass that adds a test method for every pair in TEST_DATA.
    """
    def __new__(cls, name, bases, attrs):
        def make_test_func(input_value, expected):
            return lambda self: self.assertAutotest(input_value, expected)
        for i, (html, expected) in enumerate(attrs['TEST_DATA']):
            func = make_test_func(html, expected)
            func.__doc__ = repr(html)
            attrs['test_%03d' % i] = func # Use '%03d' to make tests run in order, because unittest uses string ordering.
        return type.__new__(cls, name, bases, attrs)

class PunctuatedTestCase(unittest.TestCase):
    __metaclass__ = AutoTestMetaclass

    TEST_DATA = (
        (u'This is a sentence.', True),
        (u'This is a sentence?', True),
        (u'This is a sentence!', True),
        (u'This is a sentence.  ', True),
        (u'This is a sentence?  ', True),
        (u'This is a sentence!  ', True),
        (u'Not a sentence', False),
        (u'Not. A! Sentence? Correct', False),
        (u'"This is a quoted sentence."', True),
        (u'"This is a quoted sentence." ', True),
        (u'"This is a quoted sentence. " ', True),
        (u'"This is a quoted sentence?"', True),
        (u'"This is a quoted sentence?" ', True),
        (u'"This is a quoted sentence ?" ', True),
        (u'"This is a quoted sentence!"', True),
        (u'"This is a quoted sentence!" ', True),
        (u'"This is a quoted sentence! " ', True),
        (u'This is a sentence (yeah).', True),
        (u'This is a sentence. (Yeah.)', True),
        (u'This is a sentence. (Yeah?)', True),
        (u'This is a sentence. (Yeah!)', True),
        (u'This is a sentence. ("Quoted.")', True),
        (u'This is a sentence. ("Quoted?")', True),
        (u'This is a sentence. ("Quoted!")', True),
        (u'This is a sentence. (\'Single-quoted.\')', True),
        (u'This is a sentence. (\'Single-quoted?\')', True),
        (u'This is a sentence. (\'Single-quoted!\')', True),
        (u'This is a sentence. ("\'Double-quoted.\'")', True),
        (u'This is a sentence. ("\'Double-quoted?\'")', True),
        (u'This is a sentence. ("\'Double-quoted!\'")', True),
        (u'This is a sentence. (\'"Double-quoted."\')', True),
        (u'This is a sentence. (\'"Double-quoted?"\')', True),
        (u'This is a sentence. (\'"Double-quoted!"\')', True),
        (u'He "said, \'It\'s going to reveal what else she has done\'."', True),
        (u'He \u201csaid, \u2018It\u2019s going to reveal what else she has done\u2019.\u201d', True),
    )

    def assertAutotest(self, sentence, expected):
        self.assertEqual(bool(is_punctuated(sentence)), expected)

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = brain
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.templatemaker.brain import Brain
from ebdata.templatemaker.hole import Hole, OrHole, IgnoreHole
import unittest

class BrainTestCase(unittest.TestCase):
    def assertAsText(self, brain, marker, expected):
        """
        Asserts that Brain(brain).as_text(marker) == expected.
        """
        b = Brain(brain)
        if marker is not None:
            self.assertEqual(b.as_text(marker), expected)
        else:
            self.assertEqual(b.as_text(), expected)

    def assertNumHoles(self, brain, expected):
        """
        Asserts that Brain(brain).num_holes() == expected.
        """
        b = Brain(brain)
        self.assertEqual(b.num_holes(), expected)

    def assertRegex(self, brain, expected):
        """
        Asserts that Brain(brain).match_regex() == expected.
        """
        b = Brain(brain)
        self.assertEqual(b.match_regex(), expected)

    def test_as_text_empty1(self):
        self.assertAsText([], None, '')

    def test_as_text_empty2(self):
        self.assertAsText([], 'marker', '')

    def test_as_text1(self):
        self.assertAsText(['1', Hole(), '2', Hole(), '3'], None, '1{{ HOLE }}2{{ HOLE }}3')

    def test_as_text2(self):
        self.assertAsText(['1', Hole(), '2', Hole(), '3'], '!', '1!2!3')

    def test_num_holes_empty(self):
        self.assertNumHoles([], 0)

    def test_num_holes1(self):
        self.assertNumHoles(['a', 'b', 'c'], 0)

    def test_num_holes2(self):
        self.assertNumHoles(['a', Hole(), 'c'], 1)

    def test_num_holes3(self):
        self.assertNumHoles(['a', Hole(), 'c', Hole()], 2)

    def test_regex_empty(self):
        self.assertRegex([], '^(?s)$')

    def test_regex_noholes(self):
        self.assertRegex(['a', 'b', 'c'], '^(?s)abc$')

    def test_regex_special_chars(self):
        self.assertRegex(['^$?.*'], r'^(?s)\^\$\?\.\*$')

    def test_regex_holes1(self):
        self.assertRegex(['a', Hole(), 'b'], '^(?s)a(.*?)b$')

    def test_regex_holes2(self):
        self.assertRegex(['a', OrHole('b', 'c'), 'd', IgnoreHole()], '^(?s)a(b|c)d.*?$')

class BrainEmptyTestCase(unittest.TestCase):
    def assertConcise(self, brain, expected):
        """
        Asserts that Brain(brain).concise() == expected.
        """
        b = Brain(brain)
        self.assertEqual(b.concise(), expected)

    def test_empty(self):
        self.assertConcise([], [])

    def test_basic1(self):
        self.assertConcise(['a'], ['a'])

    def test_basic2(self):
        self.assertConcise(['a', 'b'], ['ab'])

    def test_basic3(self):
        self.assertConcise(['a', Hole(), 'b'], ['a', Hole(), 'b'])

    def test_basic4(self):
        self.assertConcise([Hole(), 'a', Hole(), 'b'], [Hole(), 'a', Hole(), 'b'])

    def test_basic5(self):
        self.assertConcise([Hole(), 'a', Hole(), 'b', Hole()],
            [Hole(), 'a', Hole(), 'b', Hole()])

    def test_basic6(self):
        self.assertConcise([Hole(), 'a', 'b', 'c', Hole(), 'd', 'e', 'f', Hole(), 'g'],
            [Hole(), 'abc', Hole(), 'def', Hole(), 'g'])

    def test_long_strings(self):
        self.assertConcise(['this is ', 'a test', Hole(), 'of the ', 'emergency ', 'broadcast system', Hole()],
            ['this is a test', Hole(), 'of the emergency broadcast system', Hole()])

class BrainSerialization(unittest.TestCase):
    def assertSerializes(self, brain):
        """
        Serializes and unserializes the given brain, asserting that a round
        trip works properly.
        """
        b = Brain(brain)
        self.assertEqual(b, Brain.from_serialized(b.serialize()))

    def test_empty(self):
        self.assertSerializes([])

    def test_integer(self):
        self.assertSerializes([1, 2, 3])

    def test_string(self):
        self.assertSerializes(['abc', 'd', 'e', 'fg hi jklmnop'])

    def test_hole1(self):
        self.assertSerializes([Hole()])

    def test_hole2(self):
        self.assertSerializes([Hole(), Hole(), Hole()])

    def test_hole_and_strings(self):
        self.assertSerializes([Hole(), 'abc', Hole(), 'def', Hole()])

    def test_format1(self):
        self.assertEqual(Brain([]).serialize(), 'gAJjZWJkYXRhLnRlbXBsYXRlbWFrZXIuYnJhaW4KQnJhaW4KcQEpgXECfXEDYi4=\n')

    def test_format2(self):
        self.assertEqual(Brain([Hole(), 'abc', Hole()]).serialize(),
                         'gAJjZWJkYXRhLnRlbXBsYXRlbWFrZXIuYnJhaW4KQnJhaW4KcQEpgXECKGNlYmRhdGEudGVtcGxh\ndGVtYWtlci5ob2xlCkhvbGUKcQMpgXEEfXEFYlUDYWJjcQZoAymBcQd9cQhiZX1xCWIu\n'
                         )

    def test_format_input1(self):
        # If this fails due to eg. module renaming, you can recreate
        # correct output like: Brain([]).serialize()
        serialized = 'gAJjZWJkYXRhLnRlbXBsYXRlbWFrZXIuYnJhaW4KQnJhaW4KcQEpgXECfXEDYi4=\n'
        self.assertEqual(Brain([]), Brain.from_serialized(serialized))

    def test_format_input2(self):
        # If this fails due to eg. module renaming, you can recreate
        # correct output like: Brain([Hole(), 'abc', Hole()]).serialize()
        serialized = 'gAJjZWJkYXRhLnRlbXBsYXRlbWFrZXIuYnJhaW4KQnJhaW4KcQEpgXECKGNlYmRhdGEudGVtcGxh\ndGVtYWtlci5ob2xlCkhvbGUKcQMpgXEEfXEFYlUDYWJjcQZoAymBcQd9cQhiZX1xCWIu\n'
        self.assertEqual(Brain([Hole(), 'abc', Hole()]),
                         Brain.from_serialized(serialized))


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = clean
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.templatemaker.clean import strip_template
from lxml import etree
from lxml.html import document_fromstring
import unittest

class StripTemplateTestCase(unittest.TestCase):
    def assertStrips(self, html1, html2, expected, num_removals, check_ids=False):
        """
        Asserts that strip_template(html1, html2) will result in the expected
        HTML string, and that the return value is num_removals.
        """
        # The test strings should *not* have <html> and <body> tags, for the
        # sake of brevity.
        tree1 = document_fromstring('<html><body>%s</body></html>' % html1)
        tree2 = document_fromstring('<html><body>%s</body></html>' % html2)
        expected = '<html><body>%s</body></html>' % expected

        got_removals = strip_template(tree1, tree2, check_ids=check_ids)
        got_tree = etree.tostring(tree1, method='html')
        self.assertEqual(got_tree, expected)
        self.assertEqual(got_removals, num_removals)

    def test_noop(self):
        self.assertStrips(
            '<p>Foo</p>',
            '<div>Bar</div>',
            '<p>Foo</p>',
            0,
        )

    def test_header(self):
        self.assertStrips(
            '<p>Header</p><h1>Headline 1</h1>',
            '<p>Header</p><h1>Headline 2</h1>',
            '<h1>Headline 1</h1>',
            1,
        )

    def test_footer(self):
        self.assertStrips(
            '<h1>Headline 1</h1><p>Footer</p>',
            '<h1>Headline 2</h1><p>Footer</p>',
            '<h1>Headline 1</h1>',
            1,
        )

    def test_header_and_footer(self):
        self.assertStrips(
            '<p>Header</p><h1>Headline 1</h1><p>Footer</p>',
            '<p>Header</p><h1>Headline 2</h1><p>Footer</p>',
            '<h1>Headline 1</h1>',
            2,
        )

    def test_header_same_tag(self):
        self.assertStrips(
            '<p>Header</p><p>Article 1</p>',
            '<p>Header</p><p>Article 2</p>',
            '<p>Article 1</p>',
            1,
        )

    def test_footer_same_tag(self):
        self.assertStrips(
            '<p>Article 1</p><p>Footer</p>',
            '<p>Article 2</p><p>Footer</p>',
            '<p>Article 1</p>',
            1,
        )

    def test_header_and_footer_same_tag(self):
        self.assertStrips(
            '<p>Header</p><p>Article 1</p><p>Footer</p>',
            '<p>Header</p><p>Article 2</p><p>Footer</p>',
            '<p>Article 1</p>',
            2,
        )

    def test_nested_1level(self):
        self.assertStrips(
            '<ul><li>News</li></ul><h1>Headline 1</h1>',
            '<ul><li>News</li></ul><h1>Headline 2</h1>',
            '<h1>Headline 1</h1>',
            2,
        )

    def test_nested_2level(self):
        self.assertStrips(
            '<div id="nav"><ul><li>News</li></ul></div><h1>Headline 1</h1>',
            '<div id="nav"><ul><li>News</li></ul></div><h1>Headline 2</h1>',
            '<h1>Headline 1</h1>',
            3,
        )

    def test_header_tail_same(self):
        self.assertStrips(
            '<p>Header</p> Tail <h1>Headline 1</h1>',
            '<p>Header</p> Tail <h1>Headline 2</h1>',
            '<h1>Headline 1</h1>',
            1,
        )

    def test_header_tail_different(self):
        self.assertStrips(
            '<p>Header</p> Tail1 <h1>Headline 1</h1>',
            '<p>Header</p> Tail2 <h1>Headline 2</h1>',
            ' Tail1 <h1>Headline 1</h1>',
            1,
        )

    def test_footer_head_same(self):
        self.assertStrips(
            '<h1>Headline 1</h1> Head <p>Footer</p>',
            '<h1>Headline 2</h1> Head <p>Footer</p>',
            '<h1>Headline 1</h1>',
            1,
        )

    def test_footer_head_different(self):
        self.assertStrips(
            '<h1>Headline 1</h1> Head1 <p>Footer</p>',
            '<h1>Headline 2</h1> Head2 <p>Footer</p>',
            '<h1>Headline 1</h1> Head1 ',
            1,
        )

    def test_same_tags_different_attributes1(self):
        self.assertStrips(
            '<p style="color: red;">Header</p><h1>Headline 1</h1>',
            '<p                    >Header</p><h1>Headline 2</h1>',
            '<p style="color: red;">Header</p><h1>Headline 1</h1>',
            0,
        )

    def test_same_tags_different_attributes2(self):
        self.assertStrips(
            '<p style="color: red;">Header</p><h1>Headline 1</h1>',
            '<p                    >Header</p><h1>Headline 1</h1>',
            '<p style="color: red;">Header</p>',
            1,
        )

    def test_different_level(self):
        """
        If data is identical but at a different level in the tree,
        strip_template() will not find it.
        """
        self.assertStrips(
            '<div><p>Foo</p><p>Bar</p></div>',
            '<p>Foo</p><p>Bar</p>',
            '<div><p>Foo</p><p>Bar</p></div>',
            0,
        )

    def test_ids_header(self):
        # This would be detected with check_ids=False, but this test makes sure
        # it doesn't break anything to use check_ids=True.
        self.assertStrips(
            '<p id="header">Header</p><h1>Headline 1</h1>',
            '<p id="header">Header</p><h1>Headline 2</h1>',
            '<h1>Headline 1</h1>',
            1,
            check_ids=True,
        )

    def test_ids_footer(self):
        self.assertStrips(
            '<h1>Headline 1</h1><p id="footer">Footer</p>',
            '<h1>Headline 2</h1><p id="footer">Footer</p>',
            '<h1>Headline 1</h1>',
            1,
            check_ids=True,
        )

    def test_ids_header_and_footer(self):
        self.assertStrips(
            '<p id="footer">Header</p><h1>Headline 1</h1><p id="footer">Footer</p>',
            '<p id="footer">Header</p><h1>Headline 2</h1><p id="footer">Footer</p>',
            '<h1>Headline 1</h1>',
            2,
            check_ids=True,
        )

    def test_ids_different_level1(self):
        self.assertStrips(
            '<div><p id="first">Foo</p><p id="second">Bar</p></div>',
            '<p id="first">Foo</p><p id="second">Bar</p>',
            '<div></div>',
            2,
            check_ids=True,
        )

    def test_ids_different_level2(self):
        self.assertStrips(
            '<div><p id="first">Foo</p><p id="second">Bar</p>Tail</div>',
            '<p id="first">Foo</p><p id="second">Bar</p>',
            '<div>Tail</div>',
            2,
            check_ids=True,
        )

    def test_ids_different_level3(self):
        self.assertStrips(
            '<div><p id="first">Foo</p><p id="second">Bar</p>Tail</div>',
            '<p id="first">Foo</p><p id="second">Bar</p>Tail',
            '<div></div>',
            2,
            check_ids=True,
        )

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = hole
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.templatemaker.hole import Hole, OrHole, RegexHole, IgnoreHole
import unittest

class HoleEquality(unittest.TestCase):
    def test_equal_hole(self):
        self.assertEqual(Hole(), Hole())

    def test_nonequal_hole(self):
        self.assertNotEqual(Hole(), OrHole())

    def test_equal_orhole(self):
        self.assertEqual(OrHole('a', 'b'), OrHole('a', 'b'))

    def test_nonequal_orhole1(self):
        self.assertNotEqual(OrHole('a'), OrHole('a', 'b'))

    def test_nonequal_orhole2(self):
        self.assertNotEqual(OrHole('a'), OrHole('b'))

    def test_equal_regexhole1(self):
        self.assertEqual(RegexHole('\d\d', False), RegexHole('\d\d', False))

    def test_equal_regexhole2(self):
        self.assertEqual(RegexHole('(\d\d)', True), RegexHole('(\d\d)', True))

    def test_nonequal_regexhole1(self):
        self.assertNotEqual(RegexHole('\d\d', False), RegexHole('\d', False))

    def test_nonequal_regexhole2(self):
        self.assertNotEqual(RegexHole('\d', False), IgnoreHole())

    def test_nonequal_regexhole3(self):
        self.assertNotEqual(RegexHole('\d', False), Hole())

    def test_nonequal_regexhole4(self):
        self.assertNotEqual(RegexHole('\d\d', False), RegexHole('\d\d', True))

    def test_nonequal_regexhole5(self):
        self.assertNotEqual(RegexHole('\d\d', False), RegexHole('(\d\d)', False))

    def test_equal_ignorehole(self):
        self.assertEqual(IgnoreHole(), IgnoreHole())

    def test_nonequal_ignorehole1(self):
        self.assertNotEqual(IgnoreHole(), Hole())

    def test_nonequal_ignorehole2(self):
        self.assertNotEqual(IgnoreHole(), OrHole('a'))

class HoleRepr(unittest.TestCase):
    def test_hole(self):
        self.assertEqual(repr(Hole()), '<Hole>')

    def test_orhole(self):
        self.assertEqual(repr(OrHole(1, 2, 3, 4)), '<OrHole: (1, 2, 3, 4)>')

    def test_regexhole(self):
        self.assertEqual(repr(RegexHole('\d\d-\d\d', False)), '<RegexHole: \d\d-\d\d>')

    def test_ignorehole(self):
        self.assertEqual(repr(IgnoreHole()), '<IgnoreHole>')

class Regexes(unittest.TestCase):
    def test_hole(self):
        self.assertEqual(Hole().regex(), '(.*?)')

    def test_orhole1(self):
        self.assertEqual(OrHole('a', 'b').regex(), '(a|b)')

    def test_orhole2(self):
        self.assertEqual(OrHole('?', '.').regex(), '(\?|\.)')

    def test_regexhole(self):
        self.assertEqual(RegexHole('\d\d-\d\d', False).regex(), '\d\d-\d\d')

    def test_ignorehole(self):
        self.assertEqual(IgnoreHole().regex(), '.*?')

class HoleCapture(unittest.TestCase):
    def test_hole(self):
        self.assertEqual(Hole().capture, True)

    def test_orhole(self):
        self.assertEqual(OrHole('a', 'b').capture, True)

    def test_regexhole1(self):
        self.assertEqual(RegexHole('\d\d-\d\d', False).capture, False)

    def test_regexhole2(self):
        self.assertEqual(RegexHole('(\d\d-\d\d)', True).capture, True)

    def test_regexhole3(self):
        self.assertEqual(RegexHole('(\d\d-\d\d)', False).capture, False)

    def test_ignorehole(self):
        self.assertEqual(IgnoreHole().capture, False)

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = htmlutils
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.templatemaker.htmlutils import percent_linked_text, printer_friendly_link
from ebdata.templatemaker.htmlutils import remove_empty_tags, brs_to_paragraphs
from ebdata.textmining.treeutils import preprocess
from lxml.html import document_fromstring
from lxml import etree
import unittest

class PercentLinkedTextTestCase(unittest.TestCase):
    def assertPercentLinked(self, html, expected):
        """
        Asserts that the given HTML string has the expected percentage of
        linked text.
        """
        tree = document_fromstring(html)
        self.assertEqual(percent_linked_text(tree), expected)

    def test_basic1(self):
        self.assertPercentLinked('<p><a href=".">Test</a></p>', 1.0)

    def test_basic2(self):
        self.assertPercentLinked('<p>Test</p>', 0.0)

    def test_basic3(self):
        self.assertPercentLinked('<p><a href=".">Test</a>Test</p>', 0.5)

    def test_basic4(self):
        self.assertPercentLinked('<p><a href=".">Test test</a>Test test</p>', 0.5)

    def test_basic5(self):
        self.assertPercentLinked('<p><a href=".">Test</a></p><p>Test2</p>', 4.0 / 9.0)

    def test_empty(self):
        self.assertPercentLinked('<p></p>', 0.0)

class PrinterFriendlyLinkTestCase(unittest.TestCase):
    def assertPrinterFriendlyLink(self, html, expected):
        """
        Asserts that the given HTML string has the expected printer-friendly
        URL.
        """
        tree = document_fromstring(html)
        self.assertEqual(printer_friendly_link(tree), expected)

    def test_empty1(self):
        self.assertPrinterFriendlyLink('<p></p>', None)

    def test_empty2(self):
        self.assertPrinterFriendlyLink('<p><a></a></p>', None)

    def test_empty3(self):
        self.assertPrinterFriendlyLink('<p><a href=""></a></p>', None)

    def test_empty4(self):
        self.assertPrinterFriendlyLink('<p><a href="/1/print/"></a></p>', None)

    def test_noprint1(self):
        self.assertPrinterFriendlyLink('<p><a href="">print</a></p>', None)

    def test_noprint2(self):
        self.assertPrinterFriendlyLink('<p><a href="foo">print</a></p>', None)

    def test_noprint3(self):
        self.assertPrinterFriendlyLink('<p><a href="print"></a></p>', None)

    def test_noprint4(self):
        self.assertPrinterFriendlyLink('<p><a href="print">foo</a></p>', None)

    def test_hit1(self):
        self.assertPrinterFriendlyLink('<p><a href="/1/print/">print</a></p>', '/1/print/')

    def test_hit2(self):
        self.assertPrinterFriendlyLink('<p><a href="/1/print/">printer</a></p>', '/1/print/')

    def test_hit3(self):
        self.assertPrinterFriendlyLink('<p><a href="/1/print/">printer-friendly</a></p>', '/1/print/')

    def test_hit4(self):
        self.assertPrinterFriendlyLink('<p><a href="/1/print/">this link happens to include the word print</a></p>', '/1/print/')

    def test_hit5(self):
        self.assertPrinterFriendlyLink('<p><a href="/1/printer/">printer-friendly</a></p>', '/1/printer/')

    def test_hit_with_child(self):
        self.assertPrinterFriendlyLink('<a href="/mediakit/print/"><img/>Print</a>', '/mediakit/print/')

    def test_case_insensitive1(self):
        self.assertPrinterFriendlyLink('<p><a href="/1/PRINT/">A PRINT VERSION</a></p>', '/1/PRINT/')

    def test_case_insensitive2(self):
        self.assertPrinterFriendlyLink('<p><a href="/1/Print/">Print version</a></p>', '/1/Print/')

    def test_multiple_links1(self):
        self.assertPrinterFriendlyLink('<a href="/1/print/">print 1</a><a href="/2/print/">print 2</a>', '/1/print/')

    def test_multiple_links_first_javascript(self):
        self.assertPrinterFriendlyLink('<a href="javascript:print();">print</a> <p><a href="/1/print/">print</a></p>', '/1/print/')

    def test_javascript1(self):
        self.assertPrinterFriendlyLink('<a href="javascript:print();">print</a>', None)

    def test_javascript2(self):
        self.assertPrinterFriendlyLink('<a href=" javascript:print(); "> print </a>', None)

    def test_false_positive_print_edition1(self):
        self.assertPrinterFriendlyLink('<a href="/news/printedition/front/">Print Edition</a>', None)

    def test_false_positive_print_edition2(self):
        self.assertPrinterFriendlyLink('<a href="/news/printedition/front/">Print-Edition</a>', None)

    def test_false_positive_print_edition3(self):
        self.assertPrinterFriendlyLink('<a href="/news/printedition/front/">Print edition</a>', None)

    def test_false_positive_print_edition4(self):
        self.assertPrinterFriendlyLink('<a href="/1/print/">Print edition</a>', None)

    def test_false_positive_reprint1(self):
        self.assertPrinterFriendlyLink('<a href="/services/site/la-reprint-request-splash,0,6731163.htmlstory">Reprint</a>', None)

    def test_false_positive_reprint2(self):
        self.assertPrinterFriendlyLink('<a href="/reprints">Reprints</a>', None)

    def test_false_positive_print_advertising1(self):
        self.assertPrinterFriendlyLink('<a href="/mediakit/print/">Print advertising</a>', None)

    def test_false_positive_print_advertising2(self):
        self.assertPrinterFriendlyLink('<a href="/mediakit/print/">Print ads</a>', None)

class PreprocessTestCase(unittest.TestCase):
    def assertPreprocess(self, html, expected, **kwargs):
        # The test strings should *not* have <html> and <body> tags, for the
        # sake of brevity.
        html = '<html><body>%s</body></html>' % html
        expected = '<html><body>%s</body></html>' % expected

        result_tree = preprocess(document_fromstring(html), **kwargs)
        got = etree.tostring(result_tree)
        self.assertEqual(got, expected)

    def test_comments1(self):
        self.assertPreprocess(
            '<h1><!-- test --></h1>',
            '<h1/>'
        )

    def test_comments2(self):
        self.assertPreprocess(
            '<h1>A<!-- test --></h1>',
            '<h1>A</h1>'
        )

    def test_comments3(self):
        self.assertPreprocess(
            '<h1><!-- test -->B</h1>',
            '<h1>B</h1>'
        )

    def test_comments4(self):
        self.assertPreprocess(
            '<h1>A<!-- test -->B</h1>',
            '<h1>AB</h1>'
        )

    def test_comments5(self):
        self.assertPreprocess(
            '<h1>A <!-- test -->B</h1>',
            '<h1>A B</h1>'
        )

    def test_comments6(self):
        self.assertPreprocess(
            '<h1><!-- <p> </p> --></h1>',
            '<h1/>'
        )

    def test_dropstyle1(self):
        self.assertPreprocess(
            '<style type="text/css">p { font-weight: 10px; }</style><p>Hello</p>',
            '<p>Hello</p>'
        )

    def test_dropstyle2(self):
        self.assertPreprocess(
            '<STYLE type="text/css">p { font-weight: 10px; }</STYLE><p>Hello</p>',
            '<p>Hello</p>'
        )

    def test_droplink1(self):
        self.assertPreprocess(
            '<link rel="stylesheet" /><p>Hello</p>',
            '<p>Hello</p>'
        )

    def test_dropmeta1(self):
        self.assertPreprocess(
            '<meta  /><p>Hello</p>',
            '<p>Hello</p>'
        )

    def test_dropscript1(self):
        self.assertPreprocess(
            '<script type="text/javascript">alert("hello");</script><p>Hello</p>',
            '<p>Hello</p>'
        )

    def test_dropnoscript1(self):
        self.assertPreprocess(
            '<noscript>Turn on JavaScript.</noscript><p>Hello</p>',
            '<p>Hello</p>'
        )

    def test_drop_tags1_control(self):
        self.assertPreprocess(
            '<b>Hello there</b>',
            '<b>Hello there</b>'
        )

    def test_drop_tags1(self):
        self.assertPreprocess(
            '<b>Hello there</b>',
            'Hello there',
            drop_tags=('b',),
        )

    def test_drop_tags_with_defaults(self):
        self.assertPreprocess(
            '<b>Hello there</b><style type="text/css">div { border: 1px; }</style>',
            'Hello there',
            drop_tags=('b',),
        )

    def test_drop_trees1_control(self):
        self.assertPreprocess(
            'That is <b>cool</b>',
            'That is <b>cool</b>'
        )

    def test_drop_trees1(self):
        self.assertPreprocess(
            'That is <b>cool</b>',
            'That is ',
            drop_trees=('b',)
        )

    def test_dropattrs1_control(self):
        self.assertPreprocess(
            '<div id="head">Hi</div>',
            '<div id="head">Hi</div>'
        )

    def test_dropattrs1(self):
        self.assertPreprocess(
            '<div id="head">Hi</div>',
            '<div>Hi</div>',
            drop_attrs=('id',)
        )

class RemoveEmptyTagsTestCase(unittest.TestCase):
    def assertTagsRemoved(self, html, expected, ignore_tags):
        """
        Asserts that removing all empty tags in `html` (except `ignore_tags`)
        will result in the string `expected`.
        """
        html = '<html><body>%s</body></html>' % html
        expected = '<html><body>%s</body></html>' % expected

        tree = document_fromstring(html)
        remove_empty_tags(tree, ignore_tags)
        self.assertEqual(etree.tostring(tree, method='html'), expected)

    def test_basic1(self):
        self.assertTagsRemoved('<p></p>', '', ())

    def test_basic2(self):
        self.assertTagsRemoved('<div></div>', '', ())

    def test_basic3(self):
        self.assertTagsRemoved('<br>', '', ())

    def test_basic4(self):
        self.assertTagsRemoved('a<p></p>b', 'ab', ())

    def test_basic5(self):
        self.assertTagsRemoved(' <p></p> ', '  ', ())

    def test_nested1(self):
        self.assertTagsRemoved('<div><p></p></div>', '', ())

    def test_nested2(self):
        self.assertTagsRemoved('<div><div><p></p></div></div>', '', ())

    def test_nested3(self):
        self.assertTagsRemoved('<div><div><p><br></p></div></div>', '', ())

    def test_nested4(self):
        self.assertTagsRemoved('<p><br></p>', '', ())

    def test_nested5(self):
        self.assertTagsRemoved('<div><p></p><p>Hey<span></span></p></div>', '<div><p>Hey</p></div>', ())

    def test_ignore1(self):
        self.assertTagsRemoved('<div></div>', '', ('br',))

    def test_ignore2(self):
        self.assertTagsRemoved('<br>', '<br>', ('br',))

    def test_ignore3(self):
        self.assertTagsRemoved('<p><br></p>', '<p><br></p>', ('br',))

    def test_wacky(self):
        self.assertTagsRemoved('<div><br/></div><br/>', '', ())

class BreakToParagraphTestCase(unittest.TestCase):
    def assertConverted(self, html, expected):
        html = '<html><body>%s</body></html>' % html
        expected = '<html><body>%s</body></html>' % expected

        tree = document_fromstring(html)
        tree = brs_to_paragraphs(tree)
        self.assertEqual(etree.tostring(tree, method='html'), expected)

    def test_basic1(self):
        self.assertConverted('<h1>Headline</h1>', '<h1>Headline</h1>')

    def test_basic2(self):
        self.assertConverted('<h1>Headline <span>Yo</span></h1>', '<h1>Headline <span>Yo</span></h1>')

    def test_basic3(self):
        self.assertConverted('First line<br>Second line', '<p>First line</p><p>Second line</p>')

    def test_basic4(self):
        self.assertConverted('<div>Hello there</div>', '<div>Hello there</div>')

    def test_empty(self):
        self.assertConverted('', '')

    def test_block_trailing_text(self):
        self.assertConverted('<div><h1>Headline</h1>Paragraph 1<br>Paragraph2</div>',
                             '<div><h1>Headline</h1><p>Paragraph 1</p><p>Paragraph2</p></div>')

    def test_initial_text(self):
        # make sure elements whose contents start with text get that text put into a <p>
        self.assertConverted('<div>Paragraph 1<br>Paragraph2</div>',
                             '<div><p>Paragraph 1</p><p>Paragraph2</p></div>')

    def test_consecutive_brs(self):
        # <br> tags with no intervening text shouldn't result in empty <p> tags
        self.assertConverted('<div>Paragraph 1<br><br><br>Paragraph 2</div>',
                             '<div><p>Paragraph 1</p><p>Paragraph 2</p></div>')

    def test_inline_links(self):
        # make sure inline <a> tags are kept in the <p> we build
        self.assertConverted('<div>Paragraph <a href="">1</a> is here.<br>Paragraph 2</div>',
                             '<div><p>Paragraph <a href="">1</a> is here.</p><p>Paragraph 2</p></div>')

    def test_trailing_whitespace(self):
        # make sure trailing whitespace doesn't get wrapped in p tags, and that
        # the element preceding the whitespace is handled correctly.
        self.assertConverted('<div><p>Paragraph 1<br>Paragraph2</p></div>   ',
                             '<div><p><p>Paragraph 1</p><p>Paragraph2</p></p></div>')

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = listdiff
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.templatemaker.hole import Hole
from ebdata.templatemaker.listdiff import listdiff, longest_common_substring
import unittest

class LongestCommonSubstring(unittest.TestCase):
    def LCS(self, seq1, seq2):
        return longest_common_substring(seq1, seq2)

    def assertLCS(self, seq1, seq2, expected_length, expected_offset1, expected_offset2):
        best_size, offset1, offset2 = self.LCS(seq1, seq2)
        self.assertEqual(best_size, expected_length)
        self.assertEqual(offset1, expected_offset1)
        self.assertEqual(offset2, expected_offset2)

    def test_both_empty(self):
        self.assertLCS([], [], 0, -1, -1)

    def test_l1_empty(self):
        self.assertLCS([], ['a'], 0, -1, -1)

    def test_l2_empty(self):
        self.assertLCS(['a'], [], 0, -1, -1)

    def test_equal1(self):
        self.assertLCS(['a'], ['a'], 1, 0, 0)

    def test_equal2(self):
        self.assertLCS(['a', 'b', 'c'], ['a', 'b', 'c'], 3, 0, 0)

    def test_common1(self):
        self.assertLCS(['a', 'b', 'c'], ['b', 'c', 'a'], 2, 1, 0)

    def test_common2(self):
        self.assertLCS(['b', 'c', 'a'], ['a', 'b', 'c'], 2, 0, 1)

    def test_common3(self):
        self.assertLCS(['a', 'b', 'c', 'd'], ['a'], 1, 0, 0)

    def test_common4(self):
        self.assertLCS(['a', 'b', 'c', 'd'], ['b'], 1, 1, 0)

    def test_common5(self):
        self.assertLCS(['a', 'b', 'c', 'd'], ['c'], 1, 2, 0)

    def test_common6(self):
        self.assertLCS(['a', 'b', 'c', 'd'], ['d'], 1, 3, 0)

    def test_common7(self):
        self.assertLCS(['a', 'b', 'c', 'd'], ['c', 'd'], 2, 2, 0)

    def test_common8(self):
        self.assertLCS(['a', 'b', 'c', 'd'], ['f', 'c', 'd'], 2, 2, 1)

    def test_common9(self):
        self.assertLCS(['a'], ['a', 'b', 'c', 'd'], 1, 0, 0)

    def test_common10(self):
        self.assertLCS(['b'], ['a', 'b', 'c', 'd'], 1, 0, 1)

    def test_common11(self):
        self.assertLCS(['c'], ['a', 'b', 'c', 'd'], 1, 0, 2)

    def test_common12(self):
        self.assertLCS(['d'], ['a', 'b', 'c', 'd'], 1, 0, 3)

    def test_common13(self):
        self.assertLCS(['c', 'd'], ['a', 'b', 'c', 'd'], 2, 0, 2)

    def test_common14(self):
        self.assertLCS(['f', 'c', 'd'], ['a', 'b', 'c', 'd'], 2, 1, 2)

    def test_common15(self):
        self.assertLCS(['1', '2', '!', '4', '5'], ['1', '2', '3', '4', '5'], 2, 0, 0)

    def test_common16(self):
        self.assertLCS(['1', '2', '4', '5'], ['1', '2', '3', '4', '5'], 2, 0, 0)

    def test_common17(self):
        self.assertLCS(['1', '2', '3', '4', '5'], ['1', '2', '4', '5'], 2, 0, 0)

    def test_hole1(self):
        self.assertLCS([Hole()], [Hole()], 1, 0, 0)

    def test_hole2(self):
        self.assertLCS([Hole(), Hole()], [Hole(), Hole()], 2, 0, 0)

    def test_hole3(self):
        self.assertLCS([Hole(), 'a'], [Hole(), 'b'], 1, 0, 0)

    def test_hole4(self):
        self.assertLCS(['a', Hole(), 'b'], ['a', Hole(), 'b'], 3, 0, 0)

    def test_hole5(self):
        self.assertLCS(['b', Hole(), 'c'], ['a', Hole(), 'c'], 2, 1, 1)

    def test_hole6(self):
        self.assertLCS(['a', Hole(), 'b'], ['c', Hole(), 'd'], 1, 1, 1)

    def test_earliest1(self):
        "The LCS should be the earliest index in both strings."
        self.assertLCS(['b', 'a', 'c'], ['a', 'd', 'a'], 1, 1, 0)

    def test_earliest2(self):
        "The LCS should be the earliest index in both strings."
        self.assertLCS(['a', 'd', 'a'], ['b', 'a', 'c'], 1, 0, 1)

class ListdiffTestCase(unittest.TestCase):
    def assertListdiff(self, l1, l2, expected):
        self.assertEqual(listdiff(l1, l2), expected)

    def test_both_empty(self):
        self.assertListdiff([], [], [])

    def test_l1_empty(self):
        self.assertListdiff(
            [],
            ['a'],
            [Hole()],
        )

    def test_l2_empty(self):
        self.assertListdiff(
            ['a'],
            [],
            [Hole()],
        )

    def test_equal1(self):
        self.assertListdiff(
            ['a'],
            ['a'],
            ['a'],
        )

    def test_equal2(self):
        self.assertListdiff(
            ['a', 'b'],
            ['a', 'b'],
            ['a', 'b'],
        )

    def test_equal3(self):
        self.assertListdiff(
            ['a', 'b', 'c'],
            ['a', 'b', 'c'],
            ['a', 'b', 'c'],
        )

    def test_hole1(self):
        self.assertListdiff(
            ['Hello', ' ', 'John'],
            ['Hello', ' ', 'Fran'],
            ['Hello', ' ', Hole()],
        )

    def test_hole2(self):
        self.assertListdiff(
            ['Hello', ' ', 'John'],
            ['Goodbye', ' ', 'Fran'],
            [Hole(), ' ', Hole()],
        )

    def test_hole3(self):
        self.assertListdiff(
            ['a', 'b', 'c', 'd', 'e', 'f'],
            ['a', '_', 'c', '_', 'e', '_'],
            ['a', Hole(), 'c', Hole(), 'e', Hole()],
        )

    def test_hole4(self):
        self.assertListdiff(
            ['a', 'b', 'c', 'd', 'e', 'f'],
            ['_', 'b', '_', 'd', '_', 'f'],
            [Hole(), 'b', Hole(), 'd', Hole(), 'f'],
        )

    def test_hole5(self):
        self.assertListdiff(
            ['this', ' ', 'and', ' ', 'that'],
            ['foo', ' ', 'and', ' ', 'bar'],
            [Hole(), ' ', 'and', ' ', Hole()],
        )

    def test_hole6(self):
        self.assertListdiff(
            ['1', '2', '3', '4', '5'],
            ['1', '2', '4', '5'],
            ['1', '2', Hole(), '4', '5'],
        )

    def test_hole7(self):
        self.assertListdiff(
            ['1', '2', '4', '5'],
            ['1', '2', '3', '4', '5'],
            ['1', '2', Hole(), '4', '5'],
        )

    def test_hole8(self):
        self.assertListdiff(
            ['3', '4', '5'],
            ['4', '5'],
            [Hole(), '4', '5'],
        )

    def test_hole9(self):
        self.assertListdiff(
            ['4', '5'],
            ['5'],
            [Hole(), '5'],
        )

    def test_hole_input1(self):
        self.assertListdiff(
            [Hole()],
            [Hole()],
            [Hole()],
        )

    def test_hole_input2(self):
        self.assertListdiff(
            [],
            [Hole()],
            [Hole()],
        )

    def test_hole_input3(self):
        self.assertListdiff(
            [Hole()],
            [],
            [Hole()],
        )

    def test_hole_input4(self):
        self.assertListdiff(
            [Hole(), 'hello'],
            [Hole(), 'hello'],
            [Hole(), 'hello'],
        )

    def test_hole_input5(self):
        self.assertListdiff(
            [Hole(), 'person 1'],
            [Hole(), 'person 2'],
            [Hole(), Hole()],
        )

    def test_hole_input6(self):
        self.assertListdiff(
            [Hole(), 'person 1', ' test'],
            [Hole(), 'person 2', ' test'],
            [Hole(), Hole(), ' test'],
        )

    def test_hole_input7(self):
        self.assertListdiff(
            ['foo', Hole(), 'person 1 test'],
            ['foo', Hole(), 'person 2 test'],
            ['foo', Hole(), Hole()],
        )

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = listdiffc
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
These tests are identical to the ones in listdiff.py but use the C version of
longest_common_substring instead of the pure Python version.
"""

from ebdata.templatemaker.listdiffc import longest_common_subsequence as longest_common_substring
from listdiff import LongestCommonSubstring
import unittest

class LongestCommonSubstringC(LongestCommonSubstring):
    def LCS(self, seq1, seq2):
        return longest_common_substring(seq1, seq2)

del LongestCommonSubstring

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = run_all
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

import glob

for filename in glob.glob('*.py'):
    exec 'from %s import *' % filename[:-3]

if __name__ == '__main__':
    import unittest
    unittest.main()

########NEW FILE########
__FILENAME__ = sst
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.templatemaker.sst import tree_diff, Template, NoMatch
from ebdata.textmining.treeutils import preprocess
from lxml import etree
from lxml.html import document_fromstring
import unittest

class TreeDiffTestCaseAlgorithm1(unittest.TestCase):
    algorithm = 1
    def assertTreeDiff(self, html1, html2, expected):
        """
        Asserts that the given HTML strings will produce a tree_diff of the
        expected HTML string.
        """
        # The test strings should *not* have <html> and <body> tags, for the
        # sake of brevity.
        tree1 = document_fromstring('<html><body>%s</body></html>' % html1)
        tree2 = document_fromstring('<html><body>%s</body></html>' % html2)
        expected = '<html><body>%s</body></html>' % expected

        result_tree = tree_diff(preprocess(tree1), preprocess(tree2), self.algorithm)
        got = etree.tostring(result_tree)
        self.assertEqual(got, expected)

    def test_same1(self):
        self.assertTreeDiff(
            '<h1>test</h1>',
            '<h1>test</h1>',
            '<h1>test</h1>'
        )

    def test_case_insensitive_tags(self):
        self.assertTreeDiff(
            '<h1>test</h1>',
            '<H1>test</H1>',
            '<h1>test</h1>'
        )

    def test_texthole1(self):
        self.assertTreeDiff(
            '<h1>Headline</h1>',
            '<h1>Different</h1>',
            '<h1>TEXT_HOLE</h1>'
        )

    def test_texthole2(self):
        self.assertTreeDiff(
            '<h1>Headline</h1><p>Para</p>',
            '<h1>Different</h1><p>Para</p>',
            '<h1>TEXT_HOLE</h1><p>Para</p>'
        )

    def test_texthole3(self):
        self.assertTreeDiff(
            '<h1>Headline</h1><p>Para</p><p>Final</p>',
            '<h1>Different</h1><p>Para</p><p>Diff</p>',
            '<h1>TEXT_HOLE</h1><p>Para</p><MULTITAG_HOLE/>'
        )

    def test_tailhole1(self):
        self.assertTreeDiff(
            '<p>That was <b>so</b> fun.</p>',
            '<p>That was <b>so</b> boring.</p>',
            '<p>That was <b>so</b>TAIL_HOLE</p>'
        )

    def test_attribhole1(self):
        self.assertTreeDiff(
            '<p id="foo">Hello</p>',
            '<p id="bar">Hello</p>',
            '<p id="ATTRIB_HOLE">Hello</p>'
        )

    def test_attribhole2(self):
        self.assertTreeDiff(
            '<p id="bar" class="1">Hello</p>',
            '<p id="bar" class="2">Hello</p>',
            '<p id="bar" class="ATTRIB_HOLE">Hello</p>'
        )

    def test_attribhole3(self):
        self.assertTreeDiff(
            '<p id="bar">Hello</p>',
            '<p>Hello</p>',
            '<p id="ATTRIB_HOLE">Hello</p>'
        )

    def test_attribhole4(self):
        self.assertTreeDiff(
            '<p>Hello</p>',
            '<p id="bar">Hello</p>',
            '<p id="ATTRIB_HOLE">Hello</p>'
        )

    def test_multitaghole1(self):
        self.assertTreeDiff(
            '<div><p>Yes</p><p>No</p></div>',
            '<div><p>Yes</p><p>No</p><p>Maybe</p></div>',
            '<div><p>Yes</p><p>No</p><MULTITAG_HOLE/></div>'
        )

    def test_multitaghole2(self):
        self.assertTreeDiff(
            '<div>Text <p>Yes</p><p>No</p></div>',
            '<div>Text <p>Yes</p><p>No</p><p>Maybe</p></div>',
            '<div>Text <p>Yes</p><p>No</p><MULTITAG_HOLE/></div>'
        )

    def test_multitaghole3(self):
        self.assertTreeDiff(
            '<div><p>Yes</p><p>No</p> Tail</div>',
            '<div><p>Yes</p><p>No</p><p>Maybe</p> Tail</div>',
            '<div><p>Yes</p><p>No</p>TAIL_HOLE<MULTITAG_HOLE/></div>'
        )

    def test_multitaghole4(self):
        self.assertTreeDiff(
            '<div><p>Yes</p><p>No</p></div>',
            '<div><p>Foo</p><p>Bar</p><p>Maybe</p></div>',
            '<div><MULTITAG_HOLE/></div>'
        )

    def test_multitaghole5(self):
        self.assertTreeDiff(
            '<div><p>Yes</p><p>No</p></div>',
            '<div><p>Yes</p><p>Bar</p><p>Maybe</p></div>',
            '<div><p>Yes</p><MULTITAG_HOLE/></div>'
        )

    def test_multitaghole6(self):
        self.assertTreeDiff(
            '<div><p>Yes</p><p>No</p></div>',
            '<div><p>Yes</p><p id="test">No</p><p>Maybe</p></div>',
            '<div><p>Yes</p><p id="ATTRIB_HOLE">No</p><MULTITAG_HOLE/></div>'
        )

    def test_same_level_p(self): 
        self.assertTreeDiff( 
            '<p>First 1</p>', 
            '<p>Second 1</p><p>Second 2</p>', 
            '<MULTITAG_HOLE/>' 
        ) 

    def test_same_level_h1(self): 
        self.assertTreeDiff( 
            '<h1>First 1</h1>', 
            '<h1>Second 1</h1><p>Second 2</p>', 
            '<h1>TEXT_HOLE</h1><MULTITAG_HOLE/>'
        ) 

    def test_same_level_h2(self): 
        self.assertTreeDiff( 
            '<h2>First 1</h2>', 
            '<h2>Second 1</h2><p>Second 2</p>', 
            '<h2>TEXT_HOLE</h2><MULTITAG_HOLE/>'
        ) 

    def test_same_level_h3(self): 
        self.assertTreeDiff( 
            '<h3>First 1</h3>', 
            '<h3>Second 1</h3><p>Second 2</p>', 
            '<h3>TEXT_HOLE</h3><MULTITAG_HOLE/>'
        ) 

    def test_same_level_h4(self): 
        self.assertTreeDiff( 
            '<h4>First 1</h4>', 
            '<h4>Second 1</h4><p>Second 2</p>', 
            '<h4>TEXT_HOLE</h4><MULTITAG_HOLE/>'
        ) 

    def test_same_level_h5(self): 
        self.assertTreeDiff( 
            '<h5>First 1</h5>', 
            '<h5>Second 1</h5><p>Second 2</p>', 
            '<h5>TEXT_HOLE</h5><MULTITAG_HOLE/>'
        ) 

    def test_same_level_h6(self): 
        self.assertTreeDiff( 
            '<h6>First 1</h6>', 
            '<h6>Second 1</h6><p>Second 2</p>', 
            '<h6>TEXT_HOLE</h6><MULTITAG_HOLE/>'
        ) 

    def test_same_level_a(self): 
        self.assertTreeDiff( 
            '<a>First 1</a>', 
            '<a>Second 1</a><p>Second 2</p>', 
            '<a>TEXT_HOLE</a><MULTITAG_HOLE/>'
        ) 

    def test_same_level1(self):
        self.assertTreeDiff(
            '<h1>Man seen</h1><p>By John Smith</p><p>A man was seen today.</p>',
            '<h1>Bird seen</h1><p>By John Smith</p><p>A bird was seen yesterday.</p>',
            '<h1>TEXT_HOLE</h1><p>By John Smith</p><MULTITAG_HOLE/>'
        )

    def test_same_level2(self):
        self.assertTreeDiff(
            '<p>By John Smith</p><h1>Man seen</h1><p>A man was seen today.</p>',
            '<p>By John Smith</p><h1>Bird seen</h1><p>A bird was seen yesterday.</p>',
            '<p>By John Smith</p><h1>TEXT_HOLE</h1><MULTITAG_HOLE/>'
        )

    def test_same_level3(self):
        self.assertTreeDiff(
            '<p>By John Smith</p><h1>Man seen</h1><p>A man was seen today.</p><p>The end.</p>',
            '<p>By John Smith</p><h1>Bird seen</h1><p>A bird was seen yesterday.</p><p>The end.</p>',
            '<p>By John Smith</p><h1>TEXT_HOLE</h1><MULTITAG_HOLE/><p>The end.</p>'
        )

    def test_confusing(self):
        # Note: The "~" are in here to make this more understandable by vertical alignment.
        self.assertTreeDiff(
            '<ul>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<li/>\n\t\t<li/>\n\t\t<li class="current"></li>\n\t\t<li/>\n\t</ul>'.replace('~', ''),
            '<ul><li class="current"></li>\n\t\t<li/>\n\t\t<li/>\n\t\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<li/>\n\t</ul>'.replace('~', ''),
            '<ul><MULTITAG_HOLE/>~~~~~~~~~~~~~~~<li/>\n\t\t<li/>\n\t\t<MULTITAG_HOLE/>~~~~~~~~~~~~~~~<li/>\n\t</ul>'.replace('~', ''),
        )

    def test_mixed1(self):
        self.assertTreeDiff(
            '<h1>Headline</h1><p>This thing</p><br/><div id="footer">Copyright 2006</div>',
            '<h1>Headline 2</h1><p id="first">This thing</p><br/><div id="footer">Copyright 2007</div>',
            '<h1>TEXT_HOLE</h1><p id="ATTRIB_HOLE">This thing</p><MULTITAG_HOLE/>'
        )

    def test_comments_ignored1(self):
        self.assertTreeDiff(
            '<h1><!-- comment --></h1>',
            '<h1></h1>',
            '<h1/>',
        )

    def test_comments_ignored2(self):
        self.assertTreeDiff(
            '<h1>A<!-- comment --></h1>',
            '<h1>A</h1>',
            '<h1>A</h1>',
        )

    def test_comments_ignored3(self):
        self.assertTreeDiff(
            '<h1><!-- comment -->A</h1>',
            '<h1>A</h1>',
            '<h1>A</h1>',
        )

    def test_comments_ignored4(self):
        self.assertTreeDiff(
            '<h1>A<!-- comment -->B</h1>',
            '<h1>AB</h1>',
            '<h1>AB</h1>',
        )

    def test_comments_ignored5(self):
        self.assertTreeDiff(
            '<h1>Title <!-- foo -->here</h1>',
            '<h1>Title here</h1>',
            '<h1>Title here</h1>',
        )

    def test_comments_ignored6(self):
        self.assertTreeDiff(
            '<h1>Title <!-- foo -->here</h1><!--<p>nothing</p>--><p><!--foo-->Paragraph here</p>',
            '<h1>Title here</h1><p>Paragraph here</p>',
            '<h1>Title here</h1><p>Paragraph here</p>',
        )

class TreeDiffTestCaseAlgorithm2(TreeDiffTestCaseAlgorithm1):
    """
    Like TreeDiffTestCaseAlgorithm1, but it uses algorithm 2. As such, it only
    needs to implement the methods whose outcome is different between the two
    algorithms.
    """
    algorithm = 2

    def test_texthole3(self):
        self.assertTreeDiff(
            '<h1>Headline</h1><p>Para</p><p>Final</p>',
            '<h1>Different</h1><p>Para</p><p>Diff</p>',
            '<h1>TEXT_HOLE</h1><p>Para</p><p>TEXT_HOLE</p>'
        )

    def test_multitaghole1(self):
        self.assertTreeDiff(
            '<div><p>Yes</p><p>No</p></div>',
            '<div><p>Yes</p><p>No</p><p>Maybe</p></div>',
            '<div><MULTITAG_HOLE/></div>'
        )

    def test_multitaghole2(self):
        self.assertTreeDiff(
            '<div>Text <p>Yes</p><p>No</p></div>',
            '<div>Text <p>Yes</p><p>No</p><p>Maybe</p></div>',
            '<div>Text <MULTITAG_HOLE/></div>'
        )

    def test_multitaghole3(self):
        self.assertTreeDiff(
            '<div><p>Yes</p><p>No</p> Tail</div>',
            '<div><p>Yes</p><p>No</p><p>Maybe</p> Tail</div>',
            '<div><MULTITAG_HOLE/></div>'
        )

    def test_multitaghole5(self):
        self.assertTreeDiff(
            '<div><p>Yes</p><p>No</p></div>',
            '<div><p>Yes</p><p>Bar</p><p>Maybe</p></div>',
            '<div><MULTITAG_HOLE/></div>'
        )

    def test_multitaghole6(self):
        self.assertTreeDiff(
            '<div><p>Yes</p><p>No</p></div>',
            '<div><p>Yes</p><p id="test">No</p><p>Maybe</p></div>',
            '<div><MULTITAG_HOLE/></div>'
        )
    def test_same_level_h1(self): 
        self.assertTreeDiff( 
            '<h1>First 1</h1>', 
            '<h1>Second 1</h1><p>Second 2</p>', 
            '<MULTITAG_HOLE/>'
        ) 

    def test_same_level_h2(self): 
        self.assertTreeDiff( 
            '<h2>First 1</h2>', 
            '<h2>Second 1</h2><p>Second 2</p>', 
            '<MULTITAG_HOLE/>'
        ) 

    def test_same_level_h3(self): 
        self.assertTreeDiff( 
            '<h3>First 1</h3>', 
            '<h3>Second 1</h3><p>Second 2</p>', 
            '<MULTITAG_HOLE/>'
        ) 

    def test_same_level_h4(self): 
        self.assertTreeDiff( 
            '<h4>First 1</h4>', 
            '<h4>Second 1</h4><p>Second 2</p>', 
            '<MULTITAG_HOLE/>'
        ) 

    def test_same_level_h5(self): 
        self.assertTreeDiff( 
            '<h5>First 1</h5>', 
            '<h5>Second 1</h5><p>Second 2</p>', 
            '<MULTITAG_HOLE/>'
        ) 

    def test_same_level_h6(self): 
        self.assertTreeDiff( 
            '<h6>First 1</h6>', 
            '<h6>Second 1</h6><p>Second 2</p>', 
            '<MULTITAG_HOLE/>'
        ) 

    def test_same_level_a(self): 
        self.assertTreeDiff( 
            '<a>First 1</a>', 
            '<a>Second 1</a><p>Second 2</p>', 
            '<MULTITAG_HOLE/>'
        ) 

    def test_same_level1(self):
        self.assertTreeDiff(
            '<h1>Man seen</h1><p>By John Smith</p><p>A man was seen today.</p>',
            '<h1>Bird seen</h1><p>By John Smith</p><p>A bird was seen yesterday.</p>',
            '<h1>TEXT_HOLE</h1><p>By John Smith</p><p>TEXT_HOLE</p>'
        )

    def test_same_level2(self):
        self.assertTreeDiff(
            '<p>By John Smith</p><h1>Man seen</h1><p>A man was seen today.</p>',
            '<p>By John Smith</p><h1>Bird seen</h1><p>A bird was seen yesterday.</p>',
            '<p>By John Smith</p><h1>TEXT_HOLE</h1><p>TEXT_HOLE</p>'
        )

    def test_same_level3(self):
        self.assertTreeDiff(
            '<p>By John Smith</p><h1>Man seen</h1><p>A man was seen today.</p><p>The end.</p>',
            '<p>By John Smith</p><h1>Bird seen</h1><p>A bird was seen yesterday.</p><p>The end.</p>',
            '<p>By John Smith</p><h1>TEXT_HOLE</h1><p>TEXT_HOLE</p><p>The end.</p>'
        )

    def test_confusing(self):
        # Note: The "~" are in here to make this more understandable by vertical alignment.
        self.assertTreeDiff(
            '<ul>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<li/>\n\t\t<li/>\n\t\t<li class="current"></li>\n\t\t<li/>\n\t</ul>'.replace('~', ''),
            '<ul><li class="current"></li>\n\t\t<li/>\n\t\t<li/>\n\t\t~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<li/>\n\t</ul>'.replace('~', ''),
            '<ul><li class="ATTRIB_HOLE"/>\n\t\t<li/>\n\t\t<li class="ATTRIB_HOLE"/>\n\t\t<li/>\n\t</ul>'.replace('~', ''),
        )

    def test_mixed1(self):
        self.assertTreeDiff(
            '<h1>Headline</h1><p>This thing</p><br/><div id="footer">Copyright 2006</div>',
            '<h1>Headline 2</h1><p id="first">This thing</p><br/><div id="footer">Copyright 2007</div>',
            '<h1>TEXT_HOLE</h1><p id="ATTRIB_HOLE">This thing</p><br/><div id="footer">TEXT_HOLE</div>'
        )

class TemplateExtractionTestCaseAlgorithm1(unittest.TestCase):
    algorithm = 1
    def assertExtracts(self, html_list, expected_data_list):
        """
        Creates a Template from every string in html_list, then extracts the
        data from each of those strings, asserting that the data matches
        expected_data_list.
        """
        t = Template(algorithm=self.algorithm)
        for html in html_list:
            t.learn(html)
        got_data_list = []
        for html in html_list:
            got_data_list.append(t.extract(html))
        self.assertEqual(got_data_list, expected_data_list)

    def assertNoMatch(self, html_list, sample):
        """
        Creates a Template from every string in html_list, then asserts that
        t.extract(sample) raises NoMatch.
        """
        t = Template()
        for html in html_list:
            t.learn(html)
        self.assertRaises(NoMatch, t.extract, sample)

    def test_same1(self):
        self.assertExtracts(
            ['<h1>test</h1>', '<h1>test</h1>'],
            [[], []],
        )

    def test_case_insensitive_tags(self):
        self.assertExtracts(
            ['<h1>test</h1>', '<H1>test</H1>'],
            [[], []],
        )

    def test_texthole1(self):
        self.assertExtracts(
            ['<h1>Headline</h1>', '<h1>Different</h1>'],
            [[{'type': 'text', 'value': 'Headline', 'tag': 'h1'}],
             [{'type': 'text', 'value': 'Different', 'tag': 'h1'}]]
        )

    def test_texthole2(self):
        self.assertExtracts(
            ['<h1>Headline</h1><p>Para</p>', '<h1>Different</h1><p>Para</p>'],
            [[{'type': 'text', 'value': 'Headline', 'tag': 'h1'}],
             [{'type': 'text', 'value': 'Different', 'tag': 'h1'}]]
        )

    def test_texthole3(self):
        self.assertExtracts(
            ['<h1>Headline</h1><p>Para</p><p>Final</p>', '<h1>Different</h1><p>Para</p><p>Diff</p>'],
            [[{'type': 'text', 'value': 'Headline', 'tag': 'h1'}, {'type': 'multitag', 'value': '<p>Final</p>', 'tag': None}],
             [{'type': 'text', 'value': 'Different', 'tag': 'h1'}, {'type': 'multitag', 'value': '<p>Diff</p>', 'tag': None}]]
        )

    def test_tailhole1(self):
        self.assertExtracts(
            ['<p>That was <b>so</b> fun.</p>', '<p>That was <b>so</b> boring.</p>'],
            [[{'type': 'tail', 'value': ' fun.', 'tag': 'p'}],
             [{'type': 'tail', 'value': ' boring.', 'tag': 'p'}]]
        )

    def test_tailhole2(self):
        self.assertExtracts(
            ['<p>That was <em><b>so</b></em> fun.</p>', '<p>That was <em><b>so</b></em> boring.</p>'],
            [[{'type': 'tail', 'value': ' fun.', 'tag': 'p'}],
             [{'type': 'tail', 'value': ' boring.', 'tag': 'p'}]]
        )

    def test_attribhole1(self):
        self.assertExtracts(
            ['<p id="foo">Hello</p>', '<p id="bar">Hello</p>'],
            [[{'type': 'attrib', 'value': 'foo', 'tag': 'p'}],
             [{'type': 'attrib', 'value': 'bar', 'tag': 'p'}]]
        )

    def test_attribhole2(self):
        self.assertExtracts(
            ['<p id="bar" class="1">Hello</p>', '<p id="bar" class="2">Hello</p>'],
            [[{'type': 'attrib', 'value': '1', 'tag': 'p'}],
             [{'type': 'attrib', 'value': '2', 'tag': 'p'}]]
        )

    def test_attribhole3(self):
        self.assertExtracts(
            ['<p id="bar">Hello</p>', '<p>Hello</p>'],
            [[{'type': 'attrib', 'value': 'bar', 'tag': 'p'}],
             [{'type': 'attrib', 'value': '', 'tag': 'p'}]]
        )

    def test_attribhole4(self):
        self.assertExtracts(
            ['<p>Hello</p>', '<p id="bar">Hello</p>'],
            [[{'type': 'attrib', 'value': '', 'tag': 'p'}],
             [{'type': 'attrib', 'value': 'bar', 'tag': 'p'}]]
        )

    def test_attribhole5(self):
        self.assertExtracts(
            ['<p class="klass" id="eyedee">Hello</p>', '<p id="eyedee" class="klass">Hello</p>'],
            [[], []]
        )

    def test_attribhole6(self):
        self.assertExtracts(
            ['<p class="klass" id="eyedee">Hello</p>', '<p id="eyedee2" class="klass2">Hello</p>'],
            [[{'type': 'attrib', 'value': 'klass', 'tag': 'p'}, {'type': 'attrib', 'value': 'eyedee', 'tag': 'p'}],
             [{'type': 'attrib', 'value': 'klass2', 'tag': 'p'}, {'type': 'attrib', 'value': 'eyedee2', 'tag': 'p'}]]
        )

    def test_attribhole7(self):
        self.assertExtracts(
            ['<p class="klass" id="eyedee">Hello</p>', '<p id="eyedee2" class="klass2" newatt="on">Hello</p>'],
            [[{'type': 'attrib', 'value': 'klass', 'tag': 'p'}, {'type': 'attrib', 'value': 'eyedee', 'tag': 'p'}, {'type': 'attrib', 'value': '', 'tag': 'p'}],
             [{'type': 'attrib', 'value': 'klass2', 'tag': 'p'}, {'type': 'attrib', 'value': 'eyedee2', 'tag': 'p'}, {'type': 'attrib', 'value': 'on', 'tag': 'p'}]]
        )

    def test_multitaghole1(self):
        self.assertExtracts(
            ['<div><p>Yes</p><p>No</p></div>', '<div><p>Yes</p><p>No</p><p>Maybe</p></div>'],
            [[{'type': 'multitag', 'value': '', 'tag': None}],
             [{'type': 'multitag', 'value': '<p>Maybe</p>', 'tag': None}]]
        )

    def test_multitaghole2(self):
        self.assertExtracts(
            ['<div>Text <p>Yes</p><p>No</p></div>', '<div>Text <p>Yes</p><p>No</p><p>Maybe</p></div>'],
            [[{'type': 'multitag', 'value': '', 'tag': None}],
             [{'type': 'multitag', 'value': '<p>Maybe</p>', 'tag': None}]]
        )

    def test_multitaghole3(self):
        # This one fails.  Bug? Wrong expectations of output? No idea. - PW
        self.assertExtracts(
            ['<div><p>Yes</p><p>No</p> Tail</div>',
             '<div><p>Yes</p><p>No</p><p>Maybe</p> Tail</div>'],
            [[{'type': 'multitag', 'value': '', 'tag': None}],
             [{'type': 'multitag', 'value': '<p>Maybe</p>', 'tag': None}]]
        )

    def test_multitaghole4(self):
        self.assertExtracts(
            ['<div><p>Yes</p><p>No</p></div>', '<div><p>Foo</p><p>Bar</p><p>Maybe</p></div>'],
            [[{'type': 'multitag', 'value': '<p>Yes</p><p>No</p>', 'tag': None}],
             [{'type': 'multitag', 'value': '<p>Foo</p><p>Bar</p><p>Maybe</p>', 'tag': None}]]
        )

    def test_multitaghole5(self):
        self.assertExtracts(
            ['<div><p>Yes</p><p>No</p></div>', '<div><p>Yes</p><p>Bar</p><p>Maybe</p></div>'],
            [[{'tag': None, 'type': 'multitag', 'value': '<p>No</p>'}],
             [{'tag': None, 'type': 'multitag', 'value': '<p>Bar</p><p>Maybe</p>'}]]
        )

    def test_multitaghole6(self):
        self.assertExtracts(
            ['<div><p>Yes</p><p>No</p></div>', '<div><p>Yes</p><p id="test">No</p><p>Maybe</p></div>'],
            [[{'tag': 'p', 'type': 'attrib', 'value': ''}, {'tag': None, 'type': 'multitag', 'value': ''}],
             [{'tag': 'p', 'type': 'attrib', 'value': 'test'}, {'tag': None, 'type': 'multitag', 'value': '<p>Maybe</p>'}]]
        )

    def test_same_level1(self):
        self.assertExtracts(
            ['<h1>Man seen</h1><p>By John Smith</p><p>A man was seen today.</p>',
             '<h1>Bird seen</h1><p>By John Smith</p><p>A bird was seen yesterday.</p>'],
            [[{'tag': 'h1', 'type': 'text', 'value': 'Man seen'}, {'tag': None, 'type': 'multitag', 'value': '<p>A man was seen today.</p>'}],
             [{'tag': 'h1', 'type': 'text', 'value': 'Bird seen'}, {'tag': None, 'type': 'multitag', 'value': '<p>A bird was seen yesterday.</p>'}]]
        )

    def test_same_level2(self):
        self.assertExtracts(
            ['<p>By John Smith</p><h1>Man seen</h1><p>A man was seen today.</p>',
             '<p>By John Smith</p><h1>Bird seen</h1><p>A bird was seen yesterday.</p>'],
            [[{'tag': 'h1', 'type': 'text', 'value': 'Man seen'}, {'tag': None, 'type': 'multitag', 'value': '<p>A man was seen today.</p>'}],
             [{'tag': 'h1', 'type': 'text', 'value': 'Bird seen'}, {'tag': None, 'type': 'multitag', 'value': '<p>A bird was seen yesterday.</p>'}]]
        )

    def test_same_level3(self):
        self.assertExtracts(
            ['<p>By John Smith</p><h1>Man seen</h1><p>A man was seen today.</p><p>The end.</p>',
             '<p>By John Smith</p><h1>Bird seen</h1><p>A bird was seen yesterday.</p><p>The end.</p>'],
            [[{'tag': 'h1', 'type': 'text', 'value': 'Man seen'}, {'tag': None, 'type': 'multitag', 'value': '<p>A man was seen today.</p>'}],
             [{'tag': 'h1', 'type': 'text', 'value': 'Bird seen'}, {'tag': None, 'type': 'multitag', 'value': '<p>A bird was seen yesterday.</p>'}]]
        )

    def test_confusing1(self):
        self.assertExtracts(
            ['<ul>\n\t\t<li></li>\n\t\t<li></li>\n\t\t<li class="current"></li>\n\t\t<li></li>\n\t</ul>',
             '<ul>\n\t\t<li class="current"></li>\n\t\t<li></li>\n\t\t<li></li>\n\t\t<li></li>\n\t</ul>',
             '<ul>\n\t\t<li></li>\n\t\t<li class="current"></li>\n\t\t<li></li>\n\t\t<li></li>\n\t</ul>'],
            [[{'tag': None, 'type': 'multitag', 'value': ''},
              {'tag': None, 'type': 'multitag', 'value': ''},
              {'tag': None, 'type': 'multitag', 'value': '<li class="current">\n\t\t'}],
             [{'tag': None, 'type': 'multitag', 'value': '<li class="current">\n\t\t'},
              {'tag': None, 'type': 'multitag', 'value': ''},
              {'tag': None, 'type': 'multitag', 'value': ''}],
             [{'tag': None, 'type': 'multitag', 'value': ''},
              {'tag': None, 'type': 'multitag', 'value': '<li class="current">\n\t\t'},
              {'tag': None, 'type': 'multitag', 'value': ''}]]
        )

    def test_confusing2(self):
        self.assertExtracts(
            ['<a>Test</a><hr><a>Foo</a> | <a>Bar</a>',
              '<b>bold:</b> <a>link1</a><input><a>link2</a>'],
            [[{'tag': None, 'type': 'multitag', 'value': ''},
              {'tag': 'a', 'type': 'text', 'value': 'Test'},
              {'tag': None, 'type': 'multitag', 'value': '<hr>'},
              {'tag': 'a', 'type': 'text', 'value': 'Foo'},
              {'tag': 'body', 'type': 'tail', 'value': ' | '},
              {'tag': None, 'type': 'multitag', 'value': '<a>Bar</a>'}],
             [{'tag': None, 'type': 'multitag', 'value': '<b>bold:</b> '},
              {'tag': 'a', 'type': 'text', 'value': 'link1'},
              {'tag': None, 'type': 'multitag', 'value': '<input>'},
              {'tag': 'a', 'type': 'text', 'value': 'link2'},
              {'tag': 'body', 'type': 'tail', 'value': None},
              {'tag': None, 'type': 'multitag', 'value': ''}]]
        )

    def test_mixed1(self):
        self.assertExtracts(
            ['<h1>Headline</h1><p>This thing</p><br/><div id="footer">Copyright 2006</div>',
             '<h1>Headline 2</h1><p id="first">This thing</p><br/><div id="footer">Copyright 2007</div>'],
            [[{'type': 'text', 'value': 'Headline', 'tag': 'h1'}, {'type': 'attrib', 'value': '', 'tag': 'p'}, {'type': 'multitag', 'value': '<br><div id="footer">Copyright 2006</div>', 'tag': None}],
             [{'type': 'text', 'value': 'Headline 2', 'tag': 'h1'}, {'type': 'attrib', 'value': 'first', 'tag': 'p'}, {'type': 'multitag', 'value': '<br><div id="footer">Copyright 2007</div>', 'tag': None}]]
        )

    def test_comments_ignored1(self):
        self.assertExtracts(
            ['<h1><!-- comment --></h1>', '<h1></h1>'],
            [[], []]
        )

    def test_comments_ignored2(self):
        self.assertExtracts(
            ['<h1>A<!-- comment --></h1>', '<h1>A</h1>'],
            [[], []]
        )

    def test_comments_ignored3(self):
        self.assertExtracts(
            ['<h1><!-- comment -->A</h1>', '<h1>A</h1>'],
            [[], []]
        )

    def test_comments_ignored4(self):
        self.assertExtracts(
            ['<h1>A<!-- comment -->B</h1>', '<h1>AB</h1>'],
            [[], []]
        )

    def test_comments_ignored5(self):
        self.assertExtracts(
            ['<h1>Title <!-- foo -->here</h1>', '<h1>Title here</h1>'],
            [[], []]
        )

    def test_comments_ignored6(self):
        self.assertExtracts(
            ['<h1>Title <!-- foo -->here</h1><!--<p>nothing</p>--><p><!--foo-->Paragraph here</p>',
             '<h1>Title here</h1><p>Paragraph here</p>'],
            [[], []]
        )

    def test_nomatch_texthole1(self):
        self.assertNoMatch(
            ['<h1>test</h1>', '<h1>test</h1>'],
            '<h1>bar</h1>',
        )

    def test_nomatch_texthole2(self):
        self.assertNoMatch(
            ['<h1>test</h1><p>Foo</p>', '<h1>test</h1><p>Bar</p>'],
            '<h1>bar</h1><p>Foo</p>',
        )

    def test_nomatch_multitaghole1(self):
        self.assertNoMatch(
            ['<div><p>1</p><p>2</p></div>', '<div><p>1</p><p>2</p></div>'],
            '<div><p>1</p><p>2</p><p>3</p></div>'
        )

    def test_nomatch_tailhole1(self):
        self.assertNoMatch(
            ['<p>This is <b>bolded</b>, right?</p>', '<p>This is <b>bolded</b>, right?</p>'],
            '<p>This is <b>bolded</b>, no?</p>'
        )

    def test_namespaced1(self): 
        self.assertExtracts( 
            ['<h1 foo:bar="ignore">Headline</h1>', '<h1>Different</h1>'], 
            [[{'type': 'text', 'value': 'Headline', 'tag': 'h1'}],
             [{'type': 'text', 'value': 'Different', 'tag': 'h1'}]] 
        ) 

    def test_namespaced2(self): 
        self.assertExtracts( 
            ['<h1>Headline</h1>', '<h1 foo:bar="ignore">Different</h1>'], 
            [[{'type': 'text', 'value': 'Headline', 'tag': 'h1'}],
             [{'type': 'text', 'value': 'Different', 'tag': 'h1'}]] 
        ) 

    def test_namespaced3(self): 
        self.assertExtracts( 
            ['<h1 foo:bar="ignore">Headline</h1>', '<h1 foo:bar="ignore">Different</h1>'], 
            [[{'type': 'text', 'value': 'Headline', 'tag': 'h1'}],
             [{'type': 'text', 'value': 'Different', 'tag': 'h1'}]] 
        ) 

    def test_namespaced4(self): 
        self.assertExtracts( 
            ['<h1 foo:bar="ignore" class="red">Headline</h1>', '<h1 foo:bar="ignore">Different</h1>'], 
            [[{'type': 'attrib', 'value': 'red', 'tag': 'h1'}, {'type': 'text', 'value': 'Headline', 'tag': 'h1'}],
             [{'type': 'attrib', 'value': '', 'tag': 'h1'}, {'type': 'text', 'value': 'Different', 'tag': 'h1'}]] 
        ) 

class TemplateExtractionTestCaseAlgorithm2(TemplateExtractionTestCaseAlgorithm1):
    algorithm = 2

    def test_texthole3(self):
        self.assertExtracts(
            ['<h1>Headline</h1><p>Para</p><p>Final</p>', '<h1>Different</h1><p>Para</p><p>Diff</p>'],
            [[{'tag': 'h1', 'type': 'text', 'value': 'Headline'},
              {'tag': 'p', 'type': 'text', 'value': 'Final'}],
             [{'tag': 'h1', 'type': 'text', 'value': 'Different'},
              {'tag': 'p', 'type': 'text', 'value': 'Diff'}]]
        )

    def test_multitaghole1(self):
        self.assertExtracts(
            ['<div><p>Yes</p><p>No</p></div>', '<div><p>Yes</p><p>No</p><p>Maybe</p></div>'],
            [[{'tag': None, 'type': 'multitag', 'value': '<p>Yes</p><p>No</p>'}],
             [{'tag': None, 'type': 'multitag', 'value': '<p>Yes</p><p>No</p><p>Maybe</p>'}]]
        )

    def test_multitaghole2(self):
        self.assertExtracts(
            ['<div>Text <p>Yes</p><p>No</p></div>', '<div>Text <p>Yes</p><p>No</p><p>Maybe</p></div>'],
            [[{'tag': None, 'type': 'multitag', 'value': '<p>Yes</p><p>No</p>'}],
             [{'tag': None, 'type': 'multitag', 'value': '<p>Yes</p><p>No</p><p>Maybe</p>'}]]
        )

    def test_multitaghole3(self):
        self.assertExtracts(
            ['<div><p>Yes</p><p>No</p> Tail</div>',
             '<div><p>Yes</p><p>No</p><p>Maybe</p> Tail</div>'],
            [[{'tag': None, 'type': 'multitag', 'value': '<p>Yes</p><p>No</p> Tail'}],
             [{'tag': None, 'type': 'multitag', 'value': '<p>Yes</p><p>No</p><p>Maybe</p> Tail'}]]
        )

    def test_multitaghole5(self):
        self.assertExtracts(
            ['<div><p>Yes</p><p>No</p></div>', '<div><p>Yes</p><p>Bar</p><p>Maybe</p></div>'],
            [[{'tag': None, 'type': 'multitag', 'value': '<p>Yes</p><p>No</p>'}],
             [{'tag': None, 'type': 'multitag', 'value': '<p>Yes</p><p>Bar</p><p>Maybe</p>'}]]
        )

    def test_multitaghole6(self):
        self.assertExtracts(
            ['<div><p>Yes</p><p>No</p></div>', '<div><p>Yes</p><p id="test">No</p><p>Maybe</p></div>'],
            [[{'tag': None, 'type': 'multitag', 'value': '<p>Yes</p><p>No</p>'}],
             [{'tag': None, 'type': 'multitag', 'value': '<p>Yes</p><p id="test">No</p><p>Maybe</p>'}]]
        )

    def test_same_level1(self):
        self.assertExtracts(
            ['<h1>Man seen</h1><p>By John Smith</p><p>A man was seen today.</p>',
             '<h1>Bird seen</h1><p>By John Smith</p><p>A bird was seen yesterday.</p>'],
            [[{'tag': 'h1', 'type': 'text', 'value': 'Man seen'},
              {'tag': 'p', 'type': 'text', 'value': 'A man was seen today.'}],
             [{'tag': 'h1', 'type': 'text', 'value': 'Bird seen'},
              {'tag': 'p', 'type': 'text', 'value': 'A bird was seen yesterday.'}]]
        )

    def test_same_level2(self):
        self.assertExtracts(
            ['<p>By John Smith</p><h1>Man seen</h1><p>A man was seen today.</p>',
             '<p>By John Smith</p><h1>Bird seen</h1><p>A bird was seen yesterday.</p>'],
            [[{'tag': 'h1', 'type': 'text', 'value': 'Man seen'},
              {'tag': 'p', 'type': 'text', 'value': 'A man was seen today.'}],
             [{'tag': 'h1', 'type': 'text', 'value': 'Bird seen'},
              {'tag': 'p', 'type': 'text', 'value': 'A bird was seen yesterday.'}]]
        )

    def test_same_level3(self):
        self.assertExtracts(
            ['<p>By John Smith</p><h1>Man seen</h1><p>A man was seen today.</p><p>The end.</p>',
             '<p>By John Smith</p><h1>Bird seen</h1><p>A bird was seen yesterday.</p><p>The end.</p>'],
            [[{'tag': 'h1', 'type': 'text', 'value': 'Man seen'},
              {'tag': 'p', 'type': 'text', 'value': 'A man was seen today.'}],
             [{'tag': 'h1', 'type': 'text', 'value': 'Bird seen'},
              {'tag': 'p', 'type': 'text', 'value': 'A bird was seen yesterday.'}]]
        )

    def test_confusing1(self):
        self.assertExtracts(
            ['<ul>\n\t\t<li></li>\n\t\t<li></li>\n\t\t<li class="current"></li>\n\t\t<li></li>\n\t</ul>',
             '<ul>\n\t\t<li class="current"></li>\n\t\t<li></li>\n\t\t<li></li>\n\t\t<li></li>\n\t</ul>',
             '<ul>\n\t\t<li></li>\n\t\t<li class="current"></li>\n\t\t<li></li>\n\t\t<li></li>\n\t</ul>'],
            [[{'tag': 'li', 'type': 'attrib', 'value': ''},
              {'tag': 'li', 'type': 'attrib', 'value': ''},
              {'tag': 'li', 'type': 'attrib', 'value': 'current'}],
             [{'tag': 'li', 'type': 'attrib', 'value': 'current'},
              {'tag': 'li', 'type': 'attrib', 'value': ''},
              {'tag': 'li', 'type': 'attrib', 'value': ''}],
             [{'tag': 'li', 'type': 'attrib', 'value': ''},
              {'tag': 'li', 'type': 'attrib', 'value': 'current'},
              {'tag': 'li', 'type': 'attrib', 'value': ''}]]
        )

    def test_confusing2(self):
        self.assertExtracts(
            ['<a>Test</a><hr><a>Foo</a> | <a>Bar</a>',
              '<b>bold:</b> <a>link1</a><input><a>link2</a>'],
            [[{'tag': None, 'type': 'multitag', 'value': '<a>Test</a><hr/><a>Foo</a> | <a>Bar</a>'}],
             [{'tag': None, 'type': 'multitag', 'value': '<b>bold:</b> <a>link1</a><input/><a>link2</a>'}]]
        )

    def test_mixed1(self):
        self.assertExtracts(
            ['<h1>Headline</h1><p>This thing</p><br/><div id="footer">Copyright 2006</div>',
             '<h1>Headline 2</h1><p id="first">This thing</p><br/><div id="footer">Copyright 2007</div>'],
            [[{'tag': 'h1', 'type': 'text', 'value': 'Headline'},
              {'tag': 'p', 'type': 'attrib', 'value': ''},
              {'tag': 'div', 'type': 'text', 'value': 'Copyright 2006'}],
             [{'tag': 'h1', 'type': 'text', 'value': 'Headline 2'},
              {'tag': 'p', 'type': 'attrib', 'value': 'first'},
              {'tag': 'div', 'type': 'text', 'value': 'Copyright 2007'}]]
        )

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = template
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

import unittest
from ebdata.templatemaker import Template, NoMatch
from ebdata.templatemaker.brain import Brain
from ebdata.templatemaker.hole import Hole

class TemplatemakerTestCase(unittest.TestCase):
    def create_the_long_way(self, *inputs):
        """
        "Helper method that returns a Template with the given inputs.
        """
        t = Template()
        for i in inputs:
            t.learn(i)
        return t

    def create_the_short_way(self, *inputs):
        t = Template()
        t.learn(*inputs)
        return t

    def assertCreated(self, expected, *inputs):
        """
        Asserts that a Template with the given inputs would be
        rendered as_text('!') to the expected string.
        """
        t1 = self.create_the_long_way(*inputs)
        t2 = self.create_the_short_way(*inputs)
        self.assertEqual(t1.as_text('!'), expected)
        self.assertEqual(t2.as_text('!'), expected)

class TemplatemakerExtractTestCase(unittest.TestCase):
    """
    This class' tests assume that self.setUp() creates self.template.
    """
    def assertExtracts(self, text, expected):
        """
        Asserts that self.template.extract(text) returns expected.
        """
        self.assertEqual(self.template.extract(text), expected)

    def assertNoMatch(self, text):
        """
        Asserts that self.template.extract(text) raises NoMatch.
        """
        self.assertRaises(NoMatch, self.template.extract, text)

class Creation(TemplatemakerTestCase):
    def test_noop1(self):
        self.assertCreated('<title>123</title>', '<title>123</title>')

    def test_noop2(self):
        self.assertCreated('<title>123</title>', '<title>123</title>', '<title>123</title>')

    def test_noop3(self):
        self.assertCreated('<title>123</title>', '<title>123</title>', '<title>123</title>', '<title>123</title>')

    def test_one_char_start1(self):
        self.assertCreated('!2345', '12345', '_2345')

    def test_one_char_start2(self):
        self.assertCreated('!2345', '12345', '12345', '_2345')

    def test_one_char_start3(self):
        self.assertCreated('!2345', '12345', '_2345', '^2345')

    def test_one_char_end1(self):
        self.assertCreated('1234!', '12345', '1234_')

    def test_one_char_end2(self):
        self.assertCreated('1234!', '12345', '12345', '1234_')

    def test_one_char_end3(self):
        self.assertCreated('1234!', '12345', '1234_', '1234^')

    def test_one_char_middle1(self):
        self.assertCreated('12!45', '12345', '12_45')

    def test_one_char_middle2(self):
        self.assertCreated('12!45', '12345', '12345', '12_45')

    def test_one_char_middle3(self):
        self.assertCreated('12!45', '12345', '12_45', '12^45')

    def test_one_char_middle4(self):
        self.assertCreated('12!45', '12345', '1245')

    def test_multi_char_start1(self):
        self.assertCreated('!345', '12345', '_2345', '1_345')

    def test_multi_char_start2(self):
        self.assertCreated('!345', '12345', '1_345', '_2345')

    def test_multi_char_start3(self):
        self.assertCreated('!45', '12345', '_2345', '1_345', '12_45')

    def test_multi_char_start4(self):
        self.assertCreated('!5', '12345', '_2345', '1_345', '12_45', '123_5')

    def test_multi_char_end1(self):
        self.assertCreated('1234!', '12345', '1234_')

    def test_multi_char_end2(self):
        self.assertCreated('123!', '12345', '1234_', '123_5')

    def test_multi_char_end3(self):
        self.assertCreated('12!', '12345', '1234_', '123_5', '12_45')

    def test_multi_char_end4(self):
        self.assertCreated('1!', '12345', '1234_', '123_5', '12_45', '1_345')

    def test_empty(self):
        self.assertCreated('', '', '')

    def test_no_similarities1(self):
        self.assertCreated('!', 'a', 'b')

    def test_no_similarities2(self):
        self.assertCreated('!', 'ab', 'ba', 'ac', 'bc')

    def test_no_similarities3(self):
        self.assertCreated('!', 'abc', 'ab_', 'a_c', '_bc')

    def test_left_weight1(self):
        self.assertCreated('!a!', 'ab', 'ba') # NOT '!b!'

    def test_left_weight2(self):
        self.assertCreated('a!b!', 'abc', 'acb')

    def test_multihole1(self):
        self.assertCreated('!2!', '123', '_23', '12_')

    def test_multihole2(self):
        self.assertCreated('!2!4!', '12345', '_2_4_')

    def test_multihole3(self):
        self.assertCreated('!2!4!', '12345', '_2345', '12_45', '1234_')

    def test_multihole4(self):
        self.assertCreated('!2!456!8', '12345678', '_2_456_8')

    def test_multihole5(self):
        self.assertCreated('!2!456!8', '12345678', '_2345678', '12_45678', '123456_8')

    def test_multihole6(self):
        self.assertCreated('!e! there', 'hello there', 'goodbye there')

class ExtractNoHoles(TemplatemakerExtractTestCase):
    def setUp(self):
        self.template = Template(Brain(['hello']))

    def test_extracts_nothing(self):
        self.assertExtracts('hello', ())

    def test_no_match_empty(self):
        self.assertNoMatch('')

    def test_no_match_case_sensitive1(self):
        self.assertNoMatch('Hello')

    def test_no_match_case_sensitive2(self):
        self.assertNoMatch('HELLO')

    def test_no_match_invalid(self):
        self.assertNoMatch('goodbye')

    def test_no_match_spaces1(self):
        self.assertNoMatch('hello ')

    def test_no_match_spaces2(self):
        self.assertNoMatch(' hello')

    def test_no_match_spaces3(self):
        self.assertNoMatch(' hello ')

class ExtractOneHole(TemplatemakerExtractTestCase):
    def setUp(self):
        self.template = Template(Brain(['Hello, ', Hole(), '. How are you?']))

    def test_one_word(self):
        self.assertExtracts('Hello, Picasso. How are you?', ('Picasso',))

    def test_two_words(self):
        self.assertExtracts('Hello, Michael Jordan. How are you?', ('Michael Jordan',))

    def test_three_words(self):
        self.assertExtracts('Hello, Frank Lloyd Wright. How are you?', ('Frank Lloyd Wright',))

    def test_period(self):
        self.assertExtracts('Hello, Richard J. Daley. How are you?', ('Richard J. Daley',))

    def test_empty_value(self):
        self.assertExtracts('Hello, . How are you?', ('',))

    def test_no_match_empty(self):
        self.assertNoMatch('')

    def test_no_match_case_sensitive(self):
        self.assertNoMatch('hello, friend. how are you?')

    def test_no_match_invalid(self):
        self.assertNoMatch('foo')

    def test_no_match_slightly_off1(self):
        self.assertNoMatch('Hello, friend.')

    def test_no_match_slightly_off2(self):
        self.assertNoMatch('Hello. How are you?')

    def test_no_match_slightly_off3(self):
        self.assertNoMatch('Hello friend. How are you?') # No comma

class ExtractTwoHoles(TemplatemakerExtractTestCase):
    def setUp(self):
        self.template = Template(Brain(['<p>', Hole(), ' and ', Hole(), '</p>']))

    def test_basic1(self):
        self.assertExtracts('<p>this and that</p>', ('this', 'that'))

    def test_basic2(self):
        self.assertExtracts('<p>foo and bar</p>', ('foo', 'bar'))

    def test_multiple_ands(self):
        self.assertExtracts('<p>and and and</p>', ('and', 'and'))

    def test_spaces1(self):
        self.assertExtracts('<p> this  and  that </p>', (' this ', ' that '))

    def test_spaces2(self):
        self.assertExtracts('<p>  and  </p>', (' ', ' '))

    def test_dots(self):
        self.assertExtracts('<p>. and .</p>', ('.', '.'))

    def test_question_marks(self):
        self.assertExtracts('<p>? and ?</p>', ('?', '?'))

    def test_empty_values(self):
        self.assertExtracts('<p> and </p>', ('', ''))

    def test_one_empty_value_first(self):
        self.assertExtracts('<p> and that</p>', ('', 'that'))

    def test_one_empty_value_second(self):
        self.assertExtracts('<p>this and </p>', ('this', ''))

    def test_no_match_empty(self):
        self.assertNoMatch('')

    def test_no_match_case_sensitive(self):
        self.assertNoMatch('<P>this and that</P>')

    def test_no_match_invalid(self):
        self.assertNoMatch('foo')

    def test_no_match_slightly_off1(self):
        self.assertNoMatch('this and that')

    def test_no_match_slightly_off2(self):
        self.assertNoMatch('<p></p>')

    def test_no_match_slightly_off3(self):
        self.assertNoMatch('<p>and</p>')

class ExtractWithHoleAtStart(TemplatemakerExtractTestCase):
    def setUp(self):
        self.template = Template(Brain([Hole(), ' and bar']))

    def test_basic(self):
        self.assertExtracts('foo and bar', ('foo',))

    def test_and(self):
        self.assertExtracts('and and bar', ('and',))

    def test_empty_value(self):
        self.assertExtracts(' and bar', ('',))

    def test_space_value(self):
        self.assertExtracts('  and bar', (' ',))

    def test_large(self):
        self.assertExtracts('This and that and this and that and bar', ('This and that and this and that',))

    def test_no_match_empty(self):
        self.assertNoMatch('')

    def test_no_match_case_sensitive(self):
        self.assertNoMatch('foo AND BAR')

    def test_no_match_invalid(self):
        self.assertNoMatch('foo')

    def test_no_match_slightly_off1(self):
        self.assertNoMatch('foo and bar.')

    def test_no_match_slightly_off2(self):
        self.assertNoMatch('and bar')

    def test_no_match_slightly_off3(self):
        self.assertNoMatch('and bar ')

class ExtractWithHoleAtEnd(TemplatemakerExtractTestCase):
    def setUp(self):
        self.template = Template(Brain(['foo and ', Hole()]))

    def test_basic(self):
        self.assertExtracts('foo and bar', ('bar',))

    def test_and(self):
        self.assertExtracts('foo and and', ('and',))

    def test_empty_value(self):
        self.assertExtracts('foo and ', ('',))

    def test_space_value(self):
        self.assertExtracts('foo and  ', (' ',))

    def test_period(self):
        self.assertExtracts('foo and bar.', ('bar.',))

    def test_large(self):
        self.assertExtracts('foo and this and that and this and that', ('this and that and this and that',))

    def test_no_match_empty(self):
        self.assertNoMatch('')

    def test_no_match_case_sensitive(self):
        self.assertNoMatch('FOO AND bar')

    def test_no_match_invalid(self):
        self.assertNoMatch('foo')

    def test_no_match_slightly_off1(self):
        self.assertNoMatch('foo and')

    def test_no_match_slightly_off2(self):
        self.assertNoMatch(' foo and')

class Initialization(unittest.TestCase):
    def test_string(self):
        # If this fails due to eg. module renaming, you can recreate
        # correct output like: Brain([Hole(), 'abc', Hole()]).serialize()
        serialized = 'gAJjZWJkYXRhLnRlbXBsYXRlbWFrZXIuYnJhaW4KQnJhaW4KcQEpgXECKGNlYmRhdGEudGVtcGxh\ndGVtYWtlci5ob2xlCkhvbGUKcQMpgXEEfXEFYlUDYWJjcQZoAymBcQd9cQhiZX1xCWIu\n'
        t = Template(serialized)
        self.assertEqual(t.brain, [Hole(), 'abc', Hole()])

    def test_brain(self):
        t = Template(brain=[Hole(), 'abc', Hole()])
        self.assertEqual(t.brain, [Hole(), 'abc', Hole()])

    def test_none(self):
        t = Template(brain=None)
        self.assertEqual(t.brain, None)

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = textlist
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.templatemaker.textlist import html_to_paragraph_list
from ebdata.textmining.treeutils import make_tree
import unittest

class AutoTextMetaclass(type):
    """
    Metaclass that adds a test method for every pair in TEST_DATA.
    """
    def __new__(cls, name, bases, attrs):
        TEST_DATA = (
            # input, expected output
            ('hello', ['hello']),
            ('hello\nthere', ['hello there']),
            ('hello\r\nthere', ['hello there']),

            ('<p>First</p><p>Second</p>', ['First', 'Second']),
            ('<p>First<p>Second</p>', ['First', 'Second']),
            ('First<p>Second</p>', ['First', 'Second']),
            ('First<p>Second', ['First', 'Second']),
            ('<p>First</p>Second', ['First', 'Second']),
            ('First</p>Second', ['First', 'Second']),
            ('First</p>Second</p>', ['First', 'Second']),
            ('First<p></p>Second', ['First', 'Second']),
            ('<p></p>First<p></p>Second', ['First', 'Second']),
            ('</p>First</p>Second', ['First', 'Second']),

            ('hello<br>there', ['hello', 'there']),
            ('hello<br>\nthere', ['hello', 'there']),
            ('hello<br><br>there', ['hello', 'there']),
            ('hello<br><br><br>there', ['hello', 'there']),
            ('hello<br><br><br><br>there', ['hello', 'there']),

            ('<p>hello<br>there</p>', ['hello', 'there']),
            ('<p>hello</p><br><p>there</p>', ['hello', 'there']),
            ('hello<br><p>there</p>', ['hello', 'there']),
            ('hello<br><p>there</p>', ['hello', 'there']),
        )
        def make_test_func(html, expected):
            return lambda self: self.assertConverts(html, expected)
        for i, (html, expected) in enumerate(TEST_DATA):
            func = make_test_func(html, expected)
            func.__doc__ = repr(html)
            attrs['test_%03d' % i] = func # Use '%03d' to make tests run in order, because unittest uses string ordering.
        return type.__new__(cls, name, bases, attrs)

class LocationTestCase(unittest.TestCase):
    __metaclass__ = AutoTextMetaclass

    def assertConverts(self, html, expected):
        self.assertEqual(html_to_paragraph_list(make_tree(html)), expected)

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = webmining
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.templatemaker.webmining import mine_page
import unittest

class MinePageTestCase(unittest.TestCase):
    def assertMines(self, html, others, expected):
        """
        Asserts that the given HTML strings will produce a tree_diff of the
        expected HTML string.
        """
        got = mine_page(html, others)
        self.assertEqual(got, expected)

    def test_basic(self):
        self.assertMines(
            '<h1>Bird flies</h1>',
            ['<h1>Man walks</h1>'],
            ['Bird flies']
        )

    def test_convert_newlines(self):
        self.assertMines(
            '<p>The person\nfell down the stairs.</p>',
            ['<p>Foo</p>'],
            ['<p>The person fell down the stairs.</p>']
        )

    def test_convert_tabs(self):
        self.assertMines(
            '<p>The person\tfell down the stairs.</p>',
            ['<p>Foo</p>'],
            ['<p>The person fell down the stairs.</p>']
        )

    def test_convert_nbsp1(self):
        self.assertMines(
            '<p>The person&nbsp;fell down the stairs.</p>',
            ['<p>Foo</p>'],
            ['<p>The person fell down the stairs.</p>']
        )

    def test_convert_nbsp2(self):
        self.assertMines(
            '<p>The person&#160;fell down the stairs.</p>',
            ['<p>Foo</p>'],
            ['<p>The person fell down the stairs.</p>']
        )

    def test_drop_nonalpha_lines1(self):
        self.assertMines(
            '<h1>-</h1>',
            ['<h1>??</h1>'],
            []
        )

    def test_drop_nonalpha_lines2(self):
        self.assertMines(
            '<h1>1</h1>',
            ['<h1>-</h1>'],
            ['1']
        )

    def test_drop_nonalpha_lines3(self):
        self.assertMines(
            '<h1><br>-</h1>',
            ['<h1><br>??</h1>'],
            []
        )

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = textlist
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.retrieval.utils import convert_entities
from lxml import etree
import re

def html_to_paragraph_list(tree):
    """
    Given an HTML tree, removes HTML tags and returns a list of strings, with
    each string representing a paragraph/block.
    """
    block_tags = set(['blockquote', 'dd', 'div', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'h7', 'h8', 'li', 'p', 'td', 'th', 'tr'])
    drop_tags_only = set(['a', 'abbr', 'acronym', 'b', 'center', 'dir', 'dl', 'em', 'font', 'form', 'hr', 'i', 'label', 'menu', 'ol', 'pre', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'tfoot', 'thead', 'topic', 'u', 'ul', 'wbr'])
    drop_tags_and_contents = set(['applet', 'area', 'button', 'embed', 'img', 'iframe', 'head', 'input', 'link', 'map', 'meta', 'noscript', 'object', 'option', 'script', 'select', 'spacer', 'style', 'textarea', 'title'])

    elements_to_drop = []
    for element in tree.getiterator():
        if not isinstance(element.tag, basestring): # If it's a comment...
            element.drop_tag()
            continue
        if element.text and '\n' in element.text:
            element.text = element.text.replace('\n', ' ')
        if element.tail and '\n' in element.tail:
            element.tail = element.tail.replace('\n', ' ')
        if element.tag in block_tags:
            element.text = '\n' + (element.text or '')
            element.tail = '\n' + (element.tail or '')
            element.drop_tag()
        elif element.tag == 'br':
            element.tail = '\n' + (element.tail or '')
            element.drop_tag()
        elif element.tag in drop_tags_only:
            element.drop_tag()
        elif element.tag in drop_tags_and_contents:
            elements_to_drop.append(element)
        elif element.tag not in ('html', 'body'): # Unknown tag!
            element.drop_tag()
    for e in elements_to_drop:
        e.drop_tree()

    try:
        tree.body
    except IndexError:
        return ''
    else:
        new_html = etree.tostring(tree.body, method='html')[6:-7] # strip <body> and </body>
        new_html = convert_entities(new_html)
        return re.split(r'\s*\n+\s*', new_html.strip())

########NEW FILE########
__FILENAME__ = webmining
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

from ebdata.templatemaker.htmlutils import remove_empty_tags, brs_to_paragraphs
from ebdata.templatemaker.sst import extract
from ebdata.textmining.treeutils import make_tree_and_preprocess, preprocess
from lxml import etree
import re

def mine_page(html, other_pages):
    result = []
    for hole in extract(html, other_pages):
        # Differences in attribute values aren't relevant.
        if hole['type'] == 'attrib' or not hole['value'] or not hole['value'].strip():
            continue

        # # Differences in links are likely navigation, and can be ignored.
        # if hole['type'] == 'text' and hole['tag'] == 'a':
        #     continue

        # If it's a multitag value, clean its HTML a bit.
        if hole['type'] == 'multitag':
            tree = make_tree_and_preprocess(hole['value'])

            # Drop a bunch of tags that can muck up the display.
            tree = preprocess(tree,
                drop_tags=('a', 'area', 'b', 'center', 'font', 'form', 'img', 'input', 'map', 'small', 'sub', 'sup', 'topic'),
                drop_trees=('applet', 'button', 'embed', 'iframe', 'object', 'select', 'textarea'),
                drop_attrs=('background', 'border', 'cellpadding', 'cellspacing', 'class', 'clear', 'id', 'rel', 'style', 'target'))

            remove_empty_tags(tree, ('br',))
            tree = brs_to_paragraphs(tree)

            # The [6:-7] cuts off the '<body>' and '</body>'.
            try:
                body = tree.body
            except IndexError:
                continue # lxml raises an IndexError if there's no <body>.

            # Skip bits that don't have at least one letter or number.
            # Note: If this code is ever internationalized, this will have to be
            # removed.
            if not re.search('[A-Za-z0-9]', body.text_content()):
                continue

            string = etree.tostring(body, method='html')[6:-7]
        else:
            string = hole['value']

            # Skip bits that don't have at least one letter or number.
            # Note: If this code is ever internationalized, this will have to be
            # removed.
            if not re.search('[A-Za-z0-9]', string):
                continue

        # Clean up newlines, tabs and &nbsp;.
        string = re.sub('[\n\t]', ' ', string.strip())
        string = string.replace('&nbsp;', ' ')
        string = string.replace('&#160;', ' ')

        result.append(string)
    return result

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

# There are no models, but `manage.py test` needs a models.py to find tests.

########NEW FILE########
__FILENAME__ = treeutils
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Unit tests for ebdata/textmining/treeutils.py
"""

from ebdata.textmining.treeutils import make_tree, preprocess
from lxml import etree
import unittest

class MakeTreeTestCase(unittest.TestCase):
    def assertMakeTree(self, html, expected):
        import warnings
        # Note, warnings.catch_warnings() should work but has no effect here?
        warnings.simplefilter('ignore', UnicodeWarning)
        got = etree.tostring(make_tree(html), method='html')
        self.assertEqual(got, expected)

    def test_basic1(self):
        self.assertMakeTree('<html><body><h1>Hello</h1></body></html>', '<html><body><h1>Hello</h1></body></html>')

    def test_lxml_magic_behavior(self):
        # lxml sometimes reorders elements, depending on whether they're
        # block/inline.
        self.assertMakeTree('<html><body><h1><p><span>Hello</span></p></h1></body></html>',
            '<html><body><h1></h1><p><span>Hello</span></p></body></html>')

    def test_empty1(self):
        self.assertMakeTree('<html></html>', '<html></html>')

    def test_empty2(self):
        self.assertMakeTree('<html><body></body></html>', '<html><body></body></html>')

    def test_newlines(self):
        self.assertMakeTree('<html><body>\r\n\r\n\r\n</body></html>', '<html><body>\n\n\n</body></html>')

    def test_unicode_xml_declaration(self):
        self.assertMakeTree(u'<?xml version="1.0" encoding="utf-8"?><html><body><h1>Hello</h1></body></html>', '<html><body><h1>Hello</h1></body></html>')

class PreprocessTestCase(unittest.TestCase):
    def assertPreprocesses(self, html, expected, **kwargs):
        import warnings
        with warnings.catch_warnings():
            tree = make_tree(html)
            got = etree.tostring(preprocess(tree, **kwargs), method='html')
            self.assertEqual(got, expected)

    def test_comment1(self):
        self.assertPreprocesses('<html><body><!-- comment --></body></html>', '<html><body></body></html>')

    def test_comment2(self):
        self.assertPreprocesses('<html><body> <!--\n comment\n --> </body></html>', '<html><body>  </body></html>')

    def test_comment3(self):
        self.assertPreprocesses('<html><body> <!-- <p>Test</p> --> </body></html>', '<html><body>  </body></html>')

    def test_comment4(self):
        self.assertPreprocesses('<html><body> <!-- <p>Test</p> --> <!-- <p>Again</p> --> </body></html>', '<html><body>   </body></html>')

    def test_style1(self):
        self.assertPreprocesses('<html><head><style type="text/css">\n#foo { font: 11px verdana,sans-serif; }\n</style></head><body>Hi</body></html>', '<html><head></head><body>Hi</body></html>')

    def test_link1(self):
        self.assertPreprocesses('<html><head><link rel="stylesheet" src="/style.css"></head><body>Hi</body></html>', '<html><head></head><body>Hi</body></html>')

    def test_meta1(self):
        self.assertPreprocesses('<html><head><meta name="robots" content="noarchive"></head><body>Hi</body></html>', '<html><head></head><body>Hi</body></html>')

    def test_script1(self):
        self.assertPreprocesses('<html><head><script type="text/javascript">alert("hello");</script></head><body>Hi</body></html>', '<html><head></head><body>Hi</body></html>')

    def test_noscript1(self):
        self.assertPreprocesses('<html><body>Hi <noscript>You have no JavaScript</noscript> </body></html>', '<html><body>Hi  </body></html>')

    def test_droptags1(self):
        self.assertPreprocesses('<html><body><h1>Hello</h1></body></html>', '<html><body><h1>Hello</h1></body></html>')
        self.assertPreprocesses('<html><body><h1>Hello</h1></body></html>', '<html><body>Hello</body></html>', drop_tags=('h1',))

    def test_droptags2(self):
        self.assertPreprocesses('<html><body><div><p>Hello</p></div></body></html>', '<html><body><div><p>Hello</p></div></body></html>')
        self.assertPreprocesses('<html><body><div><p>Hello</p></div></body></html>', '<html><body><p>Hello</p></body></html>', drop_tags=('div',))
        self.assertPreprocesses('<html><body><div><p>Hello</p></div></body></html>', '<html><body><div>Hello</div></body></html>', drop_tags=('p',))

    def test_droptrees1(self):
        self.assertPreprocesses('<html><body><h1>Hello</h1></body></html>', '<html><body><h1>Hello</h1></body></html>')
        self.assertPreprocesses('<html><body><h1>Hello</h1></body></html>', '<html><body></body></html>', drop_trees=('h1',))

    def test_droptrees3(self):
        self.assertPreprocesses('<html><body><div><p>Hello</p></div></body></html>', '<html><body><div><p>Hello</p></div></body></html>')
        self.assertPreprocesses('<html><body><div><p>Hello</p></div></body></html>', '<html><body></body></html>', drop_trees=('div',))

    def test_droptrees4(self):
        self.assertPreprocesses('<html><body><div><p><span>Hello</span></p></div></body></html>', '<html><body><div><p><span>Hello</span></p></div></body></html>')
        self.assertPreprocesses('<html><body><div><p><span>Hello</span></p></div></body></html>', '<html><body></body></html>', drop_trees=('div',))

    def test_dropattrs(self):
        self.assertPreprocesses('<html><body><div id="foo" class="bar">Hi</div></body></html>', '<html><body><div id="foo" class="bar">Hi</div></body></html>')
        self.assertPreprocesses('<html><body><div id="foo" class="bar">Hi</div></body></html>', '<html><body><div class="bar">Hi</div></body></html>', drop_attrs=('id',))

    def test_drop_namespaced_attrs1(self):
        self.assertPreprocesses('<html><body><div dc:foo="foo">Hi</div></body></html>', '<html><body><div>Hi</div></body></html>')

    def test_drop_namespaced_attrs2(self):
        self.assertPreprocesses('<html><body><div dc:foo="foo" id="bar">Hi</div></body></html>', '<html><body><div id="bar">Hi</div></body></html>')

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = treeutils
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Common utilities for creating and cleaning lxml HTML trees.
"""

from lxml.etree import ElementTree, Element
from lxml.html import document_fromstring
import lxml.html.soupparser
import re
from ebdata.retrieval.utils import convert_entities
from BeautifulSoup import UnicodeDammit

def make_tree(html):
    """
    Returns an lxml tree for the given HTML string (either Unicode or
    bytestring).

    This is better than lxml.html.document_fromstring because this takes care
    of a few known issues.
    """
    # Normalize newlines. Otherwise, "\r" gets converted to an HTML entity
    # by lxml.
    html = re.sub('\r\n', '\n', html)

    # Remove <?xml> declaration in Unicode objects, because it causes an error:
    # "ValueError: Unicode strings with encoding declaration are not supported."
    # Note that the error only occurs if the <?xml> tag has an "encoding"
    # attribute, but we remove it in all cases, as there's no downside to
    # removing it.
    if isinstance(html, unicode):
        html = re.sub(r'^\s*<\?xml\s+.*?\?>', '', html)
    else:
        html = UnicodeDammit(html, isHTML=True).unicode
    html = html.strip()
    if html:
        try:
            return document_fromstring(html)
        except:
            # Fall back to using the (slow) BeautifulSoup parser.
            return lxml.html.soupparser.fromstring(html)
    else:
        root = Element('body')
        root.text = u''
        return ElementTree(root)


def make_tree_and_preprocess(html, *args, **kw):
    """
    Returns an lxml tree for the given HTML string (either Unicode or
    bytestring). Also preprocesses the HTML to remove data that isn't relevant
    to text mining (see the docstring for preprocess()).

    Extra args are passed to preprocess().
    """
    tree = make_tree(html)
    result = preprocess(tree, *args, **kw)
    return result

def preprocess_to_string(*args, **kw):
    """
    like make_tree_and_preprocess() but returns a string.
    """
    tree = make_tree_and_preprocess(*args, **kw)
    text = tree.findtext('body') or u''
    return text.strip()

def preprocess(tree, drop_tags=(), drop_trees=(), drop_attrs=()):
    """
    Preprocesses a HTML etree to remove data that isn't relevant to text mining.
    The tree is edited in place, but it's also the return value, for
    convenience.

    Specifically, this does the following:
        * Removes all comments and their contents.
        * Removes these tags and their contents:
            <style>, <link>, <meta>, <script>, <noscript>, plus all of drop_trees.
        * For all tags in drop_tags, removes the tags (but keeps the contents).
        * Removes all namespaced attributes in all elements.
    """
    tags_to_drop = set(drop_tags)
    trees_to_drop = set(['style', 'link', 'meta', 'script', 'noscript'])
    for tag in drop_trees:
        trees_to_drop.add(tag)

    elements_to_drop = []
    for element in tree.getiterator():
        if element.tag in tags_to_drop or not isinstance(element.tag, basestring): # If it's a comment...
            element.drop_tag()
        elif element.tag in trees_to_drop:
            elements_to_drop.append(element)
        for attname in element.attrib.keys():
            if ':' in attname or attname in drop_attrs:
                del element.attrib[attname]
    for e in elements_to_drop:
        e.drop_tree()
    return tree


def text_from_html(html):
    """Remove ALL tags and return all plain text.
    """
    text = preprocess_to_string(html, drop_tags=_html_droptags,
                                drop_trees=_html_droptrees)
    if not text:
        # Maybe there was something there but not really HTML.
        if text and not isinstance(text, unicode):
            text = UnicodeDammit(html, isHTML=False).unicode.strip()
        else:
            text = u''
    text = convert_entities(text)
    return text


# Note we leave body and html in because the code expects those.
_html_droptags = [
    'a',
    'abbr',
    'acronym',
    'address',
    'applet',
    'area',
    'b',
    'base',
    'basefont',
    'bdo',
    'big',
    'blockquote',
#    'body',
    'br',
    'button',
    'caption',
    'center',
    'cite',
    'code',
    'col',
    'colgroup',
    'dd',
    'del',
    'dfn',
    'dir',
    'div',
    'dl',
    'dt',
    'em',
    'fieldset',
    'font',
    'form',
    'frame',
    'frameset',
    'h1',
    'h2',
    'h3',
    'h4',
    'h5',
    'h6',
    'hr',
#    'html',
    'i',
    'iframe',
    'img',
    'input',
    'ins',
    'kbd',
    'label',
    'legend',
    'li',
    'link',
    'map',
    'menu',
    'noframes',
    'noscript',
    'object',
    'ol',
    'optgroup',
    'option',
    'p',
    'param',
    'pre',
    'q',
    's',
    'samp',
    'select',
    'small',
    'span',
    'strike',
    'strong',
    'sub',
    'sup',
    'table',
    'tbody',
    'td',
    'textarea',
    'tfoot',
    'th',
    'thead',
    'tr',
    'tt',
    'u',
    'ul',
    'var']

_html_droptrees = [
    'head',
    'script',
    'style',
    'title',
    'meta',
 ]

########NEW FILE########
__FILENAME__ = daemon
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

# The following is from http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/
# with slight formatting changes. The author of the code there has placed it in the public domain.

import atexit
import sys
import os
import time
from signal import SIGTERM
from optparse import OptionParser

class Daemon(object):
    """
    A generic daemon class.

    Usage: subclass the Daemon class and override the run() method
    """

    usage = "usage: %prog [options] start|stop|restart"

    def __init__(self, pidfile, stdin='/dev/null', stdout='/dev/null', stderr='/dev/null'):
        """
        pid file given is used by default unless overridden at the command line.
        """
        self.stdin = stdin
        self.stdout = stdout
        self.stderr = stderr
        self.pidfile = pidfile
        self.parser = OptionParser(usage=self.usage)
        self.parser.add_option("-D", "--debug",
                               help="run in debugging mode (run in the foreground)",
                               action="store_true", dest="debugging",
                               default=False)
        self.parser.add_option("-P", "--pid-file",
                               help='specify a particular pid file',
                               dest="pidfile", default=self.pidfile)

    def parse_args(self, argv):
        """Given sys.argv, parses the command-line arguments.
        """
        (self.options, self.args) = self.parser.parse_args(argv)
        self.pidfile = self.options.pidfile
        self.command = None
        if len(self.args) == 1:
            if self.args[0] in ('start', 'stop', 'restart'):
                self.command = self.args[0]
            else:
                self.parser.error("unknown command")
                sys.exit(2)
        else:
            self.parser.error("invalid command")
            sys.exit(2)

    def run_from_command_line(self, argv):
        """
        Parses arguments from argv and calls the appropriate method,
        failing appropriately in case of problems.
        """
        self.parse_args(argv)
        if self.command == 'start':
            self.start(self.options.debugging)
        elif self.command == 'stop':
            self.stop()
        elif self.command == 'restart':
            self.restart()
        else:
            raise RuntimeError("self.command is %s, shouldn't happen" % self.command)
        sys.exit(0)

    def daemonize(self):
        """
        Do the UNIX double-fork magic. See Stevens' "Advanced
        Programming in the UNIX Environment" for details (ISBN 0201563177)
        """
        try:
            pid = os.fork()
            if pid > 0:
                # Exit the first parent.
                sys.exit(0)
        except OSError, e:
            sys.stderr.write("fork #1 failed: %d (%s)\n" % (e.errno, e.strerror))
            sys.exit(1)

        # Decouple from the parent environment.
        os.chdir("/")
        os.setsid()
        os.umask(0)

        # Do the second fork.
        try:
            pid = os.fork()
            if pid > 0:
                # Exit from the second parent.
                sys.exit(0)
        except OSError, e:
            sys.stderr.write("fork #2 failed: %d (%s)\n" % (e.errno, e.strerror))
            sys.exit(1)

        # Redirect standard file descriptors. Because the daemon has no
        # controlling terminal, we want to avoid side effects from reading and
        # writing to/from the standard file descriptors.
        sys.stdout.flush()
        sys.stderr.flush()
        si = file(self.stdin, 'r')
        so = file(self.stdout, 'a+')
        se = file(self.stderr, 'a+', 0)
        # Use os.dup2() with the fileno() instead of assigning directly to
        # sys.stdout because the former will also affect any C-level sys.stdout
        # calls.
        os.dup2(si.fileno(), sys.stdin.fileno())  # Essentially: sys.stdin = si
        os.dup2(so.fileno(), sys.stdout.fileno()) # Essentially: sys.stdout = so
        os.dup2(se.fileno(), sys.stderr.fileno()) # Essentially: sys.stderr = se

        # Write the pidfile.
        atexit.register(self.delpid)
        pid = str(os.getpid())
        open(self.pidfile, 'w+').write("%s\n" % pid)

    def get_pid_from_file(self):
        "Returns the pid value from the file."
        try:
            pf = open(self.pidfile, 'r')
            pid = int(pf.read().strip())
            pf.close()
        except IOError:
            pid = None
        return pid

    def delpid(self):
        os.remove(self.pidfile)

    def start(self, debug=False):
        """
        Starts the daemon.
        """
        # Check for a pidfile to see whether the daemon is already running.
        if self.get_pid_from_file():
            sys.stderr.write("pidfile %s already exists. Is the daemon already running?\n" % self.pidfile)
            sys.exit(1)

        # Don't detach from foreground if debugging.
        if not debug:
            self.daemonize()
        # Start the daemon.
        self.run()

    def stop(self):
        """
        Stops the daemon.
        """
        # Get the pid from the pidfile.
        pid = self.get_pid_from_file()

        if not pid:
            sys.stderr.write("pidfile %s does not exist. Is the daemon not running?\n" % self.pidfile)
            return # not an error in a restart

        # Try killing the daemon process.
        try:
            while 1:
                os.kill(pid, SIGTERM)
                time.sleep(0.1)
        except OSError, err:
            err = str(err)
            if err.find("No such process") > 0:
                os.remove(self.pidfile)
            else:
                print str(err)
                sys.exit(1)

    def restart(self):
        """
        Restarts the daemon.
        """
        self.stop()
        self.start()

    def run(self):
        """
        The daemon's logic.

        Subclasses should override this method.
        """
        raise NotImplementedError()

########NEW FILE########
__FILENAME__ = export_newsitems
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Exports newsitems to a CSV file.
"""

from ebpub.db.models import NewsItem, Location, Schema
import sys
import csv
from optparse import OptionParser

def export_newsitems(queryset, schema, out):
    ni_fields = [('title', 'title'),
                 ('description', 'description'),
                 ('location_name', 'location'),
                 ('url', 'URL'),
                 ('item_date', 'item date'),
                 ('pub_date', 'publication date')]
    s_fields = [(str(sf.name), str(sf.pretty_name)) for sf in schema.schemafield_set.all()]
    s_fields.sort()
    writer = csv.writer(out)
    writer.writerow([f[1] for f in ni_fields + s_fields])
    for ni in queryset:
        values = [getattr(ni, f[0]) for f in ni_fields]
        values += [ni.attributes[f[0]] for f in s_fields]
        writer.writerow(values)

def main():
    parser = OptionParser(usage='usage: %prog [options] <schema-slug>')
    parser.add_option('-l', '--location', dest='loc_slug', metavar="SLUG",
                      help='limit newsitems to those contained by location')
    parser.add_option('-f', '--filename', dest='out_file', metavar="FILE",
                      help='write output to this filename')

    (options, args) = parser.parse_args()

    if not args:
        parser.error('must give a schema slug')

    try:
        schema = Schema.objects.get(slug=args[0])
    except Schema.DoesNotExist:
        parser.error('unknown schema %r' % args[0])
        return 1

    niqs = NewsItem.objects.filter(schema=schema)

    if options.loc_slug:
        try:
            loc = Location.objects.get(slug=options.loc_slug)
        except Location.DoesNotExist:
            parser.error('unknown location %r' % options.loc_slug)
            return 1
        else:
            niqs = niqs.filter(location__within=loc.location)

    if options.out_file:
        f = open(options.out_file, 'w')
    else:
        f = sys.stdout

    export_newsitems(niqs, schema, f)

if __name__ == '__main__':
    sys.exit(main())
    

########NEW FILE########
__FILENAME__ = admin
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib import admin
from ebpub.accounts.models import User
from ebpub.geoadmin import OSMModelAdmin
from ebpub.preferences.models import Profile
from ebpub.openblockapi.apikey.admin import ApiKeyForm, ApiKey

class ProfileInline(admin.StackedInline):
    model = Profile
    fk_name = 'user'
    can_delete = False
    verbose_name_plural = 'Profile'

class ApiKeyInline(admin.StackedInline):
    model = ApiKey
    form = ApiKeyForm
    fk_name = 'user'
    extra = 0

class UserAdmin(OSMModelAdmin):
    inlines = [
        ApiKeyInline,
        ProfileInline,
        ]

admin.site.register(User, UserAdmin)

########NEW FILE########
__FILENAME__ = callbacks
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

# This is a lightweight framework for passing events that need to happen
# when users log in successfully. For example, there's a way to specify that
# an e-mail alert should be created for a given user as soon as he logs in.

from django.utils import simplejson
from ebpub.alerts.models import EmailAlert
import datetime

###############
# SERIALIZING #
###############

# We store compressed JSON in the PendingUserAction table.

def serialize(data):
    return simplejson.dumps(data)

def unserialize(data):
    return simplejson.loads(data)

#############
# CALLBACKS #
#############

def do_callback(callback_name, user, data):
    # callback_name is a key in CALLBACKS.
    # serialized_data is an unserialized Python object.
    try:
        callback = CALLBACKS[callback_name]
    except KeyError:
        return None
    return callback(user, data)

def create_alert(user, data):
    EmailAlert.objects.create(
        user_id=user.id,
        block_center=data['block_center'],
        location_id=data['location_id'],
        frequency=data['frequency'],
        radius=data['radius'],
        include_new_schemas=data['include_new_schemas'],
        schemas=data['schemas'],
        signup_date=datetime.datetime.now(),
        cancel_date=None,
        is_active=True,
    )
    return "Your e-mail alert was created successfully. Thanks for signing up!"

CALLBACKS = {
    'createalert': create_alert,
}

########NEW FILE########
__FILENAME__ = constants
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

# The key used in request.session to represent the user's e-mail.
EMAIL_SESSION_KEY = 'email'

########NEW FILE########
__FILENAME__ = context_processors
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from constants import EMAIL_SESSION_KEY # relative import

def user(request):
    # Makes 'USER' and 'USER_EMAIL' available in templates.
    if request.user.is_anonymous():
        return {
            'DEBUG': settings.DEBUG,
            'USER': None,
            'USER_EMAIL': None,
            }
    else:
        return {
            'DEBUG': settings.DEBUG,
            'USER': request.user,
            'USER_EMAIL':  request.session.get(EMAIL_SESSION_KEY) or getattr(request.user, 'email', None),
            }

########NEW FILE########
__FILENAME__ = forms
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django import forms
from django.contrib.auth.forms import AuthenticationForm
from django.contrib.auth import authenticate
from ebpub.accounts.models import User

class UniqueEmailField(forms.EmailField):
    """
    Validates that the given value is an e-mail address and hasn't already
    been registered.
    """
    def clean(self, value):
        value = forms.EmailField.clean(self, value).lower() # Normalize to lowercase.
        if User.objects.filter(email=value).count():
            raise forms.ValidationError('This e-mail address is already registered.')
        return value

class EmailRegistrationForm(forms.Form):
    email = UniqueEmailField(label='Your e-mail address', widget=forms.TextInput(attrs={'size': 50}))

class BasePasswordForm(forms.Form):
    password1 = forms.CharField(label='Password', widget=forms.PasswordInput)
    password2 = forms.CharField(label='Password (again)', widget=forms.PasswordInput)

    def clean_password2(self):
        p1 = self.cleaned_data['password1']
        p2 = self.cleaned_data['password2']
        if p1 != p2:
            raise forms.ValidationError("The passwords didn't match! Try entering them again.")
        return p2

class PasswordRegistrationForm(BasePasswordForm):
    e = UniqueEmailField(widget=forms.HiddenInput)
    h = forms.CharField(widget=forms.HiddenInput)

class PasswordResetForm(BasePasswordForm):
    e = forms.EmailField(widget=forms.HiddenInput)
    h = forms.CharField(widget=forms.HiddenInput)

class PasswordResetRequestForm(forms.Form):
    email = forms.EmailField()

    def clean_email(self):
        email = self.cleaned_data['email'].lower()
        if not User.objects.filter(email=email).count():
            raise forms.ValidationError("This e-mail address isn't registered yet.")
        return email

class LoginForm(AuthenticationForm):
    """Login form that uses email instead of username.
    """

    email = forms.EmailField()

    def clean(self):
        # Note that because this is the form-wide clean() method, any
        # validation errors raised here will not be tied to a particular field.
        # Instead, use form.non_field_errors() in the template.
        email = self.cleaned_data.get('email')
        password = self.cleaned_data.get('password')

        # Check that both email and password were valid. If they're not valid,
        # there's no need to run the following bit of validation.
        if email and password:
            nonesuch = forms.ValidationError("That e-mail and password combo isn't valid. Note that the password is case-sensitive.") 
            user = User.objects.user_by_password(email.lower(), password)
            if user is None:
                raise nonesuch
            # Calling authenticate() queries the db again, but we call
            # it anyway because it has at least one important side
            # effect that we shouldn't have to duplicate.
            self.user_cache = authenticate(username=user.username, password=password)
            if self.user_cache is None:
                raise nonesuch
            elif not self.user_cache.is_active:
                raise forms.ValidationError("This account is inactive.")
            if not self.cleaned_data.get('username'):
                self.cleaned_data['username'] = self.user_cache.username
                self._errors.pop('username', None)

        self.check_for_test_cookie()
        return self.cleaned_data


class AdminLoginForm(LoginForm):
    """
    Login form that uses email instead of username, for accessing the admin site.
    """

    def clean(self):
        super(AdminLoginForm, self).clean()
        if not self.user_cache or not self.user_cache.is_active or not self.user_cache.is_staff:
            raise forms.ValidationError("Please enter a correct email address and password.")
        return self.cleaned_data


########NEW FILE########
__FILENAME__ = createsuperuser
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Management utility to create superusers for OpenBlock,
with email address instead of username.

In order for this to override the default createsuperuser command,
ebpub.accounts needs to be in INSTALLED_APPS later than
django.contrib.*.
"""

import getpass
import os
import re
import sys
from optparse import make_option
from ebpub.accounts.models import User
from django.core import exceptions
from django.core.management.base import BaseCommand, CommandError
from django.utils.translation import ugettext as _

EMAIL_RE = re.compile(
    r"(^[-!#$%&'*+/=?^_`{}|~0-9A-Z]+(\.[-!#$%&'*+/=?^_`{}|~0-9A-Z]+)*"  # dot-atom
    r'|^"([\001-\010\013\014\016-\037!#-\[\]-\177]|\\[\001-\011\013\014\016-\177])*"' # quoted-string
    r')@(?:[A-Z0-9-]+\.)+[A-Z]{2,6}$', re.IGNORECASE)  # domain

def is_valid_email(value):
    if not EMAIL_RE.search(value):
        raise exceptions.ValidationError(_('Enter a valid e-mail address.'))

class Command(BaseCommand):
    option_list = BaseCommand.option_list + (
        make_option('--email', dest='email', default=None,
            help='Specifies the email address for the superuser.'),
        make_option('--noinput', action='store_false', dest='interactive', default=True,
            help='Tells Django to NOT prompt the user for input of any kind. '    \
                 'You must use --email with --noinput, and '      \
                 'superusers created with --noinput will not be able to log in '  \
                 'until they\'re given a valid password.'),
    )
    help = 'Used to create a superuser.'

    def handle(self, *args, **options):
        email = options.get('email', None)
        interactive = options.get('interactive')
        
        # Do quick and dirty validation if --noinput
        if not interactive:
            if not email:
                raise CommandError("You must use --email with --noinput.")
            try:
                is_valid_email(email)
            except exceptions.ValidationError:
                raise CommandError("Invalid email address.")

        password = ''

        # Prompt for username/email/password. Enclose this whole thing in a
        # try/except to trap for a keyboard interrupt and exit gracefully.
        if interactive:
            try:
                # Get an email
                while 1:
                    if not email:
                        email = raw_input('E-mail address: ')
                    try:
                        is_valid_email(email)
                        try:
                            User.objects.get(email=email)
                        except User.DoesNotExist:
                            break
                        else:
                            sys.stderr.write("Error: That email address is already taken.\n")
                            email = None

                    except exceptions.ValidationError:
                        sys.stderr.write("Error: That e-mail address is invalid.\n")
                        email = None
                    else:
                        break

                # Get a password
                while 1:
                    if not password:
                        password = getpass.getpass()
                        password2 = getpass.getpass('Password (again): ')
                        if password != password2:
                            sys.stderr.write("Error: Your passwords didn't match.\n")
                            password = None
                            continue
                    if password.strip() == '':
                        sys.stderr.write("Error: Blank passwords aren't allowed.\n")
                        password = None
                        continue
                    break
            except KeyboardInterrupt:
                sys.stderr.write("\nOperation cancelled.\n")
                sys.exit(1)
        
        User.objects.create_superuser(email, password)
        print "Superuser created successfully."

########NEW FILE########
__FILENAME__ = middleware
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib import auth
from django.contrib.auth.models import User as BaseUser

UNDEFINED = 123

class LazyUser(BaseUser):
    # This class is a transparent wrapper around User that hits the database
    # only after an attribute is accessed.
    def __init__(self, user_id):
        self.user_id = user_id
        self._user_cache = UNDEFINED

    def __getattr__(self, name):
        # Optimization: There's no need to hit the database if we're just
        # getting the ID.
        if name == 'id':
            return self.user_id

        if self._user_cache == UNDEFINED:
            from ebpub.accounts.models import User
            try:
                self._user_cache = User.objects.get(id=self.user_id)
            except User.DoesNotExist:
                self._user_cache = None
        return getattr(self._user_cache, name)

    def get_profile(self):
        # For some reason this doesn't automatically work.
        func = self.__getattr__('get_profile')
        return func()

class LazyUserDescriptor(object):
    # This class uses a Python descriptor so that a LazyUser isn't
    # actually created until request.user is accessed.
    def __get__(self, request, obj_type=None):
        if not hasattr(request, '_cached_user'):
            try:
                user_id = request.session[auth.SESSION_KEY]
            except KeyError:
                from ebpub.accounts.models import AnonymousUser
                user = AnonymousUser()
            else:
                user = LazyUser(user_id)
            request._cached_user = user
        return request._cached_user

class UserMiddleware(object):
    def process_request(self, request):
        request.__class__.user = LazyUserDescriptor()
        return None

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'User'
        db.create_table('accounts_user', (
            ('user_ptr', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['auth.User'], unique=True, primary_key=True)),
            ('main_metro', self.gf('django.db.models.fields.CharField')(max_length=32)),
        ))
        db.send_create_signal('accounts', ['User'])

        # Adding model 'PendingUserAction'
        db.create_table('accounts_pendinguseraction', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('email', self.gf('django.db.models.fields.EmailField')(max_length=75, db_index=True)),
            ('callback', self.gf('django.db.models.fields.CharField')(max_length=50)),
            ('data', self.gf('django.db.models.fields.TextField')()),
            ('action_date', self.gf('django.db.models.fields.DateTimeField')()),
        ))
        db.send_create_signal('accounts', ['PendingUserAction'])


    def backwards(self, orm):
        
        # Deleting model 'User'
        db.delete_table('accounts_user')

        # Deleting model 'PendingUserAction'
        db.delete_table('accounts_pendinguseraction')


    models = {
        'accounts.pendinguseraction': {
            'Meta': {'object_name': 'PendingUserAction'},
            'action_date': ('django.db.models.fields.DateTimeField', [], {}),
            'callback': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'data': ('django.db.models.fields.TextField', [], {}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'})
        },
        'accounts.user': {
            'Meta': {'object_name': 'User', '_ormbases': ['auth.User']},
            'main_metro': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'user_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['accounts']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

import datetime
from django.db import models
from django.contrib.auth.models import User as DjangoUser, UserManager as DjangoUserManager, AnonymousUser
from django.contrib.auth.backends import ModelBackend
from django.utils.hashcompat import md5_constructor

class UserManager(DjangoUserManager):

    def create_user(self, email, password=None, **kw):
        """
        Creates and saves a User with the given e-mail and password.
        """

        now = datetime.datetime.now()
        
        # Normalize the address by lowercasing the domain part of the email
        # address.
        try:
            email_name, domain_part = email.strip().split('@', 1)
        except ValueError:
            first_name = email[0:30]
        else:
            email = '@'.join([email_name, domain_part.lower()])
            first_name = email_name

        # something of a hack...
        # the username is used to enforce uniqueness and is computed
        # as a (truncated) hash of the email address given.
        if len(email) <= 30:
            username = email
        else:
            username = md5_constructor(email).hexdigest()[0:30]
        
        user_args = dict(
            first_name=first_name,
            is_staff=False,
            is_active=True, 
            is_superuser=False,
            last_login=now,
            date_joined=now
        )
        user_args.update(kw)
        user = User(username=username, email=email, **user_args)
        
        if password:
            user.set_password(password)
        else:
            user.set_unusable_password()
        user.save(using=self._db)
        return user

    def create_superuser(self, email, password=None, **kw):
        user_args = dict(kw)
        user_args['is_superuser'] = True
        user_args['is_staff'] = True
        return self.create_user(email, password=password, **user_args)

    def user_by_password(self, email, raw_password):
        """
        Returns a User object for the given e-mail and raw password. If the
        e-mail address exists but the password is incorrect, returns None.
        """
        try:
            user = self.get(email=email)
        except self.model.DoesNotExist:
            return None
        if user.check_password(raw_password):
            return user
        return None

class User(DjangoUser):
    """ A very thin multi-table-inheritance wrapper around the default User class.
    """

    main_metro = models.CharField(
        max_length=32,
        help_text="The SHORT_NAME for the user's metro when they created the account. Only useful if you have multiple metros.")

    objects = UserManager()

    def __unicode__(self):
        return self.email

class AuthBackend(ModelBackend):
    """
    Overridden ModelBackend that works with our User class.
    """
    def authenticate(self, username=None, password=None):
        return User.objects.user_by_password(username, password)

    def get_user(self, user_id):
        try:
            return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None

# Note that this class does *not* use the multidb Manager.
# It's city-specific because pending user actions are city-specific.

class PendingUserAction(models.Model):
    email = models.EmailField(db_index=True) # Stored in all-lowercase.
    callback = models.CharField(max_length=50)
    data = models.TextField() # Serialized into JSON.
    action_date = models.DateTimeField() # When the action was created (so we can clear out expired ones).

    def __unicode__(self):
        return u'%s for %s' % (self.callback, self.email)


########NEW FILE########
__FILENAME__ = urls
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf.urls.defaults import *
from ebpub.savedplaces import views as savedplaces_views
from ebpub.preferences import views as preferences_views
import views # relative import

urlpatterns = patterns(
    '',
    url(r'^dashboard/$', views.dashboard, name='accounts-dashboard'),
    url(r'^login/$', views.login, name='accounts-login'),
    url(r'^logout/$', views.logout, name='accounts-logout'),
    url(r'^register/$', views.register, name='accounts-register'),
    url(r'^password-change/$', views.request_password_change, name='accounts-pw-change'),
    url(r'^email-sent/$', 'django.views.generic.simple.direct_to_template',
        {'template': 'accounts/email_sent.html'}, name='accounts-email-sent'),
    url(r'^saved-places/add/$', savedplaces_views.ajax_save_place,
        name='saved-place-add'),
    url(r'^saved-places/delete/$', savedplaces_views.ajax_remove_place,
        name='saved-place-delete'),
    url(r'^hidden-schemas/add/$', preferences_views.ajax_save_hidden_schema,
        name='preferences-save-hidden-schema'),
    url(r'^hidden-schemas/delete/$', preferences_views.ajax_remove_hidden_schema,
        name='preferences-remove-hidden-schema'),
    url(r'^api/saved-places/$', savedplaces_views.json_saved_places,
        name='saved-place-json'),
    url(r'^c/$', views.confirm_email, name='accounts-confirm-email'),
    url(r'^r/$', views.password_reset, name='accounts-pw-reset'),
)

########NEW FILE########
__FILENAME__ = utils
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#



from django import http
from django.conf import settings
from django.contrib.auth import authenticate
from django.contrib.auth import REDIRECT_FIELD_NAME
from django.core.mail import get_connection, EmailMultiAlternatives
from django.core.urlresolvers import reverse
from django.template.loader import render_to_string
from django.utils.importlib import import_module
from functools import wraps
import constants # relative import
import urllib

# In Python 2.5+, the sha library was deprecated in favor of hashlib.
try:
    import hashlib
    sha_constructor = hashlib.sha1
except ImportError:
    import sha
    sha_constructor = sha.new

###############################
# E-MAIL ADDRESS VERIFICATION #
###############################

# We use the same e-mail verification functions for account creation
# and password reset, but each takes a 'task' argument, which is either
# CREATE_TASK or RESET_TASK.

CREATE_TASK = 1
RESET_TASK = 2

def make_email_hash(email, task):
    salt = {CREATE_TASK: settings.PASSWORD_CREATE_SALT, RESET_TASK: settings.PASSWORD_RESET_SALT}[task]
    return sha_constructor(salt % (settings.SECRET_KEY, email)).hexdigest()[:6]

def verification_url(email, task):
    params = {'e': email, 'h': make_email_hash(email, task)}
    url = {CREATE_TASK: 'c', RESET_TASK: 'r'}[task]
    return '/accounts/%s/?%s' % (url, urllib.urlencode(params))

def send_verification_email(email, task):
    domain = settings.EB_DOMAIN
    url = 'http://%s%s' % (domain, verification_url(email, task))
    template_name = {CREATE_TASK: 'register', RESET_TASK: 'password_reset'}[task]
    text_content = render_to_string('accounts/%s_email.txt' % template_name, {'url': url, 'email': email})
    html_content = render_to_string('accounts/%s_email.html' % template_name, {'url': url, 'email': email})

    subject = {CREATE_TASK: 'Please confirm account', RESET_TASK: 'Password reset request'}[task]
    conn = get_connection() # Use default settings.
    message = EmailMultiAlternatives(subject, text_content, settings.GENERIC_EMAIL_SENDER,
        [email], connection=conn)
    message.attach_alternative(html_content, 'text/html')
    message.send()


##############
# LOGGING IN #
##############

def login(request, user):
    """
    Logs the given user into the given HttpRequest, setting the correct
    bits in the session.

    This is a thin wrapper around django.contrib.auth:login().
    """
    from django.contrib import auth
    request.session[constants.EMAIL_SESSION_KEY] = user.email
    if getattr(user, 'backend', None) is None:
        user.backend = 'django.contrib.auth.backends.ModelBackend'
    return auth.login(request, user)

def login_required(view_func):
    """
    Decorator that requires login before a given view function can be
    accessed.
    """
    # TODO: Is there still any reason we still need to use this
    # instead of django.contrib.auth.decorators.login_required?
    @wraps(view_func)
    def inner_view(request, *args, **kwargs):
        if not request.user.is_anonymous():
            return view_func(request, *args, **kwargs)
        request.session[REDIRECT_FIELD_NAME] = request.path
        return http.HttpResponseRedirect(reverse('accounts-login'))
    return inner_view


def test_client_login(client, **credentials):
    """
    Sets the Client to appear as if it has successfully logged into a site.

    Returns True if login is possible; False if the provided credentials
    are incorrect, or the user is inactive, or if the sessions framework is
    not available.
    """
    user = authenticate(**credentials)
    if user and user.is_active \
            and 'django.contrib.sessions' in settings.INSTALLED_APPS:
        engine = import_module(settings.SESSION_ENGINE)

        # Create a fake request to store login details.
        request = http.HttpRequest()
        if client.session:
            request.session = client.session
        else:
            request.session = engine.SessionStore()
        login(request, user)

        # Save the session values.
        request.session.save()

        # Set the cookie to represent the session.
        session_cookie = settings.SESSION_COOKIE_NAME
        client.cookies[session_cookie] = request.session.session_key
        cookie_data = {
            'max-age': None,
            'path': '/',
            'domain': settings.SESSION_COOKIE_DOMAIN,
            'secure': settings.SESSION_COOKIE_SECURE or None,
            'expires': None,
        }
        client.cookies[session_cookie].update(cookie_data)

        return True
    else:
        return False


test_client_login.__test__ = False  # Tell Nose this isn't a test case.

########NEW FILE########
__FILENAME__ = views
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django import http
from django.contrib.auth import REDIRECT_FIELD_NAME
from django.core.urlresolvers import reverse
from django.template.loader import render_to_string
from django.template.context import RequestContext
from ebpub.accounts import callbacks
from ebpub.accounts.models import User, AnonymousUser, PendingUserAction
from ebpub.alerts.models import EmailAlert
from ebpub.metros.allmetros import get_metro
from ebpub.preferences.models import HiddenSchema
from ebpub.savedplaces.models import SavedPlace
from ebpub.utils.view_utils import eb_render
from ebpub.utils.view_utils import get_schema_manager
import forms, utils # relative import


###########################
# VIEWS FOR USER ACCOUNTS #
###########################

def login(request, custom_message=None, force_form=False, initial_email=None,
          override_target=None):
    """
    View for logging in.
    custom_message is a string to display at the top of the login form.
    force_form is used when you want to force display of the original
    form (regardless of whether it's a POST request).
    override_target can be used to set the form's target URL;
    otherwise it's self-POSTing.
    """
    if not request.user.is_anonymous():
        # If the user is already logged in, redirect to the dashboard.
        next_url = reverse(dashboard)
        return http.HttpResponseRedirect(next_url)
    if request.method == 'POST' and not force_form:

        next_url = (request.session.pop(REDIRECT_FIELD_NAME, None)
                    or request.POST.get(REDIRECT_FIELD_NAME)
                    or reverse(dashboard))

        form = forms.LoginForm(request, request.POST)
        if form.is_valid():
            utils.login(request, form.user_cache)
            if request.session.test_cookie_worked():
                request.session.delete_test_cookie()

            # If the session contains a 'pending_login' variable, it will be a
            # tuple of (callback_name, data), where data is an unserialized
            # Python object and callback_name corresponds to a callback in
            # ebpub/accounts/callbacks.py.
            if 'pending_login' in request.session:
                try:
                    callback, data = request.session['pending_login']
                    message = callbacks.do_callback(callback, form.user_cache, data)
                except (TypeError, ValueError):
                    message = None

                # We're done with the callbacks and don't want to risk them
                # happening again, so we delete the session value.
                del request.session['pending_login']

                # Save the login message in the session so we can display it
                # for the user.
                if message:
                    request.session['login_message'] = message

            return http.HttpResponseRedirect(next_url)
    else:
        form = forms.LoginForm(request, initial={'email': initial_email})

    # Rendering the form.
    request.session.set_test_cookie()
    if request.REQUEST.get(REDIRECT_FIELD_NAME):
        request.session[REDIRECT_FIELD_NAME] = request.REQUEST[REDIRECT_FIELD_NAME]
    custom_message = request.session.pop('login_message', custom_message)
    context = RequestContext(request, {
            'form': form,
            'custom_message': custom_message,
            'target': override_target or reverse(login),
            })
    return eb_render(request, 'accounts/login_form.html', context)

def logout(request):
    if request.method == 'POST':
        request.session.flush()
        request.user = AnonymousUser()
        # The `next_url` can be specified either as POST data or in the
        # session. If it's in the session, it can be trusted. If it's in
        # POST data, it can't be trusted, so we do a simple check that it
        # starts with a slash (so that people can't hack redirects to other
        # sites).
        if REDIRECT_FIELD_NAME in request.POST and request.POST[REDIRECT_FIELD_NAME].startswith('/'):
            next_url = request.POST[REDIRECT_FIELD_NAME]
        elif REDIRECT_FIELD_NAME in request.session:
            next_url = request.session.pop(REDIRECT_FIELD_NAME)
        else:
            # See if the referrer is on our site, and is not this page,
            # and if so, go there.
            referrer = request.META['HTTP_REFERER']
            host = request.get_host()
            protocol = 'https://' if request.is_secure() else 'http://'
            root_url = '%s%s' % (protocol, host)
            if referrer != request.build_absolute_uri() and referrer.startswith(root_url):
                next_url = referrer
            else:
                # Final fallback is the login page.
                request.session['login_message'] = "You're logged out. You can log in again below."
                next_url = reverse('accounts-login')

        return http.HttpResponseRedirect(next_url)
    return eb_render(request, 'accounts/logout_form.html')

@utils.login_required
def dashboard(request):
    """
    The user's account settings, saved places, alerts, and other
    personalized stuff.
    """
    custom_message = request.session.get('login_message')
    if 'login_message' in request.session:
        del request.session['login_message']

    alert_list = EmailAlert.active_objects.filter(user_id=request.user.id)
    saved_place_list = SavedPlace.objects.filter(user_id=request.user.id)
    hidden_schema_ids = HiddenSchema.objects.filter(user_id=request.user.id).values('schema_id')
    hidden_schema_ids = set([x['schema_id'] for x in hidden_schema_ids])

    schema_list = []
    manager = get_schema_manager(request)
    for schema in manager.filter(is_special_report=False).order_by('plural_name'):
        schema_list.append({'schema': schema, 'is_hidden': schema.id in hidden_schema_ids})
    from ebpub.neighbornews.utils import is_neighbornews_enabled
    return eb_render(request, 'accounts/dashboard.html', {
        'custom_message': custom_message,
        'user': request.user,
        'alert_list': alert_list,
        'saved_place_list': saved_place_list,
        'schema_list': schema_list,
        'is_neighbornews_enabled': is_neighbornews_enabled,

    })

####################################
# UTILITIES USED BY MULTIPLE VIEWS #
####################################

# These utilities encapsulate some logic used by both the registration
# workflow and the "I forgot my password" workflow.

class BadHash(Exception):
    def __init__(self, response):
        self.response = response

def send_confirmation_and_redirect(request, email, task):
    utils.send_verification_email(email, task)
    return http.HttpResponseRedirect(reverse('accounts-email-sent'))

def confirm_request_hash(request, task):
    if request.method == 'GET':
        d = request.GET
    elif request.method == 'POST':
        d = request.POST
    else:
        raise http.Http404('Invalid method')

    # Verify the hash.
    try:
        email, email_hash = d['e'], d['h']
        if email_hash != utils.make_email_hash(email, task):
            raise KeyError
    except KeyError:
        if task == utils.CREATE_TASK:
            form_link = reverse(register)
        elif task == utils.RESET_TASK:
            form_link = reverse(request_password_change)
        else:
            raise KeyError("Unknown task %r" % task)
        context = RequestContext(request, {'form_link': form_link})
        response = http.HttpResponseNotFound(render_to_string('accounts/hash_error.html',
                                                              context_instance=context))
        raise BadHash(response)

    return email, email_hash

########################
# REGISTRATION PROCESS #
########################

# We want to avoid creating a database record until an e-mail address has been
# verified, so we use a hash of the e-mail address for security.

def register(request):
    # If the user is already logged in, redirect to the dashboard.
    if not request.user.is_anonymous():
        return http.HttpResponseRedirect(reverse(dashboard))

    if request.method == 'POST':
        form = forms.EmailRegistrationForm(request.POST)
        if form.is_valid():
            return send_confirmation_and_redirect(request, form.cleaned_data['email'], utils.CREATE_TASK)
    else:
        form = forms.EmailRegistrationForm()
    return eb_render(request, 'accounts/register_form_1.html', {'form': form})

def confirm_email(request):
    try:
        email, email_hash = confirm_request_hash(request, utils.CREATE_TASK)
    except BadHash, e:
        return e.response
    if request.method == 'POST':
        form = forms.PasswordRegistrationForm(request.POST)
        if form.is_valid():
            u = User.objects.create_user(
                email=form.cleaned_data['e'],
                password=form.cleaned_data['password1'],
                main_metro=get_metro()['short_name'],
            )
            u.save()
            utils.login(request, u)

            # Look for any PendingUserActions for this e-mail address and
            # execute the callbacks.
            for action in PendingUserAction.objects.filter(email=u.email):
                data = callbacks.unserialize(action.data)
                callbacks.do_callback(action.callback, u, data)
                action.delete()

            request.session['login_message'] = 'Your account was created! Thanks for signing up.'
            return http.HttpResponseRedirect(reverse(dashboard))
    else:
        form = forms.PasswordRegistrationForm(initial={'e': email, 'h': email_hash})
    return eb_render(request, 'accounts/register_form_2.html', {'form': form})

###################
# PASSWORD CHANGE #
###################

def request_password_change(request):
    if request.method == 'POST':
        form = forms.PasswordResetRequestForm(request.POST)
        if form.is_valid():
            return send_confirmation_and_redirect(request, form.cleaned_data['email'], utils.RESET_TASK)
    else:
        form = forms.PasswordResetRequestForm()
    return eb_render(request, 'accounts/request_password_change_form.html', {'form': form})

def password_reset(request):
    try:
        email, email_hash = confirm_request_hash(request, utils.RESET_TASK)
    except BadHash, e:
        return e.response
    if request.method == 'POST':
        form = forms.PasswordResetForm(request.POST)
        if form.is_valid():
            try:
                user = User.objects.get(is_active=True, email=email.lower())
            except User.DoesNotExist:
                # If we reach this point, then somebody managed to submit a
                # hash for a user that's not registered yet.
                raise http.Http404()
        
            user.set_password(form.cleaned_data['password1'])
            user.save()
            request.session['login_message'] = 'Your password was changed successfully. Give it a shot by logging in below:'
            return http.HttpResponseRedirect(reverse(login))
    else:
        form = forms.PasswordResetForm(initial={'e': email, 'h': email_hash})
    return eb_render(request, 'accounts/password_change_form.html', {'form': form})

########NEW FILE########
__FILENAME__ = admin
#   Copyright 2012 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from .models import EmailAlert
from ebpub.geoadmin import OSMModelAdmin
from django.contrib.gis import admin


class AlertAdmin(OSMModelAdmin):

    readonly_fields = ('block',)

    # TODO: need to refactor the BlockAlertForm clean() method so we
    # can use it here too... and the extra form fields that it needs.
    # Otherwise we can't save with empty schema list.


admin.site.register(EmailAlert, AlertAdmin)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):
    
    depends_on = (
            ("db", "0001_initial"),
            ("streets", "0001_initial"),
            
        )

    def forwards(self, orm):
        
        # Adding model 'EmailAlert'
        db.create_table('alerts_emailalert', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user_id', self.gf('django.db.models.fields.IntegerField')()),
            ('block', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['streets.Block'], null=True, blank=True)),
            ('location', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Location'], null=True, blank=True)),
            ('frequency', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('radius', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
            ('include_new_schemas', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('schemas', self.gf('django.db.models.fields.TextField')()),
            ('signup_date', self.gf('django.db.models.fields.DateTimeField')()),
            ('cancel_date', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('is_active', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('alerts', ['EmailAlert'])


    def backwards(self, orm):
        
        # Deleting model 'EmailAlert'
        db.delete_table('alerts_emailalert')


    models = {
        'alerts.emailalert': {
            'Meta': {'object_name': 'EmailAlert'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'cancel_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'frequency': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'include_new_schemas': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'radius': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'schemas': ('django.db.models.fields.TextField', [], {}),
            'signup_date': ('django.db.models.fields.DateTimeField', [], {}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['alerts']

########NEW FILE########
__FILENAME__ = 0002_auto__add_field_emailalert_block_center
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding field 'EmailAlert.block_center'
        db.add_column('alerts_emailalert', 'block_center', self.gf('django.contrib.gis.db.models.fields.PointField')(null=True, blank=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'EmailAlert.block_center'
        db.delete_column('alerts_emailalert', 'block_center')


    models = {
        'alerts.emailalert': {
            'Meta': {'object_name': 'EmailAlert'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'block_center': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'cancel_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'frequency': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'include_new_schemas': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'radius': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'schemas': ('django.db.models.fields.TextField', [], {}),
            'signup_date': ('django.db.models.fields.DateTimeField', [], {}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'prefix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['alerts']

########NEW FILE########
__FILENAME__ = 0003_populate_block_center
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    depends_on = (('streets', '0013_auto__add_field_street_prefix'),
                  )
    def forwards(self, orm):
        "Write your forwards methods here."
        alerts = orm['alerts.emailalert'].objects.all()
        for alert in alerts:
            if alert.block is not None:
                from ebpub.utils.geodjango import interpolate
                alert.block_center = interpolate(alert.block.geom, 0.5, True)
                alert.save()

    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'alerts.emailalert': {
            'Meta': {'object_name': 'EmailAlert'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'block_center': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'cancel_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'frequency': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'include_new_schemas': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'radius': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'schemas': ('django.db.models.fields.TextField', [], {}),
            'signup_date': ('django.db.models.fields.DateTimeField', [], {}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'prefix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'prefix_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'prefix_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'prefix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'prefix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'blank': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'place_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.PlaceType']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placetype': {
            'Meta': {'object_name': 'PlaceType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_geocodable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_mappable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('street_slug', 'city', 'state'),)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'prefix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets', 'alerts']

########NEW FILE########
__FILENAME__ = 0004_auto__del_field_emailalert_block
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'EmailAlert.block'
        db.delete_column('alerts_emailalert', 'block_id')


    def backwards(self, orm):
        
        # Adding field 'EmailAlert.block'
        db.add_column('alerts_emailalert', 'block', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['streets.Block'], null=True, blank=True), keep_default=False)


    models = {
        'alerts.emailalert': {
            'Meta': {'object_name': 'EmailAlert'},
            'block_center': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'cancel_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'frequency': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'include_new_schemas': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'radius': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'schemas': ('django.db.models.fields.TextField', [], {}),
            'signup_date': ('django.db.models.fields.DateTimeField', [], {}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        }
    }

    complete_apps = ['alerts']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib.gis.db import models
from ebpub.db.models import Location
from ebpub.constants import BLOCK_FUZZY_DISTANCE_METERS
from ebpub.streets.models import Block

class ActiveAlertsManager(models.GeoManager):
    def get_query_set(self):
        return super(ActiveAlertsManager, self).get_query_set().filter(is_active=True)

class EmailAlert(models.Model):
    user_id = models.IntegerField()

    block_center = models.PointField(null=True, blank=True,
                                     help_text=u'Point representing the center of a related block.')
    location = models.ForeignKey(Location, blank=True, null=True)
    frequency = models.PositiveIntegerField(help_text="How often to send.",
                                            choices=((1, 'Daily'),
                                                     (7, 'Weekly')))
    radius = models.PositiveIntegerField(blank=True, null=True)

    include_new_schemas = models.BooleanField(
        help_text="If True, schemas should be treated as an exclusion list instead of "
        "an inclusion list. This allows people to exclude existing schemas, but "
        "still receive updates for new schemas when we add them later.")


    schemas = models.TextField(
        help_text="A comma-separated list of schema IDs. Semantics depend on the value "
        "of include_new_schemas (see above).")

    signup_date = models.DateTimeField()
    cancel_date = models.DateTimeField(blank=True, null=True)
    is_active = models.BooleanField()

    objects = models.Manager()
    active_objects = ActiveAlertsManager()

    def __unicode__(self):
        return u'User %d: %s' % (self.user_id, self.name())

    def unsubscribe_url(self):
        return '/alerts/unsubscribe/%s/' % self.id

    def _get_block(self):
        if self.block_center is None:
            return None
        # We buffer the center a bit because exact intersection
        # doesn't always get a match.
        from ebpub.utils.mapmath import buffer_by_meters
        geom = buffer_by_meters(self.block_center, BLOCK_FUZZY_DISTANCE_METERS)
        blocks = Block.objects.filter(geom__intersects=geom)
        if not blocks:
            raise Block.DoesNotExist("No block found at lat %s, lon %s" % (self.block_center.y, self.block_center.x))
        # If there's more than one this close, we don't really care.
        return blocks[0]

    block = property(_get_block)

    def name(self):
        if self.location:
            return self.location.pretty_name
        else:
            block = self._get_block()
            if block:
                return u'%s block%s around %s' % (self.radius, (self.radius != 1 and 's' or ''), block.pretty_name)
        return u'(no name)'

    def pretty_frequency(self):
        return {1: 'daily', 7: 'weekly'}[self.frequency]

    @property
    def user(self):
        if not hasattr(self, '_user_cache'):
            from ebpub.accounts.models import User
            try:
                self._user_cache = User.objects.get(id=self.user_id)
            except User.DoesNotExist:
                self._user_cache = None
        return self._user_cache

########NEW FILE########
__FILENAME__ = sending
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from django.core.mail import get_connection, EmailMultiAlternatives
from django.template.loader import render_to_string
from ebpub.alerts.models import EmailAlert
from ebpub.db.models import NewsItem
from ebpub.db.utils import populate_attributes_if_needed
from ebpub.db.utils import make_search_buffer
from ebpub.streets.models import Block
import datetime

class NoNews(Exception):
    pass

def email_text_for_place(alert, place, place_name, place_url,
                         news_groups, date, frequency):
    """
    Returns a tuple of (text, html) for the given args. `text` is the text-only
    e-mail, and `html` is the HTML version.
    """
    domain = settings.EB_DOMAIN
    context = {
        'place': place,
        'is_block': isinstance(place, Block),
        'block_radius': isinstance(place, Block) and alert.radius or None,
        'domain': domain,
        'email_address': alert.user.email,
        'place_name': place_name,
        'place_url': place_url,
        'news_groups': news_groups,
        'date': date,
        'frequency': frequency,
        'unsubscribe_url': alert.unsubscribe_url(),
    }
    return render_to_string('alerts/email.txt', context), render_to_string('alerts/email.html', context)

def email_for_subscription(alert, start_date, frequency):
    """
    Returns a (place_name, text, html) tuple for the given EmailAlert
    object and date.
    """
    start_datetime = datetime.datetime(start_date.year, start_date.month, start_date.day)
    yesterday = datetime.date.today() - datetime.timedelta(days=1)
    end_datetime = datetime.datetime.combine(yesterday, datetime.time(23, 59, 59, 9999)) # the end of yesterday

    from ebpub.utils.view_utils import get_schema_manager_for_user
    manager = get_schema_manager_for_user(alert.user)
    allowed_schemas = manager.allowed_schema_ids()
    qs = NewsItem.objects.select_related().filter(schema__id__in=allowed_schemas)
    if alert.include_new_schemas:
        # We saved an opt-out list.
        if alert.schemas:
            qs = qs.exclude(schema__id__in=alert.schemas.split(','))
    else:
        # We saved an opt-in list.
        if alert.schemas:
            qs = qs.filter(schema__id__in=alert.schemas.split(','))

    if alert.block_center:
        place = alert._get_block()
        place_name, place_url = place.pretty_name, place.url()
        search_buffer = make_search_buffer(place.geom.centroid, alert.radius)
        qs = qs.filter(location__bboverlaps=search_buffer)

    elif alert.location:
        place_name, place_url = alert.location.name, alert.location.url()
        place = alert.location
        qs = qs.filter(newsitemlocation__location__id=alert.location.id)

    # Order by schema__id to group schemas together.
    news_qs = qs.filter(schema__is_event=False,
                        pub_date__range=(start_datetime, end_datetime),
                        ).order_by('-schema__importance', 'schema__id', '-item_date', '-id')
    events_qs = qs.filter(schema__is_event=True,
                         pub_date__range=(start_datetime, end_datetime),
                         ).order_by('-schema__importance', 'schema__id', 'item_date', 'id')

    news_list = list(news_qs)
    events_list = list(events_qs)
    if not (news_list or events_list):
        raise NoNews
    schemas_used = set([ni.schema for ni in news_list + events_list])
    populate_attributes_if_needed(news_list, list(schemas_used))
    populate_attributes_if_needed(events_list, list(schemas_used))
    newsitem_groups = ({'title': 'Recent', 'newsitems': news_list},
                       {'title': 'Upcoming', 'newsitems': events_list})
    text, html = email_text_for_place(alert, place, place_name, place_url, newsitem_groups, start_date, frequency)
    return place_name, text, html

def send_all(frequency, verbose=False):
    """
    Sends an e-mail to all alert subscribers in the system with data
    with the given frequency (in days).

    Note that it does not keep track of already-sent messages, so take
    care not to call send_all(frequency) more often than ``frequency`` days.
    """
    conn = get_connection() # Use default settings.
    count = 0
    start_date = datetime.date.today() - datetime.timedelta(days=frequency)
    for alert in EmailAlert.active_objects.filter(frequency=frequency):
        try:
            place_name, text_content, html_content = email_for_subscription(alert, start_date, frequency)
        except NoNews:
            continue
        subject = 'Update: %s' % place_name
        message = EmailMultiAlternatives(subject, text_content, settings.GENERIC_EMAIL_SENDER,
            [alert.user.email], connection=conn)
        message.attach_alternative(html_content, 'text/html')
        message.send()
        if verbose:
            print "Sent to %s" % alert.user.email
        count += 1
    return count

def main(argv=None):
    if argv is None:
        import sys
        argv = sys.argv[1:]
    from optparse import OptionParser
    freq_choices = {'daily': 1, 'weekly': 7}
    usage = """usage: %prog [options]\nSends OpenBlock email alerts.

Warning, the system does not keep track of which alerts you've already sent.
Eg. you should run this script with --frequency='daily' exactly once per day,
NOT more, or you will send duplicate email.
"""
    optparser = OptionParser(usage=usage)
    optparser.add_option('-f', '--frequency', type="choice",
                         choices=freq_choices.keys(),
                         help='Which email alerts to send (choices: %s)' % ', '.join(freq_choices.keys()))
    optparser.add_option('-v', '--verbose', action='store_true')
    opts, args = optparser.parse_args(argv)
    try:
        frequency = freq_choices[opts.frequency]
    except KeyError:
        sys.stderr.write("Error: You must choose a valid frequency.\n\n")
        optparser.print_help()
        return 1
    count = send_all(frequency, opts.verbose)
    print "Sent %d messages for %s subscriptions" % (count, opts.frequency)


########NEW FILE########
__FILENAME__ = views
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django import forms, http
from django.core.urlresolvers import reverse
from django.shortcuts import get_object_or_404
from django.template.defaultfilters import capfirst
from ebpub.accounts import callbacks
from ebpub.accounts.models import User, PendingUserAction
from ebpub.accounts.utils import login_required, CREATE_TASK
from ebpub.accounts.views import login, send_confirmation_and_redirect
from ebpub.alerts.models import EmailAlert
from ebpub.db.utils import url_to_place, block_radius_value
from ebpub.db.utils import get_place_info_for_request
from ebpub.db.views import _preconfigured_map
from ebpub.streets.models import Block
from ebpub.utils.view_utils import eb_render, get_schema_manager
import datetime

FREQUENCY_CHOICES = (('1', 'Daily'), ('7', 'Weekly'))
RADIUS_CHOICES = (('1', '1 block'), ('3', '3 blocks'), ('8', '8 blocks'))

class SchemaMultipleChoiceField(forms.ModelMultipleChoiceField):

    # We don't assign self.queryset yet because we can only really do that
    # at runtime, with access to a request.
    # We do that during __init__().

    def label_from_instance(self, obj):
        return capfirst(obj.plural_name)

class LocationAlertForm(forms.Form):
    frequency = forms.ChoiceField(choices=FREQUENCY_CHOICES, widget=forms.RadioSelect)
    include_new_schemas = forms.BooleanField(required=False)

    # This form is slightly complicated because the e-mail address doesn't need
    # to be entered if the user is logged in. The __init__() method takes an
    # `email_required` argument, which specifies whether the `email` field
    # should be included in the form.
    # Also, because the Schemas to display may depend on the request,
    # we need to pass that to __init__ and create the selected_Schemas and
    # displayed_schemas fields on the fly.
    def __init__(self, *args, **kwargs):
        self.email_required = kwargs.pop('email_required', True)
        request = kwargs.pop('request')
        forms.Form.__init__(self, *args, **kwargs)
        if self.email_required:
            f = forms.EmailField(widget=forms.TextInput(attrs={'id': 'emailinput', 'class': 'textinput placeholder'}))
            self.fields['email'] = f
        qs = get_schema_manager(request).all()
        self.fields['selected_schemas'] = SchemaMultipleChoiceField(
            widget=forms.CheckboxSelectMultiple, queryset=qs)
        self.fields['displayed_schemas'] = SchemaMultipleChoiceField(
            widget=forms.MultipleHiddenInput, queryset=qs)


    def clean(self):
        # Normalize e-mail address to lower case.
        if self.cleaned_data.get('email'):
            self.cleaned_data['email'] = self.cleaned_data['email'].lower()

        # Set cleaned_data['schemas'], which we'll use later. Its value depends...
        if 'include_new_schemas' in self.cleaned_data and 'selected_schemas' in self.cleaned_data:
            if self.cleaned_data['include_new_schemas']:
                # Set it to the list of schemas to opt out of,
                # i.e. everything the user did NOT select.
                self.cleaned_data['schemas'] = set(self.cleaned_data['displayed_schemas']) - set(self.cleaned_data['selected_schemas'])
            else:
                # Set it to the list of schemas to opt in to.
                self.cleaned_data['schemas'] = self.cleaned_data['selected_schemas']

        return self.cleaned_data

class BlockAlertForm(LocationAlertForm):
    radius = forms.ChoiceField(choices=RADIUS_CHOICES, widget=forms.RadioSelect)

def signup(request, *args, **kwargs):
    place = url_to_place(*args, **kwargs)
    manager = get_schema_manager(request)
    if isinstance(place, Block):
        FormClass, type_code = BlockAlertForm, 'b'
    else:
        FormClass, type_code = LocationAlertForm, 'l'
    email_required = request.user.is_anonymous()
    if request.method == 'POST':
        form = FormClass(request.POST, email_required=email_required, request=request)
        if form.is_valid():
            return finish_signup(request, place, form.cleaned_data)
    else:
        schema_list = manager.filter(is_special_report=False).order_by('plural_name')
        schema_ids = [s.id for s in schema_list]
        form = FormClass(
            initial={
                'email': 'Enter your e-mail address',
                'radius': block_radius_value(request)[1],
                'frequency': '1',
                'include_new_schemas': True,
                'selected_schemas': schema_ids,
                'displayed_schemas': schema_ids,
                },
            email_required=email_required,
            request=request)
    context = get_place_info_for_request(request, *args, **kwargs)
    context['map_configuration'] = _preconfigured_map(context);
    context['form'] = form
    #context['schema_list'] = schema_list
    return eb_render(request, 'alerts/signup_form.html', context)

def finish_signup(request, place, data):
    # This is called from signup(), after `data` (the alert options) is
    # validated/cleaned. This is a separate function so signup() doesn't get
    # too unwieldy.

    # First, delete displayed_schemas and selected_schemas, because neither is
    # used in serialization. Also, convert `schemas` to be a string list of IDs
    # instead of the model objects, because that's what we end up storing in
    # the database.
    del data['displayed_schemas']
    del data['selected_schemas']
    data['schemas'] = ','.join([str(s.id) for s in data['schemas']])
    if isinstance(place, Block):
        data['block_center'] = place.geom.centroid.wkt
        data['location_id'] = None
    else:
        data['block_center'] = None
        data['location_id'] = place.id
        data['radius'] = None

    if not request.user.is_anonymous():
        email = request.user.email
    else:
        email = data['email']

    if request.user.is_authenticated():
        message = callbacks.create_alert(request.user, data)
        request.session['login_message'] = message
        return http.HttpResponseRedirect(reverse('accounts-dashboard'))

    try:
        User.objects.get(email=email)
    except User.DoesNotExist:
        # We haven't seen this e-mail address yet, so send out a confirmation
        # e-mail to create the account. But first, save the user's alert
        # information so we can create the alert once the user confirms the
        # e-mail address. (We don't want to send the alert options in that
        # confirmation e-mail, because that's too much data to pass in a URL.)
        PendingUserAction.objects.create(
            email=email,
            callback='createalert',
            data=callbacks.serialize(data),
            action_date=datetime.datetime.now(),
        )
        return send_confirmation_and_redirect(request, email, CREATE_TASK)
    else:
        # This e-mail address already has an account, so show a password
        # confirmation screen.
        msg = "You already have an account with this e-mail address. " \
              "Please enter your password to confirm this alert subscription."
        request.session['pending_login'] = ('createalert', data)
        return login(request, custom_message=msg, force_form=True, initial_email=email)

@login_required
def unsubscribe(request, alert_id):
    a = get_object_or_404(EmailAlert.active_objects.all(), id=alert_id, user_id=request.user.id)
    if request.method == 'POST':
        EmailAlert.objects.filter(id=alert_id).update(cancel_date=datetime.datetime.now(), is_active=False)
        request.session['login_message'] = "We've unsubscribed you from the alert for %s" % a.name()
        return http.HttpResponseRedirect(reverse('accounts-dashboard'))
    return eb_render(request, 'alerts/confirm_unsubscription.html', {'alert': a})

########NEW FILE########
__FILENAME__ = constants
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

# These might end up in settings eventually, but for now it's fine to
# hardcode them.

BLOCK_RADIUS_CHOICES = {'1': .0015, '3': .0035, '8': .007} # number of blocks -> number of geographic degrees ... should this vary with latitude? oh well.
BLOCK_RADIUS_COOKIE_NAME = 'radius'
BLOCK_RADIUS_DEFAULT = '8'
HIDE_ADS_COOKIE_NAME = 'h'

# How far from a block center various model geometries can be,
# and still be considered on that block.
BLOCK_FUZZY_DISTANCE_METERS = 15

########NEW FILE########
__FILENAME__ = admin
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Hooks up ebpub.db.models to the django.contrib.admin UI.
"""

from django.contrib.gis import admin
from ebpub.db.forms import NewsItemForm
from ebpub.db.models import Attribute
from ebpub.db.models import Location
from ebpub.db.models import LocationSynonym
from ebpub.db.models import LocationType
from ebpub.db.models import Lookup
from ebpub.db.models import NewsItem
from ebpub.db.models import Schema
from ebpub.db.models import SchemaField
from ebpub.geoadmin import OSMModelAdmin

class AttributeInline(admin.StackedInline):
    # TODO: this badly needs a custom Form that takes into account the
    # Schema and shows you only relevant fields, with labels.
    model = Attribute

class NewsItemAdmin(OSMModelAdmin):
    inlines = [
        AttributeInline,
        ]

    list_display = ('title', 'schema', 'item_date', 'pub_date', 'location_name')
    raw_id_fields = ('location_object', 'location_set',)
    readonly_fields = ('location_set',)
    list_filter = ('schema',)
    search_fields = ('title', 'description',)
    form = NewsItemForm

    date_hierarchy = 'item_date'


    ## This really slows down the UI if there's lots of NewsItems,
    ## and olwidget doesn't seem to paginate them along with the change list?
    # list_map = ['location']
    # list_map_options = copy.deepcopy(OSMModelAdmin.list_map_options)
    # list_map_options['cluster'] = True

class LocationTypeAdmin(admin.ModelAdmin):
    list_display = ('name', 'is_significant')
    list_filter = ('is_significant',)
    exclude = ('is_browsable',)  # TODO: unused, use it or lose it.
    prepopulated_fields = {'slug': ('plural_name',)}

class LocationAdmin(OSMModelAdmin):
    list_filter = ('location_type', 'city', 'is_public',)
    list_display = ('name', 'slug', 'location_type', 'creation_date', 'area')
    search_fields = ('name',)
    prepopulated_fields = {'slug': ('name',)}

    # area is populated by a database trigger; normalized_name is set during cleaning.
    readonly_fields = ('area', 'normalized_name')

    # Display a map of items on the change list page. (olwidget)
    # ... Or not; this gets so slow it's unusable.
    #list_map = ['location']


class SchemaAdmin(admin.ModelAdmin):
    list_display = ('name', 'last_updated', 'importance', 'is_public',
                    'has_newsitem_detail',)
    prepopulated_fields = {'slug': ('plural_name',)}
    save_as = True

class SchemaFieldAdmin(admin.ModelAdmin):

    list_display = ('pretty_name',
                    'name',
                    'schema',
                    'display',
                    'datatype',
                    'real_name',
                    'is_filter', 'is_charted', 'is_searchable',
                    'is_lookup', 'is_many_to_many_lookup',
                    )
    list_filter = ('schema', 'display', 'is_lookup', 'is_filter',
                   'is_charted', 'is_searchable', 'real_name')

    prepopulated_fields = {'name': ('pretty_name',)}


class LookupAdmin(admin.ModelAdmin):
    # TODO: this would make more sense to edit inline on NewsItem,
    # but that would require some custom wackiness.
    list_display = ('name', 'featured', 'slug', 'code', 'schema_field')
    search_fields = ('description', 'name', 'code')
    prepopulated_fields = {'slug': ('name',)}
    list_filter = ('featured', 'schema_field')

class LocationSynonymAdmin(OSMModelAdmin):
    list_display = ('pretty_name', 'location')
    search_fields = ('pretty_name', 'location')
    readonly_fields = ('normalized_name',)


# Hack to ensure that the templates in obadmin get used, if it's installed.
# This is because olwidget defines its own olwidget_change_list.html
# template for GeoModelAdmin, which OSMModelAdmin inherits.
try:
    import obadmin.admin
    LocationAdmin.change_list_template = 'admin/db/location/change_list.html'
    NewsItemAdmin.change_list_template = 'admin/db/newsitem/change_list.html'
except ImportError:
    pass

admin.site.register(Schema, SchemaAdmin)
admin.site.register(SchemaField, SchemaFieldAdmin)
admin.site.register(NewsItem, NewsItemAdmin)
admin.site.register(LocationType, LocationTypeAdmin)
admin.site.register(Location, LocationAdmin)
admin.site.register(LocationSynonym, LocationSynonymAdmin)
admin.site.register(Lookup, LookupAdmin)


########NEW FILE########
__FILENAME__ = activate_schema
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""Script that 'activates' a :py:class:`ebpub.db.models.Schema`.
This sets ``is_public=True``, and sets ``pub_date`` to today
for any older NewsItems of this schema.
"""

from django.db import connection, transaction
from ebpub.db.models import Schema
import sys

def set_schema_min_date(schema):
    """
    Sets the schema's min_date to the earliest item_date found in news items.
    """
    cursor = connection.cursor()
    cursor.execute("""
        update db_schema
              set min_date = (select min(item_date) from db_newsitem where schema_id=%s)
          where id=%s;
    """, (schema.id, schema.id))
    transaction.commit_unless_managed()

def fix_initial_pub_dates(schema):
    """
    Sets pub_date equal to item_date for the earliest import of the given schema.
    """
    cursor = connection.cursor()
    cursor.execute("""
        update db_newsitem
              set pub_date = item_date
         where pub_date = (select min(pub_date) from db_newsitem where schema_id=%s)
             and schema_id=%s;
    """, (schema.id, schema.id))
    transaction.commit_unless_managed()

def activate_schema(schema):
    """
    Fixes the given schema's min_date, its news item pub_dates, and makes it
    public.
    """
    fix_initial_pub_dates(schema)
    set_schema_min_date(schema)
    # Re-fetch the schema so we don't overwrite the previous changes.
    schema = Schema.objects.get(pk=schema.pk)
    schema.is_public = True
    schema.save()

def main():
    try:
        schema = Schema.objects.get(slug__exact=sys.argv[1])
    except Schema.DoesNotExist:
        print "Schema with slug %s could not be found." % sys.argv[1]
        sys.exit(-1)
    activate_schema(schema)
    print "%s: fixed schema.min_date, associated pub_dates, and set is_public=True." % schema.slug

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = add_location
#!/usr/bin/env python
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Script that adds a single :py:class:`ebpub.db.models.Location` by specifying
its borders in WKT format.
See :ref:`import_location_from_wkt`

Use ``--help`` to get usage instructions.
"""

import sys
from optparse import OptionParser
from django.db import connection
from django.contrib.gis.geos import fromstr
from ebpub.db.bin.alphabetize_locations import alphabetize_locations
from ebpub.db.models import Location, LocationType, NewsItem
from ebpub.geocoder.parser.parsing import normalize
from ebpub.utils.text import slugify
from ebpub.metros.allmetros import get_metro

def swallow_out(f, start_msg=None, end_msg=None):
    # Swallows the output of the wrapped function normally going to stdout,
    # optionally printing a message before and after the function call.
    def wrapped(*args, **kwargs):
        if start_msg:
            sys.stdout.write(start_msg)
            sys.stdout.flush()
        old_stdout = sys.stdout
        sys.stdout = open('/dev/null', 'w')
        f(*args, **kwargs)
        sys.stdout = old_stdout
        if end_msg:
            sys.stdout.write(end_msg)
            sys.stdout.flush()
    return wrapped

def populate_ni_loc(location):
    ni_count = NewsItem.objects.count()
    cursor = connection.cursor()
    i = 0
    while i < ni_count:
        print i
        cursor.execute("""
            INSERT INTO db_newsitemlocation (news_item_id, location_id)
            SELECT ni.id, loc.id FROM db_newsitem ni, db_location loc
            WHERE intersecting_collection(ni.location, loc.location)
                AND ni.id >= %s AND ni.id < %s
                AND loc.id = %s """, (i, i+200, location.id))
        connection._commit()
        i += 200

alphabetize_locations = swallow_out(alphabetize_locations, 'Re-alphabetizing locations ...', ' done.\n')
populate_ni_loc = swallow_out(populate_ni_loc, 'Populating newsitemlocations ...', ' done.\n')

def add_location(name, wkt, loc_type, source='UNKNOWN'):
    geom = fromstr(wkt, srid=4326)
    name = name.strip().title()
    loc, created = Location.objects.get_or_create(
        name=name,
        slug=slugify(name),
        normalized_name=normalize(name),
        location_type=loc_type,
        location=geom,
        display_order=0,
        city=get_metro()['city_name'].upper(),
        source=source
    )
    print '%s %s %s' % (created and 'Created' or 'Found', loc_type.name, name)
    return loc

def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]

    usage = 'usage: %prog [options] NAME WKT'
    usage += '\n\n WKT is the geometry in "Well-Known Text" format.'
    usage += '\n\n NAME is the human-readable name.'
    usage += '\n The slug and normalized_name will be derived from it.'

    p = OptionParser(usage=usage)
    p.add_option('-l', '--location_type', dest='loc_type_slug',
                 default='neighborhoods', help='location type slug (default: neighborhoods)')
    p.add_option('-s', '--source', dest='source',
                 default='UNKNOWN',
                 help='source of data - name or URL of the place you found it.')

    opts, args = p.parse_args(argv)

    if len(args) != 2:
        p.error('required arguments `NAME`, `WKT`')

    try:
        loc_type = LocationType.objects.get(slug=opts.loc_type_slug)
    except LocationType.DoesNotExist:
        p.error('unknown location type slug')

    location = add_location(args[0], args[1], loc_type, opts.source)

    alphabetize_locations(opts.loc_type_slug)
    populate_ni_loc(location)

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = alphabetize_locations
#!/usr/bin/env python
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Script that updates ``display_order`` for all :py:class:`ebpub.db.models.Location`
so that they are sorted alphabetically by ``name``.

Optionally pass a LocationType.slug to only sort locations of that type.

"""
import sys
from ebpub.db.models import Location

def alphabetize_locations(location_type_slug=None):
    if location_type_slug is None:
        sys.stderr.write("using default slug 'neighborhoods'")
        location_type_slug = 'neighborhoods'
    for i, loc in enumerate(Location.objects.filter(location_type__slug=location_type_slug).order_by('name').iterator()):
        print loc.name
        loc.display_order = i
        loc.save()

def main():
    location_type_slug = len(sys.argv[1:]) and sys.argv[1] or None
    sys.exit(alphabetize_locations(location_type_slug))

if __name__ == "__main__":
    main()


########NEW FILE########
__FILENAME__ = delete_newsitems
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Script that deletes all NewsItems of a given Schema (specified by slug).

To do a dry run and not actually delete anything, give the --dry-run
option.

"""
from ebpub.db.models import NewsItem, Attribute, Lookup, Schema


def delete(schema=None, do_delete=False):
    """
    Delete all NewsItems of a given Schema.

    By default, does a dry run and just prints;
    """
    schema = Schema.objects.get(slug=schema)
    qs = NewsItem.objects.filter(schema=schema).order_by('-id')
    if not do_delete:
        print "Would delete %d for schema %s ..." % (qs.count(), schema)
        print qs
    else:
        print "Deleting %d for schema %s ..." % (qs.count(), schema)
        qs.delete()
        print "Deleted."
        # This only matters if there are orphan Attribute rows.
        qs = Attribute.objects.filter(schema=schema).order_by('-id')
        print "Deleting %d attributes for schema %s ..." % (qs.count(), schema)
        qs.delete()
        print "Deleted."
        qs = Lookup.objects.filter(schema_field__schema=schema).order_by('-id')
        print "Deleting %d lookups for schema %s ..." % (qs.count(), schema)
        qs.delete()
        print "Deleted."


def main():
    import sys
    argv = sys.argv[1:]
    from optparse import OptionParser
    optparser = OptionParser()
    optparser.add_option('-d', '--dry-run', action='store_true')
    opts, args = optparser.parse_args(argv)
    schema_slug = args[0]
    delete(schema_slug, do_delete=not opts.dry_run)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = export_schema
#!/usr/bin/env python
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Prints out a SQL statement that can recreate one :py:class:`Schema <ebpub.db.models.Schema>`
row. 

Arguments should be the ``slug`` of the Schema(s) you want.

Does not included related SchemaFields.
"""

from ebpub.db.models import Schema

fixbool = lambda x: bool(x) and 't' or 'f'

def get_value(obj, field):
    if field.get_internal_type() == 'BooleanField':
        return fixbool(getattr(obj, field.attname))
    else:
        return getattr(obj, field.attname)

def escape(value):
    if isinstance(value, (int, long)):
        return str(value)
    else:
        return "'%s'" % str(value).replace("'", "''")

def get_cols_vals_for_insert(model):
    # Don't copy the primary key id field or related fields
    fields = [f for f in model._meta.fields if f.get_internal_type() not in ('AutoField', 'ForeignKey')]
    cols = [f.column for f in fields]
    values = [escape(get_value(model, f)) for f in fields]
    return (cols, values)

def get_insert_sql(table, cols, values):
    cols_clause = '(' + ', '.join(cols) + ')'
    values_clause = '(' + ', '.join(values) + ')'
    return 'INSERT INTO %s %s VALUES %s;' % (table, cols_clause, values_clause)
    
def print_schema_creation(schema_slug):
    s = Schema.objects.get(slug=schema_slug)
    print "BEGIN;"
    print get_insert_sql(s._meta.db_table, *get_cols_vals_for_insert(s))
    for sf in s.schemafield_set.all():
        cols, vals = get_cols_vals_for_insert(sf)
        cols.insert(0, 'schema_id')
        vals.insert(0, "(SELECT id FROM %s WHERE slug='%s')" % (s._meta.db_table, s.slug))
        print get_insert_sql(sf._meta.db_table, cols, vals)
    print "COMMIT;"

def main():
    import sys
    for arg in sys.argv[1:]:
        print_schema_creation(arg)
    if not sys.argv[1:]:
        sys.stderr.write("No Schema slugs specified.\n")

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = geocode_newsitems
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Script that finds NewsItems with null ``location`` fields, and
attempts to geocode them based on their ``location_name``.

Optionally provide a list of ``Schema.slug`` values to only geocode
items of that schema.
"""


from ebpub.db.models import NewsItem
from ebpub.geocoder import SmartGeocoder, GeocodingException, AmbiguousResult, InvalidBlockButValidStreet
from ebpub.geocoder.parser.parsing import ParsingError

def geocode(*schemas):
    """
    Geocode NewsItems with null locations.

    If ``schemas`` are provided, only geocode NewsItems with that particular
    schema slug(s).
    """
    geocoder = SmartGeocoder()
    qs = NewsItem.objects.filter(location__isnull=True).order_by('-id')
    if schemas is not None:
        print "Geocoding %s..." % ', '.join(schemas)
        qs = qs.filter(schema__slug__in=schemas)
    else:
        print "Geocoding all ungeocoded newsitems..."

    geocoded_count = 0
    not_found_count = 0
    ambiguous_count = 0
    parsing_error_count = 0
    invalid_block_count = 0

    for ni in qs.iterator():
        loc_name = ni.location_name
        try:
            add = geocoder.geocode(loc_name)
        except InvalidBlockButValidStreet:
            print '      invalid block but valid street: %s' % loc_name
            invalid_block_count += 1
        except AmbiguousResult:
            print '      ambiguous: %s' % loc_name
            ambiguous_count += 1
        except GeocodingException:
            print '      not found: %s' % loc_name
            not_found_count += 1
        except ParsingError:
            print '      parse error: %s' % loc_name
            parsing_error_count += 1
        except:
            raise
        else:
            ni.location = add['point']
            ni.save()
            print '%s (%s)' % (loc_name, ni.item_url())
            geocoded_count += 1
    else:
        print "No NewsItems with null locations found"

    print "------------------------------------------------------------------"
    print "Geocoded:       %s" % geocoded_count
    print "Not found:      %s" % not_found_count
    print "Ambiguous:      %s" % ambiguous_count
    print "Parse errors:   %s" % parsing_error_count
    print "Invalid blocks: %s" % invalid_block_count

def main():
    import sys
    try:
        schema_slug = sys.argv[1]
    except IndexError:
        geocode()
    else:
        geocode(schema_slug)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = import_hoods
#!/usr/bin/env python
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#


"""
Import neighborhoods from a shapefile.  Try ``--help`` for usage instructions.

Assumes you have a LocationType with ``slug='neighborhoods'``.
"""
import sys
from ebpub.db.models import LocationType
from ebpub.db.bin import import_locations
from ebpub.metros.allmetros import get_metro

def parse_args(optparser, argv):
    optparser.set_usage('usage: %prog [options] /path/to/shapefile')
    opts, args = optparser.parse_args(argv)

    if len(args) != 1:
        optparser.error('must give path to shapefile')

    layer = import_locations.layer_from_shapefile(args[0], opts.layer_id)

    return layer, opts

def location_type():
    metro = get_metro()
    metro_name = metro['metro_name'].upper()
    location_type, _ = LocationType.objects.get_or_create(
        name = 'Neighborhood',
        plural_name = 'Neighborhoods',
        scope = metro_name,
        slug = 'neighborhoods',
        is_browsable = True,
        is_significant = True,
    )
    return location_type

def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]
    layer, opts = parse_args(import_locations.optparser, argv)
    importer = import_locations.LocationImporter(
        layer,
        location_type(),
        opts.source,
        opts.filter_bounds,
        opts.verbose
    )
    num_created, num_updated = importer.save(opts.name_field)
    if opts.verbose:
        print >> sys.stderr, 'Created %s, updated %s neighborhoods.' % (num_created, num_updated)

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = import_locations
#!/usr/bin/env python
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#


"""
Script to import Locations from a shapefile.
See :ref:`import_locations_from_shapefile`

"""
import os
import sys
import datetime
from optparse import OptionParser
from django.contrib.gis.gdal import DataSource
from django.db import connection
from django.db.utils import IntegrityError
from ebpub.db.models import Location, LocationType, NewsItem, NewsItemLocation
from ebpub.geocoder.parser.parsing import normalize
from ebpub.utils.text import slugify
from ebpub.utils.geodjango import ensure_valid
from ebpub.utils.geodjango import flatten_geomcollection
from ebpub.utils.geodjango import geos_with_projection
from ebpub.metros.allmetros import get_metro

import logging
logger = logging.getLogger('ebpub.db.bin.import_locations')

def populate_ni_loc(location):
    """
    Add NewsItemLocations for all NewsItems that overlap with the new
    Location.
    """
    ni_count = NewsItem.objects.count()
    cursor = connection.cursor()
    # In case the location is not new...
    NewsItemLocation.objects.filter(location=location).delete()
    old_niloc_count = NewsItemLocation.objects.count()
    i = 0
    batch_size = 400
    while i < ni_count:
        # We don't use intersecting_collection() because we should have cleaned up
        # all our geometries by now and it's sloooow ... there could be millions
        # of db_newsitem rows.
        cursor.execute("""
            INSERT INTO db_newsitemlocation (news_item_id, location_id)
            SELECT ni.id, loc.id FROM db_newsitem ni, db_location loc
            WHERE st_intersects(ni.location, loc.location)
                AND ni.id >= %s AND ni.id < %s
                AND loc.id = %s
        """, (i, i + batch_size, location.id))
        connection._commit()
        i += batch_size
    new_count = NewsItemLocation.objects.count()
    logger.info("New: %d NewsItemLocations" % (new_count - old_niloc_count))


class LocationImporter(object):
    def __init__(self, layer, location_type, source='UNKNOWN', filter_bounds=False, verbose=False):
        self.layer = layer
        metro = get_metro()
        self.metro_name = metro['metro_name'].upper()
        self.now = datetime.datetime.now()
        if isinstance(location_type, int):
            location_type = LocationType.objects.get(id=location_type)
        self.location_type = location_type
        self.source = source
        self.filter_bounds = filter_bounds
        self.verbose = verbose
        if self.filter_bounds:
            from ebpub.utils.geodjango import get_default_bounds
            self.bounds = get_default_bounds()

    def create_location(self, name, location_type, geom, display_order=0):
        source = self.source
        geom = geos_with_projection(geom, 4326)
        geom = ensure_valid(geom, name)
        geom = flatten_geomcollection(geom)
        if not isinstance(location_type, int):
            location_type = location_type.id
        kwargs = dict(
            name=name,
            slug=slugify(name),
            location=geom,
            location_type_id=location_type,
            city=self.metro_name,
            source=source,
            is_public=True,
        )
        if not self.should_create_location(kwargs):
            return
        kwargs['defaults'] = {
            'creation_date': self.now,
            'last_mod_date': self.now,
            'display_order': display_order,
            'normalized_name': normalize(name),
            'area': geom.transform(3395, True).area,
            }
        try:
            loc, created = Location.objects.get_or_create(**kwargs)
        except IntegrityError:
            # Usually this means two towns with the same slug.
            # Try to fix that.
            slug = kwargs['slug']
            existing = Location.objects.filter(slug=slug).count()
            if existing:
                slug = slugify('%s-%s' % (slug, existing + 1))
                logger.info("Munged slug %s to %s to make it unique" % (kwargs['slug'], slug))
                kwargs['slug'] = slug
                loc, created = Location.objects.get_or_create(**kwargs)
            else:
                raise

        logger.info('%s %s %s' % (created and 'Created' or 'Already had', self.location_type.name, loc))
        logger.info('Populating newsitem locations ... ')
        populate_ni_loc(loc)
        logger.info('done.\n')

        return created

    def save(self, name_field):
        num_created = 0
        num_updated = 0
        features = sorted(self.layer, key = lambda f: f.get(name_field))
        for i, feature in enumerate(features):
            name = feature.get(name_field)
            location_type = self.get_location_type(feature)
            created = self.create_location(name, location_type, feature.geom, display_order=i)
            if created:
                num_created += 1
            else:
                num_updated += 1

        return (num_created, num_updated)

    def should_create_location(self, fields):
        if self.filter_bounds:
            if not fields['location'].intersects(self.bounds):
                logger.info("Skipping %s, out of bounds" % fields['name'])
                return False
        return True

    def get_location_type(self, feature):
        return self.location_type

optparser = OptionParser(usage= 'usage: %prog [options] type_slug /path/to/shapefile')
optparser.add_option('-n', '--name-field', dest='name_field', default='name', help='field that contains location\'s name')
optparser.add_option('-i', '--layer-index', dest='layer_id', default=0, help='index of layer in shapefile')
optparser.add_option('-s', '--source', dest='source', default='UNKNOWN', help='source metadata of the shapefile')
optparser.add_option('-v', '--verbose',  action='store_true', default=False, help='be verbose')
optparser.add_option('-b', '--filter-bounds', action='store_true', default=False,
                     help="exclude locations not within the lon/lat bounds of "
                     " your metro's extent (from your settings.py) (default false)")

def get_or_create_location_type(slug, name, name_plural, verbose):
    metro = get_metro()
    metro_name = metro['metro_name'].upper()
    try:
        location_type = LocationType.objects.get(slug = slug)
        logger.info("Location type %s already exists, ignoring type-name and type-name-plural" % slug)
    except LocationType.DoesNotExist:
        location_type, _ = LocationType.objects.get_or_create(
            name = name,
            plural_name = name_plural,
            scope = metro_name,
            slug = slug,
            is_browsable = True,
            is_significant = True,
            )
    return location_type

def layer_from_shapefile(path, layer_id):
    if not os.path.exists(path):
        raise ValueError('file does not exist: ' + path)
    ds = DataSource(path)
    return ds[layer_id]

def parse_args(optparser, argv):
    # Add some options that aren't relevant to scripts that import our optparser.
    optparser.add_option('--type-name', dest='type_name', default='', help='specifies the location type name')
    optparser.add_option('--type-name-plural', dest='type_name_plural', default='', help='specifies the location type plural name')
    opts, args = optparser.parse_args(argv)

    if len(args) != 2:
        optparser.error('must supply type slug and path to shapefile')
    type_slug = args[0]

    try:
        layer = layer_from_shapefile(args[1], opts.layer_id)
    except ValueError as e:
        optparser.error(str(e))

    return type_slug, layer, opts

def main():
    type_slug, layer, opts = parse_args(optparser, sys.argv[1:])
    if not opts.verbose:
        logging.basicConfig()
        logger.setLevel(logging.WARN)

    location_type = get_or_create_location_type(type_slug, opts.type_name, opts.type_name_plural, opts.verbose)

    importer = LocationImporter(
        layer,
        location_type,
        opts.source,
        opts.filter_bounds,
        opts.verbose
    )
    num_created, num_updated = importer.save(opts.name_field)

    logger.info('Created %s, updated %s %s.' % (num_created, num_updated, location_type.plural_name))

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = import_zips
#!/usr/bin/env python
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#


"""Script to import ZIP code Locations from a shapefile.
See :ref:`zipcodes`
"""

from django.contrib.gis.geos import MultiPolygon
from ebpub.db.models import LocationType
from ebpub.db.bin import import_locations
from ebpub.utils.geodjango import geos_with_projection
import sys


class ZipImporter(import_locations.LocationImporter):
    def __init__(self, layer, name_field, source='UNKNOWN', filter_bounds=False, verbose=False):
        location_type, _ = LocationType.objects.get_or_create(
            name = 'ZIP Code',
            plural_name = 'ZIP Codes',
            scope = 'U.S.A.',
            slug = 'zipcodes',
            is_browsable = True,
            is_significant = True,
        )
        self.name_field = name_field
        super(ZipImporter, self).__init__(layer, location_type, source, filter_bounds, verbose)
        self.zipcode_geoms = {}
        self.collapse_zip_codes()

    def collapse_zip_codes(self):
        # The ESRI ZIP Code layer breaks ZIP Codes up along county
        # boundaries, so we need to collapse them first before
        # proceeding.

        if len(self.zipcode_geoms) > 0:
            return

        for feature in self.layer:
            zipcode = feature.get(self.name_field)
            geom = geos_with_projection(feature.geom)
            if zipcode not in self.zipcode_geoms:
                self.zipcode_geoms[zipcode] = geom
            else:
                # If it's a MultiPolygon geom we're adding to our
                # existing geom, we need to "unroll" it into its
                # constituent polygons 
                if isinstance(geom, MultiPolygon):
                    subgeoms = list(geom)
                else:
                    subgeoms = [geom]
                existing_geom = self.zipcode_geoms[zipcode]
                if not isinstance(existing_geom, MultiPolygon):
                    new_geom = MultiPolygon([existing_geom])
                    new_geom.extend(subgeoms)
                    self.zipcode_geoms[zipcode] = new_geom
                else:
                    existing_geom.extend(subgeoms)


    def import_zip(self, zipcode, display_order=0):
        if zipcode not in self.zipcode_geoms:
            import_locations.logger.info("Zipcode %s not found in shapefile" % zipcode)
            return False
        return self.create_location(zipcode, self.location_type,
                                    geom=self.zipcode_geoms[zipcode],
                                    display_order=display_order)

    def save(self):
        num_created = 0
        num_updated = 0
        sorted_zipcodes = sorted(self.zipcode_geoms.iteritems(), key=lambda x: int(x[0]))
        for i, (zipcode, geom) in enumerate(sorted_zipcodes):
            created = self.create_location(zipcode, self.location_type, geom=geom,
                                           display_order=i)
            if created:
                num_created += 1
            else:
                num_updated += 1
        return (num_created, num_updated)


def parse_args(optparser, argv):
    optparser.set_usage('usage: %prog [options] /path/to/shapefile')
    optparser.remove_option('-n')
    optparser.add_option('-n', '--name-field', dest='name_field', default='ZCTA5CE',
                         help='field that contains the zipcode\'s name')
    opts, args = optparser.parse_args(argv)
    if not opts.verbose:
        import logging
        logging.basicConfig()
        import_locations.logger.setLevel(logging.WARN)

    if len(args) != 1:
        optparser.error('must give path to shapefile')

    layer = import_locations.layer_from_shapefile(args[0], opts.layer_id)

    return layer, opts

def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]
    layer, opts = parse_args(import_locations.optparser, argv)
    importer = ZipImporter(layer, opts.name_field, opts.source, opts.filter_bounds, opts.verbose)
    num_created, num_updated = importer.save()
    if opts.verbose:
        print >> sys.stderr, 'Created %s, updated %s zipcodes.' % (num_created, num_updated)

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = update_aggregates
#!/usr/bin/env python
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Script to populate :ref:`aggregates`.
Typically run without arguments.  The ``--reset`` option will delete
all aggregates first.
"""

from django.db import connection, transaction
from ebpub.db import constants
from ebpub.db.models import Schema, SchemaField, NewsItem, AggregateAll, AggregateDay, AggregateLocationDay, AggregateLocation, AggregateFieldLookup
from ebpub.utils.dates import today
from ebpub.utils.script_utils import add_verbosity_options, setup_logging_from_opts
import logging

logger = logging.getLogger('ebpub.db.bin.update_aggregates')

def smart_update(cursor, new_values, table_name, field_names, comparable_fields,
                 where, pk_name='id', dry_run=False):
    # new_values is a list of dictionaries, each with a value for each field in field_names.

    # Run a query to determine the current values in the DB.
    where = where.items()
    cursor.execute("""
        SELECT %s, %s
        FROM %s
        WHERE %s""" % (pk_name, ','.join(field_names), table_name,
            ' AND '.join(['%s=%%s' % k for k, v in where])), tuple([v for k, v in where]))
    old_values = dict([(tuple(row[1:len(comparable_fields)+1]), dict(zip((pk_name,)+field_names, row))) for row in cursor.fetchall()])
    for new_value in new_values:
        key = tuple([new_value[i] for i in comparable_fields])
        try:
            old_value = old_values.pop(key)
        except KeyError:
            logger.debug(
                "INSERT INTO %s (%s) VALUES (%s)" % (table_name, ', '.join(field_names + tuple([i[0] for i in where])), ', '.join([str(new_value[i]) for i in field_names] + [str(i[1]) for i in where])))
            if not dry_run:
                cursor.execute("INSERT INTO %s (%s) VALUES (%s)" % \
                    (table_name, ', '.join(field_names + tuple([i[0] for i in where])), ','.join(['%s' for _ in tuple(field_names) + tuple(where)])),
                    tuple([new_value[i] for i in field_names] + [i[1] for i in where]))
        else:
            for k, v in new_value.items():
                if old_value[k] != v:
                    logger.debug(
                        "UPDATE %s SET %s WHERE %s=%s" % (table_name, ', '.join(['%s=%s' % (k, v) for k, v in new_value.items()]), pk_name, old_value[pk_name]))
                    if not dry_run:
                        new_value_tuple = new_value.items()
                        cursor.execute("UPDATE %s SET %s WHERE %s=%%s" % \
                            (table_name, ', '.join(['%s=%%s' % k for k, v in new_value_tuple]), pk_name),
                            tuple([v for k, v in new_value_tuple] + [old_value[pk_name]]))
                    break
    for old_value in old_values.values():
        logger.debug("DELETE FROM %s WHERE %s = %s" % (table_name, pk_name, old_value[pk_name]))
        if not dry_run:
            cursor.execute("DELETE FROM %s WHERE %s = %%s" % (table_name, pk_name), (old_value[pk_name],))

def update_aggregates(schema_id_or_slug, dry_run=False,  reset=False):
    """
    Updates all Aggregate* tables for the given schema_id/slug,
    deleting/updating the existing records if necessary.

    If dry_run is True, then the records won't be updated -- only the SQL
    will be output.

    If reset is True, then all aggregates for this schema will be deleted before
    updating.
    """
    logger.info('... %s' % schema_id_or_slug)
    if not str(schema_id_or_slug).isdigit():
        schema_id = Schema.objects.get(slug=schema_id_or_slug).id
    else:
        schema_id = schema_id_or_slug
    cursor = connection.cursor()

    if reset and not dry_run:
        for aggmodel in (AggregateAll, AggregateDay, AggregateLocation,
                         AggregateLocationDay, AggregateFieldLookup):
            logger.info('... deleting all %s for schema %s' % (aggmodel.__name__, schema_id_or_slug))
            aggmodel.objects.filter(schema__id=schema_id).delete()

    # AggregateAll
    cursor.execute("SELECT COUNT(*) FROM db_newsitem WHERE schema_id = %s", (schema_id,))
    new_values = [{'total': row[0]} for row in cursor.fetchall()]
    smart_update(cursor, new_values, AggregateAll._meta.db_table, ('total',),
                 (), {'schema_id': schema_id}, dry_run=dry_run)

    # AggregateDay
    cursor.execute("""
        SELECT item_date, COUNT(*)
        FROM db_newsitem
        WHERE schema_id = %s
        GROUP BY 1""", (schema_id,))
    new_values = [{'date_part': row[0], 'total': row[1]} for row in cursor.fetchall()]
    smart_update(cursor, new_values, AggregateDay._meta.db_table, ('date_part', 'total'),
                 ('date_part',), {'schema_id': schema_id}, dry_run=dry_run,
                 )

    # AggregateLocationDay
    cursor.execute("""
        SELECT nl.location_id, ni.item_date, loc.location_type_id, COUNT(*)
        FROM db_newsitemlocation nl, db_newsitem ni, db_location loc
        WHERE nl.news_item_id = ni.id
            AND ni.schema_id = %s
            AND nl.location_id = loc.id
        GROUP BY 1, 2, 3""", (schema_id,))
    new_values = [{'location_id': row[0], 'date_part': row[1], 'location_type_id': row[2], 'total': row[3]} for row in cursor.fetchall()]
    smart_update(cursor, new_values, AggregateLocationDay._meta.db_table, ('location_id', 'date_part', 'location_type_id', 'total'),
                 ('location_id', 'date_part', 'location_type_id'),
                 {'schema_id': schema_id}, dry_run=dry_run,
                 )

    # AggregateLocation
    # This query is a bit clever -- we just sum up the totals created in a
    # previous aggregate. It's a helpful optimization, because otherwise
    # the location query is way too slow.
    # Note that we calculate the total for the last 30 days that had at least
    # one news item -- *NOT* the last 30 days, period.
    # We add date_part <= current_date here to keep sparse items in the future
    # from throwing off counts for the previous 30 days.
    cursor.execute("SELECT date_part FROM %s WHERE schema_id = %%s AND date_part <= current_date ORDER BY date_part DESC LIMIT 1" % \
        AggregateLocationDay._meta.db_table, (schema_id,))
    try:
        end_date = cursor.fetchone()[0]
    except TypeError: # if cursor.fetchone() is None, there are no records.
        pass
    else:
        # Note that BETWEEN is inclusive on both ends, so to get
        # AggregateLocationDays for eg. 30 days, we'd need a timedelta of 29
        start_date = end_date - constants.DAYS_AGGREGATE_TIMEDELTA
        cursor.execute("""
            SELECT location_id, location_type_id, SUM(total)
            FROM %s
            WHERE schema_id = %%s
                AND date_part BETWEEN %%s AND %%s
            GROUP BY 1, 2""" % AggregateLocationDay._meta.db_table,
                (schema_id, start_date, end_date))
        new_values = [{'location_id': row[0], 'location_type_id': row[1], 'total': row[2]} for row in cursor.fetchall()]
        smart_update(cursor, new_values, AggregateLocation._meta.db_table,
                     ('location_id', 'location_type_id', 'total'),
                     ('location_id', 'location_type_id'), {'schema_id': schema_id},
                     dry_run=dry_run,
                     )

    for sf in SchemaField.objects.filter(schema__id=schema_id, is_filter=True, is_lookup=True):
        try:
            end_date = NewsItem.objects.filter(schema__id=schema_id, item_date__lte=today()).values_list('item_date', flat=True).order_by('-item_date')[0]
        except IndexError:
            continue # There have been no NewsItems in the given date range.
        # Note BETWEEN is inclusive on both ends.
        start_date = end_date - constants.DAYS_AGGREGATE_TIMEDELTA

        if sf.is_many_to_many_lookup():
            # AggregateFieldLookup
            cursor.execute("""
                SELECT id, (
                    SELECT COUNT(*) FROM db_attribute a, db_newsitem ni
                    WHERE a.news_item_id = ni.id
                        AND a.schema_id = %%s
                        AND ni.schema_id = %%s
                        AND a.%s ~ ('[[:<:]]' || db_lookup.id || '[[:>:]]')
                        AND ni.item_date BETWEEN %%s AND %%s
                )
                FROM db_lookup
                WHERE schema_field_id = %%s""" % sf.real_name, (schema_id, schema_id, start_date, end_date, sf.id))
            new_values = [{'lookup_id': row[0], 'total': row[1]} for row in cursor.fetchall()]
            smart_update(cursor, new_values, AggregateFieldLookup._meta.db_table,
                         ('lookup_id', 'total'), ('lookup_id',),
                         {'schema_id': schema_id, 'schema_field_id': sf.id},
                         dry_run=dry_run,
                         )
        else:
            # AggregateFieldLookup
            cursor.execute("""
                SELECT a.%s, COUNT(*)
                FROM db_attribute a, db_newsitem ni
                WHERE a.news_item_id = ni.id
                    AND a.schema_id = %%s
                    AND ni.schema_id = %%s
                    AND %s IS NOT NULL
                    AND ni.item_date BETWEEN %%s AND %%s
                GROUP BY 1""" % (sf.real_name, sf.real_name), (schema_id, schema_id, start_date, end_date))
            new_values = [{'lookup_id': row[0], 'total': row[1]} for row in cursor.fetchall()]
            smart_update(cursor, new_values, AggregateFieldLookup._meta.db_table,
                         ('lookup_id', 'total'), ('lookup_id',),
                         {'schema_id': schema_id, 'schema_field_id': sf.id},
                         dry_run=dry_run)

    transaction.commit_unless_managed()

def update_all_aggregates(dry_run=False, reset=False):
    for schema in Schema.objects.all():
        if dry_run:
            logger.info('Dry run: Updating %s aggregates' % schema.plural_name)
        elif reset:
            logger.info('Resetting all %s aggregates' % schema.plural_name)
        else:
            logger.info('Updating %s aggregates' % schema.plural_name)
        update_aggregates(schema.id, dry_run=dry_run, reset=reset)

def main(argv=None):
    import sys
    if argv is None:
        argv = sys.argv[1:]
    from optparse import OptionParser
    optparser = OptionParser(usage='''usage: %prog [options] [schema]

Updates aggregate statistics for the given schema (default: all schemas).
''')
    optparser.add_option('-r', '--reset', action='store_true',
                         help='Delete all aggregates before updating.')

    add_verbosity_options(optparser)

    optparser.add_option('-d', '--dry-run', action='store_true',
                         help='Dry run, change nothing.')

    opts, args = optparser.parse_args(argv)


    setup_logging_from_opts(opts, logger)

    if args:
        return update_aggregates(*args, reset=opts.reset, dry_run=opts.dry_run)
    else:
        return update_all_aggregates(reset=opts.reset, dry_run=opts.dry_run)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = breadcrumbs
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Breadcrumbs helpers.
These functions return lists of (label, url) pairs.
"""

from django.core import urlresolvers
from ebpub.metros.allmetros import get_metro

def home(context):
    return [(get_metro()['metro_name'], urlresolvers.reverse('ebpub-homepage'),)]

def location_type_detail(context):
    crumbs = home(context)
    location_type = context['location_type']
    crumbs.append((location_type.plural_name, location_type.url()))
    return crumbs

def street_list(context):
    crumbs = home(context)
    crumbs.append((u'Streets', '/streets/'))
    if get_metro()['multiple_cities']: # XXX UNTESTED
        city = context.get('city')
        if city is None:
            if context.get('place_type') == 'block':
                city = context['place'].city_object()
            else:
                assert False, "context has neither city nor a place from which to get it"
        crumbs.append((city.name, "/streets/%s/" % city.slug))
    return crumbs

def block_list(context):
    block = context.get('first_block')
    if block is None:
        if context.get('place_type') == 'block':
            block = context['place']
        else:
            assert False, "context has neither first_block nor a block-type place"
    crumbs = street_list(context)
    crumbs.append((block.street_pretty_name, block.street_url()))
    return crumbs

def place_base(context):
    place = context['place']
    if context['is_block']:
        crumbs = block_list(context)
    else:
        context['location_type'] = place.location_type
        crumbs = location_type_detail(context)
    crumbs.append((place.pretty_name, place.url()))
    return crumbs

def place_detail_timeline(context):
    crumbs =  place_base(context)
    crumbs.append(('Recent: Everything', ''))
    return crumbs

def place_detail_upcoming(context):
    crumbs =  place_base(context)
    crumbs.append(('Upcoming: Everything', ''))
    return crumbs

def place_detail_overview(context):
    crumbs =  place_base(context)
    crumbs.append(('Overview', ''))
    return crumbs


def schema_detail(context):
    crumbs = home(context)
    schema = context['schema']
    crumbs.append((schema.plural_name,
                   urlresolvers.reverse('ebpub-schema-detail', args=(context['schema'].slug,))))
    return crumbs

def schema_about(context):
    crumbs = schema_detail(context)
    crumbs.append(('About',
                   urlresolvers.reverse('ebpub-schema-about', args=(context['schema'].slug,))))
    return crumbs

def schema_filter(context):
    crumbs = schema_detail(context)
    crumbs.append(('Search', ''))
    # This one's a generator because we want to evaluate it lazily,
    # and django's 'for' template tag doesn't accept callables.
    for crumb in crumbs:
        yield crumb

def newsitem_detail(context):
    context['schema'] = context['newsitem'].schema
    return schema_filter(context)

########NEW FILE########
__FILENAME__ = constants
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Various numbers that appear throughout the code but don't
change often enough to warrant going in settings.py.
"""

# The number of days to use in sparklines.
# A sparkline, in this context, is the aggregate view of
# how many NewsItems were added per page.
NUM_DAYS_AGGREGATE = 30

# A timedelta that can be added to an end date to get a start date
# that gives NUM_DAYS_AGGREGATE days total, *inclusive*.
# This was hardcoded in a few places, leading to several mismatches
# between expected date ranges.
import datetime
DAYS_AGGREGATE_TIMEDELTA = datetime.timedelta(days=NUM_DAYS_AGGREGATE - 1)

# A shorter span for use where there's not so much room,
# eg. in the ajax views used by place_detail_overview.
NUM_DAYS_SHORT_AGGREGATE = 10
DAYS_SHORT_AGGREGATE_TIMEDELTA = datetime.timedelta(days=NUM_DAYS_SHORT_AGGREGATE-1)

# Number of results per page in the schema_filter view.
FILTER_PER_PAGE = 30

# Number of NewsItems to fetch for place_detail.
NUM_NEWS_ITEMS_PLACE_DETAIL = 300

# Regular expression that parses block-page URLs. The last part of it is for
# the optional pre-directional and/or post-directional (for example,
# 'n', 'ne', 'n-w', '-sw').
BLOCK_URL_REGEX = r'(\d{1,6})-(\d{1,6})([nsew]{1,2})?(?:-([nsew]{0,2}))?'

# How long the Schema managers should cache allowed_schema_ids()
ALLOWED_IDS_CACHE_TIME = 60 * 10

########NEW FILE########
__FILENAME__ = context_processors
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
ebpub-specific data needed by various templates.
"""

from django.conf import settings
from django.utils import simplejson
from ebpub.db.utils import today

def _get_map_media():
    from olwidget.widgets import Map
    layers = [settings.MAP_BASELAYER_TYPE]
    map_media = Map([], options={'layers': layers}).media
    return map_media.render()

def _get_extra_layers():
    layers = getattr(settings, 'MAP_CUSTOM_BASE_LAYERS', [])
    return simplejson.dumps(layers, indent=2)

def map_context(request):
    """
    Context variables needed on pages that use maps.
    """
    # XXX TODO: can we slim or at least version the olwidget JS & CSS?
    # note they are set as settings.OLWIDGET_JS and settings.OLWIDGET_CSS,
    # could possibly munge those?
    return {'OPENLAYERS_IMG_PATH': settings.OPENLAYERS_IMG_PATH,
            'JQUERY_URL': settings.JQUERY_URL,
            'MAP_MEDIA_HTML': _get_map_media,
            'MAP_CUSTOM_BASE_LAYERS': _get_extra_layers,
            'MAP_BASELAYER_TYPE': settings.MAP_BASELAYER_TYPE,
            'alerts_installed': 'ebpub.alerts' in settings.INSTALLED_APPS,
            'today': today(),
            }

def settings_context(request):
    return {
        'EB_DOMAIN':  settings.EB_DOMAIN,
        }


########NEW FILE########
__FILENAME__ = feeds
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#


from django.conf import settings
from django.contrib.syndication.views import Feed
from django.http import Http404
from django.utils.feedgenerator import Rss201rev2Feed
from ebpub.db.models import NewsItem, Location
from ebpub.db.utils import populate_attributes_if_needed
from ebpub.db.utils import make_search_buffer, url_to_block, BLOCK_RADIUS_CHOICES, BLOCK_RADIUS_DEFAULT
from ebpub.streets.models import Block
from ebpub.utils.dates import today
import datetime
import re

# RSS feeds powered by Django's syndication framework use MIME type
# 'application/rss+xml'. That's unacceptable to us, because that MIME type
# prompts users to download the feed in some browsers, which is confusing.
# Here, we set the MIME type so that it doesn't do that prompt.
class CorrectMimeTypeFeed(Rss201rev2Feed):
    mime_type = 'application/xml'

# This is a django.contrib.syndication.feeds.Feed subclass whose feed_type
# is set to our preferred MIME type.
class EbpubFeed(Feed):
    feed_type = CorrectMimeTypeFeed

location_re = re.compile(r'^([-_a-z0-9]{1,32})/([-_a-z0-9]{1,32})$')

def bunch_by_date_and_schema(newsitem_list, date_cutoff):
    current_schema_date, current_list = None, []
    for ni in newsitem_list:
        # Remove collapsable newsitems that shouldn't be published in the
        # feed yet. See the lengthy comment in AbstractLocationFeed.items().
        if ni.schema.can_collapse and ni.item_date >= date_cutoff:
            continue

        if current_schema_date != (ni.schema, ni.item_date):
            if current_list:
                yield current_list
            current_schema_date = (ni.schema, ni.item_date)
            current_list = [ni]
        else:
            current_list.append(ni)
    if current_list:
        yield current_list

class AbstractLocationFeed(EbpubFeed):
    """
    Abstract base class for :py:class:`ebpub.db.models.Location`-aware RSS feeds.
    """

    title_template = 'feeds/streets_title.html'
    description_template = 'feeds/streets_description.html'

    def items(self, obj):
        # Note that items() returns "packed" tuples instead of objects.
        # This is necessary because we return NewsItems and blog entries,
        # plus different types of NewsItems (bunched vs. unbunched).

        # Limit the feed to all NewsItems published in the last four days.
        # We *do* include items from today in this query, but we'll filter
        # those later in this method so that only today's *uncollapsed* items
        # (schema.can_collapse=False) will be included in the feed. We don't
        # want today's *collapsed* items to be included, because more items
        # might be added to the database before the day is finished, and
        # that would result in the RSS item being updated multiple times, which
        # is annoying.

        # TODO: re-use ebpub.db.schemafilters for filtering here.

        # TODO: allow user control over date range
        today_value = today()
        start_date = today_value - datetime.timedelta(days=5)
        # Include future stuff, useful for events
        end_date = today_value + datetime.timedelta(days=5)

        qs = NewsItem.objects.select_related().by_request(self.request).filter(
            item_date__gte=start_date,
            item_date__lte=end_date).order_by('-item_date', 'schema__id', 'id')

        # Filter out ignored schemas -- those whose slugs are specified in
        # the "ignore" query-string parameter.
        if 'ignore' in self.request.GET:
            schema_slugs = self.request.GET['ignore'].split(',')
            qs = qs.exclude(schema__slug__in=schema_slugs)

        # Filter wanted schemas -- those whose slugs are specified in the
        # "only" query-string parameter.
        if 'only' in self.request.GET:
            schema_slugs = self.request.GET['only'].split(',')
            qs = qs.filter(schema__slug__in=schema_slugs)

        block_radius = self.request.GET.get('radius', BLOCK_RADIUS_DEFAULT)
        if block_radius not in BLOCK_RADIUS_CHOICES:
            raise Http404('Invalid radius')
        ni_list = list(self.newsitems_for_obj(obj, qs, block_radius))
        schema_list = list(set([ni.schema for ni in ni_list]))
        populate_attributes_if_needed(ni_list, schema_list)

        is_block = isinstance(obj, Block)

        # Note that this decorates the results by returning tuples instead of
        # NewsItems. This is necessary because we're bunching.
        for schema_group in bunch_by_date_and_schema(ni_list, today_value):
            schema = schema_group[0].schema
            if schema.can_collapse:
                yield ('newsitem', obj, schema, schema_group, is_block, block_radius)
            else:
                for newsitem in schema_group:
                    yield ('newsitem', obj, schema, newsitem, is_block, block_radius)

    def item_pubdate(self, item):
        if item[0] == 'newsitem':
            # Returning pub_date here because we need a datetime, not a date.
            # XXX That's potentially confusing since we use item_date elsewhere.
            # See ticket #77.
            if item[2].can_collapse:
                return item[3][0].pub_date
            return item[3].pub_date
        else:
            raise NotImplementedError()

    def item_link(self, item):
        if item[0] == 'newsitem':
            if item[2].can_collapse:
                return item[1].url() + '#%s-%s' % (item[3][0].schema.slug, item[3][0].item_date.strftime('%Y%m%d'))
            return item[3].item_url_with_domain()
        else:
            raise NotImplementedError()

    def newsitems_for_obj(self, obj, qs, block_radius):
        """Get the relevant NewsItems as a queryset.
        """
        raise NotImplementedError('Subclasses must implement this.')

    def link(self, obj):
        return 'http://%s%s' % (settings.EB_DOMAIN, obj.url())

    def feed_url(self, obj):
        # I only see this in django docs as a keyword arg, but it's apparently
        # used by <atom:link rel="self">; without this, that link
        # is generited by the current Site, which openblock doesn't use.
        return self.link(obj)


class BlockFeed(AbstractLocationFeed):

    def get_object(self, request, city_slug, street_slug, from_num, to_num,
                   predir, postdir):
        self.request = request
        return url_to_block(city_slug, street_slug, from_num, to_num, predir, postdir)

    def title(self, obj):
        return u"OpenBlock: %s" % obj.pretty_name

    def description(self, obj):
        return u"OpenBlock: %s" % obj.pretty_name

    def newsitems_for_obj(self, obj, qs, block_radius):
        search_buffer = make_search_buffer(obj.location.centroid, block_radius)
        return qs.filter(location__bboverlaps=search_buffer)


class LocationFeed(AbstractLocationFeed):

    def get_object(self, request, type_slug, slug):
        self.request = request
        return Location.objects.select_related().get(location_type__slug=type_slug,
                                                     slug=slug)

    def title(self, obj):
        return u"OpenBlock: %s" % obj.name

    def description(self, obj):
        return u"OpenBlock %s" % obj.name

    def newsitems_for_obj(self, obj, qs, block_radius):
        return qs.filter(newsitemlocation__location__id=obj.id)

########NEW FILE########
__FILENAME__ = fields
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Custom Fields for OpenBlock models.

"""
from django.conf import settings

from easy_thumbnails.fields import ThumbnailerImageField
class OpenblockImageField(ThumbnailerImageField):
    """
    A model Field based on ThumbnailerImageField that makes sure we
    save a correct *relative* filename.

    Uses :py:class:`OpenblockImageFormField` as its formfield.
    """
    def generate_filename(self, instance, name):
        # Save it as relative, not absolute, because absolute paths in
        # the db are A) foolishly not portable and B) too long.
        path = super(OpenblockImageField, self).generate_filename(instance, name)
        if path.startswith(settings.MEDIA_ROOT):
            path = path[len(settings.MEDIA_ROOT) + 1:]
        return path

    def formfield(self, **kwargs):
        kwargs.setdefault('form_class', OpenblockImageFormField)
        return super(OpenblockImageField, self).formfield(**kwargs)

from django.forms.fields import ImageField
class OpenblockImageFormField(ImageField):
    """
    A version of ImageField that fixes EXIF rotation on upload, so
    eg. mobile phone photos will have the correct orientation.
    """
    def to_python(self, value):
        """
        Fixes rotation if needed.
        """
        image = super(OpenblockImageFormField, self).to_python(value)
        if not image:
            return image
        from ebpub.utils.image_utils import rotate_image_by_exif
        from PIL import Image
        pil_img = Image.open(image)
        rotated = rotate_image_by_exif(pil_img)
        if not (rotated is pil_img):
            image.seek(0)
            rotated.save(image)
        return image



########NEW FILE########
__FILENAME__ = forms
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Custom Forms for ebpub.db.models.
"""

from ebpub.db import models
from django import forms
import dateutil.parser

class NewsItemForm(forms.ModelForm):
    class Meta:
        model = models.NewsItem

    # This one is a m2m field with a 'through' model, so you can't
    # assign to it directly.
    exclude = ('location_set',)

    url = forms.URLField(widget=forms.TextInput(attrs={'size': 80}), required=False)

    def _clean_fields(self):
        # Pre-parse things that should be dates, this allows
        # us to handle more formats.
        # This must be done in clean_fields because
        # weirdly self.clean_item_date() happens too late.
        # Could also fix by overriding the widget, but, meh.
        if 'item_date' in self.data:
            try:
                self.data['item_date'] = dateutil.parser.parse(self.data['item_date']).date()
            except (ValueError, AttributeError):
                pass
        if 'pub_date' in self.data:
            try:
                self.data['pub_date'] = dateutil.parser.parse(self.data['pub_date'])
            except (ValueError, AttributeError):
                pass
        return super(NewsItemForm, self)._clean_fields()

    def clean(self):
        # Remove this from cleaned_data, otherwise form.save() will
        # try to assign it, even if it's in self.exclude ... and
        # that's an error since it has a 'through' model.  Seems odd,
        # maybe django should check the exclude list? shrug.
        self.cleaned_data.pop('location_set', None)
        return self.cleaned_data

########NEW FILE########
__FILENAME__ = show_urls
# Taken from django-extensions.
# https://github.com/django-extensions/
# Copyright (c) 2007 Michael Trier
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

from django.conf import settings
from django.core.exceptions import ViewDoesNotExist
from django.core.urlresolvers import RegexURLPattern, RegexURLResolver
from django.core.management.base import BaseCommand
from django.utils.translation import ugettext as _
from optparse import make_option

try:
    # 2008-05-30 admindocs found in newforms-admin brand
    from django.contrib.admindocs.views import simplify_regex
except ImportError:
    # fall back to trunk, pre-NFA merge
    from django.contrib.admin.views.doc import simplify_regex
import re


#from django_extensions.management.color import color_style
from django.core.management import color
from django.utils import termcolors


def color_style():
    style = color.color_style()
    if color.supports_color():
        style.URL = termcolors.make_style(fg='green', opts=('bold',))
        style.MODULE = termcolors.make_style(fg='yellow')
        style.MODULE_NAME = termcolors.make_style(opts=('bold',))
        style.URL_NAME = termcolors.make_style(fg='red')
    return style

def extract_views_from_urlpatterns(urlpatterns, base=''):
    """
    Return a list of views from a list of urlpatterns.

    Each object in the returned list is a two-tuple: (view_func, regex)
    """
    views = []
    for p in urlpatterns:
        if isinstance(p, RegexURLPattern):
            try:
                views.append((p.callback, base + p.regex.pattern, p.name))
            except ViewDoesNotExist:
                continue
        elif isinstance(p, RegexURLResolver):
            try:
                patterns = p.url_patterns
            except ImportError:
                continue
            views.extend(extract_views_from_urlpatterns(patterns, base + p.regex.pattern))
        elif hasattr(p, '_get_callback'):
            try:
                views.append((p._get_callback(), base + p.regex.pattern, p.name))
            except ViewDoesNotExist:
                continue
        elif hasattr(p, 'url_patterns') or hasattr(p, '_get_url_patterns'):
            try:
                patterns = p.url_patterns
            except ImportError:
                continue
            views.extend(extract_views_from_urlpatterns(patterns, base + p.regex.pattern))
        else:
            raise TypeError, _("%s does not appear to be a urlpattern object") % p
    return views


class _Command(BaseCommand):
    options_list = BaseCommand.option_list + (
        make_option("--unsorted", "-u", action="store_true", dest="unsorted",
                    help="Show urls unsorted but same order as found in url patterns"),
    )

    help = "Displays all of the url matching routes for the project."

    requires_model_validation = True

    def handle(self, *args, **options):
        if args:
            appname, = args

        style = color_style()

        if settings.ADMIN_FOR:
            settings_modules = [__import__(m, {}, {}, ['']) for m in settings.ADMIN_FOR]
        else:
            settings_modules = [settings]

        views = []
        for settings_mod in settings_modules:
            try:
                urlconf = __import__(settings_mod.ROOT_URLCONF, {}, {}, [''])
            except Exception, e:
                if options.get('traceback', None):
                    import traceback
                    traceback.print_exc()
                print style.ERROR("Error occurred while trying to load %s: %s" % (settings_mod.ROOT_URLCONF, str(e)))
                continue
            view_functions = extract_views_from_urlpatterns(urlconf.urlpatterns)
            for (func, regex, url_name) in view_functions:
                if hasattr(func, '__name__'):
                    func_name = func.__name__
                elif hasattr(func, '__class__'):
                    func_name = '%s()' % func.__class__.__name__
                else:
                    func_name = re.sub(r' at 0x[0-9a-f]+', '', repr(func))
                views.append("%(url)s\t%(module)s.%(name)s\t%(url_name)s" % {'name': style.MODULE_NAME(func_name),
                                       'module': style.MODULE(func.__module__),
                                       'url_name': style.URL_NAME(url_name or ''),
                                       'url': style.URL(simplify_regex(regex))})
        if not getattr(options, 'unsorted', False):
            views = sorted(views)
        return "\n".join([v for v in views]) + "\n"


try:
    from django.extensions.management.commands.show_urls import Command
except ImportError:
    Command = _Command

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    depends_on = (
        ("streets", "0001_initial"),
    )



    def forwards(self, orm):
        
        # Adding model 'Schema'
        db.create_table('db_schema', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=32)),
            ('plural_name', self.gf('django.db.models.fields.CharField')(max_length=32)),
            ('indefinite_article', self.gf('django.db.models.fields.CharField')(max_length=2)),
            ('slug', self.gf('django.db.models.fields.CharField')(unique=True, max_length=32)),
            ('min_date', self.gf('django.db.models.fields.DateField')()),
            ('last_updated', self.gf('django.db.models.fields.DateField')()),
            ('date_name', self.gf('django.db.models.fields.CharField')(default='Date', max_length=32)),
            ('date_name_plural', self.gf('django.db.models.fields.CharField')(default='Dates', max_length=32)),
            ('importance', self.gf('django.db.models.fields.SmallIntegerField')(default=0)),
            ('is_public', self.gf('django.db.models.fields.BooleanField')(default=False, db_index=True)),
            ('is_special_report', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('can_collapse', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('has_newsitem_detail', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('allow_charting', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('uses_attributes_in_list', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('number_in_overview', self.gf('django.db.models.fields.SmallIntegerField')(default=5)),
            ('short_description', self.gf('django.db.models.fields.TextField')(default='', blank=True)),
            ('summary', self.gf('django.db.models.fields.TextField')(default='', blank=True)),
            ('source', self.gf('django.db.models.fields.TextField')(default='', blank=True)),
            ('grab_bag_headline', self.gf('django.db.models.fields.CharField')(default='', max_length=128, blank=True)),
            ('grab_bag', self.gf('django.db.models.fields.TextField')(default='', blank=True)),
            ('short_source', self.gf('django.db.models.fields.CharField')(default='', max_length=128, blank=True)),
            ('update_frequency', self.gf('django.db.models.fields.CharField')(default='', max_length=64, blank=True)),
            ('intro', self.gf('django.db.models.fields.TextField')(default='', blank=True)),
        ))
        db.send_create_signal('db', ['Schema'])

        # Adding model 'SchemaField'
        db.create_table('db_schemafield', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('schema', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Schema'])),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=32)),
            ('real_name', self.gf('django.db.models.fields.CharField')(max_length=10)),
            ('pretty_name', self.gf('django.db.models.fields.CharField')(max_length=32)),
            ('pretty_name_plural', self.gf('django.db.models.fields.CharField')(max_length=32)),
            ('display', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('is_lookup', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('is_filter', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('is_charted', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('display_order', self.gf('django.db.models.fields.SmallIntegerField')(default=10)),
            ('is_searchable', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('db', ['SchemaField'])

        # Adding unique constraint on 'SchemaField', fields ['schema', 'real_name']
        db.create_unique('db_schemafield', ['schema_id', 'real_name'])

        # Adding model 'LocationType'
        db.create_table('db_locationtype', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('plural_name', self.gf('django.db.models.fields.CharField')(max_length=64)),
            ('scope', self.gf('django.db.models.fields.CharField')(max_length=64)),
            ('slug', self.gf('django.db.models.fields.CharField')(unique=True, max_length=32)),
            ('is_browsable', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('is_significant', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('db', ['LocationType'])

        # Adding model 'Location'
        db.create_table('db_location', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('normalized_name', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('slug', self.gf('django.db.models.fields.CharField')(max_length=32, db_index=True)),
            ('location_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.LocationType'])),
            ('location', self.gf('django.contrib.gis.db.models.fields.GeometryField')(null=True)),
            ('centroid', self.gf('django.contrib.gis.db.models.fields.PointField')(null=True, blank=True)),
            ('display_order', self.gf('django.db.models.fields.SmallIntegerField')()),
            ('city', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('source', self.gf('django.db.models.fields.CharField')(max_length=64)),
            ('area', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('population', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('user_id', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('is_public', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('creation_date', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('last_mod_date', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
        ))
        db.send_create_signal('db', ['Location'])

        # Adding unique constraint on 'Location', fields ['slug', 'location_type']
        db.create_unique('db_location', ['slug', 'location_type_id'])

        # Adding model 'NewsItem'
        db.create_table('db_newsitem', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('schema', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Schema'])),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('description', self.gf('django.db.models.fields.TextField')()),
            ('url', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('pub_date', self.gf('django.db.models.fields.DateTimeField')(db_index=True)),
            ('item_date', self.gf('django.db.models.fields.DateField')(db_index=True)),
            ('location', self.gf('django.contrib.gis.db.models.fields.GeometryField')(null=True, blank=True)),
            ('location_name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('location_object', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Location'], null=True, blank=True)),
            ('block', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['streets.Block'], null=True, blank=True)),
        ))
        db.send_create_signal('db', ['NewsItem'])

        # Adding model 'Attribute'
        db.create_table('db_attribute', (
            ('news_item', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['db.NewsItem'], unique=True, primary_key=True)),
            ('schema', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Schema'])),
            ('varchar01', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('varchar02', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('varchar03', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('varchar04', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('varchar05', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('date01', self.gf('django.db.models.fields.DateField')(null=True, blank=True)),
            ('date02', self.gf('django.db.models.fields.DateField')(null=True, blank=True)),
            ('date03', self.gf('django.db.models.fields.DateField')(null=True, blank=True)),
            ('date04', self.gf('django.db.models.fields.DateField')(null=True, blank=True)),
            ('date05', self.gf('django.db.models.fields.DateField')(null=True, blank=True)),
            ('time01', self.gf('django.db.models.fields.TimeField')(null=True, blank=True)),
            ('time02', self.gf('django.db.models.fields.TimeField')(null=True, blank=True)),
            ('datetime01', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('datetime02', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('datetime03', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('datetime04', self.gf('django.db.models.fields.DateTimeField')(null=True, blank=True)),
            ('bool01', self.gf('django.db.models.fields.NullBooleanField')(null=True, blank=True)),
            ('bool02', self.gf('django.db.models.fields.NullBooleanField')(null=True, blank=True)),
            ('bool03', self.gf('django.db.models.fields.NullBooleanField')(null=True, blank=True)),
            ('bool04', self.gf('django.db.models.fields.NullBooleanField')(null=True, blank=True)),
            ('bool05', self.gf('django.db.models.fields.NullBooleanField')(null=True, blank=True)),
            ('int01', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('int02', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('int03', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('int04', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('int05', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('int06', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('int07', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('text01', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
        ))
        db.send_create_signal('db', ['Attribute'])

        # Adding model 'Lookup'
        db.create_table('db_lookup', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('schema_field', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.SchemaField'])),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('code', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
            ('slug', self.gf('django.db.models.fields.CharField')(max_length=32, db_index=True)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
        ))
        db.send_create_signal('db', ['Lookup'])

        # Adding unique constraint on 'Lookup', fields ['slug', 'schema_field']
        db.create_unique('db_lookup', ['slug', 'schema_field_id'])

        # Adding model 'NewsItemLocation'
        db.create_table('db_newsitemlocation', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('news_item', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.NewsItem'])),
            ('location', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Location'])),
        ))
        db.send_create_signal('db', ['NewsItemLocation'])

        # Adding unique constraint on 'NewsItemLocation', fields ['news_item', 'location']
        db.create_unique('db_newsitemlocation', ['news_item_id', 'location_id'])

        # Adding model 'AggregateAll'
        db.create_table('db_aggregateall', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('schema', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Schema'])),
            ('total', self.gf('django.db.models.fields.IntegerField')()),
        ))
        db.send_create_signal('db', ['AggregateAll'])

        # Adding model 'AggregateDay'
        db.create_table('db_aggregateday', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('schema', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Schema'])),
            ('total', self.gf('django.db.models.fields.IntegerField')()),
            ('date_part', self.gf('django.db.models.fields.DateField')(db_index=True)),
        ))
        db.send_create_signal('db', ['AggregateDay'])

        # Adding model 'AggregateLocation'
        db.create_table('db_aggregatelocation', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('schema', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Schema'])),
            ('total', self.gf('django.db.models.fields.IntegerField')()),
            ('location_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.LocationType'])),
            ('location', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Location'])),
        ))
        db.send_create_signal('db', ['AggregateLocation'])

        # Adding model 'AggregateLocationDay'
        db.create_table('db_aggregatelocationday', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('schema', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Schema'])),
            ('total', self.gf('django.db.models.fields.IntegerField')()),
            ('location_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.LocationType'])),
            ('location', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Location'])),
            ('date_part', self.gf('django.db.models.fields.DateField')(db_index=True)),
        ))
        db.send_create_signal('db', ['AggregateLocationDay'])

        # Adding model 'AggregateFieldLookup'
        db.create_table('db_aggregatefieldlookup', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('schema', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Schema'])),
            ('total', self.gf('django.db.models.fields.IntegerField')()),
            ('schema_field', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.SchemaField'])),
            ('lookup', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Lookup'])),
        ))
        db.send_create_signal('db', ['AggregateFieldLookup'])

        # Adding model 'SearchSpecialCase'
        db.create_table('db_searchspecialcase', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('query', self.gf('django.db.models.fields.CharField')(unique=True, max_length=64)),
            ('redirect_to', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=128, blank=True)),
            ('body', self.gf('django.db.models.fields.TextField')(blank=True)),
        ))
        db.send_create_signal('db', ['SearchSpecialCase'])

        # Adding model 'DataUpdate'
        db.create_table('db_dataupdate', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('schema', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Schema'])),
            ('update_start', self.gf('django.db.models.fields.DateTimeField')()),
            ('update_finish', self.gf('django.db.models.fields.DateTimeField')()),
            ('num_added', self.gf('django.db.models.fields.IntegerField')()),
            ('num_changed', self.gf('django.db.models.fields.IntegerField')()),
            ('num_deleted', self.gf('django.db.models.fields.IntegerField')()),
            ('num_skipped', self.gf('django.db.models.fields.IntegerField')()),
            ('got_error', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('db', ['DataUpdate'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'NewsItemLocation', fields ['news_item', 'location']
        db.delete_unique('db_newsitemlocation', ['news_item_id', 'location_id'])

        # Removing unique constraint on 'Lookup', fields ['slug', 'schema_field']
        db.delete_unique('db_lookup', ['slug', 'schema_field_id'])

        # Removing unique constraint on 'Location', fields ['slug', 'location_type']
        db.delete_unique('db_location', ['slug', 'location_type_id'])

        # Removing unique constraint on 'SchemaField', fields ['schema', 'real_name']
        db.delete_unique('db_schemafield', ['schema_id', 'real_name'])

        # Deleting model 'Schema'
        db.delete_table('db_schema')

        # Deleting model 'SchemaField'
        db.delete_table('db_schemafield')

        # Deleting model 'LocationType'
        db.delete_table('db_locationtype')

        # Deleting model 'Location'
        db.delete_table('db_location')

        # Deleting model 'NewsItem'
        db.delete_table('db_newsitem')

        # Deleting model 'Attribute'
        db.delete_table('db_attribute')

        # Deleting model 'Lookup'
        db.delete_table('db_lookup')

        # Deleting model 'NewsItemLocation'
        db.delete_table('db_newsitemlocation')

        # Deleting model 'AggregateAll'
        db.delete_table('db_aggregateall')

        # Deleting model 'AggregateDay'
        db.delete_table('db_aggregateday')

        # Deleting model 'AggregateLocation'
        db.delete_table('db_aggregatelocation')

        # Deleting model 'AggregateLocationDay'
        db.delete_table('db_aggregatelocationday')

        # Deleting model 'AggregateFieldLookup'
        db.delete_table('db_aggregatefieldlookup')

        # Deleting model 'SearchSpecialCase'
        db.delete_table('db_searchspecialcase')

        # Deleting model 'DataUpdate'
        db.delete_table('db_dataupdate')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0002_initial_statistics
# encoding: utf-8
import datetime
from south.db import dbs
from south.v2 import DataMigration
from django.db import models
from django.db import router

def get_db(orm, model):
    dbname = router.db_for_write(orm[model])
    return dbs[dbname]

class Migration(DataMigration):

    def forwards(self, orm):
        """
        AFAICT this is a query-planner optimization: The default
        STATISTICS level is 10.  Lowering it means: Do less work
        generating stats on this column, because it has a "simple
        distribution" (eg. just a few possible integer values), so we
        don't need to expend much time or space on helping out the
        query planner.

        Conversely, raising it means do more work (and store more
        stats) so the query planner has a better shot at making a fast
        query.

        Presumably, somebody at everyblock.com found that this
        improved performance.  See
        http://www.postgresql.org/docs/8.2/static/planner-stats.html
        and
        http://www.postgresql.org/docs/8.2/static/runtime-config-query.html

        """
        db = get_db(orm, 'db.Attribute')
        db.execute("ALTER TABLE db_attribute ALTER COLUMN schema_id SET STATISTICS 5")
        db = get_db(orm, 'db.Location')
        db.execute("ALTER TABLE db_location ALTER COLUMN location_type_id SET STATISTICS 5")
        db.execute("ALTER TABLE db_location ALTER COLUMN location SET STATISTICS 75")
        db = get_db(orm, 'db.LocationType')
        db.execute("ALTER TABLE db_locationtype ALTER COLUMN id SET STATISTICS 5")
        db = get_db(orm, 'db.Lookup')
        db.execute("ALTER TABLE db_lookup ALTER COLUMN schema_field_id SET STATISTICS 5")
        db = get_db(orm, 'db.NewsItem')
        db.execute("ALTER TABLE db_newsitem ALTER COLUMN schema_id SET STATISTICS 5")
        db.execute('ALTER TABLE db_newsitem ALTER COLUMN item_date SET STATISTICS 75')
        db = get_db(orm, 'db.SchemaField')
        db.execute('ALTER TABLE db_schemafield ALTER COLUMN schema_id SET STATISTICS 5')

    def backwards(self, orm):
        "Write your backwards methods here."
        db = get_db(orm, 'db.Attribute')
        db.execute("ALTER TABLE db_attribute ALTER COLUMN schema_id SET STATISTICS 10")
        db = get_db(orm, 'db.Location')
        db.execute("ALTER TABLE db_location ALTER COLUMN location_type_id SET STATISTICS 10")
        db.execute("ALTER TABLE db_location ALTER COLUMN location SET STATISTICS 10")
        db = get_db(orm, 'db.LocationType')
        db.execute("ALTER TABLE db_locationtype ALTER COLUMN id SET STATISTICS 10")
        db = get_db(orm, 'db.Lookup')
        db.execute("ALTER TABLE db_lookup ALTER COLUMN schema_field_id SET STATISTICS 10")
        db = get_db(orm, 'db.NewsItem')
        db.execute("ALTER TABLE db_newsitem ALTER COLUMN schema_id SET STATISTICS 10")
        db.execute('ALTER TABLE db_newsitem ALTER COLUMN item_date SET STATISTICS 10')
        db = get_db(orm, 'db.SchemaField')
        db.execute('ALTER TABLE db_schemafield ALTER COLUMN schema_id SET STATISTICS 10')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0003_attribute_indices
# encoding: utf-8
import datetime
from south.db import dbs
from south.v2 import DataMigration
from django.db import models
from django.db import router

def get_db(orm, model):
    dbname = router.db_for_write(orm[model])
    return dbs[dbname]

class Migration(DataMigration):

    def forwards(self, orm):
        "Add partial indexes for the value columns. We only want to index values that are not NULL."
        db = get_db(orm, 'db.Attribute')
        db.execute("CREATE INDEX db_attribute_varchar01 ON db_attribute (varchar01) WHERE varchar01 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_varchar02 ON db_attribute (varchar02) WHERE varchar02 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_varchar03 ON db_attribute (varchar03) WHERE varchar03 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_varchar04 ON db_attribute (varchar04) WHERE varchar04 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_varchar05 ON db_attribute (varchar05) WHERE varchar05 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_date01 ON db_attribute (date01) WHERE date01 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_date02 ON db_attribute (date02) WHERE date02 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_date03 ON db_attribute (date03) WHERE date03 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_date04 ON db_attribute (date04) WHERE date04 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_date05 ON db_attribute (date05) WHERE date05 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_time01 ON db_attribute (time01) WHERE time01 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_time02 ON db_attribute (time02) WHERE time02 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_datetime01 ON db_attribute (datetime01) WHERE datetime01 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_datetime02 ON db_attribute (datetime02) WHERE datetime02 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_datetime03 ON db_attribute (datetime03) WHERE datetime03 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_datetime04 ON db_attribute (datetime04) WHERE datetime04 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_bool01 ON db_attribute (bool01) WHERE bool01 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_bool02 ON db_attribute (bool02) WHERE bool02 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_bool03 ON db_attribute (bool03) WHERE bool03 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_bool04 ON db_attribute (bool04) WHERE bool04 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_bool05 ON db_attribute (bool05) WHERE bool05 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_int01 ON db_attribute (int01) WHERE int01 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_int02 ON db_attribute (int02) WHERE int02 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_int03 ON db_attribute (int03) WHERE int03 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_int04 ON db_attribute (int04) WHERE int04 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_int05 ON db_attribute (int05) WHERE int05 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_int06 ON db_attribute (int06) WHERE int06 IS NOT NULL;")
        db.execute("CREATE INDEX db_attribute_int07 ON db_attribute (int07) WHERE int07 IS NOT NULL;")


    def backwards(self, orm):
        "drop partial indices on attribue table"
        db = get_db(orm, 'db.Attribute')
        db.execute("DROP INDEX IF EXISTS db_attribute_varchar01;")
        db.execute("DROP INDEX IF EXISTS db_attribute_varchar02;")
        db.execute("DROP INDEX IF EXISTS db_attribute_varchar03;")
        db.execute("DROP INDEX IF EXISTS db_attribute_varchar04;")
        db.execute("DROP INDEX IF EXISTS db_attribute_varchar05;")
        db.execute("DROP INDEX IF EXISTS db_attribute_date01;")
        db.execute("DROP INDEX IF EXISTS db_attribute_date02;")
        db.execute("DROP INDEX IF EXISTS db_attribute_date03;")
        db.execute("DROP INDEX IF EXISTS db_attribute_date04;")
        db.execute("DROP INDEX IF EXISTS db_attribute_date05;")
        db.execute("DROP INDEX IF EXISTS db_attribute_time01;")
        db.execute("DROP INDEX IF EXISTS db_attribute_time02;")
        db.execute("DROP INDEX IF EXISTS db_attribute_datetime01;")
        db.execute("DROP INDEX IF EXISTS db_attribute_datetime02;")
        db.execute("DROP INDEX IF EXISTS db_attribute_datetime03;")
        db.execute("DROP INDEX IF EXISTS db_attribute_datetime04;")
        db.execute("DROP INDEX IF EXISTS db_attribute_bool01;")
        db.execute("DROP INDEX IF EXISTS db_attribute_bool02;")
        db.execute("DROP INDEX IF EXISTS db_attribute_bool03;")
        db.execute("DROP INDEX IF EXISTS db_attribute_bool04;")
        db.execute("DROP INDEX IF EXISTS db_attribute_bool05;")
        db.execute("DROP INDEX IF EXISTS db_attribute_int01;")
        db.execute("DROP INDEX IF EXISTS db_attribute_int02;")
        db.execute("DROP INDEX IF EXISTS db_attribute_int03;")
        db.execute("DROP INDEX IF EXISTS db_attribute_int04;")
        db.execute("DROP INDEX IF EXISTS db_attribute_int05;")
        db.execute("DROP INDEX IF EXISTS db_attribute_int06;")
        db.execute("DROP INDEX IF EXISTS db_attribute_int07;")

    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0004_st_intersects_patch
# encoding: utf-8
import datetime
from south.db import dbs
from south.v2 import DataMigration
from django.db import models
from django.db import router

def get_db(orm, model):
    dbname = router.db_for_write(orm[model])
    return dbs[dbname]


class Migration(DataMigration):

    def forwards(self, orm):
        ""
        db = get_db(orm, 'db.NewsItem')
        
        # -- A wrapper function for ST_Intersects() that can deal with geometries of 'GeometryCollection' type.
        # 
        #         -- WARNING, it is MUCH slower than ST_Intersects() due to use of
        #         -- ST_Buffer() which means the query doesn't make good use of spatial
        #         -- indexes. Avoid calling this at page render time without extensive
        #         -- pre-filtering.
        # 
        #         -- The only restriction is that possible collection geometry is the second argument.
        #         -- Ending statements with "--" as workaround described at http://code.djangoproject.com/ticket/3214.
        # 
        #         -- Using ST_Buffer(geom, 0.0000000001) as a workaround for some geometries
        #         -- that blow up ST_Intersects with "GEOS intersects() threw an error!",
        #         -- as per http://www.mail-archive.com/postgis-users@postgis.refractions.net/msg10143.html
        #         -- Note they suggested ST_Buffer(geom, 0) but in practice that seems
        #         -- to return no intersections, even though the resulting geometry
        #         -- seems to be the same! Postgis bug?
        
        db.execute("""
        CREATE OR REPLACE FUNCTION intersecting_collection(other geometry, possible_coll geometry) RETURNS boolean AS $$
            BEGIN
                IF (GeometryType(possible_coll) = 'GEOMETRYCOLLECTION') THEN
                    FOR i IN 1..ST_NumGeometries(possible_coll) LOOP
                        IF ST_Intersects(ST_GeometryN(possible_coll, i), ST_Buffer(other, 0.0000000001)) = 't' THEN
                            RETURN 't'; --
                        END IF; --
                    END LOOP; --
                    RETURN 'f'; --
                ELSE
                    RETURN ST_Intersects(ST_Buffer(possible_coll, 0.0000000001), ST_Buffer(other, 0.0000000001)); --
                END IF; --
            END; --
        $$ LANGUAGE plpgsql; --
        """)
        
        db.execute("""
        CREATE OR REPLACE FUNCTION set_loc_area() RETURNS TRIGGER AS $$
            BEGIN
                IF NEW.location IS NOT NULL and NEW.area IS NULL THEN
                    NEW.area = ST_Area(ST_Transform(NEW.location, 3395)); --
                END IF; --
                RETURN NEW; --
            END; --
        $$ LANGUAGE plpgsql; --
        """)
        
        db.execute("""
        CREATE TRIGGER set_loc_area BEFORE INSERT OR UPDATE ON db_location
            FOR EACH ROW EXECUTE PROCEDURE set_loc_area(); --
        """)
        

    def backwards(self, orm):
        ""
        db = get_db(orm, 'db.NewsItem')
        db.execute("DROP TRIGGER IF EXISTS set_loc_area ON db_location;")
        db.execute("DROP FUNCTION IF EXISTS set_loc_area();")
        db.execute("DROP FUNCTION IF EXISTS intersecting_collection(other geometry, possible_coll geometry);")


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0005_newsitem_location_trigger
# encoding: utf-8
import datetime
from south.db import dbs
from south.v2 import DataMigration
from django.db import models
from django.db import router

def get_db(orm, model):
    dbname = router.db_for_write(orm[model])
    return dbs[dbname]

class Migration(DataMigration):

    def forwards(self, orm):
        "create newsitemlocation function and trigger"

        db = get_db(orm, 'db.NewsItem')
        db.execute("""
        CREATE OR REPLACE FUNCTION update_newsitem_location() RETURNS TRIGGER AS $location_updater$
            DECLARE
                loc_id integer; --
            BEGIN
                IF (TG_OP = 'UPDATE') THEN
                    -- In a sane programming language, the following IF statement could
                    -- have been combined into the previous one. But we can't do that,
                    -- because short-circuit evaluation of boolean expressions is not
                    -- guaranteed. See here:
                    -- http://archive.netbsd.se/?ml=pgsql-sql&a=2005-09&t=1337824

                    IF NEW.location IS DISTINCT FROM OLD.location THEN 
        	    -- ...or maybe we want (NOT ST_Equals(NEW.location, OLD.Location))?
                        IF (OLD.location IS NOT NULL) THEN
                            DELETE FROM db_newsitemlocation WHERE news_item_id = OLD.id; --
                        END IF; --
                        IF (NEW.location IS NOT NULL) THEN
                            IF (GeometryType(NEW.location) = 'GEOMETRYCOLLECTION') THEN
                                FOR i IN 1..ST_NumGeometries(NEW.location) LOOP
                                        FOR loc_id IN SELECT id FROM db_location WHERE intersecting_collection(ST_GeometryN(NEW.location, i), db_location.location) LOOP
                                            PERFORM * FROM db_newsitemlocation WHERE news_item_id = NEW.id AND location_id = loc_id; --
                                            IF NOT FOUND THEN
                                                INSERT INTO db_newsitemlocation (news_item_id, location_id) VALUES (NEW.id, loc_id); --
                                            END IF; --
                                        END LOOP; --
                                END LOOP; --
                            ELSE
                                INSERT INTO db_newsitemlocation (news_item_id, location_id)
                                SELECT NEW.id, id FROM db_location WHERE intersecting_collection(NEW.location, db_location.location); --
                            END IF; --
                        END IF; --
                    END IF; --
                ELSIF (TG_OP = 'INSERT') THEN
                    -- See the above comment for why this statement isn't combined into
                    -- the previous one.
                    IF (NEW.location IS NOT NULL) THEN
                        IF (GeometryType(NEW.location) = 'GEOMETRYCOLLECTION') THEN
                            FOR i IN 1..ST_NumGeometries(NEW.location) LOOP
                                    FOR loc_id IN SELECT id FROM db_location WHERE intersecting_collection(ST_GeometryN(NEW.location, i), db_location.location) LOOP
                                        PERFORM * FROM db_newsitemlocation WHERE news_item_id = NEW.id AND location_id = loc_id; --
                                        IF NOT FOUND THEN
                                            INSERT INTO db_newsitemlocation (news_item_id, location_id) VALUES (NEW.id, loc_id); --
                                        END IF; --
                                    END LOOP; --
                            END LOOP; --
                        ELSE
                            INSERT INTO db_newsitemlocation (news_item_id, location_id)
                            SELECT NEW.id, id FROM db_location WHERE intersecting_collection(NEW.location, db_location.location); --
                        END IF; --
                    END IF; --
                ELSIF (TG_OP = 'DELETE') THEN
                    DELETE FROM db_newsitemlocation WHERE news_item_id = OLD.id; --
                    RETURN OLD; --
                END IF; --
                RETURN NEW; --
            END; --
        $location_updater$ LANGUAGE plpgsql; --
        """)
        db.execute("""
        CREATE TRIGGER location_updater
        BEFORE INSERT OR UPDATE OR DELETE ON db_newsitem
            FOR EACH ROW EXECUTE PROCEDURE update_newsitem_location(); --
        """)
        # additional comments from source:
        # -- To populate for a new location (as long as ni.location is not a GEOMETRYCOLLECTION):
        # -- INSERT INTO db_newsitemlocation (news_item_id, location_id)
        # -- SELECT ni.id, loc.id FROM db_newsitem ni, db_location loc
        # -- WHERE intersecting_collection(ni.location, loc.location) AND loc.id = 826;


    def backwards(self, orm):
        "drops the location updating function"
        
        db = get_db(orm, 'db.NewsItem')
        db.execute("DROP TRIGGER location_updater ON db_newsitem;")
        db.execute("DROP FUNCTION update_newsitem_location();")

    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0006_add_location_synonym
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'LocationSynonym'
        db.create_table('db_locationsynonym', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('pretty_name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('normalized_name', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('location', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Location'])),
        ))
        db.send_create_signal('db', ['LocationSynonym'])


    def backwards(self, orm):
        
        # Deleting model 'LocationSynonym'
        db.delete_table('db_locationsynonym')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0007_load_default_schemas
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models



class Migration(DataMigration):

    def forwards(self, orm):

        def _create_or_update(model_id, key, attributes):
            Model = orm[model_id]
            params = {'defaults': attributes}
            params.update(key)
            ob, created = Model.objects.get_or_create(**params)
            for k, v in attributes.items():
                setattr(ob, k, v)
            ob.save()

        _create_or_update('db.schema', {"slug": "local-news"}, {
            "allow_charting": True,
            "can_collapse": True,
            "date_name": "Date",
            "date_name_plural": "Dates",
            "grab_bag": "",
            "grab_bag_headline": "",
            "has_newsitem_detail": True,
            "importance": 100,
            "indefinite_article": "a",
            "intro": "",
            "is_public": True,
            "is_special_report": False,
            "last_updated": "2000-01-01",
            "min_date": "2000-01-01",
            "name": "Local News",
            "number_in_overview": 5,
            "plural_name": "Local News",
            "short_description": "List of news in (TOWN NAME HERE)",
            "short_source": "URL goes here",
            "slug": "local-news",
            "source": "URL goes here",
            "summary": "Local News in (TOWN NAME HERE)",
            "update_frequency": "",
            "uses_attributes_in_list": False
        })


        _create_or_update('db.schema', {'slug': 'open311-service-requests'}, {
            "allow_charting": True,
            "can_collapse": False,
            "date_name": "Date",
            "date_name_plural": "Dates",
            "grab_bag": "",
            "grab_bag_headline": "",
            "has_newsitem_detail": True,
            "importance": 0,
            "indefinite_article": "an",
            "intro": "",
            "is_public": True,
            "is_special_report": False,
            "last_updated": "2000-01-01",
            "min_date": "2000-01-01",
            "name": "Open311 Service Request",
            "number_in_overview": 5,
            "plural_name": "Open311 Service Requests",
            "short_description": "",
            "short_source": "",
            "slug": "open311-service-requests",
            "source": "",
            "summary": "",
            "update_frequency": "",
            "uses_attributes_in_list": True
        })

        schema = orm['db.schema'].objects.get(slug="open311-service-requests")

        _create_or_update("db.schemafield", {"schema": schema, "real_name": "datetime02"}, {
            "display": True,
            "display_order": 4,
            "is_charted": False,
            "is_filter": False,
            "is_lookup": False,
            "is_searchable": False,
            "name": "expected_datetime",
            "pretty_name": "Expected Completion Date",
            "pretty_name_plural": "Expected Completion Dates",
            "real_name": "datetime02",
            "schema": schema
        })

        _create_or_update("db.schemafield", {"schema": schema, "real_name": "varchar03"}, {
            "display": False,
            "display_order": 10,
            "is_charted": False,
            "is_filter": False,
            "is_lookup": False,
            "is_searchable": False,
            "name": "address_id",
            "pretty_name": "Address ID",
            "pretty_name_plural": "Address IDs",
            "real_name": "varchar03",
            "schema": schema
        })

        _create_or_update("db.schemafield", {"schema": schema, "real_name": "varchar04"}, {
            "display": True,
            "display_order": 10,
            "is_charted": False,
            "is_filter": False,
            "is_lookup": False,
            "is_searchable": False,
            "name": "media_url",
            "pretty_name": "Media URL",
            "pretty_name_plural": "Media URLs",
            "real_name": "varchar04",
            "schema": schema
        })


        _create_or_update("db.schemafield", {"schema": schema, "real_name": "varchar01"}, {
            "display": True,
            "display_order": 10,
            "is_charted": False,
            "is_filter": False,
            "is_lookup": False,
            "is_searchable": False,
            "name": "service_request_id",
            "pretty_name": "Request ID",
            "pretty_name_plural": "Request IDs",
            "real_name": "varchar01",
            "schema": schema
        })

        _create_or_update("db.schemafield", {"schema": schema, "real_name": "datetime01"}, {
            "display": True,
            "display_order": 5,
            "is_charted": False,
            "is_filter": False,
            "is_lookup": False,
            "is_searchable": False,
            "name": "requested_datetime",
            "pretty_name": "Request Time",
            "pretty_name_plural": "Request Times",
            "real_name": "datetime01",
            "schema": schema
        })

        _create_or_update("db.schemafield", {"schema": schema, "real_name": "int02"}, {
            "display": True,
            "display_order": 6,
            "is_charted": False,
            "is_filter": True,
            "is_lookup": True,
            "is_searchable": False,
            "name": "agency_responsible",
            "pretty_name": "Responsible Agency",
            "pretty_name_plural": "Responsible Agencies",
            "real_name": "int02",
            "schema": schema
        })

        _create_or_update("db.schemafield", {"schema": schema, "real_name": "varchar02"}, {
            "display": False,
            "display_order": 10,
            "is_charted": False,
            "is_filter": False,
            "is_lookup": False,
            "is_searchable": False,
            "name": "service_code",
            "pretty_name": "Service Code",
            "pretty_name_plural": "Service Codes",
            "real_name": "varchar02",
            "schema": schema
        })

        _create_or_update("db.schemafield", {"schema": schema, "real_name": "int01"}, {
            "display": True,
            "display_order": 1,
            "is_charted": False,
            "is_filter": True,
            "is_lookup": True,
            "is_searchable": False,
            "name": "service_name",
            "pretty_name": "Service Name",
            "pretty_name_plural": "Service Names",
            "real_name": "int01",
            "schema": schema
        })

        _create_or_update("db.schemafield", {"schema": schema, "real_name": "text01"}, {
            "display": True,
            "display_order": 10,
            "is_charted": False,
            "is_filter": False,
            "is_lookup": False,
            "is_searchable": False,
            "name": "service_notice",
            "pretty_name": "Service Notice",
            "pretty_name_plural": "Service Notices",
            "real_name": "text01",
            "schema": schema
        })

        _create_or_update("db.schemafield", {"schema": schema, "real_name": "int03"}, {
            "display": True,
            "display_order": 2,
            "is_charted": False,
            "is_filter": False,
            "is_lookup": True,
            "is_searchable": False,
            "name": "status",
            "pretty_name": "Status",
            "pretty_name_plural": "Statuses",
            "real_name": "int03",
            "schema": schema
        })

        _create_or_update("db.schemafield", {"schema": schema, "real_name": "varchar05"}, {
            "display": True,
            "display_order": 3,
            "is_charted": False,
            "is_filter": False,
            "is_lookup": False,
            "is_searchable": False,
            "name": "status_notes",
            "pretty_name": "Status Notes",
            "pretty_name_plural": "Status Notes",
            "real_name": "varchar05",
            "schema": schema
        })


    def backwards(self, orm):
        "Write your backwards methods here."
        # We can't safely remove the default schemas because users may
        # have hand-modified them, added new ones, etc.
        pass

    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0008_bigger_attributes
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Attribute.text02'
        db.add_column('db_attribute', 'text02', self.gf('django.db.models.fields.TextField')(null=True, blank=True), keep_default=False)

        # Changing field 'Attribute.varchar02'
        db.alter_column('db_attribute', 'varchar02', self.gf('django.db.models.fields.CharField')(max_length=4096, null=True))

        # Changing field 'Attribute.varchar05'
        db.alter_column('db_attribute', 'varchar05', self.gf('django.db.models.fields.CharField')(max_length=4096, null=True))

        # Changing field 'Attribute.varchar04'
        db.alter_column('db_attribute', 'varchar04', self.gf('django.db.models.fields.CharField')(max_length=4096, null=True))

        # Changing field 'Attribute.varchar03'
        db.alter_column('db_attribute', 'varchar03', self.gf('django.db.models.fields.CharField')(max_length=4096, null=True))

        # Changing field 'Attribute.varchar01'
        db.alter_column('db_attribute', 'varchar01', self.gf('django.db.models.fields.CharField')(max_length=4096, null=True))


    def backwards(self, orm):

        # WARNING, blows up if any of these fields have a value > 255
        # characters.
        # Could do something like:
        # update db_attribute set varchar01 = substring(varchar01 from 0 for 255) where octet_length(varchar01) > 255;

        # Deleting field 'Attribute.text02'
        db.delete_column('db_attribute', 'text02')

        # Changing field 'Attribute.varchar02'
        db.alter_column('db_attribute', 'varchar02', self.gf('django.db.models.fields.CharField')(max_length=255, null=True))

        # Changing field 'Attribute.varchar05'
        db.alter_column('db_attribute', 'varchar05', self.gf('django.db.models.fields.CharField')(max_length=255, null=True))

        # Changing field 'Attribute.varchar04'
        db.alter_column('db_attribute', 'varchar04', self.gf('django.db.models.fields.CharField')(max_length=255, null=True))

        # Changing field 'Attribute.varchar03'
        db.alter_column('db_attribute', 'varchar03', self.gf('django.db.models.fields.CharField')(max_length=255, null=True))

        # Changing field 'Attribute.varchar01'
        db.alter_column('db_attribute', 'varchar01', self.gf('django.db.models.fields.CharField')(max_length=255, null=True))


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0009_add_real_slug_to_schemafield
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'SchemaField.slug'
        db.add_column('db_schemafield', 'slug', self.gf('django.db.models.fields.SlugField')(default='', max_length=32, db_index=True), keep_default=False)


    def backwards(self, orm):

        # Deleting field 'SchemaField.slug'
        db.delete_column('db_schemafield', 'slug')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'default': "''", 'max_length': '32', 'db_index': 'True'})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0010_populate_schemafield_slugs
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        for obj in orm.SchemaField.objects.all():
            obj.slug = obj.name.replace('_', '-')
            obj.save()

    def backwards(self, orm):
        for obj in orm.SchemaField.objects.all():
            name = obj.slug.replace('-', '_')
            if obj.name != name:
                obj.name = name
                obj.save()

    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'default': "''", 'max_length': '32', 'db_index': 'True'})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0011_delete_schemafield_name
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'SchemaField.name'
        db.delete_column('db_schemafield', 'name')


    def backwards(self, orm):
        
        # Adding field 'SchemaField.name'
        db.add_column('db_schemafield', 'name', self.gf('django.db.models.fields.CharField')(default='', max_length=32), keep_default=False)


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0012__undo_0011
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding field 'SchemaField.name'
        db.add_column('db_schemafield', 'name', self.gf('django.db.models.fields.SlugField')(default='', max_length=32, db_index=True), keep_default=False)


    def backwards(self, orm):
        # Deleting field 'SchemaField.name'
        db.delete_column('db_schemafield', 'name')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0013__undo_0010
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        for obj in orm.SchemaField.objects.all():
            name = obj.slug.replace('-', '_')
            if obj.name != name:
                obj.name = name
                obj.save()

    def backwards(self, orm):
        for obj in orm.SchemaField.objects.all():
            obj.slug = obj.name.replace('_', '-')
            obj.save()

    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'default': "''", 'max_length': '32', 'db_index': 'True'})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0014__undo_0009
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'SchemaField.slug'
        db.delete_column('db_schemafield', 'slug')

    def backwards(self, orm):
        # Adding field 'SchemaField.slug'
        db.add_column('db_schemafield', 'slug', self.gf('django.db.models.fields.SlugField')(default='', max_length=32, db_index=True), keep_default=False)

    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0015_auto__add_field_schema_map_icon_url__add_field_schema_map_color
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Schema.map_icon_url'
        db.add_column('db_schema', 'map_icon_url', self.gf('django.db.models.fields.TextField')(null=True, blank=True), keep_default=False)

        # Adding field 'Schema.map_color'
        db.add_column('db_schema', 'map_color', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True), keep_default=False)


    def backwards(self, orm):
        import tempfile, os, sys
        sys.stderr.write("WARNING, destroying Schema.map_icon_url column\n")
        sys.stderr.write("WARNING, destroying Schema.map_color column\n")
        # Want to dump a fixture here.  Can't just use
        # call_command('dumpdata') because it knows about *current*
        # model code, not South's own ORM state.
        tmpdir = tempfile.mkdtemp()
        tmpname = os.path.join(tmpdir, 'schema_icons_colors.json')
        sys.stderr.write("... will try to save data in %s\n" % tmpname)
        try:
            dumpfile = open(tmpname, 'w')
            schemas = orm.Schema.objects.all()
            from django.core import serializers
            serializer = serializers.get_serializer('json')()
            serializer.serialize(schemas, stream=dumpfile)
            sys.stderr.write("\n... saved\n")
        except Exception, e:
            sys.stderr.write("\n... failed to save data:\n%s\n" % e)
        # Deleting field 'Schema.map_icon_url'
        db.delete_column('db_schema', 'map_icon_url')

        # # Deleting field 'Schema.map_color'
        db.delete_column('db_schema', 'map_color')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0016_use_slug_fields_for_slugs
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Changing field 'Lookup.slug'
        db.alter_column('db_lookup', 'slug', self.gf('django.db.models.fields.SlugField')(max_length=32))

        # Changing field 'LocationType.slug'
        db.alter_column('db_locationtype', 'slug', self.gf('django.db.models.fields.SlugField')(unique=True, max_length=32))

        # Adding index on 'LocationType', fields ['slug']
        db.create_index('db_locationtype', ['slug'])

        # Changing field 'Location.slug'
        db.alter_column('db_location', 'slug', self.gf('django.db.models.fields.SlugField')(max_length=32))

        # Changing field 'Schema.slug'
        db.alter_column('db_schema', 'slug', self.gf('django.db.models.fields.SlugField')(unique=True, max_length=32))

        # Adding index on 'Schema', fields ['slug']
        db.create_index('db_schema', ['slug'])


    def backwards(self, orm):
        
        # Removing index on 'Schema', fields ['slug']
        db.delete_index('db_schema', ['slug'])

        # Removing index on 'LocationType', fields ['slug']
        db.delete_index('db_locationtype', ['slug'])

        # Changing field 'Lookup.slug'
        db.alter_column('db_lookup', 'slug', self.gf('django.db.models.fields.CharField')(max_length=32))

        # Changing field 'LocationType.slug'
        db.alter_column('db_locationtype', 'slug', self.gf('django.db.models.fields.CharField')(max_length=32, unique=True))

        # Changing field 'Location.slug'
        db.alter_column('db_location', 'slug', self.gf('django.db.models.fields.CharField')(max_length=32))

        # Changing field 'Schema.slug'
        db.alter_column('db_schema', 'slug', self.gf('django.db.models.fields.CharField')(max_length=32, unique=True))


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0017_del_location_centroid
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'Location.centroid'
        db.delete_column('db_location', 'centroid')



    def backwards(self, orm):
        # Adding field 'Location.centroid'
        db.add_column('db_location', 'centroid', self.gf('django.contrib.gis.db.models.fields.PointField')(null=True, blank=True), keep_default=False)


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0018_add_newsitem_last_modification
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'NewsItem.last_modification'
        db.add_column('db_newsitem', 'last_modification', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, default=datetime.datetime.now(), db_index=True, blank=True), keep_default=False)



    def backwards(self, orm):
        
        # Deleting field 'NewsItem.last_modification'
        db.delete_column('db_newsitem', 'last_modification')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0019_auto__add_field_schema_allow_comments
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Schema.allow_comments'
        db.add_column('db_schema', 'allow_comments', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Schema.allow_comments'
        db.delete_column('db_schema', 'allow_comments')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0020_auto__add_field_schema_is_event
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Schema.is_event'
        db.add_column('db_schema', 'is_event', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Schema.is_event'
        db.delete_column('db_schema', 'is_event')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0021_auto__add_unique_lookup_code_schema_field
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding unique constraint on 'Lookup', fields ['code', 'schema_field']
        db.create_unique('db_lookup', ['code', 'schema_field_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Lookup', fields ['code', 'schema_field']
        db.delete_unique('db_lookup', ['code', 'schema_field_id'])


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'), ('code', 'schema_field'))", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0022_auto__del_field_newsitem_block
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'NewsItem.block'
        db.delete_column('db_newsitem', 'block_id')


    def backwards(self, orm):
        
        # Adding field 'NewsItem.block'
        db.add_column('db_newsitem', 'block', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['streets.Block'], null=True, blank=True), keep_default=False)


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'), ('code', 'schema_field'))", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date.today', 'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date(1970, 1, 1)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0023_auto__add_newsitemimage
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    depends_on = (
        ('easy_thumbnails',
         '0011_auto__add_field_source_storage_hash__add_field_thumbnail_storage_hash'
         ),
        )

    def forwards(self, orm):
        
        # Adding model 'NewsItemImage'
        db.create_table('db_newsitemimage', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('news_item', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.NewsItem'])),
            ('image', self.gf('django.db.models.fields.files.ImageField')(max_length=256)),
        ))
        db.send_create_signal('db', ['NewsItemImage'])

        # Adding unique constraint on 'NewsItemImage', fields ['news_item', 'image']
        db.create_unique('db_newsitemimage', ['news_item_id', 'image'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'NewsItemImage', fields ['news_item', 'image']
        db.delete_unique('db_newsitemimage', ['news_item_id', 'image'])

        # Deleting model 'NewsItemImage'
        db.delete_table('db_newsitemimage')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'), ('code', 'schema_field'))", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date.today', 'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'+'", 'null': 'True', 'to': "orm['db.Location']"}),
            'location_set': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Location']", 'null': 'True', 'through': "orm['db.NewsItemLocation']", 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemimage': {
            'Meta': {'unique_together': "(('news_item', 'image'),)", 'object_name': 'NewsItemImage'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '256'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date(1970, 1, 1)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0024_auto__add_field_schema_allow_flagging
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):

        # Adding field 'Schema.allow_flagging'
        db.add_column('db_schema', 'allow_flagging', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Schema.allow_flagging'
        db.delete_column('db_schema', 'allow_flagging')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'), ('code', 'schema_field'))", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date.today', 'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'+'", 'null': 'True', 'to': "orm['db.Location']"}),
            'location_set': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Location']", 'null': 'True', 'through': "orm['db.NewsItemLocation']", 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemimage': {
            'Meta': {'unique_together': "(('news_item', 'image'),)", 'object_name': 'NewsItemImage'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '256'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_flagging': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date(1970, 1, 1)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0025_auto__add_more_indexes
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'Lookup', fields ['code']
        db.create_index('db_lookup', ['code'])

        # Adding index on 'Location', fields ['city']
        db.create_index('db_location', ['city'])


    def backwards(self, orm):
        
        # Removing index on 'Location', fields ['city']
        db.delete_index('db_location', ['city'])

        # Removing index on 'Lookup', fields ['code']
        db.delete_index('db_lookup', ['code'])


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'), ('code', 'schema_field'))", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date.today', 'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'+'", 'null': 'True', 'to': "orm['db.Location']"}),
            'location_set': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Location']", 'null': 'True', 'through': "orm['db.NewsItemLocation']", 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemimage': {
            'Meta': {'unique_together': "(('news_item', 'image'),)", 'object_name': 'NewsItemImage'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '256'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_flagging': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date(1970, 1, 1)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0026_make_unique_lookup_names
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        # Ensure names are unique.
        for lname in orm['db.lookup'].objects.all().distinct('name').values_list('name'):
            lname = lname[0]
            for sf in orm['db.schemafield'].objects.all():
                with_name = orm['db.lookup'].objects.filter(name=lname, schema_field=sf)
                for i, lookup in enumerate(with_name):
                    if i:
                        newname ='%s (%s)' % (lookup.name, str(i + 1))
                        print "Munging %s to %s" % (lookup.name, newname)
                        lookup.name = newname
                        lookup.save()


    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'), ('code', 'schema_field'), ('name', 'schema_field'))", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date.today', 'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'+'", 'null': 'True', 'to': "orm['db.Location']"}),
            'location_set': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Location']", 'null': 'True', 'through': "orm['db.NewsItemLocation']", 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemimage': {
            'Meta': {'unique_together': "(('news_item', 'image'),)", 'object_name': 'NewsItemImage'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '256'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_flagging': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date(1970, 1, 1)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0027_add_field_lookup_featured__add_unique_lookup_schema_field_name
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Lookup.featured'
        db.add_column('db_lookup', 'featured', self.gf('django.db.models.fields.BooleanField')(default=False), keep_default=False)
        # Adding unique constraint on 'Lookup', fields ['schema_field', 'name']
        db.create_unique('db_lookup', ['schema_field_id', 'name'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Lookup', fields ['schema_field', 'name']
        db.delete_unique('db_lookup', ['schema_field_id', 'name'])

        # Deleting field 'Lookup.featured'
        db.delete_column('db_lookup', 'featured')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'), ('code', 'schema_field'), ('name', 'schema_field'))", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'featured': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date.today', 'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'+'", 'null': 'True', 'to': "orm['db.Location']"}),
            'location_set': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Location']", 'null': 'True', 'through': "orm['db.NewsItemLocation']", 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemimage': {
            'Meta': {'unique_together': "(('news_item', 'image'),)", 'object_name': 'NewsItemImage'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '256'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_flagging': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date(1970, 1, 1)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0028_auto__add_unique_schemafield_name_schema__add_field_schema_edit_window
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    depends_on = (('neighbornews', '0004_chartable_categories'),
                  ('widgets', '0003_auto__add_pinneditem'),
                  ('preferences', '0005_auto__add_field_profile_properties'),
                  )

    def forwards(self, orm):
        
        # Adding unique constraint on 'SchemaField', fields ['name', 'schema']
        db.create_unique('db_schemafield', ['name', 'schema_id'])

        # Adding field 'Schema.edit_window'
        db.add_column('db_schema', 'edit_window', self.gf('django.db.models.fields.FloatField')(default=0.0, blank=True), keep_default=False)


    def backwards(self, orm):
        
        # Removing unique constraint on 'SchemaField', fields ['name', 'schema']
        db.delete_unique('db_schemafield', ['name', 'schema_id'])

        # Deleting field 'Schema.edit_window'
        db.delete_column('db_schema', 'edit_window')


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'), ('code', 'schema_field'), ('name', 'schema_field'))", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'featured': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date.today', 'db_index': 'True', 'blank': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'+'", 'null': 'True', 'to': "orm['db.Location']"}),
            'location_set': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Location']", 'null': 'True', 'through': "orm['db.NewsItemLocation']", 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True', 'blank': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemimage': {
            'Meta': {'unique_together': "(('news_item', 'image'),)", 'object_name': 'NewsItemImage'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '256'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_flagging': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'edit_window': ('django.db.models.fields.FloatField', [], {'default': '0.0', 'blank': 'True'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date(1970, 1, 1)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'), ('schema', 'name'))", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = 0029_auto__del_fields_schema__intro__grab_bag__grab_bag_headline
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):


    def forwards(self, orm):
        
        # Deleting field 'Schema.intro'
        db.delete_column('db_schema', 'intro')

        # Deleting field 'Schema.grab_bag_headline'
        db.delete_column('db_schema', 'grab_bag_headline')

        # Deleting field 'Schema.grab_bag'
        db.delete_column('db_schema', 'grab_bag')


    def backwards(self, orm):
        
        # Adding field 'Schema.intro'
        db.add_column('db_schema', 'intro', self.gf('django.db.models.fields.TextField')(default='', blank=True), keep_default=False)

        # Adding field 'Schema.grab_bag_headline'
        db.add_column('db_schema', 'grab_bag_headline', self.gf('django.db.models.fields.CharField')(default='', max_length=128, blank=True), keep_default=False)

        # Adding field 'Schema.grab_bag'
        db.add_column('db_schema', 'grab_bag', self.gf('django.db.models.fields.TextField')(default='', blank=True), keep_default=False)


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'), ('code', 'schema_field'), ('name', 'schema_field'))", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'featured': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date.today', 'db_index': 'True', 'blank': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'+'", 'null': 'True', 'to': "orm['db.Location']"}),
            'location_set': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Location']", 'null': 'True', 'through': "orm['db.NewsItemLocation']", 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True', 'blank': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemimage': {
            'Meta': {'unique_together': "(('news_item', 'image'),)", 'object_name': 'NewsItemImage'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '256'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_flagging': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'edit_window': ('django.db.models.fields.FloatField', [], {'default': '0.0', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date(1970, 1, 1)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'), ('schema', 'name'))", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        }
    }

    complete_apps = ['db']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""

.. _newsitems:

.. _newsitem-schemas:

Overview: NewsItems and Schemas
===============================

The ebpub system is capable of handling
many disparate types of news -- e.g., crime, photos and restaurant inspections.
Each type of news is referred to as a :py:class:`Schema`,
and an individual piece of news is a :py:class:`NewsItem`.

.. _newsitem_core_fields:

Core Fields of NewsItems
------------------------

The :py:class:`NewsItem <NewsItem>` model in itself is generic -- a
lowest-common denominator of each piece of news on the site. It has:

* title (required)
* url (optional)
* description (optional)
* location_name (optional but highly desirable; can be reverse-geocoded from location if you have one)
* location (optional but highly desirable; can be geocoded from location_name if you have one)
* item_date (default: today)
* pub_date (default: current date and time)

.. _newsitem_attributes:

Flexible data: SchemaFields and Attributes
------------------------------------------

If you'd like to extend your NewsItems to include
more information, you can use :py:class:`SchemaFields <SchemaField>`.

Each piece of news is described by:

* One :py:class:`NewsItem` instance, with just the core fields like
  title and description.

* One corresponding :py:class:`Attribute` instance, which is a dictionary-like
  object containing extra data, and is available as ``newsitem.attributes``.

* One :py:class:`Schema` that identifies the "type" of NewsItem; and

* A set of :py:class:`SchemaFields <SchemaField>`, each of which describes:
  a valid key for the attributes dictionary; the type of its allowed values;
  and some configuration metadata about how to display and use that attribute.

This is intended to be flexible enough for real-world news data, while
still allowing for fast database queries.  For more background,
you might be interested in the video
`Behind the scenes of EveryBlock.com <http://blip.tv/file/1957362>`_.

.. admonition:: Why not NoSQL?

   ebpub was originally written around the time of the rise in popularity of
   schemaless document storage systems commonly lumped together as
   `nosql <http://en.wikipedia.org/wiki/Nosql>`_,
   which would have made this one aspect of ebpub rather trivial.
   However, at the time, none of them had much in the way of
   geospatial capabilities; even today, none of them are as
   full-featured as PostGIS.


Examples might make this clearer. To assign the whole ``attributes`` dictionary::

    ni = NewsItem.objects.get(...)
    ni.attributes = {'sale_price': 19}
    # There is no need to call ni.save() or ni.attributes.save();
    # the assignment operation does that behind the scenes.

To assign a single value::

    ni.attributes['sale_price'] = 19
    # Again there is no need to save() anything explicilty.

To get a value::

    print ni.attributes['sale_price']

Or, from a database perspective: The "db_attribute" table stores
arbitrary attributes for each NewsItem, and the "db_schemafield" table
is the key for those attributes.
A SchemaField says, for example, that
the "int01" column in the db_attribute table for the "real estate
sales" Schema corresponds to the "sale price".

We'll walk through this example in detail below.


Detailed Example
------------------

Imagine you have a "real estate sales"
Schema, with an id of 5. Say, for each sale, you want to store the following
information:

* address
* sale date
* sale price

The first two fields should go in ``NewsItem.location_name`` and ``NewsItem.item_date``,
respectively -- there's no reason to put them in the Attribute table, because
the NewsItem table has a slot for them.

Sale price is a number (we'll assume it's an integer), so create a
:py:class:`SchemaField` defining it, with these values:

.. code-block:: python
    :linenos:

    field = SchemaField(schema_id = 5,
        name = 'sale_price',
        real_name = 'int01',
        pretty_name = 'sale price',
        pretty_name_plural = 'sale prices',
        display = True,
        display_order = 1,
        is_searchable = False,
       )

Line 1. ``schema_id`` is the id of our "real estate sales" schema.

Line 2.      ``name`` is the alphanumeric-and-underscores-only name for this field.
(Used in URLs, and as the key for ``newsitem.attributes``,
and for the
:py:meth:`NewsItemQuerySet.by_attribute` method.)
This value must be unique with respect to the schema_id.

Line 3.  ``real_name`` is the column to use in the db_attribute model. Choices are:
int01-07, text01, bool01-05, datetime01-04, date01-05, time01-02,
varchar01-05. This value must be unique with respect to the schema_id.

Lines 4-5. ``pretty_name`` and ``pretty_name_plural`` are the human-readable name
for this attribute.

Line 6.  ``display`` controls whether to display the value on the site.

Line 7: `sort_order`` - An integer representing what order it should be displayed
on newsitem_detail pages.

Line 8: ``is_searchable`` - Whether you can do text searches on this field.
Only works with text or varchar fields.

Once you've created this SchemaField, the value of "int01" for any db_attribute
row with schema_id=5 will be the sale price.

Having done all that, using the field is as easy as::

   from ebpub.db.models import NewsItem
   ni = NewsItem(schema__id=5, title='the title', description='the description', ...)
   ni.save()
   ni.attributes['sale_price'] = 59


Searching by Attributes
------------------------

There is a simple API for searching NewsItems by attribute values:

   sale_price = SchemaField.objects.get(schema__id=5, name='sale_price')
   NewsItem.objects.filter(schema__id=5).by_attribute(sale_price, 59)

For details see :py:meth:`NewsItemQuerySet.by_attribute`.


Attributes: Under the hood
---------------------------

The dictionary-like API is provided thanks to the combination of
the ``AttributesDescriptor``, ``AttributeDict``, and
:py:class:`Attribute` classes; see the source code for details.

Images
------

NewsItems have a ``newsitemimage_set`` reverse relationship
with the :py:class:`NewsItemImage` model, allowing any number of
images to be associated with one NewsItem.
All the images for a NewsItem can be retrieved via
``item.newsitemimage_set.all()``.


Dates
-----

The distinction between ``NewsItem.pub_date`` and ``NewsItem.item_date``
is intended for data sets where there's
a lag in publishing or where the data is updated infrequently or
irregularly. 

For example, on EveryBlock.com, Chicago crime data is published a week
after it is reported, so a crime's ``item_date`` is the day of the
crime report, whereas the ``pub_date`` is the day the data was
published to EveryBlock.com.

Location, location, location
-----------------------------

NewsItems have several distinct notions of location:

* ``NewsItem.location_name`` is a human-readable version of the location;
  it can be anything, but typically it describes an address,
  block, geographic area, or landmark.

* ``NewsItem.location`` is used frequently; typically a point, and
  typically set when scraping data, by geocoding if
  not provided in the source data.  This is used in
  many views for finding relevant NewsItems (indirectly; actually
  see below about NewsItemLocations).

* ``NewsItem.location_set`` is a convenient way to get
  all :py:class:`Locations <Location>` that overlap this item's ``location``.
  It's a many-to-many relationship (via the
  NewsItemLocation model).  The NewsItemLocations are created by a sql trigger
  whenever self.location changes; not set by any python code. Used
  in various views for filtering.

* ``NewsItem.location_object`` is a single :py:class:`Location` reference;
  theoretically to be explicitly assigned by a scraper script when
  there's no known address or geographic point for this NewsItem
  but we know the name of the general area it's within.

  For example, many stories might mention a town or city name, or a
  police report might tell you the precinct.  In practice, this field
  is usually Null; more importantly it's only used currently
  (2011-12-06) by self.location_url(), for linking back to a location
  view from a newsitem view.  (Example of where everyblock.com uses
  this: NYC crime aggregates,
  eg. http://nyc.everyblock.com/crime/by-date/2010/8/23/3364632/ )

  See also this ticket http://developer.openblockproject.org/ticket/93
  about possibly making more use of self.location_object.


.. _aggregates:

Aggregates
----------

Several parts of ebpub display aggregate totals of NewsItems for a particular
Schema; for example, charts of how many were added each day.

Because these calculations can be expensive, there's an infrastructure
for caching the aggregate numbers regularly in separate tables (db_aggregate*).

To do this, just run the :py:mod:`update_aggregates <ebpub.db.bin.update_aggregates>`
script on the command line.

You'll want to do this on a regular basis, depending on how often you update
your data. **Some parts of the site (such as charts) will not be visible** until
you populate the aggregates.

.. _future_events:

Event-like News Types
----------------------

In order for OpenBlock to treat a news type as being about
(potentially) future events, rather than news from the (recent) past,
there is a simple convention that you should follow:

1. Set the schema's ``is_event=True``.

2. Add a SchemaField with ``name='start_time'``. It should be a Time
   field, i.e. ``real_name`` should be one of ``time01``, ``time02``,
   etc.  Leave ``is_filter``, ``is_lookoup``, ``is_searchable``, and
   ``is_charted`` set to False.  The ``pretty_name`` can be whatever
   you like of course.

3. Optionally add another SchemaField with ``name='end_time'``, if your data
   source will include this information.

4. When adding NewsItems of this type, the NewsItem's ``item_date``
   field should be set to the date on which the event will (or already
   did) take place, and ``attributes['start_time']`` should be set to
   the (local) time it will start, and ``attributes['end_time']``
   (if needed) should be set to the (local) end time.

All-day events can be represented by leaving ``start_time`` empty.

There is no special support for repeating events or other advanced
calendar features.

.. _lookups:

Lookups
========

Lookups are a way to reduce duplication and support fast searching
for similar NewsItems.

Consider the "real estate" schema we talked about in earlier examples.
We want to add a field representing "property type" for each real estate sale
NewsItem.

We could store it as a varchar field (in which case we'd set
real_name='varchar01') -- but that would cause a lot of duplication and
redundancy, because there are only a couple of property types -- the set
['single-family', 'condo', 'land', 'multi-family']. To represent this set,
we can use a Lookup -- a way to normalize the data.

To do this, set ``SchemaField.is_lookup=True`` and make sure to use an 'int' column
for SchemaField.real_name.  For example:

.. code-block:: python

    field = SchemaField(schema_id = 5,
        name = 'property_type',
        real_name = 'int02',
        is_lookup=True,
        pretty_name = 'property type',
        pretty_name_plural = 'property types',
        display = True,
        display_order = 2,
       )


Then, for each record, get or create a :py:class:`Lookup`
object that represents the data, and use
the Lookup's id in the appropriate attribute field.
For example:

.. code-block:: python

    condo = Lookup.objects.get_or_create_lookup(
        schema_field=field, name='condo')
    newsitem['property_type'] = condo

Note the convenience function :py:meth:`Lookup.objects.get_or_create_lookup() <LookupManager.get_or_create_lookup>`.

Many-to-many Lookups
--------------------

Sometimes a :py:class:`NewsItem` has multiple values for a single attribute.
For example, a restaurant inspection can have multiple violations. In
this case, you can use a many-to-many Lookup. To do this, just set
``SchemaField.is_lookup=True`` as before, but use a varchar field for
the ``SchemaField.real_name``. Then, in the db_attribute column, set
the value to a string of comma-separated integers of the Lookup IDs:

.. code-block:: python

    field = SchemaField.objects.get(schema_id=5, name='property_type')
    field.real_name = 'varchar01'
    field.save()

    newsitem.attributes['property_type'] = '1,2,3'


.. _featured_lookups:

"Featured" Lookups
-----------------------

A :py:class:`Lookup` instance can have ``featured=True``, which you can use to
mark some Lookup values as "special" for eg. navigation purposes.
One example use case would be special tags or keywords that mark
any relevant NewsItems for inclusion in a special part of your homepage.

To work with Lookups that are marked with ``featured=True``, there are
several useful tools:

* :py:meth:`Lookup.objects.featured_lookups_for(newsitem, name) <LookupManager.featured_lookups_for>`
  will, given a NewsItem instance and an attribute name, find all
  featured Lookups for that attribute which are relevant to that NewsItem.
* The same functionality is available in templates via the 
  :py:func:`featured_lookups_for_item <ebpub.db.templatetags.eb.featured_lookups_for_item>` template tag.
* :py:func:`get_featured_lookups_by_schema <ebpub.db.templatetags.eb.get_featured_lookups_by_schema>`
  is a tag that finds all currently featured Lookups, and URLs to find
  relevant NewsItems.


.. _charting_and_filtering:

Charting and filtering lookups
------------------------------

Set ``SchemaField.is_filter=True`` on a lookup SchemaField, and the detail page for
the NewsItem (newsitem_detail) will automatically link that field to a page
that lists all of the other NewsItems in that Schema with that particular
Lookup value.

Set ``SchemaField.is_charted=True`` on a lookup SchemaField, and the detail page
for the Schema (schema_detail) will include a chart of the top 10 lookup values
in the last 30 days' worth of data. Similar charts are on the
place detail overview page. (This assumes aggregates are populated; see
the Aggregates section below.)


module contents
================
"""

from django.conf import settings
from django.contrib.gis.db import models
from django.contrib.gis.db.models import Count
from django.core import urlresolvers
from django.core.cache import cache
from django.core.exceptions import ValidationError
from django.db import connection, transaction
from ebpub.db import constants
from ebpub.geocoder.parser.parsing import normalize
from ebpub.utils.geodjango import flatten_geomcollection
from ebpub.utils.geodjango import ensure_valid
from ebpub.utils.text import slugify
from .fields import OpenblockImageField

import datetime
import logging
import re

logger = logging.getLogger('ebpub.db.models')

# Need these monkeypatches for "natural key" support during fixture load/dump.
import ebpub.monkeypatches
ebpub.monkeypatches.patch_once()

FREQUENCY_CHOICES = ('Hourly', 'Throughout the day', 'Daily', 'Twice a week', 'Weekly', 'Twice a month', 'Monthly', 'Quarterly', 'Sporadically', 'No longer updated')
FREQUENCY_CHOICES = [(a, a) for a in FREQUENCY_CHOICES]

logger = logging.getLogger('ebpub.db.models')

def get_valid_real_names():
    """
    Field names of ``Attribute``, suitable for use as
    ``SchemaField.real_name``.
    """
    for name in sorted(Attribute._meta.get_all_field_names()):
        if re.search(r'\d\d$', name):
            yield name


def field_mapping(schema_id_list):
    """
    Given a list of schema IDs, returns a dictionary of dictionaries, mapping
    schema_ids to dictionaries mapping the fields' name->real_name.
    Example return value::

        {1: {u'crime_type': 'varchar01', u'crime_date', 'date01'},
         2: {u'permit_number': 'int01', 'to_date': 'date01'},
        }
    """
    result = {}
    for sf in SchemaField.objects.filter(schema__id__in=(schema_id_list)).values('schema', 'name', 'real_name'):
        result.setdefault(sf['schema'], {})[sf['name']] = sf['real_name']
    return result


class SchemaQuerySet(models.query.GeoQuerySet):

    def update(self, *args, **kwargs):
        # Django doesn't provide pre/post_update signals, rats.
        # See https://code.djangoproject.com/ticket/13021
        # So we define one and send it here.
        result = super(SchemaQuerySet, self).update(*args, **kwargs)
        post_update.send(sender=Schema)
        return result


class SchemaManager(models.Manager):

    _allowed_ids_cache_key = 'allowed_schema_ids__all'

    def update(self, *args, **kwargs):
        return self.get_query_set().update(*args, **kwargs)

    def get_by_natural_key(self, slug):
        return self.get(slug=slug)

    def get_query_set(self):
        """Warning: This breaks manage.py dumpdata.
        See bug #82.

        """
        return SchemaQuerySet(model=self.model, using=self._db).defer(
            'short_description',
            'summary',
            'source',
            'short_source',
            'update_frequency',
            )

    def allowed_schema_ids(self):
        """
        Useful for filtering out schemas (or things related to
        schemas) based on the current Manager.
        """
        ids = cache.get(self._allowed_ids_cache_key, None)
        if ids is None:
            ids = [s['id'] for s in self.all().values('id')]
            cache.set(self._allowed_ids_cache_key, ids, constants.ALLOWED_IDS_CACHE_TIME)
        return ids


class SchemaPublicManager(SchemaManager):

    _allowed_ids_cache_key = 'allowed_schema_ids__public'

    def get_query_set(self):
        return super(SchemaManager, self).get_query_set().filter(is_public=True)


class Schema(models.Model):
    """
    Describes a type of :py:class:`NewsItem`.  A NewsItem has exactly one Schema,
    which describes its Attributes, via associated :py:class:`SchemaFields <SchemaField>`.

    nb. to get all NewsItem instances for a Schema, you can do the usual as per
    http://docs.djangoproject.com/en/dev/topics/db/queries/#backwards-related-objects:
    schema.newsitem_set.all()

    nb. Some Schemas may not be visible to some users, if eg.
    ``is_public=False``. To abstract this, use the
    :py:func:`ebpub.utils.view_utils.get_schema_manager` function,
    rather than directly using ``Schema.objects`` or ``Schema.public_objects``.

    (To filter NewsItems appropriately, do NewsItem.objects.by_request(request)
    which will take care of using the right Schema manager.)
    """
    name = models.CharField(max_length=32)
    plural_name = models.CharField(max_length=32)
    indefinite_article = models.CharField(max_length=2,
                                          help_text="eg.'a' or 'an'")
    slug = models.SlugField(max_length=32, unique=True)
    min_date = models.DateField(
        help_text="The earliest available pub_date for this Schema",
        default=lambda: datetime.date(1970, 1, 1))
    last_updated = models.DateField(
        help_text=u"Last date any NewsItems were loaded for this Schema.")
    date_name = models.CharField(
        max_length=32, default='Date',
        help_text='Human-readable name for the item_date field')
    date_name_plural = models.CharField(max_length=32, default='Dates')
    importance = models.SmallIntegerField(
        default=0,
        help_text='Bigger number is more important; used for sorting in some places.')
    is_public = models.BooleanField(
        db_index=True, default=False,
        help_text="Set False if you want only people with the staff cookie to be able to see it.") 
    is_special_report = models.BooleanField(
        default=False,
        help_text="Whether to use the schema_detail_special_report view for these items, eg. for displaying items that have a known general Location but not a specific point.")

    is_event = models.BooleanField(
        default=False,
        help_text="Whether these items are (potentially) future events rather than news in the past.")

    can_collapse = models.BooleanField(
        default=False,
        help_text="Whether RSS feed should collapse many of these into one.")

    has_newsitem_detail = models.BooleanField(
        default=False,
        help_text="Whether to show a detail page for NewsItems of this schema, or redirect to the NewsItem's source URL instead.")

    allow_comments = models.BooleanField(
        default=False,
        help_text="Whether to allow users to add comments to NewsItems of the schema. Only applies to items with detail page."
    )

    allow_flagging = models.BooleanField(
        default=False,
        help_text="Whether to allow users to flag NewsItems of this schema as spam or inappropriate."
        )

    allow_charting = models.BooleanField(
        default=False,
        help_text="Whether aggregate charts are displayed on the home page of this Schema")

    uses_attributes_in_list = models.BooleanField(
        default=False,
        help_text="Whether attributes should be preloaded for NewsItems of this Schema, in the list view")


    number_in_overview = models.SmallIntegerField(
        default=5,
        help_text="Number of records to show on place_overview")

    # TODO: maybe this should be either a FileField or a FilePathField instead?
    map_icon_url = models.TextField(
        blank=True, null=True,
        help_text="Set this to a URL to a small image icon and it will be displayed on maps. Should be roughly 40x40 pixels. Optional.",
        )

    def get_map_icon_url(self):
        # Could be relative.
        url = self.map_icon_url or u''
        if url and not (url.startswith('/') or url.startswith('http')):
            url = '%s/%s' % (settings.STATIC_URL.rstrip('/'), url)
        return url

    map_color = models.CharField(
        max_length=255, blank=True, null=True,
        help_text="CSS color code used on maps to display this type of news. eg #FF0000.  Only used if map_icon_url is not set. Optional.")


    edit_window = models.FloatField(
        blank=True, default=0.0,
        help_text=u"How long, in hours, the creator of an item is allowed to edit it. Set to 0 to disallow edits by non-Admin users. Set to -1 to allow editing forever."
        )

    objects = SchemaManager()
    public_objects = SchemaPublicManager()

    def __unicode__(self):
        return self.name

    def natural_key(self):
        return (self.slug,)

    def get_absolute_url(self):
        return urlresolvers.reverse('ebpub-schema-filter', args=(self.slug,))

    # Backward compatibility.
    url = get_absolute_url

    ######################################################################
    # Metadata fields that used to live in a separate SchemaInfo model.
    short_description = models.TextField(blank=True, default='')
    summary = models.TextField(blank=True, default='')
    source = models.TextField(blank=True, default='',
                              help_text='Where this information came from, as one or more URLs, one per line.')
    short_source = models.CharField(max_length=128, blank=True, default='One-line description of where this information came from.')
    update_frequency = models.CharField(max_length=64, blank=True, default='',
                                        choices=FREQUENCY_CHOICES)

    class Meta:
        ordering = ('name',)


class SchemaFieldManager(models.Manager):

    def get_by_natural_key(self, schema_slug, real_name):
        return self.get(schema__slug=schema_slug, real_name=real_name)


class SchemaField(models.Model):
    """
    Describes the meaning of one Attribute field for one Schema type.
    """
    objects = SchemaFieldManager()

    schema = models.ForeignKey(Schema)

    pretty_name = models.CharField(
        max_length=32,
        help_text="Human-readable name of this field, for display."
        )
    pretty_name_plural = models.CharField(
        max_length=32,
        help_text="Plural human-readable name"
        )

    name = models.SlugField(max_length=32)

    real_name = models.CharField(
        max_length=10,
        help_text="Column name in the Attribute model. 'varchar01', 'varchar02', etc.",
        choices=((name, name) for name in get_valid_real_names()),
        )
    display = models.BooleanField(
        default=True,
        help_text='Whether to display value on the public site.'
        )
    is_lookup = models.BooleanField(
        blank=True, default=False,
        help_text='Whether the value is a foreign key to Lookup.'
        )
    is_filter = models.BooleanField(
        blank=True, default=False,
        help_text='Whether to link to list of items with the same value in this field. Assumes is_lookup=True.'
        )
    is_charted = models.BooleanField(
        blank=True, default=False,
        help_text='Whether the schema detail view displays a chart for this field; also see "trends" tabs on place overview page. Assumes is_lookup=True.'
        )
    display_order = models.SmallIntegerField(default=10)
    is_searchable = models.BooleanField(
        default=False,
        help_text="Whether the value is searchable by content. Doesn't make sense if is_lookup=True."
        )

    def natural_key(self):
        return (self.schema.slug, self.real_name)

    class Meta(object):
        unique_together = (('schema', 'real_name'),
                           ('schema', 'name'),
                           )
        ordering = ('pretty_name',)

    def __unicode__(self):
        return u'%s - %s' % (self.schema, self.name)

    @property
    def datatype(self):
        return self.real_name[:-2]

    def is_type(self, *data_types):
        """
        Returns True if this SchemaField is of *any* of the given data types.

        Allowed values are 'varchar', 'date', 'time', 'datetime', 'bool', 'int'.
        """
        return self.datatype in data_types

    def is_many_to_many_lookup(self):
        """
        Returns True if this SchemaField is a many-to-many lookup.
        """
        return self.is_lookup and not self.is_type('int')
    is_many_to_many_lookup.boolean = True

    def all_lookups(self):
        if not self.is_lookup:
            raise ValueError('SchemaField.all_lookups() can only be called if is_lookup is True')
        return Lookup.objects.filter(schema_field__id=self.id).order_by('name')

    def browse_by_title(self):
        "Returns FOO in 'Browse by FOO', for this SchemaField."
        if self.is_type('bool'):
            return u'whether they %s' % self.pretty_name_plural
        return self.pretty_name

    def smart_pretty_name(self):
        """
        Returns the pretty name for this SchemaField, taking into account
        many-to-many fields.
        """
        if self.is_many_to_many_lookup():
            return self.pretty_name_plural
        return self.pretty_name


class LocationTypeManager(models.Manager):
    def get_by_natural_key(self, slug):
        return self.get(slug=slug)


class LocationType(models.Model):
    '''
    Used for classifying and grouping :py:class:`Location`.
    
    You'll want to create at least one LocationType with the slug set to
    the same value as ``settings.DEFAULT_LOCTYPE_SLUG``, because that's
    used in various default URLs.  By default this is set to
    "neighborhoods".
    '''
    name = models.CharField(max_length=255,
                            help_text='for example, "Ward" or "Congressional District"')
    plural_name = models.CharField(max_length=64)
    scope = models.CharField(max_length=64,
                             help_text='e.g., "Chicago" or "U.S.A.". For display only; has no effect.')
    slug = models.SlugField(max_length=32, unique=True)
    is_browsable = models.BooleanField(
        default=True, help_text="Whether this is displayed on location_type_list.") #  XXX unused??
    is_significant = models.BooleanField(
        default=True,
        help_text="Whether this can be used to filter NewsItems, shows up in 'nearby locations', etc."
        )

    def __unicode__(self):
        return u'%s, %s' % (self.name, self.scope)

    def get_absolute_url(self):
        return urlresolvers.reverse('ebpub-loc-type-detail', args=(self.slug,))

    # Backward compatibility.
    url = get_absolute_url

    def natural_key(self):
        return (self.slug,)

    class Meta:
        ordering = ('name',)

    objects = LocationTypeManager()


class LocationManager(models.GeoManager):
    def get_by_natural_key(self, slug, location_type_slug):
        return self.get(slug=slug, location_type__slug=location_type_slug)


class Location(models.Model):
    '''
    A polygon that represents a geographic area, such as a specific
    neighborhood, ZIP code boundary or political boundary. Each ``Location`` has an
    associated :py:class:`LocationType` (e.g., "neighborhood"). To add a Location to the
    system, follow these steps:

        1. Create a :py:class:`LocationType`.

        2. Get the Location's geographic representation (a set of
           longitude/latitude points that determine the border of the
           polygon).  You might want to draw this on your own using
           desktop GIS tools or online tools, or you can try to get
           the data from a company or government agency.  (You can
           even draw simple shapes in the OpenBlock admin UI.)

        3. With the geographic representation, create a row in the
           "db_location" table that describes the Location. See below
           for what the various fields mean.

           You can create Locations in various ways: use the admin UI;
           use the script ``add_location`` to create one by
           specifying its geometry in well-known text (WKT) format;
           use the script ``import_locations`` to import them from shapefiles;
           or use the Django model API; or do a manual SQL INSERT statement.
    '''

    name = models.CharField(max_length=255, help_text='e.g., "35th Ward"')
    normalized_name = models.CharField(max_length=255, db_index=True)
    slug = models.SlugField(max_length=32, db_index=True)
    location_type = models.ForeignKey(LocationType)
    location = models.GeometryField(null=True)
    display_order = models.SmallIntegerField()
    city = models.CharField(max_length=255, db_index=True)
    source = models.CharField(max_length=64)
    area = models.FloatField(
        blank=True, null=True,
        help_text="In square meters. This is populated automatically."
        # the db trigger is created by ebpub/db/migrations/0004_st_intersects_patch.py.
        )
    population = models.IntegerField(blank=True, null=True,
                                     help_text='Optional. If used, typicall found in census data.')
    user_id = models.IntegerField(
        blank=True, null=True,
        help_text="Used for 'custom' Locations created by end users.")
    is_public = models.BooleanField(
        help_text='Whether this is publically visible, or requires the staff cookie')
    description = models.TextField(blank=True)
    creation_date = models.DateTimeField(blank=True, null=True,
                                         default=datetime.datetime.now)
    last_mod_date = models.DateTimeField(blank=True, null=True,
                                         default=datetime.datetime.now)

    objects = LocationManager()

    @property
    def centroid(self):
        # For backward compatibility.
        import warnings
        warnings.warn(
            "Location.centroid is deprecated. Use Location.location.centroid instead.",
            DeprecationWarning)
        return self.location.centroid

    def clean(self):
        if self.location:
            try:
                self.location = ensure_valid(flatten_geomcollection(self.location))
            except ValueError, e:
                raise ValidationError(str(e))
        if self.normalized_name:
            self.normalized_name = normalize(self.normalized_name)
        else:
            self.normalized_name = normalize(self.name)

    class Meta:
        unique_together = (('slug', 'location_type'),)
        ordering = ('slug',)

    def natural_key(self):
        return (self.slug, self.location_type.slug)

    def __unicode__(self):
        return self.name

    def get_absolute_url(self):
        return urlresolvers.reverse('ebpub-location-recent',
                                    args=(self.location_type.slug, self.slug))

    # Backward compatibility.
    url = get_absolute_url

    def rss_url(self):
        return urlresolvers.reverse('ebpub-location-rss',
                                    args=(self.location_type.slug, self.slug))


    def alert_url(self):
        return urlresolvers.reverse('ebpub-location-alerts',
                                    args=(self.location_type.slug, self.slug))

    # Give Location objects a "pretty_name" attribute for interoperability with
    # Block objects. (Parts of our app accept either a Block or Location.)
    @property
    def pretty_name(self):
        return self.name

    @property
    def is_custom(self):
        return self.location_type.slug == 'custom'


class LocationSynonymManager(models.Manager):
    def get_canonical(self, name):
        """
        Returns the canonical normalized spelling of the given location name. 
        If the given location name is already correctly spelled, then it's returned as-is.
        """
        try:
            normalized_name = normalize(name)
            return self.get(normalized_name=normalized_name).location.normalized_name
        except self.model.DoesNotExist:
            return normalized_name


class LocationSynonym(models.Model):
    """
    Represents an alternate name for a :py:class:`Location`.
    """
    pretty_name = models.CharField(max_length=255)
    normalized_name = models.CharField(max_length=255, db_index=True)
    location = models.ForeignKey(Location,
                                 help_text='Location this is a synonym for.')
    objects = LocationSynonymManager()

    def save(self, force_insert=False, force_update=False, using=None):
        # Not doing this in clean() because we really don't want there to be
        # any way to get this wrong.
        if self.normalized_name:
            self.normalized_name = normalize(self.normalized_name)
        else:
            self.normalized_name = normalize(self.pretty_name)
        super(LocationSynonym, self).save(force_update=force_update, force_insert=force_insert, using=using)

    def __unicode__(self):
        return self.pretty_name


class AttributesDescriptor(object):

    # No docstring, not part of API.
    #
    # This class provides the functionality that makes the attributes available
    # as a dictionary-like `attributes` on a model instance.
    #
    # You normally don't instantiate this directly.
    # Just use newsitem.attributes like a normal dictionary.

    def __get__(self, instance, instance_type=None):
        if instance is None:
            raise AttributeError("%s must be accessed via instance" % self.__class__.__name__)
        if not hasattr(instance, '_attributes_cache'):
            select_dict = field_mapping([instance.schema_id]).get(instance.schema_id, {})
            instance._attributes_cache = AttributeDict(instance.id, instance.schema_id, select_dict)
        return instance._attributes_cache

    def __set__(self, instance, value):
        if instance is None:
            raise AttributeError("%s must be accessed via instance" % self.__class__.__name__)
        if not isinstance(value, dict):
            raise ValueError('Only a dictionary is allowed')
        mapping = field_mapping([instance.schema_id]).get(instance.schema_id, {}).items()
        if not mapping:
            if value:
                logger.warn("Can't save non-empty attributes dict with an empty schema")
            return
        values = [value.get(k, None) for k, v in mapping]
        cursor = connection.cursor()
        cursor.execute("""
            UPDATE %s
            SET %s
            WHERE news_item_id = %%s
            """ % (Attribute._meta.db_table, ','.join(['%s=%%s' % v for k, v in mapping])),
                values + [instance.id])
        # If no records were updated, that means the DB doesn't yet have a
        # row in the attributes table for this news item. Do an INSERT.
        if cursor.rowcount < 1:
            cursor.execute("""
                INSERT INTO %s (news_item_id, schema_id, %s)
                VALUES (%%s, %%s, %s)""" % (Attribute._meta.db_table, ','.join([v for k, v in mapping]), ','.join(['%s' for k in mapping])),
                [instance.id, instance.schema_id] + values)
        transaction.commit_unless_managed()


class AttributeDict(dict):

    # No docstring, not part of API.
    #
    # A dictionary-like object that serves as a wrapper around attributes for a
    # given NewsItem.
    #
    # You normally don't instantiate this directly.
    # Just use news_item.attributes like a normal dictionary.

    def __init__(self, news_item_id, schema_id, mapping):
        dict.__init__(self)
        self.news_item_id = news_item_id
        self.schema_id = schema_id
        self.mapping = mapping # name -> real_name dictionary
        self.cached = False

    def __do_query(self):
        if not self.cached:
            attr_values = Attribute.objects.filter(news_item__id=self.news_item_id).extra(select=self.mapping).values(*self.mapping.keys())
            # Rarely, we might have added the first SchemaField for this
            # Schema *after* the NewsItem was scraped.  In that case
            # attr_values will be empty list.
            if attr_values:
                self.update(attr_values[0])
            self.cached = True

    def __len__(self):
        # So len(self) and bool(self) work.
        self.__do_query()
        return dict.__len__(self)

    def keys(self, *args, **kwargs):
        self.__do_query()        
        return dict.keys(self, *args, **kwargs)

    def items(self, *args, **kwargs):
        self.__do_query()        
        return dict.items(self, *args, **kwargs)

    def get(self, *args, **kwargs):
        self.__do_query()
        return dict.get(self, *args, **kwargs)

    def __getitem__(self, name):
        self.__do_query()
        return dict.__getitem__(self, name)

    def __setitem__(self, name, value):
        # TODO: refactor, code overlaps largely with AttributesDescriptor.__set__
        cursor = connection.cursor()
        real_name = self.mapping[name]
        cursor.execute("""
            UPDATE %s
            SET %s = %%s
            WHERE news_item_id = %%s
            """ % (Attribute._meta.db_table, real_name), [value, self.news_item_id])
        # If no records were updated, that means the DB doesn't yet have a
        # row in the attributes table for this news item. Do an INSERT.
        if cursor.rowcount < 1:
            cursor.execute("""
                INSERT INTO %s (news_item_id, schema_id, %s)
                VALUES (%%s, %%s, %%s)""" % (Attribute._meta.db_table, real_name),
                [self.news_item_id, self.schema_id, value])
        transaction.commit_unless_managed()
        dict.__setitem__(self, name, value)


class NewsItemQuerySet(models.query.GeoQuerySet):

    """
    Adds special methods for searching :py:class:`NewsItem`.
    """

    def prepare_attribute_qs(self):
        clone = self._clone()
        if 'db_attribute' not in clone.query.extra_tables:
            clone = clone.extra(tables=('db_attribute',))
        # extra_where went away in Django 1.1.
        # This seems to be the correct replacement as per
        # http://docs.djangoproject.com/en/dev/ref/models/querysets/
        clone = clone.extra(where=('db_newsitem.id = db_attribute.news_item_id',))
        return clone

    def by_attribute(self, schema_field, att_value, is_lookup=False):
        """
        Returns a QuerySet of NewsItems whose attribute value for the given
        SchemaField is att_value.

        For example::

           items = NewsItem.objects.filter(schema_id=1)
           sf = SchemaField.objects.get(name='violation', schema_id=1)
           items.by_attribute(sf, 'unsanitary work surface')

        If att_value is a list, this will do the
        equivalent of an "OR" search, returning all NewsItems that have an
        attribute value in the att_value list.

        Handles many-to-many lookups correctly behind the scenes.

        If is_lookup is True, then each att_value must be either a
        :py:class:`Lookup` instance, or the 'code' field of a Lookup instance, or an id
        of a Lookup instance.  (If is_lookup is False, then only ids
        will work.)

        Does not support comparisons other than simple equality testing.
        """

        clone = self.prepare_attribute_qs()
        real_name = str(schema_field.real_name)
        if isinstance(att_value, models.query.QuerySet):
            att_value = list(att_value)
        if not isinstance(att_value, (list, tuple)):
            att_value = [att_value]
        if is_lookup:
            if isinstance(att_value[0], int):
                # Assume all are Lookup.id values. Get just the ones
                # that exist.
                att_value = Lookup.objects.filter(schema_field__id=schema_field.id, id__in=att_value)
            elif not isinstance(att_value[0], Lookup):
                # Assume all are Lookup.code values. Get just the ones
                # that exist.
                att_value = Lookup.objects.filter(schema_field__id=schema_field.id, code__in=att_value)
            if not att_value:
                # If the lookup values don't exist, then there aren't any
                # NewsItems with these attribute values. Note that we aren't
                # using QuerySet.none() here, because we want the result to
                # be a NewsItemQuerySet, and none() returns a normal QuerySet.
                clone = clone.extra(where=('1=0',))
                return clone
            att_value = [val.id for val in att_value]
        if schema_field.is_many_to_many_lookup():
            for value in att_value:
                if not str(value).isdigit():
                    raise ValueError('Only integer strings allowed for att_value in many-to-many SchemaFields; got %r' % value)
            # We have to use a regular expression search to look for
            # all rows with the given att_value *somewhere* in the
            # column. The [[:<:]] thing is a word boundary, and the
            # (?:) groups the possible values to distinguish them from
            # the word boundary part of the regex.
            pattern = '[[:<:]](?:%s)[[:>:]]' % '|'.join([str(val) for val in att_value])
            clone = clone.extra(where=("db_attribute.%s ~ '%s'" % (real_name, pattern),))

        elif None in att_value:
            if att_value != [None]:
                raise ValueError('by_attribute() att_value list cannot have more than one element if it includes None')
            clone = clone.extra(where=("db_attribute.%s IS NULL" % real_name,))
        else:
            clone = clone.extra(where=("db_attribute.%s IN (%s)" % (real_name, ','.join(['%s' for val in att_value])),),
                                params=tuple(att_value))
        return clone

    def date_counts(self):
        """
        Returns a dictionary mapping {item_date: count}, i.e. the number of
        :py:class:`NewsItem` created each day.
        """
        from django.db.models.query import QuerySet
        qs = QuerySet.values(self, 'item_date').annotate(count=models.Count('id'))
        # Turn off ordering, as that breaks Count; see https://docs.djangoproject.com/en/dev/topics/db/aggregation/#interaction-with-default-ordering-or-order-by
        qs = qs.order_by()
        return dict([(v['item_date'], v['count']) for v in qs])

    def top_lookups(self, schema_field, count):
        """
        Returns a list of {lookup, count} dictionaries representing the top
        Lookups for this QuerySet.
        """
        real_name = "db_attribute." + str(schema_field.real_name)
        if schema_field.is_many_to_many_lookup():
            # First prepare a subquery to get a *single* count of
            # attribute rows that match each relevant m2m lookup
            # value.  It's very important to get a single row here or
            # else we get a DataBaseError with "more than one row
            # returned by a subquery used as an expression". (Bug #146)
            clone = self.prepare_attribute_qs()
            clone = clone.filter(schema__id=schema_field.schema_id)
            # This is a regex search for the lookup id.
            clone = clone.extra(where=[real_name + " ~ ('[[:<:]]' || db_lookup.id || '[[:>:]]')"])
            # We want to count the current queryset and get a single
            # row for injecting into the subsequent Lookup query, but
            # we don't want Django's aggregation support to
            # automatically group by fields that aren't relevant and
            # would cause multiple rows as a result. So we call
            # `values()' on a field that we're already filtering by,
            # in this case, schema, as essentially a harmless identify
            # function.
            # See http://docs.djangoproject.com/en/dev/topics/db/aggregation/#values
            clone = clone.values('schema')

            # Fix #146: Having any `ORDER BY foo` in this subquery causes
            # Django to also add a `GROUP BY foo`, which potentially
            # returns multiple rows. So, remove the ordering.
            clone = clone.order_by()
            clone = clone.annotate(count=Count('schema'))
            # Unusual: We don't run the clone query, we just stuff its SQL
            # into our Lookup qs.
            qs = Lookup.objects.filter(schema_field__id=schema_field.id)
            qs = qs.extra(select={'lookup_id': 'id', 'item_count': clone.values('count').query})
        else:
            # Counts of attribute rows matching each relevant Lookup.
            # Much easier when is_many_to_many_lookup == False :-)
            qs = self.prepare_attribute_qs().extra(select={'lookup_id': real_name})
            qs.query.group_by = [real_name]
            qs = qs.values('lookup_id').annotate(item_count=Count('id'))

        qs = qs.values('lookup_id', 'item_count').order_by('-item_count')
        ids_and_counts = [(v['lookup_id'], v['item_count']) for v in qs
                          if v['item_count']]
        ids_and_counts = ids_and_counts[:count]
        lookup_objs = Lookup.objects.in_bulk([i[0] for i in ids_and_counts])
        return [{'lookup': lookup_objs[i[0]], 'count': i[1]} for i in ids_and_counts
                if not None in i]

    def text_search(self, schema_field, query):
        """
        Returns a QuerySet of NewsItems whose attribute for
        a given schema field matches a text search query.
        """
        clone = self.prepare_attribute_qs()
        query = query.lower()

        clone = clone.extra(where=("db_attribute." + str(schema_field.real_name) + " ILIKE %s",),
                            params=("%%%s%%" % query,))
        return clone

    def by_request(self, request):
        """
        Returns a QuerySet that does additional request-specific
        filtering; currently this just uses
        get_schema_manager(request) to limit the schemas that are
        visible during this request.
        """
        clone = self._clone()
        from ebpub.utils.view_utils import get_schema_manager
        allowed_schema_ids = get_schema_manager(request).allowed_schema_ids()
        return clone.filter(schema__id__in=allowed_schema_ids)


class NewsItemManager(models.GeoManager):
    """
    Available as :py:class:`NewsItem`.objects
    """
    def get_query_set(self):
        """
        Returns a :py:class:`NewsItemQuerySet`
        """
        return NewsItemQuerySet(self.model)

    def by_attribute(self, *args, **kwargs):
        """
        See :py:meth:`NewsItemQuerySet.by_attribute`
        """
        return self.get_query_set().by_attribute(*args, **kwargs)

    def text_search(self, *args, **kwargs):
        """
        See :py:meth:`NewsItemQuerySet.text_search`
        """
        return self.get_query_set().text_search(*args, **kwargs)

    def date_counts(self, *args, **kwargs):
        """
        See :py:meth:`NewsItemQuerySet.date_counts`
        """
        return self.get_query_set().date_counts(*args, **kwargs)

    def top_lookups(self, *args, **kwargs):
        """
        See :py:meth:`NewsItemQuerySet.top_lookups`
        """
        return self.get_query_set().top_lookups(*args, **kwargs)

    def by_request(self, request):
        """
        See :py:meth:`NewsItemQuerySet.by_request`
        """
        return self.get_query_set().by_request(request)


class NewsItem(models.Model):
    """
    A NewsItem is broadly defined as "something with a date and a
    location." For example, it could be a local news article, a
    building permit, a crime report, or a photo.

    For the big picture, see :ref:`newsitems`


    """

    # We don't have a natural_key() method because we don't know for
    # sure that anything other than ID will be unique.

    schema = models.ForeignKey(Schema, help_text=u'What kind of news is this and what extra fields does it have?')
    title = models.CharField(max_length=255, help_text=u'the "headline"')
    description = models.TextField(blank=True, default=u'')
    url = models.TextField(
        blank=True, default=u'',
        help_text="link to original source for this news")
    pub_date = models.DateTimeField(
        db_index=True,
        help_text='Date/time this Item was added to the OpenBlock site; default now.',
        default=datetime.datetime.now,
        blank=True,
        )
    item_date = models.DateField(
        db_index=True,
        help_text='Date (without time) this Item occurred, or failing that, the date of publication on the original source site; default today.',
        default=datetime.date.today,
        blank=True,
        )

    # Automatic last modification tracking.  Note: if changing only attributes, the
    # NewsItem should also be save()'d to update last_modification when complete.
    last_modification = models.DateTimeField(db_index=True, auto_now=True)

    location = models.GeometryField(blank=True, null=True, spatial_index=True,
                                    help_text="Coordinates where this news occurred.")
    location_name = models.CharField(max_length=255,
                                     help_text="Human-readable address or name of place where this news item occurred.")
    location_object = models.ForeignKey(Location, blank=True, null=True,
                                        help_text="Optional reference to a Location where this item occurred, for use when we know the general area but not specific coordinates.",
                                        related_name='+')

    location_set = models.ManyToManyField(
        Location, through='NewsItemLocation', blank=True, null=True,
        help_text="db.Location objects that intersect with our .location geometry. These are set automatically, do not try to assign to them.")

    objects = NewsItemManager()

    # Treat this like a dict. The related Schema and SchemaFields explain
    # what keys/ types of values you can set.
    # See the ``ebpub`` section of the docs for more information.
    # Note you do NOT need to save() the NewsItem after setting or modifying
    # this dictionary - but you do need to save() before the FIRST time you do so,
    # because the underlying Attribute instance needs a reference to the NewsItem's
    # primary key.
    attributes = AttributesDescriptor()

    def clean(self):
        if self.location is None:
            if self.location_object is None:
                logger.warn(
                    "Saving NewsItem with neither a location nor a location_object")
        else:
            self.location = ensure_valid(flatten_geomcollection(self.location))

    class Meta:
        ordering = ('title',)

    def __unicode__(self):
        return self.title or 'Untitled News Item'

    def get_absolute_url(self):
        return urlresolvers.reverse('ebpub-newsitem-detail',
                                    args=[self.schema.slug, self.id], kwargs={})

    # Backward compatibility.
    item_url = get_absolute_url

    def item_url_with_domain(self):
        return 'http://%s%s' % (settings.EB_DOMAIN, self.item_url())

    def item_date_url(self):
        from ebpub.db.schemafilters import FilterChain
        chain = FilterChain(schema=self.schema)
        chain.add('date', self.item_date)
        return chain.make_url()

    def location_url(self):
        if self.location_object_id is not None:
            return self.location_object.url()
        # TODO: look for a Block?
        return None

    def attributes_for_template(self):
        """
        Return a list of AttributeForTemplate objects for this NewsItem. The
        objects are ordered by SchemaField.display_order.
        """
        fields = SchemaField.objects.filter(schema__id=self.schema_id).select_related().order_by('display_order')
        if not fields:
            return []
        if not self.attributes:
            logger.warn("%s has fields in its schema, but no attributes!" % self)
            # Hopefully we can cope with an empty dict.
            #return []
        return [AttributeForTemplate(f, self.attributes) for f in fields]


class AttributeForTemplate(object):
    def __init__(self, schema_field, attribute_row):
        self.sf = schema_field
        if not schema_field.name in attribute_row:
            logger.warn("Attribute row %s is missing field %s" %
                        (attribute_row, schema_field.name))
        self.raw_value = attribute_row.get(schema_field.name)
        self.schema_slug = schema_field.schema.slug
        self.is_lookup = schema_field.is_lookup
        self.is_filter = schema_field.is_filter
        if self.is_lookup:
            # Earlier queries may have already looked up Lookup instances.
            # Don't do unnecessary work.
            if isinstance(self.raw_value, Lookup):
                self.values = [self.raw_value]
            elif (isinstance(self.raw_value, list) and self.raw_value
                  and isinstance(self.raw_value[0], Lookup)):
                self.values = self.raw_values
            elif self.raw_value is None or self.raw_value == '':
                self.values = []
            elif self.sf.is_many_to_many_lookup():
                try:
                    id_values = map(int, self.raw_value.split(','))
                except ValueError:
                    self.values = []
                else:
                    lookups = Lookup.objects.in_bulk(id_values)
                    self.values = [lookups[i] for i in id_values if i in lookups]
            else:
                self.values = [Lookup.objects.get(id=self.raw_value)]
        else:
            self.values = [self.raw_value]

    def value_list(self):
        """
        Returns a list of {value, url, description} dictionaries
        representing each value for this attribute.
        """
        from django.utils.dateformat import format, time_format
        # Setting these to [None] ensures that zip() returns a list
        # of at least length one.
        urls = [None]
        descriptions = [None]
        if self.is_filter:
            from ebpub.db.schemafilters import FilterChain
            chain = FilterChain(schema=self.sf.schema)
            if self.is_lookup:
                urls = [chain.replace(self.sf, look).make_url() if look else None
                        for look in self.values]
            else:
                urls = [chain.replace(self.sf, self.raw_value).make_url()]
        if self.is_lookup:
            values = [val and val.name or 'None' for val in self.values]
            descriptions = [val and val.description or None for val in self.values]
        elif isinstance(self.raw_value, datetime.datetime):
            values = [format(self.raw_value, 'F j, Y, P')]
        elif isinstance(self.raw_value, datetime.date):
            values = [format(self.raw_value, 'F j, Y')]
        elif isinstance(self.raw_value, datetime.time):
            values = [time_format(self.raw_value, 'P')]
        elif self.raw_value is True:
            values = ['Yes']
        elif self.raw_value is False:
            values = ['No']
        elif self.raw_value is None:
            values = ['N/A']
        else:
            values = [self.raw_value]
        return [{'value': value, 'url': url, 'description': description} for value, url, description in zip(values, urls, descriptions)]


class Attribute(models.Model):

    """
    Extended metadata for NewsItems.

    Each row contains all the extra metadata for one NewsItem
    instance.  The field names are generic, so in order to know what
    they mean, you must look at the SchemaFields for the Schema for
    that NewsItem.

    You don't normally access an Attribute instance directly.
    You usually go through the dictionary-like API provided by
    :ref:`newsitem_attributes`.

    """
    news_item = models.OneToOneField(NewsItem, primary_key=True, unique=True)
    schema = models.ForeignKey(Schema)
    # All data-type field names must end in two digits, because the code assumes this.
    varchar01 = models.CharField(max_length=4096, blank=True, null=True)
    varchar02 = models.CharField(max_length=4096, blank=True, null=True)
    varchar03 = models.CharField(max_length=4096, blank=True, null=True)
    varchar04 = models.CharField(max_length=4096, blank=True, null=True)
    varchar05 = models.CharField(max_length=4096, blank=True, null=True)
    date01 = models.DateField(blank=True, null=True)
    date02 = models.DateField(blank=True, null=True)
    date03 = models.DateField(blank=True, null=True)
    date04 = models.DateField(blank=True, null=True)
    date05 = models.DateField(blank=True, null=True)
    time01 = models.TimeField(blank=True, null=True)
    time02 = models.TimeField(blank=True, null=True)
    datetime01 = models.DateTimeField(blank=True, null=True)
    datetime02 = models.DateTimeField(blank=True, null=True)
    datetime03 = models.DateTimeField(blank=True, null=True)
    datetime04 = models.DateTimeField(blank=True, null=True)
    bool01 = models.NullBooleanField(blank=True)
    bool02 = models.NullBooleanField(blank=True)
    bool03 = models.NullBooleanField(blank=True)
    bool04 = models.NullBooleanField(blank=True)
    bool05 = models.NullBooleanField(blank=True)
    int01 = models.IntegerField(blank=True, null=True)
    int02 = models.IntegerField(blank=True, null=True)
    int03 = models.IntegerField(blank=True, null=True)
    int04 = models.IntegerField(blank=True, null=True)
    int05 = models.IntegerField(blank=True, null=True)
    int06 = models.IntegerField(blank=True, null=True)
    int07 = models.IntegerField(blank=True, null=True)
    text01 = models.TextField(blank=True, null=True)
    text02 = models.TextField(blank=True, null=True)

    def __unicode__(self):
        return u'Attributes for news item %s' % self.news_item_id


class LookupManager(models.Manager):

    def get_by_natural_key(self, slug, schema__slug,
                           schema_field__real_name):
        return self.get(slug=slug, schema_field__schema__slug=schema__slug,
                        schema_field__real_name=schema_field__real_name)

    def get_or_create_lookup(self, schema_field, name, code=None, description='', make_text_slug=True, logger=None):
        """
        Returns the Lookup instance matching the given SchemaField, name and
        Lookup.code, creating it (with the given name/code/description) if it
        doesn't already exist.

        If ``code`` is not provided, ``name`` will be also used as code.

        If ``make_text_slug`` is True (the default), then a slug will
        be created from the given name. If it's False, then the slug
        will be the Lookup's ID.
        """
        def log_info(message):
            if logger is None:
                return
            logger.info(message)
        def log_warn(message):
            if logger is None:
                return
            logger.warn(message)
        code = code or name # code defaults to name if it wasn't provided
        try:
            obj = Lookup.objects.get(schema_field__id=schema_field.id, code=code)
        except Lookup.DoesNotExist:
            if make_text_slug:
                slug = slugify(name)
                if len(slug) > 32:
                    log_warn("Trimming slug %r to %r in order to fit 32-char limit." % (slug, slug[:32]))
                    slug = slug[:32]
            else:
                # To avoid integrity errors in the slug when creating the Lookup,
                # use a temporary dummy slug that's guaranteed not to be in use.
                # We'll change it back immediately afterward.
                slug = '__3029j3f029jf029jf029__'
            if len(name) > 255:
                old_name = name
                name = name[:250] + '...'
                # Save the full name in the description.
                if not description:
                    description = old_name
                log_warn("Trimming name %r to %r in order to fit 255-char limit." % (old_name, name))
            if Lookup.objects.filter(schema_field=schema_field, name=name).count():
                # Avoid integrity errors on 'name'.
                old_name = name
                name = name + ' b'
                log_warn("Munging name %r to %r in order to avoid dupe." % (old_name, name))

            obj = Lookup(schema_field_id=schema_field.id, name=name, code=code, slug=slug, description=description)
            obj.save()
            if not make_text_slug:
                # Set the slug to the ID.
                obj.slug = obj.id
                obj.save()
            log_info('Created %s %r' % (schema_field.name, name))
        return obj

    def featured_lookups_for(self, newsitem, attribute_key):
        """
        Return a list of the :ref:`featured_lookups` that the
        newsitem has for the named attribute.

        Here's a rather morbid example::

          schema = Schema(name='obituary', ...)
          profession = SchemaField(schema=schema, is_lookup=True, name="profession")

        Now let's make some lookups representing a few professions::

          nurse = Lookup(schema_field=sf, name='nurse')
          programmer = Lookup(schema_field=sf, name='programmer')
          chef = Lookup(schema_field=sf, name='chef')

        And some NewsItems::

          item1 = NewsItem(schema=schema, ...)
          item1.attributes['profession'] = programmer.id

        And let's imagine that this week, we are very excited about
        recently deceased programmers::

           programmer.featured = True
           programmer.save()

        Now we can use ``featured_lookups_for`` to see if this person
        was a programmer::

          for feat in Lookup.objects.featured_lookups_for(schema, item1):
              print feat.name
          # --> prints "programmer"

        If we disable the ``featured`` flag on the Lookup, because
        people have lost interest in deceased programmers, then
        getting featured lookups on this programmer returns an empty
        list::

          programmer.featured = False
          programmer.save()
          for feat in Lookup.objects.featured_lookups_for(schema, item1):
              print feat.name
          # --> prints nothing.

        See also the
        :py:func:`featured_lookups_for_item <ebpub.db.templatetags.eb.featured_lookups_for_item>`
        template tag.

        """
        # This uses several queries, not very efficient...
        sf = SchemaField.objects.get(schema__id=newsitem.schema_id, name=attribute_key)
        # Yet another manual decode of the comma-separated value,
        # refs #265
        if sf.is_many_to_many_lookup():
            try:
                value = newsitem.attributes.get(attribute_key, None)
                if not value:
                    ni_lookup_ids = []
                else:
                    ni_lookup_ids = [int(i) for i in value.split(',')]
            except (KeyError, AttributeError):
                # This item may be lacking an Attributes row entirely?
                # Or the value may be None.
                # Not sure when/how that happens, but it'll get fixed
                # on any write to item.attributes, so don't worry
                # about it here.
                ni_lookup_ids = []
        else:
            ni_lookup_ids = [newsitem.attributes[attribute_key]]
        featured = self.filter(featured=True, id__in=ni_lookup_ids)
        return featured


class Lookup(models.Model):
    """
    Lookups are a normalized way to store Attribute fields that have only a
    few possible values.

    For more context, see :ref:`lookups`.
    """
    schema_field = models.ForeignKey(
        SchemaField,
        help_text="This must be a SchemaField whose real_name is an int or varchar column.")
    name = models.CharField(max_length=255,
                            help_text='Human-readable name of this lookup value.')
    code = models.CharField(
        max_length=255, blank=True,
        help_text='Value used for queries. May differ from `name` if `name` is modified from the original data source, eg. to make `name` prettier. `code` should not be modified from the original source data.',
        db_index=True)
    # ... For example, in scraping Chicago crimes, we use the crime type code
    # to find the appropriate crime type in this table. We can't use `name`
    # in that case, because we've massaged `name` to use a "prettier"
    # formatting than exists in the data source.

    slug = models.SlugField(max_length=32, db_index=True,
                            help_text="URL-safe identifier")
    description = models.TextField(blank=True)

    featured = models.BooleanField(blank=True, default=False,
                                   help_text="Whether this lookup value is 'special' eg. for use in navigation.")

    objects = LookupManager()

    class Meta:
        unique_together = (('slug', 'schema_field'),
                           ('code', 'schema_field'),
                           ('name', 'schema_field'),
                          )
        ordering = ('slug',)

    def natural_key(self):
        return (self.slug, self.schema_field.schema.slug,
                self.schema_field.real_name)

    def __unicode__(self):
        return u'%s - %s' % (self.schema_field, self.name)


class NewsItemLocation(models.Model):
    """

    Many-to-many mapping of :py:class:`NewsItem` to
    :py:class:`Location` where the geometries intersect.

    This is both an optimization - so we don't have to do spatial
    searches very much - and a useful abstraction in that a NewsItem
    may be relevant in any number of places.
    You can get all associated Locations from a
    NewsItem by doing ``newsitem.location_set.all()``, and all associated
    NewsItems from a Location by doing ``location.newsitem_set.all()``.

    Normally you don't have to worry about creating NewsItemLocations:
    there are database triggers that update this table whenever a
    NewsItem's location is set or updated.

    """
    news_item = models.ForeignKey(NewsItem)
    location = models.ForeignKey(Location)

    class Meta:
        unique_together = (('news_item', 'location'),)

    def __unicode__(self):
        return u'%s - %s' % (self.news_item, self.location)


#############################################################################
# Aggregates.

class AggregateBaseClass(models.Model):
    """
    Aggregates provide for quick lookups of NewsItems by various buckets,
    eg. number of NewsItems added on one day.
    """
    schema = models.ForeignKey(Schema)
    total = models.IntegerField()

    class Meta:
        abstract = True


class AggregateAll(AggregateBaseClass):
    """Total items in the schema.
    """
    pass


class AggregateDay(AggregateBaseClass):
    """Total items in the schema with item_date on the given day
    """
    date_part = models.DateField(db_index=True)


class AggregateLocation(AggregateBaseClass):
    """Total items in the schema in location, summed over that last 30 days
    """
    location_type = models.ForeignKey(LocationType)
    location = models.ForeignKey(Location)

class AggregateLocationDay(AggregateBaseClass):
    """Total items in the schema in location with item_date on the given day
    """
    location_type = models.ForeignKey(LocationType)
    location = models.ForeignKey(Location)
    date_part = models.DateField(db_index=True)


class AggregateFieldLookup(AggregateBaseClass):
    """Total items in the schema with schema_field's value = lookup
    """
    schema_field = models.ForeignKey(SchemaField)
    lookup = models.ForeignKey(Lookup)


class SearchSpecialCase(models.Model):
    """
    Used as a fallback for location searches that don't match
    any Location, Intersection, etc.
    """
    query = models.CharField(
        max_length=64, unique=True,
        help_text='Normalized form of search queries that match this special case.'
        )  # TODO: normalize this on save
    redirect_to = models.CharField(
        max_length=255, blank=True,
        help_text='Optional absolute URL to redirect to on searches that match the query.')
    title = models.CharField(
        max_length=128, blank=True,
        help_text="Title to display on the results page if we don't redirect."
        )
    body = models.TextField(
        blank=True,
        help_text="Body to display on the result page if we don't redirect. HTML is OK.")

    def __unicode__(self):
        return self.query


class DataUpdate(models.Model):
    """Scraper scripts can use this to keep track of
    each time we populate NewsItems of a given Schema.
    """
    schema = models.ForeignKey(Schema)
    update_start = models.DateTimeField(
        help_text="When the scraper/importer started running.")
    update_finish = models.DateTimeField(
        help_text="When the scraper/importer finished.")
    num_added = models.IntegerField()
    num_changed = models.IntegerField()
    num_deleted = models.IntegerField()
    num_skipped = models.IntegerField()
    got_error = models.BooleanField()

    def __unicode__(self):
        return u'%s started on %s' % (self.schema.name, self.update_start)

    def total_time(self):
        return self.update_finish - self.update_start

def get_city_locations():
    """
    If we have configured multiple_cities, find all Locations
    of the city_location_type.
    Otherwise, empty query set.
    """
    from ebpub.metros.allmetros import get_metro
    metro = get_metro()
    if metro['multiple_cities']:
        cities = Location.objects.filter(location_type__slug=metro['city_location_type'])
        cities = cities.exclude(location_type__name__startswith='Unknown')
        return cities
    else:
        return Location.objects.filter(id=None)


class NewsItemImage(models.Model):
    """
    NewsItems can optionally be associated with any number of images.
    """

    news_item = models.ForeignKey(NewsItem)
    # Note max_length = filename.
    image = OpenblockImageField(upload_to=settings.MEDIA_ROOT, max_length=256,
                                help_text='Upload an image')

    class Meta(object):
        unique_together = (('news_item', 'image'),)

    def __unicode__(self):
        return u'%s - %s' % (self.news_item, self.image.name)

###########################################
# Signals                                 #
###########################################

# Django doesn't provide a pre_update() signal, rats.
# See https://code.djangoproject.com/ticket/13021
from django.dispatch import Signal
from django.db.models.signals import post_save, post_delete

post_update = Signal(providing_args=[])

def clear_allowed_schema_ids_cache(sender, **kwargs):
    cache.delete_many((SchemaPublicManager._allowed_ids_cache_key,
                       SchemaManager._allowed_ids_cache_key))

post_update.connect(clear_allowed_schema_ids_cache, sender=Schema)
post_save.connect(clear_allowed_schema_ids_cache, sender=Schema)
post_delete.connect(clear_allowed_schema_ids_cache, sender=Schema)

########NEW FILE########
__FILENAME__ = schemafilters
#   Copyright 2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
API that abstracts filtering NewsItems by various criteria.
Features:

* validation of filter parameters.
* detecting when more user input is needed, so views can provide a
  disambiguation UI.
* consistent normalized URLs and breadcrumbs.
* consistent order of filter application

TODO:
 *  generate URLs for the REST API too?

 *  profile optimal order of filters for sort()?
    Currently guessing it should be something like:
    schema, date, non-lookup attrs, block/location, lookup attrs, text search.
    This will need profiling with lots of test data.
"""

from django.utils import dateformat
from django.utils.datastructures import SortedDict
from ebpub.db import constants
from ebpub.db import models
from ebpub.db.utils import block_radius_value
from ebpub.db.utils import make_search_buffer
from ebpub.db.utils import url_to_block
from ebpub.db.utils import url_to_location
from ebpub.geocoder import SmartGeocoder, AmbiguousResult, GeocodingException
from ebpub.geocoder.parser.parsing import ParsingError
from ebpub.metros.allmetros import get_metro
from ebpub.utils.dates import parse_date
from ebpub.utils.view_utils import parse_pid
from ebpub.utils.view_utils import get_schema_manager

import calendar
import datetime
import ebpub.streets.models
import logging
import posixpath
import re
import urllib

logger = logging.getLogger('ebpub.db.schemafilters')

class NewsitemFilter(object):

    """
    Base class for filtering NewsItems.
    """

    _sort_value = 100.0  # Used by FilterChain for sorting filters.

    # Various attributes used for URL construction, breadcrumbs,
    # and for display in templates.
    # If these are None, they should not be shown to the user.

    slug = None   # ID for this type of filter. Used with FilterChain.add() / .remove()
    value = None  # Value fed to the filter, for display.
    label = None  # Human-readable name of the filter, for display.
    short_value = None  # Shorter version of value fed to the filter, for display.
    argname = None  # For generating query parameters for URLs.
    query_param_value = None  # For generating query parameters for URLs.

    def __init__(self, request, context, queryset=None, *args, **kw):
        self.qs = queryset if (queryset is not None) else models.NewsItem.objects.all()
        self.context = context
        self.request = request
        self._got_args = False

    def apply(self):
        """mutate *and* return the queryset, and modify any other state that
        needs sharing with others.
        """
        raise NotImplementedError # pragma: no cover

    def validate(self):
        """
        If we didn't get enough info from the args, eg. it's a
        Location filter but no location was specified, then return a
        dict of stuff for putting in a template context.

        If we have enough information, returns an empty dict.

        The dict keys are::
            'filter_key': The filter slug.
            'param_name': Query parameter for this filter, for forms or URLs.
            'param_label': Human-readable name of this filter.
            'option_list': A list of possible argument values for this
            filter. Each is a dict with keys 'value' (usable for input
            values) and 'name' (human-readable).
            'select_multiple': boolean, whether you can filter on more than one value.

        ... or maybe this should be something more generic across both REST
        and UI views
        """
        # TODO: Maybe split this into .get_extra_context() -> dict
        # and .needs_more_info() -> bool
        raise NotImplementedError  # pragma: no cover

    def __getitem__(self, key):
        # Emulate a dict to make legacy code in ebpub.db.breadcrumbs happy
        try:
            return getattr(self, key)
        except AttributeError:
            raise KeyError(key)

    def get_query_params(self):
        """
        Suitable for composing query strings out of dictionaries.
        """
        return {self.argname: self.query_param_value or ''}


class FilterError(Exception):
    """
    All-purpose exception for invalid filter parameters and the like.

    If self.url is set, it may be used for redirection.
    """
    def __init__(self, msg, url=None):
        self.msg = msg
        self.url = url

    def __str__(self):
        return repr(self.msg)


class IdFilter(NewsitemFilter):
    """
    Filters by NewsItem ids, which may be a list.
    """
    _sort_value = 1
    slug = 'id'
    label = u'id'
    argname = 'id'
    value = None

    def __init__(self, request, context, queryset, *args, **kwargs):
        NewsitemFilter.__init__(self, request, context, queryset, *args, **kwargs)
        self.ids = kwargs.pop('ids', None)
        if self.ids is None:
            self._got_args = False
            self.ids = []
        else:
            self._got_args = True
            if not isinstance(self.ids, (list, tuple)):
                self.ids = [self.ids]
        self.query_param_value = ','.join([str(i) for i in self.ids])
        self.value = self.query_param_value

    def apply(self):
        """Filtering by ID.
        """
        self.qs = self.qs.filter(id__in=self.ids)
        return self.qs

    def validate(self):
        if self._got_args:
            return {}
        return {
            'filter_key': self.slug,
            'param_name': self.argname,
            'param_label': self.argname,
            'option_list': [],  # Not gonna list all IDs.
            'select_multiple': True,
            }


class SchemaFilter(NewsitemFilter):
    """
    Filters by NewsItem.schema, which may be a list.

    Schemas that the current user is not allowed to see will be filtered out.
    """
    _sort_value = -1  # Me first!!
    slug = 'schema'
    url = None
    label = None  # Don't show this one in the UI.
    value = None

    def __init__(self, request, context, queryset, *args, **kwargs):
        NewsitemFilter.__init__(self, request, context, queryset, *args, **kwargs)
        self.schema = kwargs['schema']

    def validate(self):
        return {}

    @property
    def schemas(self):
        if isinstance(self.schema, (list, tuple)):
            schemas = self.schema
        else:
            schemas = [self.schema]
        return schemas

    def apply(self):
        schema_ids = [s.id for s in self.schemas]
        if self.request:
            allowed_schema_ids = get_schema_manager(self.request).allowed_schema_ids()
            schema_ids = set(schema_ids).intersection(allowed_schema_ids)
            self.qs = self.qs.filter(schema__id__in=schema_ids)

    def get_query_params(self):
        # This one is part of the URL path so doesn't need any.
        return {}


class AttributeFilter(NewsitemFilter):

    """
    Base class for more specific types of attribute filters
    (LookupFilter, TextSearchFilter, etc).
    """

    _sort_value = 101.0

    def __init__(self, request, context, queryset, *args, **kwargs):
        NewsitemFilter.__init__(self, request, context, queryset, *args, **kwargs)
        self.schemafield = kwargs['schemafield']
        self.slug = self.schemafield.name
        self.argname = 'by-%s' % self.slug
        self.value = self.short_value = ''  # Descriptions of this filter, for display.
        self.label = self.schemafield.pretty_name
        if args:
            # This should work for int and varchar fields. (TODO: UNTESTED)
            self.att_value = args[0]
            self._got_args = True
            if isinstance(self.att_value, datetime.datetime):
                # Zone??
                str_att_value = self.att_value.strftime('%Y-%m-%dT%H:%M:%S')
            elif isinstance(self.att_value, datetime.date):
                str_att_value = self.att_value.strftime('%Y-%m-%d')
            elif isinstance(self.att_value, datetime.time):
                str_att_value = self.att_value.strftime('%H:%M:%S')
            else:
                str_att_value = str(self.att_value)
            self.query_param_value = str_att_value

    def apply(self):
        self.qs = self.qs.by_attribute(self.schemafield, self.att_value)


class TextSearchFilter(AttributeFilter):

    """Does a text search on values of the given attribute.
    """

    _sort_value = 1000.0

    def __init__(self, request, context, queryset, *args, **kwargs):
        AttributeFilter.__init__(self, request, context, queryset, *args, **kwargs)
        self.label = self.schemafield.pretty_name
        if not args:
            raise FilterError('Text search lookup requires search params')
        self.query = ', '.join(args)
        self.short_value = self.query
        self.value = self.query
        self.argname = 'by-' + self.schemafield.name
        self.query_param_value = ','.join(args)

    def apply(self):
        self.qs = self.qs.text_search(self.schemafield, self.query)

    def validate(self):
        return {}

class BoolFilter(AttributeFilter):

    """
    Filters on boolean attributes.
    """

    _sort_value = 100.0

    def __init__(self, request, context, queryset, *args, **kwargs):
        AttributeFilter.__init__(self, request, context, queryset, *args, **kwargs)
        if len(args) > 1:
            raise FilterError("Invalid boolean arg %r" % ','.join(args))
        elif len(args) == 1:
            self.boolslug = args[0]
            self.real_val = {'yes': True, 'no': False, 'na': None}.get(self.boolslug, self.boolslug)
            if self.real_val not in (True, False, None):
                raise FilterError('Invalid boolean value %r' % self.boolslug)
            self.argname = 'by-%s' % self.schemafield.name
            self.query_param_value = self.boolslug
            self._got_args = True
        else:
            # No args.
            self.value = u'By whether they %s' % self.schemafield.pretty_name_plural
            self._got_args = False

    def validate(self):
        if self._got_args:
            return {}
        return {
            'filter_key': self.slug,
            'param_name': self.argname,
            'param_label': self.value[3:],
            'option_list': [{'value': 'yes', 'name': 'Yes'}, {'value': 'no', 'name': 'No'}, {'value': 'na', 'name': 'N/A'}],
            'select_multiple': True,
            }


    def apply(self):
        self.qs = self.qs.by_attribute(self.schemafield, self.real_val)
        self.short_value = {True: 'Yes', False: 'No', None: 'N/A'}[self.real_val]
        self.value = u'%s%s: %s' % (self.label[0].upper(), self.label[1:], self.short_value)


class LookupFilter(AttributeFilter):
    """
    Filters on Lookup attributes (see ebpub.db.models for more info).

    *Note* the args are expected to be either Lookup instances or
    Lookup.slug, but *not* Lookup.code, because the slugs are safe for use
    in URLs and the codes may not be.
    """

    _sort_value = 900.0

    def __init__(self, request, context, queryset, *args, **kwargs):
        AttributeFilter.__init__(self, request, context, queryset, *args, **kwargs)
        self.lookups = []
        slugs = []
        maybe_lookups = args
        self._got_args = bool(maybe_lookups)
        if self._got_args:
            if not isinstance(maybe_lookups, (list, tuple)):
                maybe_lookups = [maybe_lookups]
            for candidate in maybe_lookups:
                if isinstance(candidate, models.Lookup):
                    self.lookups.append(candidate)
                    slugs.append(candidate.slug)
                else:
                    try:
                        lookup = models.Lookup.objects.get(
                            schema_field__id=self.schemafield.id, slug=candidate)
                        self.lookups.append(lookup)
                        slugs.append(lookup.slug)
                    except models.Lookup.DoesNotExist:
                        raise FilterError("No such lookup %r" % candidate)
            self.value = ', '.join([lk.name for lk in self.lookups])
            self.short_value = self.value
            self.query_param_value = ','.join(slugs)

    def validate(self):
        if self._got_args:
            return {}
        option_list = models.Lookup.objects.filter(schema_field__id=self.schemafield.id).order_by('name')
        option_list = [{'name': lookup.name, 'value': lookup.slug}
                       for lookup in option_list]
        return {
            'filter_key': self.slug,
            'param_name': self.argname,
            'param_label': self.schemafield.pretty_name_plural,
            'option_list': option_list,
            'select_multiple': True,
        }

    def apply(self):
        self.qs = self.qs.by_attribute(self.schemafield, self.lookups, is_lookup=True)


class LocationFilter(NewsitemFilter):

    """
    Filters on intersecting ebpub.db.models.Location.
    """

    _sort_value = 200.0

    slug = 'location'
    argname = 'locations'

    def __init__(self, request, context, queryset, *args, **kwargs):
        NewsitemFilter.__init__(self, request, context, queryset, *args, **kwargs)
        self.location_object = None
        if 'location' in kwargs:
            self._update_location(kwargs['location'])
            self._got_args = True
        else:
            if 'location_type' in kwargs:
                self.location_type = kwargs['location_type']
                self.location_type_slug = self.location_type.slug
                self.label = self.location_type.name
            else:
                if not args:
                    raise FilterError("Not enough args, need a location type")
                self.location_type_slug = args[0]
            self.value = 'Choose %s' % self.location_type_slug.title()
            self.query_param_value = self.location_type_slug
            try:
                self.location_slug = args[1]
                self._got_args = True
            except IndexError:
                self._got_args = False

        if self._got_args and self.location_object is None:
            loc = url_to_location(self.location_type_slug, self.location_slug)
            self._update_location(loc)

    def _update_location(self, loc):
        self.location_slug = loc.slug
        self.location_type = loc.location_type
        self.location_type_slug = loc.location_type.slug
        self.label = loc.location_type.name
        self.short_value = loc.name
        self.value = loc.name
        self.location_name = loc.name
        self.location_object = loc
        self.query_param_value = '%s,%s' % (self.location_type_slug,
                                            self.location_slug)


    def validate(self):
        # List of available locations for this location type.
        if self._got_args:
            return {}
        else:
            option_list = models.Location.objects.filter(location_type__slug=self.location_type_slug, is_public=True).order_by('display_order')
            if not option_list:
                raise FilterError("empty lookup list")
            location_type = option_list[0].location_type
            option_list = [
                {'name': loc.pretty_name,
                 'value': '%s,%s' % (self.location_type_slug, loc.slug)}
                for loc in option_list]
            return {
                'filter_key': self.slug,
                'param_name': self.argname,
                'param_label': location_type.name,
                'option_list': option_list,
                'select_multiple': False,
                }


    def apply(self):
        """
        filtering by Location
        """
        loc = self.location_object
        self.qs = self.qs.filter(newsitemlocation__location__id=loc.id)


class BlockFilter(NewsitemFilter):

    """
    Filters on intersecting ebpub.streets.models.Block.
    """
    slug = 'location'

    _sort_value = 200.0

    def _update_block(self, block):
        self.location_object = self.context['place'] = block
        self.city_slug = block.city  # XXX is that a slug?
        self.street_slug = block.street_slug
        self.block_range = block.number() + block.dir_url_bit()
        self.label = 'Area'
        # Assume we already have self.block_radius.
        value = '%s block%s around %s' % (self.block_radius, (self.block_radius != '1' and 's' or ''), block.pretty_name)
        self.short_value = value
        self.value = value
        self.argname = 'streets'
        self.query_param_value = []
        if get_metro()['multiple_cities']:
            self.query_param_value.append(self.city_slug)
        self.query_param_value.extend([block.street_slug,
                                       block.number() + block.dir_url_bit(),
                                       radius_slug(self.block_radius)])
        self.query_param_value = ','.join(self.query_param_value)
        self.location_name = block.pretty_name
        self._got_args = True

    def __init__(self, request, context, queryset, *args, **kwargs):
        NewsitemFilter.__init__(self, request, context, queryset, *args, **kwargs)
        self.location_object = None
        args = list(args)

        if 'block' not in kwargs:
            # We do this first so we consume the right number of args
            # before getting to block_radius.
            try:
                if get_metro()['multiple_cities']:
                    self.city_slug = args.pop(0)
                else:
                    self.city_slug = ''
                self.street_slug = args.pop(0)
                self.block_range = args.pop(0)
            except IndexError:
                raise FilterError("not enough args, need a street and a block range")

        try:
            block_radius = args.pop(0)
            self.block_radius = radius_from_slug(block_radius)
        except (TypeError, ValueError):
            raise FilterError('bad radius %r' % block_radius)
        except IndexError:
            self.block_radius = context.get('block_radius')
            if self.block_radius is None:
                # Redirect to a URL that includes some radius, either
                # from a cookie, or the default radius.
                # TODO: Filters are used in various contexts, but the
                # redirect URL is tailored only for the schema_filter
                # view.
                xy_radius, block_radius, cookies_to_set = block_radius_value(request)
                radius_param = urllib.quote(',' + radius_slug(block_radius))
                radius_url = request.get_full_path() + radius_param
                raise FilterError('missing radius', url=radius_url)

        if 'block' in kwargs:
            # needs block_radius to already be there.
            self._update_block(kwargs['block'])

        if self.location_object is not None:
            block = self.location_object
        else:
            m = re.search('^%s$' % constants.BLOCK_URL_REGEX, self.block_range)
            if not m:
                raise FilterError('Invalid block URL: %r' % self.block_range)
            url_to_block_args = m.groups()

            block = url_to_block(self.city_slug, self.street_slug,
                                 *url_to_block_args)
            self._update_block(block)
        self._got_args = True


    def validate(self):
        # Filtering UI does not provide a page for selecting a block.
        return {}

    def apply(self):
        """filtering by Block.
        """
        block = self.location_object
        search_buf = make_search_buffer(block.location.centroid, self.block_radius)
        self.qs = self.qs.filter(location__bboverlaps=search_buf)
        return self.qs


class DateFilter(NewsitemFilter):

    """Filters on NewsItem.item_date.
    The start_date and end_date args are *inclusive*.
    They can be the same; missing end_date implies start == end.
    """

    slug = 'date'
    date_field_name = 'item_date'
    argname = 'by-date'

    _sort_value = 1.0

    def __init__(self, request, context, queryset, *args, **kwargs):
        NewsitemFilter.__init__(self, request, context, queryset, *args, **kwargs)
        args = list(args)
        schema = kwargs.get('schema') or context.get('schema')
        if schema is not None:
            if isinstance(schema, list):
                # Um. Use the first schema? This is rather arbitrary.
                schema = schema[0]
            self.label = schema.date_name
        else:
            self.label = self.slug
        gte_kwarg = '%s__gte' % self.date_field_name
        lt_kwarg = '%s__lt' % self.date_field_name
        if not args:
            raise FilterError("Missing date range")

        start_date = args[0]
        end_date = args[-1]

        def _parse(date):
            # Ugh, papering over wild proliferation of date formats.
            try:
                date = parse_date(date, '%m/%d/%Y')
            except ValueError:
                try:
                    date = parse_date(date, '%Y/%m/%d')
                except ValueError:
                    try:
                        date = datetime.date(*map(int, date.split('-')))
                    except ValueError:
                        raise BadDateException("Unknown date format on %r" % date)
            return date

        assert end_date is not None

        if isinstance(start_date, basestring):
            start_date = _parse(start_date)
        if isinstance(end_date, basestring):
            end_date = _parse(end_date)
        elif end_date is None:
            end_date = start_date

        for d in (start_date, end_date):
            if d and d.year < 1900:
                # This prevents strftime from throwing a ValueError.
                raise BadDateException('Dates before 1900 are not supported.')

        assert end_date is not None
        self.start_date = start_date
        self.end_date = end_date

        self.kwargs = {
            gte_kwarg: self.start_date,
            lt_kwarg: self.end_date+datetime.timedelta(days=1)
            }

        if self.start_date == self.end_date:
            self.value = dateformat.format(self.start_date, 'N j, Y')
        else:
            self.value = u'%s - %s' % (dateformat.format(self.start_date, 'N j, Y'), dateformat.format(self.end_date, 'N j, Y'))
        self.short_value = self.value

    def get_query_params(self):
        return {'start_date': self.start_date.strftime('%Y-%m-%d'),
                'end_date': self.end_date.strftime('%Y-%m-%d')}

    def validate(self):
        # Filtering UI does not provide a page for selecting a date.
        return {}

    def apply(self):
        """ filtering by Date """
        self.qs = self.qs.filter(**self.kwargs)


class PubDateFilter(DateFilter):

    """
    Filters on NewsItem.pub_date.
    """

    argname = 'by-pubdate'
    date_field_name = 'pub_date'

    _sort_value = 1.0

    def __init__(self, request, context, queryset, *args, **kwargs):
        DateFilter.__init__(self, request, context, queryset, *args, **kwargs)
        self.label = 'date published'

    def get_query_params(self):
        return {'start_pubdate': self.start_date.strftime('%Y-%m-%d'),
                'end_pubdate': self.end_date.strftime('%Y-%m-%d')}


class DuplicateFilterError(FilterError):
    """
    Raised if we try to add conflicting filters to a FilterChain.
    """
    pass

class FilterChain(SortedDict):

    """
    A set of NewsitemFilters, to be applied in a predictable order.

    The update_from_request() method can be used to configure one
    based on the request URL.

    Also handles URL generation.
    """

    _base_url = ''
    schema = None

    def __repr__(self):
        return u'FilterChain(%s)' % SortedDict.__repr__(self)

    def __init__(self, data=None, request=None, context=None, queryset=None, schema=None):
        SortedDict.__init__(self, data=None)
        self.request = request
        self.context = context if context is not None else {}
        self.qs = queryset
        if data is not None:
            # We do this to force our __setitem__ to get called
            # so it will raise error on dupes.
            self.update(data)
        self.lookup_descriptions = []  # Lookup instances used for blurbs for templates.
        self.schema = schema
        if schema:
            self.add('schema', SchemaFilter(request, context, queryset, schema=schema))
        self.other_query_params = {}

    def __setitem__(self, key, value):
        """
        stores a NewsitemFilter, and raises DuplicateFilterError if the
        key exists.
        """
        if self.has_key(key):
            raise DuplicateFilterError(key)
        SortedDict.__setitem__(self, key, value)

    def update(self, dict_):
        # Need this until http://code.djangoproject.com/ticket/15812
        # gets accepted & released.
        if getattr(dict_, 'iteritems', None) is not None:
            dict_ = dict_.iteritems()
        for k, v in dict_:
            # This works for tuples, lists, and other iterators too.
            self[k] = v

    def update_from_request(self, filter_sf_dict):
        """Update the list of filters based on the request params.

        After this is called, it's recommended to redirect to a
        normalized form of the URL, which you can get via self.sort();
        self.make_url()

        ``filter_sf_dict`` is a mapping of name -> SchemaField which have
        either is_filter or is_searchable True.  We remove
        SchemaFields that we create filters for. (This is so that
        templates can display input widgets for the ones we're not
        already filtering by.)

        TODO: This should not bail out on the first error,
        it should do as much as possible and signal multiple errors.
        (Use the forms framework?)
        """
        request, context = self.request, self.context
        qs = self.qs
        params = request.GET.copy()

        def pop_key(key, single=False):
            """
            Pop the value(s) from params, treat it as a
            comma-separated list of values, and split that into a
            list. So ?foo=bar,baz is equivalent to ?foo=bar&foo=baz.

            If single==True, return only the first one; in the example
            we'd return 'bar'.  Otherwise, by default, return the
            list; in the example we'd return ['bar', 'baz']
            """
            result = []
            # Doesn't seem to be a way to get a list of values *and*
            # remove it in one call; so use both getlist() and pop().
            values = params.getlist(key) or [u'']
            params.pop(key, None)
            for value in values:
                value = value.replace(u'+', u' ') # XXX does django do this already?
                values = [s.strip() for s in value.split(u',')]
                result.extend(values)
            result = [r for r in result if r]
            if single:
                return result[0] if result else u''
            return result

        # IDs.
        ids = pop_key('id', single=False)
        if ids:
            self.replace('id', *ids)

        # Address.
        address = pop_key('address', single=True)
        if address:
            xy_radius, block_radius, cookies_to_set = block_radius_value(request)
            pop_key('radius')  # Just to remove it, block_radius_value() used it.
            result = None
            try:
                result = SmartGeocoder().geocode(address)
            except AmbiguousResult, e:
                raise BadAddressException(address, block_radius, address_choices=e.choices)
            except (GeocodingException, ParsingError):
                raise BadAddressException(address, block_radius, address_choices=())
            assert result
            if result['block']:
                block = result['block']
            elif result['intersection']:
                try:
                    block = result['intersection'].blockintersection_set.all()[0].block
                except IndexError:
                    # TODO: Not sure this was deliberate, but we used to
                    # call intersection.url() here, which would
                    # raise an IndexError here if there was no
                    # matching block.  Preserving that behavior.
                    # Should this be BadAddressException?
                    raise
            else:
                # TODO: should this be BadAddressException?
                raise NotImplementedError('Reached invalid geocoding type: %r' % result)
            self.replace('location', block, block_radius)

        # Dates.
        # For hysterical reasons we support several ways of passing
        # these in.  TODO: consolidate these into ONLY the start_ and
        # end_ variants, no more of the comma-separated by-date stuff.
        # The latter are more compact, but a) more work on the client
        # side, and b) look uglier in URLs due to the url-quoted
        # comma.
        pub_start_and_end = [pop_key('start_pubdate', single=True),
                             pop_key('end_pubdate', single=True)]
        pub_start_and_end = [s for s in pub_start_and_end if s]
        pub_dates = pop_key('by-pubdate') or pub_start_and_end

        start_and_end = [pop_key('start_date', single=True),
                         pop_key('end_date', single=True)]
        start_and_end = [s for s in start_and_end if s]
        dates = pop_key('by-date') or start_and_end

        if dates and pub_dates:
            raise DuplicateFilterError("You can only filter by one set of dates.")
        elif dates:
            self['date'] = DateFilter(request, context, qs, *dates,
                                      schema=self.schema)
        elif pub_dates:
            self['date'] = PubDateFilter(request, context, qs, *pub_dates,
                                         schema=self.schema)

        # Text searches. Apparently we only support one at a time.
        lookup_name = pop_key('textsearch', single=True)
        search_string = pop_key('q', single=True)
        if lookup_name and search_string:
            # Can raise DoesNotExist. Should that be FilterError?
            schemafield = models.SchemaField.objects.get(name=lookup_name,
                                                         schema=self.schema)
            self.replace(schemafield, search_string)

        # All remaining args.
        for argname in params.keys():

            # Street/address
            if argname.startswith('streets'):
                argvalues = pop_key(argname)
                self['location'] = BlockFilter(request, context, qs, *argvalues)

            # Location filtering
            elif argname.startswith('locations'):
                argvalues = pop_key(argname)
                self['location'] = LocationFilter(request, context, qs, *argvalues)

            # Attribute filtering
            elif argname.startswith('by-'):
                argvalues = pop_key(argname)
                sf_name = argname[3:]
                try:
                    sf = filter_sf_dict.pop(sf_name)
                except KeyError:
                    raise FilterError('Invalid or duplicate SchemaField name %r' % sf_name)
                self.add_by_schemafield(sf, *argvalues, _replace=True)
            else:
                # Unknown param, ignore it.
                pass


        self.sort()
        # Stash any un-consumed query params for URL construction.
        self.other_query_params = params
        return self


    def validate(self):
        """Check whether any of the filters were requested without
        a required value.  If so, return info about what's needed,
        as a dict.  Stops on the first one that returns anything.

        Can raise FilterError.
        """
        for key, filt in self.items():
            more_needed = filt.validate()
            if more_needed:
                return more_needed
        return {}

    def apply(self, queryset=None):
        """
        Applies each filter in the chain.
        """
        for key, filt in self._sorted_items():
            # TODO: this is an awkward way of passing the queryset.
            if queryset is not None:
                filt.qs = queryset
            filt.apply()
            queryset = filt.qs

        if self.request and (not 'schema' in self):
            queryset = queryset.by_request(self.request)
        return queryset

    def copy(self):
        # Overriding because default dict.copy() re-inits attributes,
        # and we want copies to be independently mutable.
        # Unfortunately this seems to require explicitly copying
        # all attributes we care about.
        clone = self.__class__()
        clone.lookup_descriptions = self.lookup_descriptions[:]
        clone._base_url = self._base_url
        clone.schema = self.schema
        clone.request = self.request
        clone.context = self.context
        clone.other_query_params = self.other_query_params
        clone.update(self)
        return clone

    def sort(self):
        """
        Put keys in optimal order.
        """
        items = self._sorted_items()
        self.clear()
        self.update(items)

    def _sorted_items(self):
        items = self.items()
        return sorted(items, key=lambda item: item[1]._sort_value)

    def replace(self, key, *values):
        """Same as self.add(), but instead of raising DuplicateFilterError
        on existing keys, replaces them.
        """
        if key in self:
            del self[key]
        return self.add(key, *values, _replace=True)


    def add(self, key, *values, **kwargs):
        """Given a key that is a string or a SchemaField, construct an
        appropriate NewsitemFilter with the values as arguments, and
        save it as self[key], where the new key is either the string
        key or derived automatically from the SchemaField.

        This does no parsing of values.  The filter added may be
        determined by the type of the values passed. Eg. if the value
        is a Block, Location, or LocationType, a LocationFilter or
        BlockFilter will be added under the key 'location'.  If the
        value is a datetime, a DateFilter or PubDateFilter will be
        added depending on the key.

        Yes, this smells too complicated.

        For convenience, this returns self.
        """
        # Unfortunately there's no way to accept a single optional named arg
        # at the same time as accepting arbitrary *values.
        _replace = kwargs.pop('_replace', False)
        if kwargs:
            raise TypeError("unexpected keyword args %s" % kwargs.keys())

        values = list(values)
        if isinstance(key, models.SchemaField):
            return self.add_by_schemafield(key, *values, **{'_replace': _replace})

        if not values:
            raise FilterError("no values passed for arg %s" % key)

        if key == 'id':
            val = IdFilter(self.request, self.context, self.qs, ids=values)

        elif isinstance(values[0], models.Location):
            val = LocationFilter(self.request, self.context, self.qs, location=values[0])
            key = val.slug
        elif isinstance(values[0], ebpub.streets.models.Block):
            block = values.pop(0)
            val = BlockFilter(self.request, self.context, self.qs, *values, block=block)
            key = val.slug
        elif isinstance(values[0], models.LocationType):
            val = LocationFilter(self.request, self.context, self.qs, *values[1:], location_type=values[0])
            key = val.slug
        elif isinstance(values[0], models.Lookup):
            key = values[0].schema_field
            val = LookupFilter(self.request, self.context, self.qs, *values,
                               schemafield=key)
        elif isinstance(values[0], (datetime.date, datetime.datetime)):
            if len(values) == 1:
                # start and end are the same date.
                values.append(values[0])
            if values[1] == 'month':
                # Whole month, regardless of precise day of first value.
                # TODO: document this!!
                _unused, end = calendar.monthrange(values[0].year, values[0].month)
                values[0] = values[0].replace(day=1)
                values[1] = values[0].replace(day=end)
            if key in ('pubdate', 'pub_date'):  # argh
                key = 'date'
                val = PubDateFilter(self.request, self.context, self.qs, *values, schema=self.schema)
            else:
                val = DateFilter(self.request, self.context, self.qs, *values, schema=self.schema)
        elif isinstance(values[0], models.Schema) or (isinstance(values[0], list) and values[0] and isinstance(values[0][0], models.Schema)):
            key = 'schema'
            schema = values[0]
            val = SchemaFilter(self.request, self.context, self.qs, *values, schema=schema)
            self.schema = schema
            for filt in self.values():
                # TODO: this may be too late if some things depend on
                # schema during __init__()
                filt.schema = schema
        else:
            val = values[0]
            # We seem to get some unexpected types here sometimes:
            # dicts, strings...
            if not isinstance(val, NewsitemFilter):
                logger.warn("SchemaFilter.add called with key %r and unexpected values %r, not adding."
                            % (key, values))
                if self.request:
                    logger.warn('path was: %s' % self.request.get_full_path())
                return self

        if _replace and key in self:
            del self[key]
        self[key] = val
        return self

    def add_by_schemafield(self, schemafield, *values, **kwargs):
        """Given a SchemaField, construct an appropriate
        NewsitemFilter with the values as arguments, and save it as
        self[schemafield.name].

        For convenience, returns self.
        """
        # Unfortunately there's no way to accept a single optional named arg
        # at the same time as accepting arbitrary *values.
        _replace = kwargs.pop('_replace', False)
        if kwargs:
            raise TypeError("unexpected keyword args %s" % kwargs.keys())

        values = list(values)
        key = schemafield.name
        if schemafield.is_lookup:
            filterclass = LookupFilter
        elif schemafield.is_type('bool'):
            filterclass = BoolFilter
        elif schemafield.is_searchable:
            filterclass = TextSearchFilter
        else:
            # Ints, varchars, dates, times, and datetimes.
            filterclass = AttributeFilter

        if _replace and key in self:
            del self[key]

        self[key] = filterclass(self.request, self.context, self.qs, schemafield=schemafield, *values)

        if schemafield.is_lookup:
            self.lookup_descriptions.extend(getattr(self[key], 'lookups', []))
        return self

    def make_breadcrumbs(self, additions=(), removals=(), stop_at=None, 
                         base_url=None):
        """
        Returns a list of (label, URL) pairs suitable for making
        breadcrumbs for the schema_filter view.

        If ``base_url`` is passed, URLs generated will be include that
        that; otherwise fall back to self.base_url, which falls
        back to self.schema.url().

        If ``stop_at`` is passed, the key specified will be the last
        one used for the breadcrumb list.

        If ``removals`` is passed, the specified filter keys will be
        excluded from the breadcrumb list.

        If ``additions`` is passed, the specified (key, NewsitemFilter)
        pairs will be added to the end of the breadcrumb list.

        (In some cases, you can pass (key, [args]) and it will figure
        out what kind of NewsitemFilter to create.  TODO: document
        this!!)

        Also, if self.other_query_params is a dictionary, its items
        will be added as query parameters to all the URLs.  This can
        be used to add or preserve query parameters that aren't
        relevant to the FilterChain.

        In all URLs, query parameters will be sorted alphabetically by
        name.
        """
        # TODO: Can filter_reverse leverage this? Or vice-versa?
        clone = self.copy()
        for key in removals:
            try:
                del clone[key]
            except KeyError:
                logger.warn("can't delete nonexistent key %s" % key)

        for key, values in additions:
            clone.replace(key, *values)

        base_url = base_url or clone.base_url
        base_url = posixpath.normpath(base_url) + '/'

        crumbs = []
        params_so_far = self.other_query_params.copy()
        for key, filt in clone._items_with_labels():
            # I'm not sure why we prefer short_value to label, but that's what
            # the old code did.
            label = getattr(filt, 'short_value', None) or getattr(filt, 'value', None) or getattr(filt, 'label', None)
            assert label is not None
            label = label.title()
            if label:
                params_so_far.update(filt.get_query_params())
                # We need doseq=True in case any of other_query_params have multiple values.
                query_string = urllib.urlencode(sorted(params_so_far.items()),
                                                doseq=True)
                url = '%s?%s' % (base_url, query_string)
                crumbs.append((label, url))
            if key == stop_at:
                break
        return crumbs

    def make_url(self, additions=(), removals=(), stop_at=None, base_url=None):
        """
        Makes one URL representing all the filters of this filter chain,
        for the schema_filter view.
        """
        crumbs = self.make_breadcrumbs(additions, removals, stop_at, base_url)
        if crumbs:
            return crumbs[-1][1]
        else:
            if self.other_query_params:
                return '%s?%s' % (base_url or self.base_url,
                                  urllib.urlencode(self.other_query_params))
            else:
                return base_url or self.base_url

    def add_by_place_id(self, pid):
        """
        ``pid`` is a place id string as used by parse_pid and make_pid,
        identifying a location or block (and if a block, a radius).
        """
        place, block_radius, xy_radius = parse_pid(pid)
        if isinstance(place, ebpub.streets.models.Block):
            self['location'] = BlockFilter(self.request, self.context, self.qs,
                                           block_radius, block=place)
        else:
            self['location'] = LocationFilter(self.request, self.context, self.qs,
                                              location=place)

    def filters_for_display(self):
        """
        If a filter has no label, that means don't show it in various
        places in the UI.  This is a convenience to get only the
        values that should be shown.
        """
        return [v for (k, v) in self._items_with_labels()]

    def _items_with_labels(self):
        return [(k, v) for (k, v) in self.items() if getattr(v, 'label', None)]

    def _get_base_url(self):
        return self._base_url or self.schema.url()
    def _set_base_url(self, url):
        self._base_url = url
    base_url = property(_get_base_url, _set_base_url)


class BadAddressException(Exception):
    def __init__(self, address, block_radius, address_choices, message=None):
        self.address = address
        self.block_radius = block_radius
        self.address_choices = address_choices
        self.message = message
        self.radius_slug = radius_slug(block_radius)


class BadDateException(FilterError):
    pass


# Block radius utility functions.
# Moved here because nothing else was using them.

def radius_slug(radius):
    """Return radius string like 8-blocks, 1-block ..."""
    radius = unicode(radius)
    return u'%s-block%s' % (radius, radius != '1' and 's' or '')

def radius_from_slug(slug):
    """Extract radius from a string like 8-blocks, 1-block, ..."""
    slug = unicode(slug)
    radius = slug.split('-')[0]
    assert radius.isdigit()
    return radius

########NEW FILE########
__FILENAME__ = dateutils
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Template tags for working with dates.
To use these, your template must include:

.. code-block:: html+django

   {% load dateutils %}

"""

from django import template
from ebpub.utils.dates import today
import calendar
import datetime

register = template.Library()

def days_in_month(value):
    """A filter.  Given a ``datetime.date`` or ``datetime.datetime`` object,
    returns the number of days in that month.

    Example:

    .. code-block:: html+django

      {{ some_date|days_in_month }}

    Example output::

      31

    Examples, in python:

    .. code-block:: python

      >>> import datetime
      >>> print days_in_month(datetime.date(2011, 8, 15))
      31
      >>> print days_in_month(datetime.datetime(2011, 8, 15, 0, 0))
      31
      >>> print days_in_month(datetime.date(2012, 2, 1))
      29
      >>> print days_in_month(datetime.date(2011, 2, 1))
      28
    """
    return calendar.monthrange(value.year, value.month)[1]
register.filter('days_in_month', days_in_month)

def friendlydate(value):
    """
    A filter that takes a date and includes 'Today' or 'Yesterday' if
    relevant, or the day of the week if it's within the past week,
    otherwise just the date.

    Example (in template):

    .. code-block:: html+django

      {% start_date|friendlydate %}

    Examples, in python:

    .. code-block:: python

      >>> import mock, datetime
      >>> with mock.patch('ebpub.db.templatetags.dateutils.today', lambda: datetime.date(2011, 8, 15)):
      ...     print friendlydate(datetime.date(2011, 8, 15))
      ...     print friendlydate(datetime.date(2011, 8, 16))
      ...     print friendlydate(datetime.date(2011, 8, 14))
      ...     print friendlydate(datetime.date(2011, 8, 13))
      ...     print friendlydate(datetime.date(2011, 8, 9))
      ...     print friendlydate(datetime.date(2011, 8, 8))
      ...
      Today August 15, 2011
      Tomorrow August 16, 2011
      Yesterday August 14, 2011
      Saturday August 13, 2011
      Tuesday August 9, 2011
      August 8, 2011
    """
    try: # Convert to a datetime.date, if it's a datetime.datetime.
        value = value.date()
    except AttributeError:
        pass
    # Using value.day because strftine('%d') is zero-padded and we don't want that.
    # TODO: parameterize format to allow i18n?
    formatted_date = value.strftime('%B ') + unicode(value.day) + value.strftime(', %Y')
    _today = today()
    if value == _today:
        return 'Today %s' % formatted_date
    elif value == _today - datetime.timedelta(1):
        return 'Yesterday %s' % formatted_date
    elif value == _today + datetime.timedelta(1):
        return 'Tomorrow %s' % formatted_date
    elif _today - value <= datetime.timedelta(6):
        return '%s %s' % (value.strftime('%A'), formatted_date)
    return formatted_date

register.filter('friendlydate', friendlydate)

########NEW FILE########
__FILENAME__ = eb
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Template tags for working with
:py:class:`NewsItem <ebpub.db.models.NewsItem>`,
:py:class:`Location <ebpub.db.models.Location>`,
etc.

To use these, your template must include:

.. code-block:: html+django

    {% load eb %}

"""
from django import template
from django.core.cache import cache
from django.template.defaultfilters import stringfilter
from django.template.loader import select_template
from ebpub.db.models import LocationType
from ebpub.db.models import Lookup
from ebpub.db.models import NewsItem
from ebpub.db.models import SchemaField, Schema
from ebpub.db.schemafilters import FilterChain
from ebpub.db.utils import populate_attributes_if_needed
from ebpub.metros import allmetros
from ebpub.utils.bunch import bunch, bunchlong, stride
from ebpub.utils.dates import today
from ebpub.utils.models import is_instance_of_model
from ebpub.utils.text import smart_title

import json
import re

register = template.Library()

# Split a list into sub-lists in various ways; See ebpub.utils.bunch.
register.filter('bunch', bunch)
register.filter('bunchlong', bunchlong)
register.filter('stride', stride)

def METRO_NAME():
    """Prints the metro_name from get_metro(), titlecase.

    Example:

    .. code-block:: html+django

       <h1>{% METRO_NAME %}</h1>

    """
    name = allmetros.get_metro()['metro_name']
    if name[0] != name[0].upper:
        name = name.title()
    return name
register.simple_tag(METRO_NAME)

def isdigit(value):
    """Filter that returns whether the value is a digit.

    Example:

    .. code-block:: html+django

      {% if "123"|isdigit %} It's a digit {% endif %}
      {% if not "Fred"|isdigit %} It's not a digit {% endif %}


    Python examples:

    .. code-block:: python

    >>> isdigit("1")
    True
    >>> isdigit("999")
    True
    >>> isdigit("42.1")
    False
    >>> isdigit("hello")
    False
    >>> isdigit("")
    False

    """
    return value.isdigit()
register.filter('isdigit', stringfilter(isdigit))


def lessthan(value, arg):
    """Filter. Obsolete since Django 1.1:  Use the < operator instead.
    """
    return int(value) < int(arg)   # pragma: no cover
register.filter('lessthan', lessthan)

def greaterthan(value, arg):
    """Filter. Obsolete since Django 1.1:  Use the > operator instead.
    """
    return int(value) > int(arg)  # pragma: no cover
register.filter('greaterthan', greaterthan)

def schema_plural_name(schema, value):
    """
    Tag that shows singular or plural name of a schema, depending on
    ``value``.  Example:

    .. code-block:: html+django

        {% schema_plural_name schema 3 %}  --> Restaurant Inspections
        {% schema_plural_name schema 1 %}  --> Restaurant Inspection

    """
    if isinstance(value, (list, tuple)):
        value = len(value)
    return (value == 1) and schema.name or schema.plural_name
register.simple_tag(schema_plural_name)

def safe_id_sort(value, arg):
    """
    Filter that sorts like Django's built-in "dictsort", but sorts
    second by the ID attribute, to ensure sorts always end up the
    same.

    Example:

    .. code-block:: html+django

      {% for item in itemlist|safe_id_sort "item_date" %} ... {% endfor %}

    """
    var_resolve = template.Variable(arg).resolve
    decorated = [(var_resolve(item), item.id, item) for item in value]
    decorated.sort()
    return [item[2] for item in decorated]
safe_id_sort.is_safe = False
register.filter('safe_id_sort', safe_id_sort)


@register.simple_tag(takes_context=True)
def get_metro_list(context):
    """
    Tag that puts settings.METRO_LIST into the context as METRO_LIST.

    Example:

    .. code-block:: html+django

      {% get_metro_list %}
      {% for metro in METRO_LIST %}
        <p>The metro is {{ metro.city_name }}</p>
      {% endfor %}
    """
    context['METRO_LIST'] = allmetros.METRO_LIST
    return ''


@register.simple_tag(takes_context=True)
def get_metro(context):
    """
    Tag that puts get_metro() into the context as METRO

    Example:

    .. code-block:: html+django

      {% get_metro %}
      <p>Current metro is {{ METRO.city_name }}</p>

    """
    context['METRO'] = allmetros.get_metro()
    return u''


class GetNewsItemNode(template.Node):
    def __init__(self, newsitem_variable, context_var):
        self.variable = template.Variable(newsitem_variable)
        self.context_var = context_var

    def render(self, context):
        newsitem_id = self.variable.resolve(context)
        try:
            context[self.context_var] = NewsItem.objects.select_related().get(id=newsitem_id)
        except NewsItem.DoesNotExist:
            pass
        return ''

def get_newsitem(parser, token):
    """
    Tag that puts a newsitem with the given ID in the context with the given
    variable name. Examples:

    .. code-block:: html+django

      {% get_newsitem some_id as my_item %}
      {% get_newsitem '23' as my_other_item %}
      <p>{{ my_item.title }}</p>
      <p>{{ my_other_item.title }}</p>

    """
    bits = token.split_contents()
    if len(bits) != 4:
        raise template.TemplateSyntaxError('%r tag requires 3 arguments' % bits[0])
    return GetNewsItemNode(bits[1], bits[3])
register.tag('get_newsitem', get_newsitem)

## This is a very obscure feature that we don't use anywhere...
# class GetNewerNewsItemNode(template.Node):
#     def __init__(self, newsitem_variable, newsitem_list_variable, context_var):
#         self.newsitem_var = template.Variable(newsitem_variable)
#         self.newsitem_list_var = template.Variable(newsitem_list_variable)
#         self.context_var = context_var

#     def render(self, context):
#         newsitem = self.newsitem_var.resolve(context)
#         newsitem_list = self.newsitem_list_var.resolve(context)
#         if newsitem_list and newsitem_list[0].item_date > newsitem.item_date:
#             context[self.context_var] = newsitem_list[0]
#         else:
#             context[self.context_var] = None
#         return ''
#
# def get_newer_newsitem(parser, token):
#     """Tag which, given a newsitem, and a list of other newsitems,
#     puts only those items more recent than the first item into a new
#     context variable.

#     Example::

#       {% get_more_recent_newsitem [newsitem] [item_list] as [context_var] %}
#     """
#     bits = token.split_contents()
#     if len(bits) != 5:
#         raise template.TemplateSyntaxError('%r tag requires 4 arguments' % bits[0])
#     return GetNewerNewsItemNode(bits[1], bits[2], bits[4])
# register.tag('get_newer_newsitem', get_newer_newsitem)

class GetNewsItemListByAttributeNode(template.Node):
    def __init__(self, schema_id_variable, newsitem_id_variable, att_name, att_value_variable, context_var):
        self.schema_id_variable = template.Variable(schema_id_variable)
        if newsitem_id_variable is None:
            self.newsitem_id_variable = None
        else:
            self.newsitem_id_variable = template.Variable(newsitem_id_variable)
        self.att_name = att_name
        self.att_value_variable = template.Variable(att_value_variable)
        self.context_var = context_var

    def render(self, context):
        schema_id = self.schema_id_variable.resolve(context)
        if hasattr(schema_id, 'id'):
            # It could be a Schema.
            schema_kwargs = {'schema__id': schema_id.id}
        elif isinstance(schema_id, basestring):
            # It could be a slug.
            schema_kwargs = {'schema__slug': schema_id}
        else:
            schema_kwargs = {'schema__id': schema_id}

        att_value = self.att_value_variable.resolve(context)
        sf = SchemaField.objects.select_related().get(name=self.att_name, **schema_kwargs)
        queryset = NewsItem.objects.select_related().filter(**schema_kwargs)

        if self.newsitem_id_variable is not None:
            newsitem_id = self.newsitem_id_variable.resolve(context)
            if hasattr(newsitem_id, 'id'):
                # It could be a NewsItem.
                newsitem_id = newsitem_id.id
            queryset = queryset.exclude(id=newsitem_id)

        queryset = queryset.by_attribute(sf, att_value).order_by('-item_date')
        populate_attributes_if_needed(queryset, [sf.schema])

        # We're assigning directly to context.dicts[-1] so that the variable
        # gets set in the top-most context in the context stack. If we didn't
        # do this, the variable would only be available within the specific
        # {% block %} from which the template tag was called, because the
        # {% block %} implementation does a context.push() and context.pop().
        context.dicts[-1][self.context_var] = queryset

        return ''

def get_newsitem_list_by_attribute(parser, token):
    """
    Tag that gets a list of NewsItems with a given attribute value,
    and saves it in a context variable.
    Optionally exclude a NewsItem by id.  (Useful if you have a NewsItem
    and you want to build a list of similar NewsItems without 
    including the one you already have.)

    Syntax:

    .. code-block:: html+django

      {% get_newsitem_list_by_attribute [schema] [newsitem_to_ignore] [att_name]=[value_or_var_containing_value] as [context_var] %}
      {% get_newsitem_list_by_attribute [schema] [att_name]=[value_or_var_containing_value] as [context_var] %}

    The ``schema`` and ``newsitem_to_ignore`` arguments can be either
    IDs or instances of Schema and NewsItem, respectively.
    ``Schema`` can also be specified by slug.

    Example 1. Here's a list of the latest 3 items that have the "tag" value of
    "garage sale" and schema slug "local-news":

    .. code-block:: html+django

      {% get_newsitem_list_by_attribute "local-news" tag="garage sale" as recent_sales %}
      {% for sale in recent_sales|slice:":3" %}
         <li><i>{{ sale.title }}</i></li>
      {% endfor %}

    Example 2. Here's a list of items that have the same "business_id" value as
    ``item`` does.   ``item`` itself is excluded from the list.

    .. code-block:: html+django

      {% get_newsitem_list_by_attribute item.schema item business_id=item.attributes.business_id as other_licenses %}
      {% for item in other_licenses %}
         <li><i>{{ item.title }}</i>
      {% endfor %}


    """
    bits = token.split_contents()
    if len(bits) == 5:
        att_arg_index = 2
        news_item_var=None
    elif len(bits) == 6:
        att_arg_index = 3
        news_item_var = bits[2]
    else:
        raise template.TemplateSyntaxError('%r tag requires 4 or 5 arguments' % bits[0])
    if bits[att_arg_index].count('=') != 1:
        raise template.TemplateSyntaxError('%r tag argument must contain 1 equal sign' % bits[0])
    att_name, att_value_variable = bits[att_arg_index].split('=')
    return GetNewsItemListByAttributeNode(bits[1], news_item_var, att_name, att_value_variable, bits[-1])

register.tag('get_newsitem_list_by_attribute', get_newsitem_list_by_attribute)


class NewsItemListBySchemaNode(template.Node):
    def __init__(self, newsitem_list_variable, is_ungrouped):
        self.variable = template.Variable(newsitem_list_variable)
        self.is_ungrouped = is_ungrouped

    def render(self, context):
        ni_list = self.variable.resolve(context)

        # For convenience, the newsitem_list might just be a single newsitem,
        # in which case we turn it into a list.
        if isinstance(ni_list, NewsItem):
            ni_list = [ni_list]

        schema = ni_list[0].schema
        template_list = ['db/snippets/newsitem_list/%s.html' % schema.slug,
                         'db/snippets/newsitem_list.html']
        schema_template = select_template(template_list)
        return schema_template.render(template.Context({
            'is_grouped': not self.is_ungrouped,
            'schema': schema,
            'newsitem_list': ni_list,
            'num_newsitems': len(ni_list),
            'place': context.get('place'),
            'is_block': context.get('is_block'),
            'block_radius': context.get('block_radius'),
            'today': today,
        }))


def newsitem_list_by_schema(parser, token):
    """
    Tag that renders a NewsItem, or list of NewsItems, using the
    appropriate newsitem_list template, optionally grouped by schema.

    Syntax:

    .. code-block:: html+django


      {% newsitem_list_by_schema [newsitem_or_newsitem_list] [ungrouped?] %}


    Examples:

    .. code-block:: html+django

      {% newsitem_list_by_schema newsitem "ungrouped" %}
      {% newsitem_list_by_schema newsitem_list %}

    """
    bits = token.split_contents()
    if len(bits) not in (2, 3):
        raise template.TemplateSyntaxError('%r tag requires one or two arguments' % bits[0])
    if len(bits) == 3:
        if bits[2] != 'ungrouped':
            raise template.TemplateSyntaxError('Optional last argument to %r tag must be the string "ungrouped"' % bits[0])
        is_ungrouped = True
    else:
        is_ungrouped = False
    return NewsItemListBySchemaNode(bits[1], is_ungrouped)
register.tag('newsitem_list_by_schema', newsitem_list_by_schema)


def contains(value, arg):
    """Filter to check whether ``arg`` is in ``value``.
    Obsolete since Django 1.2, use the 'in' operator instead.

    Example:

    .. code-block:: html+django

      {% if "Bob" in name_list %}
         Hi Bob!
      {% endif %}
    """
    return arg in value  # pragma: no cover
register.filter('contains', contains)


class SearchPlaceholderNode(template.Node):

    #See search_placeholder()

    def __init__(self, prefix, var_name):
        self.prefix = prefix.strip()
        self.var_name = var_name.strip()

    def render(self, context):
        cachekey = 'SearchPlaceholderNode'
        result = cache.get(cachekey)
        if result is None:
            from ebpub.db.models import LocationType
            types = LocationType.objects.filter(is_significant=True)
            types = list(types.order_by('name').values('name'))
            names = ['address'] + [loctype['name'].lower() for loctype in types]
            if len(names) > 3:
                # like "foo, bar, baz, ..."
                result = u'%s, ...' % (u', '.join(names[:3]))
            elif len(names) > 2:
                # like "foo, bar, or baz"
                result = u'%s, or %s' % (u', '.join(names[:-1]), names[-1])
            elif len(names) == 2:
                # like "foo or bar"
                result = u'%s or %s' % tuple(names)
            else:
                result = names[0]
            cache.set(cachekey, result, 60 * 60)
        if self.prefix:
            result = u'%s %s' % (self.prefix, result)
        else:
            # By default we want just the 1st letter forced caps,
            # and only when there's no prefix.
            result = result[0].upper() + result[1:]
        context[self.var_name] = result
        return ''

def search_placeholder(parser, token):
    """
    Tag that stores in a context variable a list of
    :py:class:`ebpub.db.models.LocationType`,
    plus 'address', with an optional prefix.

    Useful for search form widgets where we want to use this as
    placeholder text on the input, and need to write exactly the same string
    over and over because javascript will be checking for the
    placeholder text, restoring it, etc.

    Example:

    .. code-block:: html+django

      {% set_search_placeholder "Some prefix" as some_var %}
      <p>{{ some_var }}</p>

    If you have LocationTypes named 'ZIP' and 'neighborhood,'
    this would output in the template:

    .. code-block:: html+django

      <p>Some prefix address, ZIP, or neighborhood</p>
    """
    # In Django 1.4, this could become an assignment_tag as per
    # https://docs.djangoproject.com/en/dev/howto/custom-template-tags/#howto-custom-template-tags-assignment-tags
    # This version uses a regular expression to parse tag contents.
    try:
        # Splitting by None == splitting by spaces.
        tag_name, arg = token.contents.split(None, 1)
    except ValueError:
        raise template.TemplateSyntaxError("%r tag requires arguments" % token.contents.split()[0])
    m = re.search(r'(.*?) as (\w+)', arg)
    if not m:
        raise template.TemplateSyntaxError("%r tag had invalid arguments" % tag_name)
    prefix, var_name = m.groups()
    if not (prefix[0] == prefix[-1] and prefix[0] in ('"', "'")):
        raise template.TemplateSyntaxError("%r tag's argument should be in quotes" % tag_name)
    return SearchPlaceholderNode(prefix[1:-1], var_name)

register.tag('set_search_placeholder', search_placeholder)


@register.simple_tag(takes_context="true")
def featured_lookup_for_item(context, newsitem, attribute_key):
    """Tag that, given a NewsItem, finds any :ref:`featured_lookups`
    that correspond to its values for the named attribute.
    Saves them in the current context under the same name as the attribute.

    Example:

    .. code-block:: html+django

      {% featured_lookup_for_item item 'tags' %}
      {% for tag in tags %}
        This item has tag {{ tag }}
      {% endfor %}

    """
    lookups = Lookup.objects.featured_lookups_for(newsitem, attribute_key)
    context[attribute_key] = lookups
    return ""


@register.simple_tag(takes_context="true")
def get_featured_lookups_by_schema(context):
    """
    Get all :ref:`featured_lookups` names and URLs for them; 
    puts in the context as
    'featured_lookups', a mapping grouped by schema.

    Example:

    .. code-block:: html+django

        {% get_featured_lookups_by_schema %}
        {% for schema, lookups in featured_lookups.items %}
           <ul>{{ schema }}
            {% for info in lookups %}
              <a href="{{ info.url }}">{{ info.lookup }}</a>
               ...
            {% endfor %}
        {% endfor %}
    """
    lookups = {}
    for lookup in Lookup.objects.filter(featured=True).select_related():
        sf = lookup.schema_field
        schema = sf.schema
        filters = FilterChain(schema=schema)
        filters.add(sf, lookup)
        info = {'lookup': lookup.name, 'url': filters.make_url()}
        lookups.setdefault(schema.slug, []).append(info)
    context['featured_lookups'] = lookups
    return u''


@register.simple_tag()
def json_lookup_values_for_attribute(schema_slug, sf_name):
    """Given a schema slug and attribute name, returns
    all the current Lookup values of the relevant attribute,
    as a JSON-formatted list.

    Assumes the relevant schemafield has is_lookup=True.

    Example:

    .. code-block:: html+django

     <script>
      var lookups = {% json_lookup_values_for_attribute 'police-reports' 'violations' %};
     </script>

    Example output:

    .. code-block:: html+django

     <script>
      var lookups = ['burglary', 'speeding', 'vandalism'];
     </script>
    """
    if is_instance_of_model(schema_slug, Schema):
        schema_slug = schema_slug.slug
    values = Lookup.objects.filter(schema_field__schema__slug=schema_slug,
                                   schema_field__name=sf_name).values_list('name')
    values = [d[0] for d in values]
    return json.dumps(sorted(values))


def get_locations_for_item(parser, token):
    """
    Tag that puts into the context some data about intersecting locations,
    useful for eg. linking to URLs based on those locations.

    Syntax:

    .. code-block:: html+django

      {% get_locations_for_item newsitem location_type_slug (location_type_slug2 ...) as varname %}

    The ``location_type_slug`` arguments will be used, in the order
    given, to specify which types of locations to find.

    The last argument is the name of the context variable in which to
    put the result.

    For each matching location, the result will contain a dictionary
    with these keys: location_slug, location_name, location_type_slug,
    location_type_name.


    Here's an example template in which we build links for each
    intersecting location:

    .. code-block:: html+django

     {% for item in news_items %}
       {% get_locations_for_item item 'village' 'town' 'city' as locations_info %}
       {% for loc_info in locations_info %}
         <li><a href="http://example.com/yourtown/{{loc_info.location_slug}}">
            Other News in {{ loc_info.location_name }}
         </a></li>
       {% endfor %}
     {% endfor %}

    """
    bits = token.split_contents()
    tagname = bits.pop(0)
    if len(bits) < 4:
        raise template.TemplateSyntaxError('%r tag requires at least 3 arguments' % tagname)
    newsitem = bits[0]
    varname = bits[-1]
    if bits[-2] != 'as':
        raise template.TemplateSyntaxError('%r tag needs args: newsitem slug (slug...) as variable' % tagname)
    loctypes = [s.strip('\'"') for s in bits[1:-2]]
    return LocationInfoNode(newsitem, varname, *loctypes)
register.tag('get_locations_for_item', get_locations_for_item)


class LocationInfoNode(template.Node):
    def __init__(self, newsitem_context_var, varname, *location_type_slugs):
        self.newsitem_context_var = template.Variable(newsitem_context_var)
        self.varname = varname
        self.loctype_slugs = location_type_slugs

    def render(self, context):
        """Puts some information about overlapping locations into context[varname].
        """
        newsitem_context = self.newsitem_context_var.resolve(context)
        if isinstance(newsitem_context, dict):
            newsitem = newsitem_context.get('_item', None)
        else:
            newsitem = newsitem_context
        if not is_instance_of_model(newsitem, NewsItem):
            raise template.TemplateSyntaxError("The newsitem argument to 'get_locations_for_item' tag must be either a NewsItem, or a dictionary eg. as created by the template_context_for_item() function")

        # TODO: cache the LocationType lookup?
        location_types = LocationType.objects.filter(slug__in=self.loctype_slugs)
        loctype_dict = dict([(d['slug'], d)
                             for d in location_types.values('name', 'slug')])
        result = []
        nilocations = newsitem.location_set.all()
        for slug in self.loctype_slugs:
            loctype = loctype_dict.get(slug)
            if loctype is None:
                continue
            locations = nilocations.filter(location_type__slug=loctype['slug'])
            # Assume there is at most one intersecting location of each type.
            # That will probably be wrong somewhere someday...
            # eg. neighborhoods with fuzzy borders.
            locations = list(locations[:1])
            if locations:
                location = locations[0]
                result.append(
                    {'location_slug': location.slug,
                     'location_type_slug': loctype['slug'],
                     'location_type_name': smart_title(loctype['name'], ['ZIP']),
                     'location_name': location.name,
                     }
                    )

        context[self.varname] = result
        return u''

########NEW FILE########
__FILENAME__ = eb_filter
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Template tags mostly related to the
:py:func:`ebpub.db.views.schema_filter` view:
generating URLs and forms to link/submit to that view.

To use these, your template must include:

.. code-block:: html+django

   {% load eb_filter %}

"""

from django import template
from ebpub.db.models import Schema
from ebpub.db.schemafilters import FilterChain

register = template.Library()

class Base(template.Node):

    def __init__(self, filterchain_var, additions, removals, clear=False):
        self.filterchain_var = template.Variable(filterchain_var)
        self.clear = clear
        # Additions and removals are tuples to make sure we
        # don't do anything non-threadsafe with them during render().
        # http://docs.djangoproject.com/en/dev/howto/custom-template-tags/#thread-safety-considerations
        if clear:
            self.removals = ()
        else:
            self.removals = tuple(template.Variable(r) for r in removals)
        self.additions = []
        for key, values in additions:
            self.additions.append((template.Variable(key),
                                   tuple(template.Variable(v) for v in values),
                                   ))
        self.additions = tuple(self.additions)

    def _get_additions(self, context):
        additions = []
        for key, values in self.additions:
            key = key.resolve(context)
            additions.append((key, [v.resolve(context) for v in values]))
        return additions

    def _get_removals(self, context):
        removals = [r.resolve(context) for r in self.removals]
        return removals

    def _get_filterchain(self, context):
        filterchain_or_schema = self.filterchain_var.resolve(context)
        if isinstance(filterchain_or_schema, FilterChain):
            filterchain = filterchain_or_schema
        elif isinstance(filterchain_or_schema, Schema):
            # Note, context['request'] only works if
            # django.core.context_processors.request is enabled in
            # TEMPLATE_CONTEXT_PROCESSORS.
            filterchain = FilterChain(context=context, request=context.get('request'),
                                      schema=filterchain_or_schema)
        else:
            raise template.TemplateSyntaxError(
                "%r is neither a FilterChain nor a Schema" % filterchain_or_schema)
        if self.clear:
            filterchain = filterchain.copy()
            filterchain.clear()
        return filterchain


class FilterUrlNode(Base):

    # Node for the filter_url tag

    def render(self, context):
        filterchain = self._get_filterchain(context)
        additions = self._get_additions(context)
        removals = self._get_removals(context)
        return filterchain.make_url(additions=additions, removals=removals)


class FilterFormInputsNode(Base):

    # Node for the filter_form_inputs tag

    def render(self, context):
        filterchain = self._get_filterchain(context)
        for key in self._get_removals(context):
            try:
                del filterchain[key]
            except KeyError:
                pass
        for key, values in self._get_additions(context):
            filterchain.replace(key, *values)
        output = ['<!-- filter_form_inputs tag output -->']
        for name, filter in filterchain.items():
            for name, values in filter.get_query_params().items():
                if not isinstance(values, (list, tuple)):
                    values = [values]
                    for v in values:
                        output.append('<input type="hidden" name="%s" value="%s" />'
                                      % (name, v))
        output.append('<!-- end filter_form_inputs -->')
        from django.utils.safestring import mark_safe
        output = '\n'.join(output)
        return mark_safe(output)


def filter_url(parser, token):
    """
    Template tag that outputs a URL based on the filter chain, with
    optional additions/removals of filters.  The first argument is
    required and can be either an existing FilterChain or a Schema:

    .. code-block:: html+django

      {% filter_url filter_chain %}
      {% filter_url schema %}

    To remove a NewsitemFilter from the url, specify the key with a leading "-":

    .. code-block:: html+django

      {% filter_url filter_chain -key_to_remove %}
      {% filter_url filter_chain -"key_to_remove" %}
      {% filter_url filter_chain -key1 -key2 ... %}

    To add NewsitemFilters to the url, specify the key with a leading
    "+", followed by args to use for constructing a NewsitemFilter.

    Keys and values will be passed to FilterChain.add(); see its docs
    for info on legal values. But briefly, the keys are either
    SchemaField instances, or a string understood by SchemaFilter,
    such as 'pubdate':

    .. code-block:: html+django

      {% filter_url filter_chain +"key" value %}
      {% filter_url filter_chain +key value1 value 2 ... %}
      {% filter_url filter_chain +key1 "arg1a" "arg1b" +key2 "arg2a" ... %}

    You can even mix and match additions and removals:

    .. code-block:: html+django

      {% filter_url filter_chain -key1 +key2 arg2 -key3 +key4 arg4 ... %}
    """
    args = _parse(parser, token)
    return FilterUrlNode(*args)



def filter_form_inputs(parser, token):
    """
    Template tag that takes same args as :py:func:`filter_url`, but outputs a set
    of hidden form inputs encapsulating the current filter chain,
    optionally with added or removed filters.

    For example, to make a form that preserves current filters except
    allows choosing a new date range, you would do:

    .. code-block:: html+django

      <form action="{% filter_url filters.schema %}">
         {% filter_form_inputs filters -"date" %}
         <input type="text" name="start_date">
         <input type="text" name="end_date">
         <input type="submit">
      </form>

    In this example,
    the form action URL is generated by ``filter_url`` with just the schema,
    and all non-date current filters are inserted by using
    ``filter_form_inputs`` on the second line.
    The new dates are given by normal non-hidden form fields.
    """
    args = _parse(parser, token)
    return FilterFormInputsNode(*args)


def _parse(parser, token):
    # Handle parsing of filter_url and filter_form_inputs tags.
    bits = token.split_contents()
    additions, removals = [], []
    try:
        filterchain_var = bits[1]
    except IndexError:
        raise template.TemplateSyntaxError('Missing required filterchain argument')
    # TODO: This probably fails for removals of hard-coded strings that contain spaces.
    bits = bits[2:]
    clear = False
    while bits:
        bit = bits.pop(0)
        if bit.startswith('-'):
            key = bit[1:]
            if not len(key):
                raise template.TemplateSyntaxError('Invalid argument: %r' % bit)
            if key == 'all':
                removals = []
                clear=True
            else:
                removals.append(key)
        elif bit.startswith('+'):
            key = bit[1:]
            if not len(key):
                raise template.TemplateSyntaxError('Invalid argument: %r' % bit)
            values = []
            while bits:
                # Consume all remaining args until the next addition/removal.
                if bits[0][0] in ('+', '-'):
                    break
                values.append(bits.pop(0))
            # if not len(values):
            #     raise template.TemplateSyntaxError('Invalid argument: %r' % bit)
            additions.append((key, values))
        else:
            raise template.TemplateSyntaxError('Invalid argument: %r' % bit)
    return (filterchain_var, additions, removals, clear)


register.tag('filter_url', filter_url)
register.tag('filter_form_inputs', filter_form_inputs)

########NEW FILE########
__FILENAME__ = eb_json
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Custom template tags for dealing with json.

To use these, your template must include:

.. code-block:: html+django

   {% load eb_json %}

"""

from django import template
from django.conf import settings
from django.utils import simplejson

register = template.Library()


def json_value(value, arg=None):
    """
    Filter that turns a JSON string into a data structure.

    Example:

    .. code-block:: html+django

      {% for item in "[1,2,3]"|json_value %}
        <li>{{ item }}</li>
      {% endfor %}

    This would insert into the page::

       <li>1</li>
       <li>2</li>
       <li>3</li>
    """
    data = simplejson.loads(value)
    if arg is not None:
        try:
            return data[arg]
        except (KeyError, IndexError):
            if settings.DEBUG:
                raise
            return None
    return data

register.filter('json_value', json_value)

########NEW FILE########
__FILENAME__ = full_links
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Template tags for helping with URLs.
To use these, your template must include:

.. code-block:: html+django

  {% load full_links %}

"""

from django import template
import re

register = template.Library()

class FullLinksNode(template.Node):
    def __init__(self, nodelist, domain_var):
        self.nodelist = nodelist
        self.domain_var = template.Variable(domain_var)

    def render(self, context):
        domain = self.domain_var.resolve(context)
        output = self.nodelist.render(context)
        output = re.sub(r'(?i)(<(a|link)\b.*?\bhref=")/', r'\1http://%s/' % domain, output)
        output = re.sub(r'(?i)(<(img|script)\b.*?\bsrc=")/', r'\1http://%s/' % domain, output)
        return output

def full_links(parser, token):
    """
    Converts all <a href>s and <img src>s within {% full_links %} / {% end_full_links %} to
    use fully qualified URLs -- i.e., to start with 'http://'. Doesn't touch
    the ones that already start with 'http://'.

    TODO: Doesn't handle https://

    Example:

    .. code-block:: html+django

      {% full_links "example.com" %}
        <a href="/food"></a>
        <img src="/sleep"></img>

      {% end_full_links %}

    Output::

       <a href="http://example.com/food"></a>
       <img src="http://example.com/sleep"></img>

    """

    args = token.contents.split()
    if len(args) != 2:
        raise template.TemplateSyntaxError("%r tag requires exactly one argument." % args[0])
    nodelist = parser.parse(('end_full_links',))
    parser.delete_first_token()
    return FullLinksNode(nodelist, args[1])
register.tag('full_links', full_links)

########NEW FILE########
__FILENAME__ = mapping
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#


"""
Template tags for helping with maps.
To use these, your template must include:

.. code-block:: html+django

  {% load mapping %}

"""

from django import template

register = template.Library()


@register.simple_tag
def map_icon_img(obj):
    """
    Returns an image tag with a URL for a map icon for the given
    object, which may be a db.Schema, or streets.PlaceType.

    (If there's no image configured but there's a fill color, makes a
    little box of the right color.)

    Example:

    .. code-block:: html+django

      {% map_icon_img [schema] %}
      {% map_icon_img [place_type] %}

    """
    getter = getattr(obj, 'get_map_icon_url', None)
    if getter is not None:
        url = obj.get_map_icon_url()
    else:
        url = ''
    if url:
        alt = '%s icon' % (obj.name or obj.slug)
        return '<img class="schema-icon" src="%s" alt="%s" />' % (url, alt)
    color = getattr(obj, 'map_color', '') or ''
    color = color.strip()
    if color:
        return '<div class="schema-colorsample" style="background: %s">&nbsp;</div>' % color
    return ''

########NEW FILE########
__FILENAME__ = raw
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#


"""
To use these, your template must include:

.. code-block:: html+django


  {% load raw %}

"""

from django import template

register = template.Library()

def raw(parser, token):
    """
    Whatever is between {% raw %} and {% endraw %} will be preserved as
    raw, unrendered template code.
    If 'silent' is passed in -- {% raw silent %} -- then the resulting output
    will not contain the {% raw %} and {% endraw %} tags themselves.
    Otherwise, the output will include an {% endraw %} at the start and
    {% raw %} at the end, so that other parts of the page aren't vulnerable
    to Django template escaping injection.

    Probably only useful for development.

    Example:

    .. code-block:: html+django

      {% raw %}
         Some django template code, like {{ something }}.
      {% endraw %}

    Example output::

         Some django template code, like {{ something }}.

    """

    silent = 'silent' in token.contents
    if silent:
        text = []
    else:
        text = ['{% endraw %}']
    parse_until = 'endraw'
    tag_mapping = {
        template.TOKEN_TEXT: ('', ''),
        template.TOKEN_VAR: ('{{', '}}'),
        template.TOKEN_BLOCK: ('{%', '%}'),
        template.TOKEN_COMMENT: ('{#', '#}'),
    }
    # By the time this template tag is called, the template system has already
    # lexed the template into tokens. Here, we loop over the tokens until
    # {% endraw %} and parse them to TextNodes. We have to add the start and
    # end bits (e.g. "{{" for variables) because those have already been
    # stripped off in a previous part of the template-parsing process.
    while parser.tokens:
        token = parser.next_token()
        if token.token_type == template.TOKEN_BLOCK and token.contents == parse_until:
            if not silent:
                text.append('{% raw silent %}')
            return template.TextNode(u''.join(text))
        start, end = tag_mapping[token.token_type]
        text.append(u'%s%s%s' % (start, token.contents, end))
    parser.unclosed_block_tag(parse_until)
raw = register.tag(raw)

########NEW FILE########
__FILENAME__ = recaptcha_tags
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#


"""
To use these, your template must include:

.. code-block:: html+django

  {% load recaptcha_tags %}

"""

from django import template  
from django.conf import settings  
from recaptcha.client import captcha

register = template.Library()

@register.simple_tag
def recaptcha_html():
    """Inserts a ReCaptcha widget, using settings.RECAPTCHA_PUBLIC_KEY.
    If that's not set, outputs an empty string.

    Usage:

    .. code-block:: html+django

      {% recaptcha_html %}

    """
    if not getattr(settings, 'RECAPTCHA_PUBLIC_KEY', None):
        return u''
    html = u'<script type="text/javascript">var RecaptchaOptions = {theme : "white"};</script>'
    html += captcha.displayhtml(settings.RECAPTCHA_PUBLIC_KEY)
    return html

########NEW FILE########
__FILENAME__ = test_models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Unit tests for db.models.
"""

from ebpub.utils.django_testcase_backports import TestCase
from ebpub.db.models import NewsItem, Attribute
import datetime
import mock

class DatabaseExtensionsTestCase(TestCase):
    "Unit tests for the custom ORM stuff in models.py."
    fixtures = ('crimes.json',)

    def testAttributesLazilyLoaded(self):
        # Attributes are retrieved lazily the first time you access the
        # `attributes` attribute.

        # Turn DEBUG on and reset queries, so we can keep track of queries.
        # This is hackish.
        from django.db import connection
        connection.queries = []
        with self.settings(DEBUG=True):
            ni = NewsItem.objects.get(id=1)
            self.assertEquals(ni.attributes['case_number'], u'case number 1')
            self.assertEquals(ni.attributes['crime_date'], datetime.date(2006, 9, 19))
            self.assertEquals(ni.attributes['crime_time'], None)
            self.assertEquals(len(connection.queries), 3)
            connection.queries = []

    def testSetAllAttributesNonDict(self):
        # Setting `attributes` to something other than a dictionary will raise
        # ValueError.
        ni = NewsItem.objects.get(id=1)
        def setAttributeToNonDict():
            ni.attributes = 1
        self.assertRaises(ValueError, setAttributeToNonDict)

    def testSetAllAttributes1(self):
        # Attributes can be set by assigning a dictionary to the `attributes`
        # attribute. As soon as `attributes` is assigned-to, the UPDATE query
        # is executed in the database.
        ni = NewsItem.objects.get(id=1)
        self.assertEquals(ni.attributes['case_number'], u'case number 1')
        ni.attributes = dict(ni.attributes, case_number=u'Hello')
        self.assertEquals(Attribute.objects.get(news_item__id=1).varchar01, u'Hello')

    def testSetAllAttributes2(self):
        # Setting attributes works even if you don't access them first.
        ni = NewsItem.objects.get(id=1)
        ni.attributes = {
            u'arrests': False,
            u'beat': 214,
            u'block_id': 25916,
            u'case_number': u'Hello',
            u'crime_date': datetime.date(2006, 9, 19),
            u'crime_time': None,
            u'domestic': False,
            u'is_outdated': True,
            u'location_id': 66,
            u'police_id': None,
            u'status': u'',
            u'type_id': 97
        }
        self.assertEquals(Attribute.objects.get(news_item__id=1).varchar01, u'Hello')

    def testSetAllAttributesNull(self):
        # If you assign to NewsItem.attributes and the dictionary
        # doesn't include a value for every field, a None/NULL will be
        # inserted for values that aren't represented in the
        # dictionary.
        ni = NewsItem.objects.get(id=1)
        ni.attributes = {u'arrests': False}
        ni = NewsItem.objects.get(id=1)
        self.assertEquals(ni.attributes['arrests'], False)
        self.assertEquals(ni.attributes['beat'], None)
        self.assertEquals(ni.attributes['block_id'], None)
        self.assertEquals(ni.attributes['case_number'], None)
        self.assertEquals(ni.attributes['crime_date'], None)
        self.assertEquals(ni.attributes['crime_time'], None)
        self.assertEquals(ni.attributes['domestic'], None)
        self.assertEquals(ni.attributes['is_outdated'], None)
        self.assertEquals(ni.attributes['location_id'], None)
        self.assertEquals(ni.attributes['police_id'], None)
        self.assertEquals(ni.attributes['status'], None)
        self.assertEquals(ni.attributes['type_id'], None)

    def testSetSingleAttribute1(self):
        # Setting a single attribute will result in an immediate query setting
        # just that attribute.
        ni = NewsItem.objects.get(id=1)
        self.assertEquals(ni.attributes['case_number'], u'case number 1')
        ni.attributes['case_number'] = u'Hello'
        self.assertEquals(Attribute.objects.get(news_item__id=1).varchar01, u'Hello')

    def testSetSingleAttribute2(self):
        # Setting single attributes works even if you don't access them first.
        ni = NewsItem.objects.get(id=1)
        ni.attributes['case_number'] = u'Hello'
        self.assertEquals(Attribute.objects.get(news_item__id=1).varchar01, u'Hello')

    def testSetSingleAttribute3(self):
        # Setting a single attribute will result in the value being cached.
        ni = NewsItem.objects.get(id=1)
        self.assertEquals(ni.attributes['case_number'], u'case number 1')
        ni.attributes['case_number'] = u'Hello'
        self.assertEquals(ni.attributes['case_number'], u'Hello')

    def testSetSingleAttribute4(self):
        # Setting a single attribute will result in the value being cached, even
        # if you don't access the attribute first.
        ni = NewsItem.objects.get(id=1)
        ni.attributes['case_number'] = u'Hello'
        self.assertEquals(ni.attributes['case_number'], u'Hello')

    def testSetSingleAttributeNumQueries(self):
        # When setting an attribute, the system will only use a single query --
        # i.e., it won't have to retrieve the attributes first simply because
        # code accessed the NewsItem.attributes attribute.

        # Turn DEBUG on and reset queries, so we can keep track of queries.
        from django.db import connection
        connection.queries = []
        with self.settings(DEBUG=True):
            ni = NewsItem.objects.get(id=1)
            ni.attributes['case_number'] = u'Hello'
            self.assertEquals(len(connection.queries), 3)

        connection.queries = []

    def testBlankAttributes(self):
        # If a NewsItem has no attributes set, accessing
        # NewsItem.attributes will return an empty dictionary.
        Attribute.objects.filter(news_item__id=1).delete()
        ni = NewsItem.objects.get(id=1)
        self.assertEquals(ni.attributes, {})

    def testSetAttributesFromBlank(self):
        # When setting attributes on a NewsItem that doesn't have
        # attributes yet, the underlying implementation will use an
        # INSERT statement instead of an UPDATE.
        Attribute.objects.filter(news_item__id=1).delete()
        ni = NewsItem.objects.get(id=1)
        ni.attributes = {
            u'arrests': False,
            u'beat': 214,
            u'block_id': 25916,
            u'case_number': u'Hello',
            u'crime_date': datetime.date(2006, 9, 19),
            u'crime_time': None,
            u'domestic': False,
            u'is_outdated': True,
            u'location_id': 66,
            u'police_id': None,
            u'status': u'',
            u'type_id': 97
        }
        self.assertEquals(Attribute.objects.get(news_item__id=1).varchar01, u'Hello')

    def testSetSingleAttributeFromBlank(self):
        # When setting a single attribute on a NewsItem that doesn't have
        # attributes yet, the underlying implementation will use an INSERT
        # statement instead of an UPDATE.
        Attribute.objects.filter(news_item__id=1).delete()
        ni = NewsItem.objects.get(id=1)
        ni.attributes['case_number'] = u'Hello'
        self.assertEquals(Attribute.objects.get(news_item__id=1).varchar01, u'Hello')

    def testAttributeFromBlankSanity(self):
        # Sanity check for munging attribute data from blank.
        Attribute.objects.filter(news_item__id=1).delete()
        ni = NewsItem.objects.get(id=1)
        self.assertEquals(ni.attributes, {})
        ni.attributes['case_number'] = u'Hello'
        self.assertEquals(ni.attributes['case_number'], u'Hello')
        self.assertEquals(Attribute.objects.get(news_item__id=1).varchar01, u'Hello')

    def test_top_lookups__int(self):
        from ebpub.db.models import SchemaField
        sf = SchemaField.objects.get(name='beat')
        qs = NewsItem.objects.all()
        top_lookups = list(qs.top_lookups(sf, 2))
        self.assertEqual(len(top_lookups), 2)
        self.assertEqual(top_lookups[0]['count'], 2)
        self.assertEqual(top_lookups[0]['lookup'].slug, u'beat-64')
        self.assertEqual(top_lookups[1]['count'], 1)
        self.assertEqual(top_lookups[1]['lookup'].slug, u'beat-214')

    def test_top_lookups__m2m(self):
        from ebpub.db.models import SchemaField
        sf = SchemaField.objects.get(name='tag')
        # from ebpub.db.bin.update_aggregates import update_aggregates
        # update_aggregates(sf.schema.id)
        qs = NewsItem.objects.all()
        top_lookups = list(qs.top_lookups(sf, 2))
        self.assertEqual(len(top_lookups), 2)
        self.assertEqual(top_lookups[0]['count'], 3)
        self.assertEqual(top_lookups[0]['lookup'].slug, u'tag-1')
        self.assertEqual(top_lookups[1]['count'], 2)
        self.assertEqual(top_lookups[1]['lookup'].slug, u'tag-2')


    def test_allowed_schema_ids(self):
        from ebpub.db.models import Schema
        self.assertIn(1, Schema.objects.allowed_schema_ids())
        self.assertIn(1, Schema.public_objects.allowed_schema_ids())
        Schema.objects.all().update(is_public=False)
        # Now 'objects' still returns everything, but 'public_objects' doesn't.
        self.assertIn(1, Schema.objects.allowed_schema_ids())
        self.assertEqual(Schema.public_objects.allowed_schema_ids(), [])

    @mock.patch('ebpub.utils.view_utils.get_schema_manager')
    def test_by_request(self, mock_get_schema_manager):
        mock_get_schema_manager.return_value.allowed_schema_ids.return_value = []
        from ebpub.db.models import NewsItem
        request = mock.Mock()
        self.assertEqual(NewsItem.objects.by_request(request).count(), 0)
        self.assertEqual(mock_get_schema_manager.call_count, 1)

    def test_by_attribute__lookup_single(self):
        from ebpub.db.models import NewsItem, SchemaField, Lookup
        by_attribute = NewsItem.objects.by_attribute
        sf = SchemaField.objects.get(name='beat')
        lookups = Lookup.objects.filter(schema_field=sf, code__in=['214', '64'])
        qs = by_attribute(sf, lookups, is_lookup=True)
        self.assertEqual(qs.count(), 3)
        lookups = Lookup.objects.filter(schema_field=sf, code='214')
        qs = by_attribute(sf, lookups, is_lookup=True)
        self.assertEqual(qs.count(), 1)


    def test_by_attribute__lookup_m2m(self):
        from ebpub.db.models import NewsItem, SchemaField, Lookup
        by_attribute = NewsItem.objects.by_attribute
        sf = SchemaField.objects.get(name='tag')
        lookups = Lookup.objects.filter(schema_field=sf, code__in=['1', '2'])
        qs = by_attribute(sf, lookups, is_lookup=True)
        self.assertEqual(qs.count(), 3)
        lookups = Lookup.objects.filter(schema_field=sf, code__in=['2', '3'])
        qs = by_attribute(sf, lookups, is_lookup=True)
        self.assertEqual(qs.count(), 2)
        lookups = Lookup.objects.filter(schema_field=sf, code__in=['3'])
        qs = by_attribute(sf, lookups, is_lookup=True)
        self.assertEqual(qs.count(), 1)
        lookups = Lookup.objects.filter(schema_field=sf, code__in=['999'])
        qs = by_attribute(sf, lookups, is_lookup=True)
        self.assertEqual(qs.count(), 0)


    def test_by_attribute__lookup_m2m__by_code(self):
        from ebpub.db.models import NewsItem, SchemaField
        by_attribute = NewsItem.objects.by_attribute
        sf = SchemaField.objects.get(name='tag')
        qs = by_attribute(sf, ['1', '2'], is_lookup=True)
        self.assertEqual(qs.count(), 3)
        qs = by_attribute(sf, ['2', '3'], is_lookup=True)
        self.assertEqual(qs.count(), 2)
        qs = by_attribute(sf, ['3'], is_lookup=True)
        self.assertEqual(qs.count(), 1)
        qs = by_attribute(sf, ['999'], is_lookup=True)
        self.assertEqual(qs.count(), 0)

########NEW FILE########
__FILENAME__ = test_schemafilters
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Unit tests for db.schemafilters.
"""

from ebpub.utils.testing import RequestFactory
from django.core import urlresolvers
from django.test import TestCase
from ebpub.db.schemafilters import FilterChain
from ebpub.db.schemafilters import FilterError
from ebpub.db.urlresolvers import filter_reverse
from ebpub.db.views import BadAddressException
from ebpub.db import models
import datetime
import mock
import random

class TestNewsitemFilter(TestCase):

    def test_getitem(self):
        from ebpub.db.schemafilters import NewsitemFilter
        fil = NewsitemFilter('dummy request', 'dummy context')
        fil.foo = 'bar'
        self.assertEqual(fil['foo'], 'bar')
        self.assertRaises(KeyError, fil.__getitem__, 'bar')


class TestIdFilter(TestCase):

    fixtures = ('test-schemafilter-views.json',)

    def test_validate(self):
        from ebpub.db.schemafilters import IdFilter
        fil = IdFilter(request=None, context={}, queryset=None)
        self.assertEqual(fil.validate(),
                         {'filter_key': 'id',
                          'option_list': [],
                          'param_label': 'id',
                          'param_name': 'id',
                          'select_multiple': True}
                         )

    def test_apply__no_ids(self):
        from ebpub.db.schemafilters import IdFilter
        fil = IdFilter(request=None, context={}, queryset=None, ids=[])
        self.assertEqual(list(fil.apply()), [])
        from ebpub.db.models import NewsItem
        self.assert_(NewsItem.objects.all().count() >= 1,
                     "we should have some items")

    def test_apply__some_ids(self):
        from ebpub.db.schemafilters import IdFilter
        from ebpub.db.models import NewsItem
        items = NewsItem.objects.all()[:2]
        self.assert_(len(items), "we should have some items")
        expected_ids = [item.id for item in items]
        fil = IdFilter(request=None, context={}, queryset=None,
                       ids=expected_ids)
        got_ids = [item.id for item in fil.apply()]
        self.assertEqual(sorted(expected_ids), sorted(got_ids))


class TestSchemaFilter(TestCase):

    fixtures = ('test-schemafilter-views.json',)

    def test_validate(self):
        from ebpub.db.schemafilters import SchemaFilter
        schema = models.Schema.objects.get(slug='crime')
        fil = SchemaFilter(request=None, context={}, queryset=None, schema=schema)
        self.assertEqual(fil.validate(), {})


    def test_apply(self):
        from ebpub.db.schemafilters import SchemaFilter
        schema = models.Schema.objects.get(slug='crime')
        fil = SchemaFilter(request=None, context={}, queryset=None, schema=schema)
        fil.apply()
        self.assert_(len(fil.qs) > 0)
        for item in fil.qs:
            self.assertEqual(item.schema.natural_key(), schema.natural_key())

    def test_apply__multi_schema(self):
        from ebpub.db.schemafilters import SchemaFilter
        schema = models.Schema.objects.get(slug='crime')
        fil = SchemaFilter(request=None, context={}, queryset=None,
                           schema=[schema, schema])
        fil.apply()
        self.assert_(len(fil.qs) > 0)
        for item in fil.qs:
            self.assertEqual(item.schema.natural_key(), schema.natural_key())


    @mock.patch('ebpub.db.schemafilters.get_schema_manager')
    def test_apply__with_request(self, mock_get_mgr):
        from ebpub.db.schemafilters import SchemaFilter
        schema = models.Schema.objects.get(slug='crime')
        request = mock.Mock()
        mock_get_mgr.return_value = models.Schema.objects
        fil = SchemaFilter(request=request, context={}, queryset=None,
                           schema=[schema, schema])
        fil.apply()
        self.assertEqual(mock_get_mgr.call_count, 1)


class TestLocationFilter(TestCase):

    # fixtures = ('test-locationtypes.json', 'test-locations.json',
    #             )
    fixtures = ('test-schemafilter-views.json',)


    def _make_filter(self, *url_args):
        crime = mock.Mock(spec=models.Schema)
        from ebpub.db.schemafilters import LocationFilter
        reverse_args = ('locations',) + url_args
        url = filter_reverse('crime', [reverse_args])
        req = RequestFactory().get(url)
        context = {'schema': crime}
        filt = LocationFilter(req, context, None, *reverse_args[1:])
        return filt

    def test_filter__empty(self):
        self.assertRaises(FilterError, self._make_filter)

    def test_filter_by_location__choices(self):
        filt = self._make_filter('neighborhoods')
        more_needed = filt.validate()
        self.assertEqual(more_needed['filter_key'], u'location')
        self.assertEqual(more_needed['param_name'], 'locations')
        self.assertEqual(more_needed['param_label'], u'Neighborhood')
        self.assert_(len(more_needed['option_list']) > 0)
        self.assertEqual(filt.get_query_params(),
                         {'locations': 'neighborhoods'})

    @mock.patch('ebpub.db.schemafilters.models.Location.objects.filter')
    def test_filter_by_location__no_locations(self, mock_location_query):
        mock_location_query.return_value.order_by.return_value = []
        filt = self._make_filter('neighborhoods')
        self.assertRaises(FilterError, filt.validate)
        try:
            filt.validate()
        except FilterError, e:
            self.assertEqual(str(e), "'empty lookup list'")

    def test_filter_by_location_detail(self):
        # TODO: this exercises a lot of implementation details; mock
        # more things to make it more isolated unit test?
        filt = self._make_filter('neighborhoods', 'hood-1')
        filt.request.user = mock.Mock(is_anonymous=lambda: True)
        self.assertEqual(filt.validate(), {})
        filt.apply()
        expected_loc = models.Location.objects.get(slug='hood-1')
        self.assertEqual(filt.location_object, expected_loc)
        self.assertEqual(filt.get_query_params(),
                         {'locations': 'neighborhoods,hood-1'})
        # Items 1 & 2 should match this query because there's a corresponding
        # NewsItemLocation.
        self.assertEqual(sorted([item.id for item in filt.qs]),
                         [1, 2])


class TestBlockFilter(TestCase):

    fixtures = ('test-schemafilter-views.json',)

    def _make_filter(self, *url_args):
        crime = mock.Mock(spec=models.Schema)
        from ebpub.db.schemafilters import BlockFilter
        reverse_args = ('streets',) + url_args
        url = filter_reverse('crime', [reverse_args])
        req = RequestFactory().get(url)
        context = {'schema': crime}
        filt = BlockFilter(req, context, None, *reverse_args[1:])
        return filt

    def test_filter__errors(self):
        self.assertRaises(FilterError, self._make_filter)
        self.assertRaises(FilterError, self._make_filter, '')
        self.assertRaises(FilterError, self._make_filter, 'wabash-ave')
        # Bogus block range.
        self.assertRaises(FilterError, self._make_filter, 'wabash-ave', 'bogus', '8')


    @mock.patch('ebpub.db.schemafilters.get_metro')
    @mock.patch('ebpub.db.schemafilters.url_to_block')
    def test_filter__ok(self, mock_url_to_block, mock_get_metro):
        def _mock_url_to_block(request, *args, **kwargs):
            from django.contrib.gis.geos import Point
            block = mock.Mock(
                from_num=99, to_num=100, street_slug='something',
                pretty_name='99-100 something st',
                location=Point(60.0, 60.0),
                city='boston', left_city='boston',
                )
            block.number.return_value = '99-100'
            block.dir_url_bit.return_value = ''
            return block

        mock_url_to_block.side_effect = _mock_url_to_block
        mock_get_metro.return_value = {'multiple_cities': True}
        filt = self._make_filter('boston', 'wabash-ave', '216-299n-s', '8-blocks')
        self.assertEqual(filt.validate(), {})
        filt.apply()
        self.assertEqual(filt.location_object.from_num, 99)
        self.assertEqual(filt.location_object.to_num, 100)
        self.assertEqual(filt.value, '8 blocks around 99-100 something st')

class TestDateFilter(TestCase):

    fixtures = ('test-locationtypes.json', 'test-locations.json', 'crimes.json'
                )

    def _make_filter(self, *url_args):
        crime = mock.Mock()
        from ebpub.db.schemafilters import DateFilter
        url = filter_reverse('crime', [url_args])
        req = RequestFactory().get(url)
        context = {'schema': crime}
        self.mock_qs = mock.Mock()
        filt = DateFilter(req, context, self.mock_qs, *url_args[1:])
        return filt

    def test_filter__errors(self):
        self.assertRaises(FilterError, self._make_filter, '')
        self.assertRaises(FilterError, self._make_filter, 'by-date')
        self.assertRaises(FilterError, self._make_filter, 'by-date', 'bogus')
        self.assertRaises(FilterError, self._make_filter, 'by-date', 'bogus', 'bogus')

    def test_filter__ok(self):
        filt = self._make_filter('by-date', '2006-11-08', '2006-11-09')
        self.assertEqual(filt.validate(), {})
        filt.apply()
        self.assertEqual(filt.value, u'Nov. 8, 2006 - Nov. 9, 2006')
        self.assertEqual(self.mock_qs.filter.call_args, ((), filt.kwargs))

    def test__single_arg_date(self):
        filt = self._make_filter('by-date', '2011-04-07')
        filt.apply()
        self.assertEqual(filt.value, u'April 7, 2011')


    def test_filter__ok__one_day(self):
        filt = self._make_filter('by-date', '2006-11-08', '2006-11-08')
        self.assertEqual(filt.validate(), {})
        filt.apply()
        self.assertEqual(filt.value, u'Nov. 8, 2006')
        self.assertEqual(self.mock_qs.filter.call_args, ((), filt.kwargs))

    def test_pub_date_filter(self):
        filt = self._make_filter('by-pubdate', '2006-11-08', '2006-11-09')
        from ebpub.db.schemafilters import PubDateFilter
        filt2 = PubDateFilter(filt.request, filt.context, filt.qs,
                              '2006-11-08', '2006-11-09')
        self.assertEqual(filt2.validate(), {})
        filt2.apply()
        self.assertEqual(filt2.date_field_name, 'pub_date')
        self.assertEqual(filt2.label, 'date published')
        self.assertEqual(self.mock_qs.filter.call_args, ((), filt2.kwargs))


class TestAttributeFilter(TestCase):

    def _mock_schemafield(self, name='mock-sf', pretty_name='Mock SF', **kwargs):
        # This is because the 'name' argument to mock.Mock
        # means something special, so we have to assign to it
        # after instantiation.
        sf = mock.Mock(pretty_name=pretty_name, **kwargs)
        sf.name = name
        return sf

    def test_init__no_args(self):
        from ebpub.db.schemafilters import AttributeFilter
        schemafield = self._mock_schemafield(name='mock-sf')
        qs = {}
        request = context = None
        filter = AttributeFilter(request, context, qs, schemafield=schemafield)
        self.assertEqual(filter.get_query_params(),
                         {'by-mock-sf': ''})


    def test_init__with_date(self):
        from ebpub.db.schemafilters import AttributeFilter
        schemafield = self._mock_schemafield(name='mock-sf')
        when = datetime.date(2009, 1, 23)
        qs = {}
        request = context = None
        filter = AttributeFilter(request, context, qs, when, schemafield=schemafield)
        self.assertEqual(filter.get_query_params(),
                         {'by-mock-sf': '2009-01-23'})

    def test_init__with_datetime(self):
        from ebpub.db.schemafilters import AttributeFilter
        schemafield = self._mock_schemafield(name='mock-sf')
        when = datetime.datetime(2009, 1, 23, 22, 40)
        qs = {}
        request = context = None
        filter = AttributeFilter(request, context, qs, when, schemafield=schemafield)
        self.assertEqual(filter.get_query_params(),
                         {'by-mock-sf': '2009-01-23T22:40:00'})

    def test_init__with_time(self):
        from ebpub.db.schemafilters import AttributeFilter
        schemafield = self._mock_schemafield(name='mock-sf')
        when = datetime.time(22, 40)
        qs = {}
        request = context = None
        filter = AttributeFilter(request, context, qs, when, schemafield=schemafield)
        self.assertEqual(filter.get_query_params(), 
                         {'by-mock-sf': '22:40:00'})


class TestBoolFilter(TestCase):

    fixtures = ('crimes.json',)

    def _make_filter(self, *url_args):
        crime = models.Schema.objects.get(slug='crime')
        from ebpub.db.schemafilters import BoolFilter
        url = filter_reverse('crime', [url_args])
        req = RequestFactory().get(url)
        context = {'schema': crime}
        sf_name = url_args[0][3:]   # 'by-foo' -> 'foo'
        sf = models.SchemaField.objects.get(name=sf_name, schema=crime)
        self.mock_qs = mock.Mock()
        filt = BoolFilter(req, context, self.mock_qs, *url_args[1:], schemafield=sf)
        return filt

    def test_filter__errors(self):
        self.assertRaises(FilterError, self._make_filter, 'by-arrests', 'maybe')
        self.assertRaises(FilterError, self._make_filter, 'by-arrests', 'maybe', 'no')

    def test_filter__ok(self):
        filt = self._make_filter('by-arrests', 'no')
        self.assertEqual(filt.validate(), {})
        filt.apply()
        self.assertEqual(self.mock_qs.by_attribute.call_args,
                         ((filt.schemafield, False), {}))
        self.assertEqual(filt.label, 'Arrests')
        self.assertEqual(filt.short_value, 'No')
        self.assertEqual(filt.value, 'Arrests: No')

    def test_filter__more_needed(self):
        filt = self._make_filter('by-arrests')
        more_needed = filt.validate()
        self.assertEqual(more_needed['filter_key'], 'arrests')
        self.assertEqual(more_needed['param_name'], 'by-arrests')


class TestLookupFilter(TestCase):

    fixtures = ('crimes.json',)

    def _make_filter(self, *url_args):
        crime = mock.Mock()
        from ebpub.db.schemafilters import LookupFilter
        url = filter_reverse('crime', [url_args])
        req = RequestFactory().get(url)
        context = {'schema': crime}
        sf_name, lookups = url_args[0], url_args[1:]
        sf_name = sf_name[3:]   # 'by-foo' -> 'foo'
        sf = models.SchemaField.objects.get(name=sf_name)
        self.mock_qs = mock.Mock()
        filt = LookupFilter(req, context, self.mock_qs, *lookups, schemafield=sf)
        return filt

    def test_filter__errors(self):
        #self.assertRaises(FilterError, self._make_filter, 'by-beat', )
        self.assertRaises(FilterError, self._make_filter, 'by-beat', 'whoops')
        self.assertRaises(FilterError,
                          self._make_filter, 'by-beat', 'beat-9999')


    def test_filter__more_needed(self):
        filt = self._make_filter('by-beat')
        more_needed = filt.validate()
        self.assert_(more_needed)
        self.assertEqual(more_needed['filter_key'], 'beat')
        self.assertEqual(more_needed['param_name'], 'by-beat')
        self.assertEqual(more_needed['param_label'], 'Beats')
        self.assert_(len(more_needed['option_list']) > 0)

    def test_filter__ok_single(self):
        filt = self._make_filter('by-beat', 'beat-214', )
        self.assertEqual(filt.validate(), {})
        filt.apply()
        self.assertEqual(filt.lookups[0].id, 214)
        self.assertEqual(self.mock_qs.by_attribute.call_args,
                         ((filt.schemafield, filt.lookups), {'is_lookup': True}))
        self.assertEqual(filt.value, 'Police Beat 214')
        self.assertEqual(filt.short_value, 'Police Beat 214')
        self.assertEqual(filt.label, 'Beat')
        self.assertEqual(filt.argname, 'by-beat')

    def test_filter__ok_multi(self):
        filt = self._make_filter('by-beat', 'beat-214', 'beat-64')
        self.assertEqual(filt.validate(), {})
        filt.apply()
        self.assertEqual(filt.lookups[0].id, 214)
        self.assertEqual(filt.lookups[1].id, 64)
        self.assertEqual(self.mock_qs.by_attribute.call_args,
                         ((filt.schemafield, filt.lookups), {'is_lookup': True}))
        self.assertEqual(filt.value, 'Police Beat 214, Police Beat 64')
        self.assertEqual(filt.short_value, 'Police Beat 214, Police Beat 64')
        self.assertEqual(filt.label, 'Beat')
        self.assertEqual(filt.argname, 'by-beat')
        self.assertEqual(filt.get_query_params(),
                         {'by-beat': 'beat-214,beat-64'})


class TestTextFilter(TestCase):

    fixtures = ('crimes.json',)

    def _make_filter(self, *url_args):
        crime = models.Schema.objects.get(slug='crime')
        from ebpub.db.schemafilters import TextSearchFilter
        url = filter_reverse('crime', [url_args])
        req = RequestFactory().get(url)
        context = {'schema': crime}
        sf_name = url_args[0][3:]   # 'by-foo' -> 'foo'
        sf = models.SchemaField.objects.get(name=sf_name, schema=crime)
        self.mock_qs = mock.Mock()
        filt = TextSearchFilter(req, context, self.mock_qs, *url_args[1:], schemafield=sf)
        return filt

    def test_filter__errors(self):
        self.assertRaises(FilterError, self._make_filter, 'by-status')

    def test_filter__ok(self):
        filt = self._make_filter('by-status', 'status 9-19')
        self.assertEqual(filt.validate(), {})
        filt.apply()
        self.assertEqual(self.mock_qs.text_search.call_count, 1)


class TestFilterChain(TestCase):

    def test_empty(self):
        chain = FilterChain()
        self.assertEqual(chain.items(), [])

    def test_ordering(self):
        chain = FilterChain()
        args = range(10)
        random.shuffle(args)
        for i in args:
            chain[i] = i
        self.assertEqual(chain.items(), [(i, i) for i in args])
        self.assertEqual(chain.keys(), args)

    def test_copy_and_mutate(self):
        schema = mock.Mock()
        chain = FilterChain(schema=schema)
        chain.lookup_descriptions.append(1)
        chain.base_url = 'http://xyz'
        chain['foo'] = 'bar'
        chain['qux'] = 'whee'
        clone = chain.copy()
        # Attributes are copied...
        self.assertEqual(clone.lookup_descriptions, [1])
        self.assertEqual(clone.base_url, chain.base_url)
        self.assertEqual(clone.schema, chain.schema, schema)
        # ... and mutating them doesn't affect the original.
        clone.lookup_descriptions.pop()
        self.assertEqual(chain.lookup_descriptions, [1])
        # Likewise, items are copied, and mutating doesn't affect the copy.
        self.assertEqual(clone['foo'], 'bar')
        del chain['foo']
        self.assertEqual(clone['foo'], 'bar')
        del clone['qux']
        self.assertEqual(chain['qux'], 'whee')
        # Likewise, clearing.
        clone.clear()
        self.assertEqual(clone.items(), [])
        self.assertEqual(chain['qux'], 'whee')

    def test_no_duplicates(self):
        from ebpub.db.schemafilters import DuplicateFilterError
        self.assertRaises(DuplicateFilterError, FilterChain,
                          (('foo', 'bar'), ('foo', 'bar2')))
        chain = FilterChain()
        chain['foo'] = 'bar'
        self.assertRaises(DuplicateFilterError, chain.__setitem__, 'foo', 'bar')

    def test_sort(self):
        class Dummy(object):
            def __init__(self, sort_value):
                self._sort_value = sort_value

        dummies = [Dummy(i) for i in range(10)]
        random.shuffle(dummies)
        chain = FilterChain()
        for i in range(10):
            chain[i] = dummies[i]

        self.assertNotEqual(range(10),
                            [v._sort_value for v in chain.values()])

        normalized = chain.copy()
        normalized.sort()
        self.assertEqual(range(10),
                         [v._sort_value for v in normalized.values()])


    def test_sort__real_filters(self):
        req = mock.Mock()
        qs = mock.Mock()
        schema = mock.Mock()
        context = {'newsitem_qs': qs, 'schema': schema}
        from ebpub.db.schemafilters import TextSearchFilter, BoolFilter
        from ebpub.db.schemafilters import LookupFilter, LocationFilter
        from ebpub.db.schemafilters import DateFilter

        def mock_schemafield(name):
            # mock.Mock(name='foo') does something magic, but I just
            # want to set the name attribute.
            sf = mock.Mock()
            sf.name = name
            return sf

        all_filters = [
            TextSearchFilter(req, context, qs, 'hi',
                             schemafield=mock_schemafield(name='mock text sf')),
            BoolFilter(req, context, qs, 'yes',
                       schemafield=mock_schemafield(name='mock bool sf')),
            LookupFilter(req, context, qs,
                         schemafield=mock_schemafield(name='mock lookup sf')),
            LocationFilter(req, context, qs, 'neighborhoods'),
            DateFilter(req, context, qs, '2011-04-11', '2011-04-12'),
            ]
        chain = FilterChain([(item.slug, item) for item in all_filters])
        ordered_chain = chain.copy()
        ordered_chain.sort()
        self.assertEqual(ordered_chain.keys(),
                         ['date', 'mock bool sf', 'location', 'mock lookup sf', 'mock text sf'])

    def test_filters_for_display(self):
        class Dummy(object):
            def __init__(self, label):
                self.label = label
        chain = FilterChain([('foo', Dummy('yes')),
                             ('bar', Dummy(None)),
                             ('bat', Dummy('yes also')),
                             ('baz', Dummy(None)),
                             ])
        self.assertEqual(len(chain.values()), 4)
        self.assertEqual(len(chain.filters_for_display()), 2)
        self.assert_(all([f.label for f in chain.filters_for_display()]))

    def test_add_date__whole_month(self):
        # Special syntax for adding a whole month, convenient for templates
        # where you don't want to have to calculate the end date.
        chain = FilterChain()
        import datetime
        chain.add('date', datetime.date(2011, 8, 13), 'month')
        self.assertEqual(chain['date'].start_date, datetime.date(2011, 8, 1))
        self.assertEqual(chain['date'].end_date, datetime.date(2011, 8, 31))

    def test_add__pubdate(self):
        # Key gets overridden.
        chain = FilterChain()
        import datetime
        chain.add('pubdate', datetime.date(2011, 8, 13))
        self.assert_(chain.has_key('date'))
        self.failIf(chain.has_key('pubdate'))
        self.assertEqual(chain['date'].start_date, datetime.date(2011, 8, 13))

    def test_add__bogus_keyword_arg(self):
        chain = FilterChain()
        self.assertRaises(TypeError, chain.add, 'date', '2011-01-1', foo='bar')

    def test_add__no_value(self):
        chain = FilterChain()
        self.assertRaises(FilterError, chain.add, 'date')

    def test_update_from_request__empty(self):
        request = mock.Mock()
        class StubQueryDict(dict):
            def getlist(self, key):
                return []
            def copy(self):
                return StubQueryDict(self.items())

        request.GET = StubQueryDict()
        chain = FilterChain(request=request)
        chain.update_from_request({})
        self.assertEqual(len(chain), 0)

    def test_add_by_place_id__bad(self):
        chain = FilterChain()
        from django.http import Http404
        self.assertRaises(Http404, chain.add_by_place_id, '')
        self.assertRaises(Http404, chain.add_by_place_id, 'blah')
        self.assertRaises(Http404, chain.add_by_place_id, 'b:123.1')
        self.assertRaises(Http404, chain.add_by_place_id, 'l:9999')

    @mock.patch('ebpub.utils.view_utils.get_object_or_404')
    def test_add_by_place_id(self, mock_get_object_or_404):
        chain = FilterChain()
        from ebpub.streets.models import Block
        from ebpub.db.schemafilters import BlockFilter
        block = Block(city='city', street_slug='street_slug',
                      pretty_name='pretty_name',
                      street_pretty_name='street_pretty_name',
                      street='street',
                      from_num='123', to_num='456',
                      )
        mock_get_object_or_404.return_value = block
        chain.add_by_place_id('b:123.1')
        self.assert_(isinstance(chain['location'], BlockFilter))

    def test_add__id(self):
        from ebpub.db.schemafilters import IdFilter
        chain = FilterChain()
        chain.add('id', [1, 2, 3])
        self.assert_(isinstance(chain['id'], IdFilter))


class TestUrlNormalization(TestCase):

    fixtures = ('test-schemafilter-views.json',)

    def setUp(self):
        super(TestUrlNormalization, self).setUp()
        self._patcher1 = mock.patch('ebpub.streets.models.proper_city')
        self.proper_city = self._patcher1.start()
        self.proper_city.return_value = 'chicago'
        self._patcher2 = mock.patch('ebpub.db.schemafilters.SmartGeocoder.geocode')
        self.mock_geocode = self._patcher2.start()

    def tearDown(self):
        self._patcher1.stop()
        self._patcher2.stop()
        super(TestUrlNormalization, self).tearDown()

    def _make_chain(self, url):
        request = RequestFactory().get(url)
        crime = models.Schema.objects.get(slug='crime')
        context = {'schema': crime}
        chain = FilterChain(request=request, context=context, schema=crime)
        chain.update_from_request(filter_sf_dict={})
        return chain

    def test_urls__ok(self):
        url = filter_reverse('crime',
                             [('streets', 'wabash-ave', '216-299n-s', '8-blocks'),])
        chain = self._make_chain(url)
        self.assertEqual(url, chain.make_url())

    def test_urls__intersection(self):
        url = urlresolvers.reverse(
            'ebpub-schema-filter', args=['crime']) + '?address=foo+and+bar'
        from ebpub.streets.models import Block, Intersection, BlockIntersection
        intersection = mock.Mock(spec=Intersection)
        blockintersection = mock.Mock(spec=BlockIntersection)
        blockintersection.block = Block.objects.get(street_slug='wabash-ave', from_num=216)
        intersection.blockintersection_set.all.return_value = [blockintersection]
        self.mock_geocode.return_value = {'intersection': intersection,
                                          'block': None}
        chain = self._make_chain(url)
        expected = filter_reverse('crime', [('streets', 'wabash-ave', '216-299n-s', '8-blocks'),])
        result = chain.make_url()
        self.assertEqual(result, expected)

    def test_urls__bad_intersection(self):
        url = urlresolvers.reverse(
            'ebpub-schema-filter', args=['crime']) + '?address=foo+and+bar'
        from ebpub.streets.models import Block, Intersection, BlockIntersection
        intersection = mock.Mock(spec=Intersection)
        blockintersection = mock.Mock(spec=BlockIntersection)
        blockintersection.block = Block.objects.get(street_slug='wabash-ave', from_num=216)
        self.mock_geocode.return_value = {'intersection': intersection,
                                          'block': None}

        # Empty intersection list.
        intersection.blockintersection_set.all.return_value = []
        self.assertRaises(IndexError, self._make_chain, url)

        # Or, no block or intersection at all.
        self.mock_geocode.return_value = {'intersection': None, 'block': None}
        self.assertRaises(NotImplementedError, self._make_chain, url)


    def test_make_url__bad_address(self):
        url = urlresolvers.reverse('ebpub-schema-filter', args=['crime'])
        url += '?address=anything'  # doesn't matter because of mock_geocode

        from ebpub.geocoder.parser.parsing import ParsingError
        self.mock_geocode.side_effect = ParsingError()
        self.assertRaises(BadAddressException, self._make_chain, url)

        from ebpub.geocoder import GeocodingException
        self.mock_geocode.side_effect = GeocodingException()
        self.assertRaises(BadAddressException, self._make_chain, url)

        from ebpub.geocoder import AmbiguousResult
        self.mock_geocode.side_effect = AmbiguousResult(['foo', 'bar'])
        self.assertRaises(BadAddressException, self._make_chain, url)

    def test_make_url__address_query(self):
        from ebpub.streets.models import Block
        block = Block.objects.get(street_slug='wabash-ave', from_num=216)
        self.mock_geocode.return_value = {
            'city': block.left_city.title(),
            'zip': block.left_zip,
            'point': block.geom.centroid,
            'state': block.left_state,
            'intersection_id': None,
            'address': u'216 N Wabash Ave',
            'intersection': None,
            'block': block,
            }

        url = urlresolvers.reverse('ebpub-schema-filter', args=['crime'])
        url += '?address=216+n+wabash+st&radius=8' # geocode result is mocked anyway.

        expected_url = filter_reverse('crime', [('streets', 'wabash-ave', '216-299n-s', '8-blocks'),])
        chain = self._make_chain(url)
        self.assertEqual(expected_url, chain.make_url())

    def test_make_url__bad_dates(self):
        from ebpub.db.views import BadDateException
        url = urlresolvers.reverse('ebpub-schema-filter', args=['crime'])
        # Error if either date is way too old.
        self.assertRaises(BadDateException, self._make_chain,
                          url + '?start_date=12/31/1899&end_date=01/01/2011')
        self.assertRaises(BadDateException, self._make_chain,
                          url + '?start_date=01/01/2011&end_date=12/31/1899')

        # Error if either date is not a parseable date.
        self.assertRaises(BadDateException, self._make_chain,
                          url + '?start_date=Whoops&end_date=01/01/2011')
        self.assertRaises(BadDateException, self._make_chain,
                          url + '?start_date=01/01/2011&end_date=Bzorch')


    def test_make_url__date_query(self):
        url = urlresolvers.reverse('ebpub-schema-filter', args=['crime'])
        url += '?start_date=2010/12/01&end_date=2011/01/01'
        chain = self._make_chain(url)
        expected = filter_reverse('crime', [('start_date', '2010-12-01'),
                                            ('end_date', '2011-01-01')])
        self.assertEqual(chain.make_url(), expected)

    def test_make_url__no_such_schemafield(self):
        url = urlresolvers.reverse('ebpub-schema-filter', args=['crime'])
        url += '?textsearch=foo&q=hello+goodbye'
        self.assertRaises(models.SchemaField.DoesNotExist,
                          self._make_chain, url)

    def test_make_url__textsearch_query(self):
        url = urlresolvers.reverse('ebpub-schema-filter', args=['crime'])
        url += '?textsearch=status&q=hello+goodbye'
        chain = self._make_chain(url)
        expected = filter_reverse('crime', [('by-status', 'hello goodbye')])
        self.assertEqual(chain.make_url(), expected)

    def test_make_url__preserves_other_query_params_sorted(self):
        url = filter_reverse('crime', [('start_date', '2011-04-05'),
                                       ('end_date', '2011-04-06')])
        url += '&textsearch=status&q=bar'
        # Add the extra params.
        url += '&zzz=yes&A=no'
        chain = self._make_chain(url)
        expected = filter_reverse('crime', [('start_date', '2011-04-05'),
                                            ('end_date', '2011-04-06'),
                                            ('by-status', 'bar')])
        # The extra params should end up sorted alphanumerically.
        expected = expected.replace('?', '?A=no&') + '&zzz=yes'
        self.assertEqual(chain.make_url(), expected)

########NEW FILE########
__FILENAME__ = test_templatetags
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.core import urlresolvers
from django import template
from django.template import base as template_base
from django.template import loader
from django.utils.translation import activate, deactivate
from ebpub.db.templatetags import eb_filter
from ebpub.db.templatetags import eb
from ebpub.utils.django_testcase_backports import TestCase
import mock
import os
import sys
import traceback
import unittest

class TestFilterUrl(unittest.TestCase):

    def setUp(self):
        self.mock_parser = mock.Mock()
        self.mock_token = mock.Mock()
        self.mock_filterchain = mock.Mock()
        # Monkeypatching because Variable has no useful equality test by default
        template.Variable.__eq__ = lambda self, other: self.var == other.var

    def tearDown(self):
        del(template.Variable.__eq__)

    def test__invalid_no_filterchain(self):
        self.mock_token.split_contents.return_value = ['filter_url']
        self.assertRaises(template.TemplateSyntaxError,
                          eb_filter.filter_url, self.mock_parser, self.mock_token)

    def test__invalid__bad_addition(self):
        self.mock_token.split_contents.return_value = ['filter_url', 'filterchain', 'oops']
        self.assertRaises(template.TemplateSyntaxError,
                          eb_filter.filter_url, self.mock_parser, self.mock_token)

    def test__invalid__bad_addition2(self):
        self.mock_token.split_contents.return_value = [
            'filter_url', 'filterchain', '+', 'oops']
        self.assertRaises(template.TemplateSyntaxError,
                          eb_filter.filter_url, self.mock_parser, self.mock_token)

    def test__invalid__bad_removal(self):
        self.mock_token.split_contents.return_value = [
            'filter_url', 'filterchain', '-', 'oops']

        self.assertRaises(template.TemplateSyntaxError,
                          eb_filter.filter_url, self.mock_parser, self.mock_token)

    def test__only_filterchain(self):
        self.mock_token.split_contents.return_value = ['filter_url',
                                                       'filterchain']
        node = eb_filter.filter_url(self.mock_parser, self.mock_token)
        self.assertEqual(node.additions, ())
        self.assertEqual(node.removals, ())
        self.assertEqual(node.filterchain_var.var, 'filterchain')

    def test__addition_no_args(self):
        self.mock_token.split_contents.return_value = [
            'filter_url', 'filterchain', '+maybe']
        node = eb_filter.filter_url(self.mock_parser, self.mock_token)
        self.assertEqual(node.additions, ((template.Variable('maybe'), ()),))

    def test__additions(self):
        self.mock_token.split_contents.return_value = ['filter_url',
                                                       'filterchain',
                                                       '+foo', 'foo2',
                                                       '+bar', 'bar2', 'bar3',
                                                       '+baz', 'baz2']
        node = eb_filter.filter_url(self.mock_parser, self.mock_token)
        self.assertEqual(node.removals, ())
        self.assertEqual(len(node.additions), 3)
        from django.template import Variable
        expected = ((Variable('foo'), (Variable('foo2'),)),
                    (Variable('bar'), (Variable('bar2'), Variable('bar3'))),
                    (Variable('baz'), (Variable('baz2'),)))

        self.assertEqual(node.additions, expected)

    def test__removals(self):
        self.mock_token.split_contents.return_value = ['filter_url',
                                                       'filterchain',
                                                       '-foo', '-bar', '-baz']
        node = eb_filter.filter_url(self.mock_parser, self.mock_token)
        self.assertEqual(node.additions, ())
        self.assertEqual(len(node.removals), 3)
        Variable = template.Variable
        expected = (Variable('foo'), Variable('bar'), Variable('baz'))
        self.assertEqual(node.removals, expected)

    def test__additions_and_removals(self):
        self.mock_token.split_contents.return_value = ['filter_url',
                                                       'filterchain',
                                                       '-foo',
                                                       '+bar', 'bar2',
                                                       '-baz']
        node = eb_filter.filter_url(self.mock_parser, self.mock_token)
        self.assertEqual(len(node.removals), 2)
        self.assertEqual(len(node.additions), 1)

        Variable = template.Variable
        self.assertEqual(node.additions,
                         ((Variable('bar'), (Variable('bar2'),)),))
        self.assertEqual(node.removals,
                         (Variable('foo'), Variable('baz')))

    def test_render(self):
        from ebpub.db.schemafilters import FilterChain
        mock_chain = mock.Mock(spec=FilterChain)
        # Hack so mock_chain() also inherits FilterChain
        mock_chain.return_value = mock_chain
        mock_chain.schema = mock.Mock()
        mock_chain.make_url.return_value = 'ok'
        mock_chain.schema.url.return_value = 'http://X/'

        context = {'filterchain': mock_chain,
                   'add1': 'X', 'add2': 'Y', 'remove1': 'Z'}
        node = eb_filter.FilterUrlNode('filterchain',
                                       [('add1', ('add2',))],
                                       ['remove1'])
        self.assertEqual(node.render(context), 'ok')
        self.assertEqual(mock_chain.make_url.call_args,
                         ((), {'additions': [('X', ['Y'])], 'removals': ['Z']}))


class TestSimpleTags(unittest.TestCase):
    # Misc tags that don't require a database for testing.

    def test_schema_plural_name(self):
        class stubschema:
            name = 'dog'
            plural_name = 'dogs'

        self.assertEqual(eb.schema_plural_name(stubschema, 0), 'dogs')
        self.assertEqual(eb.schema_plural_name(stubschema, 1), 'dog')
        self.assertEqual(eb.schema_plural_name(stubschema, 2), 'dogs')
        self.assertEqual(eb.schema_plural_name(stubschema, -1), 'dogs')
        self.assertEqual(eb.schema_plural_name(stubschema, 999), 'dogs')

    def test_schema_plural_name__list(self):
        class stubschema:
            name = 'dog'
            plural_name = 'dogs'

        self.assertEqual(eb.schema_plural_name(stubschema, []), 'dogs')
        self.assertEqual(eb.schema_plural_name(stubschema, [None]), 'dog')
        self.assertEqual(eb.schema_plural_name(stubschema, [None, None]), 'dogs')

    def test_safe_id_sort(self):
        class Item(dict):
            def __init__(self, id, *args, **kwargs):
                self.id = id
                self.update(kwargs)

        items = [
            Item(3, a=1, b=2, c=3),
            Item(4, a=1, b=2, c=3),
            Item(-1, a=1, b=2, c=3),
            Item(4, a=1, b=-999, c=3),
            ]
        result = eb.safe_id_sort(items, 'b')
        self.assertEqual([(item['b'], item.id) for item in result],
                         [(-999, 4),
                          (2, -1),
                          (2, 3),
                          (2, 4)]
                         )


    def test_get_metro(self):
        import ebpub.metros.allmetros
        context = {}
        eb.get_metro(context)
        self.assertEqual(context['METRO'], ebpub.metros.allmetros.get_metro())

    def test_get_metro_list(self):
        import ebpub.metros.allmetros
        context = {}
        eb.get_metro_list(context)
        self.assertEqual(context['METRO_LIST'], ebpub.metros.allmetros.METRO_LIST)


from django.conf import settings

class ShouldNotExecuteException(Exception):
    pass

class ContextStackException(Exception):
    pass


class BaseTemplateTagSetup(object):

    # The actual test cases are a dictionary returned by self.get_template_tests().

    # Partially copied from django.tests.regressiontests.templates.tests,
    # which is not available for import if we don't have a development checkout
    # of Django.

    def setUp(self):
        from django.test.utils import get_warnings_state
        import warnings
        self._warnings_state = get_warnings_state()
        warnings.filterwarnings('ignore', category=DeprecationWarning,
                                module='django.template.defaulttags')

        self.old_static_url = settings.STATIC_URL
        self.old_media_url = settings.MEDIA_URL
        settings.STATIC_URL = u"/static/"

        settings.MEDIA_URL = u"/media/"

    def tearDown(self):
        from django.test.utils import restore_warnings_state
        settings.STATIC_URL = self.old_static_url
        settings.MEDIA_URL = self.old_media_url
        restore_warnings_state(self._warnings_state)

    def test_templates(self):
        from django.test.utils import setup_test_template_loader
        from django.test.utils import restore_template_loaders

        template_tests = self.get_template_tests()
        filter_tests = {}  #filters.get_filter_tests()

        # Quickly check that we aren't accidentally using a name in both
        # template and filter tests.
        overlapping_names = [name for name in filter_tests if name in template_tests]
        assert not overlapping_names, 'Duplicate test name(s): %s' % ', '.join(overlapping_names)

        template_tests.update(filter_tests)

        cache_loader = setup_test_template_loader(
            dict([(name, t[0]) for name, t in template_tests.iteritems()]),
            use_cached_loader=True,
        )
        failures = []

        # Turn TEMPLATE_DEBUG off, because tests assume that.
        old_td, settings.TEMPLATE_DEBUG = settings.TEMPLATE_DEBUG, False

        # Set TEMPLATE_STRING_IF_INVALID to a known string.
        old_invalid = settings.TEMPLATE_STRING_IF_INVALID
        expected_invalid_str = 'INVALID'

        #Set ALLOWED_INCLUDE_ROOTS so that ssi works.
        old_allowed_include_roots = settings.ALLOWED_INCLUDE_ROOTS
        settings.ALLOWED_INCLUDE_ROOTS = (
            os.path.dirname(os.path.abspath(__file__)),
            )

        try:
            # Openblock: Original code copied from django regression tests
            # didn't have a try/finally block here, which meant any failure
            # below would cause failure to restore template loaders etc.,
            # with disastrous effects for other test suites.
            tests = template_tests.items()
            tests.sort()
            # Warm the URL reversing cache. This ensures we don't pay the cost
            # warming the cache during one of the tests.
            urlresolvers.reverse('ebpub-homepage')

            for name, vals in tests:
                if isinstance(vals[2], tuple):
                    normal_string_result = vals[2][0]
                    invalid_string_result = vals[2][1]

                    if isinstance(invalid_string_result, tuple):
                        expected_invalid_str = 'INVALID %s'
                        invalid_string_result = invalid_string_result[0] % invalid_string_result[1]
                        template_base.invalid_var_format_string = True

                    try:
                        template_debug_result = vals[2][2]
                    except IndexError:
                        template_debug_result = normal_string_result

                else:
                    normal_string_result = vals[2]
                    invalid_string_result = vals[2]
                    template_debug_result = vals[2]

                if 'LANGUAGE_CODE' in vals[1]:
                    activate(vals[1]['LANGUAGE_CODE'])
                else:
                    activate('en-us')
                for invalid_str, template_debug, result in [
                        ('', False, normal_string_result),
                        (expected_invalid_str, False, invalid_string_result),
                        ('', True, template_debug_result)
                    ]:
                    settings.TEMPLATE_STRING_IF_INVALID = invalid_str
                    settings.TEMPLATE_DEBUG = template_debug
                    for is_cached in (False, True):
                        try:
                            try:
                                test_template = loader.get_template(name)
                            except ShouldNotExecuteException:
                                failures.append("Template test (Cached='%s', TEMPLATE_STRING_IF_INVALID='%s', TEMPLATE_DEBUG=%s): %s -- FAILED. Template loading invoked method that shouldn't have been invoked." % (is_cached, invalid_str, template_debug, name))

                            try:
                                output = self.render(test_template, vals)
                            except ShouldNotExecuteException:
                                failures.append("Template test (Cached='%s', TEMPLATE_STRING_IF_INVALID='%s', TEMPLATE_DEBUG=%s): %s -- FAILED. Template rendering invoked method that shouldn't have been invoked." % (is_cached, invalid_str, template_debug, name))
                        except ContextStackException:
                            failures.append("Template test (Cached='%s', TEMPLATE_STRING_IF_INVALID='%s', TEMPLATE_DEBUG=%s): %s -- FAILED. Context stack was left imbalanced" % (is_cached, invalid_str, template_debug, name))
                            continue
                        except Exception:
                            exc_type, exc_value, exc_tb = sys.exc_info()
                            if exc_type != result:
                                tb = '\n'.join(traceback.format_exception(exc_type, exc_value, exc_tb))
                                failures.append("Template test (Cached='%s', TEMPLATE_STRING_IF_INVALID='%s', TEMPLATE_DEBUG=%s): %s -- FAILED. Got %s, exception: %s\n%s" % (is_cached, invalid_str, template_debug, name, exc_type, exc_value, tb))
                            continue
                        if output != result:
                            failures.append("Template test (Cached='%s', TEMPLATE_STRING_IF_INVALID='%s', TEMPLATE_DEBUG=%s): %s -- FAILED. Expected %r, got %r" % (is_cached, invalid_str, template_debug, name, result, output))
                    cache_loader.reset()

                if 'LANGUAGE_CODE' in vals[1]:
                    deactivate()

                if template_base.invalid_var_format_string:
                    expected_invalid_str = 'INVALID'
                    template_base.invalid_var_format_string = False
        finally:
            restore_template_loaders()
            deactivate()
            settings.TEMPLATE_DEBUG = old_td
            settings.TEMPLATE_STRING_IF_INVALID = old_invalid
            settings.ALLOWED_INCLUDE_ROOTS = old_allowed_include_roots

        self.assertEqual(failures, [], "Tests failed:\n%s\n%s" %
            ('-'*70, ("\n%s\n" % ('-'*70)).join(failures)))

    def render(self, test_template, vals):
        context = template.Context(vals[1])
        before_stack_size = len(context.dicts)
        output = test_template.render(context)
        if len(context.dicts) != before_stack_size:
            raise ContextStackException
        return output


class TemplateTagTests(BaseTemplateTagSetup, unittest.TestCase):

    def setUp(self):
        self.patchers = {
            'get_metro': mock.patch('ebpub.metros.allmetros.get_metro'),
            }
        self.mock_get_metro = self.patchers['get_metro'].start()
        self.mock_get_metro.return_value = {'metro_name': 'Test Metro',
                                            'city_name': 'Test City',
                                            'short_name': 'test',
                                            'state': 'XY',
                                            'multiple_cities': False,
                                            }

    def tearDown(self):
        for patcher in self.patchers.values():
            patcher.stop()


    def get_template_tests(self):
        # SYNTAX --
        # 'template_name': ('template contents', 'context dict', 'expected string output' or Exception class)
        #basedir = os.path.dirname(os.path.abspath(__file__))
        from django import template
        tests = {
            #'cycle01': ('{% cycle a %}', {}, template.TemplateSyntaxError),
            'METRO_NAME': ('{% load eb %}{% METRO_NAME %}', {}, self.mock_get_metro()['metro_name']),
            }
        return tests



class TestTemplateTagsWithDatabase(BaseTemplateTagSetup, TestCase):

    fixtures = ('test-schemafilter-views.json',)

    def get_template_tests(self):
        # SYNTAX --
        # 'template_name': ('template contents', 'context dict', 'expected string output' or Exception class)
        #basedir = os.path.dirname(os.path.abspath(__file__))
        from ebpub.db.models import NewsItem
        return {

            'get_newsitem1':
                ('{% load eb %}{% get_newsitem "1" as my_item %}{{my_item.title}}',
                 {}, 'crime title 1'),

            'get_newsitem2':
                ('{% load eb %}{% get_newsitem some_id as my_item %}{{my_item.title}}',
                 {'some_id': 1}, 'crime title 1'),

            'get_newsitem3':
                ('{% load eb %}{% get_newsitem "987654331" as my_item %}{{my_item.title}}',
                 {}, ('', 'INVALID')),

            'get_newsitem4':
                ('{% load eb %}{% get_newsitem %}', {}, template.TemplateSyntaxError),


            'get_newsitem_list_by_attr__error':
                ('{% load eb %}{% get_newsitem_list_by_attribute "crime" %}',
                 {}, template.TemplateSyntaxError),

            'get_newsitem_list_by_attr__slug':
                ('{% load eb %}{% get_newsitem_list_by_attribute "crime" type_id=58 as items %}{% for item in items %}{{ item.title }}. {% endfor %}',
                 {},
                 u'crime title 2. '),

            'get_newsitem_list_by_attr__schema':
                ('{% load eb %}{% get_newsitem_list_by_attribute myschema type_id=58 as items %}{% for item in items %}{{ item.title }}. {% endfor %}',
                 {'myschema': 1},
                 u'crime title 2. ',
                 ),


            'json_lookup_values_for_attribute':
                ('{% load eb %}{% json_lookup_values_for_attribute "crime" "tag" %}',
                 {},
                 u'["Tag 1", "Tag 2", "Tag 3", "Tag 999 UNUSED"]',
                 ),

            'get_locations_for_item__dict':
                ('{% load eb %}{% get_locations_for_item item neighborhoods as locs %}{% for loc in locs %}{{ loc.location_slug }}, {% endfor %}',
                 {'item': {'_item': NewsItem.objects.get(id=1)},},
                 u'hood-1, ',
                 ),

            'get_locations_for_item__newsitem':
                ('{% load eb %}{% get_locations_for_item item neighborhoods nonexistent-loctype-slug as locs %}{% for loc in locs %}{{ loc.location_slug }}, {% endfor %}',
                 {'item': NewsItem.objects.get(id=1),},
                 u'hood-1, ',
                 ),


            'get_locations_for_item__not_enough_args':
                ('{% load eb %}{% get_locations_for_item item as locs %}{% for loc in locs %}{{ loc.location_slug }}, {% endfor %}',
                 {'item': {'_item': NewsItem.objects.get(id=2)}},
                 template.TemplateSyntaxError,
                 ),

            'get_locations_for_item__bad_args':
                ('{% load eb %}{% get_locations_for_item item OUCHIE locs %}{% for loc in locs %}{{ loc.location_slug }}, {% endfor %}',
                 {'item': {'_item': NewsItem.objects.get(id=2)}},
                 template.TemplateSyntaxError,
                 ),

            'get_locations_for_item__not_item':
                ('{% load eb %}{% get_locations_for_item item neighborhoods as locs %}{% for loc in locs %}{{ loc.location_slug }}, {% endfor %}',
                 {'item': 'whoops'}, template.TemplateSyntaxError,
                 ),

            }

########NEW FILE########
__FILENAME__ = test_utils
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.test import TestCase

class TestDoFilterUrl(TestCase):

    fixtures = ('crimes.json',)

    def test_populate_attributes_if_needed(self):

        from ebpub.db.models import NewsItem
        item = NewsItem.objects.get(title='crime title 1')
        ni_list = [item]

        # It's lazy - but just checking length is enough to trigger
        # attribute population.
        self.assert_(len(item.attributes) > 1)

        from ebpub.db.utils import populate_attributes_if_needed
        schema_list = list(set((ni.schema for ni in ni_list)))
        populate_attributes_if_needed(ni_list, schema_list)
        self.assert_(len(item.attributes) > 1)
        self.assertEqual(item.attributes['arrests'], False)
        self.assertEqual(item.attributes['case_number'], 'case number 1')

        # Get another reference to the same NewsItem and verify that
        # prepopulation and laziness give all the same results.
        ni2 = NewsItem.objects.get(title='crime title 1')
        self.failIf(item is ni2)
        ni2.attributes['beat']  # Triggers loading.
        for key, val in item.attributes.items():
            # ... well, mostly the same.
            # populate_attributes_if_needed() dereferences Lookups,
            # which lazy attribute lookup doesn't yet.  This is crazy,
            # but AttributesForTemplate handles both cases.
            from ebpub.db.models import Lookup
            if isinstance(val, Lookup):
                self.assertEqual(val.id, ni2.attributes[key])
            elif isinstance(val, list) and isinstance(val[0], Lookup):
                self.assertEqual(','.join([str(v.id) for v in val]),
                                 ni2.attributes[key])
            else:
                self.assertEqual(val, ni2.attributes[key])

########NEW FILE########
__FILENAME__ = test_views
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Unit tests for db.views.
"""

from django.core import urlresolvers
from django.utils import simplejson
from ebpub.db import models
from ebpub.db.urlresolvers import filter_reverse
from ebpub.db.views import BadAddressException
from ebpub.utils.django_testcase_backports import TestCase
import datetime
import logging
import mock
import urllib


class BaseTestCase(TestCase):

    _logger_keys = ('django.request',)

    def setUp(self):
        # Don't log 404 warnings, we expect a lot of them during these
        # tests.
        self._previous_levels = {}
        for key in self._logger_keys:
            logger = logging.getLogger(key)
            self._previous_levels[key] = logger.getEffectiveLevel()
            logger.setLevel(logging.ERROR)

    def tearDown(self):
        # Restore old log level.
        for key in self._logger_keys:
            logger = logging.getLogger(key)
            logger.setLevel(self._previous_levels[key])

class ViewTestCase(BaseTestCase):
    "Unit tests for views.py."
    fixtures = ('crimes',)

    def test_search__bad_schema(self):
        url = urlresolvers.reverse('ebpub.db.views.search', args=['kaboom'])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_search__no_query(self):
        url = urlresolvers.reverse('ebpub.db.views.search', args=['crime'])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], 'http://testserver/crime/')
        response = self.client.get(url + '?type=alert')
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], 'http://testserver/crime/')

    def test_search(self):
        url = urlresolvers.reverse('ebpub.db.views.search', args=['crime'])
        response = self.client.get(url + '?q=228 S. Wabash Ave.')
        self.assertEqual(response.status_code, 200)
        assert 'location not found' in response.content.lower()
        # TODO: load a fixture with some locations and some news?

    @mock.patch('ebpub.db.views.NewsItem.location_url')
    def test_newsitem_detail(self, mock_location_url):
        mock_location_url.return_value = 'http://X'
        url = urlresolvers.reverse('ebpub.db.views.newsitem_detail',
                                   args=['crime', 1])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'crime title 1')
        self.assertContains(response, 'http://X')

    def test_locationtype_list_redirect(self):
        with self.settings(DEFAULT_LOCTYPE_SLUG='thingies'):
            response = self.client.get('/locations/')
            self.assertEqual(response.status_code, 301)
            self.assertEqual(response['Location'], 'http://testserver/locations/thingies/')

    def test_schema_detail(self):
        response = self.client.get('/crime/')
        self.assertEqual(response.status_code, 200)
        # TODO: more than a smoke test!

    def test_schema_detail__notfound(self):
        response = self.client.get('/nonexistent/')
        self.assertEqual(response.status_code, 404)



class LocationDetailTestCase(BaseTestCase):
    fixtures = ('test-locationdetail-views.json',)

    def test_location_type_detail(self):
        url = urlresolvers.reverse('ebpub-loc-type-detail', args=['neighborhoods'])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        # TODO: more than a smoke test!

    @mock.patch('ebpub.db.views.today')
    def test_location_timeline(self, mock_today):
        mock_today.return_value = datetime.date(2006, 9, 26)
        url = urlresolvers.reverse('ebpub-location-recent',
                                   args=['neighborhoods', 'hood-1'])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.context['newsitem_list']), 1)
        self.assertEqual(response.context['newsitem_list'][0].title, 'crime title 1')
        # We don't get 'crime title 2' in this query because it's in the future.

    def test_location_overview(self):
        url = urlresolvers.reverse('ebpub-location-overview',
                                   args=['neighborhoods', 'hood-1'])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        # TODO: more than a smoke test!

    def test_feed_signup(self):
        url = urlresolvers.reverse('ebpub-feed-signup',
                                   args=['neighborhoods', 'hood-1'])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)


class TestAjaxViews(BaseTestCase):
    fixtures = ('crimes.json',)

    @mock.patch('ebpub.db.views.FilterChain')
    def test_ajax_place_lookup_chart__location(self, mock_chain):
        # Hack so isinstance(mock_chain(), FilterChain) works
        from ebpub.db import schemafilters
        mock_chain.return_value = mock.Mock(spec=schemafilters.FilterChain)
        mock_chain().return_value = mock_chain()
        mock_chain().make_url.return_value = 'foo'
        mock_chain().schema.url.return_value = 'bar'
        mock_chain().apply.return_value = models.NewsItem.objects.all()
        url = urlresolvers.reverse('ajax-place-lookup-chart')
        url += '?sf=13&pid=b:1000.8'
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['total_count'], 3)

    def test_ajax_place_lookup_chart__bad_args(self):
        url = urlresolvers.reverse('ajax-place-lookup-chart')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)
        response = self.client.get(url + '?sf=13')
        self.assertEqual(response.status_code, 404)
        response = self.client.get(url + '?pid=b:1000.8')
        self.assertEqual(response.status_code, 404)


    @mock.patch('ebpub.db.views.today')
    @mock.patch('ebpub.db.views.FilterChain')
    def test_ajax_place_date_chart__location(self, mock_chain, mock_today):
        mock_today.return_value = datetime.date(2006, 11, 10)
        # Hack so isinstance(mock_chain(), FilterChain) works
        from ebpub.db import schemafilters
        mock_chain.return_value = mock.Mock(spec=schemafilters.FilterChain)
        mock_chain().return_value = mock_chain()
        mock_chain().make_url.return_value = 'foo'
        mock_chain().schema.url.return_value = 'bar'
        mock_chain().apply.return_value = models.NewsItem.objects.all()
        url = urlresolvers.reverse('ajax-place-date-chart') + '?s=1&pid=b:1000.8'
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['date_chart']['total_count'], 2)
        self.assertEqual(len(response.context['date_chart']['dates']), 10)
        self.assertEqual(response.context['date_chart']['dates'][-1],
                         {'date': datetime.date(2006, 11, 8), 'count': 2})


    @mock.patch('ebpub.db.views.FilterChain')
    def test_newsitems_geojson__with_pid(self, mock_chain):
        mock_chain().apply.return_value = models.NewsItem.objects.all()
        url = urlresolvers.reverse('ajax-newsitems-geojson')
        url += '?schema=crime&pid=l:2000'
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        items = simplejson.loads(response.content)
        self.assertEqual(items['type'], 'FeatureCollection')
        self.assertEqual(len(items['features']), 3)
        feat = items['features'][0]
        self.assertEqual(feat['type'], 'Feature')
        self.assertEqual(feat['properties']['title'], 'crime title 3')
        self.assertEqual(feat['geometry']['type'], 'Point')
        self.assert_('coordinates' in feat['geometry'])

    @mock.patch('ebpub.db.views.FilterChain')
    def test_newsitems_geojson__with_pid_no_schema(self, mock_chain):
        mock_chain().apply.return_value = models.NewsItem.objects.all()
        url = urlresolvers.reverse('ajax-newsitems-geojson')
        url += '?pid=b:1000.8'
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        items = simplejson.loads(response.content)
        self.assertEqual(items['type'], 'FeatureCollection')
        self.assertEqual(len(items['features']), 3)


class TestSchemaFilterView(BaseTestCase):

    fixtures = ('test-schemafilter-views.json',)

    def test_filter_by_no_args(self):
        url = filter_reverse('crime', [])
        response = self.client.get(url)
        self.assertContains(response, 'choose a location')
        self.assertContains(response, 'id="date-filtergroup"')

    def test_filter_by_location_choices(self):
        url = filter_reverse('crime', [('locations', 'neighborhoods')])
        response = self.client.get(url)
        self.assertContains(response, 'Select Neighborhood')
        self.assertContains(response, 'Hood 1')
        self.assertContains(response, 'Hood 2')

    def test_filter_by_location_detail(self):
        url = filter_reverse('crime', [('locations', 'neighborhoods', 'hood-1')])
        response = self.client.get(url)
        self.assertContains(response, 'Hood 1')
        self.assertNotContains(response, 'Hood 2')
        self.assertContains(response, 'Remove this filter')

    @mock.patch('ebpub.db.schemafilters.logger')
    @mock.patch('ebpub.db.schemafilters.FilterChain.update_from_request')
    def test_filter_by_ambiguous_address(self, mock_from_request, mock_logger):
        # Using Mocks here causes eb_filter to call FilterChain.make_url
        # with additions that it doesn't understand. That's fine for this test,
        # but causes logging spew, hence we mock the logger too.
        url = filter_reverse('crime', [('by-foo', 'bar')]) + '?address=foofoo'
        mock_result = {'address': 'foofoo', 'block': mock.Mock()}
        mock_result['block'].url = '/foofoo/'
        mock_from_request.side_effect = BadAddressException('123 somewhere', 3, 
                                                            [mock_result, mock_result])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.template[0].name, 'db/filter_bad_address.html')

    @mock.patch('ebpub.db.schemafilters.FilterChain.update_from_request')
    @mock.patch('ebpub.db.schemafilters.FilterChain.make_url')
    def test_filter__normalized_redirect(self, mock_make_url, mock_from_request):
        from ebpub.db import schemafilters
        mock_make_url.return_value = '/whee/'
        mock_from_request.return_value = schemafilters.FilterChain()
        url = filter_reverse('crime', [('by-foo', 'bar')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], 'http://testserver/whee/')

    def test_filter__bad_params(self):
        url = filter_reverse('crime', [('by-foo', 'bar')])
        url = url.replace(urllib.quote('='), 'X')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    @mock.patch('ebpub.db.schemafilters.FilterChain.update_from_request')
    def test_filter__bad_date(self, mock_update):
        from ebpub.db.views import BadDateException
        mock_update.side_effect = BadDateException("oh no")
        url = filter_reverse('crime', [('by-date', '2006-11-01', '2006-11-30')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_filter_by_daterange(self):
        url = filter_reverse('crime', [('start_date', '2006-11-01'),
                                       ('end_date', '2006-11-30')])
        response = self.client.get(url)
        self.assertContains(response, 'Clear')
        self.assertNotContains(response, "crime title 1")
        self.assertContains(response, "crime title 2")
        self.assertContains(response, "crime title 3")

    def test_filter_by_pubdate_daterange(self):
        url = filter_reverse('crime', [('start_pubdate', '2006-11-01'),
                                       ('end_pubdate', '2006-11-30')])
        response = self.client.get(url)
        self.assertContains(response, 'Clear')
        self.assertNotContains(response, "crime title 1")
        self.assertContains(response, "crime title 2")
        self.assertContains(response, "crime title 3")

    def test_filter__only_one_date_allowed(self):
        url = filter_reverse('crime',
                             [('by-date', '2006-11-01', '2006-11-30'),
                              ('by-pubdate', '2006-11-01', '2006-11-30')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)


    def test_filter__date_missing(self):
        url = filter_reverse('crime', [('start_date', '')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 302)
        self.assert_(response['location'].endswith('/crime/'))

    def test_filter__invalid_daterange(self):
        url = filter_reverse('crime', [('start_date', 'whoops'),
                                       ('end_date', 'ouchie')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)
        url = filter_reverse('crime', [('start_date', '2006-11-30'),
                                       ('end_date', 'ouchie')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)


    def test_filter_by_day(self):
        url = filter_reverse('crime', [('start_date', '2006-09-26'),
                                       ('end_date', '2006-09-26')])
        response = self.client.get(url)
        self.assertContains(response, "crime title 1")
        self.assertNotContains(response, "crime title 2")
        self.assertNotContains(response, "crime title 3")


    def test_filter__by_date__legacy_redirects(self):
        base = 'http://testserver' + filter_reverse('crime', [])
        expected_to_actual = (
            (filter_reverse('crime', [('by-date', '2011-09-25', '2012-10-31')]),
             base + '?end_date=2012-10-31&start_date=2011-09-25'
             ),
            (filter_reverse('crime', [('by-pubdate', '2011-09-25', '2012-10-31')]),
             base + '?end_pubdate=2012-10-31&start_pubdate=2011-09-25'
             ),

            )
        for expected, actual in expected_to_actual:
            response = self.client.get(expected)
            self.assertEqual(response.status_code, 302)
            self.assertEqual(response['location'], actual)
            response2 = self.client.get(actual)
            self.assertEqual(response2.status_code, 200)



    def test_filter_by_attributes__text(self):
        url = filter_reverse('crime', [('by-status', 'status 9-19')])
        response = self.client.get(url)
        self.assertEqual(len(response.context['newsitem_list']), 1)
        self.assertContains(response, "crime title 1")
        self.assertNotContains(response, "crime title 2")
        self.assertNotContains(response, "crime title 3")


    def test_filter_by_attributes__text__empty(self):
        url = filter_reverse('crime', [('by-status', '')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_filter_by_attributes__bad_attr(self):
        url = filter_reverse('crime', [('by-bogosity', 'anything')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_filter_by_attributes__bad_value(self):
        url = filter_reverse('crime', [('by-status', 'bogus')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertNotContains(response, "crime title ")

    def test_filter_by_street__missing_street(self):
        url = filter_reverse('crime', [('streets', '')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_filter_by_street__missing_block(self):
        url = filter_reverse('crime', [('streets', 'wabash-ave',)])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_filter_by_street__bad_block(self):
        url = filter_reverse('crime', [('streets', 'bogus',)])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

        url = filter_reverse('crime', [('streets', 'bogus street', 'bogus block', '8-blocks')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    @mock.patch('ebpub.streets.models.proper_city')
    def test_filter_by_block__no_radius(self, mock_proper_city):
        # We just fall back to the default radius.
        mock_proper_city.return_value = 'chicago'
        url = filter_reverse('crime', [('streets', 'wabash-ave', '216-299n-s')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 302)
        fixed_url = filter_reverse('crime', [
                ('streets', 'wabash-ave', '216-299n-s', '8-blocks')])
        self.assertEqual(response['location'], 'http://testserver' + fixed_url)

    @mock.patch('ebpub.streets.models.proper_city')
    def test_filter_by_block(self, mock_proper_city):
        mock_proper_city.return_value = 'chicago'
        url = filter_reverse('crime', [('streets', 'wabash-ave', '216-299n-s', '8-blocks')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        # TODO: more assertions

    @mock.patch('ebpub.streets.models.proper_city')
    def test_filter__only_one_location_allowed(self, mock_proper_city):
        mock_proper_city.return_value = 'chicago'
        url = filter_reverse('crime', [('streets', 'wabash-ave', '216-299n-s', '8-blocks'),
                                       ('locations', 'neighborhoods', 'hood-1'),
                                       ])
        response = self.client.get(url)
        url = filter_reverse('crime', [('locations', 'neighborhoods', 'hood-1'),
                                       ('streets', 'wabash-ave', '216-299n-s', '8')
                                       ])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_filter__by_location__not_found(self):
        url = filter_reverse('crime', [('locations', 'anything')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_filter__by_location__empty_location(self):
        url = filter_reverse('crime', [('locations', '')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_filter_by_location(self):
        url = filter_reverse('crime', [('locations', 'neighborhoods', 'hood-1'),])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'Hood 1')

    def test_filter__by_bad_lookup_attr(self):
        url = filter_reverse('crime', [('by-fleezleglop', '214', ),])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_filter__by_lookup_attr(self):
        url = filter_reverse('crime', [('by-beat', 'beat-214', ),])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'Police Beat 214')

    def test_filter__by_lookup__not_specified(self):
        url = filter_reverse('crime', [('by-beat', ''),])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.template[0].name, 'db/filter_lookup_list.html')

    def test_filter__by_m2m_lookup_attr(self):
        url = filter_reverse('crime', [('by-tag', 'tag-1', 'tag-2',),])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'Tag 1')
        self.assertContains(response, 'Tag 2')
        self.assertNotContains(response, 'Tag 999')
        self.assertContains(response, 'crime title 1')
        self.assertContains(response, 'crime title 2')

    def test_filter__by_boolean_attr__true(self):
        url = filter_reverse('crime', [('by-arrests', 'yes',),])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertContains(response, 'crime title 2')
        self.assertNotContains(response, 'crime title 1')
        self.assertNotContains(response, 'crime title 3')

    def test_filter__by_boolean_attr__false(self):
        url = filter_reverse('crime', [('by-arrests', 'no',),])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertNotContains(response, 'crime title 2')
        self.assertContains(response, 'crime title 1')
        self.assertContains(response, 'crime title 3')

    def test_filter__by_boolean__invalid(self):
        url = filter_reverse('crime', [('by-arrests', 'yes', 'no'),])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)
        url = filter_reverse('crime', [('by-arrests', 'maybe'),])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_filter__invalid_argname(self):
        # These are ignored.
        url = filter_reverse('crime', [('bogus-key', 'bogus-value')])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    @mock.patch('ebpub.db.schemafilters.logger')
    @mock.patch('ebpub.db.models.AggregateFieldLookup.objects.filter')
    def test_filter__has_more(self, mock_aggr, mock_logger):
        # Using Mocks here causes eb_filter to call FilterChain.make_url
        # with additions that it doesn't understand. That's fine for this test,
        # but causes logging spew, hence we mock the logger too.
        mock_item = mock.Mock()
        mock_item.return_value = mock_item
        mock_item.alters_data = False
        mock_aggr().select_related().order_by.return_value = [mock_item] * 999
        url = urlresolvers.reverse('ebpub-schema-filter', args=['crime'])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        lookup_list = response.context['lookup_list']
        self.assert_(lookup_list)
        for lookup_info in lookup_list:
            self.assertEqual(lookup_info['has_more'], True)

    def test_filter__pagination__invalid_page(self):
        url = filter_reverse('crime', [('by-status', 'status 9-19')])
        url += '&page=oops'
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_filter__pagination__empty_page(self):
        url = filter_reverse('crime', [('by-status', 'status 9-19')])
        url += '&page=99'
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    @mock.patch('ebpub.db.views.FilterChain', spec=True)
    def test_filter__pagination__has_more(self, mock_chain):
        url = filter_reverse('crime', [('by-status', 'status 9-19')])
        url += '&page=2'
        # We can mock the FilterChain to get a very long list of NewsItems
        # without actually creating them in the db, but it means
        # also mocking a ton of methods used by schema_filter or filter.html.
        # (We can't just patch text_search() anymore because now there's more
        # filtering after that.)
        # TODO: this is pretty brittle. Worth it?
        mock_qs = mock.Mock()
        mock_qs.filter.return_value = mock_qs
        newsitem = models.NewsItem.objects.all()[0]
        mock_qs.order_by.return_value = [newsitem] * 999

        mock_chain.return_value = mock_chain
        mock_chain.apply.return_value = mock_qs
        mock_chain.__contains__ = lambda self, other: False
        mock_chain.get.return_value = None
        mock_chain.validate.return_value = {}
        mock_chain.make_breadcrumbs.return_value = []
        mock_chain.values = []
        mock_chain.lookup_descriptions = []
        mock_chain.make_url.return_value = urllib.unquote(url)  # Avoid redirect.

        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.context['has_next'], True)
        self.assertEqual(response.context['has_previous'], True)

########NEW FILE########
__FILENAME__ = urlresolvers
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.core import urlresolvers
import posixpath
import urllib

def filter_reverse(slug, args):
    """Generate a reverse schema_filter URL.
    """
    for i, a  in enumerate(args):
        if isinstance(a, tuple) or isinstance(a, list):
            # The first item is the arg name, the rest are arg values.
            if len(a) > 1:
                name = a[0]
                values = ','.join(a[1:])
                args[i] = (name, values)
            else:
                # No values.
                # This is allowed eg. for showing a list of available
                # Blocks, or Lookup values, etc.
                args[i] = (a[0], '')
        else:
            raise TypeError("Need a list or tuple, got: %s" % a)

    url = urlresolvers.reverse('ebpub-schema-filter', args=[slug])
    # Normalize duplicate slashes, dots, and the like.
    url = posixpath.normpath(url) + '/'
    if args:
        # Normalize a bit.
        args = sorted(args)
        querystring = urllib.urlencode(args)
        url = '%s?%s' % (url, querystring)
    return url


########NEW FILE########
__FILENAME__ = utils
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.db.models import Q
from django.http import Http404
from django.shortcuts import get_object_or_404
from ebpub.db.models import AttributeDict
from ebpub.db.models import Location
from ebpub.db.models import field_mapping
from ebpub.streets.models import Block
from ebpub.streets.models import City
from ebpub.metros.allmetros import get_metro
from ebpub.constants import BLOCK_RADIUS_CHOICES, BLOCK_RADIUS_DEFAULT
from ebpub.constants import BLOCK_RADIUS_COOKIE_NAME
from ebpub.utils.view_utils import make_pid
from ebpub.savedplaces.models import SavedPlace

from ebpub.utils.dates import today # For backward compatibility

def populate_attributes_if_needed(newsitem_list, schema_list,
                                  get_lookups=True):
    """
    Optimization helper function that takes a list of NewsItems and ensures
    the ni.attributes pseudo-dictionary is populated, for all NewsItems whose
    schemas have uses_attributes_in_list=True. This is accomplished with a
    minimal amount of database queries.

    The values in the NewsItem.attributes pseudo-dictionary are Lookup
    instances in the case of Lookup fields. Otherwise, they're the
    direct values from the Attribute table.

    (Note this is different than accessing NewsItem.attributes without
    having called this function, in which case Lookups are not
    dereferenced automatically.  Client code such as
    AttributesForTemplate should handle both cases - or really .attributes
    should be fixed to be consistent.)

    schema_list should be a list of all Schemas that are referenced in
    newsitem_list.

    Note that the list is edited in place; there is no return value.
    """
    from ebpub.db.models import Attribute, Lookup, SchemaField
    # To accomplish this, we determine which NewsItems in ni_list require
    # attribute prepopulation, and run a single DB query that loads all of the
    # attributes. Another way to do this would be to load all of the attributes
    # when loading the NewsItems in the first place (via a JOIN), but we want
    # to avoid joining such large tables.

    preload_schema_ids = set([s.id for s in schema_list if s.uses_attributes_in_list])
    if not preload_schema_ids:
        return
    preloaded_nis = [ni for ni in newsitem_list if ni.schema_id in preload_schema_ids]
    if not preloaded_nis:
        return
    # fmap is a mapping like:
    # {schema_id: {'fields': [(name, real_name)], 'lookups': [real_name1, real_name2]}}
    fmap = {}
    attribute_columns_to_select = set(['news_item'])

    for sf in SchemaField.objects.filter(schema__id__in=[s.id for s in schema_list]).values('schema', 'name', 'real_name', 'is_lookup'):
        fmap.setdefault(sf['schema'], {'fields': [], 'lookups': []})['fields'].append((sf['name'], sf['real_name']))
        if sf['is_lookup']:
            fmap[sf['schema']]['lookups'].append(sf['real_name'])
        attribute_columns_to_select.add(str(sf['real_name']))

    att_dict = dict([(i['news_item'], i) for i in Attribute.objects.filter(news_item__id__in=[ni.id for ni in preloaded_nis]).values(*list(attribute_columns_to_select))])

    if not fmap:
        return

    # Determine which Lookup objects need to be retrieved.
    lookup_ids = set()
    for ni in preloaded_nis:
        # Fix for #38: not all Schemas have SchemaFields, can be 100% vanilla.
        if not ni.schema_id in fmap:
            continue
        for real_name in fmap[ni.schema_id]['lookups']:
            if ni.id not in att_dict:
                # AFAICT this should not happen, but if you have
                # newsitems created before a schema defined any
                # schemafields, and schemafields were added later,
                # then you might get some NewsItems that don't have a
                # corresponding att_dict result.
                continue
            value = att_dict[ni.id][real_name]
            if ',' in str(value):
                lookup_ids.update(value.split(','))
            else:
                lookup_ids.add(value)

    # Retrieve only the Lookups that are referenced in preloaded_nis.
    lookup_ids = [i for i in lookup_ids if i]
    if lookup_ids:
        lookup_objs = Lookup.objects.in_bulk(lookup_ids)
    else:
        lookup_objs = {}

    # Cache attribute values for each NewsItem in preloaded_nis.
    for ni in preloaded_nis:
        # Fix for #38: Schemas may not have any SchemaFields, and thus
        # the ni will have no attributes, and the schema won't be in
        # fmap, and that's OK.
        if not ni.id in att_dict:
            continue
        if not ni.schema_id in fmap:
            continue

        att = att_dict[ni.id]
        att_values = {}
        for field_name, real_name in fmap[ni.schema_id]['fields']:
            value = att[real_name]
            if real_name in fmap[ni.schema_id]['lookups']:
                if value is None:
                    value = u''
                    continue
                if real_name.startswith('int'):
                    value = lookup_objs[value]
                else: # Many-to-many lookups are comma-separated strings.
                    value = [lookup_objs[int(i)] for i in value.split(',') if i]
            att_values[field_name] = value
        select_dict = field_mapping([ni.schema_id]).get(ni.schema_id, {})
        ni._attributes_cache = AttributeDict(ni.id, ni.schema_id, select_dict)
        ni._attributes_cache.cached = True
        ni._attributes_cache.update(att_values)

def populate_schema(newsitem_list, schema):
    for ni in newsitem_list:
        # TODO: This relies on undocumented Django APIs -- the "_schema_cache" name.
        ni._schema_cache = schema


def get_locations_near_place(place, block_radius=3):
    nearby = Location.objects.filter(location_type__is_significant=True)
    nearby = nearby.select_related()
    if isinstance(place, Location):
        nearby = nearby.exclude(id=place.id)
    # If the location is a point, or very small, we want to expand
    # the area we care about via make_search_buffer().  But if
    # it's not, we probably want the extent of its geometry.
    # Let's just take the union to cover both cases.
    search_buf = make_search_buffer(place.location.centroid, block_radius)
    search_buf = search_buf.union(place.location)
    nearby = nearby.filter(location__bboverlaps=search_buf)
    nearby = nearby.order_by('location_type__id', 'name')
    return nearby, search_buf

def get_place_info_for_request(request, *args, **kwargs):
    """
    A utility function that abstracts getting some commonly used
    location-related information: a place (Location or Block), its type,
    a bbox, a list of nearby locations, etc.
    """
    info = dict(bbox=None,
                nearby_locations=[],
                location=None,
                place_type=None,
                is_block=False,
                block_radius=None,
                is_saved=False,
                pid='',
                cookies_to_set={},
                )

    if 'place' in kwargs:
        info['place'] = place = kwargs['place']
    else:
        info['place'] = place = url_to_place(*args, **kwargs)

    if isinstance(place, Block):
        info['is_block'] = True
        xy_radius, block_radius, cookies_to_set = block_radius_value(request)
        block_radius = kwargs.get('block_radius') or block_radius
        nearby, search_buf = get_locations_near_place(place, block_radius)
        info['nearby_locations'] = nearby
        info['bbox'] = search_buf.extent
        saved_place_lookup = {'block_center': place.geom.centroid}
        info['block_radius'] = block_radius
        info['cookies_to_set'] = cookies_to_set
        info['pid'] = make_pid(place, block_radius)
        info['place_type'] = 'block'
    else:
        info['location'] = place
        info['place_type'] = place.location_type.slug
        saved_place_lookup = {'location__id': place.id}
        info['pid'] = make_pid(place)
        if place.location is None:
            # No geometry.
            info['bbox'] = get_metro()['extent']
        else:
            nearby, search_buf = get_locations_near_place(place)
            info['bbox'] = search_buf.extent
            info['nearby_locations'] = nearby

    # Determine whether this is a saved place.
    if not request.user.is_anonymous():
        saved_place_lookup['user_id'] = request.user.id # TODO: request.user.id should not do a DB lookup
        info['is_saved'] = SavedPlace.objects.filter(**saved_place_lookup).count()

    return info

def url_to_place(*args, **kwargs):
    # Given args and kwargs captured from the URL, returns the place.
    # This relies on "place_type" being provided in the URLpattern.
    parse_func = kwargs['place_type'] == 'block' and url_to_block or url_to_location
    return parse_func(*args)

def url_to_block(city_slug, street_slug, from_num, to_num, predir, postdir):
    params = {
        'street_slug': street_slug,
        'predir': (predir and predir.upper() or ''),
        'postdir': (postdir and postdir.upper() or ''),
        'from_num': int(from_num),
        'to_num': int(to_num),
    }
    if city_slug:
        city = City.from_slug(city_slug).norm_name
        city_filter = Q(left_city=city) | Q(right_city=city)
    else:
        city_filter = Q()
    b_list = list(Block.objects.filter(city_filter, **params))

    if not b_list:
        raise Http404()

    return b_list[0]

def url_to_location(type_slug, slug):
    return get_object_or_404(Location.objects.select_related(), location_type__slug=type_slug, slug=slug)


def block_radius_value(request):
    """
    Get block radius from either query string or cookie, or default.
    """
    # Returns a tuple of (xy_radius, block_radius, cookies_to_set).
    if 'radius' in request.GET and request.GET['radius'] in BLOCK_RADIUS_CHOICES:
        block_radius = request.GET['radius']
        cookies_to_set = {BLOCK_RADIUS_COOKIE_NAME: block_radius}
    else:
        if request.COOKIES.get(BLOCK_RADIUS_COOKIE_NAME) in BLOCK_RADIUS_CHOICES:
            block_radius = request.COOKIES[BLOCK_RADIUS_COOKIE_NAME]
        else:
            block_radius = BLOCK_RADIUS_DEFAULT
        cookies_to_set = {}
    return BLOCK_RADIUS_CHOICES[block_radius], block_radius, cookies_to_set

def make_search_buffer(geom, block_radius):
    """
    Returns a polygon of a buffer around a block's centroid.

    ``geom`` is the centroid of the block, and
    ``block_radius`` is the number of blocks.
    """
    return geom.buffer(BLOCK_RADIUS_CHOICES[str(block_radius)]).envelope

########NEW FILE########
__FILENAME__ = views
#   Copyright 2007,2008,2009,2011,2012 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from django.contrib.gis.shortcuts import render_to_kml
from django.core.cache import cache
from django.core.urlresolvers import reverse
from django.db.models import Q
from django.http import Http404
from django.http import HttpResponse
from django.http import HttpResponseRedirect, HttpResponsePermanentRedirect
from django.shortcuts import render_to_response, get_object_or_404
from django.utils import simplejson
from django.utils.cache import patch_response_headers
from django.utils.datastructures import SortedDict
from django.views.decorators.cache import cache_page
from django.views.decorators.csrf import csrf_protect
from ebpub.constants import HIDE_ADS_COOKIE_NAME
from ebpub.db import breadcrumbs
from ebpub.db import constants
from ebpub.db.models import AggregateDay, AggregateLocation, AggregateFieldLookup
from ebpub.db.models import NewsItem, Schema, SchemaField, LocationType, Location, SearchSpecialCase
from ebpub.db.schemafilters import FilterError
from ebpub.db.schemafilters import FilterChain
from ebpub.db.schemafilters import BadAddressException
from ebpub.db.schemafilters import BadDateException

from ebpub.db.utils import populate_attributes_if_needed, populate_schema
from ebpub.db.utils import url_to_place
from ebpub.db.utils import get_place_info_for_request
from ebpub import geocoder
from ebpub.geocoder.base import full_geocode
from ebpub.geocoder.parser.parsing import normalize
from ebpub.metros.allmetros import get_metro
from ebpub.openblockapi.views import api_items_geojson
from ebpub.preferences.models import HiddenSchema
from ebpub.streets.models import Street, City, Block, Intersection
from ebpub.utils.dates import daterange, today
from ebpub.utils.view_utils import eb_render
from ebpub.utils.view_utils import get_schema_manager
from ebpub.utils.view_utils import paginate

import datetime
import hashlib
import logging
import operator
import re

logger = logging.getLogger('ebpub.db.views')

################################
# HELPER FUNCTIONS (NOT VIEWS) #
################################


def get_date_chart_agg_model(schemas, start_date, end_date, agg_model, kwargs=None):
    """start_date and end_date are *inclusive*.
    """
    kwargs = kwargs or {}
    counts = {}
    for agg in agg_model.objects.filter(schema__id__in=[s.id for s in schemas], date_part__range=(start_date, end_date), **kwargs):
        counts.setdefault(agg.schema_id, {})[agg.date_part] = agg.total
    return get_date_chart(schemas, start_date, end_date, counts)

def get_date_chart(schemas, start_date, end_date, counts):
    """
    Returns a list that's used to display a date chart for the given
    schemas. Note that start_date and end_date should be datetime.date objects,
    NOT datetime.datetime objects, and they are *inclusive*,
    i.e. the resulting chart will include both start_date and end_date.

    counts should be a nested dictionary: {schema_id: {date: count}}

    The list will be in order given by the `schemas` parameter.
    """
    result = []
    for schema in schemas:
        if schema.id not in counts:
            result.append({
                'schema': schema,
                'dates': [{'date': d, 'count': 0} for d in daterange(start_date, end_date)],
                'max_count': 0,
                'total_count': 0,
                'latest_date': None,
            })
        else:
            dates = [{'date': d, 'count': counts[schema.id].get(d, 0)} for d in daterange(start_date, end_date)]
            nonzero_dates = [d['date'] for d in dates if d['count']]
            if nonzero_dates:
                latest_date = max(nonzero_dates)
            else:
                latest_date = None
            result.append({
                'schema': schema,
                'dates': dates,
                'max_count': max(d['count'] for d in dates),
                'total_count': sum(d['count'] for d in dates),
                'latest_date': latest_date,
            })
    return result


def block_bbox(block, radius):
    """
    Given a :py:class:`ebpub.streets.models.Block`, and an integer ``radius``,
    returns a geometry representing a bounding box around the block.

    Assumes `block`` has ``wkt`` attribute.
    """
    try:
        from osgeo import ogr
    except ImportError:
        import ogr
    env = ogr.CreateGeometryFromWkt(block.wkt).Buffer(radius).GetEnvelope()
    return (env[0], env[2], env[1], env[3])




##############
# AJAX VIEWS #
##############


def ajax_place_lookup_chart(request):
    """
    Returns HTML fragment -- expects request.GET['pid'] and request.GET['sf'] (a SchemaField ID).
    """
    allowed_schemas = get_schema_manager(request).allowed_schema_ids()
    try:
        sf = SchemaField.objects.select_related().get(id=int(request.GET['sf']),
                                                      schema__id__in=allowed_schemas)
    except (KeyError, ValueError, SchemaField.DoesNotExist):
        raise Http404('Invalid SchemaField')
    filters = FilterChain(request=request, schema=sf.schema)
    filters.add_by_place_id(request.GET.get('pid', ''))
    qs = filters.apply()
    total_count = qs.count()
    top_values = qs.top_lookups(sf, 10)
    return render_to_response('db/snippets/lookup_chart.html', {
        'lookup': {'sf': sf, 'top_values': top_values},
        'total_count': total_count,
        'schema': sf.schema,
        'filters': filters,
    })

def ajax_place_date_chart(request):
    """
    Returns HTML fragment containing a chart of how many news items
    were added for each day over a short period (length defined by
    constants.DAYS_SHORT_AGGREGATE_TIMEDELTA).

    Expects request.GET['pid'] and request.GET['s'] (a Schema ID).
    """
    manager = get_schema_manager(request)
    try:
        schema = manager.get(id=int(request.GET['s']))
    except (KeyError, ValueError, Schema.DoesNotExist):
        raise Http404('Invalid Schema')
    filters = FilterChain(request=request, schema=schema)
    filters.add_by_place_id(request.GET.get('pid', ''))
    qs = filters.apply()

    # These charts are used on eg. the place overview page; there,
    # they should be smaller than the ones on the schema_detail view;
    # we don't have room for a full 30 days.
    date_span = constants.DAYS_SHORT_AGGREGATE_TIMEDELTA
    if schema.is_event:
        # Soonest span that includes some.
        try:
            qs = qs.filter(item_date__gte=today()).order_by('item_date', 'pub_date', 'id')
            first_item = qs.values('item_date')[0]
            start_date = first_item['item_date']
        except IndexError:  # No matching items.
            start_date = today()
        end_date = today() + date_span
    else:
        # Most recent span that includes some.
        try:
            qs = qs.filter(item_date__lte=today()).order_by('-item_date', '-pub_date', '-id')
            last_item = qs.values('item_date')[0]
            end_date = last_item['item_date']
        except IndexError:  # No matching items.
            end_date = today()
        start_date = end_date - date_span

    filters.add('date', start_date, end_date)
    counts = filters.apply().date_counts()
    date_chart = get_date_chart([schema], start_date, end_date, {schema.id: counts})[0]
    return render_to_response('db/snippets/date_chart.html', {
        'schema': schema,
        'date_chart': date_chart,
        'filters': filters,
    })


def newsitems_geojson(request):
    """Get a list of newsitems, optionally filtered for one place ID
    and/or one schema slug.

    Response is a geojson string.
    """
    # Note: can't use @cache_page here because that ignores all requests
    # with query parameters (in FetchFromCacheMiddleware.process_request).
    # So, we'll use the low-level cache API.

    # Copy-pasted code from ajax_place_newsitems.  Refactoring target:
    # Seems like there are a number of similar code blocks in
    # ebpub.db.views?

    pid = request.GET.get('pid', '')
    schema = request.GET.get('schema', None)
    if schema is not None:
        schema = get_object_or_404(Schema, slug=schema)

    nid = request.GET.get('newsitem', '')

    newsitem_qs = NewsItem.objects.by_request(request)
    if nid:
        newsitem_qs = newsitem_qs.filter(id=nid)
    else:
        filters = FilterChain(request=request, queryset=newsitem_qs, schema=schema)
        if pid:
            filters.add_by_place_id(pid)
        else:
            # Whole city!
            pass

        # More copy/paste from ebpub.db.views...
        # As an optimization, limit the NewsItems to those published in the
        # last few days.
        filter_sf_dict = _get_filter_schemafields(schema)
        filters.update_from_request(filter_sf_dict)
        if not filters.has_key('date'):
            end_date = today()
            start_date = end_date - datetime.timedelta(days=settings.DEFAULT_DAYS)
            filters.add('date', start_date, end_date)
        newsitem_qs = filters.apply()
        newsitem_qs = newsitem_qs.by_request(request)

        # Put a hard limit on the number of newsitems, and throw away
        # older items.
        newsitem_qs = newsitem_qs.select_related().order_by('-item_date', '-pub_date', '-id')
        newsitem_qs = newsitem_qs[:constants.NUM_NEWS_ITEMS_PLACE_DETAIL]

    # Done preparing the query; cache based on the raw SQL
    # to be sure we capture everything that matters.
    cache_seconds = 60 * 5
    cache_key = 'newsitem_geojson:' + _make_cache_key_from_queryset(newsitem_qs)
    output = cache.get(cache_key, None)
    if output is None:
        newsitem_list = list(newsitem_qs)
        output = api_items_geojson(newsitem_list)
        cache.set(cache_key, output, cache_seconds)

    response = HttpResponse(output, mimetype="application/javascript")
    patch_response_headers(response, cache_timeout=60 * 5)
    return response

def _make_cache_key_from_queryset(qs):
    cache_key = 'query:'
    cache_key += hashlib.md5(str(qs.query)).hexdigest()
    return cache_key

@cache_page(60 * 60)
def place_kml(request, *args, **kwargs):
    place = url_to_place(*args, **kwargs)
    return render_to_kml('place.kml', {'place': place})


#########
# VIEWS #
#########

def homepage(request):
    """Front page of the default OpenBlock theme.
    """
    context = _homepage_context(request)
    return eb_render(request, 'homepage.html', context)

def _homepage_context(request):
    # Factored out to make easier to override or wrap.
    end_date = today()
    start_date = end_date - datetime.timedelta(days=settings.DEFAULT_DAYS)
    end_date += datetime.timedelta(days=1)

    manager = get_schema_manager(request)
    sparkline_schemas = list(manager.filter(allow_charting=True, is_special_report=False))

    # Order by slug to ensure case-insensitive ordering. (Kind of hackish.)
    lt_list = LocationType.objects.filter(is_significant=True).order_by('slug').extra(select={'count': 'select count(*) from db_location where is_public=True and location_type_id=db_locationtype.id'})
    street_count = Street.objects.count()
    more_schemas = manager.filter(allow_charting=False).order_by('name')

    # Get schemas that are restricted / allowed for this user.  Note,
    # in some use cases you might want to override these so that
    # eg. allowed_schema_ids includes only ids that are always visible
    # to all users, so the template can display restricted schemas but
    # mark them specially eg. with CSS classes.  But by default we
    # don't have anything on which to make such a distinction,
    # so these mean allowed & restricted *for the current user*.
    allowed_schema_ids = get_schema_manager(request).allowed_schema_ids()
    restricted_schemas = Schema.objects.exclude(id__in=allowed_schema_ids)

    # Get the public records.
    date_charts = get_date_chart_agg_model(sparkline_schemas, start_date, end_date, AggregateDay)
    empty_date_charts, non_empty_date_charts = [], []
    for chart in date_charts:
        if chart['total_count']:
            non_empty_date_charts.append(chart)
        else:
            empty_date_charts.append(chart)
    def _date_chart_sort_func(a, b):
        return cmp(
            # Higher importance first, higher count first, lower name first.
            (b['schema'].importance, b['total_count'], a['schema'].plural_name),
            (a['schema'].importance, a['total_count'], b['schema'].plural_name))

    non_empty_date_charts.sort(_date_chart_sort_func)
    empty_date_charts.sort(_date_chart_sort_func)
    return {
        'location_type_list': lt_list,
        'street_count': street_count,
        'more_schemas': more_schemas,
        'non_empty_date_charts': non_empty_date_charts,
        'empty_date_charts': empty_date_charts,
        'num_days': settings.DEFAULT_DAYS,
        'default_lon': settings.DEFAULT_MAP_CENTER_LON,
        'default_lat': settings.DEFAULT_MAP_CENTER_LAT,
        'default_zoom': settings.DEFAULT_MAP_ZOOM,
        'bodyclass': 'homepage',
        'breadcrumbs': breadcrumbs.home({}),
        'map_configuration': _preconfigured_map({}),
        'restricted_schemas': restricted_schemas,
        'allowed_schema_ids': allowed_schema_ids,
        }


def search(request, schema_slug=''):
    "Performs a location search and redirects to the address/xy page."
    # Check whether a schema was provided.
    if schema_slug:
        try:
            schema = get_schema_manager(request).get(slug=schema_slug)
        except Schema.DoesNotExist:
            raise Http404('Schema does not exist')
        url_prefix = schema.url()[:-1]
    else:
        schema = None
        url_prefix = ''

    # Get the query.
    q = request.GET.get('q', '').strip()
    if not q:
        return HttpResponseRedirect(url_prefix + '/') # TODO: Do something better than redirecting.

    # For /search/?type=alert, we redirect results to the alert page, not the
    # place page.
    if request.GET.get('type', '') == 'alert':
        url_method = 'alert_url'
    else:
        url_method = 'url'

    # Try to geocode it using full_geocode().
    try:
        result = full_geocode(q, search_places=True)
    except:
        logger.debug('Unhandled exception from full_geocode:',
                     exc_info=True)
    else:
        if result['ambiguous']:
            if result['type'] == 'block':
                streets = []
                street_blocks = {}
                for block in result['result']:
                    street_name = block.street_pretty_name
                    if street_name not in streets:
                        streets.append(street_name)
                        street_blocks[street_name] = []
                    street_blocks[street_name].append(block)

                choices = [{'name': s, 'blocks': street_blocks[s]} for s in streets]
                return eb_render(request, 'db/search_invalid_block.html', {
                    'query': q,
                    'choices': choices,
                })
            else:
                # TODO: does this work with Places?
                return eb_render(request, 'db/did_you_mean.html', {'query': q, 'choices': result['result']})
        elif result['type'] == 'location':
            return HttpResponseRedirect(url_prefix + getattr(result['result'], url_method)())
        elif result['type'] == 'place':
            block, distance = geocoder.reverse.reverse_geocode(result['result'].location)
            return HttpResponseRedirect(url_prefix + getattr(block, url_method)())

        elif result['type'] == 'address':
            # Block
            if result['result']['block']:
                return HttpResponseRedirect(url_prefix + getattr(result['result']['block'], url_method)())
            # Intersection
            try:
                intersection = Intersection.objects.get(id=result['result']['intersection_id'])
            except Intersection.DoesNotExist:
                pass
            else:
                return HttpResponseRedirect(url_prefix + getattr(intersection, url_method)())

    # Failing the geocoding, look in the special-case table.
    try:
        special_case = SearchSpecialCase.objects.get(query=normalize(q))
    except SearchSpecialCase.DoesNotExist:
        pass
    else:
        if special_case.redirect_to:
            return HttpResponseRedirect(special_case.redirect_to)
        else:
            return eb_render(request, 'db/search_special_case.html', {'query': q, 'special_case': special_case})

    # Failing that, display a list of ZIP codes if this looks like a ZIP.
    if re.search(r'^\s*\d{5}(?:-\d{4})?\s*$', q):
        z_list = Location.objects.filter(location_type__slug='zipcodes', is_public=True).select_related().order_by('name')
        if z_list:
            return eb_render(request, 'db/search_error_zip_list.html', {'query': q, 'zipcode_list': z_list})

    # Failing all of that, display the search error page.
    lt_list = LocationType.objects.filter(is_significant=True).order_by('name')
    return eb_render(request, 'db/search_error.html', {'query': q, 'locationtype_list': lt_list})

@csrf_protect
def newsitem_detail(request, schema_slug, newsitem_id):
    """
    Page displaying a single NewsItem.
    """
    ni = get_object_or_404(NewsItem.objects.by_request(request).select_related(),
                           id=newsitem_id,
                           schema__slug=schema_slug)

    if not ni.schema.has_newsitem_detail:
        # Don't show detail pages.
        if ni.url:
            return HttpResponsePermanentRedirect(ni.url)
        else:
            # We have nothing to show the user; ticket #110.
            raise Http404("This news item needs an external URL (because schema.has_newsitem_detail is False), and it doesn't have one")

    atts = ni.attributes_for_template()

    has_location = ni.location is not None

    if has_location:
        locations_within = Location.objects.select_related().filter(
            newsitemlocation__news_item__id=ni.id)
        center_x = ni.location.centroid.x
        center_y = ni.location.centroid.y
    else:
        locations_within = ()
        center_x = settings.DEFAULT_MAP_CENTER_LON
        center_y = settings.DEFAULT_MAP_CENTER_LAT

    hide_ads = (request.COOKIES.get(HIDE_ADS_COOKIE_NAME) == 't')
    templates_to_try = ('db/newsitem_detail/%s.html' % ni.schema.slug, 'db/newsitem_detail.html')

    # Try to find a usable URL to link to from the location name.
    # TODO: move this logic to NewsItem.location_url()
    location_url = ni.location_url()
    if not location_url:
        # There might be any number of intersecting locations_within,
        # and we don't have any criteria for deciding which if any
        # best corresponds to ni.location_name; but we can try
        # a few other fallbacks.
        if ni.location:
            # Try reverse-geocoding and see if we get a block.
            try:
                block, distance = geocoder.reverse.reverse_geocode(ni.location)
                location_url = block.url()
            except geocoder.reverse.ReverseGeocodeError:
                logger.error(
                    "%r (id %d) has neither a location_url, nor a block,"
                    " nor a reverse-geocodable location" % (ni, ni.id))
                pass

    from ebpub.neighbornews.utils import user_can_edit
    from easy_thumbnails.files import get_thumbnailer
    size = getattr(settings, 'UPLOADED_IMAGE_DIMENSIONS', (640, 480))
    images = [get_thumbnailer(i.image).get_thumbnail({'size': size})
              for i in ni.newsitemimage_set.all()]
    if 'ebpub.moderation' in settings.INSTALLED_APPS:
        allow_flagging = ni.schema.allow_flagging
    else:
        allow_flagging = False
    context = {
        'newsitem': ni,
        'attribute_list': [att for att in atts if att.sf.display],
        'attribute_dict': dict((att.sf.name, att) for att in atts),
        'has_location': has_location,
        'locations_within': locations_within,
        'location_url': location_url,
        'hide_ads': hide_ads,
        'map_center_x': center_x,
        'map_center_y': center_y,
        'bodyclass': 'newsitem-detail',
        'bodyid': schema_slug,
        'can_edit': user_can_edit(request, ni),
        'allow_flagging': allow_flagging,
        'images': images,
    }
    context['breadcrumbs'] = breadcrumbs.newsitem_detail(context)
    context['map_configuration'] = _preconfigured_map(context)
    return eb_render(request, templates_to_try, context)


def schema_list(request):
    allowed_schemas = get_schema_manager(request).all()
    schema_list = allowed_schemas.select_related().filter(is_special_report=False).order_by('plural_name')
    schemafield_list = list(SchemaField.objects.filter(is_filter=True).order_by('display_order'))
    browsable_locationtype_list = LocationType.objects.filter(is_significant=True)
    # Populate s_list, which contains a schema and schemafield list for each schema.
    s_list = []
    for s in schema_list:
        s_list.append({
            'schema': s,
            'schemafield_list': [sf for sf in schemafield_list if sf.schema_id == s.id],
        })

    return eb_render(request, 'db/schema_list.html', {
        'schema_list': s_list,
        'browsable_locationtype_list': browsable_locationtype_list,
        'bodyclass': 'schema-list',
    })

def schema_detail(request, slug):
    s = get_object_or_404(get_schema_manager(request), slug=slug)
    if s.is_special_report:
        return schema_detail_special_report(request, s)

    location_type_list = LocationType.objects.filter(is_significant=True).order_by('slug')
    if s.allow_charting:
        # For the date range, the end_date is the last non-future date
        # with at least one NewsItem.
        try:
            end_date = NewsItem.objects.filter(schema__id=s.id, item_date__lte=today()).values_list('item_date', flat=True).order_by('-item_date')[0]
        except IndexError:
            latest_dates = ()
            date_chart = {}
            start_date = end_date = None
        else:
            start_date = end_date - constants.DAYS_AGGREGATE_TIMEDELTA
            date_chart = get_date_chart_agg_model([s], start_date, end_date, AggregateDay)[0]
            latest_dates = [date['date'] for date in date_chart['dates'] if date['count']]

        # Populate schemafield_list and lookup_list.
        schemafield_list = list(s.schemafield_set.filter(is_filter=True).order_by('display_order'))
        LOOKUP_MAX_DISPLAYED = 12
        LOOKUP_BUFFER = 4
        lookup_list = []
        for sf in schemafield_list:
            if not (sf.is_charted and sf.is_lookup):
                continue
            lookup_list.append(_get_lookup_list_for_sf(sf, LOOKUP_MAX_DISPLAYED, LOOKUP_BUFFER))

        location_chartfield_list = []

        # Populate location_chartfield_list.
        for lt in location_type_list:
            # Collect the locations in the location_type here so we don't have
            # to query them again in the select_related() below.
            locations = dict([(loc.id, loc) for loc in lt.location_set.iterator()])

            ni_totals = AggregateLocation.objects.filter(
                schema__id=s.id,
                location_type__id=lt.id,
                location__is_public=True).select_related('location').order_by('-total')

            if ni_totals:  # This runs the query.
                known_count = reduce(operator.add, (n.total for n in ni_totals))
                total_count = date_chart.get('total_count', 0)
                unknown_count = max(0, total_count - known_count)
                location_chartfield_list.append({'location_type': lt, 'locations': ni_totals[:9], 'unknown': unknown_count})
        ni_list = ()
    else:
        date_chart = {}
        latest_dates = schemafield_list = lookup_list = location_chartfield_list = ()
        ni_list = list(NewsItem.objects.filter(schema__id=s.id).order_by('-item_date', '-id')[:30])
        populate_schema(ni_list, s)
        populate_attributes_if_needed(ni_list, [s])

    textsearch_sf_list = list(SchemaField.objects.filter(schema__id=s.id, is_searchable=True).order_by('display_order'))
    boolean_lookup_list = [sf for sf in SchemaField.objects.filter(schema__id=s.id, is_filter=True, is_lookup=False).order_by('display_order') if sf.is_type('bool')]

    templates_to_try = ('db/schema_detail/%s.html' % s.slug, 'db/schema_detail.html')


    context = {
        'schema': s,
        'schemafield_list': schemafield_list,
        'location_type_list': location_type_list,
        'date_chart': date_chart,
        'lookup_list': lookup_list,
        'location_chartfield_list': location_chartfield_list,
        'boolean_lookup_list': boolean_lookup_list,
        'search_list': textsearch_sf_list,
        'newsitem_list': ni_list,
        'latest_dates': latest_dates[-3:],
        'start_date': s.min_date,
        'end_date': today(),
        'bodyclass': 'schema-detail',
        'bodyid': slug,
        'filters': FilterChain(schema=s),
    }
    context['breadcrumbs'] = breadcrumbs.schema_detail(context)
    return eb_render(request, templates_to_try, context)

def schema_detail_special_report(request, schema):
    """
    For display of schemas where is_special_report=True.
    """
    ni_list = NewsItem.objects.filter(schema__id=schema.id)
    populate_schema(ni_list, schema)
    populate_attributes_if_needed(ni_list, [schema])

    if schema.allow_charting:
        browsable_locationtype_list = LocationType.objects.filter(is_significant=True)
        schemafield_list = list(schema.schemafield_set.filter(is_filter=True).order_by('display_order'))
    else:
        browsable_locationtype_list = []
        schemafield_list = []

    templates_to_try = ('db/schema_detail/%s.html' % schema.slug, 'db/schema_detail_special_report.html')
    return eb_render(request, templates_to_try, {
        'schema': schema,
        'newsitem_list': ni_list,
        'browsable_locationtype_list': browsable_locationtype_list,
        'schemafield_list': schemafield_list,
        'bodyclass': 'schema-detail-special-report',
        'bodyid': schema.slug,
    })


def _get_filter_schemafields(schema):
    """Given a Schema, get a sorted mapping of schemafield names to
    SchemaField instances.

    Only SchemaFields that have is_searchable or is_filter enabled
    will be returned.
    """
    filter_sf_list = list(SchemaField.objects.filter(schema=schema, is_filter=True).order_by('display_order'))
    textsearch_sf_list = list(SchemaField.objects.filter(schema=schema, is_searchable=True).order_by('display_order'))
    # Use SortedDict to preserve the display_order.
    filter_sf_dict = SortedDict([(sf.name, sf) for sf in filter_sf_list] + [(sf.name, sf) for sf in textsearch_sf_list])
    return filter_sf_dict


def schema_filter_geojson(request, slug):
    s = get_object_or_404(get_schema_manager(request), slug=slug, is_special_report=False)
    # Determine what filters to apply, based on path and/or query string.
    filterchain = FilterChain(request=request, schema=s)
    filter_sf_dict = _get_filter_schemafields(s)
    try:
        filterchain.update_from_request(filter_sf_dict)
        filters_need_more = filterchain.validate()
    except FilterError:
        return HttpResponse(status=400)
    except BadAddressException:
        return HttpResponse(status=400)
    except BadDateException:
        return HttpResponse(status=400)

    if filters_need_more:
        return HttpResponse(status=400)


    # If there isn't a date filter, add some dates to the queryset,
    # but NOT to the filterchain, because need to give the user the
    # option of choosing dates.
    qs, start_date, end_date = _default_date_filtering(filterchain)

    if s.is_event:
        qs = qs.order_by('item_date', 'id')
    else:
        qs = qs.order_by('-item_date', '-id')

    try:
        page = int(request.GET.get('page', 1))
    except ValueError:
        return HttpResponse('Invalid Page %r' % page, status=400)
    paginated_info = paginate(qs, page=page)
    ni_list = paginated_info[0]  # Don't need anything else.
    # Pagination not captured by queryset, so we hack that into the
    # cache key.
    cache_key = 'schema_filter_geojson:page-%d:' % page
    cache_key += _make_cache_key_from_queryset(qs)

    cache_seconds = 60 * 5
    output = cache.get(cache_key, None)
    if output is None:
        output = api_items_geojson(ni_list)
        cache.set(cache_key, output, cache_seconds)

    response = HttpResponse(output, mimetype="application/javascript")
    patch_response_headers(response, cache_timeout=60 * 5)
    return response


def _get_lookup_list_for_sf(sf, top_value_count=100, orphan_buffer=4):
    """
    Given a schemafield where is_lookup = True, make a dictionary
    that contains the ``top_values`` list, the ``total_value_count`` int,
    and (if total count is more than the number of top values) a boolean
    ``has_more``.  And the schemafield itself.

    Useful for creating UI elements where you want to show only the
    most common values of a Lookup, eg. tags, and maybe link to a page
    that has the rist.
    """
    all_values = AggregateFieldLookup.objects.filter(schema_field__id=sf.id).select_related('lookup')
    top_values = all_values.order_by('-total')[:top_value_count+orphan_buffer]
    top_values = list(top_values)
    if len(top_values) < top_value_count + orphan_buffer:
        total_value_count = len(top_values)
        has_more = False
    elif len(top_values) == top_value_count + orphan_buffer:
        top_values = top_values[:top_value_count]
        total_value_count = all_values.count()
        has_more = True
    else:
        raise Exception("impossible to get here")

    return({'sf': sf,
            'top_values': top_values,
            'has_more': has_more,
            'total_value_count': total_value_count,
            })


def schema_filter(request, slug):
    """
    List NewsItems for one schema, filtered by various criteria in the
    query params (eg. date, location, or values of SchemaFields).
    """
    s = get_object_or_404(get_schema_manager(request), slug=slug, is_special_report=False)
    context = {
        'bodyclass': 'schema-filter',
        'bodyid': s.slug,
        'schema': s,
        }
    # Breadcrumbs. We can assign this early because it's a generator,
    # so it'll get the full context no matter what.
    context['breadcrumbs'] = breadcrumbs.schema_filter(context)

    filter_sf_dict = _get_filter_schemafields(s)

    # Determine what filters to apply, based on path and/or query string.
    filterchain = FilterChain(request=request, context=context, schema=s)

    context['filters'] = filterchain
    try:
        filterchain.update_from_request(filter_sf_dict)
        filters_need_more = filterchain.validate()
    except FilterError, e:
        if getattr(e, 'url', None) is not None:
            return HttpResponseRedirect(e.url)
        raise Http404(str(e))
    except BadAddressException, e:
        context.update({
                'address_choices': e.address_choices,
                'address': e.address,
                'radius': e.block_radius,
                'radius_slug': e.radius_slug,
                })
        return eb_render(request, 'db/filter_bad_address.html', context)
    except BadDateException, e:
        raise Http404('<h1>%s</h1>' % str(e))

    if filters_need_more:
        # Show a page to select the unspecified value.
        context.update(filters_need_more)
        return eb_render(request, 'db/filter_lookup_list.html', context)

    # Normalize the URL, and redirect if we're not already there.
    new_url = filterchain.make_url()
    if new_url != request.get_full_path():
        return HttpResponseRedirect(new_url)

    # Make the queryset, with default date filtering if needed.
    qs, start_date, end_date = _default_date_filtering(filterchain)

    if s.is_event:
        qs = qs.order_by('item_date', 'id')
    else:
        qs = qs.order_by('-item_date', '-id')

    context['newsitem_qs'] = qs

    #########################################################################

    # Get the list of top values for each lookup that isn't being filtered-by.
    # LOOKUP_MAX_DISPLAYED sets the number of records to display for each lookup
    # type. Normally, the UI displays a "See all" link, but the link is removed
    # if there are fewer than (LOOKUP_MAX_DISPLAYED + LOOKUP_BUFFER) records.
    LOOKUP_MAX_DISPLAYED = 100
    LOOKUP_BUFFER = 4
    lookup_list, boolean_lookup_list, search_list = [], [], []

    for sf in filter_sf_dict.values():
        if sf.is_searchable:
            search_list.append(sf)
        elif sf.is_type('bool'):
            boolean_lookup_list.append(sf)
        elif sf.is_lookup:
            top_for_sf = _get_lookup_list_for_sf(sf, LOOKUP_MAX_DISPLAYED, LOOKUP_BUFFER)
            # Note we ordered by -total to get the top values, but since we don't
            # display the count, that ordering is nonsensical to the user.
            top_for_sf['top_values'] = sorted(top_for_sf['top_values'],
                                              key = lambda x: x.lookup.name)
            lookup_list.append(top_for_sf)

    # Get the list of LocationTypes if a location filter has *not* been applied.
    if 'location' in filterchain:
        location_type_list = []
    else:
        location_type_list = LocationType.objects.filter(is_significant=True).order_by('slug')

    # Pagination.
    try:
        page = int(request.GET.get('page', '1'))
    except ValueError:
        raise Http404('Invalid page')
    ni_list, has_previous, has_next, idx_start, idx_end = paginate(qs, page=page)
    if page > 1 and not ni_list:
        raise Http404('No objects on page %s' % page)

    populate_schema(ni_list, s)
    populate_attributes_if_needed(ni_list, [s])

    # Need map parameters based on location/block, if there is one.
    loc_filter = filterchain.get('location')
    if loc_filter:
        context.update(get_place_info_for_request(
                request,
                place=loc_filter.location_object,
                block_radius=getattr(loc_filter, 'block_radius', None)))
    else:
        # Whole city map.
        context.update({
                'default_lon': settings.DEFAULT_MAP_CENTER_LON,
                'default_lat': settings.DEFAULT_MAP_CENTER_LAT,
                'default_zoom': settings.DEFAULT_MAP_ZOOM,
                })

    # Try to provide a link to larger map, but don't worry about it
    # if there is no richmap app hooked in...
    try:
        bigmap_base = reverse('bigmap_filter', args=(slug,))
        have_richmaps = True
    except:
        have_richmaps = False
    if have_richmaps:
        try:
            large_map_url = filterchain.make_url(base_url=bigmap_base)
            if filterchain.get('date') is None:
                # force a date range; not sure why Luke wanted that?
                if ni_list:
                    additions=[('date', sorted([ni_list[0].item_date, ni_list[-1].item_date]))]
                else:
                    additions=[]
                large_map_url = filterchain.make_url(
                    base_url=bigmap_base,
                    additions=additions)
            context.update({
                'large_map_url': large_map_url
            })
        except:
            logger.exception("Unhandled exception making large_map_url")
            pass

    context.update({
        'newsitem_list': ni_list,

        # Pagination stuff
        'has_next': has_next,
        'has_previous': has_previous,
        'page_number': page,
        'previous_page_number': page - 1,
        'next_page_number': page + 1,
        'page_start_index': idx_start + 1,
        'page_end_index': idx_end,
        # End pagination.
        'lookup_list': lookup_list,
        'boolean_lookup_list': boolean_lookup_list,
        'search_list': search_list,
        'location_type_list': location_type_list,
        'date_filter_applied': filterchain.has_key('date'),
        'location_filter_applied': filterchain.has_key('location'),
        'lookup_descriptions': filterchain.lookup_descriptions,
        'start_date': start_date,
        'end_date': end_date,
    })
    context['map_configuration'] = _preconfigured_map(context);

    templates_to_try = ('db/schema_filter/%s.html' % s.slug,
                        'db/schema_filter.html')
    return eb_render(request, templates_to_try, context)


def _default_date_filtering(filterchain):
    """
    Apply the filterchain, and make sure we do some date limiting, but
    don't force a DateFilter into the filterchain, because that would
    prevent users from choosing dates.
    """
    schema = filterchain['schema'].schema
    date_filter = filterchain.get('date') or filterchain.get('pubdate')
    qs = filterchain.apply()
    if date_filter:
        start_date = date_filter.start_date
        end_date = date_filter.end_date
    else:
        if schema.is_event:
            start_date = today()
            end_date = start_date + datetime.timedelta(days=30)
        else:
            start_date = schema.min_date
            end_date = today()
        qs = qs.filter(item_date__gte=start_date,
                       item_date__lte=end_date)
    return qs, start_date, end_date

def location_type_list(request):
    """
    Default view of /locations; just redirect to the default loc type.
    """
    url = reverse('ebpub-loc-type-detail', args=(settings.DEFAULT_LOCTYPE_SLUG,))
    return HttpResponsePermanentRedirect(url)

def location_type_detail(request, slug):
    lt = get_object_or_404(LocationType, slug=slug)
    order_by = get_metro()['multiple_cities'] and ('city', 'display_order') or ('display_order',)
    loc_list = Location.objects.filter(location_type__id=lt.id, is_public=True).order_by(*order_by)
    lt_list = [{'location_type': i, 'is_current': i == lt} for i in LocationType.objects.filter(is_significant=True).order_by('plural_name')]
    context = {
        'location_type': lt,
        'location_list': loc_list,
        'location_type_list': lt_list,
        'bodyclass': 'location-type-detail',
        'bodyid': slug,
        }
    context['breadcrumbs'] = breadcrumbs.location_type_detail(context)
    return eb_render(request, 'db/location_type_detail.html', context)


def city_list(request):
    city_type_slug = get_metro()['city_location_type']
    cities_with_streets = set([City.from_norm_name(c['city']).slug
                               for c in Street.objects.order_by().distinct().values('city')])
    all_cities = [City.from_norm_name(v['slug']) for v in
                  Location.objects.filter(location_type__slug=city_type_slug).values('slug', 'name').order_by('name')]

    all_cities = [city for city in all_cities if city.slug.strip()]
    return eb_render(request, 'db/city_list.html',
                     {'all_cities': all_cities,
                      'cities_with_streets': cities_with_streets,
                      'bodyclass': 'city-list',
                      })

def street_list(request, city_slug=None):
    city = city_slug and City.from_slug(city_slug) or None
    kwargs = city_slug and {'city': city.norm_name} or {}
    streets = list(Street.objects.filter(**kwargs).order_by('street_slug'))
    if not streets:
        raise Http404('This city has no streets')
    # URLs are generated from the slugs, which are distinct per city.
    # If the ``city_slug`` arg was None, then the streets list can
    # contain what look like duplicate streets, just in different
    # cities.  That's not helpful because they all link to the same
    # page anyway. So, remove the dupes.  Might be a clever way to do
    # this in one db query; but for a few thousand streets, it's fine
    # to do here.
    slugs_seen = set()
    filtered_streets = []
    for street in streets:
        if street.street_slug in slugs_seen:
            continue
        filtered_streets.append(street)
        slugs_seen.add(street.street_slug)

    try:
        example_loctype = LocationType.objects.get(slug=settings.DEFAULT_LOCTYPE_SLUG).plural_name
    except LocationType.DoesNotExist:
        example_loctype = None
    context = {
        'street_list': filtered_streets,
        'city': city,
        'bodyclass': 'street-list',
        'example_loctype': example_loctype,
    }
    context['breadcrumbs'] = breadcrumbs.street_list(context)
    return eb_render(request, 'db/street_list.html', context)

def block_list(request, city_slug, street_slug):
    city = city_slug and City.from_slug(city_slug) or None
    kwargs = {'street_slug': street_slug}
    if city_slug:
        city_filter = Q(left_city=city.norm_name) | Q(right_city=city.norm_name)
    else:
        city_filter = Q()
    blocks = Block.objects.filter(city_filter, **kwargs).order_by('postdir', 'predir', 'from_num', 'to_num')
    if not blocks:
        raise Http404('This street has no blocks')
    context = {
        'block_list': blocks,
        'first_block': blocks[0],
        'city': city,
        'bodyclass': 'block-list',
    }
    context['breadcrumbs'] = breadcrumbs.block_list(context)
    return eb_render(request, 'db/block_list.html', context)


def _get_place_and_normalize_url(request, *args, **kwargs):
    context = get_place_info_for_request(request, *args, **kwargs)
    if context.get('block_radius') and 'radius' not in request.GET:
        # Normalize the URL so we always have the block radius.
        url = request.get_full_path()
        if '?' in url:
            context['normalized_url'] = '%s&radius=%s' % (url, context['block_radius'])
        else:
            context['normalized_url'] = '%s?radius=%s' % (url, context['block_radius'])
    return context


def place_detail_timeline(request, *args, **kwargs):
    """
    Recent news OR upcoming events for the given Location or Block.
    """
    context = _get_place_and_normalize_url(request, *args, **kwargs)
    if context.get('normalized_url'):
        response = HttpResponse(status=302)
        response['location'] = context['normalized_url']
        for key, val in context.get('cookies_to_set', {}).items():
            response.set_cookie(key, val)
        return response

    show_upcoming = kwargs.get('show_upcoming')
    if show_upcoming:
        context['breadcrumbs'] = breadcrumbs.place_detail_upcoming(context)
    else:
        context['breadcrumbs'] = breadcrumbs.place_detail_timeline(context)

    context = _news_context(request, context,
                            max_items=constants.NUM_NEWS_ITEMS_PLACE_DETAIL,
                            show_upcoming=show_upcoming,
                            location=context['place'],
                            )

    context['map_configuration'] = _preconfigured_map(context)
    context['bodyclass'] = 'place-detail-timeline'
    context['bodyid'] = context.get('place_type') or ''

    response = eb_render(request, 'db/place_detail.html', context)
    for k, v in context['cookies_to_set'].items():
        response.set_cookie(k, v)
    return response


def _news_context(request, context, max_items, show_upcoming=False, **filterargs):
    """
    Puts a list of recent -or- upcoming NewsItems in the context,
    and returns the context.

    ``**filterargs`` are passed to FilterChain.add().

    """
    schema_manager = get_schema_manager(request)
    filterchain = FilterChain(request=request, context=context)

    for key, val in filterargs.items():
        filterchain.add(key, val)

    # Only fetch for relevant schemas - either event-ish or not.
    if show_upcoming:
        # Events, from earliest to latest
        s_list = schema_manager.filter(is_event=True)
        order_by = ('item_date_date', '-pub_date')
        date_limit = Q(item_date__gte=today())
    else:
        # News, from newest to oldest
        s_list = schema_manager.filter(is_event=False)
        order_by = ('-item_date_date', '-pub_date')
        date_limit = Q(item_date__lte=today())

    filterchain.add('schema', list(s_list))
    newsitem_qs = filterchain.apply().select_related().filter(date_limit)
    # TODO: can this really only be done via extra()?
    newsitem_qs = newsitem_qs.extra(
        select={'item_date_date': 'date(db_newsitem.item_date)'},
        order_by=order_by + ('-schema__importance', 'schema'),
    )

    try:
        page = int(request.GET.get('page', 1))
    except ValueError:
        return HttpResponse('Invalid Page %r' % page, status=400)

    # We're done filtering, so go ahead and do the query, to
    # avoid running it multiple times,
    # per http://docs.djangoproject.com/en/dev/topics/db/optimization
    ni_list, has_previous, has_next, idx_start, idx_end = paginate(
        newsitem_qs, page=page, pagesize=max_items)
    schemas_used = list(set([ni.schema for ni in ni_list]))
    s_list = s_list.filter(is_special_report=False, allow_charting=True).order_by('plural_name')
    populate_attributes_if_needed(ni_list, schemas_used)

    hidden_schema_list = []
    if not request.user.is_anonymous():
        hidden_schema_list = [o.schema for o in HiddenSchema.objects.filter(user_id=request.user.id)]

    context.update({
        'newsitem_list': ni_list,
        # Pagination stuff
        'has_next': has_next,
        'has_previous': has_previous,
        'page_number': page,
        'previous_page_number': page - 1,
        'next_page_number': page + 1,
        'page_start_index': idx_start + 1,
        'page_end_index': idx_end,
        # End pagination.
        'hidden_schema_list': hidden_schema_list,
        'filters': filterchain,
        'show_upcoming': show_upcoming,
    })

    context['filtered_schema_list'] = s_list
    return context


def _preconfigured_map(context):
    """
    helper to rig up a map configuration for 
    templates based on the menagerie of
    values provided in the template context.
    
    returns a json string with the layer configuration 
    for the map that should be displayed on the page. 
    """
    
    config = {
        'locations': [],
        'layers': [],
    }

    # load layer boundary if a Location is specified
    location = context.get('location')
    if location is not None:
        loc_json_url = reverse('location_detail_json',
                                 kwargs={'loctype': location.location_type.slug, 
                                         'slug': location.slug})
        loc_boundary = {
            'url': loc_json_url,
            'params': {},
            'title': "%s Boundary" % location.pretty_name,
            'visible': True
        }
        config['locations'].append(loc_boundary);

    ###########################
    # configure newsitem layer 
    # 
    # TODO filtering? via api? see ticket #121
    ###########################
    
    filters = context.get('filters', None)
    if filters is not None and (filters.schema is not None and not isinstance(filters.schema, list)):
        base_url = reverse('ebpub-schema-filter-geojson', args=(context['schema'].slug,))
        layer_url = filters.make_url(base_url=base_url)
        layer_params = {}
        if 'page_number' in context: 
            layer_params['page'] = context['page_number']
        items_layer = {
            'url': layer_url,
            'params': layer_params,
            'title': "Custom Filter" ,
            'visible': True
        }
    else:
        # make up an api layer from the context 
    
        # single news item ? 
        layer_params = {}
        item = context.get('newsitem')
        if item is not None: 
            layer_params['newsitem'] = item.id

        # restricted to place?
        for key in ['pid']:
            val = context.get(key)
            if val is not None: 
                layer_params[key] = val

        # restricted date range ?
        for key in ['start_date', 'end_date']:
            val = context.get(key)
            if val is not None: 
                layer_params[key] = val.strftime('%Y/%m/%d')

        # restricted by schema ?
        schema_slug = context.get('schema_slug')
        if schema_slug is not None: 
            layer_params['schema'] = schema_slug

        items_layer = {
            'url': reverse('ajax-newsitems-geojson'),
            'params': layer_params,
            'title': "News" ,
            'visible': True
        }
    config['layers'].append(items_layer)
    config['baselayer_type'] = settings.MAP_BASELAYER_TYPE
    return simplejson.dumps(config, indent=2)



def place_detail_overview(request, *args, **kwargs):
    """Recent news AND upcoming events for a Location or Block,
    grouped by Schema.
    """
    context = _get_place_and_normalize_url(request, *args, **kwargs)
    if context.get('normalized_url'):
        response = HttpResponse(status=302)
        response['location'] = context['normalized_url']
        for key, val in context.get('cookies_to_set', {}).items():
            response.set_cookie(key, val)
        return response

    schema_manager = get_schema_manager(request)
    context['breadcrumbs'] = breadcrumbs.place_detail_overview(context)

    schema_list = SortedDict([(s.id, s) for s in schema_manager.filter(is_special_report=False).order_by('plural_name')])
    # needed = set(schema_list.keys())

    # We actually want two lists of schemas, since we care whether
    # they are news-like or future-event-like.
    eventish_schema_list = SortedDict()
    newsish_schema_list = SortedDict()
    for s_id, schema in schema_list.items():
        if schema.is_event:
            eventish_schema_list[s_id] = schema
        else:
            newsish_schema_list[s_id] = schema

    filterchain = FilterChain(request=request, context=context)
    filterchain.add('location', context['place'])

    # Distinguish between past news and upcoming events.
    # With some preliminary date limiting too.
    filterchain_news = filterchain.copy()
    filterchain_news.add('date',
                         today() - datetime.timedelta(days=90),
                         today())

    filterchain_events = filterchain.copy()
    filterchain_events.add('date',
                           today(),
                           today() + datetime.timedelta(days=60))

    # Ordering by ID ensures consistency across page views.
    newsitem_qs = filterchain_news.apply().order_by('-item_date', '-id')
    events_qs = filterchain_events.apply().order_by('item_date', 'id')

    # Mapping of schema id -> [schemafields], for building Lookup charts.
    sf_dict = {}
    allowed_schemas = get_schema_manager(request).allowed_schema_ids()
    charted_lookups = SchemaField.objects.filter(
        is_lookup=True, is_charted=True, schema__id__in=allowed_schemas,
        schema__is_special_report=False)
    charted_lookups = charted_lookups.values('id', 'schema_id', 'pretty_name')
    for sf in charted_lookups.order_by('schema__id', 'display_order'):
        sf_dict.setdefault(sf['schema_id'], []).append(sf)

    # Now retrieve newsitems per schema.
    schema_groups, all_newsitems = [], []
    for schema in schema_list.values():
        if schema.id in newsish_schema_list:
            newsitems = newsitem_qs.filter(schema__id=schema.id)
        elif schema.id in eventish_schema_list:
            newsitems = events_qs.filter(schema__id=schema.id)
        else:
            raise RuntimeError("should never get here")
        newsitems = list(newsitems[:s.number_in_overview])
        populate_schema(newsitems, schema)
        schema_groups.append({
            'schema': schema,
            'latest_newsitems': newsitems,
            'has_newsitems': bool(newsitems),
            'lookup_charts': sf_dict.get(schema.id),
        })
        all_newsitems.extend(newsitems)
    schema_list = schema_list.values()
    populate_attributes_if_needed(all_newsitems, schema_list)
    schema_list = [s for s in schema_list if s.allow_charting]

    context['schema_groups'] = schema_groups
    context['filtered_schema_list'] = schema_list
    context['bodyclass'] = 'place-detail-overview'
    if context['is_block']:
        context['bodyid'] = '%s-%s-%s' % (context['place'].street_slug,
                                          context['place'].number(),
                                          context['place'].dir_url_bit())
    else:
        context['bodyid'] = context['location'].slug
    response = eb_render(request, 'db/place_overview.html', context)
    for k, v in context['cookies_to_set'].items():
        response.set_cookie(k, v)
    return response


def feed_signup(request, *args, **kwargs):
    context = get_place_info_for_request(request, *args, **kwargs)
    context['schema_list'] = get_schema_manager(request).filter(is_special_report=False).order_by('plural_name')
    context['map_configuration'] = _preconfigured_map(context);
    return eb_render(request, 'db/feed_signup.html', context)

########NEW FILE########
__FILENAME__ = geoadmin
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Admin UI classes and Widgets with maps customized for OpenBlock,
based on django-olwidget.
"""

from copy import deepcopy
from django.conf import settings
from olwidget.admin import GeoModelAdmin
from olwidget.fields import MapField, EditableLayerField
from olwidget.widgets import Map
import logging

logger = logging.getLogger('ebpub.geoadmin')

# Base options for olwidget, used by maps in the admin UI.
# TODO: olwidget already checks for OLWIDGET_DEFAULT_OPTIONS in settings,
# so this should move to default_settings; but it depends on other
# settings that are probably user-defined.

OLWIDGET_DEFAULT_OPTIONS = getattr(settings, 'OLWIDGET_DEFAULT_OPTIONS', None) or \
    {
    'default_lat': settings.DEFAULT_MAP_CENTER_LAT,
    'default_lon': settings.DEFAULT_MAP_CENTER_LON,
    'default_zoom': settings.DEFAULT_MAP_ZOOM,
    'zoom_to_data_extent': True,
    'layers': [settings.MAP_BASELAYER_TYPE],
    'controls': ['Navigation', 'PanZoom', 'Attribution'],
    # Defaults for generic GeometryFields.
    'geometry': ['point', 'linestring', 'polygon'],
    'isCollection': True,
    # These are necessary to keep our default OSM WMS layer happy.
    'map_options': {'max_resolution': 156543.03390625,
                    'num_zoom_levels': 19,
                    },
    }


class OBMapWidget(Map):

    @classmethod
    def get_extra_context(klass):
        """
        Hook provided by our hacked version of django-olwidget.
        Stuffs a dict of JSON-encoded values into the template
        context so we can provide extra data to our customized
        map template.
        """
        from ebpub.db.context_processors import _get_extra_layers
        return {'MAP_CUSTOM_BASE_LAYERS': _get_extra_layers}

# Need this for changelist maps and other places that aren't convenient to
# override via subclassing.
Map.get_extra_context = OBMapWidget.get_extra_context

class OBMapField(MapField):
    """
    A FormField just like olwidget's MapField but the default widget
    is OBMapWidget, with our default options.
    """

    def __init__(self, fields=None, options=None, layer_names=None,
                 template=None, **kwargs):
        merged_options = deepcopy(OLWIDGET_DEFAULT_OPTIONS)
        if options:
            merged_options.update(options)
        if not fields:
            fields = [EditableLayerField(required=kwargs.get('required'))]
        layers = [field.widget for field in fields]
        self.fields = fields
        kwargs['widget'] = kwargs.get(
            'widget',
            OBMapWidget(layers, merged_options, template, layer_names))
        super(OBMapField, self).__init__(fields=fields, options=merged_options,
                                         layer_names=layer_names,
                                         template=template, **kwargs)


class OSMModelAdmin(GeoModelAdmin):

    options = deepcopy(OLWIDGET_DEFAULT_OPTIONS)

    # This relies on a hack in our forked version of olwidget.
    default_field_class = OBMapField

    list_map_options = deepcopy(options)
    list_map_options['zoom_to_data_extent'] = False

    def changelist_view(self, request, extra_context=None):
        if extra_context is None:
            extra_context = {}
        extra_context.update(OBMapWidget.get_extra_context())
        return super(OSMModelAdmin, self).changelist_view(request, extra_context)

########NEW FILE########
__FILENAME__ = base
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Flexible geocoding against our models, including db.Location,
streets.Place, streets.Block, streets.Intersection ...
"""

from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist
from django.db.models import Q
from ebpub.geocoder.parser.parsing import normalize, parse, ParsingError
from ebpub.utils.text import address_to_block
import logging
import re

block_re = re.compile(r'^(\d+)[-\s]+(?:blk|block)\s+(?:of\s+)?(.*)$', re.IGNORECASE)
intersection_re = re.compile(r'(?<=.) (?:and|\&|at|near|@|around|towards?|off|/|(?:just )?(?:north|south|east|west) of|(?:just )?past) (?=.)', re.IGNORECASE)
# segment_re = re.compile(r'^.{1,40}?\b(?:between .{1,40}? and|from .{1,40}? to) .{1,40}?$', re.IGNORECASE) # TODO

logger = logging.getLogger('ebpub.geocoder.base')

class GeocodingException(Exception):
    pass

class AmbiguousResult(GeocodingException):
    def __init__(self, choices, message=None):
        self.choices = choices
        if message is None:
            message = "Address DB returned %s results" % len(choices)
        self.message = message

    def __str__(self):
        return self.message

class DoesNotExist(GeocodingException):
    pass

class UnparseableLocation(GeocodingException):
    pass

class InvalidBlockButValidStreet(GeocodingException):
    def __init__(self, block_number, street_name, block_list):
        self.block_number = block_number
        self.street_name = street_name
        self.block_list = block_list

class Address(dict):
    "A simple container class for representing a single street address."
    def __init__(self, *args, **kwargs):
        dict.__init__(self, *args, **kwargs)
        self._cache_hit = False

    @property
    def latitude(self):
        if self["point"]:
            return self["point"].y
    lat = latitude

    @property
    def longitude(self):
        if self["point"]:
            return self["point"].x
    lng = longitude

    @property
    def location(self):
        """Everything else full_geocode() can return has a .location,
        so this is here for consistency of API."""
        if self["point"]:
            return self["point"]

    def __unicode__(self):
        return u", ".join([self[k] for k in ["address", "city", "state", "zip"]])

    @classmethod
    def from_cache(cls, cached):
        """
        Builds an Address object from a GeocoderCache result object.
        """
        #  This should probably use the normal Django cache, see ticket #163
        fields = {
            'address': cached.address,
            'city': cached.city,
            'state': cached.state,
            'zip': cached.zip,
            'point': cached.location,
            'intersection_id': cached.intersection_id,
        }
        try:
            block_obj = cached.block
        except ObjectDoesNotExist:
            fields.update({'block': None})
        else:
            fields.update({'block': block_obj})
        try:
            intersection_obj = cached.intersection
        except ObjectDoesNotExist:
            fields.update({'intersection': None})
        else:
            fields.update({'intersection': intersection_obj})
        obj = cls(fields)
        obj._cache_hit = True
        return obj

class Geocoder(object):
    """
    Generic Geocoder class.

    Subclasses must override the following attribute:

        _do_geocode(self, location_string)
            Actually performs the geocoding. The base class implementation of
            geocode() calls this behind the scenes.
    """
    def __init__(self, use_cache=True):
        self.use_cache = use_cache

    def geocode(self, location):
        """
        Geocodes the given location, handling caching behind the scenes.
        """
        location = normalize(location)
        result, cache_hit = None, False

        # Get the result (an Address instance), either from the cache or by
        # calling _do_geocode().
        # TODO: Why does this not use the normal Django caching
        # framework?
        # Defer import to avoid cyclical imports.
        from ebpub.geocoder.models import GeocoderCache
        if self.use_cache:
            try:
                cached = GeocoderCache.objects.filter(normalized_location=location)[0]
            except IndexError:
                pass
            else:
                logger.debug('GeocoderCache HIT for %r' % location)
                result = Address.from_cache(cached)
                cache_hit = True

        if result is None:
            try:
                result = self._do_geocode(location)
            except AmbiguousResult, e:
                # If multiple results were found, check whether they have the
                # same point. If they all have the same point, don't raise the
                # AmbiguousResult exception -- just return the first one.
                # 
                # An edge case is if result['point'] is None. This could happen
                # if the geocoder found locations, not points. In that case,
                # just raise the AmbiguousResult.
                result = e.choices[0]
                if result['point'] is None:
                    raise
                for i in e.choices[1:]:
                    if i['point'] != result['point']:
                        raise
                logger.debug('Got ambiguous results but all had same point, '
                             'returning the first')
        # Save the result to the cache if it wasn't in there already.
        if not cache_hit and self.use_cache:
            logger.debug('caching result for %r' % location)
            GeocoderCache.populate(location, result)

        logger.debug('geocoded: %r to %s' % (location, result))
        return result


class AddressGeocoder(Geocoder):
    """
    Treats the location_string as an address and looks for a matching Block.
    """
    def _do_geocode(self, location_string):
        # Parse the address.
        try:
            locations = parse(location_string)
        except ParsingError, e:
            raise e

        all_results = []

        # For capturing streets with matching name but no matching block.
        invalid_block_args = []

        for loc in locations:
            logger.debug('AddressGeocoder: Trying %r' % loc)
            loc_results = self._db_lookup(loc)
            # If none were found, maybe the street was
            # misspelled. Check that.
            # Defer import to avoid cyclical import.
            from ebpub.streets.models import StreetMisspelling
            if not loc_results and loc['street']:
                logger.debug('AddressGeocoder: checking for alternate spellings of %r'
                             % loc['street'])
                try:
                    misspelling = StreetMisspelling.objects.get(incorrect=loc['street'])
                    # TODO: stash away the original 'street' value for
                    # possible disambiguation later? ticket #295
                    loc['street'] = misspelling.correct
                    logger.debug(' ... corrected to %r' % loc['street'])
                except StreetMisspelling.DoesNotExist:
                    logger.debug(' ... no StreetMisspellings found.')
                    pass
                else:
                    loc_results = self._db_lookup(loc)
                # Next, try removing the street suffix, in case an incorrect
                # one was given.
                if not loc_results and loc['suffix']:
                    logger.debug('No results, will try removing suffix %r'
                                 % loc['suffix'])
                    loc_results = self._db_lookup(dict(loc, suffix=None))
                # Next, try looking for the street, in case the street
                # (without any suffix) exists but the address doesn't.
                if not loc_results and loc['number']:
                    kwargs = {'street': loc['street']}
                    sided_filters = []
                    if loc['city']:
                        city_filter = Q(left_city=loc['city']) | Q(right_city=loc['city'])
                        sided_filters.append(city_filter)
                    # Defer this to avoid import cycle.
                    from ebpub.streets.models import Block
                    b_list = Block.objects.filter(*sided_filters, **kwargs).order_by('predir', 'from_num', 'to_num')
                    if b_list:
                        # We got some blocks with the bare street name.
                        # Might be InvalidBlockButValidStreet, but we don't
                        # want to raise that till we've tried all locations,
                        # in case there's a better one coming up.
                        logger.debug("Street %r exists but block %r doesn't"
                                     % (b_list[0].street_pretty_name, loc['number']))
                        invalid_block_args = [loc['number'], b_list[0].street_pretty_name, b_list]

            if loc_results:
                logger.debug(u'Success. Adding to results: %s' % [unicode(r) for r in loc_results])
                all_results.extend(loc_results)
            else:
                logger.debug('... Got nothing.')

        if not all_results:
            if invalid_block_args:
                raise InvalidBlockButValidStreet(*invalid_block_args)
            else:
                raise DoesNotExist("Geocoder db couldn't find this location: %r" % location_string)
        elif len(all_results) == 1:
            return all_results[0]
        else:
            raise AmbiguousResult(all_results)


    def _db_lookup(self, location):
        """
        Given a location dict as returned by parse(), looks up the address in
        the DB. Always returns a list of Address dictionaries (or an empty list
        if no results are found).
        """
        if not location['number']:
            return []

        # Query the blocks database.
        try:
            # Defer this to avoid import cycle.
            from ebpub.streets.models import Block
            blocks = Block.objects.search(
                street=location['street'],
                number=location['number'],
                predir=location['pre_dir'],
                prefix=location['prefix'],
                suffix=location['suffix'],
                postdir=location['post_dir'],
                city=location['city'],
                state=location['state'],
                zipcode=location['zip'],
            )
        except:
            # TODO: replace with Block-specific exception?
            raise
        return [self._build_result(location, block, geocoded_pt) for block, geocoded_pt in blocks]


    def _build_result(self, location, block, geocoded_pt):
        return Address({
            'address': unicode(" ".join([str(s) for s in [location['number'], block.predir, block.street_pretty_name, block.postdir] if s])),
            'city': block.city.title(),
            'state': block.state,
            'zip': block.zip,
            'block': block,
            'intersection_id': None,
            'point': geocoded_pt,
            'url': block.url(),
            'wkt': str(block.location),
        })


class BlockGeocoder(AddressGeocoder):
    """
    Geocodes the location_string as a streets.Block.
    """

    def _do_geocode(self, location_string):
        m = block_re.search(location_string)
        if not m:
            raise ParsingError("BlockGeocoder somehow got an address it can't parse: %r" % location_string)
        new_location_string = ' '.join(m.groups())
        return AddressGeocoder._do_geocode(self, new_location_string)


class IntersectionGeocoder(Geocoder):
    """
    Geocodes the location_string as a streets.Intersection.
    """

    def _do_geocode(self, location_string):
        sides = intersection_re.split(location_string)
        if len(sides) != 2:
            raise ParsingError("Couldn't parse intersection: %r" % location_string)

        # Parse each side of the intersection to a list of possibilities.
        # Let the ParseError exception propagate, if it's raised.
        left_side = parse(sides[0])
        right_side = parse(sides[1])

        all_results = []
        seen_intersections = set()
        # Defer to avoid cyclical import.
        from ebpub.streets.models import StreetMisspelling
        for street_a in left_side:
            street_a['street'] = StreetMisspelling.objects.make_correction(street_a['street'])
            for street_b in right_side:
                street_b['street'] = StreetMisspelling.objects.make_correction(street_b['street'])
                for result in self._db_lookup(street_a, street_b):
                    if result["intersection_id"] not in seen_intersections:
                        seen_intersections.add(result["intersection_id"])
                        all_results.append(result)

        if not all_results:
            raise DoesNotExist("Geocoder db couldn't find this intersection: %r" % location_string)
        elif len(all_results) == 1:
            return all_results.pop()
        else:
            raise AmbiguousResult(list(all_results), "Intersections DB returned %s results" % len(all_results))


    def _db_lookup(self, street_a, street_b):
        # Avoid circular import.
        from ebpub.streets.models import Intersection
        try:
            intersections = Intersection.objects.search(
                predir_a=street_a["pre_dir"],
                street_a=street_a["street"],
                suffix_a=street_a["suffix"],
                postdir_a=street_a["post_dir"],
                predir_b=street_b["pre_dir"],
                street_b=street_b["street"],
                suffix_b=street_b["suffix"],
                postdir_b=street_b["post_dir"]
            )
        except Exception, e:
            raise DoesNotExist("Intersection db query failed: %r" % e)
        return [self._build_result(i) for i in intersections]


    def _build_result(self, intersection):
        return Address({
            'address': intersection.pretty_name,
            'city': intersection.city,
            'state': intersection.state,
            'zip': intersection.zip,
            'intersection_id': intersection.id,
            'intersection': intersection,
            'block': None,
            'point': intersection.location,
            'url': intersection.url(),
            'wkt': str(intersection.location),
        })

# THIS IS NOT YET FINISHED
#
# class SegmentGeocoder(Geocoder):
#     def _do_geocode(self, location_string):
#         bits = segment_re.findall(location_string)
#         g = IntersectionGeocoder()
#         try:
#             point1 = g.geocode('%s and %s' % (bits[0], bits[1]))
#             point2 = g.geocode('%s and %s' % (bits[0], bits[2]))
#         except DoesNotExist, e:
#             raise DoesNotExist("Segment query failed: %r" % e)
#         # TODO: Make a line from the two points, and return that.


class SmartGeocoder(Geocoder):
    """
    Checks whether the location_string looks like an Intersection, Block,
    or Address, and delegates to the appropriate Geocoder subclass.
    """
    def _do_geocode(self, location_string):
        if intersection_re.search(location_string):
            logger.debug('%r looks like an intersection' % location_string)
            geocoder = IntersectionGeocoder()
        elif block_re.search(location_string):
            logger.debug('%r looks like a block' % location_string)
            geocoder = BlockGeocoder()
        else:
            logger.debug('%r assumed to be an address' % location_string)
            geocoder = AddressGeocoder()
        return geocoder._do_geocode(location_string)


def full_geocode(query, search_places=True, convert_to_block=True, guess=False,
                 **disambiguation_kwargs):
    """
    Tries the full geocoding stack on the given query (a string):

    * Normalizes whitespace/capitalization
    * Searches the Misspelling table to corrects location misspellings
    * Searches the Location table
    * Failing that, searches the Place table (if search_places is True)
    * Failing that, uses the SmartGeocoder to parse this as an address, block,
      or intersection
    * Failing that, raises whichever error is raised by the geocoder --
      except AmbiguousResult, in which case all possible results are
      returned

    Returns a dictionary of {type, result, ambiguous}, where ambiguous is True
    or False, and type can be on of these strings:

    * 'location' -- in which case result is a Location object.
    * 'place' -- in which case result is a Place object. (This is only
      possible if search_places is True.)
    * 'address' -- in which case result is an Address object as returned
      by geocoder.geocode().
    * 'block' -- in which case result is an Address object based on the block.

    When ``ambiguous`` is True in the output dict, ``result`` will be
    a list of objects, and vice versa.

    You can control behavior with ambiguous results in several ways:

    * By passing guess=True, only the first result will be returned.

    * By passing additional kwargs such as ``zipcode``, ``city``, or
      ``state``, they will be used to attempt to disambiguate address
      or block results as needed.  Keys should be keys in each Address result;
      invalid keys have no effect.

    * By default, *if* the exact address is not matched, it will be
      rounded down to the nearest 100, eg.  '123 Main St' will be
      converted to '100 block of Main St', and tried again with
      BlockGeocoder.  This is enabled by default; you can pass
      ``convert_to_block=False`` to turn it off.

    """
    # Local import to avoid circular imports.
    from ebpub.db.models import Location, LocationSynonym
    from ebpub.streets.models import Place, PlaceSynonym

    # Search the Location table.
    try:
        canonical_loc = LocationSynonym.objects.get_canonical(query)
        loc = Location.objects.get(normalized_name=canonical_loc)
    except Location.DoesNotExist:
        pass
    else:
        logger.debug('geocoded %r to Location %s' % (query, loc))
        return {'type': 'location', 'result': loc, 'ambiguous': False}

    # Search the Place table, for stuff like "Sears Tower".
    if search_places:
        canonical_place = PlaceSynonym.objects.get_canonical(query)
        places = Place.objects.filter(normalized_name=canonical_place)
        if len(places) == 1:
            logger.debug(u'geocoded %r to Place %s' % (query, places[0]))
            return {'type': 'place', 'result': places[0], 'ambiguous': False}
        elif len(places) > 1:
            # TODO: Places don't know about city, state, zip...
            # so we can't disambiguate.
            logger.debug(u'geocoded %r to multiple Places: %s' % (query, unicode(places)))
            return {'type': 'place', 'result': places, 'ambiguous': True}

    # Try geocoding this as an address.
    geocoder = SmartGeocoder(use_cache=getattr(settings, 'EBPUB_CACHE_GEOCODER', False))
    try:
        result = geocoder.geocode(query)
    except AmbiguousResult, e:
        logger.debug('Multiple addresses for %r' % query)
        # The disambiguation args (zipcode, city, state,...)
        # are not included in the initial pass because it
        # is often too picky, yielding no results when there is a
        # legitimate nearby zipcode or city identified in either the address
        # or street number data.
        results = disambiguate(e.choices, guess=guess, **disambiguation_kwargs)
        if not results:
            logger.debug("Disambiguate returned nothing, should not happen")
            results = e.choices
        if len(results) > 1:
            return {'type': 'address', 'result': results, 'ambiguous': True}
        else:
            return {'type': 'address', 'result': results[0], 'ambiguous': False}

    except InvalidBlockButValidStreet, e:
        result = {
            'type': 'block',
            'ambiguous': True,
            'result': e.block_list,
            'street_name': e.street_name,
            'block_number': e.block_number,
            }
        if convert_to_block:
            # If the exact address couldn't be geocoded, try using the
            # normalized block name.
            block_name = address_to_block(query)
            if block_name != query:
                try:
                    result['result'] = BlockGeocoder()._do_geocode(block_name)
                    result['result']['address'] = block_name
                    result['ambiguous'] = False
                    logger.debug('Resolved %r to block %r' % (query, block_name))
                except (InvalidBlockButValidStreet, AmbiguousResult):
                    pass
        if result['ambiguous']:
            logger.debug('Invalid block for %r, returning all possible blocks' % query)
        return result

    except:
        raise

    logger.debug('SmartGeocoder for %r returned %s' % (query, result))
    return {'type': 'address', 'result': result, 'ambiguous': False}


def disambiguate(geocoder_results, guess=False, **kwargs):
    """Disambiguate a list of geocoder results based on city, state, zip.
    Result will be a list, which may be the original list or a subset of it.

    If guess==True, returns the first remaining result, which could be
    wildly off from what you expect (eg. in the case of 'invalid block
    but valid street')... so use with caution.
    """
    if not kwargs:
        if guess and geocoder_results:
            logger.debug("Nothing to disambiguate on, returning first result.")
            return [geocoder_results[0]]
        else:
            logger.debug("Nothing to disambiguate or guess, returning all.")
            return geocoder_results

    filtered_results = geocoder_results[:]

    for key, target_val in kwargs.items():
        # special case: allow passing either form
        if key == 'zipcode':
            key = 'zip'

        if not target_val:
            continue

        target_val = target_val.lower()
        previous_results = filtered_results[:]
        filtered_results = [r for r in previous_results
                            if r.get(key, '').lower() == target_val]
        if not filtered_results:
            # Oops, too restrictive. Ignore this disambiguator and
            # try again with any remaining  disambiguators.
            logger.debug(
                "Ambiguous results, but none are in %s %r" % (key, target_val))
            filtered_results = previous_results
            continue

        if len(filtered_results) > 1:
            # Still too many.
            logger.debug(
                "Still ambiguous results in %s %r..." % (key, target_val))
            continue

        elif len(filtered_results) == 1:
            # Yay, successfully disambiguated.
            return filtered_results

    if len(filtered_results) > 1 and guess:
        logger.debug("Still ambiguous results, guessing first.")
        return [filtered_results[0]]

    return filtered_results

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'GeocoderCache'
        db.create_table('geocoder_geocodercache', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('normalized_location', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('address', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('city', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('state', self.gf('django.db.models.fields.CharField')(max_length=2)),
            ('zip', self.gf('django.db.models.fields.CharField')(max_length=10)),
            ('location', self.gf('django.contrib.gis.db.models.fields.PointField')()),
            ('block', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['streets.Block'], null=True, blank=True)),
            ('intersection', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['streets.Intersection'], null=True, blank=True)),
            ('generated_at', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
        ))
        db.send_create_signal('geocoder', ['GeocoderCache'])


    def backwards(self, orm):
        
        # Deleting model 'GeocoderCache'
        db.delete_table('geocoder_geocodercache')


    models = {
        'geocoder.geocodercache': {
            'Meta': {'object_name': 'GeocoderCache'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'generated_at': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'normalized_location': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        }
    }

    complete_apps = ['geocoder']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib.gis.db import models
from ebpub.streets.models import Block
from ebpub.streets.models import Intersection

class GeocoderCache(models.Model):
    """
    Persistent cache for Geocoder results.
    Not sure why this merits a custom model;
    see http://developer.openblockproject.org/ticket/163
    """
    normalized_location = models.CharField(max_length=255, db_index=True)
    address = models.CharField(max_length=255)
    city = models.CharField(max_length=255)
    state = models.CharField(max_length=2)
    zip = models.CharField(max_length=10)
    location = models.PointField()
    block = models.ForeignKey(Block, blank=True, null=True)
    intersection = models.ForeignKey(Intersection, blank=True, null=True)
    generated_at = models.DateTimeField(auto_now_add=True)
    objects = models.GeoManager()

    def __unicode__(self):
        return self.normalized_location

    @classmethod
    def populate(cls, normalized_location, address):
        """
        Populates the cache from an Address object.
        """
        if address['point'] is None:
            return
        obj = cls()
        obj.normalized_location = normalized_location
        for field in ('address', 'city', 'state', 'zip'):
            setattr(obj, field, address[field])
        for relation in ['block', 'intersection_id']:
            if relation in address:
                setattr(obj, relation, address[relation])
        obj.location = address['point']
        obj.save()


from django.contrib.gis import admin

class GeocoderCacheAdmin(admin.ModelAdmin):
    """Adding to admin so you at least can delete them from *somewhere*
    """
    readonly_fields = ('normalized_location',
                       'address',
                       'city',
                       'state',
                       'zip',
                       'location',
                       'block',
                       'intersection',
                       'generated_at',
                       )

    list_display = ('normalized_location', 'city', 'state', 'zip', 'generated_at',
                    )
    list_filter = ('city', 'state', 'zip',
                   )

    search_fields = ('normalized_location',
                     )

admin.site.register(GeocoderCache, GeocoderCacheAdmin)

########NEW FILE########
__FILENAME__ = cities
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

cities = {
    "CHICAGO": "CHI",
    "SAN FRANCISCO": ["SAN FRAN", "SF"],
    "NEW YORK": ["NY", "NYC"],
    "THE BRONX": ["BRONX"],
}

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebdata
#
#   ebdata is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebdata is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebdata.  If not, see <http://www.gnu.org/licenses/>.
#

# needed for manage.py test to find the tests automatically

########NEW FILE########
__FILENAME__ = numbered_streets
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

numbered_streets = {
    "1ST": ["FIRST", "1"],
    "2ND": ["SECOND", "2D", "2"],
    "3RD": ["THIRD", "3D", "3"],
    "4TH": ["FOURTH", "4"],
    "5TH": ["FIFTH", "5"],
    "6TH": ["SIXTH", "6"],
    "7TH": ["SEVENTH", "7"],
    "8TH": ["EIGHTH", "8"],
    "9TH": ["NINTH", "9"],
    "10TH": ["TENTH", "10"],
    "11TH": ["ELEVENTH", "11"],
    "12TH": ["TWELFTH", "TWELVTH", "12"],
    "13TH": ["THIRTEENTH", "13"],
    "14TH": ["FOURTEENTH", "14"],
    "15TH": ["FIFTEENTH", "15"],
    "16TH": ["SIXTEENTH", "16"],
    "17TH": ["SEVENTEENTH", "17"],
    "18TH": ["EIGHTEENTH", "18"],
    "19TH": ["NINTEENTH", "19"],
    "20TH": ["TWENTIETH", "20"],
    "21ST": "21",
    "22ND": "22",
    "23RD": ["23D", "23"],
    "24TH": "24",
    "25TH": "25",
    "26TH": "26",
    "27TH": "27",
    "28TH": "28",
    "29TH": "29",
    "30TH": ["THIRTIETH", "30"],
    "31ST": "31",
    "32ND": "32",
    "33RD": ["33D", "33"],
    "34TH": "34",
    "35TH": "35",
    "36TH": "36",
    "37TH": "37",
    "38TH": "38",
    "39TH": "39",
    "40TH": ["FORTIETH", "40"],
    "41ST": "41",
    "42ND": "42",
    "43RD": ["43D", "43"],
    "44TH": "44",
    "45TH": "45",
    "46TH": "46",
    "47TH": "47",
    "48TH": "48",
    "49TH": "49",
    "50TH": ["FIFTIETH", "50"],
    "51ST": "51",
    "52ND": "52",
    "53RD": ["53D", "53"],
    "54TH": "54",
    "55TH": "55",
    "56TH": "56",
    "57TH": "57",
    "58TH": "58",
    "59TH": "59",
    "60TH": ["SIXTYETH", "SIXTIETH", "60"],
    "61ST": "61",
    "62ND": "62",
    "63RD": ["63D", "63"],
    "64TH": "64",
    "65TH": "65",
    "66TH": "66",
    "67TH": "67",
    "68TH": "68",
    "69TH": "69",
    "70TH": ["SEVENTYITH", "SEVENTIETH", "70"],
    "71ST": "71",
    "72ND": "72",
    "73RD": ["73D", "73"],
    "74TH": "74",
    "75TH": "75",
    "76TH": "76",
    "77TH": "77",
    "78TH": "78",
    "79TH": "79",
    "80TH": ["EIGHTYITH", "EIGHTIETH", "80"],
    "81ST": "81",
    "82ND": "82",
    "83RD": ["83D", "83"],
    "84TH": "84",
    "85TH": "85",
    "86TH": "86",
    "87TH": "87",
    "88TH": "88",
    "89TH": "89",
    "90TH": ["NINETYITH", "NINETIETH", "90"],
    "91ST": "91",
    "92ND": "92",
    "93RD": ["93D", "93"],
    "94TH": "94",
    "95TH": "95",
    "96TH": "96",
    "97TH": "97",
    "98TH": "98",
    "99TH": "99",
    "100TH": "100",
    "101ST": "101",
    "102ND": "102",
    "103RD": ["103D", "103"],
    "104TH": "104",
    "105TH": "105",
    "106TH": "106",
    "107TH": "107",
    "108TH": "108",
    "109TH": "109",
    "110TH": "110",
    "111TH": "111",
    "112TH": "112",
    "113TH": "113",
    "114TH": "114",
    "115TH": "115",
    "116TH": "116",
    "117TH": "117",
    "118TH": "118",
    "119TH": "119",
    "120TH": "120",
    "121ST": "121",
    "122ND": "122",
    "123RD": ["123D", "123"],
    "124TH": "124",
    "125TH": "125",
    "126TH": "126",
    "127TH": "127",
    "128TH": "128",
    "129TH": "129",
    "130TH": "130",
    "131ST": "131",
    "132ND": "132",
    "133RD": ["133D", "133"],
    "134TH": "134",
    "135TH": "135",
    "136TH": "136",
    "137TH": "137",
    "138TH": "138",
    "139TH": "139",
    "140TH": "140",
    "141ST": "141",
    "142ND": "142",
    "143RD": ["143D", "143"],
    "144TH": "144",
    "145TH": "145",
    "146TH": "146",
    "147TH": "147",
    "148TH": "148",
    "149TH": "149",
    "150TH": "150",
    "151ST": "151",
    "152ND": "152",
    "153RD": ["153D", "153"],
    "154TH": "154",
    "155TH": "155",
    "156TH": "156",
    "157TH": "157",
    "158TH": "158",
    "159TH": "159",
    "160TH": "160",
    "161ST": "161",
    "162ND": "162",
    "163RD": ["163D", "163"],
    "164TH": "164",
    "165TH": "165",
    "166TH": "166",
    "167TH": "167",
    "168TH": "168",
    "169TH": "169",
    "170TH": "170",
    "171ST": "171",
    "172ND": "172",
    "173RD": ["173D", "173"],
    "174TH": "174",
    "175TH": "175",
    "176TH": "176",
    "177TH": "177",
    "178TH": "178",
    "179TH": "179",
    "180TH": "180",
    "181ST": "181",
    "182ND": "182",
    "183RD": ["183D", "183"],
    "184TH": "184",
    "185TH": "185",
    "186TH": "186",
    "187TH": "187",
    "188TH": "188",
    "189TH": "189",
    "190TH": "190",
    "191ST": "191",
    "192ND": "192",
    "193RD": ["193D", "193"],
    "194TH": "194",
    "195TH": "195",
    "196TH": "196",
    "197TH": "197",
    "198TH": "198",
    "199TH": "199",
    "200TH": "200",
    "201ST": "201",
    "202ND": "202",
    "203RD": ["203D", "203"],
    "204TH": "204",
    "205TH": "205",
    "206TH": "206",
    "207TH": "207",
    "208TH": "208",
    "209TH": "209",
    "210TH": "210",
    "211TH": "211",
    "212TH": "212",
    "213RD": "213",
    "214TH": "214",
    "215TH": "215",
    "216TH": "216",
    "217TH": "217",
    "218TH": "218",
    "219TH": "219",
    "220TH": "220",
    "221ST": "221",
    "222ND": "222",
    "223RD": ["223D", "223"],
    "224TH": "224",
    "225TH": "225",
    "226TH": "226",
    "227TH": "227",
    "228TH": "228",
    "229TH": "229",
    "230TH": "230",
    "231ST": "231",
    "232ND": "232",
    "233RD": ["233D", "233"],
    "234TH": "234",
    "235TH": "235",
    "236TH": "236",
    "237TH": "237",
    "238TH": "238",
    "239TH": "239",
    "240TH": "240",
    "241ST": "241",
    "242ND": "242",
    "243RD": ["243D", "243"],
    "244TH": "244",
    "245TH": "245",
    "246TH": "246",
    "247TH": "247",
    "248TH": "248",
    "249TH": "249",
    "250TH": "250",
    "251ST": "251",
    "252ND": "252",
    "253RD": ["253D", "253"],
    "254TH": "254",
    "255TH": "255",
    "256TH": "256",
    "257TH": "257",
    "258TH": "258",
    "259TH": "259",
    "260TH": "260",
    "261ST": "261",
    "262ND": "262",
    "263RD": ["263D", "263"],
    "264TH": "264",
    "265TH": "265",
    "266TH": "266",
    "267TH": "267",
    "268TH": "268",
    "269TH": "269",
    "270TH": "270",
    "271ST": "271",
    "272ND": "272",
    "273RD": ["273D", "273"],
    "274TH": "274",
    "275TH": "275",
    "276TH": "276",
    "277TH": "277",
    "278TH": "278",
    "279TH": "279",
    "280TH": "280",
    "281ST": "281",
    "282ND": "282",
    "283RD": ["283D", "283"],
    "284TH": "284",
    "285TH": "285",
    "286TH": "286",
    "287TH": "287",
    "288TH": "288",
    "289TH": "289",
    "290TH": "290",
    "291ST": "291",
    "292ND": "292",
    "293RD": ["293D", "293"],
    "294TH": "294",
    "295TH": "295",
    "296TH": "296",
    "297TH": "297",
    "298TH": "298",
    "299TH": "299",
}

########NEW FILE########
__FILENAME__ = parsing
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

import logging
import re
import string
from itertools import izip

# The following are all relative imports
from suffixes import suffixes
from prefixes import prefixes
from states import states
from cities import cities
from numbered_streets import numbered_streets

logger = logging.getLogger('ebpub.geocoder.parser')

class ParsingError(Exception):
    pass

#################
# STANDARDIZERS #
#################

DIRECTIONALS = {
    'N': 'NORTH',
    'NE': 'NORTHEAST',
    'E': 'EAST',
    'SE': 'SOUTHEAST',
    'S': 'SOUTH',
    'SW': 'SOUTHWEST',
    'W': 'WEST',
    'NW': 'NORTHWEST',
}

class Standardizer(object):
    """Replaces a suffix, directional, state, etc. with the preferred standard form.

    For example, given the text "avenu" for suffixes, returns "AVE".
    ::

        >>> suff_standardizer = Standardizer(suffixes)
        >>> suff_standardizer("avenu")
        'AVE'
        >>> dir_standardizer = Standardizer(DIRECTIONALS)
        >>> dir_standardizer("north")
        'N'
        >>> dir_standardizer("n")
        'N'
        >>> pre_standardizer = Standardizer(prefixes)
        >>> pre_standardizer("US hwy")
        'US HIGHWAY'
        >>> pre_standardizer("SR")
        'STATE ROUTE'
    """
    def __init__(self, d):
        self.replacement = {}
        for standard, options in d.items():
            standard = standard.upper()
            if isinstance(options, basestring):
                options = [options]
            for opt in options:
                self.replacement[opt.upper()] = standard
            # Also map the standard to itself.
            self.replacement[standard] = standard

    def __call__(self, s):
        if s.upper() in self.replacement:
            return self.replacement[s.upper()]
        else:
            return s

_number_standardizer_re = re.compile(r'(\d+)')

def number_standardizer(s):
    """
    Removes the second number in hyphenated addresses such as '123-02', as
    used in NYC. Note that this also removes the second number in address
    ranges, and non-digit prefixes or suffixes::
    
        >>> number_standardizer('1-2')
        '1'
        >>> number_standardizer('100-200')
        '100'
        >>> number_standardizer('12A-12B')
        '12'
        >>> number_standardizer('x')
        'x'
        >>> number_standardizer('257b')
        '257'
        >>> number_standardizer('9L00')
        '9'
        >>> number_standardizer('W01')
        '01'
        >>> number_standardizer('9 8 7 6 5')
        '9'

    """
    m = _number_standardizer_re.search(s)
    if not m:
        # We shouldn't reach this, but if the regex doesn't match, just return the input.
        return s
    return m.group(1)

dir_standardizer = Standardizer(DIRECTIONALS)

STANDARDIZERS = {
    'number': number_standardizer,
    'pre_dir': dir_standardizer,
    'street': Standardizer(numbered_streets),
    'suffix': Standardizer(suffixes),
    'post_dir': dir_standardizer,
    'city': Standardizer(cities),
    'state': Standardizer(states),
    'prefix': Standardizer(prefixes),
}

# Regex which matches all punctuation, except for dashes (which
# might be used in NYC addresses) and ampersands.
preserved_puncts = "-&"
punct = re.compile(r'[%s]' % re.escape("".join(set(string.punctuation) - set(preserved_puncts))))

half_addresses_re = re.compile(r'(?<=\s)[I1]/2(?=\s)')
multi_dash_re = re.compile(r'(?<=\d)\s*-+\s*(?=\d)')
zip_plus_4_re = re.compile(r'(?<=^\d{5})-\d{4}$')

def normalize(location):
    """
    Normalizes an address string for parsing, comparisons.
    ::

        >>> normalize(u"1972 n. dawson ave. chicago il")
        u'1972 N DAWSON AVE CHICAGO IL'
        >>> normalize(u"1972 n. dawson ave., chicago il")
        u'1972 N DAWSON AVE CHICAGO IL'
        >>> normalize(u"n kimball ave & w diversey ave")
        u'N KIMBALL AVE & W DIVERSEY AVE'
        >>> normalize(None)
        u'NONE'
    """
    location = unicode(location)
    old_location = location
    location = location.upper()
    location = half_addresses_re.sub('', location) # Strip "1/2" addresses.
    location = multi_dash_re.sub('-', location)
    location = punct.sub('', location) # Remove all punctuation except dashes, and ampersands.
    location = re.sub(r'\s+', ' ', location.strip()) # Strip/normalize whitespace.
    location = zip_plus_4_re.sub('', location) # Strip the +4 part of a ZIP+4.
    logger.debug("normalized: %r to %r" % (old_location, location))
    return location

def strip_unit(location):
    """
    Given an address string, strips the apartment number, suite number, etc.
    ::

        >>> strip_unit('200 E 31st st')
        '200 E 31st st'
        >>> strip_unit('200 E 31st st unit 123')
        '200 E 31st st'
        >>> strip_unit('123 W broadway apt B')
        '123 W broadway'
        >>> strip_unit('99 s northshore drive apt. B')
        '99 s northshore drive'
        >>> strip_unit('45 carlton ave #12')
        '45 carlton ave'
        >>> strip_unit('148 lafayette st suite 13')
        '148 lafayette st'

    """
    return re.sub(r'(?i)(\s*,)?\s*(?:space\s+|suite\s+|ste\.?\s+|unit:?\s+|apt\.?\s+|\#\s*)[-\#0-9a-z]*$', '', location)

###########
# PARSING #
###########

def abbrev_regex(d, case_insensitive=True, matches_entirely=True):
    '''
    Returns a regular expression pattern that matches an abbreviation:

    .. code-block:: python
    
        >>> suffixes = {
        ...     'av': ['ave', 'avenue'],
        ...     'st': ['str', 'street'],
        ...     'rd': 'road'
        ... }
        >>> regex = abbrev_regex(suffixes)
        >>> re.search(regex, "Ave")  # doctest: +ELLIPSIS
        <_sre.SRE_Match object at ...>
        >>> re.search(regex, " Ave ") == None
        True
        >>> regex = abbrev_regex(suffixes, case_insensitive=False)
        >>> re.search(regex, "str")  # doctest: +ELLIPSIS
        <_sre.SRE_Match object at ...>
        >>> re.search(regex, "Str") == None
        True
        >>> regex = abbrev_regex(suffixes, matches_entirely=False)
        >>> re.search(regex, " Road ")  # doctest: +ELLIPSIS
        <_sre.SRE_Match object at ...>

    '''
    alts = []
    for k, v in d.items():
        if isinstance(v, basestring):
            v = [v]
        alts.append(k)
        alts.extend(v)
    pattern = r"(?:%s)" % "|".join(alts)
    if matches_entirely:
        pattern = "^" + pattern + "$"
    if case_insensitive:
        pattern = "(?i)" + pattern
    return pattern

directional_re = re.compile(abbrev_regex(DIRECTIONALS))

def prefix_regex(case_insensitive=True, matches_entirely=True):
    """
    Returns a regex that matches any token of the prefixes:

    >>> regex = prefix_regex()
    >>> re.search(regex, 'HWY')   # doctest:+ELLIPSIS
    <_sre.SRE_Match object at ...>
    >>> re.search(regex, 'NY')   # doctest:+ELLIPSIS
    <_sre.SRE_Match object at ...>
    >>> print re.search(regex, 'nope')
    None
    """
    alts = set()
    for v in prefixes.values():
        if isinstance(v, basestring):
            alts.update(v.split())
        else:
            for inner_v in v:
                alts.update(inner_v.split())
    pattern = r"(?:%s)" % "|".join(alts)
    if matches_entirely:
        pattern = "^" + pattern + "$"
    if case_insensitive:
        pattern = "(?i)" + pattern
    return pattern


TOKEN_REGEXES = {
    'number': re.compile(r'^\d+[A-Z]?(?:-\d+[A-Z]?)?$'),
    'pre_dir': directional_re,
    'prefix': re.compile(prefix_regex()),
    'street': re.compile(r'^[0-9]{1,3}(?:ST|ND|RD|TH)|[A-Z]{1,25}|(I(-?))?[0-9]{1,3}[A-Z]?$'),
    'suffix': re.compile(abbrev_regex(suffixes)),
    'post_dir': directional_re,
    # Cities are assumed to have at least three letters and at most 25 letters.
    # This is a safe assumption that comes from this page:
    # http://www.geographylists.com/list17f.html
    'city': re.compile(r'^[A-Z]{3,25}$'),

    # State words can have between 2 and 13 letters ('MASSACHUSETTS' is the
    # longest, with 13 letters). Note that this doesn't count states whose
    # names take up more than one word. This regex matches *single* words.
    'state': re.compile(r'^[A-Z]{2,13}$'),

    'zip': re.compile(r'^\d{5}(?:-\d{4})?$'),
}

class Location(dict):
    """
    A dict-like object with only a few valid keys:
    ('number', 'pre_dir', 'prefix', 'street', 'suffix', 'post_dir', 'city', 'state', 'zip')

    """
    location_keys = ('number', 'pre_dir', 'prefix', 'street', 'suffix', 'post_dir', 'city', 'state', 'zip')

    def __init__(self, *args):
        super(Location, self).__init__(*args)
        for location_key in self.location_keys:
            if location_key not in self:
                self[location_key] = None

    def __repr__(self):
        return "{%s}" % ", ".join(["%r: %r" % (k, self[k]) for k in self.location_keys])

    def __setitem__(self, name, value):
        if name not in self.location_keys:
            raise AttributeError(repr(name))
        super(Location, self).__setitem__(name, value)

def address_combinations():
    """
    Generator that yields a list of strings for every possible
    combination of address tokens. For example::

        ['number', 'pre_dir', 'street']
        ['number', 'street', 'city', 'state']

    There were about 6240 combinations at last count.
    """
    for number_times in (0, 1):
        for pre_dir_times in (0, 1):
            for prefix_times in (0, 1, 2, 3):
                for street_times in (1, 2, 3, 4, 5):
                    for suffix_times in (0, 1):
                        for post_dir_times in (0, 1):
                            for city_times in (0, 1, 2, 3, 4):
                                # If a city isn't given, then a state isn't allowed.
                                for state_times in (city_times == 0 and (0,) or (0, 1, 2)):
                                    for zip_times in (0, 1):
                                        yield ['number'] * number_times + ['pre_dir'] * pre_dir_times + ['prefix'] * prefix_times + ['street'] * street_times + ['suffix'] * suffix_times + ['post_dir'] * post_dir_times + ['city'] * city_times + ['state'] * state_times + ['zip'] * zip_times


token_split = re.compile(r"\S+").findall

# Special case for detecting eg. 'I40', 'I-40'
interstate_street_re = re.compile(r"^I(-?\s*)(\d{1,3}[A-Z]?)$")

def parse(location):
    """
    Given a ``location`` string, return a list of possible valid
    results as ``Location`` instances.

    """
    s = strip_unit(normalize(location))
    logger.debug('parse: normalized and stripped %r to %r' % (location, s))
    tokens = token_split(s)
    len_tokens = len(tokens)
    result_list = []

    for token_types in address_combinations():
        if len(token_types) == len_tokens:
            try:
                for token, token_type in izip(tokens, token_types):
                    if not TOKEN_REGEXES[token_type].match(token):
                        raise StopIteration() # Token regex didn't match.
            except StopIteration:
                continue

            # If we made it this far, then all of the tokens are valid.
            # Create the Location object.
            result = Location()
            for token, token_type in izip(tokens, token_types):
                if result[token_type]:
                    result[token_type] += ' ' + token
                else:
                    result[token_type] = token

            if result['street'] and not result['prefix']:
                # Special case: "I40" -> "Interstate 40"
                fixed = interstate_street_re.sub(r'\2', result['street'])
                if fixed != result['street']:
                    result['street'] = fixed
                    result['prefix'] = 'INTERSTATE'

            # Standardize all values.
            for key, value in result.items():
                if value and key in STANDARDIZERS:
                    if key == 'street':
                        if result['prefix']:
                            # Special case: "US Highway 101", not "US Highway 101st".
                            continue
                    result[key] = STANDARDIZERS[key](value)
                    logger.debug('parse: standardized %r to %r' % (value, result[key]))

            logger.debug('parse: %r gave possible result address %s' % (s, result))
            result_list.append(result)

    if not result_list:
        raise ParsingError("Failed to parse location %r" % location)
    return result_list

if __name__ == "__main__":
    import doctest
    doctest.testmod(optionflags=doctest.ELLIPSIS)

########NEW FILE########
__FILENAME__ = prefixes
#   Copyright 2012 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
US street address prefix standardization,
derived from http://pe.usps.gov/text/pub28/28apf.html
"""

prefixes = {
    'COUNTY HIGHWAY': ['COUNTY HIGHWAY', 'COUNTY HWY', 'CNTY HWY'],
    'COUNTY ROAD': ['COUNTY RD', 'COUNTY ROAD', 'CR', 'CNTY RD'],
    'EXPRESSWAY': ['EXPRESSWAY', 'EXPWY'],
    'FM': ['FARM TO MARKET', 'FM', 'HWY FM'],
    'HIGHWAY': ['HIGHWAY', 'HIWAY', 'HWY'],
    'INTERSTATE': ['I', 'INTERSTATE', 'IH', 'INTERSTATE HWY'],
    'ROAD': ['RD', 'ROAD'],
    'ROUTE': ['RT', 'RTE', 'ROUTE'],
    'RANCH ROAD': ['RANCH RD'],
    'STATE HIGHWAY': ['ST HIGHWAY', 'STATE HWY', 'ST HWY'],
    # Problem: 'SR' is ambiguous, could be STATE ROAD or STATE ROUTE.
    # We choose STATE ROUTE arbitrarily.
    'STATE ROAD': ['ST RD', 'STATE ROAD',], # 'SR'],
    'STATE ROUTE': ['SR', 'ST RT', 'STATE ROUTE', 'STATE RTE'],
    'TOWNSHIP ROAD': ['TOWNSHIP RD', 'TSR', 'TOWNSHIP ROAD'],
    'US HIGHWAY': ['US', 'US HIGHWAY', 'US HWY'],

    # These OLD variants are not documented by the post office, but
    # I've seen 'em in TIGER census data.
    'OLD US HIGHWAY': ['OLD US', 'OLD US HIGHWAY', 'OLD US HWY'],
    'OLD STATE HIGHWAY': ['OLD STATE', 'OLD STATE HIGHWAY', 'OLD STATE HWY', 'OLD ST HWY'],
    'OLD STATE ROUTE': ['OLD SR', 'OLD ST RT', 'OLD STATE ROUTE', 'OLD STATE RTE'],
    'OLD STATE ROAD': ['OLD ST RD', 'OLD STATE ROAD',], # 'OLD SR'],
    'OLD ROUTE': ['OLD RT', 'OLD RTE', 'OLD ROUTE'],
    'OLD COUNTY HIGHWAY': ['OLD COUNTY HIGHWAY', 'OLD COUNTY HWY', 'OLD CNTY HWY'],
    'OLD COUNTY ROAD': ['OLD COUNTY RD', 'OLD COUNTY ROAD', 'OLD CR', 'OLD CNTY RD'],
    'OLD HIGHWAY': ['OLD HIGHWAY', 'OLD HIWAY', 'OLD HWY'],
    'OLD': ['OLD'],

    # 'LOOP' and 'BUSINESS LOOP' are not in docs, but I've seen it in
    # Columbia MO data.
    'LOOP': ['LOOP'],
    'BUSINESS LOOP': ['BUSINESS LOOP'],

}

state_prefixes = {}
from states import states
for abbr, full in states.items():
    # Example:
    #'KY HIGHWAY': ['KENTUCKY', 'KY HIGHWAY', 'KENTUCKY HIGHWAY', 'KY', 'KY HWY'],
    key = abbr + ' HIGHWAY'
    vals = [key, abbr, full, full + ' HIGHWAY', abbr + ' HWY']
    state_prefixes[key] = vals

    # Example:
    #'KY STATE HIGHWAY': ['KY ST HWY', 'KY STATE HIGHWAY', 'KENTUCKY STATE HIGHWAY'],
    key = abbr + ' STATE HIGHWAY'
    vals = [key, abbr + ' ST HWY', full + ' STATE HIGHWAY']
    state_prefixes[key] = vals

    # Example:
    #'CA COUNTY ROAD': ['CA COUNTY RD', 'CALIFORNIA COUNTY ROAD', 'CA COUNTY ROAD'],
    key = abbr + ' COUNTY ROAD'
    vals = [key, abbr + ' COUNTY RD', full + ' COUNTY ROAD']


prefixes.update(state_prefixes)

# These examples were in the file but aren't separate prefixes.
# 'INTERSTATE 55 BYP': 'I 55 BYPASS',
# 'INTERSTATE 26 BYPASS RD': 'I 26 BYP ROAD',
# 'INTERSTATE 44 FRONTAGE RD': 'I 44 FRONTAGE ROAD',
# 'HIGHWAY 11 BYP': 'HWY 11 BYPASS',
# 'HIGHWAY 66 FRONTAGE RD': 'HWY 66 FRONTAGE ROAD',
# 'HIGHWAY 3 BYPASS RD': 'HIGHWAY 3 BYP ROAD',



########NEW FILE########
__FILENAME__ = states
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

states = {
  'AL': 'ALABAMA',
  'AK': 'ALASKA',
  'AS': 'AMERICAN SAMOA',
  'AZ': 'ARIZONA',
  'AR': 'ARKANSAS',
  'CA': 'CALIFORNIA',
  'CO': 'COLORADO',
  'CT': 'CONNECTICUT',
  'DE': 'DELAWARE',
  'DC': 'DISTRICT OF COLUMBIA',
  'FM': 'FEDERATED STATES OF MICRONESIA',
  'FL': 'FLORIDA',
  'GA': 'GEORGIA',
  'GU': 'GUAM',
  'HI': 'HAWAII',
  'ID': 'IDAHO',
  'IL': 'ILLINOIS',
  'IN': 'INDIANA',
  'IA': 'IOWA',
  'KS': 'KANSAS',
  'KY': 'KENTUCKY',
  'LA': 'LOUISIANA',
  'ME': 'MAINE',
  'MH': 'MARSHALL ISLANDS',
  'MD': 'MARYLAND',
  'MA': 'MASSACHUSETTS',
  'MI': 'MICHIGAN',
  'MN': 'MINNESOTA',
  'MS': 'MISSISSIPPI',
  'MO': 'MISSOURI',
  'MT': 'MONTANA',
  'NE': 'NEBRASKA',
  'NV': 'NEVADA',
  'NH': 'NEW HAMPSHIRE',
  'NJ': 'NEW JERSEY',
  'NM': 'NEW MEXICO',
  'NY': 'NEW YORK',
  'NC': 'NORTH CAROLINA',
  'ND': 'NORTH DAKOTA',
  'MP': 'NORTHERN MARIANA ISLANDS',
  'OH': 'OHIO',
  'OK': 'OKLAHOMA',
  'OR': 'OREGON',
  'PW': 'PALAU',
  'PA': 'PENNSYLVANIA',
  'PR': 'PUERTO RICO',
  'RI': 'RHODE ISLAND',
  'SC': 'SOUTH CAROLINA',
  'SD': 'SOUTH DAKOTA',
  'TN': 'TENNESSEE',
  'TX': 'TEXAS',
  'UT': 'UTAH',
  'VT': 'VERMONT',
  'VI': 'VIRGIN ISLANDS',
  'VA': 'VIRGINIA',
  'WA': 'WASHINGTON',
  'WV': 'WEST VIRGINIA',
  'WI': 'WISCONSIN',
  'WY': 'WYOMING',
}

########NEW FILE########
__FILENAME__ = suffixes
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

suffixes = {
 'ALY': ['ALLEE', 'ALLY', 'ALLEY', 'ALY'],
 'ANX': ['ANEX', 'ANNX', 'ANX', 'ANNEX'],
 'ARC': ['ARC', 'ARCADE'],
 'AVE': ['AVEN', 'AVNUE', 'AVENU', 'AVN', 'AV', 'AVE', 'AVENUE'],
 'BCH': ['BCH', 'BEACH'],
 'BG': ['BURG'],
 'BGS': ['BURGS'],
 'BLF': ['BLUF', 'BLF', 'BLUFF'],
 'BLFS': ['BLUFFS'],
 'BLVD': ['BLVD', 'BOULV', 'BOUL', 'BOULEVARD', 'BL'],
 'BND': ['BEND', 'BND'],
 'BR': ['BRNCH', 'BR', 'BRANCH'],
 'BRG': ['BRG', 'BRIDGE', 'BRDGE'],
 'BRK': ['BRK', 'BROOK'],
 'BRKS': ['BROOKS'],
 'BTM': ['BTM', 'BOTTM', 'BOT', 'BOTTOM'],
 'BYP': ['BYPS', 'BYPA', 'BYPAS', 'BYP', 'BYPASS'],
 'BYU': ['BAYOU', 'BAYOO'],
 'CIR': ['CIRC', 'CRCLE', 'CIR', 'CIRCL', 'CIRCLE', 'CRCL'],
 'CIRS': ['CIRCLES'],
 'CLB': ['CLUB', 'CLB'],
 'CLF': ['CLF', 'CLIFF'],
 'CLFS': ['CLIFFS', 'CLFS'],
 'CMN': ['COMMON'],
 'COR': ['CORNER', 'COR'],
 'CORS': ['CORNERS', 'CORS'],
 'CP': ['CP', 'CAMP', 'CMP'],
 'CPE': ['CAPE', 'CPE'],
 'CRES': ['CRESENT',
          'CRECENT',
          'CRSENT',
          'CRSNT',
          'CRES',
          'CRSCNT',
          'CRESCENT'],
 'CRK': ['CK', 'CR', 'CREEK', 'CRK'],
 'CRSE': ['COURSE', 'CRSE'],
 'CRST': ['CREST'],
 'CSWY': ['CSWY', 'CAUSWAY', 'CAUSEWAY'],
 'CT': ['COURT', 'CRT', 'CT'],
 'CTR': ['CNTER', 'CTR', 'CENTRE', 'CEN', 'CENT', 'CNTR', 'CENTR', 'CENTER'],
 'CTRS': ['CENTERS'],
 'CTS': ['COURTS', 'CTS'],
 'CURV': ['CURVE'],
 'CV': ['COVE', 'CV'],
 'CVS': ['COVES'],
 'CYN': ['CANYON', 'CANYN', 'CNYN', 'CYN'],
 'DL': ['DALE', 'DL'],
 'DM': ['DAM', 'DM'],
 'DR': ['DRIV', 'DR', 'DRIVE', 'DRV'],
 'DRS': ['DRIVES'],
 'DV': ['DV', 'DVD', 'DIV', 'DIVIDE'],
 'EST': ['EST', 'ESTATE'],
 'ESTS': ['ESTATES', 'ESTS'],
 'EXPY': ['EXPY', 'EXPR', 'EXPRESS', 'EXPW', 'EXP', 'EXPWY', 'EXPRESSWAY'],
 'EXT': ['EXTN', 'EXT', 'EXTNSN', 'EXTENSION'],
 'EXTS': ['EXTS', 'EXTENSIONS'],
 'FALL': ['FALL'],
 'FLD': ['FIELD', 'FLD'],
 'FLDS': ['FIELDS', 'FLDS'],
 'FLS': ['FLS', 'FALLS'],
 'FLT': ['FLAT', 'FLT'],
 'FLTS': ['FLATS', 'FLTS'],
 'FRD': ['FRD', 'FORD'],
 'FRDS': ['FORDS'],
 'FRG': ['FORGE', 'FRG', 'FORG'],
 'FRGS': ['FORGES'],
 'FRK': ['FORK', 'FRK'],
 'FRKS': ['FORKS', 'FRKS'],
 'FRST': ['FRST', 'FOREST', 'FORESTS'],
 'FRY': ['FERRY', 'FRY', 'FRRY'],
 'FT': ['FRT', 'FT', 'FORT'],
 'FWY': ['FREEWAY', 'FRWAY', 'FRWY', 'FREEWY', 'FWY'],
 'GDN': ['GARDN', 'GRDN', 'GARDEN', 'GDN', 'GRDEN'],
 'GDNS': ['GDNS', 'GRDNS', 'GARDENS'],
 'GLN': ['GLEN', 'GLN'],
 'GLNS': ['GLENS'],
 'GRN': ['GRN', 'GREEN'],
 'GRNS': ['GREENS'],
 'GRV': ['GROVE', 'GRV', 'GROV'],
 'GRVS': ['GROVES'],
 'GTWY': ['GTWAY', 'GATWAY', 'GTWY', 'GATEWAY', 'GATEWY'],
 'HBR': ['HARBOR', 'HARBR', 'HARB', 'HRBOR', 'HBR'],
 'HBRS': ['HARBORS'],
 'HL': ['HILL', 'HL'],
 'HLS': ['HLS', 'HILLS'],
 'HOLW': ['HOLW', 'HOLWS', 'HLLW', 'HOLLOWS', 'HOLLOW'],
 'HTS': ['HTS', 'HEIGHT', 'HGTS', 'HT', 'HEIGHTS'],
 'HVN': ['HVN', 'HAVEN', 'HAVN'],
 'HWY': ['HIWY', 'HIGHWAY', 'HWY', 'HWAY', 'HIWAY', 'HIGHWY'],
 'INLT': ['INLT', 'INLET'],
 'IS': ['ISLAND', 'IS', 'ISLND'],
 'ISLE': ['ISLE', 'ISLES'],
 'ISS': ['ISS', 'ISLANDS', 'ISLNDS'],
 'JCT': ['JCT', 'JCTN', 'JUNCTION', 'JCTION', 'JUNCTN', 'JUNCTON'],
 'JCTS': ['JCTNS', 'JCTS', 'JUNCTIONS'],
 'KNL': ['KNL', 'KNOL', 'KNOLL'],
 'KNLS': ['KNOLLS', 'KNLS'],
 'KY': ['KY', 'KEY'],
 'KYS': ['KEYS', 'KYS'],
 'LAND': ['LAND'],
 'LCK': ['LOCK', 'LCK'],
 'LCKS': ['LOCKS', 'LCKS'],
 'LDG': ['LODGE', 'LDGE', 'LODG', 'LDG'],
 'LF': ['LF', 'LOAF'],
 'LGT': ['LIGHT', 'LGT'],
 'LGTS': ['LIGHTS'],
 'LK': ['LAKE', 'LK'],
 'LKS': ['LAKES', 'LKS'],
 'LN': ['LN', 'LANE', 'LANES', 'LA'],
 'LNDG': ['LNDNG', 'LNDG', 'LANDING'],
 'LOOP': ['LOOPS', 'LOOP'],
 'MALL': ['MALL'],
 'MDW': ['MEADOW', 'MDW'],
 'MDWS': ['MEDOWS', 'MEADOWS', 'MDWS'],
 'MEWS': ['MEWS'],
 'ML': ['ML', 'MILL'],
 'MLS': ['MLS', 'MILLS'],
 'MNR': ['MNR', 'MANOR'],
 'MNRS': ['MNRS', 'MANORS'],
 'MSN': ['MSN', 'MISSN', 'MISSION', 'MSSN'],
 'MT': ['MT', 'MOUNT', 'MNT'],
 'MTN': ['MOUNTAIN', 'MOUNTIN', 'MNTN', 'MNTAIN', 'MTN', 'MTIN'],
 'MTNS': ['MOUNTAINS', 'MNTNS'],
 'MTWY': ['MOTORWAY'],
 'NCK': ['NCK', 'NECK'],
 'OPAS': ['OVERPASS'],
 'ORCH': ['ORCHRD', 'ORCH', 'ORCHARD'],
 'OVAL': ['OVAL', 'OVL'],
 'PARK': ['PK', 'PARK', 'PARKS', 'PRK'],
 'PASS': ['PASS'],
 'PATH': ['PATH', 'PATHS'],
 'PIKE': ['PIKE', 'PIKES'],
 'PKWY': ['PKWAY', 'PKY', 'PARKWAYS', 'PKWY', 'PARKWY', 'PKWYS', 'PARKWAY'],
 'PL': ['PLACE', 'PL'],
 'PLN': ['PLAIN', 'PLN'],
 'PLNS': ['PLNS', 'PLAINS', 'PLAINES'],
 'PLZ': ['PLAZA', 'PLZ', 'PLZA'],
 'PNE': ['PINE'],
 'PNES': ['PINES', 'PNES'],
 'PR': ['PR', 'PRR', 'PRAIRIE', 'PRARIE'],
 'PRT': ['PRT', 'PORT'],
 'PRTS': ['PRTS', 'PORTS'],
 'PSGE': ['PASSAGE'],
 'PT': ['PT', 'POINT'],
 'PTS': ['POINTS', 'PTS'],
 'RADL': ['RADL', 'RAD', 'RADIEL', 'RADIAL'],
 'RAMP': ['RAMP'],
 'RD': ['RD', 'ROAD'],
 'RDG': ['RDG', 'RIDGE', 'RDGE'],
 'RDGS': ['RDGS', 'RIDGES'],
 'RDS': ['ROADS', 'RDS'],
 'RIV': ['RIV', 'RVR', 'RIVER', 'RIVR'],
 'RNCH': ['RANCHES', 'RANCH', 'RNCH', 'RNCHS'],
 'ROW': ['ROW'],
 'RPD': ['RAPID', 'RPD'],
 'RPDS': ['RPDS', 'RAPIDS'],
 'RST': ['RST', 'REST'],
 'RTE': ['ROUTE'],
 'RUE': ['RUE'],
 'RUN': ['RUN'],
 'SHL': ['SHL', 'SHOAL'],
 'SHLS': ['SHLS', 'SHOALS'],
 'SHR': ['SHOAR', 'SHORE', 'SHR'],
 'SHRS': ['SHORES', 'SHOARS', 'SHRS'],
 'SKWY': ['SKYWAY'],
 'SMT': ['SMT', 'SUMMIT', 'SUMITT', 'SUMIT'],
 'SPG': ['SPRING', 'SPNG', 'SPRNG', 'SPG'],
 'SPGS': ['SPRINGS', 'SPGS', 'SPRNGS', 'SPNGS'],
 'SPUR': ['SPUR', 'SPURS'],
 'SQ': ['SQR', 'SQ', 'SQUARE', 'SQU', 'SQRE'],
 'SQS': ['SQRS', 'SQUARES'],
 'ST': ['STRT', 'STREET', 'STR', 'ST'],
 'STA': ['STATN', 'STN', 'STATION', 'STA'],
 'STRA': ['STRAVE',
          'STRAV',
          'STRAVEN',
          'STRAVN',
          'STRVN',
          'STRAVENUE',
          'STRVNUE',
          'STRA'],
 'STRM': ['STREME', 'STRM', 'STREAM'],
 'STS': ['STREETS'],
 'TER': ['TER', 'TERRACE', 'TERR'],
 'TPKE': ['TURNPK', 'TRPK', 'TPK', 'TPKE', 'TURNPIKE', 'TRNPK'],
 'TRAK': ['TRACK', 'TRACKS', 'TRKS', 'TRK', 'TRAK'],
 'TRCE': ['TRCE', 'TRACES', 'TRACE'],
 'TRFY': ['TRFY', 'TRAFFICWAY'],
 'TRL': ['TRLS', 'TRAIL', 'TR', 'TRL', 'TRAILS'],
 'TRWY': ['THROUGHWAY'],
 'TUNL': ['TUNEL', 'TUNNEL', 'TUNLS', 'TUNL', 'TUNNL', 'TUNNELS'],
 'UN': ['UNION', 'UN'],
 'UNS': ['UNIONS'],
 'UPAS': ['UNDERPASS'],
 'VIA': ['VIADUCT', 'VDCT', 'VIA', 'VIADCT'],
 'VIS': ['VSTA', 'VIS', 'VISTA', 'VST', 'VIST'],
 'VL': ['VILLE', 'VL'],
 'VLG': ['VILLAG', 'VILLG', 'VILLIAGE', 'VLG', 'VILL', 'VILLAGE'],
 'VLGS': ['VLGS', 'VILLAGES'],
 'VLY': ['VLY', 'VALLEY', 'VALLY', 'VLLY'],
 'VLYS': ['VALLEYS', 'VLYS'],
 'VW': ['VW', 'VIEW'],
 'VWS': ['VWS', 'VIEWS'],
 'WALK': ['WALKS', 'WALK', 'WK'],
 'WALL': ['WALL'],
 'WAY': ['WY', 'WAY'],
 'WAYS': ['WAYS'],
 'WL': ['WELL'],
 'WLS': ['WLS', 'WELLS'],
 'XING': ['CROSSING', 'XING', 'CRSSNG', 'CRSSING'],
 'XRD': ['CROSSROAD']}

########NEW FILE########
__FILENAME__ = tests
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Tests for address parsing.

The LocationTestCase class contains both hand-written tests and a metaclass
that auto-generates tests based on some sample data.
"""

from ebpub.geocoder.parser.parsing import parse, address_combinations, ParsingError, Location
import unittest

class AutoLocationMetaclass(type):
    """
    Metaclass that adds a test method for every combination of test data
    (defined in TEST_DATA).
    """
    def __new__(cls, name, bases, attrs):
        TEST_DATA = (
            # token type, (one-word sample, two-word sample, three-word sample, ...)
            ('number', ('228',)),
            ('pre_dir', ('S',)),
            ('prefix', ('HIGHWAY', 'US HIGHWAY', 'FARM TO MARKET')),
            ('street', ('BROADWAY', 'OLD MILL', 'MARTIN LUTHER KING', 'MARTIN LUTHER KING JR', 'DR MARTIN LUTHER KING JR')),
            ('suffix', ('AVE',)),
            ('post_dir', ('S',)),
            ('city', ('CHICAGO', 'SAN FRANCISCO', 'NEW YORK CITY', 'OLD NEW YORK CITY')),
            ('state', ('IL', 'NEW HAMPSHIRE')),
            ('zip', ('60604',)),
        )
        for token_types in address_combinations():
            test_input = []
            expected = Location()
            for t_type, samples in TEST_DATA:
                count = token_types.count(t_type)
                if count:
                    test_input.append(samples[count-1])
                    expected[t_type] = samples[count-1]

            # Take the normalization into account.
            if expected['state'] == 'NEW HAMPSHIRE':
                expected['state'] = 'NH'

            location = ' '.join(test_input)
            func = lambda self: self.assertParseContains(location, expected)
            func.__doc__ = "generated test: %r" % location
            attrs['test_%s' % '_'.join(token_types)] = func

        return type.__new__(cls, name, bases, attrs)

class LocationTestCase(unittest.TestCase):
    __metaclass__ = AutoLocationMetaclass

    # def assertParses(self, location, expected):
    #     try:
    #         actual = [dict(result) for result in parse(location)]
    #         try:
    #             self.assertEqual(actual, expected)
    #         except AssertionError, e:
    #             raise AssertionError("%r: %s" % (location, e))
    #     except ParsingError, e:
    #         self.fail(e)

    def assertParseContains(self, location, contains):
        # Because the parser is overly greedy and gives many possible
        # responses, it keeps the unit tests tidier and less brittle if we
        # just list one important parse result that we expect, rather than
        # listing every single test result.
        import pprint
        try:
            actual = [dict(result) for result in parse(location)]
        except ParsingError, e:
            self.fail(e)
        else:
            self.assert_(contains in actual,
                         '\n%r\nnot in\n%s' % (contains, pprint.pformat(actual)))

    def test_saint_louis(self):
        self.assertParseContains('11466 S Saint Louis Ave, Chicago, IL, 60655',
            {'number': '11466', 'pre_dir': 'S', 'prefix': None, 'street': 'SAINT LOUIS', 'suffix': 'AVE', 'post_dir': None, 'city': 'CHICAGO', 'state': 'IL', 'zip': '60655'},
        )

    def test_st_louis_ave(self):
        self.assertParseContains('11466 S St Louis Ave',
            {'number': '11466', 'pre_dir': 'S', 'prefix': None, 'street': 'ST LOUIS', 'suffix': 'AVE', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_st_louis_st(self):
        self.assertParseContains('11466 S St Louis St',
            {'number': '11466', 'pre_dir': 'S', 'prefix': None, 'street': 'ST LOUIS', 'suffix': 'ST', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_numbered_street1(self):
        self.assertParseContains('2 W 111th Pl',
            {'number': '2', 'pre_dir': 'W', 'prefix': None, 'street': '111TH', 'suffix': 'PL', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_numbered_street2(self):
        self.assertParseContains('260 W 44th St',
            {'number': '260', 'pre_dir': 'W', 'prefix': None, 'street': '44TH', 'suffix': 'ST', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_numbered_street3(self):
        self.assertParseContains('260 W 44th, New York, NY 10036',
            {'number': '260', 'pre_dir': 'W', 'prefix': None, 'street': '44TH', 'suffix': None, 'post_dir': None, 'city': 'NEW YORK', 'state': 'NY', 'zip': '10036'},
        )

    def test_numbered_street4(self):
        self.assertParseContains('1 5th Ave, New York, NY 10003',
            {'number': '1', 'pre_dir': None, 'prefix': None, 'street': '5TH', 'suffix': 'AVE', 'post_dir': None, 'city': 'NEW YORK', 'state': 'NY', 'zip': '10003'},
        )

    def test_numbered_street5(self):
        self.assertParseContains('329 50 ST, MANHATTAN',
            {'number': '329', 'pre_dir': None, 'prefix': None, 'street': '50TH', 'suffix': 'ST', 'post_dir': None, 'city': 'MANHATTAN', 'state': None, 'zip': None},
        )

    def test_numbered_street6(self):
        self.assertParseContains('329 41 ST, MANHATTAN',
            {'number': '329', 'pre_dir': None, 'prefix': None, 'street': '41ST', 'suffix': 'ST', 'post_dir': None, 'city': 'MANHATTAN', 'state': None, 'zip': None},
        )

    def test_numbered_street7(self):
        self.assertParseContains('329 42 ST, MANHATTAN',
            {'number': '329', 'pre_dir': None, 'prefix': None, 'street': '42ND', 'suffix': 'ST', 'post_dir': None, 'city': 'MANHATTAN', 'state': None, 'zip': None},
        )

    def test_numbered_street8(self):
        self.assertParseContains('329 43 ST, MANHATTAN',
            {'number': '329', 'pre_dir': None, 'prefix': None, 'street': '43RD', 'suffix': 'ST', 'post_dir': None, 'city': 'MANHATTAN', 'state': None, 'zip': None},
        )

    def test_junior(self):
        self.assertParseContains('3624 S. John Hancock Jr. Road',
            {'number': '3624', 'pre_dir': 'S', 'prefix': None, 'street': 'JOHN HANCOCK JR', 'suffix': 'RD', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_nyc_borough(self):
        self.assertParseContains("187 Bedord Ave, Brooklyn, NY",
            {'number': '187', 'pre_dir': None, 'prefix': None, 'street': 'BEDORD', 'suffix': 'AVE', 'post_dir': None, 'city': 'BROOKLYN', 'state': 'NY', 'zip': None},
        )

    def test_avenue_b_nyc(self):
        self.assertParseContains("51 Avenue B, New York, NY",
            {'number': '51', 'pre_dir': None, 'prefix': None, 'street': 'AVENUE B', 'suffix': None, 'post_dir': None, 'city': 'NEW YORK', 'state': 'NY', 'zip': None},
        )

    def test_e20th_st_nyc(self):
        self.assertParseContains("31 East 20th Street, New York, NY",
            {'number': '31', 'pre_dir': 'E', 'prefix': None, 'street': '20TH', 'suffix': 'ST', 'post_dir': None, 'city': 'NEW YORK', 'state': 'NY', 'zip': None},
        )

    def test_fifth_st_standardization(self):
        self.assertParseContains('175 Fifth St Brooklyn NY',
            {'number': '175', 'pre_dir': None, 'prefix': None, 'street': '5TH', 'suffix': 'ST', 'post_dir': None, 'city': 'BROOKLYN', 'state': 'NY', 'zip': None},
        )

    def test_bronx_standardization1(self):
        self.assertParseContains('123 Main St Bronx',
            {'number': '123', 'pre_dir': None, 'prefix': None, 'street': 'MAIN', 'suffix': 'ST', 'post_dir': None, 'city': 'THE BRONX', 'state': None, 'zip': None},
        )

    def test_bronx_standardization2(self):
        self.assertParseContains('123 Main St, The Bronx',
            {'number': '123', 'pre_dir': None, 'prefix': None, 'street': 'MAIN', 'suffix': 'ST', 'post_dir': None, 'city': 'THE BRONX', 'state': None, 'zip': None},
        )

    def test_broadway_simple(self):
        self.assertParseContains('321 BROADWAY, MANHATTAN',
            {'number': '321', 'pre_dir': None, 'prefix': None, 'street': 'BROADWAY', 'suffix': None, 'post_dir': None, 'city': 'MANHATTAN', 'state': None, 'zip': None},
        )

    def test_staten_island1(self):
        self.assertParseContains('321 BROADWAY, STATEN ISLAND',
            {'number': '321', 'pre_dir': None, 'prefix': None, 'street': 'BROADWAY', 'suffix': None, 'post_dir': None, 'city': 'STATEN ISLAND', 'state': None, 'zip': None},
        )

    def test_staten_island2(self):
        self.assertParseContains('349 TRAVIS AVENUE, STATEN ISLAND',
            {'number': '349', 'pre_dir': None, 'prefix': None, 'street': 'TRAVIS', 'suffix': 'AVE', 'post_dir': None, 'city': 'STATEN ISLAND', 'state': None, 'zip': None},
        )

    def test_queens_address_range(self):
        self.assertParseContains('25-82 MAIN ST, QUEENS',
            {'number': '25', 'pre_dir': None, 'prefix': None, 'street': 'MAIN', 'suffix': 'ST', 'post_dir': None, 'city': 'QUEENS', 'state': None, 'zip': None},
        )

    def test_ft_washington_ave(self):
        self.assertParseContains('270 FT WASHINGTON AVENUE, MANHATTAN',
            {'number': '270', 'pre_dir': None, 'prefix': None, 'street': 'FT WASHINGTON', 'suffix': 'AVE', 'post_dir': None, 'city': 'MANHATTAN', 'state': None, 'zip': None},
        )

    def test_east_broadway(self):
        self.assertParseContains('183 EAST BROADWAY, MANHATTAN',
            {'number': '183', 'pre_dir': None, 'prefix': None, 'street': 'EAST BROADWAY', 'suffix': None, 'post_dir': None, 'city': 'MANHATTAN', 'state': None, 'zip': None},
        )

    def test_one_nob_hill(self):
        self.assertParseContains('1 Nob Hill',
            {'number': '1', 'pre_dir': None, 'prefix': None, 'street': 'NOB HILL', 'suffix': None, 'post_dir': None, 'city': None, 'state': None, 'zip': None}
        )

    def test_west_irving_park(self):
        self.assertParseContains('1234 W IRVING PARK',
            {'number': '1234', 'pre_dir': 'W', 'prefix': None, 'street': 'IRVING PARK', 'suffix': None, 'post_dir': None, 'city': None, 'state': None, 'zip': None}
        )

    def test_half_address1(self):
        self.assertParseContains('123 1/2 MAIN ST',
            {'number': '123', 'pre_dir': None, 'prefix': None, 'street': 'MAIN', 'suffix': 'ST', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_half_address2(self):
        self.assertParseContains('123 I/2 MAIN ST',
            {'number': '123', 'pre_dir': None, 'prefix': None, 'street': 'MAIN', 'suffix': 'ST', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_hyphen_space_address1(self):
        self.assertParseContains('123 - 125 MAIN ST',
            {'number': '123', 'pre_dir': None, 'prefix': None, 'street': 'MAIN', 'suffix': 'ST', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_hyphen_space_address2(self):
        self.assertParseContains('123- 125 MAIN ST',
            {'number': '123', 'pre_dir': None, 'prefix': None, 'street': 'MAIN', 'suffix': 'ST', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_hyphen_space_address3(self):
        self.assertParseContains('123 -125 MAIN ST',
            {'number': '123', 'pre_dir': None, 'prefix': None, 'street': 'MAIN', 'suffix': 'ST', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_multiple_hyphen_space_address(self):
        self.assertParseContains('123--125 MAIN ST',
            {'number': '123', 'pre_dir': None, 'prefix': None, 'street': 'MAIN', 'suffix': 'ST', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_letter_in_address(self):
        self.assertParseContains('2833A W CHICAGO AVE',
            {'number': '2833', 'pre_dir': 'W', 'prefix': None, 'street': 'CHICAGO', 'suffix': 'AVE', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_letter_in_address_range(self):
        self.assertParseContains('2833A-2835A W CHICAGO AVE',
            {'number': '2833', 'pre_dir': 'W', 'prefix': None, 'street': 'CHICAGO', 'suffix': 'AVE', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_mies_van_der_rohe_wy(self):
        self.assertParseContains('830 N MIES VAN DER ROHE WY',
            {'number': '830', 'pre_dir': 'N', 'prefix': None, 'street': 'MIES VAN DER ROHE', 'suffix': 'WAY', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_the_bronx_address1(self):
        self.assertParseContains('823 East 147th St, The Bronx',
            {'number': '823', 'pre_dir': 'E', 'prefix': None, 'street': '147TH', 'suffix': 'ST', 'post_dir': None, 'city': 'THE BRONX', 'state': None, 'zip': None},
        )

    def test_the_bronx_address2(self):
        self.assertParseContains('1401 Grand Concourse, The Bronx',
            {'number': '1401', 'pre_dir': None, 'prefix': None, 'street': 'GRAND CONCOURSE', 'suffix': None, 'post_dir': None, 'city': 'THE BRONX', 'state': None, 'zip': None},
        )

    def test_the_bronx_address3(self):
        self.assertParseContains('1110 Bronx River Ave, The Bronx',
            {'number': '1110', 'pre_dir': None, 'prefix': None, 'street': 'BRONX RIVER', 'suffix': 'AVE', 'post_dir': None, 'city': 'THE BRONX', 'state': None, 'zip': None},
        )

    def test_prefix_1(self):
        self.assertParseContains(
            '17 Hwy 101',
            {'number': '17', 'pre_dir': None, 'prefix': 'HIGHWAY', 'street': '101', 'suffix': None, 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_prefix_2(self):
        self.assertParseContains(
            '17 US Hwy 101 N',
            {'number': '17', 'pre_dir': None, 'prefix': 'US HIGHWAY', 'street': '101', 'suffix': None, 'post_dir': 'N', 'city': None, 'state': None, 'zip': None},
        )

    def test_prefix_with_suffix(self):
        self.assertParseContains(
            '17 US Hwy 101 Bypass',
            {'number': '17', 'pre_dir': None, 'prefix': 'US HIGHWAY', 'street': '101', 'suffix': 'BYP', 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_prefix_with_lettered_street(self):
        self.assertParseContains(
            '17 US 9G',
            {'number': '17', 'pre_dir': None, 'prefix': 'US HIGHWAY', 'street': '9G',
             'suffix': None, 'post_dir': None, 'city': None, 'state': None,
             'zip': None},
            )

    def test_interstate_prefix(self):
        self.assertParseContains(
            '17 I 101',
            {'number': '17', 'pre_dir': None, 'prefix': 'INTERSTATE', 'street': '101', 'suffix': None, 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_interstate_prefix_no_space(self):
        self.assertParseContains(
            '17 I95 S',
            {'number': '17', 'pre_dir': None, 'prefix': 'INTERSTATE', 'street': '95', 'suffix': None, 'post_dir': 'S', 'city': None, 'state': None, 'zip': None},
        )

    def test_state_prefix(self):
        self.assertParseContains(
            '123 NY 9G',
            {'number': '123', 'pre_dir': None, 'prefix': 'NY HIGHWAY', 'street': '9G', 'suffix': None, 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    def test_state_prefix_2(self):
        self.assertParseContains(
            '123 NY STATE HIGHWAY 9G',
            {'number': '123', 'pre_dir': None, 'prefix': 'NY STATE HIGHWAY', 'street': '9G', 'suffix': None, 'post_dir': None, 'city': None, 'state': None, 'zip': None},
        )

    # def test_state_prefix_3(self):
    #     self.assertParseContains(
    #         '123 NY COUNTY RD 9G',
    #         {'number': '123', 'pre_dir': None, 'prefix': 'NY COUNTY ROAD', 'street': '9G', 'suffix': None, 'post_dir': None, 'city': None, 'state': None, 'zip': None},
    #     )


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = reverse
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

import unittest
from psycopg2 import Binary
from django.contrib.gis.geos import Point
from django.db import connection

class ReverseGeocodeError(Exception):
    pass

def reverse_geocode(point):
    """
    Looks up the nearest block to the point.

    Argument can be either a Point instance, or an (x, y) tuple, or a
    WKT string.

    Returns (block, distance (in degrees I think??))
    """
    # Defer import to avoid cyclical import.
    from ebpub.streets.models import Block

    if isinstance(point, basestring):
        from django.contrib.gis.geos import fromstr
        point = fromstr(point, srid=4326)
    elif isinstance(point, tuple) or isinstance(point, list):
        point = Point(tuple(point))
    # In degrees for now because transforming to a projected space is
    # too slow for this purpose. TODO: store projected versions of the
    # locations alongside the canonical lng/lat versions.
    min_distance = 0.007
    # We use min_distance to cut down on the searchable space, because
    # the distance query we do next that actually compares distances
    # between geometries does not use the spatial index. TODO: convert
    # this to GeoDjango syntax. Should be possible but there are some
    # subtleties / performance issues with the DB API.
    cursor = connection.cursor()
    # Switched to WKT rather than WKB, because constructing WKB as a
    # string leads to psycopg2 getting confused by '%' as per
    # http://stackoverflow.com/questions/1734814/why-isnt-psycopg2-executing-any-of-my-sql-functions-indexerror-tuple-index-ou
    # We could probably do something like
    # str(Binary(point.wkb)).replace('%', '%%') ... but I don't know
    # if that could have other problems?
    # Or maybe a Binary() could be passed as a parameter to cursor.execute().
    # Anyway, WKT is safe.
    params = {'field_list': ', '.join([f.column for f in Block._meta.fields]),
              'pt_wkt': point.wkt,
              'geom_fieldname': 'geom',
              'tablename': Block._meta.db_table,
              'min_distance': min_distance
              }
    sql = """
        SELECT %(field_list)s, ST_Distance(ST_GeomFromText('%(pt_wkt)s', 4326), %(geom_fieldname)s) AS "dist"
        FROM %(tablename)s
        WHERE id IN
            (SELECT id
             FROM %(tablename)s
             WHERE ST_DWithin(%(geom_fieldname)s, ST_GeomFromText('%(pt_wkt)s', 4326), %(min_distance)s))
        ORDER BY "dist"
        LIMIT 1;
    """ % params
    cursor.execute(sql)
    num_fields = len(Block._meta.fields)
    rows = cursor.fetchall()
    if not rows:
        raise ReverseGeocodeError('No results')
    block, distance = [(Block(*row[:num_fields]), row[-1]) for row in rows][0]
    return block, distance

########NEW FILE########
__FILENAME__ = geocoder
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from ebpub.geocoder import SmartGeocoder, AmbiguousResult, InvalidBlockButValidStreet, DoesNotExist
import django.test
import mock


class TestSmartGeocoder(django.test.TestCase):
    fixtures = ['wabash.yaml']

    def setUp(self):
        self.geocoder = SmartGeocoder(use_cache=False)

    @mock.patch('ebpub.streets.models.get_metro')
    def test_address_geocoder(self, mock_get_metro):
        mock_get_metro.return_value = {'city_name': 'CHICAGO',
                                       'multiple_cities': False}
        result = self.geocoder.geocode('200 S Wabash Ave')
        self.assertEqual(result['city'], 'Chicago')
        self.assertEqual(result['address'], '200 S Wabash Ave.')

    @mock.patch('ebpub.streets.models.get_metro')
    def test_address_geocoder__wrong_suffix_works(self, mock_get_metro):
        mock_get_metro.return_value = {'city_name': 'CHICAGO',
                                       'multiple_cities': False}
        result = self.geocoder.geocode('220 S Wabash St')
        self.assertEqual(result['address'], '220 S Wabash Ave.')
        # Or none at all.
        result = self.geocoder.geocode('220 S Wabash')
        self.assertEqual(result['address'], '220 S Wabash Ave.')

    @mock.patch('ebpub.streets.models.get_metro')
    def test_address_geocoder_ambiguous(self, mock_get_metro):
        mock_get_metro.return_value = {'city_name': 'CHICAGO',
                                       'multiple_cities': False}
        # Ambiguous because of missing pre_dir.
        self.assertRaises(AmbiguousResult, self.geocoder.geocode, '220 Wabash')

    def test_address_geocoder_invalid_block(self):
        self.assertRaises(InvalidBlockButValidStreet,
                          self.geocoder.geocode, '100000 S Wabash')

    @mock.patch('ebpub.streets.models.get_metro')
    def test_block_geocoder(self, mock_get_metro):
        mock_get_metro.return_value = {'city_name': 'CHICAGO',
                                       'multiple_cities': False}
        address = self.geocoder.geocode('200 block of Wabash')
        self.assertEqual(address['city'], 'Chicago')

    def test_intersection_geocoder(self):
        address = self.geocoder.geocode('Wabash and Jackson')
        self.assertEqual(address['city'], 'CHICAGO')


class TestFullGeocode(django.test.TestCase):

    fixtures = ['wabash.yaml', 'places.yaml']

    def test_full_geocode_place(self):
        from ebpub.geocoder.base import full_geocode
        place = full_geocode('Sears Tower', search_places=True)
        self.assertEqual(place['type'], 'place')
        self.assertEqual(place['result'].normalized_name, 'SEARS TOWER')

    def test_full_geocode__no_place(self):
        from ebpub.geocoder.base import full_geocode, DoesNotExist
        self.assertRaises(DoesNotExist, full_geocode, 'Bogus Place Name')

    def test_full_geocode__bad_block_on_good_street(self):
        from ebpub.geocoder.base import full_geocode
        # This block goes up to 298.
        result = full_geocode('299 S. Wabash Ave.', convert_to_block=False)
        self.assert_(result['ambiguous'])
        self.assertEqual(result['type'], 'block')
        self.assertEqual(result['street_name'], 'Wabash Ave.')
        self.assertEqual(len(result['result']), 3)

    def test_full_geocode__convert_to_block(self):
        from ebpub.geocoder.base import full_geocode
        # This block goes up to 298.
        result = full_geocode('299 S. Wabash Ave.', convert_to_block=True)
        self.failIf(result['ambiguous'])
        self.assertEqual(result['type'], 'block')
        self.assertEqual(result['result']['address'], '200 block of S. Wabash Ave.')
        # This is also the default behavior.
        self.assertEqual(result, full_geocode('299 S. Wabash Ave.'))


class TestDisambiguation(django.test.TestCase):

    def test_disambiguate__no_args(self):
        from ebpub.geocoder.base import disambiguate
        self.assertEqual(disambiguate([]), [])
        self.assertEqual(disambiguate([]), [])

    def test_disambiguate__guess(self):
        from ebpub.geocoder.base import disambiguate
        # 'guess' doesn't do anything unless we have something to filter on.
        self.assertEqual(disambiguate([], zipcode="10014", guess=True),
                         [])
        self.assertEqual(disambiguate([{1:1}], zipcode="10014", guess=True),
                         [{1:1}])
        self.assertEqual(disambiguate([{1:1}, {2:2}, {3:3}], zipcode="10014", guess=True),
                         [{1:1}])

    def test_disambiguate__city(self):
        from ebpub.geocoder.base import disambiguate
        input_results = [{'name': 'bob', 'city': 'Brooklyn'},
                         {'name': 'bob', 'city': 'Manchester'},
                         {'name': 'bob', 'city': 'Oslo'},
                         {'name': 'joe', 'city': 'Oslo'},
                         ]
        self.assertEqual(disambiguate(input_results, city='Some Other City'),
                         input_results)
        self.assertEqual(disambiguate(input_results, city='Brooklyn'),
                         [{'name': 'bob', 'city': 'Brooklyn'}])
        self.assertEqual(disambiguate(input_results, city='Oslo'),
                         [{'name': 'bob', 'city': 'Oslo'},
                          {'name': 'joe', 'city': 'Oslo'}])
        self.assertEqual(disambiguate(input_results, city='Oslo', guess=True),
                         [{'name': 'bob', 'city': 'Oslo'}])


    def test_disambiguate__state(self):
        from ebpub.geocoder.base import disambiguate
        input_results = [{'name': 'bob', 'state': 'MA'},
                         {'name': 'bob', 'state': 'TN'},
                         {'name': 'bob', 'state': 'WA'},
                         {'name': 'joe', 'state': 'WA'},
                         ]
        self.assertEqual(disambiguate(input_results, state='Some Other State'),
                         input_results)
        self.assertEqual(disambiguate(input_results, state='WA'),
                         [{'name': 'bob', 'state': 'WA'},
                          {'name': 'joe', 'state': 'WA'},
                          ])

    def test_disambiguate__zip(self):
        from ebpub.geocoder.base import disambiguate
        input_results = [{'name': 'bob', 'zip': '12345'},
                         {'name': 'bob', 'zip': '67890'},
                         {'name': 'bob', 'zip': '55555'},
                         {'name': 'joe', 'zip': '55555'},
                         ]
        self.assertEqual(disambiguate(input_results, zipcode='Some Other Zipcode'),
                         input_results)
        self.assertEqual(disambiguate(input_results, zipcode='67890'),
                         [{'name': 'bob', 'zip': '67890'},])
        # You can spell it either 'zipcode' or 'zip'.
        self.assertEqual(disambiguate(input_results, zip='67890'),
                         [{'name': 'bob', 'zip': '67890'},])


    def test_disambiguate__all(self):
        from ebpub.geocoder.base import disambiguate
        input_results = [
            {'name': 'bob', 'city': 'C1', 'state': 'S2', 'zip': 'Z1'},
            {'name': 'bob', 'city': 'C1', 'state': 'S1', 'zip': 'Z1'},
            {'name': 'bob', 'city': 'C1', 'state': 'S1', 'zip': 'Z2'},
            {'name': 'bob', 'city': 'C2', 'state': 'S1', 'zip': 'Z1'},
            {'name': 'bob', 'city': 'C2', 'state': 'S1', 'zip': 'Z1', 'suffix': 'SF1'},
            ]
        self.assertEqual(disambiguate(input_results, city='C1', state='S1', zipcode='Z1'),
                         [{'name': 'bob', 'city': 'C1', 'state': 'S1', 'zip': 'Z1'}])

        # We could pass other args, eg. 'suffix', although
        # in practice this would require those keys to be present in Address dicts.
        self.assertEqual(disambiguate(input_results, suffix='SF1'),
                         [{'name': 'bob', 'city': 'C2', 'state': 'S1', 'zip': 'Z1', 'suffix': 'SF1'}])



if __name__ == '__main__':
    pass

########NEW FILE########
__FILENAME__ = parser
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from ebpub.geocoder.parser.parsing import strip_unit
import unittest

class StripUnitTestCase(unittest.TestCase):
    def assertStripUnit(self, text, expected):
        self.assertEqual(strip_unit(text), expected)

    def test_suite01(self):
        self.assertStripUnit('123 Main St Suite 1', '123 Main St')

    def test_suite02(self):
        self.assertStripUnit('123 Main St, Suite 1', '123 Main St')

    def test_suite03(self):
        self.assertStripUnit('123 Main St, Suite 2', '123 Main St')

    def test_suite04(self):
        self.assertStripUnit('123 Main St, Suite #2', '123 Main St')

    def test_suite05(self):
        self.assertStripUnit('123 Main St, Suite 465', '123 Main St')

    def test_suite06(self):
        self.assertStripUnit('123 Main St, Suite A', '123 Main St')

    def test_suite07(self):
        self.assertStripUnit('123 Main St, Suite AB', '123 Main St')

    def test_suite08(self):
        self.assertStripUnit('123 Main St, Suite 1A', '123 Main St')

    def test_suite09(self):
        self.assertStripUnit('123 Main St, Suite 2B', '123 Main St')

    def test_suite10(self):
        self.assertStripUnit('123 Main St, Suite 1-A', '123 Main St')

    def test_suite11(self):
        self.assertStripUnit('123 Main St, Suite #1', '123 Main St')

    def test_suite12(self):
        self.assertStripUnit('123 Main St, Suite #1A', '123 Main St')

    def test_suite13(self):
        self.assertStripUnit('123 Main St, Suite #1-A', '123 Main St')

    def test_suite14(self):
        self.assertStripUnit('123 Main St, Suite #A', '123 Main St')

    def test_ste1(self):
        self.assertStripUnit('123 Main St, Ste 14', '123 Main St')

    def test_ste2(self):
        self.assertStripUnit('123 Main St, Ste. 14', '123 Main St')

    def test_unit1(self):
        self.assertStripUnit('123 Main St, Unit 1W', '123 Main St')

    def test_hash1(self):
        self.assertStripUnit('123 Main St, #1', '123 Main St')

    def test_hash_dash(self):
        self.assertStripUnit('123 Main St, Ste K-#b', '123 Main St')

    def test_apt01(self):
        self.assertStripUnit('123 Main St, Apt 1', '123 Main St')

    def test_apt02(self):
        self.assertStripUnit('123 Main St, Apt. 1', '123 Main St')

    def test_space01(self):
        self.assertStripUnit('3015 Grand Avenue, Space 310', '3015 Grand Avenue')

    def test_unit_with_colon(self):
        self.assertStripUnit('325 Arlington Ave Unit: 140', '325 Arlington Ave')

if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = allmetros
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings

METRO_LIST = settings.METRO_LIST
METRO_DICT = dict([(m['short_name'], m) for m in METRO_LIST])

def get_metro(short_name=None):
    """
    Get the named dictionary from settings.METRO_LIST.

    Defaults to the one whose short_name == settings.SHORT_NAME.
    """
    if short_name is None:
        short_name = settings.SHORT_NAME
    return METRO_DICT[short_name]

########NEW FILE########
__FILENAME__ = loader
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib.gis.gdal import DataSource
from django.contrib.gis.geos import MultiPolygon
from ebpub.metros.allmetros import METRO_DICT
from ebpub.metros.models import Metro

class Usage(Exception):
    pass

def load_metro(short_name, shpfile, layer_id=0):
    """
    Creates a new Metro object, populating geometry from shapefile and
    the rest of its fields from the old settings module.
    """
    ds = DataSource(shpfile)
    lyr = ds[layer_id]
    model_fields = set([f.name for f in Metro._meta.fields])
    metro_from_settings = METRO_DICT[short_name]
    settings_fields = set(metro_from_settings.keys())
    metro = Metro()
    for f in (model_fields & settings_fields):
        setattr(metro, f, metro_from_settings[f])
    metro.name = metro_from_settings['city_name']
    metro_geom = None
    for feature in lyr:
        if metro_geom is None:
            geom = feature.geom.geos
            geom_type = geom.geom_type
            if geom_type == 'Polygon':
                # Normalize to MultiPolygon
                metro_geom = MultiPolygon([geom])
            elif geom_type == 'MultiPolygon':
                metro_geom = geom
            else:
                raise ValueError('expected Polygon or MultiPolygon, got %s' % geom_type)
    metro.location = metro_geom
    metro.save()
    return metro

def main():
    import getopt
    import sys

    (opts, args) = getopt.getopt(sys.argv[1:], 'h', ['help'])
    try:
        for opt, value in opts:
            if opt in ('-h', '--help'):
                raise Usage()
        if len(args) != 2:
            raise Usage()
        try:
            metro = load_metro(args[0], args[1])
        except ValueError, e:
            print >> sys.stderr, e
            return 1
        else:
            print 'Created %s' % metro
            return 0
    except Usage:
        print >> sys.stderr, '%s: <short_name> /path/to/shapefile' % sys.argv[0]
        return 1

if __name__ == '__main__':
    import sys
    sys.exit(main())

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Metro'
        db.create_table('metros_metro', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=64)),
            ('short_name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=64)),
            ('metro_name', self.gf('django.db.models.fields.CharField')(max_length=64)),
            ('population', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('area', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('is_public', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('multiple_cities', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('state', self.gf('django.db.models.fields.CharField')(max_length=2)),
            ('state_name', self.gf('django.db.models.fields.CharField')(max_length=64)),
            ('location', self.gf('django.contrib.gis.db.models.fields.MultiPolygonField')()),
        ))
        db.send_create_signal('metros', ['Metro'])

        # Adding unique constraint on 'Metro', fields ['name', 'state']
        db.create_unique('metros_metro', ['name', 'state'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Metro', fields ['name', 'state']
        db.delete_unique('metros_metro', ['name', 'state'])

        # Deleting model 'Metro'
        db.delete_table('metros_metro')


    models = {
        'metros.metro': {
            'Meta': {'unique_together': "(('name', 'state'),)", 'object_name': 'Metro'},
            'area': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'location': ('django.contrib.gis.db.models.fields.MultiPolygonField', [], {}),
            'metro_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'multiple_cities': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'short_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'state_name': ('django.db.models.fields.CharField', [], {'max_length': '64'})
        }
    }

    complete_apps = ['metros']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from django.contrib.gis.db import models

class MetroManager(models.GeoManager):
    def get_current(self):
        return self.get(short_name=settings.SHORT_NAME)

    def containing_point(self, point):
        # First pass, just check to see if it's in the bounding box --
        # this is faster for checking across all metros
        metros = self.filter(location__bbcontains=point)
        n = metros.count()
        if not n:
            raise Metro.DoesNotExist()
        else:
            # Now do the slower but more accurate lookup to see if the
            # point is completely within the actual bounds of the
            # metro. Note that we could also have hit two or more
            # metros if they have overlapping bounding boxes.
            matches = 0
            for metro in metros:
                if metro.location.contains(point):
                    matches += 1
            if matches > 1:
                # Something went wrong, it would mean the metros have
                # overlapping borders
                raise Exception('more than one metro found to contain this point')
            elif matches == 0:
                raise Metro.DoesNotExist()
            else:
                return metro

class Metro(models.Model):
    """
    Note this is currently not used in the openblock codebase;
    settings.METRO_LIST is used instead.

    Metro is an in-database representation of a metropolitan region
    covered by one OpenBlock site.  These look to be equivalent to the
    data in settings.METRO_LIST.

    It's unclear what the history is. Possibly, everyblock.com was in
    the process of transitioning to in-database metro data at the time
    they released their source code?

    Given that the concept of 'metros' is a lot less important to
    OpenBlock than it was to Everyblock.com, we can possibly safely
    remove this.
    """
    name = models.CharField(max_length=64)
    short_name = models.CharField(max_length=64, unique=True)
    metro_name = models.CharField(max_length=64)
    population = models.IntegerField(null=True, blank=True)
    area = models.IntegerField(null=True, blank=True)
    is_public = models.BooleanField(default=False)
    multiple_cities = models.BooleanField(default=False)
    state = models.CharField(max_length=2)
    state_name = models.CharField(max_length=64)
    location = models.MultiPolygonField()
    objects = MetroManager()

    def __unicode__(self):
        return self.name

    class Meta:
        unique_together = ('name', 'state')

########NEW FILE########
__FILENAME__ = tests
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.test import TestCase
from django.contrib.gis.geos import Point
from ebpub.metros.models import Metro
import logging

pt_in_chicago = Point((-87.68489561595398, 41.852929331184384)) # point in center of Chicago
pt_in_chi_bbox = Point((-87.83384627077956, 41.85365447332586)) # point just west of Chicago's border but due south of O'Hare
pt_in_lake_mi = Point((-86.99514699540548, 41.87468001919902)) # point way out in Lake Michigan

class MetroTest(TestCase):
    fixtures = ['metros.json']

    def test_point_in_metro(self):
        # Tests finding a metro with a point contained by its boundary
        self.assertEquals(Metro.objects.containing_point(pt_in_chicago).name, 'Chicago')

    def test_point_in_bbox_not_in_metro(self):
        # Tests with a point in the metro's bounding box but not in its boundary
        self.assertRaises(Metro.DoesNotExist, Metro.objects.containing_point, pt_in_chi_bbox)

    def test_point_not_in_metro(self):
        # Tests with a point not in any metro
        self.assertRaises(Metro.DoesNotExist, Metro.objects.containing_point, pt_in_lake_mi)

class MetroViewsTest(TestCase):
    fixtures = ['metros.json']

    # De-hardcoding ebpub's URLs means that to test 404 pages, we need
    # ebpub's URL config or else the 404 page blows up with NoReverseMatch.
    # So, cook up a URL config that includes both.
    urls = 'ebpub.metros.test_urls'

    def setUp(self):
        # Don't log 404 warnings, we expect a lot of them during these
        # tests.
        logger = logging.getLogger('django.request')
        self._previous_level = logger.getEffectiveLevel()
        logger.setLevel(logging.ERROR)

    def tearDown(self):
        # Restore old log level.
        logger = logging.getLogger('django.request')
        logger.setLevel(self._previous_level)

    def test_lookup_metro_success(self):
        # Tests getting a successful JSON response from a lng/lat query
        response = self.client.get('/metros/lookup/', {'lng': pt_in_chicago.x, 'lat': pt_in_chicago.y})
        self.assertContains(response, 'Chicago', status_code=200)
        self.assertEqual(response['content-type'], 'application/javascript')

    def test_lookup_metro_in_bbox_fails(self):
        # Tests getting a 404 from a lng/lat query not quite in the metro
        response = self.client.get('/metros/lookup/', {'lng': pt_in_chi_bbox.x, 'lat': pt_in_chi_bbox.y})
        self.assertEqual(response.status_code, 404)

    def test_lookup_metro_fails(self):
        # Tests getting a 404 from a lng/lat query not in any metro
        response = self.client.get('/metros/lookup/', {'lng': pt_in_lake_mi.x, 'lat': pt_in_lake_mi.y})
        self.assertEqual(response.status_code, 404)

########NEW FILE########
__FILENAME__ = test_urls
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf.urls.defaults import patterns, handler404, handler500, include

urlpatterns = patterns(
    '',
    (r'^metros/', include('ebpub.metros.urls')),
    (r'^/', include('ebpub.urls')),
)

########NEW FILE########
__FILENAME__ = urls
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf.urls.defaults import patterns, handler404, handler500
from django.views.generic import list_detail
from ebpub.metros import views
from ebpub.metros.models import Metro

urlpatterns = patterns('',
    (r'^$', list_detail.object_list, {'queryset': Metro.objects.order_by('name'), 'template_object_name': 'metro'}),
    (r'^lookup/$', views.lookup_metro),
)

########NEW FILE########
__FILENAME__ = views
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib.gis.geos import Point
from django.http import HttpResponse, Http404
from django.utils import simplejson as json
from ebpub.metros.models import Metro

def lookup_metro(request):
    """
    Lookups up a metro that contains the point represented by the two
    GET parameters, ``lng`` and ``lat``.

    Returns a JSON object representing the Metro, minus the actual
    geometry.
    """
    try:
        lng = float(request.GET['lng'])
        lat = float(request.GET['lat'])
    except (KeyError, ValueError, TypeError):
        raise Http404('Missing/invalid lng and lat query parameters')

    try:
        metro = Metro.objects.containing_point(Point(lng, lat))
    except Metro.DoesNotExist:
        raise Http404("Couldn't find any metro matching that query")

    fields = [f.name for f in metro._meta.fields]
    fields.remove('location')
    metro = dict([(f, metro.serializable_value(f)) for f in fields])

    return HttpResponse(json.dumps(metro), mimetype='application/javascript')

########NEW FILE########
__FILENAME__ = admin
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from .models import NewsItemFlag
from django import forms
from django.conf.urls.defaults import patterns, url
from django.contrib import messages
from django.contrib.gis import admin
from django.forms.widgets import Widget
from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.utils.safestring import mark_safe
from ebpub.geoadmin import OSMModelAdmin


class ModerationWidget(Widget):

    instance = None  # Gets bound at widget init time.

    def render(self, name, value, attrs=None):
        # TODO: this is OK, but if the instance isn't saved yet, I'd
        # like to totally hide the widget label too.
        if self.instance and self.instance.pk is not None:
            output = u'''
        <a href="moderate/?delete=1" class="button">Delete News Item!</a>
        <a href="moderate/?approve=1" class="button">Approve it! (un-flag)</a>
'''
            return mark_safe(output)
        return u''

class ModerationForm(forms.ModelForm):
    class Meta:
        model = NewsItemFlag

    def __init__(self, *args, **kwargs):
        super(ModerationForm, self).__init__(*args, **kwargs)
        self.fields['moderate'].widget.instance = self.instance

    moderate = forms.CharField(widget=ModerationWidget(), required=False)


def bulk_delete_action(modeladmin, request, queryset):
    """
    Delete a batch of NewsItemFlags and their associated NewsItems.
    """
    # Admin bulk action as per
    # https://docs.djangoproject.com/en/1.3/ref/contrib/admin/actions/
    ids = [v['news_item_id'] for v in queryset.values('news_item_id')]
    queryset.delete()
    from ebpub.db.models import NewsItem
    NewsItem.objects.filter(id__in=ids).delete()
    messages.add_message(request, messages.INFO,
                         u'%d NewsItems, and all associated flags, deleted' % len(ids))

bulk_delete_action.short_description = u'Delete all selected News Items'

def bulk_approve_action(modeladmin, request, queryset):
    """
    Approve a batch of NewsItemFlags.
    """
    # Admin bulk action as per
    # https://docs.djangoproject.com/en/1.3/ref/contrib/admin/actions/
    queryset.update(state='approved')
    messages.add_message(request, messages.INFO, u'%d flagged items approved'
                         % queryset.count())

bulk_approve_action.short_description = u'Approve all selected NewsItems (un-flag)'


class NewsItemFlagAdmin(OSMModelAdmin):

    # We want new items first.
    ordering = ('-state', '-submitted')

    form = ModerationForm

    list_display = ('item_title', 'item_schema', 'state', 'reason', 'submitted', 'updated')
    search_fields = ('item_title', 'item_description', 'comment',)

    # TODO: filtering on news_item__schema__slug gives the filter the label 'slug',
    # which is not very user-friendly.  Don't see any way around that?
    list_filter = ('reason', 'state', 'news_item__schema__slug',)

    raw_id_fields = ('news_item',)

    date_hierarchy = 'submitted'
    readonly_fields = (
        'state',
        'submitted', 'updated',
        'view_item',
        'item_title', 'item_schema', 'item_description', 'item_original_url',
        'item_pub_date',
        )

    fieldsets = (
        (None, {'fields': ('moderate',
                           'reason',
                           'news_item',
                           'comment',
                           'state',
                           'submitted', 'updated',
                          )
                }),
        ('NewsItem info', {'fields': readonly_fields[3:]}),
        )

    actions = [bulk_approve_action, bulk_delete_action]

    def get_urls(self):
        urls = patterns(
            '',
            url(r'^(.+)/moderate/$', self.admin_site.admin_view(self.handle_moderation)),
            )
        urls = urls + super(NewsItemFlagAdmin, self).get_urls()
        return urls

    def handle_moderation(self, request, object_id):
        """
        View to delete or approve a single flagged item.
        """
        deleting = request.REQUEST.get('delete')
        approving = request.REQUEST.get('approve')
        qs = self.form.Meta.model.objects.filter(id=object_id)
        if request.method == 'GET':
            context = RequestContext(request,
                                     {'deleting': deleting, 'approving': approving,})
            return render_to_response('moderation/moderate_confirmation.html', context)
        elif request.method == 'POST':
            if deleting:
                bulk_delete_action(self, request, qs)
            elif approving:
                bulk_approve_action(self, request, qs)
        return HttpResponseRedirect('../../')

admin.site.register(NewsItemFlag, NewsItemFlagAdmin)

########NEW FILE########
__FILENAME__ = forms
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from .models import NewsItemFlag
from django import forms

class NewsItemFlagForm(forms.ModelForm):
    class Meta:
        model = NewsItemFlag
        widgets = {
            'news_item': forms.HiddenInput,  # Derived from URI.
            }
        exclude = ('state',) # Default value is OK.

    user = forms.CharField(label='Email')

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'NewsItemFlag'
        db.create_table('moderation_newsitemflag', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('news_item', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='moderation_newsitemflag_related', null=True, to=orm['db.NewsItem'])),
            ('reason', self.gf('django.db.models.fields.CharField')(max_length=128, db_index=True)),
            ('user', self.gf('django.db.models.fields.CharField')(default='anonymous', max_length=128, null=True, blank=True)),
            ('comment', self.gf('django.db.models.fields.CharField')(max_length=512, null=True, blank=True)),
            ('submitted', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('state', self.gf('django.db.models.fields.CharField')(default='new', max_length=64, db_index=True, blank=True)),
        ))
        db.send_create_signal('moderation', ['NewsItemFlag'])

        # Adding model 'CommentFlag'
        db.create_table('moderation_commentflag', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('news_item', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='moderation_commentflag_related', null=True, to=orm['db.NewsItem'])),
            ('reason', self.gf('django.db.models.fields.CharField')(max_length=128, db_index=True)),
            ('user', self.gf('django.db.models.fields.CharField')(default='anonymous', max_length=128, null=True, blank=True)),
            ('comment', self.gf('django.db.models.fields.CharField')(max_length=512, null=True, blank=True)),
            ('submitted', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('updated', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('state', self.gf('django.db.models.fields.CharField')(default='new', max_length=64, db_index=True, blank=True)),
        ))
        db.send_create_signal('moderation', ['CommentFlag'])


    def backwards(self, orm):
        
        # Deleting model 'NewsItemFlag'
        db.delete_table('moderation_newsitemflag')

        # Deleting model 'CommentFlag'
        db.delete_table('moderation_commentflag')


    models = {
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date.today', 'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'+'", 'null': 'True', 'to': "orm['db.Location']"}),
            'location_set': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Location']", 'null': 'True', 'through': "orm['db.NewsItemLocation']", 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_flagging': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date(1970, 1, 1)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'moderation.commentflag': {
            'Meta': {'ordering': "('news_item',)", 'object_name': 'CommentFlag'},
            'comment': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True', 'null': 'True'}),
            'user': ('django.db.models.fields.CharField', [], {'default': "'anonymous'", 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'moderation_commentflag_related'", 'null': 'True', 'to': "orm['db.NewsItem']"}),
            'reason': ('django.db.models.fields.CharField', [], {'max_length': '128', 'db_index': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'default': "'new'", 'max_length': '64', 'db_index': 'True', 'blank': 'True'}),
            'submitted': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        },
        'moderation.newsitemflag': {
            'Meta': {'ordering': "('news_item',)", 'object_name': 'NewsItemFlag'},
            'comment': ('django.db.models.fields.CharField', [], {'max_length': '512', 'blank': 'True', 'null': 'True'}),
            'user': ('django.db.models.fields.CharField', [], {'default': "'anonymous'", 'max_length': '128', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'moderation_newsitemflag_related'", 'null': 'True', 'to': "orm['db.NewsItem']"}),
            'reason': ('django.db.models.fields.CharField', [], {'max_length': '128', 'db_index': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'default': "'new'", 'max_length': '64', 'db_index': 'True', 'blank': 'True'}),
            'submitted': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['moderation']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Users can flag NewsItems or comments as spam, offensive, or 'other'.
"""

from django.contrib.gis.db import models
from django.utils.safestring import mark_safe
from ebpub.db.models import NewsItem

class Flag(models.Model):
    class Meta:
        abstract = True
        ordering = ('news_item',)

    news_item = models.ForeignKey(NewsItem, null=True, blank=True,
                                  related_name="%(app_label)s_%(class)s_related")

    reason = models.CharField(max_length=128, db_index=True,
                              choices=(('spam', u'Spam'),
                                       ('inappropriate', u'Inappropriate'),
                                       ('other', u'other (please explain below)')),
                              help_text=u'Why are you flagging this item?')

    user = models.CharField(max_length=128, null=True, blank=True,
                            default='anonymous')

    comment = models.CharField(max_length=512, blank=True, null=True)

    submitted = models.DateTimeField(auto_now_add=True)

    updated = models.DateTimeField(auto_now=True)

    state = models.CharField(max_length=64, db_index=True,
                             choices=(('new', u'New'),
                                      ('approved', u'Item Approved'),
                                      ),
                             blank=True,
                             default='new',
                             )



    # Extra stuff for admin convenience.
    @property
    def item_title(self):
        return self.news_item.title

    @property
    def item_schema(self):
        return self.news_item.schema.slug

    @property
    def item_description(self):
        return self.news_item.description

    @property
    def item_original_url(self):
        return self.news_item.url

    @property
    def item_pub_date(self):
        return self.news_item.pub_date

    @property
    def view_item(self):
        _url = self.news_item.item_url()
        return mark_safe('<a href="%s">%s</a>' % (_url, _url))


class NewsItemFlag(Flag):
    """
    Flags on NewsItems.
    """

class CommentFlag(Flag):
    """
    Flags on Comments.
    """

########NEW FILE########
__FILENAME__ = urls
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf.urls.defaults import patterns, url
from ebpub.moderation import views

urlpatterns = patterns(
    '',
    url(r'^flag/(?P<newsitem_id>.+)/$', views.newsitem_flag, name="moderation_flag_form"),
)

########NEW FILE########
__FILENAME__ = views
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from .forms import NewsItemFlagForm
from .models import NewsItemFlag
from django.db.models import Count
from django.shortcuts import get_object_or_404
from django.views.decorators.csrf import csrf_protect
from ebpub.db.models import NewsItem
from ebpub.utils.view_utils import eb_render

@csrf_protect
def newsitem_flag(request, newsitem_id):
    ni = get_object_or_404(NewsItem.objects.by_request(request), id=newsitem_id)
    flags = NewsItemFlag.objects.filter(news_item=ni).exclude(state='approved')
    flag_counts = flags.values('reason').annotate(count=Count('id')).order_by()

    context = {
        'flag_counts': flag_counts,
        'news_item_id': newsitem_id,
        }
    if request.method == 'POST':
        form = NewsItemFlagForm(request.POST)
        context['form'] = form
        if form.is_valid():
            form.save()
            return eb_render(request, 'moderation/flagged.html', context)

    else:
        form = NewsItemFlagForm()
        context['form'] = form

    # Initial values are easier to set here since we have access to the request,
    # and the Form doesn't.
    form.fields['news_item'].initial = str(newsitem_id)
    if not request.user.is_anonymous():
        form.fields['user'].initial = request.user.email

    context['form'] = form

    return eb_render(request, 'moderation/flag_form.html', context)

########NEW FILE########
__FILENAME__ = monkeypatches
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
This file contains monkey-patches for upstream code that we don't wish
to fork, eg. core Django features that haven't landed in the version
of Django we need, etc.

These patches were developed against Django 1.3.
If/when upgrading DJango to 1.4 or later, this file will need a full audit.

"""


from django.utils.encoding import smart_unicode
from django.core.serializers import base

####################################################################
# Support for "natural keys" in fixtures.
# See http://code.djangoproject.com/ticket/13252
####################################################################


# django.core.serializers.base.build_instance
def build_instance(Model, data, db):
    """
    Build a model instance.

    If the model instance doesn't have a primary key and the model supports
    natural keys, try to retrieve it from the database.
    """
    obj = Model(**data)
    if obj.pk is None and hasattr(Model, 'natural_key') and\
            hasattr(Model._default_manager, 'get_by_natural_key'):
        pk = obj.natural_key()
        try:
            obj.pk = Model._default_manager.db_manager(db)\
                                           .get_by_natural_key(*pk).pk
        except Model.DoesNotExist:
            pass
    return obj

# python.Serializer.end_object
def end_object(self, obj):
    data = {
        "model": smart_unicode(obj._meta),
        "fields": self._current
    }
    if not self.use_natural_keys or not hasattr(obj, 'natural_key'):
        data['pk'] = smart_unicode(obj._get_pk_val(), strings_only=True)
    self.objects.append(data)
    self._current = None



from django.db import models, DEFAULT_DB_ALIAS

# django.core.serializers.python.Deserializer
def Deserializer(object_list, **options):
    """
    Deserialize simple Python objects back into Django ORM instances.

    It's expected that you pass the Python objects themselves (instead of a
    stream or a string) to the constructor
    """
    # Too bad this is so big, we only add a tiny bit of code
    # near the beginning and end; but not such that we can just wrap it.
    from django.conf import settings
    from django.core.serializers import python
    _get_model = python._get_model

    db = options.pop('using', DEFAULT_DB_ALIAS)
    models.get_apps()
    for d in object_list:
        # Look up the model and starting build a dict of data for it.
        Model = _get_model(d["model"])
        data = {}
        if 'pk' in d:
            data[Model._meta.pk.attname] = Model._meta.pk.to_python(d['pk'])
        m2m_data = {}

        # Handle each field
        for (field_name, field_value) in d["fields"].iteritems():
            if isinstance(field_value, str):
                field_value = smart_unicode(field_value, options.get("encoding", settings.DEFAULT_CHARSET), strings_only=True)

            field = Model._meta.get_field(field_name)

            # Handle M2M relations
            if field.rel and isinstance(field.rel, models.ManyToManyRel):
                if hasattr(field.rel.to._default_manager, 'get_by_natural_key'):
                    def m2m_convert(value):
                        if hasattr(value, '__iter__'):
                            return field.rel.to._default_manager.db_manager(db).get_by_natural_key(*value).pk
                        else:
                            return smart_unicode(field.rel.to._meta.pk.to_python(value))
                else:
                    m2m_convert = lambda v: smart_unicode(field.rel.to._meta.pk.to_python(v))
                m2m_data[field.name] = [m2m_convert(pk) for pk in field_value]

            # Handle FK fields
            elif field.rel and isinstance(field.rel, models.ManyToOneRel):
                if field_value is not None:
                    if hasattr(field.rel.to._default_manager, 'get_by_natural_key'):
                        if hasattr(field_value, '__iter__'):
                            obj = field.rel.to._default_manager.db_manager(db).get_by_natural_key(*field_value)
                            value = getattr(obj, field.rel.field_name)
                            # If this is a natural foreign key to an object that
                            # has a FK/O2O as the foreign key, use the FK value
                            if field.rel.to._meta.pk.rel:
                                value = value.pk
                        else:
                            value = field.rel.to._meta.get_field(field.rel.field_name).to_python(field_value)
                        data[field.attname] = value
                    else:
                        data[field.attname] = field.rel.to._meta.get_field(field.rel.field_name).to_python(field_value)

                else:
                    data[field.attname] = None

            # Handle all other fields
            else:
                data[field.name] = field.to_python(field_value)

        obj = base.build_instance(Model, data, db)

        yield base.DeserializedObject(obj, m2m_data)

# django.core.serializers.xml_serializer.Serializer.start_object
def start_object(self, obj):
    """
    Called as each object is handled.
    """
    if not hasattr(obj, "_meta"):
        raise base.SerializationError("Non-model object (%s) encountered during serialization" % type(obj))

    self.indent(1)
    object_data = {"model": smart_unicode(obj._meta)}
    if not self.use_natural_keys or not hasattr(obj, 'natural_key'):
        object_data['pk'] = smart_unicode(obj._get_pk_val())
    self.xml.startElement("object", object_data)



# django.core.serializers.xml_serializer.Deserializer._handle_object
def _handle_object(self, node):
    """
    Convert an <object> node to a DeserializedObject.
    """
    from django.core.serializers import xml_serializer
    getInnerText = xml_serializer.getInnerText

    # Look up the model using the model loading mechanism. If this fails,
    # bail.

    Model = self._get_model_from_node(node, "model")

    # Start building a data dictionary from the object.
    data = {}
    if node.hasAttribute('pk'):
        data[Model._meta.pk.attname] = Model._meta.pk.to_python(
                                                node.getAttribute('pk'))

    # Also start building a dict of m2m data (this is saved as
    # {m2m_accessor_attribute : [list_of_related_objects]})
    m2m_data = {}

    # Deseralize each field.
    for field_node in node.getElementsByTagName("field"):
        # If the field is missing the name attribute, bail (are you
        # sensing a pattern here?)
        field_name = field_node.getAttribute("name")
        if not field_name:
            raise base.DeserializationError("<field> node is missing the 'name' attribute")

        # Get the field from the Model. This will raise a
        # FieldDoesNotExist if, well, the field doesn't exist, which will
        # be propagated correctly.
        field = Model._meta.get_field(field_name)

        # As is usually the case, relation fields get the special treatment.
        if field.rel and isinstance(field.rel, models.ManyToManyRel):
            m2m_data[field.name] = self._handle_m2m_field_node(field_node, field)
        elif field.rel and isinstance(field.rel, models.ManyToOneRel):
            data[field.attname] = self._handle_fk_field_node(field_node, field)
        else:
            if field_node.getElementsByTagName('None'):
                value = None
            else:
                value = field.to_python(getInnerText(field_node).strip())
            data[field.name] = value

    obj = base.build_instance(Model, data, self.db)

    # Return a DeserializedObject so that the m2m data has a place to live.
    return base.DeserializedObject(obj, m2m_data)

####################################################################
# End of "natural keys" fixture support.
####################################################################


####################################################################
# Patch django.utils.xmlutils to put newlines after closing tags,
# for some modicum of readability.
####################################################################

def endElement(self, name):
    self._write('</%s>\n' % name)



####################################################################
# Patch postgis driver to work with postgres 9.1.
# Based on https://code.djangoproject.com/changeset/16826
# this can go away once we're on Django 1.4.
####################################################################

def _adapter_init(self, geom):
    "Initializes on the geometry."
    # Getting the WKB (in string form, to allow easy pickling of
    # the adaptor) and the SRID from the geometry.
    self.ewkb = str(geom.ewkb)
    self.srid = geom.srid
    from psycopg2 import Binary
    self._adapter = Binary(self.ewkb)

def _adapter_prepare(self, conn):
    """
    This method allows escaping the binary in the style required by the
    server's `standard_conforming_string` setting.
    """
    self._adapter.prepare(conn)

def _adapter_getquoted(self):
    "Returns a properly quoted string for use in PostgreSQL/PostGIS."
    # psycopg will figure out whether to use E'\\000' or '\000'
    return 'ST_GeomFromEWKB(%s)' % self._adapter.getquoted()


####################################################################
# End of patches.
####################################################################

import threading
_PATCHED = False
_lock = threading.Lock()
def patch_once():
    with _lock:
        global _PATCHED
        if _PATCHED:
            return

        import django
        if django.VERSION >= (1, 4):
            import warnings
            warnings.warn("Running Django version %s. The monkeypatches in %s were written for Django 1.3, need auditing!" % (django.VERSION, __file__))


        ####################################################
        # Natural keys.
        base.build_instance = build_instance

        # Serialization.
        from django.core.serializers import python
        python.Deserializer = Deserializer
        python.Serializer.end_object = end_object
        # have to patch stuff that's already been loaded with a 'from' import, yay
        from django.core.serializers import json
        json.PythonDeserializer = Deserializer

        from django.core.serializers import xml_serializer
        xml_serializer.Serializer.start_object = start_object
        xml_serializer.Deserializer._handle_object = _handle_object

        ####################################################
        # XML output
        from django.utils import xmlutils
        xmlutils.SimplerXMLGenerator.endElement = endElement

        ####################################################
        # PostGIS 9.1 support.
        from django.contrib.gis.db.backends.postgis.adapter import PostGISAdapter
        PostGISAdapter.__init__ = _adapter_init
        PostGISAdapter.getquoted = _adapter_getquoted
        PostGISAdapter.prepare = _adapter_prepare

        _PATCHED = True


########NEW FILE########
__FILENAME__ = admin
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

########NEW FILE########
__FILENAME__ = forms
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Forms for adding & editing :ref:`user_content`

"""
from django import forms
from django.conf import settings
from ebpub.db.forms import NewsItemForm as NewsItemFormBase
from ebpub.db.models import NewsItem
from recaptcha.client import captcha
from ebpub.db.fields import OpenblockImageFormField
import logging
logger = logging.getLogger('neighbornews.forms')

class NewsItemForm(NewsItemFormBase):

    need_captcha = False
    recaptcha_ip = None

    image = OpenblockImageFormField(required=False, label="Upload image")

    def _clean_captcha(self):
        if self.need_captcha and \
                getattr(settings, 'RECAPTCHA_PRIVATE_KEY', None) and \
                getattr(settings, 'RECAPTCHA_PUBLIC_KEY', None):
            challenge_field = self.data.get('recaptcha_challenge_field')
            response_field = self.data.get('recaptcha_response_field')
            client = self.recaptcha_ip  # Must be set by our view code.
            check_captcha = captcha.submit(
                challenge_field, response_field,
                settings.RECAPTCHA_PRIVATE_KEY, client)

            if check_captcha.is_valid is False:
                self.errors['recaptcha'] = 'Invalid captcha value'

    def clean(self):
        self._clean_captcha()
        cleaned_data = super(NewsItemForm, self).clean()
        # Reverse-geocode if we need to - eg. user clicked map
        # but didn't give an address.
        if not cleaned_data.get('location_name'):
            if cleaned_data.get('location'):
                from ebpub.geocoder.reverse import reverse_geocode
                from ebpub.geocoder.reverse import ReverseGeocodeError
                try:
                    block, distance = reverse_geocode(cleaned_data['location'])
                    cleaned_data['location_name'] = block.pretty_name
                except ReverseGeocodeError:
                    logger.info("Saving NewsItem with no location_name because reverse-geocoding %(location)s failed" % cleaned_data)

        # Geocode if we can, and need to.
        # Should not be necessary, but this is groundwork for #284.
        if not cleaned_data.get('location'):
            if cleaned_data.get('location_name'):
                from ebpub.geocoder.base import full_geocode
                try:
                    geocoded = full_geocode(cleaned_data['location_name'].strip(),
                                            guess=True)
                    cleaned_data['location'] = geocoded['result'].location.wkt
                except (IndexError, KeyError, AttributeError):
                    logger.info("Saving NewsItem with no location because geocoding %(location_name)s failed" % cleaned_data)

        # Note, any NewsItem fields that aren't listed in self._meta.fields
        # have to be manually saved here, because that's the list that's
        # normally consulted when setting attributes on the instance.
        # ... And yes, clean() is normally responsible for setting
        # attributes on the bound instance.
        for key in forms.fields_for_model(self._meta.model):
            if key in cleaned_data.keys():
                setattr(self.instance, key, cleaned_data[key])

        return cleaned_data

class NeighborMessageForm(NewsItemForm):

    class Meta:
        model = NewsItem
        # Hide some fields, re-order others.
        fields = ('title', 'location_name', 'url',
                  'image',
                  'image_url', 'categories',
                  'description',
                  'location',
                  )

    location_name = forms.CharField(max_length=255, label="Address or Location",
                                    help_text=u"Or click the map.",
                                    required=False)
    image_url = forms.CharField(max_length=2048, label="Link to external image",
                                required=False)
    categories = forms.CharField(max_length=10240, required=False,
                                 help_text="Separate with commas")
    location = forms.CharField(max_length=255, widget=forms.HiddenInput)


class NeighborEventForm(NeighborMessageForm):

    class Meta:
        model = NewsItem
        # Hide some fields, re-order others.
        fields = ('title', 'location_name',
                  'item_date',
                  'start_time', 'end_time',
                  'url', 'image', 'image_url',
                  'categories',
                  'description',
                  )

    item_date = forms.DateField(label="Date")
    start_time = forms.TimeField(label="Start Time", required=False,
                                 input_formats=("%I:%M%p",))
    end_time = forms.TimeField(label="End Time", required=False,
                               input_formats=("%I:%M%p",))

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    depends_on = (
        ("accounts", "0001_initial"),
        ("db", "0018_add_newsitem_last_modification")
    )
    

    def forwards(self, orm):
        
        # Adding model 'NewsItemCreator'
        db.create_table('neighbornews_newsitemcreator', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('news_item', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.NewsItem'])),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['accounts.User'])),
        ))
        db.send_create_signal('neighbornews', ['NewsItemCreator'])

        # Adding unique constraint on 'NewsItemCreator', fields ['news_item', 'user']
        db.create_unique('neighbornews_newsitemcreator', ['news_item_id', 'user_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'NewsItemCreator', fields ['news_item', 'user']
        db.delete_unique('neighbornews_newsitemcreator', ['news_item_id', 'user_id'])

        # Deleting model 'NewsItemCreator'
        db.delete_table('neighbornews_newsitemcreator')


    models = {
        'accounts.user': {
            'Meta': {'object_name': 'User', '_ormbases': ['auth.User']},
            'main_metro': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'user_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'neighbornews.newsitemcreator': {
            'Meta': {'ordering': "('news_item',)", 'unique_together': "(('news_item', 'user'),)", 'object_name': 'NewsItemCreator'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['accounts.User']"})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['neighbornews']

########NEW FILE########
__FILENAME__ = 0002_add_is_event
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    depends_on = (
        ("db", "0020_auto__add_field_schema_is_event"),
        )

    def forwards(self, orm):
        """
        Just in case somebody loaded the neighbornews fixtures
        before we added the Schema.is_event field.
        """
        schemas = orm['db.schema'].objects.filter(slug='neighbor-events')
        if schemas.count():
            schema = schemas[0]
            schema.is_event = True
            schema.save()

    def backwards(self, orm):
        pass


    models = {
        'accounts.user': {
            'Meta': {'object_name': 'User', '_ormbases': ['auth.User']},
            'main_metro': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'user_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'neighbornews.newsitemcreator': {
            'Meta': {'ordering': "('news_item',)", 'unique_together': "(('news_item', 'user'),)", 'object_name': 'NewsItemCreator'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['accounts.User']"})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db', 'neighbornews']

########NEW FILE########
__FILENAME__ = 0003_allow_flagging
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    depends_on = (
        ("db", "0024_auto__add_field_schema_allow_flagging"),
        )

    def forwards(self, orm):
        """
        Just in case somebody loaded the neighbornews fixtures
        before we added the Schema.allow_flagging field.
        """
        schemas = orm['db.schema'].objects.filter(slug__in=('neighbor-events', ('neighbor-messages')))
        for schema in schemas:
            schema.allow_flagging = True
            schema.save()


    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'accounts.user': {
            'Meta': {'object_name': 'User', '_ormbases': ['auth.User']},
            'main_metro': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'user_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'), ('code', 'schema_field'))", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date.today', 'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'+'", 'null': 'True', 'to': "orm['db.Location']"}),
            'location_set': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Location']", 'null': 'True', 'through': "orm['db.NewsItemLocation']", 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemimage': {
            'Meta': {'unique_together': "(('news_item', 'image'),)", 'object_name': 'NewsItemImage'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '256'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_flagging': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date(1970, 1, 1)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'moderation.commentflag': {
            'Meta': {'ordering': "('news_item',)", 'object_name': 'CommentFlag'},
            'comment': ('django.db.models.fields.CharField', [], {'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'moderation_commentflag_related'", 'null': 'True', 'to': "orm['db.NewsItem']"}),
            'reason': ('django.db.models.fields.CharField', [], {'max_length': '128', 'db_index': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'default': "'new'", 'max_length': '64', 'db_index': 'True', 'blank': 'True'}),
            'submitted': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.CharField', [], {'default': "'anonymous'", 'max_length': '128', 'null': 'True', 'blank': 'True'})
        },
        'moderation.newsitemflag': {
            'Meta': {'ordering': "('news_item',)", 'object_name': 'NewsItemFlag'},
            'comment': ('django.db.models.fields.CharField', [], {'max_length': '512', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'moderation_newsitemflag_related'", 'null': 'True', 'to': "orm['db.NewsItem']"}),
            'reason': ('django.db.models.fields.CharField', [], {'max_length': '128', 'db_index': 'True'}),
            'state': ('django.db.models.fields.CharField', [], {'default': "'new'", 'max_length': '64', 'db_index': 'True', 'blank': 'True'}),
            'submitted': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.CharField', [], {'default': "'anonymous'", 'max_length': '128', 'null': 'True', 'blank': 'True'})
        },
        'neighbornews.newsitemcreator': {
            'Meta': {'ordering': "('news_item',)", 'unique_together': "(('news_item', 'user'),)", 'object_name': 'NewsItemCreator'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['accounts.User']"})
        }
    }

    complete_apps = ['db', 'moderation', 'neighbornews']

########NEW FILE########
__FILENAME__ = 0004_chartable_categories
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."

        cat_fields = orm['db.schemafield'].objects.filter(
            schema__slug__in=('neighbor-events', 'neighbor-messages'),
            name='categories')

        for sf in cat_fields:
            sf.allow_charting = True
            sf.save()


    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'accounts.user': {
            'Meta': {'object_name': 'User', '_ormbases': ['auth.User']},
            'main_metro': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'user_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'), ('code', 'schema_field'), ('name', 'schema_field'))", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'featured': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date.today', 'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'+'", 'null': 'True', 'to': "orm['db.Location']"}),
            'location_set': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Location']", 'null': 'True', 'through': "orm['db.NewsItemLocation']", 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemimage': {
            'Meta': {'unique_together': "(('news_item', 'image'),)", 'object_name': 'NewsItemImage'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '256'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_flagging': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date(1970, 1, 1)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'neighbornews.newsitemcreator': {
            'Meta': {'ordering': "('news_item',)", 'unique_together': "(('news_item', 'user'),)", 'object_name': 'NewsItemCreator'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['accounts.User']"})
        }
    }

    complete_apps = ['db', 'neighbornews']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib.gis.db import models
from ebpub.accounts.models import User
from ebpub.db.models import NewsItem

class NewsItemCreator(models.Model):
    """
    Represents an add-on created-by relationship between
    a User and a NewsItem without interfering with the
    NewsItem model.
    """

    news_item = models.ForeignKey(NewsItem)
    user = models.ForeignKey(User)

    class Meta:
        unique_together = (('news_item', 'user'),)
        ordering = ('news_item',)

########NEW FILE########
__FILENAME__ = tests
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

########NEW FILE########
__FILENAME__ = urls
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf.urls.defaults import patterns, url
from ebpub.neighbornews import views

urlpatterns = patterns(
    '',
    url(r'^message/new/$', views.new_message, name="new_message"),
    url(r'^message/(?P<newsitem>.+)/edit/$', views.edit_message, name="edit_message"),
    url(r'^message/(?P<newsitem>.+)/delete/$', views.delete_message, name="delete_message"),

    url(r'^event/new/$', views.new_event, name="new_event"),
    url(r'^event/(?P<newsitem>.+)/edit/$', views.edit_event, name="edit_event"),
    url(r'^event/(?P<newsitem>.+)/delete/$', views.delete_event, name="delete_event"),

    url(r'^by_user/(?P<userid>.+)/$', views.news_by_user, name="neighbornews_by_user"),

)

########NEW FILE########
__FILENAME__ = utils
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Utility functions related to :ref:`user_content`

"""
from django.http import HttpResponse
from ebpub.db.models import Schema, NewsItem
from ebpub.neighbornews.models import NewsItemCreator
import datetime
import functools

NEIGHBOR_MESSAGE_SLUG = 'neighbor-messages'
NEIGHBOR_EVENT_SLUG = 'neighbor-events'

def app_enabled():
    from django.conf import settings
    return 'ebpub.neighbornews' in settings.INSTALLED_APPS

def is_schema_enabled(slug):
    try:
        return app_enabled() and Schema.objects.filter(slug=slug).values_list('is_public')[0][0]
    except IndexError:
        return False

def is_neighbor_message_enabled():
    return is_schema_enabled(NEIGHBOR_MESSAGE_SLUG)

def is_neighbor_event_enabled():
    """
    Is the neigbhor-events schema enabled?
    """
    return is_schema_enabled(NEIGHBOR_EVENT_SLUG)

def is_neighbornews_enabled():
    """
    Returns true if either of the neighbornews schemas exist and the app
    is installed.
    """
    return is_neighbor_message_enabled() or is_neighbor_event_enabled()

def if_disabled404(slug):
    """
    Decorator that checks whether the schema is disabled, and if so,
    the decorated view returns 404.
    """
    def decorator(func):
        @functools.wraps(func)
        def inner(*args, **kw):
            if not is_schema_enabled(slug):
                return HttpResponse(status=404)
            else:
                return func(*args, **kw)
        return inner

    return decorator

def user_can_edit(request, item):
    """Can the current user edit this NewsItem?
    """
    if request.user.is_anonymous():
        return False
    allowed = False
    if isinstance(item, (basestring, int)):
        item_id = int(item)
        item = NewsItem.objects.get(id=item_id)
    else:
        item_id = item.id

    if request.user.has_perm('db.change_newsitem'):
        allowed = True
    elif NewsItemCreator.objects.filter(news_item__id=item_id,
                                        user__id=request.user.id).count():
        # It might be temporarily allowed.
        if item.schema.edit_window == 0.0:
            allowed = False
        elif item.schema.edit_window < 0:
            # ... Or permanently!
            allowed = True
        elif item.last_modification + datetime.timedelta(hours=item.schema.edit_window) >= datetime.datetime.now():
            allowed = True
    return allowed

def can_edit(func):
    """Decorator that checks whether you created this NewsItem, or
    have permission to edit all NewsItems.
    """
    @functools.wraps(func)
    def inner(request, newsitem, *args, **kw):
        if not user_can_edit(request, newsitem):
            return HttpResponse(status=403)
        return func(request, newsitem, *args, **kw)
    return inner

########NEW FILE########
__FILENAME__ = views
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from django.contrib import messages
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404
from django.views.decorators.csrf import csrf_protect
from ebpub.accounts.models import User
from ebpub.accounts.utils import login_required
from ebpub.db.models import Schema, SchemaField, Lookup, NewsItem
from ebpub.neighbornews.forms import NeighborMessageForm, NeighborEventForm
from ebpub.neighbornews.models import NewsItemCreator
from ebpub.neighbornews.utils import NEIGHBOR_MESSAGE_SLUG, NEIGHBOR_EVENT_SLUG
from ebpub.neighbornews.utils import if_disabled404, can_edit
from ebpub.utils.view_utils import eb_render
import re

@if_disabled404(NEIGHBOR_MESSAGE_SLUG)
@login_required
@csrf_protect
def new_message(request):
    """
    Add form for neighbor-messages
    """
    schema = Schema.objects.get(slug=NEIGHBOR_MESSAGE_SLUG)
    FormType = NeighborMessageForm
    return _new_item(request, schema, FormType)


@if_disabled404(NEIGHBOR_EVENT_SLUG)
@login_required
@csrf_protect
def new_event(request):
    """
    Add form for neighbor-events
    """
    schema = Schema.objects.get(slug=NEIGHBOR_EVENT_SLUG)
    FormType = NeighborEventForm
    return _new_item(request, schema, FormType)


@if_disabled404(NEIGHBOR_MESSAGE_SLUG)
@login_required
@csrf_protect
@can_edit
def edit_message(request, newsitem):
    """
    Edit form for neighbor-messages
    """
    FormType = NeighborMessageForm
    return _edit_item(request, newsitem, FormType)

@if_disabled404(NEIGHBOR_EVENT_SLUG)
@login_required
@csrf_protect
@can_edit
def edit_event(request, newsitem):
    """
    Edit form for neighbor-events
    """
    FormType = NeighborEventForm
    return _edit_item(request, newsitem, FormType)


@if_disabled404(NEIGHBOR_MESSAGE_SLUG)
@login_required
@csrf_protect
@can_edit
def delete_message(request, newsitem):
    """
    Delete confirmation for neighbor-messages
    """
    return _delete(request, newsitem)

@if_disabled404(NEIGHBOR_EVENT_SLUG)
@login_required
@csrf_protect
@can_edit
def delete_event(request, newsitem):
    """
    Delete confirmation for neighbor-events
    """
    return _delete(request, newsitem)


def news_by_user(request, userid):
    """
    List of all messages / events posted by the given user.
    """
    user = User.objects.get(id=userid)
    is_viewing_self = False
    if not request.user.is_anonymous():
        if user.id == request.user.id:
            is_viewing_self = True
    items_by_schema = []
    for slug in ('neighbor-messages', 'neighbor-events'):
        try:
            schema = Schema.objects.get(slug=slug)
        except Schema.DoesNotExist:
            continue
        items = NewsItemCreator.objects.filter(user__id=userid, news_item__schema=schema)
        items = items.select_related().order_by('-news_item__item_date')
        items = [item.news_item for item in items]
        items_by_schema.append({'schema': schema, 'items': items})

    context = {'items_by_schema': items_by_schema, 'user': user,
               'is_viewing_self': is_viewing_self}
    return eb_render(request, "neighbornews/news_by_user.html", context)


################################################################
# Utility functions.

def _delete(request, newsitem):
    item = get_object_or_404(NewsItem, id=newsitem)
    if request.method == 'POST':
        item.delete()
        messages.add_message(request, messages.INFO, 'Deleted.')
        return HttpResponseRedirect(reverse('neighbornews_by_user',
                                            args=(request.user.id,)))
    else:
        return eb_render(request, 'neighbornews/delete_form.html',
                         {'newsitem': item})

def _edit_item(request, newsitem_id, FormType):
    instance = NewsItem.objects.get(id=newsitem_id)
    if request.method == 'POST':
        form = FormType(request.POST, request.FILES, instance=instance)
    else:
        form = FormType(instance=instance)
    return _update_item(request, form, instance.schema, action='edit')


def _new_item(request, schema, FormType):
    if request.method == 'POST':
        form = FormType(request.POST, request.FILES)
    else:
        form = FormType()
    return _update_item(request, form, schema, action='create')


def _update_item(request, form, schema, action):
    # Do we need to use need captcha? 
    # This might depend on the request, so you can set it to a callable,
    # or rather a path to a callable.
    need_captcha = getattr(settings, 'NEIGHBORNEWS_USE_CAPTCHA', False)
    if isinstance(need_captcha, basestring):
        module, func = need_captcha.split(':')
        import importlib
        module = importlib.import_module(module)
        need_captcha = getattr(module, func)

    if callable(need_captcha):
        need_captcha = need_captcha(request)

    if need_captcha:
        form.need_captcha = True
        form.recaptcha_ip = request.META['REMOTE_ADDR']

    cat_field = SchemaField.objects.get(schema=schema, name='categories')
    if form.is_bound and form.is_valid():
        # Creating or updating a NewsItem.
        form.instance.schema = schema
        item = form.save()

        # Add a NewsItemCreator association; un-lazy the User.
        user = User.objects.get(id=request.user.id)
        NewsItemCreator.objects.get_or_create(news_item=item, user=user)

        # Image url.
        if form.cleaned_data['image_url'] is not None:
            item.attributes['image_url'] = form.cleaned_data['image_url']

        # Image.
        uploaded = form.cleaned_data['image']
        if uploaded is False:
            # This is apparently how File fields announce deletion. Is
            # that in the docs??
            item.newsitemimage_set.all().delete()
        elif uploaded:
            from ebpub.db.models import NewsItemImage
            # TODO: allow more than one? For now, we just delete and recreate.
            item.newsitemimage_set.all().delete()
            ni_image, created = NewsItemImage.objects.get_or_create(news_item=item,
                                                                    image=uploaded.name)
            ni_image.image.save(uploaded.name, uploaded)

        # Times.
        for key in ('start_time', 'end_time'):
            if key in form.fields and form.cleaned_data.get(key):
                item.attributes[key] = form.cleaned_data[key]

        # 'categories'
        cats = [cat.strip() for cat in form.cleaned_data['categories'].split(',') if cat.strip()]
        if len(cats):
            lookups = set()
            for cat in cats:
                code = _category_code(cat)
                nice_name = _category_nice_name(cat)
                try:
                    # We don't call get_or_create() yet because we
                    # only want to look up by the normalized code, to
                    # avoid dupes with slightly different names.
                    from django.db.models import Q
                    lu = Lookup.objects.filter(
                        Q(schema_field=cat_field),
                        Q(code=code) | Q(name=nice_name)
                        )[0]
                except (IndexError, Lookup.DoesNotExist):
                    # We know it doesn't exist, but use get_or_create_lookup()
                    # here b/c that takes care of the slug.
                    lu = Lookup.objects.get_or_create_lookup(cat_field, nice_name, code=code)
                lookups.add(lu.id)
            item.attributes['categories'] = ','.join(['%d' % luid for luid in lookups])

        detail_url = reverse('ebpub-newsitem-detail',
                             args=(schema.slug, '%d' % item.id))
        if action == 'create':
            messages.add_message(request, messages.INFO, '%s created.' % schema.name)
        else:
            messages.add_message(request, messages.INFO, '%s edited.' % schema.name)
        return HttpResponseRedirect(detail_url)

    elif form.instance:
        # Update form.
        if form.instance.attributes.get('categories'):
            cat_ids = form.instance.attributes['categories'].split(',')
            cat_lookups = Lookup.objects.filter(schema_field=cat_field, id__in=cat_ids)
            form.fields['categories'].initial = ', '.join(
                sorted([look.name for look in cat_lookups]))
        if form.instance.location:
            form.fields['location'].initial = form.instance.location.wkt

        existing_images = list(form.instance.newsitemimage_set.all())
        if existing_images:
            img = existing_images[0].image
            # TODO: allow uploading more than one?
            form.fields['image'].initial = img
        else:
            img = None

        for key in ('start_time', 'end_time', 'image_url'):
            if key in form.fields and form.instance.attributes.get(key):
                value = form.instance.attributes[key]
                if key.endswith('time'):
                    value = value.strftime('%H:%M%p')
                form.fields[key].initial = value

    mapconfig = {
        'locations': [],
        'layers': [],
        'baselayer_type': settings.MAP_BASELAYER_TYPE,

    }
    ctx = {
        'form': form,
        'map_configuration': mapconfig,
        'default_lon': settings.DEFAULT_MAP_CENTER_LON,
        'default_lat': settings.DEFAULT_MAP_CENTER_LAT,
        'default_zoom': settings.DEFAULT_MAP_ZOOM,
        'schema': schema,
        'action': action,
        'need_captcha': need_captcha,
        'image': img,
    }
    return eb_render(request, "neighbornews/new_message.html", ctx)


def _category_code(cat):
    code = cat.strip().lower()
    code = re.sub('\s+', ' ', code)
    code = re.sub('[^\w]', '-', code)
    return code

def _category_nice_name(cat):
    nice = cat.strip().title()
    nice = re.sub('\s+', ' ', nice)
    return nice

########NEW FILE########
__FILENAME__ = admin
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.


from django.contrib.admin import ModelAdmin
from django.contrib.gis import admin
from django.forms import CharField
from django.forms import IPAddressField
from django.forms import ModelForm
from django.forms import ValidationError
from .models import KEY_SIZE
from .models import ApiKey
from .models import generate_unique_api_key

class ApiKeyForm(ModelForm):
    """
    Generate a random API key if one isn't provided.
    """

    class Meta:
        model = ApiKey

    key = CharField(max_length=KEY_SIZE, required=False,
                    help_text=u'If not provided, a random key will be generated.')

    logged_ip = IPAddressField(required=False)

    def clean(self):
        profile = self.cleaned_data.get('user').user.get_profile()
        if self.instance.pk is None:
            # We're creating a new instance
            if not profile.can_make_api_key():
                raise ValidationError("User already has max number of keys")

        apikey = self.cleaned_data.get('key') or ''

        if not apikey:
            # 'key' is required, but we want to allow generating it server-side.
            # so we remove its errors if it's not provided.
            # Note that we can't just define self.clean_key() because that's never
            # called if the key isn't provided.
            self._errors.pop('key', None)
            apikey = generate_unique_api_key()
            self.cleaned_data['key'] = apikey
            if hasattr(self, 'clean_key'):
                # NOW we can call this...
                self.cleaned_data['key'] = self.clean_key()

        # For logged IP, convert blank to NULL
        self.cleaned_data['logged_ip'] = self.cleaned_data.get('logged_ip') or None
        return self.cleaned_data


class ApiKeyAdmin(ModelAdmin):
    form = ApiKeyForm

    list_display = ('key', 'user', 'logged_ip', 'last_used')

admin.site.register(ApiKey, ApiKeyAdmin)


########NEW FILE########
__FILENAME__ = auth
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib.auth import login
from django.core.exceptions import PermissionDenied
from .models import ApiKey

KEY_HEADER = 'HTTP_X_OPENBLOCK_KEY'

class APIKeyBackend(object):
    """
    Django authentication backend purely by API key.
    """

    # Not sure yet if we really want to use this as an auth backend;
    # we certainly don't want it in the global settings.AUTHENTICATION_BACKENDS
    supports_object_permissions = False
    supports_anonymous_user = False
    supports_inactive_user = False

    def authenticate(self, key=None, ip_address=None):
        if not key:
            return None

        user, key_instance = self._get_user_and_key(key)
        if None in (user, key_instance):
            return None
        key_instance.login(ip_address)
        return user

    def get_user(self, user_id):
        """user_id is an API key.
        """
        return self._get_user_and_key(user_id)[1]


    def _get_user_and_key(self, key):
        try:
            key_instance = ApiKey.objects.get(key=key)
        except ApiKey.DoesNotExist:
            return (None, None)
        return key_instance.user, key_instance

def check_api_authorization(request):
    """
    Check API access based on the current request.

    Currently requires that either the user is logged in (eg. via
    basic auth or cookie), or there is a valid API key in the '%s' request
    header.  If either fails, raises ``PermissionDenied``.

    This should become more configurable.
    """ % KEY_HEADER
    if request.user.is_authenticated():
        user = request.user
        if user.is_active:
            return True
        else:
            raise PermissionDenied("Your account is disabled.")
    else:
        ip_address = request.META['REMOTE_ADDR']
        key = request.META.get(KEY_HEADER)
        user = APIKeyBackend().authenticate(key=key, ip_address=ip_address)
        if user is None:
            raise PermissionDenied("invalid key?")
        if user.is_active:
            # login() expects a dotted name at user.backend.
            user.backend = 'ebpub.openblockapi.authentication.APIKeyBackend'
            login(request, user)
            return True
        else:
            raise PermissionDenied("Your account is disabled.")


########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'ApiKey'
        db.create_table('key_apikey', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(related_name='keys', to=orm['auth.User'])),
            ('key', self.gf('django.db.models.fields.CharField')(unique=True, max_length=32)),
            ('logged_ip', self.gf('django.db.models.fields.IPAddressField')(max_length=15, null=True)),
            ('last_used', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.utcnow)),
        ))
        db.send_create_signal('apikey', ['ApiKey'])


    def backwards(self, orm):
        
        # Deleting model 'ApiKey'
        db.delete_table('key_apikey')


    models = {
        'apikey.apikey': {
            'Meta': {'object_name': 'ApiKey', 'db_table': "'key_apikey'"},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'last_used': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.utcnow'}),
            'logged_ip': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'null': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'keys'", 'to': "orm['auth.User']"})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        }
    }

    complete_apps = ['apikey']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
REST API Key model implementation derived from django-apikey,
copyright (c) 2011 Steve Scoursen and Jorge Eduardo Cardona.
BSD license.
http://pypi.python.org/pypi/django-apikey
"""

from django.db import models
from django.contrib.auth.models import User
from django.conf import settings
from datetime import datetime


# Changing this would require a migration
KEY_SIZE = 32

try:
    MAX_KEYS = settings.MAX_KEYS_PER_USER
except AttributeError:
    MAX_KEYS = -1


class ApiKey(models.Model):
    user = models.ForeignKey(User, related_name='keys')
    key = models.CharField(max_length=KEY_SIZE, unique=True)
    logged_ip = models.IPAddressField(null=True)
    last_used = models.DateTimeField(default=datetime.utcnow)

    class Meta:
        db_table = 'key_apikey'

    def login(self, ip_address):
        self.logged_ip = ip_address
        self.save()

    def logout(self):
        self.logged_ip = None
        self.save()

    def __unicode__(self):
        return self.key

def generate_unique_api_key():
    """random string suitable for use with ApiKey
    """
    # From http://jetfar.com/simple-api-key-generation-in-python/
    import base64
    import hashlib
    import random
    api_key = ''
    while len(api_key) < KEY_SIZE:
        more_key = str(random.getrandbits(256))
        more_key = hashlib.sha256(more_key).hexdigest()
        more_key = base64.b64encode(
            more_key,
            random.choice(['rA','aZ','gQ','hH','hG','aR','DD']))
        more_key = more_key.rstrip('=')
        api_key += more_key
    api_key = api_key[:KEY_SIZE]
    return api_key

########NEW FILE########
__FILENAME__ = signals
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Signals sent when saving REST API Keys.
Derived from django-apikey,
copyright (c) 2011 Steve Scoursen and Jorge Eduardo Cardona.
BSD license.
http://pypi.python.org/pypi/django-apikey
"""

from django.db.models.signals import post_save
from django.db.models.signals import post_delete
from .models import ApiKey

def save_api_key( sender, instance, created, **kwargs ):
    try:
        instance.user.get_profile().save()
    except:
        pass
post_save.connect(save_api_key, sender=ApiKey)


def post_delete_api_key( sender, instance, **kwargs ):
    try:
        instance.user.get_profile().save()
    except:
        pass
post_delete.connect(post_delete_api_key, sender=ApiKey)

########NEW FILE########
__FILENAME__ = urls
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
URL patterns for REST API Key views.
Derived from django-apikey,
copyright (c) 2011 Steve Scoursen and Jorge Eduardo Cardona.
BSD license.
http://pypi.python.org/pypi/django-apikey
"""

from django.conf.urls.defaults import *


urlpatterns = patterns('ebpub.openblockapi.apikey.views',
                       url(r'^create_key/$', 'generate_key', 
                           name='api_create_key' ),
                       url(r'^keys/$', 'list_keys',
                           name='api_list_keys' ),
                       url(r'^delete_key/$', 'delete_key',
                           name='api_delete_key' ),
                       )

########NEW FILE########
__FILENAME__ = views
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Views for managing REST API keys.

Derived from django-apikey,
copyright (c) 2011 Steve Scoursen and Jorge Eduardo Cardona.
BSD license.
http://pypi.python.org/pypi/django-apikey
"""

from .models import ApiKey, generate_unique_api_key
from django.contrib import messages
from ebpub.accounts.utils import login_required
from django.core.cache import cache
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.views.decorators.cache import cache_page
from django.views.decorators.http import condition
import datetime


def get_etag_key(request):
    try:
        lm = request.user.get_profile().last_accessed
    except:
        try:
            lm = request.get_profile().last_accessed
        except:
            lm = datetime.datetime.utcnow()
    k = 'etag.%s' % (lm)
    return k.replace(' ', '_')

def etag_func(request, *args, **kwargs):
    etag_key = get_etag_key(request)
    etag = cache.get(etag_key, None)
    return etag

def latest_access(request, *args, **kwargs):
    try:
        return request.user.get_profile().last_accessed
    except:
        return datetime.datetime.utcnow()



@login_required
@condition(etag_func=etag_func, last_modified_func=latest_access)
@cache_page(1)
def generate_key(request):
    if request.method == 'POST':
        # Trigger loading the real user object (not a LazyUser proxy),
        # and use it.
        user = request.user.user
        profile = user.get_profile()
        if profile.can_make_api_key():
            key = generate_unique_api_key()
            apikey = ApiKey(user=user, key=key)
            apikey.clean()
            apikey.save()
            messages.add_message(request, messages.INFO, 'Key %s created.' % key)
        else:
            messages.add_message(request, messages.ERROR,
                                 "You can't have more keys unless you delete some.")

    return do_generate_key_list(request)


@login_required
@condition(etag_func=etag_func, last_modified_func=latest_access)
@cache_page(1)
def list_keys(request):
    return do_generate_key_list(request)

def do_generate_key_list(request):
    # Trigger loading the real user object (not a LazyUser proxy),
    # and use it.
    user = request.user.user
    profile = user.get_profile()
    keys = ApiKey.objects.filter(user=user)
    cmak = profile.can_make_api_key()
    ak = profile.available_keys()
    return render_to_response('key/key.html',
                              { 'keys': keys, 'user': user,
                                'can_make_api_key': cmak,
                                'available_keys': ak },
                              context_instance=RequestContext(request))

@login_required
@condition(etag_func=etag_func, last_modified_func=latest_access)
@cache_page(1)
def delete_key(request):
    user = request.user.user
    to_delete = request.POST.getlist('key')
    if to_delete:
        # TODO: verify that there actually was a matching key.
        ApiKey.objects.filter(user=user, key__in=to_delete).delete()
        for key in to_delete:
            messages.add_message(request, messages.INFO, 'Key %s deleted.' % key)
    else:
        messages.add_message(request, messages.ERROR, 'No key to delete was specified.')
    return HttpResponseRedirect(reverse(list_keys))

########NEW FILE########
__FILENAME__ = itemquery
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.

"""
Filtering of NewsItems for the openblock REST API.

TODO: This is largely parallel to ebpub.db.schemafilters,
and could be merged with that code?

Filters accept and return:
 * the current django model query
 * the remaining set of parameters describing the query
 * an arbitrary state dictionary for signaling / caching

The first filter to use a parameter removes it.
Related filters can communicate through the 'state' dict.

This allows identification of unused/ill specified parameters and
disallows overlapping interpretations of a parameter.

The full set of parameters that control these filters is specified in
the API documentation.
"""

from django.contrib.gis import geos
from ebpub.utils.dates import parse_date
from ebpub.db.models import NewsItem
from ebpub.streets.models import Place
import pyrfc3339
import re

__all__ = ['build_item_query', 'build_place_query']


class QueryError(Exception):
    def __init__(self, message):
        self.message = message

def build_item_query(request):
    """
    builds a NewsItem QuerySet according to the request parameters given as
    specified in the API documentation.  raises QueryError if
    invalid query parameters are specified.

    Returns the queryset, and a dictionary of *unused* parameters.
    """
    params = _copy_nomulti(request.GET)
    # some different ordering may be more optimal here /
    # some index could be specifically created.
    # Also this could be rewritten to use ebpub.db.schemafilter
    filters = [_schema_filter,
               _id_filter,
               _daterange_filter, _predefined_place_filter,
               _radius_filter, _bbox_filter, _attributes_filter, _order_by,
               _object_limit]

    query = NewsItem.objects.by_request(request)
    params = dict(params)
    state = {}
    for f in filters:
        query, params, state = f(query, params, state)

    return query, params


def _schema_filter(query, params, state):
    """
    handles filtering items by schema type
    parameters: type
    """

    slug = params.pop('type', None)
    if slug is not None:
        if isinstance(slug, basestring):
            query = query.filter(schema__slug=slug)
        else:
            query = query.filter(schema__slug__in=slug)
        state['schema_slug'] = slug
    return query, params, state

def _id_filter(query, params, state):
    """
    handles filtering items by explicit IDs
    parameters: 'id'
    """
    ids = params.pop('id', None)
    if ids is not None:
        if isinstance(ids, basestring):
            ids = [i for i in re.split(r'[^\d]+', ids) if i.strip()]
        if ids:
            query = query.filter(id__in=ids)
    return query, params, state


def _attributes_filter(query, params, state):
    # not implemented yet
    return query, params, state

def _daterange_filter(query, params, state):
    """
    handles filtering by start and end date
    paramters: startdate, enddate
    """
    startdate = params.get('startdate')
    if startdate is not None:
        try:
            del params['startdate']
            try:
                startdate = parse_date(startdate, '%Y-%m-%d')
            except ValueError:
                startdate = pyrfc3339.parse(startdate)
            query = query.filter(pub_date__gte=startdate)
        except ValueError:
            raise QueryError('Invalid start date "%s", must be YYYY-MM-DD or rfc3339' % startdate)
    
    enddate = params.get('enddate')
    if enddate is not None:
        try:
            del params['enddate']
            try:
                enddate = parse_date(enddate, '%Y-%m-%d')
            except ValueError: 
                enddate = pyrfc3339.parse(enddate)
            query = query.filter(pub_date__lte=enddate)
        except ValueError:
            raise QueryError('Invalid end date "%s", must be YYYY-MM-DD or rfc3339' % enddate)

    return query, params, state

def _predefined_place_filter(query, params, state):
    """
    handles filtering by predefined place (newsitemlocation)
    parameters: locationid
    """
    locationid = params.pop('locationid', None)
    if locationid is None: 
        return query, params, state
    if state.get('has_geo_filter') == True: 
        raise QueryError('Only one geographic filter may be specified')

    if isinstance(locationid, basestring):
        ids = [locationid]
    else:
        ids = locationid
    queries = []
    from django.db.models import Q
    # Need to build up an OR query, so we use django Q objects.
    for loc in ids:
        try:
            # Note, API doc specifies splitting on "/" but
            # we also support commas for convenience of ebpub.richmaps
            loctypeslug, locslug = re.split(r'[/,]', loc)
            queries.append(Q(newsitemlocation__location__slug=locslug,
                             newsitemlocation__location__location_type__slug=loctypeslug))
        except ValueError: 
            raise QueryError('Invalid location identifier "%s"' % loc)
    if queries:
        loc_query = queries[0]
        for q in queries[1:]:
            loc_query = loc_query | q

        # Could get overlaps?
        query = query.filter(loc_query).distinct()

    state['has_geo_filter'] = True
    return query, params, state


def _bbox_filter(query, params, state):
    """
    handles filtering by a bounding box region
    parameters: bbox 
    comma separated lon1,lat1,lon2,lat2
    eg bbox=-71.775184936525,42.077772745456,-70.541969604493,42.585381248024
    """
    
    bbox = params.get('bbox')
    if bbox is None: 
        return query, params, state
    
    if state.get('has_geo_filter') == True: 
        raise QueryError('Only one geographic filter may be specified')

    try:
        lon1,lat1,lon2,lat2 = (float(x.strip()) for x in bbox.split(','))
        search_region = geos.Polygon.from_bbox([lon1,lat1,lon2,lat2])
        search_region.srid = 4326
        query = query.filter(location__contained=search_region)
    except:
        import traceback
        traceback.print_exc()
        raise QueryError("Invalid bounding box.")
        
    state['has_geo_filter'] = True
    
    return query, params, state

def _radius_filter(query, params, state):
    """
    handles filtering by a 'circular' geographic region
    parameters: center, radius
    """
    center = params.get('center')
    radius = params.get('radius')
    
    if center is None and radius is None: 
        return query, params, state

    if 'center' in params: 
        del params['center']
    if 'radius' in params: 
        del params['radius']

    if state.get('has_geo_filter') == True: 
        raise QueryError('Only one geographic filter may be specified')

    try: 
        lon, lat = [float(x.strip()) for x in center.split(',')]
        center = geos.Point(lon, lat, srid=4326)
    except ValueError:
        raise QueryError('Invalid center point "%s"' % center)
        
    try:
        radius = float(radius)
        if radius < 0: 
            raise QueryError('Radius must be greater than 0')
        # pop into spherical mercator to make a circle in meters
        search_region = center.transform(3785, True)
        search_region = search_region.buffer(radius)
    except ValueError:
        raise QueryError('Invalid radius "%s"' % radius)

    query = query.filter(location__bboverlaps=search_region)
    state['has_geo_filter'] = True

    return query, params, state

def _object_limit(query, params, state):
    """
    handles limiting the number of results and skipping results
    parameters: limit, offset
    """
    try: 
        offset = int(params.get('offset', 0))
    except:
        raise QueryError('Invalid offset')
    
    try: 
        limit = int(params.get('limit', 50))
        if limit > 1000: 
            limit = 1000
    except:
        raise QueryError('Invalid limit')
    
    if 'limit' in params: 
        del params['limit']
    if 'offset' in params: 
        del params['offset']

    query = query[offset:offset+limit]
    
    return query, params, state

def _order_by(query, params, state):
    """
    handles order of results.
    parameters: None, currently fixed
    """
    # it is always by item date currently
    query = query.order_by('-item_date')
    return query, params, state


###################################
# Some piggy-backing for Places API
###################################

def _placetype_filter(query, params, state):
    """
    handles filtering Places by placetype
    """
    query = query.filter(place_type__is_mappable=True)

    slug = params.get('type')
    if slug is not None:
        del params['type']
        state['placetype_slug'] = slug
        query = query.filter(place_type__slug=slug)    
    return query, params, state


def build_place_query(params):
    """
    builds a Place QuerySet according to the request parameters given 
    as specified in the API documentation. raises QueryError if 
    invalid query parameters are specified. 
    """
    filters = [_placetype_filter, _radius_filter, _bbox_filter, _object_limit]

    query = Place.objects.all()
    params = dict(params)
    state = {}
    for f in filters: 
        query, params, state = f(query, params, state)

    return query, params

def _copy_nomulti(d):
    """
    make a copy of django wack-o immutable query multi-dict
    making single item values non-lists.
    """
    d = dict(d) # Work around request.GET.items() not giving all values
    r = {}
    for k,v in d.items():
        try:
            if len(v) == 1:
                r[k] = v[0]
            else:
                r[k] = v
        except TypeError:
            r[k] = v
    return r

########NEW FILE########
__FILENAME__ = models
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

# No models here.

########NEW FILE########
__FILENAME__ = tests
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.

"""
API tests
"""
import cgi
import datetime
import feedparser
import logging
import mock
import pytz
from ebpub.utils.testing import RequestFactory
from django.contrib.gis import geos
from django.core.urlresolvers import reverse
from ebpub.utils.django_testcase_backports import TestCase
from django.utils import simplejson
from ebpub.db.models import Location, NewsItem, Schema
from ebpub.openblockapi import views
from ebpub.openblockapi.apikey import auth


class BaseTestCase(TestCase):
    def setUp(self):
        # Don't log 404 warnings, we expect a lot of them during these
        # tests.
        logger = logging.getLogger('django.request')
        self._previous_level = logger.getEffectiveLevel()
        logger.setLevel(logging.ERROR)

        from ebpub.metros.allmetros import get_metro
        metro = get_metro()        
        self.old_multiple = metro['multiple_cities']
        self.old_city = metro['city_name']
        metro['multiple_cities'] = False
        metro['city_name'] = 'Boston'

    def tearDown(self):
        # Restore old log level.
        from ebpub.metros.allmetros import get_metro
        metro = get_metro()
        metro['multiple_cities'] = self.old_multiple
        metro['city_name'] = self.old_city

        logger = logging.getLogger('django.request')
        logger.setLevel(self._previous_level)



@mock.patch('ebpub.openblockapi.views.throttle_check', mock.Mock(return_value=0))
class TestAPI(BaseTestCase):

    fixtures = ('test-schema', 'test-locationtypes', 'test-locations')

    def test_api_available(self):
        response = self.client.get(reverse('check_api_available'))
        self.assertEqual(response.status_code, 200)

    def test_types_json(self):
        response = self.client.get(reverse('list_types_json'))
        self.assertEqual(response.status_code, 200)

        types = simplejson.loads(response.content)

        # The number of types includes any schemas loaded via
        # migrations or initial_data fixtures from ebpub.db *and* any
        # other apps in INSTALLED_APPS that load schemas. Ugh.
        self.assert_(len(types) >= 1, "no schemas loaded")

        t1 = types['test-schema']
        self.assertEqual(sorted(t1.keys()),
                         ['attributes',
                          'indefinite_article',
                          'last_updated',
                          'name',
                          'plural_name',
                          'slug',
                          ]
                         )
        self.assertEqual(t1['indefinite_article'], 'a')
        self.assertEqual(t1['last_updated'], '2007-12-10')
        self.assertEqual(t1['name'], 'Test schema item')
        self.assertEqual(t1['plural_name'], 'Test schema items')
        self.assertEqual(t1['slug'], 'test-schema')
        self.assertEqual(sorted(t1['attributes'].keys()),
                         ['bool', 'date', 'datetime', 'int', 'lookup',
                          'time', 'varchar',
                          ])
        self.assertEqual(t1['attributes']['varchar'],
                         {'pretty_name': 'Varchar', 'type': 'text',})
        self.assertEqual(t1['attributes']['lookup'],
                         {'pretty_name': 'Lookups', 'type': 'text'})
        self.assertEqual(t1['attributes']['bool'],
                         {'pretty_name': 'Bool', 'type': 'bool'})
        self.assertEqual(t1['attributes']['datetime'],
                         {'pretty_name': 'Datetime', 'type': 'datetime'})

    def test_jsonp(self):
        # Quick test that API endpoints are respecting the jsonp query
        # parameter.
        param = 'jsonp'
        wrapper = 'FooseBall'
        qs = '?%s=%s' % (param, wrapper)

        endpoints = [
            reverse('geocoder_api') + qs + '&q=Hood+1',
            reverse('items_json') + qs,
            reverse('list_types_json') + qs,
            reverse('locations_json') + qs,
            reverse('location_types_json') + qs,
            reverse('location_detail_json', kwargs={'slug': 'hood-1', 'loctype': 'neighborhoods'}) + qs,
        ]

        for e in endpoints:
            response = self.client.get(e)
            self.assertEqual(response.status_code, 200)
            self.assertEqual(response.content[:len(wrapper) + 1],
                             '%s(' % wrapper)
            self.assertEqual(response.content[-2:], ');')
            self.assertEqual(response.get('content-type', '')[:22],
                             'application/javascript')

    def test_items_redirect(self):
        url = reverse('items_index')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'],
                         'http://testserver' + reverse('items_json'))


@mock.patch('ebpub.openblockapi.views.throttle_check', mock.Mock(return_value=0))
class TestPushAPI(BaseTestCase):

    fixtures = ('test-schema',)

    def _make_geojson(self, coords, **props):
        return {
            "type": "Feature",
            "geometry": {
                "type": "Point", "coordinates": coords,
                },
            "properties": props
            }


    @mock.patch('ebpub.openblockapi.views.check_api_authorization',
                mock.Mock(return_value=True))
    def test_create_basic(self):
        info = self._make_geojson(coords=[1.0, -1.0],
                                  description="Bananas!",
                                  title="All About Fruit",
                                  location_name="somewhere",
                                  url="http://example.com/bananas",
                                  item_date="2011-01-01",
                                  type="test-schema",
                                  )

        json = simplejson.dumps(info)
        url = reverse('items_index')
        response = self.client.post(url, json, content_type='application/json')
        self.assertEqual(response.status_code, 201)
        new_item = NewsItem.objects.get(title='All About Fruit')
        self.assertEqual(
            response['location'],
            'http://testserver' + reverse('single_item_json', args=(), kwargs={'id_': new_item.id}))
        self.assertEqual(new_item.url, info['properties']['url'])
        # ... etc.


    def test_create__no_schema(self):
        info = self._make_geojson(coords=[1.0, 2.0])
        with self.assertRaises(views.InvalidNewsItem) as e:
            views._item_create(info)
        self.assertEqual(e.exception.errors,
                         {'type': 'schema None does not exist'})

    def test_create__no_geojson(self):
        info = {'type': 'ouchie'}
        with self.assertRaises(views.InvalidNewsItem) as e:
            views._item_create(info)
        self.assertEqual(e.exception.errors,
                         {'type': 'not a valid GeoJSON Feature'})

    def test_create__bad_dates(self):
        info = self._make_geojson(coords=[1.0, -1.0], type='test-schema',
                                  name='hello', title='hello title',
                                  description='hello descr', url='http://foo.com',
                                  item_date='ouch', location_name='here',
                                  )
        with self.assertRaises(views.InvalidNewsItem) as e:
            views._item_create(info)
        self.assertEqual(e.exception.errors,
                         {'item_date': [u'Enter a valid date.']})

    @mock.patch('ebpub.openblockapi.views._get_location_info')
    def test_create__missing_required_fields(self, mock_get_loc_info):
        mock_get_loc_info.return_value = (geos.Point(1,-1), 'somewhere')
        info = self._make_geojson(coords=[1.0, -1.0], type='test-schema')
        with self.assertRaises(views.InvalidNewsItem) as e:
            views._item_create(info)
        self.assertEqual(e.exception.errors,
                         {'title': [u'This field is required.'],
                          })

    @mock.patch('ebpub.openblockapi.views._get_location_info')
    def test_create_with_existing_lookups(self, mock_get_loc_info):
        mock_get_loc_info.return_value = (geos.Point(1,-1), 'somewhere')
        info = self._make_geojson(coords=[1.0, -1.0],
                                  lookup=['Lookup 7700 Name', 'Lookup 7701 Name'],
                                  type='test-schema',
                                  title='I have lookups', description='yes i do',
                                  url='http://foo.com',
                                  )
        views._item_create(info)
        item = NewsItem.objects.get(title='I have lookups')
        self.assertEqual(item.attributes['lookup'], u'7700,7701')


    @mock.patch('ebpub.openblockapi.views._get_location_info')
    def test_create_with_new_lookups(self, mock_get_loc_info):
        mock_get_loc_info.return_value = (geos.Point(1,-1), 'somewhere')
        info = self._make_geojson(coords=[1.0, -1.0],
                                  lookup=['Lookup 7702 Name', 'Lookup 7703 Name'],
                                  type='test-schema',
                                  title='I have lookups too', description='yes i do',
                                  url='http://foo.com',
                                  )
        views._item_create(info)
        item = NewsItem.objects.get(title='I have lookups too')
        self.assertEqual(item.attributes['lookup'], u'7702,7703')


@mock.patch('ebpub.openblockapi.views.throttle_check', mock.Mock(return_value=0))
class TestQuickAPIErrors(BaseTestCase):
    # Test errors that happen before filters get applied,
    # so, no fixtures needed.

    def test_jsonp__alphanumeric_only(self):
        import urllib
        params = {'jsonp': '()[]{};"<./,abc_XYZ_123~!@#$'}
        url = reverse('items_json') + '?' + urllib.urlencode(params)
        response = self.client.get(url)
        munged_value = 'abc_XYZ_123'
        self.assertEqual(response.content.strip()[:12], munged_value + '(')
        self.assertEqual(response.content.strip()[-2:], ');')


    def test_not_allowed(self):
        response = self.client.delete(reverse('items_index'))
        self.assertEqual(response.status_code, 405)
        response = self.client.put(reverse('items_index'))
        self.assertEqual(response.status_code, 405)

    @mock.patch('ebpub.openblockapi.views.LOCAL_TZ', pytz.timezone('US/Pacific'))
    def test_items_filter_date_invalid(self):
        qs = "?startdate=oops"
        response = self.client.get(reverse('items_json') + qs)
        self.assertContains(response, "Invalid start date", status_code=400)

        qs = "?enddate=oops"
        response = self.client.get(reverse('items_json') + qs)
        self.assertContains(response, "Invalid end date", status_code=400)

        # Atom too
        qs = "?enddate=oops"
        response = self.client.get(reverse('items_atom') + qs)
        self.assertContains(response, "Invalid end date", status_code=400)



@mock.patch('ebpub.openblockapi.views.LOCAL_TZ', pytz.timezone('US/Pacific'))
@mock.patch('ebpub.openblockapi.views.throttle_check', mock.Mock(return_value=0))
class TestItemSearchAPI(BaseTestCase):

    fixtures = ('test-item-search.json', 'test-schema.yaml')

    def tearDown(self):
        NewsItem.objects.all().delete()

    def test_single_item_json__notfound(self):
        id_ = '99999'
        response = self.client.get(reverse('single_item_json', kwargs={'id_': id_}))
        self.assertEqual(response.status_code, 404)

    def test_single_item_json(self):
        schema1 = Schema.objects.get(slug='type1')
        zone = 'US/Pacific'
        with self.settings(TIME_ZONE=zone):
            item = _make_items(1, schema1)[0]
            item.save()
            id_ = item.id
            response = self.client.get(reverse('single_item_json', kwargs={'id_': id_}))
            self.assertEqual(response.status_code, 200)
            out = simplejson.loads(response.content)
            self.assertEqual(out['type'], 'Feature')
            self.assert_('geometry' in out.keys())
            self.assertEqual(out['geometry']['type'], 'Point')
            self.assert_('properties' in out.keys())
            self.assertEqual(out['properties']['title'], item.title)
            self.assertEqual(out['properties']['description'], item.description)
            self.assertEqual(out['properties']['type'], schema1.slug)


    def test_items_nofilter(self):
        # create a few items
        schema1 = Schema.objects.get(slug='type1')
        schema2 = Schema.objects.get(slug='type2')
        items = []
        zone = 'US/Eastern'
        with self.settings(TIME_ZONE=zone):
            items += _make_items(5, schema1)
            items += _make_items(5, schema2)
            for item in items:
                item.save()

            response = self.client.get(reverse('items_json'))
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)

            assert len(ritems['features']) == len(items)

    def test_items_atom_nofilter(self):
        zone = 'America/Chicago'
        with self.settings(TIME_ZONE=zone):
            schema1 = Schema.objects.get(slug='type1')
            schema2 = Schema.objects.get(slug='type2')
            items = _make_items(5, schema1) + _make_items(5, schema2)
            for item in items:
                item.save()
            response = self.client.get(reverse('items_atom'))
            self.assertEqual(response.status_code, 200)
            self.assertEqual(response['content-type'], 'application/atom+xml')
            feed = feedparser.parse(response.content)
            self.assertEqual(feed['feed']['title'], u'openblock news item atom feed')
            self.assertEqual(len(feed['entries']), len(items))
            assert self._items_exist_in_xml_result(items, response.content)

    def test_items_filter_schema(self):
        zone = 'Asia/Dubai'
        with self.settings(TIME_ZONE=zone):
            # create a few items of each of two schema types
            schema1 = Schema.objects.get(slug='type1')
            schema2 = Schema.objects.get(slug='type2')
            items1 = _make_items(5, schema1)
            items2 = _make_items(5, schema2)
            for item in items1 + items2:
                item.save()

            # query for only the second schema
            response = self.client.get(reverse('items_json') + "?type=type2")
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)

            self.assertEqual(len(ritems['features']), len(items2))
            for item in ritems['features']:
                assert item['properties']['type'] == 'type2'
            assert self._items_exist_in_result(items2, ritems)

            # query for both schemas.
            response = self.client.get(reverse('items_json') + "?type=type2&type=type1")
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            self.assertEqual(len(ritems['features']), len(items2 + items1))



    def test_items_atom_filter_schema(self):
        zone = 'Australia/North'
        with self.settings(TIME_ZONE=zone):
            # create a few items of each of two schema types
            schema1 = Schema.objects.get(slug='type1')
            schema2 = Schema.objects.get(slug='type2')
            items1 = _make_items(5, schema1)
            items2 = _make_items(5, schema2)
            for item in items1 + items2:
                item.save()

            # query for only the second schema
            response = self.client.get(reverse('items_atom') + "?type=type2")
            self.assertEqual(response.status_code, 200)
            feed = feedparser.parse(response.content)

            assert len(feed['entries']) == len(items2)
            for item in feed['entries']:
                # Yay feedparser, we don't know how it will spell the
                # openblock:type element, varies depending on... something.
                assert item.get('openblock_type', item.get('type')) == u'type2'


    def test_extension_fields_json(self):
        zone = 'Europe/Malta'
        with self.settings(TIME_ZONE=zone):
            schema = Schema.objects.get(slug='test-schema')

            ext_vals = {
                'varchar': ('This is a varchar', 'This is a varchar'), 
                'date': (datetime.date(2001, 01, 02), '2001-01-02'),
                'time': (datetime.time(hour=10, minute=11, second=12), 
                         '10:11:12-08:00'),
                'datetime': (datetime.datetime(2001, 01, 02, hour=10, minute=11, second=12),
                             '2001-01-02T10:11:12-08:00'),
                'bool': (True, True),
                'int': (7, 7),
                'lookup': ('7701,7700', ['Lookup 7701 Name', 'Lookup 7700 Name']),
            }

            items = _make_items(5, schema)
            for item in items:
                item.save()
                for k,v in ext_vals.items():
                    item.attributes[k] = v[0]

            response = self.client.get(reverse('items_json'))
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)

            self.assertEqual(len(ritems['features']), len(items))
            for item in ritems['features']:
                for k, v in ext_vals.items():
                    self.assertEqual(item['properties'][k], v[1])
            assert self._items_exist_in_result(items, ritems)


    def test_extension_fields_atom(self):
        zone = 'Pacific/Fiji'
        with self.settings(TIME_ZONE=zone):
            schema = Schema.objects.get(slug='test-schema')
            ext_vals = {
                'varchar': ('This is a varchar', 'This is a varchar'), 
                'date': (datetime.date(2001, 01, 02), '2001-01-02'),
                'time': (datetime.time(hour=10, minute=11, second=12), 
                         '10:11:12-08:00'),
                'datetime': (datetime.datetime(2001, 01, 02, hour=10, minute=11, second=12),
                             '2001-01-02T10:11:12-08:00'),
                'bool': (True, 'True'),
                'int': (7, '7'),
                'lookup': ('7700,7701', 'Lookup 7700 Name'),  # only check 1
            }

            items = _make_items(5, schema)
            for item in items:
                item.save()
                for k,v in ext_vals.items():
                    item.attributes[k] = v[0]

            response = self.client.get(reverse('items_atom'))
            self.assertEqual(response.status_code, 200)

            # Darn feedparser throws away nested extension elements. Gahhh.
            # Okay, let's parse the old-fashioned way.
            from lxml import etree
            root = etree.fromstring(response.content)
            ns = {'atom': 'http://www.w3.org/2005/Atom',
                  'openblock': 'http://openblock.org/ns/0'}

            entries = root.xpath('//atom:entry', namespaces=ns)
            assert len(entries) == len(items)
            for entry in entries:
                for key, value in sorted(ext_vals.items()):
                    attrs = entry.xpath(
                        'openblock:attributes/openblock:attribute[@name="%s"]' % key,
                        namespaces=ns)
                    if key == 'lookup':
                        self.assertEqual(len(attrs), 2)
                    else:
                        self.assertEqual(len(attrs), 1)
                    self.assertEqual(attrs[0].text, value[1])
            assert self._items_exist_in_xml_result(items, response.content)


    def test_items_filter_daterange_rfc3339(self):
        import pyrfc3339
        import pytz
        zone='US/Pacific'
        local_tz = pytz.timezone(zone)
        with self.settings(TIME_ZONE=zone):
            # create some items, they will have
            # dates spaced apart by one day, newest first
            schema1 = Schema.objects.get(slug='type1')
            items = _make_items(4, schema1)
            for item in items:
                item.save()

            # filter out the first and last item by constraining
            # the date range to the inner two items.
            # (Use local timezone for consistency with _make_items())
            startdate = pyrfc3339.generate(items[2].pub_date.replace(tzinfo=local_tz))
            enddate = pyrfc3339.generate(items[1].pub_date.replace(tzinfo=local_tz))
            # filter both ends
            qs = "?startdate=%s&enddate=%s" % (startdate, enddate)
            response = self.client.get(reverse('items_json') + qs)
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            self.assertEqual(len(ritems['features']), 2)
            assert self._items_exist_in_result(items[1:3], ritems)

            # startdate only
            qs = "?startdate=%s" % startdate
            response = self.client.get(reverse('items_json') + qs)
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            assert len(ritems['features']) == 3
            assert self._items_exist_in_result(items[:-1], ritems)

            # enddate only
            qs = "?enddate=%s" % enddate
            response = self.client.get(reverse('items_json') + qs)
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            assert len(ritems['features']) == 3
            assert self._items_exist_in_result(items[1:], ritems)

    def test_items_filter_daterange(self):
        zone = 'UTC'
        with self.settings(TIME_ZONE=zone):
            # create some items, they will have
            # dates spaced apart by one day, newest first
            schema1 = Schema.objects.get(slug='type1')
            items = _make_items(4, schema1)
            for item in items:
                cd = item.item_date
                item.pub_date = datetime.datetime(year=cd.year, month=cd.month, day=cd.day)
                item.save()

            # filter out the first and last item by constraining
            # the date range to the inner two items
            startdate = items[2].pub_date.strftime('%Y-%m-%d')
            enddate = items[1].pub_date.strftime('%Y-%m-%d')

            # filter both ends
            qs = "?startdate=%s&enddate=%s" % (startdate, enddate)
            response = self.client.get(reverse('items_json') + qs)
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            assert len(ritems['features']) == 2
            assert self._items_exist_in_result(items[1:3], ritems)

            # startdate only
            qs = "?startdate=%s" % startdate
            response = self.client.get(reverse('items_json') + qs)
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            assert len(ritems['features']) == 3
            assert self._items_exist_in_result(items[:-1], ritems)

            # enddate only
            qs = "?enddate=%s" % enddate
            response = self.client.get(reverse('items_json') + qs)
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            assert len(ritems['features']) == 3
            assert self._items_exist_in_result(items[1:], ritems)

    def test_items_limit_offset(self):
        zone = 'Europe/Vienna'
        with self.settings(TIME_ZONE=zone):
            # create a bunch of items
            schema1 = Schema.objects.get(slug='type1')
            items = _make_items(10, schema1)
            for item in items:
                item.save()

            # with no query, we should get all the items
            response = self.client.get(reverse('items_json'))
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            assert len(ritems['features']) == len(items)
            assert self._items_exist_in_result(items, ritems)

            # limited to 5, we should get the first 5
            qs = "?limit=5"
            response = self.client.get(reverse('items_json') + qs)
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            assert len(ritems['features']) == 5
            assert self._items_exist_in_result(items[:5], ritems)

            # offset by 2, we should get the last 8
            qs = "?offset=2"
            response = self.client.get(reverse('items_json') + qs)
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            assert len(ritems['features']) == 8
            assert self._items_exist_in_result(items[2:], ritems)

            # offset by 2, limit to 5
            qs = "?offset=2&limit=5"
            response = self.client.get(reverse('items_json') + qs)
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            assert len(ritems['features']) == 5
            assert self._items_exist_in_result(items[2:7], ritems)

    def test_items_predefined_location(self):
        zone = 'Europe/Zurich'
        with self.settings(TIME_ZONE=zone):
            # create a bunch of items that are nowhere in particular
            schema1 = Schema.objects.get(slug='type1')
            items_nowhere = _make_items(5, schema1, 'nowhere ')
            for item in items_nowhere:
                item.save()

            # make some items that are centered on a location
            loc = Location.objects.get(slug='hood-1')
            pt = loc.location.centroid
            items_hood1 = _make_items(5, schema1, 'hood1 ')
            for item in items_hood1:
                item.location = pt
                item.save()

            qs = "?locationid=%s" % cgi.escape("neighborhoods/hood-1")
            response = self.client.get(reverse('items_json') + qs)
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            assert len(ritems['features']) == 5
            assert self._items_exist_in_result(items_hood1, ritems)
            # TODO what we really want is to assert *none* of these are found
            self.failIf(self._items_exist_in_result(items_nowhere, ritems))

            # make some items that are centered on another location
            loc2 = Location.objects.get(slug='hood-2')
            pt2 = loc2.location.centroid
            items_hood2 = _make_items(3, schema1, 'hood2 ')
            for item in items_hood2:
                item.location = pt2
                item.save()
            qs2 = qs + "&locationid=%s" % cgi.escape("neighborhoods/hood-2")
            response = self.client.get(reverse('items_json') + qs2)
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            self.assertEqual(len(ritems['features']), 8)
            self.assert_(self._items_exist_in_result(items_hood1, ritems))
            self.assert_(self._items_exist_in_result(items_hood2, ritems))
            # TODO what we really want is to assert *none* of these are found
            self.failIf(self._items_exist_in_result(items_nowhere, ritems))


    def test_items_radius(self):
        zone = 'Asia/Saigon'
        with self.settings(TIME_ZONE=zone):
            # create a bunch of items nowhere in particular
            schema1 = Schema.objects.get(slug='type1')
            items_nowhere = _make_items(5, schema1, 'nowhere ')
            for item in items_nowhere:
                item.save()

            # make some items that are centered on a location
            loc = Location.objects.get(slug='hood-1')
            pt = loc.location.centroid
            items_hood1 = _make_items(5, schema1, 'hood1 ')
            for item in items_hood1:
                item.location = pt
                item.save()

            qs = "?center=%f,%f&radius=10" % (pt.x, pt.y)
            response = self.client.get(reverse('items_json') + qs)
            self.assertEqual(response.status_code, 200)
            ritems = simplejson.loads(response.content)
            assert len(ritems['features']) == 5
            self.assert_(self._items_exist_in_result(items_hood1, ritems))
            self.failIf(self._items_exist_in_result(items_nowhere, ritems))


    def _items_exist_in_result(self, items, ritems):
        all_ids = set([i['properties']['id'] for i in ritems['features']])
        for item in items:
            if not item.id in all_ids: 
                return False
        return True

    def _items_exist_in_xml_result(self, items, xmlstring):
        from lxml import etree
        root = etree.fromstring(xmlstring)
        ns = {'atom': 'http://www.w3.org/2005/Atom',
              'openblock': 'http://openblock.org/ns/0'}

        title_nodes = root.xpath('//atom:entry/atom:title', namespaces=ns)
        all_titles = set([t.text for t in title_nodes])
        for item in items:
            if not item.title in all_titles:
                return False
        return True

def _make_items(number, schema, title_prefix=''):
    items = []
    from django.conf import settings
    local_tz = pytz.timezone(settings.TIME_ZONE)
    curdate = datetime.datetime.now().replace(microsecond=0, tzinfo=local_tz)
    inc = datetime.timedelta(days=-1)
    for i in range(number):
        desc = '%s item %d' % (schema.slug, i)
        items.append(NewsItem(schema=schema,
                              title=title_prefix+desc,
                              description=desc,
                              item_date=curdate.date(),
                              pub_date=curdate,
                              location=geos.Point(0,0)))
        curdate += inc
    return items

@mock.patch('ebpub.openblockapi.views.throttle_check', mock.Mock(return_value=0))
class TestGeocoderAPI(BaseTestCase):

    fixtures = ('test-locationtypes', 
                'test-locations.json',
                'test-placetypes.json',
                'test-places.json', 
                'test-streets.json',)

    def test_missing_params(self):
        response = self.client.get(reverse('geocoder_api'))
        self.assertEqual(response.status_code, 400)

    def test_address(self):
        qs = '?q=100+Adams+St'
        response = self.client.get(reverse('geocoder_api') + qs)
        self.assertEqual(response.status_code, 200)
        response = simplejson.loads(response.content)
        assert response['type'] == 'FeatureCollection'
        assert len(response['features']) == 1
        res = response['features'][0]
        assert res['geometry']['type'] == 'Point'
        assert res['properties']['type'] == 'address'
        assert res['properties']['address'] == '100 Adams St.'


    def test_address_notfound(self):
        qs = '?q=100+Nowhere+St'
        response = self.client.get(reverse('geocoder_api') + qs)
        self.assertEqual(response.status_code, 404)
        response = simplejson.loads(response.content)
        self.assertEqual(len(response['features']), 0)

    def test_intersection(self):
        qs = '?q=Adams+and+Chestnut'
        response = self.client.get(reverse('geocoder_api') + qs)
        self.assertEqual(response.status_code, 200)
        response = simplejson.loads(response.content)
        assert response['type'] == 'FeatureCollection'
        assert len(response['features']) == 1
        res = response['features'][0]
        assert res['geometry']['type'] == 'Point'
        assert res['properties']['type'] == 'address'
        assert res['properties']['address'] == 'Adams St. & Chestnut St.'

    def test_place(self):
        qs = '?q=Fake+Yards'
        response = self.client.get(reverse('geocoder_api') + qs)
        self.assertEqual(response.status_code, 200)
        response = simplejson.loads(response.content)
        assert response['type'] == 'FeatureCollection'
        assert len(response['features']) == 1
        res = response['features'][0]
        assert res['geometry']['type'] == 'Point'
        assert res['properties']['type'] == 'place'
        assert res['properties']['name'] == 'Fake Yards'

    def test_location(self):
        qs = '?q=Hood+1'
        response = self.client.get(reverse('geocoder_api') + qs)
        self.assertEqual(response.status_code, 200)
        response = simplejson.loads(response.content)
        assert response['type'] == 'FeatureCollection'
        assert len(response['features']) == 1
        res = response['features'][0]
        assert res['geometry']['type'] == 'Point'
        assert res['properties']['type'] == 'neighborhoods'
        assert res['properties']['name'] == 'Hood 1'


    def test_ambiguous(self):
        qs = '?q=Chestnut+and+Chestnut'
        response = self.client.get(reverse('geocoder_api') + qs)
        self.assertEqual(response.status_code, 200)
        response = simplejson.loads(response.content)
        assert response['type'] == 'FeatureCollection'
        assert len(response['features']) == 2

        names = set()
        for res in response['features']: 
            assert res['geometry']['type'] == 'Point'
            assert res['properties']['type'] == 'address'
            names.add(res['properties']['address'])

        assert "Chestnut Sq. & Chestnut Ave." in names
        assert "Chestnut Pl. & Chestnut Ave." in names


@mock.patch('ebpub.openblockapi.views.throttle_check', mock.Mock(return_value=0))
class TestLocationsAPI(BaseTestCase):

    fixtures = ('test-locationtypes.json', 'test-locations.json')

    def test_locations_json(self):
        response = self.client.get(reverse('locations_json'))
        self.assertEqual(response.status_code, 200)

        locations = simplejson.loads(response.content)
        self.assertEqual(type(locations), list)
        self.assertEqual(len(locations), 4)
        for loc in locations:
            self.assertEqual(sorted(loc.keys()),
                             ['city', 'description', 'id', 'name', 'slug', 'type', 'url'])
            self.assertEqual(loc['city'], 'boston')
            self.assert_(loc['type'] in ['zipcodes', 'neighborhoods'])
        self.assertEqual(locations[0]['slug'], 'zip-1')
        self.assertEqual(locations[0]['name'], 'Zip 1')

    def test_locations_json_by_type(self):
        qs = '?type=neighborhoods'
        response = self.client.get(reverse('locations_json') + qs)
        self.assertEqual(response.status_code, 200)
        locations = simplejson.loads(response.content)
        self.assertEqual(type(locations), list)
        self.assertEqual(len(locations), 2)
        for loc in locations:
            self.assertEqual(sorted(loc.keys()),
                             ['city', 'description', 'id', 'name', 'slug', 'type', 'url'])
            self.assertEqual(loc['city'], 'boston')
            self.assert_(loc['type'] == 'neighborhoods')
        self.assertEqual(locations[0]['slug'], 'hood-1')
        self.assertEqual(locations[0]['name'], 'Hood 1')

    def test_location_detail__invalid_type(self):
        response = self.client.get(reverse('location_detail_json', kwargs={'slug': 'hood-1', 'loctype': 'bogus'}))
        self.assertEqual(response.status_code,404)

    def test_location_detail__invalid_slug(self):
        response = self.client.get(reverse('location_detail_json', kwargs={'slug': 'bogus', 'loctype': 'neighborhoods'}))
        self.assertEqual(response.status_code,404)

    def _get_detail(self):
        url = reverse('location_detail_json', kwargs={'slug': 'hood-1', 'loctype': 'neighborhoods'})
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        detail = simplejson.loads(response.content)
        return detail

    def test_location_detail_json(self):
        detail = self._get_detail()
        self.assertEqual(type(detail), dict)
        self.assertEqual(sorted(detail.keys()), ['geometry', 'id', 'properties', 'type'])
        self.assertEqual(detail['type'], 'Feature')

    def test_location_detail_json__properties(self):
        detail = self._get_detail()
        props = detail['properties']
        self.assertEqual(type(props), dict)
        self.assertEqual(sorted(props.keys()),
                         ['area', 'centroid', 'city', 'description', 'name', 'openblock_type', 'population', 'slug', 'source', 'type'])
        self.assertEqual(type(props['area']), float)
        self.assert_(isinstance(props['city'], basestring))
        self.assert_(isinstance(props['description'], basestring))
        self.assertEqual(props['slug'], 'hood-1')
        self.assertEqual(props['name'], 'Hood 1')
        self.assertEqual(props['population'], None)
        self.assert_(props['centroid'].startswith('POINT ('))


    def test_location_detail_json__geometry(self):
        detail = self._get_detail()
        geom = detail['geometry']
        self.assertEqual(type(geom), dict)
        self.assertEqual(sorted(geom.keys()), ['coordinates', 'type'])
        self.assertEqual(geom['type'], 'MultiPolygon')
        coords = geom['coordinates'][0][0]
        self.assert_(len(coords), "No coordinates")
        for coord in coords:
            self.assertEqual(len(coord), 2)
            self.assertEqual(type(coord[0]), float)
            self.assertEqual(type(coord[1]), float)

    def test_location_types(self):
        response = self.client.get(reverse('location_types_json'))
        self.assertEqual(response.status_code, 200)
        types = simplejson.loads(response.content)
        self.assertEqual(len(types), 2)
        for typeinfo in types.values():
            self.assertEqual(sorted(typeinfo.keys()),
                             ['name', 'plural_name', 'scope'])
        t1 = types['neighborhoods']
        self.assertEqual(t1['name'], 'neighborhood')
        self.assertEqual(t1['plural_name'], 'neighborhoods')
        self.assertEqual(t1['scope'], 'boston')


@mock.patch('ebpub.openblockapi.views.throttle_check', mock.Mock(return_value=0))
class TestPlacesAPI(BaseTestCase):

    fixtures = ('test-placetypes.json', 'test-places.json')

    def test_place_types_json(self):
        response = self.client.get(reverse('place_types_json'))

        types = simplejson.loads(response.content)
        self.assertEqual(len(types), 2)
        for typeinfo in types.values():
            self.assertEqual(sorted(typeinfo.keys()),
                             ['geojson_url', 'name', 'plural_name'])
        t1 = types['poi']
        self.assertEqual(t1['name'], 'Point of Interest')
        self.assertEqual(t1['plural_name'], 'Points of Interest')

        t1 = types['police']
        self.assertEqual(t1['name'], 'Police Station')
        self.assertEqual(t1['plural_name'], 'Police Stations')

    def test_place_detail_json(self):
        response = self.client.get(reverse('place_detail_json', kwargs={'placetype': 'poi'}))
        places = simplejson.loads(response.content)
        self.assertEqual(len(places['features']), 2)

        names = set([x['properties']['name'] for x in places['features']])
        self.assertTrue('Fake Monument' in names)
        self.assertTrue('Fake Yards' in names)

        response = self.client.get(reverse('place_detail_json', kwargs={'placetype': 'police'}))
        places = simplejson.loads(response.content)
        self.assertEqual(len(places['features']), 2)

        names = set([x['properties']['name'] for x in places['features']])
        self.assertTrue('Faketown Precinct 1' in names)
        self.assertTrue('Faketown Precinct 2' in names)

    def test_place_detail_json__bogus_type(self):
        response = self.client.get(
            reverse('place_detail_json', kwargs={'placetype': 'Oops'}))
        self.assertEqual(response.status_code, 404)


@mock.patch('ebpub.openblockapi.views.throttle_check', mock.Mock(return_value=0))
class TestOpenblockAtomFeed(BaseTestCase):

    def test_root_attrs(self):
        from ebpub.openblockapi.views import OpenblockAtomFeed
        attrs = OpenblockAtomFeed('title', 'link', 'descr').root_attributes()
        self.assertEqual(attrs['xmlns:georss'], 'http://www.georss.org/georss')
        self.assertEqual(attrs['xmlns:openblock'], 'http://openblock.org/ns/0')

    # Not testing add_item_elements as it's an implementation detail
    # ... and, unlike root_attributes, is a pain to test.


class TestUtilFunctions(TestCase):

    def test_copy_nomulti(self):
        from ebpub.openblockapi.views import _copy_nomulti
        self.assertEqual(_copy_nomulti({}), {})
        self.assertEqual(_copy_nomulti({'a': 1}), {'a': 1})
        self.assertEqual(_copy_nomulti({'a': [1]}), {'a': 1})
        self.assertEqual(_copy_nomulti({'a': [1], 'b': [1,2,3]}),
                         {'a': 1, 'b': [1,2,3]})
        # It should work with a django Request too.
        request = RequestFactory().get('/foo/?a=1&b=2&b=3')
        self.assertEqual(_copy_nomulti(request.GET),
                         {'a': '1', 'b': ['2', '3']})


    def test_get_location_info(self):
        geom_dict = { "type": "Point", "coordinates": [100.0, 0.0] }
        geom, name = views._get_location_info(geom_dict, 'anywhere')
        self.assertEqual(geom.coords, (100.0, 0.0))
        self.assertEqual(name, 'anywhere')


    def test_check_api_auth__no_credentials(self):
        ip = '1.2.3.4'
        from django.core.exceptions import PermissionDenied
        request = mock.Mock(**{'user.is_authenticated.return_value': False,
                               'META': {'REMOTE_ADDR': ip},
                               'GET': {}, 'POST': {}})
        self.assertRaises(PermissionDenied, auth.check_api_authorization,
                          request)

    def test_check_api_auth__logged_in(self):
        ip = '1.2.3.4'
        request = mock.Mock(**{'user.is_authenticated.return_value': True,
                               'META': {'REMOTE_ADDR': ip},
                               'GET': {}, 'POST': {}})
        self.assertEqual(True, auth.check_api_authorization(request))

    def test_check_api_auth__key_invalid(self):
        from django.core.exceptions import PermissionDenied
        key = '12345'
        ip = '1.2.3.4'
        get_request = mock.Mock(**{'user.is_authenticated.return_value': False,
                                   'META': {'REMOTE_ADDR': ip,
                                            auth.KEY_HEADER: key},
                                   'GET': {}, 'POST': {}})
        self.assertRaises(PermissionDenied, auth.check_api_authorization,
                          get_request)


    def test_check_api_auth__key(self):
        from ebpub.openblockapi.apikey.models import generate_unique_api_key
        from ebpub.openblockapi.apikey.models import ApiKey
        from ebpub.accounts.models import User
        ip = '1.2.3.4'
        user = User.objects.create_user(email='bob@bob.com')
        key = ApiKey(key=generate_unique_api_key(), user=user)
        key.save()
        get_request = mock.Mock(**{'user.is_authenticated.return_value': False,
                                   'META': {'REMOTE_ADDR': ip,
                                            auth.KEY_HEADER: key},
                                   'session': mock.MagicMock(),
                                   'GET': {}, 'POST': {}})
        self.assertEqual(True, auth.check_api_authorization(get_request))

    @mock.patch('ebpub.openblockapi.views.patch_vary_headers')
    @mock.patch('ebpub.openblockapi.views.throttle_check')
    def test_rest_view_decorator__allowed_methods(self, throttle_check, patch_vary):
        from ebpub.openblockapi.views import rest_view
        from django.http import HttpResponseNotAllowed
        throttle_check.return_value = False

        @rest_view(['HEAD', 'PUT'])
        def foo(request):
            return request.method

        request = mock.Mock(method='GET')

        result = foo(request)
        self.assert_(isinstance(result, HttpResponseNotAllowed))

        request.method = 'HEAD'
        self.assertEqual(foo(request), 'HEAD')
        request.method = 'PUT'
        self.assertEqual(foo(request), 'PUT')
        request.method = 'ANYTHING ELSE'
        result = foo(request)
        self.assert_(isinstance(result, HttpResponseNotAllowed))

    @mock.patch('ebpub.openblockapi.views.patch_vary_headers')
    @mock.patch('ebpub.openblockapi.views.throttle_check')
    def test_rest_view_decorator__throttling(self, throttle_check, patch_vary):
        from ebpub.openblockapi.views import rest_view
        request = mock.Mock(method='GET')

        @rest_view(['GET'])
        def foo(request):
            return 'ok'

        throttle_check.return_value = 0
        self.assertEqual('ok', foo(request))

        throttle_check.return_value = 1234
        result = foo(request)
        self.assertEqual(result.status_code, 503)
        self.assertEqual(result['Retry-After'], '1234')

    @mock.patch('ebpub.openblockapi.views.throttle_check')
    def test_rest_view_decorator__vary(self, throttle_check):
        throttle_check.return_value = 0
        from ebpub.openblockapi.views import rest_view
        request = mock.Mock(method='GET')

        @rest_view(['GET'])
        def foo(request):
            from django.http import HttpResponse
            return HttpResponse('ok')

        result = foo(request)
        self.assertEqual(result.status_code, 200)
        self.assertEqual(result['Vary'], 'Authorization, Cookie, X-Openblock-Key')

    @mock.patch('ebpub.openblockapi.throttle.cache')
    def test_cachethrottle(self, mock_cache):
        import time
        from ebpub.openblockapi.throttle import CacheThrottle
        throttle_at=25
        throttle = CacheThrottle(throttle_at=throttle_at)

        mock_cache.get.return_value = []
        self.assertEqual(False, throttle.should_be_throttled('some_id'))
        mock_cache.get.return_value = [int(time.time())] * (throttle_at - 1)
        self.assertEqual(False, throttle.should_be_throttled('some_id'))

        mock_cache.get.return_value = [int(time.time())] * throttle_at
        self.assertEqual(True, throttle.should_be_throttled('some_id'))
        mock_cache.get.return_value = [int(time.time())] * (throttle_at + 1)
        self.assertEqual(True, throttle.should_be_throttled('some_id'))

    @mock.patch('ebpub.openblockapi.views.check_api_authorization')
    @mock.patch('ebpub.openblockapi.views._throttle')
    def test_throttlecheck(self, mock_throttle, mock_check_api_auth):
        from ebpub.openblockapi.views import throttle_check
        request = mock.Mock(**{'user.is_authenticated.return_value': True,
                               'REQUEST.get.return_value': 'anything'})
        mock_throttle.should_be_throttled.return_value = True
        mock_throttle.seconds_till_unthrottling.return_value = 99
        self.assertEqual(99, throttle_check(request))

        request = mock.Mock(**{'user.is_authenticated.return_value': False,
                               'META': {auth.KEY_HEADER: 'test-api-key',}})
        self.assertEqual(99, throttle_check(request))

        self.assertEqual(mock_throttle.accessed.call_count, 0)
        mock_throttle.should_be_throttled.return_value = False
        self.assertEqual(0, throttle_check(request))
        self.assertEqual(mock_throttle.accessed.call_count, 1)

########NEW FILE########
__FILENAME__ = throttle
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Throttle implementation borrowed from Django-Tastypie
http://github.com/toastdriven/django-tastypie/

Copyright 2011 Daniel Lindsley.  BSD license.
"""

import time
from django.core.cache import cache

class BaseThrottle(object):
    """
    A simplified, swappable base class for throttling.
    
    Does nothing save for simulating the throttling API and implementing
    some common bits for the subclasses.
    
    Accepts a number of optional kwargs::
    
        * ``throttle_at`` - the number of requests at which the user should
          be throttled. Default is 150 requests.
        * ``timeframe`` - the length of time (in seconds) in which the user
          make up to the ``throttle_at`` requests. Default is 3600 seconds (
          1 hour).
        * ``expiration`` - the length of time to retain the times the user
          has accessed the api in the cache. Default is 604800 (1 week).
    """
    def __init__(self, throttle_at=150, timeframe=3600, expiration=None):
        self.throttle_at = throttle_at
        # In seconds, please.
        self.timeframe = timeframe
        
        if expiration is None:
            # Expire in a week.
            expiration = 604800
        
        self.expiration = int(expiration)
    
    def convert_identifier_to_key(self, identifier):
        """
        Takes an identifier (like a username or IP address) and converts it
        into a key usable by the cache system.
        """
        bits = []
        
        for char in identifier:
            if char.isalnum() or char in ['_', '.', '-']:
                bits.append(char)
        
        safe_string = ''.join(bits)
        return "%s_accesses" % safe_string
    
    def should_be_throttled(self, identifier, **kwargs):
        """
        Returns whether or not the user has exceeded their throttle limit.
        
        Always returns ``False``, as this implementation does not actually
        throttle the user.
        """
        return False
    
    def accessed(self, identifier, **kwargs):
        """
        Handles recording the user's access.
        
        Does nothing in this implementation.
        """
        pass


class CacheThrottle(BaseThrottle):
    """
    A throttling mechanism that uses just the cache.
    """
    def should_be_throttled(self, identifier, **kwargs):
        """
        Returns whether or not the user has exceeded their throttle limit.
        
        Maintains a list of timestamps when the user accessed the api within
        the cache.
        
        Returns ``False`` if the user should NOT be throttled or ``True`` if
        the user should be throttled.
        """
        key = self.convert_identifier_to_key(identifier)
        
        # Make sure something is there.
        cache.add(key, [])
        
        # Weed out anything older than the timeframe.
        minimum_time = int(time.time()) - int(self.timeframe)
        times_accessed = [access for access in cache.get(key, ()) if access >= minimum_time]
        cache.set(key, times_accessed, self.expiration)
        
        if len(times_accessed) >= int(self.throttle_at):
            # Throttle them.
            return True
        
        # Let them through.
        return False
    
    def accessed(self, identifier, **kwargs):
        """
        Handles recording the user's access.
        
        Stores the current timestamp in the "accesses" list within the cache.
        """
        key = self.convert_identifier_to_key(identifier)
        times_accessed = cache.get(key, [])
        times_accessed.append(int(time.time()))
        cache.set(key, times_accessed, self.expiration)

    def seconds_till_unthrottling(self, identifier):
        """
        New feature for OpenBlock: try to figure out when the user will be un-throttled.
        """
        key = self.convert_identifier_to_key(identifier)
        times_accessed = cache.get(key, [])
        if not times_accessed:
            return 0
        # Assume we have already weeded out anything older than the timeframe.
        oldest = times_accessed[0]
        when = oldest + self.timeframe
        return when - int(time.time())


########NEW FILE########
__FILENAME__ = urls
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.

from django.conf.urls.defaults import patterns, url, handler404, handler500
from ebpub.openblockapi import views

urlpatterns = patterns(
    '',
    url(r'^$', views.check_api_available, name="check_api_available"),
    url(r'^geocode/$', views.geocode, name='geocoder_api'),
    url(r'^items.json$', views.items_json, name="items_json"),
    url(r'^items.atom$', views.items_atom, name="items_atom"),
    url(r'^items/types.json$', views.list_types_json, name="list_types_json"),
    url(r'^items/(?P<id_>\d+).json$', views.single_item_json, name="single_item_json"),
    url(r'^items/$', views.items_index, name="items_index"),
    url(r'^locations.json$', views.locations_json, name="locations_json"),
    url(r'^locations/types.json', views.location_types_json, name="location_types_json"),
    url(r'^locations/(?P<loctype>[^/].*)/(?P<slug>.*).json$', views.location_detail_json, name="location_detail_json"),
    url(r'^places/types.json', views.place_types_json, name="place_types_json"),
    url(r'^places/(?P<placetype>[^/].*).json$', views.place_detail_json, name="place_detail_json"),
)

########NEW FILE########
__FILENAME__ = views
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.

from apikey.auth import KEY_HEADER  # relative import
from apikey.auth import check_api_authorization  # relative import
from django.conf import settings
from django.core.exceptions import PermissionDenied
from django.core.urlresolvers import reverse
from django.http import Http404
from django.http import HttpResponse
from django.http import HttpResponseBadRequest
from django.http import HttpResponseNotAllowed
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404
from django.utils import feedgenerator
from django.utils import simplejson
from django.utils.cache import patch_response_headers
from django.utils.cache import patch_vary_headers
from ebpub.db import models
from ebpub.geocoder import DoesNotExist
from ebpub.geocoder.base import full_geocode
from ebpub.openblockapi.itemquery import _copy_nomulti
from ebpub.openblockapi.itemquery import build_item_query, build_place_query, QueryError
from ebpub.streets.models import PlaceType
from ebpub.utils.dates import parse_date, parse_time
from ebpub.utils.geodjango import ensure_valid
from ebpub.utils.models import is_instance_of_model
from ebpub.utils.view_utils import get_schema_manager
from functools import wraps
import copy
import datetime
import logging
import pyrfc3339
import pytz
import re

JSONP_QUERY_PARAM = 'jsonp'
ATOM_CONTENT_TYPE = "application/atom+xml"
JSON_CONTENT_TYPE = 'application/json'
JAVASCRIPT_CONTENT_TYPE = 'application/javascript'

LOCAL_TZ = pytz.timezone(settings.TIME_ZONE)

logger = logging.getLogger('openblockapi')

############################################################
# Util functions.
############################################################

def APIGETResponse(request, body, **kw):
    """
    constructs either a normal HTTPResponse using the
    keyword arguments given or a JSONP / JSONPX wrapped response
    depending on the presence and validity of
    JSONP_QUERY_PARAM in the request.

    This may alter the content type of the response
    if JSONP/JSONPX is triggered. Status is preserved.
    """
    jsonp = request.GET.get(JSONP_QUERY_PARAM)
    format = kw.setdefault('content_type', JSON_CONTENT_TYPE)
    if format == JSON_CONTENT_TYPE and not isinstance(body, basestring):
        body = simplejson.dumps(body, indent=1, default=_serialize_unknown)
    if jsonp is None:
        return HttpResponse(body, **kw)
    else:
        jsonp = re.sub(r'[^a-zA-Z0-9_]+', '', jsonp)
        body = '%s(%s);' % (jsonp, body)
        kw['content_type'] = JAVASCRIPT_CONTENT_TYPE
        return HttpResponse(body, **kw)

def normalize_datetime(dt):
    # XXX needs tests
    if dt.tzinfo is None:
        # Assume naive times are in local zone.
        dt = dt.replace(tzinfo=LOCAL_TZ)
    return dt.astimezone(LOCAL_TZ)

def get_datatype(schemafield):
    """
    Human-readable datatype based on real_name; notably, use 'text',
    not 'varchar'; Lookups are 'text'.
    """
    if schemafield.is_lookup:
        datatype = 'text'
    else:
        datatype = schemafield.datatype
        if datatype == 'varchar':
            datatype = 'text'
    return datatype


def api_items_geojson(items):
    """
    helper to produce the geojson of the same form as the 
    API in other contexts (not a view)
    """
    body = {'type': 'FeatureCollection',
            'features': [item for item in items if item.location]}
    return simplejson.dumps(body, indent=1, default=_serialize_unknown)

def _item_geojson_dict(item):
    # Prepare a single NewsItem as a structure that can be JSON-encoded.
    props = {}
    geom = simplejson.loads(item.location.geojson)
    result = {
        'type': 'Feature',
        'geometry': geom,
        }
    for attr in item.attributes_for_template():
        key = attr.sf.name
        if attr.sf.is_many_to_many_lookup():
            props[key] = attr.values
        else:
            try:
                props[key] = attr.values[0]
            except IndexError:
                props[key] = None

    props.update(
        {'type': item.schema.slug,
         'title': item.title,
         'description': item.description,
         'url': item.url,
         'pub_date': item.pub_date,
         'item_date': item.item_date,
         'id': item.id,
         'openblock_type': 'newsitem',
         'icon': item.schema.get_map_icon_url(),
         'color': item.schema.map_color,
         'location_name': item.location_name,
         })
    result['properties'] = props
    return result

def _serialize_unknown(obj):
    # Handle NewsItems and various other types that default json serializer
    # doesn't know how to do.
    if isinstance(obj, (datetime.datetime, datetime.date, datetime.time)):
        return serialize_date_or_time(obj)
    elif is_instance_of_model(obj, models.Lookup):
        return obj.name
    elif is_instance_of_model(obj, models.NewsItem):
        return _item_geojson_dict(obj)
    return None

def serialize_date_or_time(obj):
    if isinstance(obj, datetime.datetime):
        obj = normalize_datetime(obj)
        return pyrfc3339.generate(obj, utc=False)
    elif isinstance(obj, datetime.date):
        return obj.strftime('%Y-%m-%d')
    elif isinstance(obj, datetime.time):
        # XXX super ugly
        if obj.tzinfo is None:
            obj = obj.replace(tzinfo=LOCAL_TZ)
        dd = datetime.datetime.now()
        dd = dd.replace(hour=obj.hour, minute=obj.minute,
                        second=obj.second, tzinfo=obj.tzinfo)
        dd = normalize_datetime(dd)
        ss = pyrfc3339.generate(dd, utc=False)
        return ss.split('T', 1)[1]
    else:
        return None

def _get_location_info(geometry, location_name):
    location = None
    if geometry:
        # geometry is a decoded geojson geometry dict.
        # GEOSGeometry can already parse geojson geometries (as a string)...
        # but not the whole geojson string... so we have to re-encode
        # just the geometry :-P
        from django.contrib.gis.geos import GEOSGeometry
        location = GEOSGeometry(simplejson.dumps(geometry))
        location = ensure_valid(location)
        if not location_name:
            raise NotImplementedError("Should do reverse-geocoding here")
    elif location_name:
        raise NotImplementedError("Should do geocoding here.")
    return location, location_name

def rest_view(methods, cache_timeout=None):
    """
    Decorator that applies throttling and restricts the available HTTP
    methods, and optionally adds some HTTP cache headers based on cache_timeout.
    Also sets the Vary header.
    """
    def inner(func):
        @wraps(func)
        def wrapper(request, *args, **kwargs):
            if request.method not in methods:
                return HttpResponseNotAllowed(methods)
            # Note throttle_check() does auth as a side effect.
            seconds_throttled = throttle_check(request)
            if seconds_throttled > 0:
                msg = u'Throttle limit exceeded. Try again in %d seconds.\n' % seconds_throttled
                response = HttpResponse(msg, status=503)
                response['Retry-After'] = str(seconds_throttled)
                response['Content-Type'] = 'text/plain'
            else:
                response = func(request, *args, **kwargs)
                if cache_timeout is not None:
                    patch_response_headers(response, cache_timeout=cache_timeout)
            # Different users may have different stuff filtered.
            key_header = '-'.join(KEY_HEADER.split('_')[1:]).title()
            patch_vary_headers(response, ['Authorization', 'Cookie', key_header])
            return response

        return wrapper
    return inner

from ebpub.openblockapi.throttle import CacheThrottle


# We could have more than one throttle instance to be more flexible.
_throttle = CacheThrottle(
    throttle_at=getattr(settings, 'API_THROTTLE_AT', 150), # max requests per timeframe.
    timeframe=getattr(settings, 'API_THROTTLE_TIMEFRAME', 60 * 60), # default 1 hour.
    expiration=getattr(settings, 'API_THROTTLE_EXPIRATION', 60 * 60 * 24 * 7)  # default 1 week.
    )

def throttle_check(request):
    """
    Handles checking if the request should be throttled.

    If so, returns number of seconds after which user can try again.
    If not, returns 0.

    Based originally on code from TastyPie, copyright Daniel Lindsley,
    BSD license.

    Note this does API key auth as a side effect, if user is not
    already logged in.
    """
    # First get best user identifier available.
    if request.user.is_anonymous():
        try:
            check_api_authorization(request)
        except PermissionDenied:
            pass
    if request.user.is_authenticated():
        identifier = request.user.username
    else:
        # We don't check KEY_HEADER here because check_api_authorization()
        # should have resolved that to a valid user account.  So, if
        # we're still not authenticated, any KEY_HEADER in the request
        # was a bad key, and we should ignore it.
        identifier = "%s_%s" % (request.META.get('REMOTE_ADDR', 'noaddr'),
                                request.META.get('REMOTE_HOST', 'nohost'))

    if _throttle.should_be_throttled(identifier):
        # Throttle limit exceeded.
        return _throttle.seconds_till_unthrottling(identifier)

    # Log throttle access.
    _throttle.accessed(identifier, url=request.get_full_path(),
                      request_method=request.method.lower())
    return 0


class HttpResponseCreated(HttpResponseRedirect):
    status_code = 201

class HttpResponseUnavailable(HttpResponse):
    status_code = 503

############################################################
# View functions.
############################################################

@rest_view(['GET'], cache_timeout = 7 * 24 * 60 * 60)
def check_api_available(request):
    """
    endpoint to indicate that this version of the API
    is available.
    """
    return HttpResponse(status=200)

@rest_view(['GET'], cache_timeout=3600)
def items_json(request):
    """
    handles the items.json API endpoint
    """
    # TODO: support filtering by block + radius, and somehow support
    # adding extra info eg. popup html.  Together, that would allow
    # this to replace ebub.db.views.newsitems_geojson. See #81
    try:
        items, params = build_item_query(request)
        # could test for extra params aside from jsonp...
        items = [item for item in items if item.location is not None]
        items_geojson_dict = {'type': 'FeatureCollection',
                              'features': items
                              }
        return APIGETResponse(request, items_geojson_dict, content_type=JSON_CONTENT_TYPE)
    except QueryError as err:
        return HttpResponseBadRequest(err.message)

@rest_view(['GET'])
def items_atom(request):
    """
    handles the items.atom API endpoint
    """
    try:
        items, params = build_item_query(request)
        # could test for extra params aside from jsonp...
        items = [item for item in items if item.location is not None]
        return APIGETResponse(request, _items_atom(items), content_type=ATOM_CONTENT_TYPE)
    except QueryError as err:
        return HttpResponseBadRequest(err.message)

@rest_view(['GET', 'POST'])
def items_index(request):
    """
    GET: Redirects to a list of JSON items.

    POST: Takes a single JSON mapping describing a NewsItem, creates
    it, and redirects to a JSON view of the created item
    (HTTP response 201).

    On errors, gives a 400 response.

    """
    if request.method == 'GET':
        return HttpResponseRedirect(reverse('items_json'))
    elif request.method == 'POST':
        check_api_authorization(request)
        info = simplejson.loads(request.raw_post_data)
        try:
            item = _item_create(info)
        except InvalidNewsItem, e:
            errors = simplejson.dumps({'errors': e.errors}, indent=2)
            return HttpResponseBadRequest(errors, content_type=JSON_CONTENT_TYPE)
        item_url = reverse('single_item_json', kwargs={'id_': str(item.id)})
        return HttpResponseCreated(item_url)


class InvalidNewsItem(Exception):
    def __init__(self, errors):
        self.errors = errors

#@permission_required('db.add_newsitem')
def _item_create(info):
    info = copy.deepcopy(info)
    try:
        assert info.pop('type') == 'Feature'
        props = info['properties']
    except (KeyError, AssertionError):
        raise InvalidNewsItem({'type': 'not a valid GeoJSON Feature'})
    try:
        slug = props.pop('type', None)
        schema = models.Schema.objects.get(slug=slug)
    except (models.Schema.DoesNotExist):
        raise InvalidNewsItem({'type': 'schema %r does not exist' % slug})

    data = {'schema': schema.id}
    for key in ('title', 'description', 'url'):
        data[key] = props.pop(key, '')

    # If there are errors parsing the dates, keep the raw data and let
    # the ModelForm sort it out.
    pub_date = props.pop('pub_date', None)
    if pub_date:
        try:
            data['pub_date'] = normalize_datetime(pyrfc3339.parse(pub_date))
        except Exception:
            data['pub_date'] = pub_date
    else:
        data['pub_date'] = normalize_datetime(datetime.datetime.utcnow())
    item_date = props.pop('item_date', None)
    if item_date:
        try:
            data['item_date'] = parse_date(item_date, '%Y-%m-%d', False)
        except Exception:
            data['item_date'] = item_date
    else:
        try:
            data['item_date'] = data['pub_date'].date()
        except Exception:
            data['item_date'] = None

    data['location'], data['location_name'] = _get_location_info(
        info.get('geometry'), props.pop('location_name', None))
    if not data['location']:
        logger.warn("Saving NewsItem %s with no geometry" % data['title'])
    if not data['location_name']:
        logger.warn("Saving NewsItem %s with no location_name" % data['title'])


    from ebpub.db.forms import NewsItemForm
    form = NewsItemForm(data)
    if form.is_valid():
        item = form.save()
    else:
        raise InvalidNewsItem(form.errors)

    # Everything else goes in .attributes.
    attributes = {}
    for key, val in props.items():
        sf = models.SchemaField.objects.get(schema=schema, name=key)
        if sf.is_many_to_many_lookup():
            lookups = []
            for lookup_name in val:
                lookups.append(
                    models.Lookup.objects.get_or_create_lookup(sf, lookup_name))
            val = ','.join((str(lookup.id) for lookup in lookups))
        elif sf.is_lookup:
            val = models.Lookup.objects.get_or_create_lookup(sf, val)
        elif sf.is_type('date'):
            val = normalize_datetime(parse_date(val, '%Y-%m-%d'))
        elif sf.is_type('time'):
            val = normalize_datetime(parse_time(val, '%H:%M'))
        elif sf.is_type('datetime'):
            val = normalize_datetime(pyrfc3339.parse(datetime))
        attributes[key] = val
    item.attributes = attributes
    return item


@rest_view(['GET'], cache_timeout=3600)
def single_item_json(request, id_=None):
    """
    GET a single item as GeoJSON.
    """
    assert request.method == 'GET'
    # TODO: handle PUT, DELETE?
    from ebpub.db.models import NewsItem
    item = get_object_or_404(
        NewsItem.objects.by_request(request).select_related(), pk=id_)
    return APIGETResponse(request, item, content_type=JSON_CONTENT_TYPE)



def _items_atom(items):
    # XXX needs tests
    feed_url = reverse('items_atom')
    atom = OpenblockAtomFeed(
        title='openblock news item atom feed', description='',
        link=reverse('items_json'),  # For the rel=alternate link.
        feed_url=feed_url,
        id=feed_url,)

    for item in items:
        location = item.location
        if location:
            location = location.centroid
        attributes = []
        for attr in item.attributes_for_template():
            datatype = get_datatype(attr.sf)
            for val in attr.values:
                if attr.sf.is_lookup:
                    val = val.name
                attributes.append((attr.sf.name, datatype, val))
        atom.add_item(item.title,
                      item.url, # XXX should this be a local url?
                      item.description,
                      location=location,
                      location_name=item.location_name,
                      pubdate=normalize_datetime(item.pub_date),
                      schema_slug=item.schema.slug,
                      attributes=attributes,
                      )

    return atom.writeString('utf8')


@rest_view(['GET'], cache_timeout=3600)
def geocode(request):
    # TODO: this will obsolete:
    # ebdata.geotagger.views.geocode and 
    # ebpub.db.views.ajax_wkt
    q = request.GET.get('q', '').strip()
    if not q:
        return HttpResponseBadRequest('Missing or empty q parameter.')
    collection = {'type': 'FeatureCollection',
                  'features': _geocode_geojson(q)}
    if collection['features']:
        status = 200
    else:
        status = 404
    return APIGETResponse(request, simplejson.dumps(collection, indent=1),
                          content_type=JSON_CONTENT_TYPE, status=status)


def _geocode_geojson(query):
    """Geocode a string and return the result as a list of
    GeoJSON Features.
    """
    if not query: 
        return []
        
    try: 
        res = full_geocode(query)
        # normalize a bit
        if not res['ambiguous']: 
            res['result'] = [res['result']]
    except DoesNotExist:
        return []
        
    features = []
    if res['type'] == 'location':
        for r in res['result']: 
            feature = {
                'type': 'Feature',
                'geometry': simplejson.loads(r.location.centroid.geojson),
                'properties': {
                    'type': r.location_type.slug,
                    'name': r.name,
                    'city': r.city,
                    'query': query,
                }
            }
            features.append(feature)
    elif res['type'] == 'place':
        for r in res['result']: 
            feature = {
                'type': 'Feature',
                'geometry': simplejson.loads(r.location.geojson),
                'properties': {
                    'type': 'place',
                    'name': r.pretty_name,
                    'address': r.address, 
                    'query': query,
                }
            }
            features.append(feature)
    elif res['type'] == 'address':
        for r in res['result']:
            feature = {
                'type': 'Feature',
                'geometry': {
                    'type': 'Point',
                    'coordinates': [r.lng, r.lat],
                },
                'properties': {
                    'type': 'address',
                    'address': r.get('address'),
                    'city': r.get('city'),
                    'state': r.get('state'),
                    'zip': r.get('zip'),
                    'query': query
                }
            }
            features.append(feature)
    # we could get type == 'block', but 
    # ebpub.db.views.ajax_wkt returned nothing for this,
    # so for now we follow their lead.
    # elif res['type'] == 'block': 
    #     pass

    return features


@rest_view(['GET'], cache_timeout = 24 * 3600)
def list_types_json(request):
    """
    List the known NewsItem types (Schemas).
    """
    schemas = {}
    for schema in get_schema_manager(request).all():
        attributes = {}
        for sf in schema.schemafield_set.all():
            fieldtype = get_datatype(sf)
            attributes[sf.name] = {
                'pretty_name': sf.smart_pretty_name(),
                'type': fieldtype,
                # TODO: what else?
                }
            # TODO: should we enumerate known values of Lookups?
        schemas[schema.slug] = {
                'indefinite_article': schema.indefinite_article,
                'last_updated': schema.last_updated.strftime('%Y-%m-%d'),
                'name': schema.name,
                'plural_name': schema.plural_name,
                'slug': schema.slug,
                'attributes': attributes,
                }

    return APIGETResponse(request, simplejson.dumps(schemas, indent=1),
                          content_type=JSON_CONTENT_TYPE)

@rest_view(['GET'], cache_timeout=24 * 3600)
def locations_json(request):
    locations = models.Location.objects.filter(is_public=True)
    loctype = request.GET.get('type')
    if loctype is not None:
        locations = locations.filter(location_type__slug=loctype)

    locations = locations.order_by('display_order').select_related().defer('location')
    
    loc_objs = [
        {'id': "%s/%s" % (loc.location_type.slug, loc.slug),
         'slug': loc.slug, 'name': loc.name, 'city': loc.city,
         'type': loc.location_type.slug,
         'description': loc.description or '',
         'url': reverse('location_detail_json', kwargs={'slug': loc.slug, 'loctype': loc.location_type.slug})
         }
        for loc in locations]

    return APIGETResponse(request, simplejson.dumps(loc_objs, indent=1),
                          content_type=JSON_CONTENT_TYPE)

@rest_view(['GET'], cache_timeout=24 * 3600)
def location_detail_json(request, loctype, slug):
    # TODO: this will obsolete ebpub.db.views.ajax_location
    try:
        loctype_obj = models.LocationType.objects.get(slug=loctype)
    except (ValueError, models.LocationType.DoesNotExist):
        raise Http404("No such location type %r" % loctype)
    try:
        location = models.Location.objects.geojson().get(
            location_type=loctype_obj, slug=slug)
    except (ValueError, models.Location.DoesNotExist):
        raise Http404("No such location %r/%r" % (loctype, slug))
    geojson = {'type': 'Feature',
               'id': '%s/%s' % (loctype, slug),
               'geometry': simplejson.loads(location.geojson),
               'properties': {'type': loctype,
                              'slug': location.slug,
                              'source': location.source,
                              'description': location.description,
                              'centroid': location.location.centroid.wkt,
                              'area': location.area,
                              'population': location.population,
                              'city': location.city,
                              'name': location.name,
                              'openblock_type': 'location',
                              }
               }
    geojson = simplejson.dumps(geojson, indent=1)
    return APIGETResponse(request, geojson, content_type=JSON_CONTENT_TYPE)

@rest_view(['GET'], cache_timeout = 24 * 3600)
def location_types_json(request):
    typelist = models.LocationType.objects.order_by('plural_name').values(
        'name', 'plural_name', 'scope', 'slug')
    typedict = {}
    for typeinfo in typelist:
        typedict[typeinfo.pop('slug')] = typeinfo

    return APIGETResponse(request, simplejson.dumps(typedict, indent=1),
                         content_type=JSON_CONTENT_TYPE)


@rest_view(['GET'], cache_timeout = 24 * 3600)
def place_types_json(request):
    typelist = PlaceType.objects.filter(is_mappable=True).order_by('plural_name').values(
        'name', 'plural_name', 'slug')
    typedict = {}
    for typeinfo in typelist: 
        slug = typeinfo.pop('slug')
        typedict[slug] = typeinfo
        typedict[slug]['geojson_url'] = reverse('place_detail_json', kwargs={'placetype': slug})

    return APIGETResponse(request, simplejson.dumps(typedict, indent=1),
                         content_type=JSON_CONTENT_TYPE)

@rest_view(['GET'], cache_timeout = 24 * 3600)
def place_detail_json(request, placetype):
    try:
        placetype_obj = PlaceType.objects.get(slug=placetype, is_mappable=True)
    except (ValueError, PlaceType.DoesNotExist):
        raise Http404("No mappable place type %r" % placetype)

    result = {
        'type': 'FeatureCollection',
        'features': []
    }
    
    params = _copy_nomulti(request.GET)
    params['type'] = placetype
    places, params = build_place_query(params)
    for place in places:
        feature = {'type': 'Feature',
                   'geometry': simplejson.loads(place.location.geojson),
                   'properties': {'type': placetype,
                                  'name': place.pretty_name,
                                  'address': place.address,
                                  'icon': place.place_type.get_map_icon_url(),
                                  'color': place.place_type.map_color,
                                  'id': place.id,
                                  'openblock_type': 'place'
                                  }
                   }
        result['features'].append(feature)

    geojson = simplejson.dumps(result, indent=1)
    return APIGETResponse(request, geojson, content_type=JSON_CONTENT_TYPE)


class OpenblockAtomFeed(feedgenerator.Atom1Feed):
    """
    An Atom feed generator that adds extra stuff like georss.
    """

    def root_attributes(self):
        attrs = super(OpenblockAtomFeed, self).root_attributes()
        attrs['xmlns:georss'] = 'http://www.georss.org/georss'
        attrs['xmlns:openblock'] = 'http://openblock.org/ns/0'
        return attrs

    def add_item_elements(self, handler, item):
        super(OpenblockAtomFeed, self).add_item_elements(handler, item)
        location = item['location']
        if location is not None:
            # yes, georss is "y x" not "x y"!!
            handler.addQuickElement('georss:point', '%.16f %.16f' % (location.y, location.x))
        handler.addQuickElement('georss:featureName', item['location_name'])

        handler.addQuickElement('openblock:type', item['schema_slug'])

        # TODO: item_date in custom namespace
        handler.startElement(u'openblock:attributes', {})
        for key, datatype, val in item['attributes']:
            val = serialize_date_or_time(val) or val
            handler.addQuickElement('openblock:attribute', unicode(val),
                                    {'name': key, 'type': datatype})
        handler.endElement(u'openblock:attributes')

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Petition'
        db.create_table('petitions_petition', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('schema', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Schema'], null=True, blank=True)),
            ('slug', self.gf('django.db.models.fields.CharField')(unique=True, max_length=64, blank=True)),
            ('data_name', self.gf('django.db.models.fields.CharField')(max_length=64, blank=True)),
            ('teaser', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
            ('petition', self.gf('django.db.models.fields.TextField')()),
            ('creation_date', self.gf('django.db.models.fields.DateField')()),
        ))
        db.send_create_signal('petitions', ['Petition'])

        # Adding model 'Petitioner'
        db.create_table('petitions_petitioner', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('petition', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['petitions.Petition'])),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('location', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('city', self.gf('django.db.models.fields.CharField')(max_length=30)),
            ('state', self.gf('django.db.models.fields.CharField')(max_length=2)),
            ('email', self.gf('django.db.models.fields.EmailField')(max_length=75)),
            ('notes', self.gf('django.db.models.fields.TextField')()),
            ('date_signed', self.gf('django.db.models.fields.DateTimeField')()),
            ('ip_address', self.gf('django.db.models.fields.IPAddressField')(max_length=15)),
        ))
        db.send_create_signal('petitions', ['Petitioner'])


    def backwards(self, orm):
        
        # Deleting model 'Petition'
        db.delete_table('petitions_petition')

        # Deleting model 'Petitioner'
        db.delete_table('petitions_petitioner')


    models = {
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'petitions.petition': {
            'Meta': {'object_name': 'Petition'},
            'creation_date': ('django.db.models.fields.DateField', [], {}),
            'data_name': ('django.db.models.fields.CharField', [], {'max_length': '64', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'petition': ('django.db.models.fields.TextField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']", 'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64', 'blank': 'True'}),
            'teaser': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'})
        },
        'petitions.petitioner': {
            'Meta': {'object_name': 'Petitioner'},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '30'}),
            'date_signed': ('django.db.models.fields.DateTimeField', [], {}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'ip_address': ('django.db.models.fields.IPAddressField', [], {'max_length': '15'}),
            'location': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'notes': ('django.db.models.fields.TextField', [], {}),
            'petition': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['petitions.Petition']"}),
            'state': ('django.db.models.fields.CharField', [], {'max_length': '2'})
        }
    }

    complete_apps = ['petitions']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.db import models
from ebpub.db.models import Schema

class Petition(models.Model):
    # NULL schema means a city-level petition (i.e., not tied to a schema).
    schema = models.ForeignKey(Schema, blank=True, null=True)
    slug = models.CharField(max_length=64, unique=True, blank=True)
    data_name = models.CharField(max_length=64, blank=True)
    teaser = models.CharField(max_length=255, blank=True)
    petition = models.TextField()
    creation_date = models.DateField()

    def __unicode__(self):
        return self.full_data_name()

    def full_data_name(self):
        if self.schema:
            return self.schema.name
        return self.data_name

class Petitioner(models.Model):
    petition = models.ForeignKey(Petition)
    name = models.CharField(max_length=100)
    location = models.CharField(max_length=100)
    city = models.CharField(max_length=30)
    state = models.CharField(max_length=2)
    email = models.EmailField()
    notes = models.TextField()
    date_signed = models.DateTimeField()
    ip_address = models.IPAddressField()

    def __unicode__(self):
        return self.name

########NEW FILE########
__FILENAME__ = views
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django import forms
from django.http import HttpResponseRedirect
from django.shortcuts import get_object_or_404
from ebpub.metros.allmetros import get_metro
from ebpub.petitions.models import Petition, Petitioner
from ebpub.geocoder import full_geocode
from ebpub.utils.view_utils import eb_render
import datetime

class LocationField(forms.CharField):
    def clean(self, value):
        if not value:
            raise forms.ValidationError('Enter your location.')
        try:
            result = full_geocode(value, search_places=False)
        except Exception:
            raise forms.ValidationError("We're not familiar with this location. Could you please enter another one that we'd know, like a ZIP code, perhaps?")
        if result['ambiguous'] and result['type'] != 'block':
            raise forms.ValidationError("This location is ambiguous. Please enter one of the following: %s" % ', '.join([r['address'] for r in result['result']]))
        return value

class PetitionForm(forms.Form):
    name = forms.CharField(max_length=100, widget=forms.TextInput(attrs={'size': 30}))
    location = LocationField(max_length=100, widget=forms.TextInput(attrs={'size': 30}))
    city = forms.CharField(max_length=30, widget=forms.TextInput(attrs={'size': 30}), initial=get_metro()['city_name'])
    state = forms.CharField(max_length=2, widget=forms.TextInput(attrs={'size': 2}), initial=get_metro()['state'])
    email = forms.EmailField(widget=forms.TextInput(attrs={'size': 30}))
    notes = forms.CharField(required=False, widget=forms.Textarea(attrs={'cols': 35, 'rows': 4}))

def form_view(request, slug, is_schema):
    if is_schema:
        p = get_object_or_404(Petition, schema__slug=slug)
    else:
        p = get_object_or_404(Petition, slug=slug)
    if request.method == 'POST':
        form = PetitionForm(request.POST)
        if form.is_valid():
            cd = form.cleaned_data
            ip_address = request.META.get('HTTP_X_FORWARDED_FOR', '').split(',')[0] or request.META.get('REMOTE_ADDR', '')
            Petitioner.objects.create(
                petition=p,
                name=cd['name'].strip(),
                location=cd['location'].strip(),
                city=cd['city'].strip(),
                state=cd['state'].strip(),
                email=cd['email'].strip().lower(),
                notes=cd['notes'].strip(),
                date_signed=datetime.datetime.now(),
                ip_address=ip_address,
            )
            return HttpResponseRedirect('thanks/')
    else:
        form = PetitionForm()
    return eb_render(request, 'petitions/form.html', {'form': form, 'is_schema': is_schema, 'petition': p})

def form_thanks(request, slug, is_schema):
    if is_schema:
        p = get_object_or_404(Petition.objects.select_related(), schema__slug=slug)
    else:
        p = get_object_or_404(Petition, slug=slug)
    return eb_render(request, 'petitions/thanks.html', {'is_schema': is_schema, 'petition': p})

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'HiddenSchema'
        db.create_table('preferences_hiddenschema', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user_id', self.gf('django.db.models.fields.IntegerField')()),
            ('schema', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Schema'])),
        ))
        db.send_create_signal('preferences', ['HiddenSchema'])


    def backwards(self, orm):
        
        # Deleting model 'HiddenSchema'
        db.delete_table('preferences_hiddenschema')


    models = {
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'preferences.hiddenschema': {
            'Meta': {'object_name': 'HiddenSchema'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        }
    }

    complete_apps = ['preferences']

########NEW FILE########
__FILENAME__ = 0002_auto__add_profile
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    depends_on = (('accounts', '0001_initial'),
                  )

    def forwards(self, orm):
        # Adding model 'Profile'
        db.create_table('preferences_profile', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['accounts.User'], unique=True)),
        ))
        db.send_create_signal('preferences', ['Profile'])


    def backwards(self, orm):
        
        # Deleting model 'Profile'
        db.delete_table('preferences_profile')


    models = {
        'accounts.user': {
            'Meta': {'object_name': 'User', '_ormbases': ['auth.User']},
            'main_metro': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'user_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'preferences.hiddenschema': {
            'Meta': {'object_name': 'HiddenSchema'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'preferences.profile': {
            'Meta': {'object_name': 'Profile'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['accounts.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['preferences']

########NEW FILE########
__FILENAME__ = 0003_populate_profiles
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for user in orm['accounts.user'].objects.all():
            profile, created = orm['preferences.Profile'].objects.get_or_create(
                user_id=user.id)

    def backwards(self, orm):
        "Write your backwards methods here."
        # Not safe to remove anything here.
        pass

    models = {
        'accounts.user': {
            'Meta': {'object_name': 'User', '_ormbases': ['auth.User']},
            'main_metro': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'user_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'preferences.hiddenschema': {
            'Meta': {'object_name': 'HiddenSchema'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'preferences.profile': {
            'Meta': {'object_name': 'Profile'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['accounts.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['preferences']

########NEW FILE########
__FILENAME__ = 0004_auto__add_field_profile_max_keys
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Profile.max_keys'
        db.add_column('preferences_profile', 'max_keys', self.gf('django.db.models.fields.IntegerField')(default=3), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Profile.max_keys'
        db.delete_column('preferences_profile', 'max_keys')


    models = {
        'accounts.user': {
            'Meta': {'object_name': 'User', '_ormbases': ['auth.User']},
            'main_metro': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'user_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'preferences.hiddenschema': {
            'Meta': {'object_name': 'HiddenSchema'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'preferences.profile': {
            'Meta': {'object_name': 'Profile'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'max_keys': ('django.db.models.fields.IntegerField', [], {'default': '3'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['accounts.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['preferences']

########NEW FILE########
__FILENAME__ = 0005_auto__add_field_profile_properties
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Profile.properties'
        db.add_column('preferences_profile', 'properties', self.gf('jsonfield.fields.JSONField')(default={}, null=True, blank=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Profile.properties'
        db.delete_column('preferences_profile', 'properties')


    models = {
        'accounts.user': {
            'Meta': {'object_name': 'User', '_ormbases': ['auth.User']},
            'main_metro': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'user_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'preferences.hiddenschema': {
            'Meta': {'object_name': 'HiddenSchema'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'preferences.profile': {
            'Meta': {'object_name': 'Profile'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'max_keys': ('django.db.models.fields.IntegerField', [], {'default': '3'}),
            'properties': ('jsonfield.fields.JSONField', [], {'default': '{}', 'null': 'True', 'blank': 'True'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['accounts.User']", 'unique': 'True'})
        }
    }

    complete_apps = ['preferences']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.db import models
from django.db.models.signals import post_save
from ebpub.db.models import Schema
from ebpub.openblockapi.apikey.models import MAX_KEYS
import ebpub.accounts.models
import warnings

with warnings.catch_warnings():
    # Okay, silencing deprecation warnings is not great,
    # but a lot of OpenBlock's intended audience seem to think
    # that DeprecationWarnings are actually errors.
    warnings.simplefilter("ignore")
    from jsonfield.fields import JSONField

class HiddenSchema(models.Model):
    user_id = models.IntegerField()
    schema = models.ForeignKey(Schema)

    @property
    def user(self):
        if not hasattr(self, '_user_cache'):
            from ebpub.accounts.models import User
            try:
                self._user_cache = User.objects.get(id=self.user_id)
            except User.DoesNotExist:
                self._user_cache = None
        return self._user_cache

    def __unicode__(self):
        return u'<HiddenSchema %s for user %s>' % (self.user_id, self.schema.slug)


class Profile(models.Model):
    """
    User account metadata: API key limits, plus a big bag of JSON
    for arbitrary other stuff.
    """
    user = models.ForeignKey(ebpub.accounts.models.User, unique=True)

    max_keys = models.IntegerField(default=MAX_KEYS,
                                   help_text="How many API keys can this user have?")

    properties = JSONField(null=True, blank=True, default=dict,
                           help_text="A bag of JSON for holding arbitrary user metadata."
                           )

    def available_keys(self):
        """
        How many *more* API keys can this user get?
        """
        allowed = self.max_keys
        return max(0, allowed - self.user.keys.count())

    def can_make_api_key(self):
        if self.available_keys() > 0:
            return True

    def __unicode__(self):
        return "Profile: user %d" % (self.user_id)

# Need to explicitly create profiles on user save, as per django docs:
# https://docs.djangoproject.com/en/1.3/topics/auth/#storing-additional-information-about-users
def post_save_user(sender, **kwargs):
    profile, created = Profile.objects.get_or_create(user=kwargs['instance'])

post_save.connect(post_save_user, sender=ebpub.accounts.models.User)

########NEW FILE########
__FILENAME__ = views
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django import http
from ebpub.db.models import Schema
from ebpub.preferences.models import HiddenSchema
from ebpub.utils.view_utils import get_schema_manager

def ajax_save_hidden_schema(request):
    """
    Creates a HiddenSchema for request.POST['schema'] and request.user.
    """
    if request.method != 'POST':
        raise http.Http404()
    if 'schema' not in request.POST:
        raise http.Http404('Missing schema')
    if request.user.is_anonymous():
        raise http.Http404('Not logged in')

    # Validate that the HiddenSchema hasn't already been created for this user,
    # to avoid duplicates.
    try:
        manager = get_schema_manager(request)
        schema = manager.get(slug=request.POST['schema'])
        HiddenSchema.objects.get(user_id=request.user.id, schema=schema)
    except Schema.DoesNotExist:
        return http.HttpResponse('0') # Schema doesn't exist.
    except HiddenSchema.DoesNotExist:
        pass
    else:
        return http.HttpResponse('0') # Already exists.

    HiddenSchema.objects.create(user_id=request.user.id, schema=schema)
    return http.HttpResponse('1')

def ajax_remove_hidden_schema(request):
    """
    Removes the HiddenSchema for request.POST['schema'] and request.user.
    """
    if request.method != 'POST':
        raise http.Http404()
    if 'schema' not in request.POST:
        raise http.Http404('Missing schema')
    if request.user.is_anonymous():
        raise http.Http404('Not logged in')

    try:
        hidden_schema = HiddenSchema.objects.filter(user_id=request.user.id, schema__slug=request.POST['schema'])
    except HiddenSchema.DoesNotExist:
        # The schema didn't exist. This is a no-op.
        return http.HttpResponse('0')
    hidden_schema.delete()
    return http.HttpResponse('1')

########NEW FILE########
__FILENAME__ = models
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

# No models, but need this for django to see this as an app.

########NEW FILE########
__FILENAME__ = tests
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
This file demonstrates two different styles of tests (one doctest and one
unittest). These will both pass when you run "manage.py test".

Replace these with more appropriate tests for your application.
"""

from django.core import urlresolvers
from django.test import TestCase
from ebpub.openblockapi.tests import _make_items
from ebpub.db.models import NewsItem
from ebpub.db.models import Schema
import mock
import json


class TestViews(TestCase):

    def tearDown(self):
        NewsItem.objects.all().delete()
        Schema.objects.all().delete()


    @mock.patch('ebpub.richmaps.views.build_item_query')
    def test_map_items__no_params_no_items(self, mock_build_item_query):
        url = urlresolvers.reverse('map_items_json')
        mock_build_item_query.return_value = ([], {})
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        decoded = json.loads(response.content)
        self.assertEqual(decoded,
                         {u'type': u'FeatureCollection',
                          u'features': []})

    @mock.patch('ebpub.richmaps.views.build_item_query')
    def test_map_items__no_params__with_items(self, mock_build_item_query):
        schema = Schema.objects.create(
            name='n1', plural_name='n1s',
            indefinite_article='a', last_updated='2012-01-01',
            date_name='dn', date_name_plural='dns')
        items = _make_items(3, schema)
        mock_build_item_query.return_value = (items, {})
        for item in items:
            item.save()
        url = urlresolvers.reverse('map_items_json')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        decoded = json.loads(response.content)
        self.assertEqual(len(decoded['features']), 3)


########NEW FILE########
__FILENAME__ = urls
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf.urls.defaults import patterns, url, handler404, handler500
from ebpub.richmaps import views

urlpatterns = patterns(
    '',
    url(r'^$', views.bigmap, name="bigmap"),
    url(r'^headlines/?', views.headlines, name="headlines"),
    url(r'^popup/newsitem/(?P<item_id>.*)/?', views.item_popup, name="item_popup"),
    url(r'^popup/place/(?P<place_id>.*)/?', views.place_popup, name="place_popup"),
    url(r'^items.json/?', views.map_items_json, name="map_items_json"),
    url(r'^([-\w]{4,32})/filter/?$', views.bigmap_filter, name='bigmap_filter')
)

########NEW FILE########
__FILENAME__ = views
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django import template
from django.conf import settings
from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404
from django.template.loader import get_template, select_template
from django.utils import simplejson
from django.utils.cache import patch_response_headers
from ebpub.db.models import NewsItem
from ebpub.db.schemafilters import FilterChain
from ebpub.db.views import _get_filter_schemafields
from ebpub.openblockapi.itemquery import build_item_query
from ebpub.openblockapi.views import JSON_CONTENT_TYPE
from ebpub.streets.models import Place, PlaceType
from ebpub.utils.view_utils import eb_render
from ebpub.utils.view_utils import get_schema_manager
import datetime
import logging
import re

logger = logging.getLogger('ebpub.richmaps.views')

def bigmap_filter(request, slug):
    """
    Big map with just one Schema (identified by ``slug``) enabled by
    default.
    """
    s = get_object_or_404(get_schema_manager(request), slug=slug, is_special_report=False)
    if not s.allow_charting:
        return HttpResponse(status=404)

    filter_sf_dict = _get_filter_schemafields(s)

    # Determine what filters to apply, based on path and/or query string.
    filterchain = FilterChain(request=request, schema=s)
    try:
        filterchain.update_from_request(filter_sf_dict)
        filters_need_more = filterchain.validate()
    except:
        logger.exception("Unhandled error")
        return HttpResponse(status=404)

    config = _decode_map_permalink(request, show_default_layers=False, filters=filterchain)


    # TODO: This can leave in permalink params eg. 'i', even if there
    # is also 'ids', because it doesn't recognize those as being the
    # same.
    new_url = filterchain.make_url(base_url=reverse('bigmap_filter', args=(slug,)))
    if new_url != request.get_full_path():
        return HttpResponseRedirect(new_url)

    if config['is_widget']:
        return eb_render(request, 'richmaps/embed_bigmap.html', {
            'map_config': simplejson.dumps(config, indent=2)
        })
    else:
        return eb_render(request, 'richmaps/bigmap.html', {
            'map_config': simplejson.dumps(config, indent=2)
        })


def bigmap(request):
    '''
    Big map with all Schemas enabled by default.
    '''
    filterchain = FilterChain(request=request)
    config = _decode_map_permalink(request, filters=filterchain)

    if config['is_widget']: 
        return eb_render(request, 'richmaps/embed_bigmap.html', {
            'map_config': simplejson.dumps(config, indent=2)
        })
    else:
        return eb_render(request, 'richmaps/bigmap.html', {
            'map_config': simplejson.dumps(config, indent=2)
        })

def _decode_map_permalink(request, show_default_layers=True, filters=None):
    """
    Permalinks for the big map, with more compact query parameters.

    Returns a map_config dictionary.

    Accepted parameters:

    c - map center, separated by underscore, eg. c=-92.28283_38.95658

    z - map zoom, eg. z=12

    l - layers to display on load, comma- or dash-separated,
        eg. l=p13,t32,p1 or eg. l=p12345-t7-t9,
        where p => place layer
        and t => schema ("type") layer

    i - items to load specificially by id, comma- or dash-separated,
        eg. i=t1234-t456

    p - popup center, with underscore, eg. p=-92.3438_38.9658
    f - popup feature, eg. f=t1234 or f=p1234
        where p = a place and t = a news item

    start_date - start date (inclusive) %m/%d/%Y
    end_date - end date (inclusive) %m/%d/%Y
    d - duration in days (overridden by end date), eg. d=7

    x - show as 'widget', just the map and nothign around it.
        Takes no value, eg. x
    w - width of map (widget only), in pixels
    h - height of map (widget only), in pixels
    v - limits what map controls are displayed (widget only).
        By default, widget-stype map shows none of these.
        Possible values, joined with no separator:
        l - layer switcher
        h - list of headlines next to map
        p - permalink
        eg. to turn them all on: v=lhp


    """
    params = request.GET
    schemas = set()
    place_types = set()
    lids = params.get("l", None)
    show_custom_layer = False
    if lids is not None: 
        no_layers_specified = False
        try:
            pat = re.compile('(\w\d+)')
            for lid in pat.findall(lids):
                layer_type = lid[0]
                layer_id = int(lid[1:])
                if layer_type == 'p': 
                    place_types.add(layer_id)
                elif layer_type == 't': 
                    schemas.add(layer_id)
                elif layer_type == 'c':
                    show_custom_layer = True
        except: 
            pass
    else:
        no_layers_specified = True

    # map center
    center = params.get("c", None)
    if center: 
        try:
            center = [float(x) for x in center.split('_')][0:2]
        except: 
            pass
    
    # map zoom level 
    zoom = params.get("z", None)
    if zoom:
        try:
            zoom = float(zoom)
        except: 
            pass
        
    # popup 
    popup_info = None
    popup_center = params.get("p", None)
    popup_feature = params.get("f", None)
    if popup_center and popup_feature: 
        try:
            popup_center = [float(x) for x in popup_center.split('_')][0:2]
            feature_type = popup_feature[0]
            feature_id = int(popup_feature[1:])
            if feature_type == 'p': 
                openblock_type = 'place'
            elif feature_type == 't': 
                openblock_type = 'newsitem'

            popup_info = {
                'id': feature_id,
                'openblock_type': openblock_type,
                'lonlat': [popup_center[0], popup_center[1]]
            }
        except: 
            popup_center = None
            popup_feature = None

    # start and end date range
    default_interval = datetime.timedelta(days=7)
    duration = params.get('d')
    if duration is not None:
        try:
            duration = datetime.timedelta(days=int(duration))
        except (TypeError, ValueError):
            duration = default_interval
    else:
        duration = default_interval
    default_enddate = datetime.date.today()
    default_startdate = default_enddate - duration

    startdate = params.get('start_date')
    if startdate is not None:
        for format in ('%m/%d/%Y', '%Y-%m-%d'):
            try:
                startdate = datetime.datetime.strptime(startdate, format).date()
                break
            except ValueError:
                pass
        if isinstance(startdate, basestring):
            startdate = None

    enddate = params.get('end_date')
    if enddate is not None:
        for format in ('%m/%d/%Y', '%Y-%m-%d'):
            try:
                enddate = datetime.datetime.strptime(enddate, format).date()
                break
            except ValueError:
                pass
        if isinstance(enddate, basestring):
            enddate = None

    # The filters argument can override startdate & enddate.
    if startdate is None and enddate is None and filters:
        date_filter = filters.get('date') or filters.get('pubdate')
        if date_filter:
            startdate = date_filter.start_date
            enddate = date_filter.end_date

    if startdate is None and enddate is None:
        enddate = datetime.date.today()
        startdate = enddate - duration
    elif startdate is None:
        startdate = enddate - duration
    elif enddate is None:
        enddate = startdate + duration

    if enddate < startdate:
        enddate = startdate + duration

    # inject date range into filters if none was specified:
    if filters and filters.get('date') is None: 
        filters.add('date', startdate, enddate)

    api_startdate = startdate.strftime("%Y-%m-%d")  
    api_enddate = (enddate + datetime.timedelta(days=1)).strftime("%Y-%m-%d")

    layers = []

    if (startdate != default_startdate) or (enddate != default_enddate):
        show_custom_layer = True

    # All available place layers.
    for place_type in PlaceType.objects.filter(is_mappable=True).all():
        layers.append({
            'id': 'p%d' % place_type.id,
            'title': place_type.plural_name,
            'url': reverse('place_detail_json', args=[place_type.slug]),
            'params': {'limit': 1000},
            'minZoom': 15,
            'bbox': True,
            'visible': place_type.id in place_types # off by default
        })

    # All available NewsItem layers.
    for schema in get_schema_manager(request).all():
        # if filters and 'schema' in filters and filters['schema'].schema == schema:
        #     visible = True
        if no_layers_specified and show_default_layers and not show_custom_layer:
            # default on if no 't' param given
            visible = True
        elif schemas and schema.id in schemas:
            visible = True
        else:
            visible = False
        layers.append({
            'id': 't%d' % schema.id,
            'title':  schema.plural_name,
            'url':    reverse('map_items_json'),
            'params': {'type': schema.slug, 'limit': 1000,
                       'startdate': api_startdate,
                       'enddate': api_enddate},
            'bbox': False,
            'visible': visible
        })

    # Explicit filtering by ID.
    ids = params.get('i') or u''
    ids = [i.strip() for i in re.split(r'[^\d]+', ids)
           if i.strip()]
    if ids:
        show_custom_layer = True
        if filters is None:
            filters = FilterChain(request)
        filters.replace('id', *ids)


    # 'Custom' layer. This is a catch-all for all filtering
    # that isn't just enabling a default layer with the default
    # date range.
    # Not visible unless there is something like that to show.
    if filters and sorted(filters.keys()) not in ([],
                                                  ['date'],
                                                  ['date', 'schema'],
                                                  ['schema']):
        show_custom_layer = True

    if filters is not None:
        # Don't inspect filters['schema']; that's already covered by schemas above.
        base_url = reverse('map_items_json')
        layer_url = filters.make_url(base_url=base_url)
        # Quick ugly hacks to make the itemquery api happy.
        # Hooray proliferation of spellings.
        layer_url = layer_url.replace('locations=', 'locationid=')
        layer_url = layer_url.replace('start_date=', 'startdate=')
        layer_url = layer_url.replace('end_date=', 'enddate=')

        if 'schema' in filters:
            # Normally, filters.make_url() captures the schema in the
            # path part of the URL. But map_items_json doesn't,
            # so we add a query parameter.
            params = {'type': [s.slug for s in filters['schema'].schemas]}
        else:
            params = {}
        custom_layer = {
            'url': layer_url,
            'params': params,
            'title': u"Custom Filter",
            'visible': show_custom_layer,
            'id': 'c1',
            }
        layers.append(custom_layer)

    is_widget = params.get('x', None) is not None
    controls = {}
    control_list = params.get("v", None)
    if control_list is not None: 
        if 'l' in control_list: 
            controls['layers'] = True
        if 'h' in control_list: 
            controls['headline_list'] = True
        if 'p' in control_list: 
            controls['permalink'] = True

    width = params.get("w", None)
    if width:
        try:
            width = int(width)
        except: 
            width = None

    height = params.get("h", None)
    if height:
        try:
            height = int(height)
        except: 
            height = None

    config = {
      'center': center or [settings.DEFAULT_MAP_CENTER_LON,
                           settings.DEFAULT_MAP_CENTER_LAT],

      'zoom': zoom or settings.DEFAULT_MAP_ZOOM,
      
      'layers': layers, 
      
      'is_widget': is_widget,
      
      'permalink_params': {
        'start_date': startdate.strftime('%m/%d/%Y'),
        'end_date': enddate.strftime('%m/%d/%Y'),
      }, 
    }

    if 'id' in filters:
        # Put them in the params so the js code can construct, well,
        # permalinks with these ids, on the client side.
        ids = '-'.join(map(str, filters['id'].ids))
        config['permalink_params']['i'] = ids
    if popup_info:
        config['popup'] = popup_info

    if is_widget: 
        config['controls'] = controls
        if width is not None: 
            config['width'] = width
        if height is not None: 
            config['height'] = height
    
    return config

def headlines(request):
    html = ''
    items = request.REQUEST.getlist('item_id')
    items = [x.split(':') for x in items]
    if len(items) == 0:
        cur_template = get_template('richmaps/no_headlines.html')
        html = cur_template.render(template.Context({}))
    else: 
        for (obtype, item_id) in items:
            if obtype == 'newsitem':
                html += _item_headline(request, item_id)
            else: 
                html += _place_headline(request, item_id)

    response = HttpResponse(html)
    patch_response_headers(response, cache_timeout=3600)
    return response


def _item_headline(request, item_id):
    """
    returns the headline list html for a single item.
    """
    try:
        item_id = int(item_id)
        ni = NewsItem.objects.get(id=item_id)
    except:
        return ''

    schema = ni.schema
    template_list = ['richmaps/newsitem_headline_%s.html' % schema.slug,
                     'richmaps/newsitem_headline.html',
                     ]
    current_template = select_template(template_list)
    return current_template.render(template.Context({'newsitem': ni, 'schema': schema, }))


def _place_headline(request, item_id):
    """
    returns the headline list html for a single place.
    """
    try:
        item_id = int(item_id)
        place = Place.objects.get(id=item_id)
        place_type = place.place_type
    except:
        return ''


    template_list = ['richmaps/place_headline_%s.html' % place_type.slug,
                     'richmaps/place_headline.html',
                     ]
    current_template = select_template(template_list)
    return current_template.render(template.Context({'place': place, 'place_type': place_type, }))


def item_popup(request, item_id):
    """
    returns the popup html for a single item.
    """
    try:
        item_id = int(item_id)
        ni = NewsItem.objects.get(id=item_id)
    except:
        return HttpResponse(status=404)

    schema = ni.schema
    template_list = ['richmaps/newsitem_popup_%s.html' % schema.slug,
                     'richmaps/newsitem_popup.html',
                     ]
    current_template = select_template(template_list)
    html = current_template.render(template.Context({'newsitem': ni, 'schema': schema, }))
    response = HttpResponse(html)
    patch_response_headers(response, cache_timeout=3600)
    return response

def place_popup(request, place_id):
    try: 
        place_id = int(place_id)
        place = Place.objects.get(id=place_id)
    except:
        return HttpResponse(status=404)

    template_list = ['richmaps/place_popup_%s.html' % place.place_type.slug,
                     'richmaps/place_popup.html',
                     ]
    current_template = select_template(template_list)
    html = current_template.render(template.Context({'place': place, 'place_type': place.place_type, }))
    response = HttpResponse(html)
    patch_response_headers(response, cache_timeout=3600)
    return response

def map_items_json(request):
    """
    slightly briefer and less attribute-accessing 
    rendition of the REST api's geojson response. includes
    only attributes used by the map.
    """
    items, params = build_item_query(request)

    def _item_to_feature(item):
        geom = simplejson.loads(item.location.geojson)
        result = {
            'type': 'Feature',
            'geometry': geom,
            }

        # Uh-oh, this is not y10k compliant :-p
        sort_key = '%d-%d-%d-%s-%d' % (9999 - item.item_date.year,
                                    13 - item.item_date.month,
                                    32 - item.item_date.day,
                                    item.title,
                                    item.id)
        props = {'id': item.id,
                 'openblock_type': 'newsitem',
                 'icon': item.schema.get_map_icon_url(),
                 'color': item.schema.map_color,
                 'sort': sort_key
                }
        result['properties'] = props
        return result

    items = [_item_to_feature(item) for item in items if item.location is not None]
    items_geojson_dict = {'type': 'FeatureCollection',
                          'features': items
                          }
    
    body = simplejson.dumps(items_geojson_dict)
    response = HttpResponse(body, content_type=JSON_CONTENT_TYPE)
    patch_response_headers(response, cache_timeout=3600)
    return response

########NEW FILE########
__FILENAME__ = admin
#   Copyright 2012 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from .models import SavedPlace
from ebpub.geoadmin import OSMModelAdmin
from django.contrib.gis import admin

class SavedPlaceAdmin(OSMModelAdmin):
    pass


admin.site.register(SavedPlace, SavedPlaceAdmin)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'SavedPlace'
        db.create_table('savedplaces_savedplace', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('user_id', self.gf('django.db.models.fields.IntegerField')()),
            ('block', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['streets.Block'], null=True, blank=True)),
            ('location', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Location'], null=True, blank=True)),
            ('nickname', self.gf('django.db.models.fields.CharField')(max_length=128, blank=True)),
        ))
        db.send_create_signal('savedplaces', ['SavedPlace'])


    def backwards(self, orm):
        
        # Deleting model 'SavedPlace'
        db.delete_table('savedplaces_savedplace')


    models = {
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'savedplaces.savedplace': {
            'Meta': {'object_name': 'SavedPlace'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'nickname': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['savedplaces']

########NEW FILE########
__FILENAME__ = 0002_auto__add_field_savedplace_block_center
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'SavedPlace.block_center'
        db.add_column('savedplaces_savedplace', 'block_center', self.gf('django.contrib.gis.db.models.fields.PointField')(null=True, blank=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'SavedPlace.block_center'
        db.delete_column('savedplaces_savedplace', 'block_center')


    models = {
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'savedplaces.savedplace': {
            'Meta': {'object_name': 'SavedPlace'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'block_center': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'nickname': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'prefix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['savedplaces']

########NEW FILE########
__FILENAME__ = 0003_populate_block_center
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        savedplaces = orm['savedplaces.savedplace'].objects.all()
        for sp in savedplaces:
            if sp.block is not None:
                from ebpub.utils.geodjango import interpolate
                sp.block_center = interpolate(sp.block.geom, 0.5, True)
                sp.save()

    def backwards(self, orm):
        "Write your backwards methods here."

    models = {
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'savedplaces.savedplace': {
            'Meta': {'object_name': 'SavedPlace'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'block_center': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'nickname': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'prefix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'prefix_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'prefix_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'prefix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'prefix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'blank': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'place_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.PlaceType']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placetype': {
            'Meta': {'object_name': 'PlaceType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_geocodable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_mappable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('street_slug', 'city', 'state'),)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'prefix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets', 'savedplaces']

########NEW FILE########
__FILENAME__ = 0004_auto__del_field_savedplace_block
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'SavedPlace.block'
        db.delete_column('savedplaces_savedplace', 'block_id')


    def backwards(self, orm):
        
        # Adding field 'SavedPlace.block'
        db.add_column('savedplaces_savedplace', 'block', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['streets.Block'], null=True, blank=True), keep_default=False)


    models = {
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'savedplaces.savedplace': {
            'Meta': {'object_name': 'SavedPlace'},
            'block_center': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'nickname': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {})
        }
    }

    complete_apps = ['savedplaces']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib.gis.db import models
from ebpub.db.models import Location
from ebpub.streets.models import Block
from ebpub.constants import BLOCK_FUZZY_DISTANCE_METERS

class SavedPlace(models.Model):
    """
    Either a db.Location or streets.Block that a user saves a reference to
    so they can easily find it later.
    """

    objects = models.GeoManager()

    user_id = models.IntegerField()

    block_center = models.PointField(null=True, blank=True,
                                     help_text=u'Point representing the center of a related block.')
    location = models.ForeignKey(Location, blank=True, null=True)
    nickname = models.CharField(max_length=128, blank=True)

    def __unicode__(self):
        return u'User %s: %s' % (self.user_id, self.place.pretty_name)

    @property
    def place(self):
        return self._get_block() or self.location

    @property
    def user(self):
        if not hasattr(self, '_user_cache'):
            from ebpub.accounts.models import User
            try:
                self._user_cache = User.objects.get(id=self.user_id)
            except User.DoesNotExist:
                self._user_cache = None
        return self._user_cache

    def pid(self):
        """Place ID as used by ebpub.db.views
        """
        from ebpub.utils.view_utils import make_pid
        if self.block_center:
            block = self._get_block()
            return make_pid(block, 8)
        else:
            return make_pid(self.location)

    def clean(self):
        from django.core.exceptions import ValidationError
        error = ValidationError("SavedPlace must have either a Location or a block_center, but not both")
        if self.block_center and self.location_id:
            raise error
        if not (self.block_center or self.location_id):
            raise error

    def _get_block(self):
        if self.block_center is None:
            return None
        # We buffer the center a bit because exact intersection
        # doesn't always get a match.
        from ebpub.utils.mapmath import buffer_by_meters
        geom = buffer_by_meters(self.block_center, BLOCK_FUZZY_DISTANCE_METERS)
        blocks = Block.objects.filter(geom__intersects=geom)
        if not blocks:
            raise Block.DoesNotExist("No block found at lat %s, lon %s" % (self.block_center.y, self.block_center.x))
        # If there's more than one this close, we don't really care.
        return blocks[0]

    block = property(_get_block)

    def name(self):
        if self.location:
            return self.location.pretty_name
        else:
            block = self._get_block()
            if block:
                return u'%s block%s around %s' % (self.radius, (self.radius != 1 and 's' or ''), block.pretty_name)
        return u'(no name)'

########NEW FILE########
__FILENAME__ = views
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django import http
from django.utils import simplejson
from ebpub.savedplaces.models import SavedPlace
from ebpub.streets.models import Block
from ebpub.utils.view_utils import parse_pid

def ajax_save_place(request):
    """
    Creates a SavedPlace for request.POST['pid'] and request.user.
    """
    if request.method != 'POST':
        raise http.Http404()
    if 'pid' not in request.POST:
        raise http.Http404('Missing pid')
    if request.user.is_anonymous():
        raise http.Http404('Not logged in')
    place, block_radius, xy_radius = parse_pid(request.POST['pid'])
    kwargs = {'user_id': request.user.id}
    if isinstance(place, Block):
        block_center, location = place.geom.centroid, None
        kwargs['block_center'] = block_center
    else:
        block_center, location = None, place
        kwargs['location__id'] = place.id

    # Validate that the SavedPlace hasn't already been created for this user,
    # to avoid duplicates.
    try:
        SavedPlace.objects.get(**kwargs)
    except SavedPlace.DoesNotExist:
        pass
    else:
        return http.HttpResponse('0') # Already exists.

    savedplace = SavedPlace(
        user_id=request.user.id,
        block_center=block_center,
        location=location,
        nickname=request.POST.get('nickname', '').strip(),
    )
    savedplace.full_clean()
    savedplace.save()
    return http.HttpResponse('1')

def ajax_remove_place(request):
    """
    Removes the SavedPlace for request.POST['pid'] and request.user.
    """
    if request.method != 'POST':
        raise http.Http404()
    if 'pid' not in request.POST:
        raise http.Http404('Missing pid')
    if request.user.is_anonymous():
        raise http.Http404('Not logged in')

    place, block_radius, xy_radius = parse_pid(request.POST['pid'])
    kwargs = {'user_id': request.user.id}
    if isinstance(place, Block):
        block_center, location = place.geom.centroid, None
        kwargs['block_center'] = block_center
    else:
        block_center, location = None, place
        kwargs['location__id'] = place.id

    SavedPlace.objects.filter(**kwargs).delete()
    return http.HttpResponse('1')

def json_saved_places(request):
    """
    Returns JSON of SavedPlaces for request.user, or an empty list
    if the user isn't logged in.
    """
    if request.user.is_anonymous():
        result = []
    else:
        result = [{'name': sp.place.pretty_name, 'url': sp.place.url()} for sp in SavedPlace.objects.filter(user_id=request.user.id)]
    return http.HttpResponse(simplejson.dumps(result), mimetype='application/javascript')

########NEW FILE########
__FILENAME__ = settings_default
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
This file should rarely need editing; if it does, you might want to
move the setting in question into settings.py (and settings.py.in)

Known required settings are: %r
"""

import os
import imp

EBPUB_DIR = imp.find_module('ebpub')[1]
DJANGO_DIR = imp.find_module('django')[1]


########################
# CORE DJANGO SETTINGS #
########################

required_settings=[
    'DEBUG',
    # Database configuration as per
    # http://docs.djangoproject.com/en/1.2/topics/db/multi-db/
    # There's an example in obdemo/settings.py.in
    'DATABASES',
]

TEMPLATE_DIRS = (
    os.path.join(EBPUB_DIR, 'templates'),
    os.path.join(DJANGO_DIR, 'contrib', 'gis', 'templates'),
    # django template override hack to partially override templates
    # by referring to them with a unique path, see:
    # http://stackoverflow.com/questions/3967801/django-overriding-and-extending-an-app-template
    # You can use {% extends "ebpub/templates/..." %} to partially extend a template
    os.path.dirname(EBPUB_DIR)
)
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader'
)
TEMPLATE_CONTEXT_PROCESSORS = (
    'ebpub.accounts.context_processors.user',
    'django.contrib.auth.context_processors.auth',
    "django.core.context_processors.media",
    "django.core.context_processors.static",
    'django.core.context_processors.csrf',
    'django.contrib.messages.context_processors.messages',
    'ebpub.db.context_processors.map_context',
    'ebpub.db.context_processors.settings_context',
    'django.core.context_processors.request',
    #'django.core.context_processors.debug',
)

AUTHENTICATION_BACKENDS = (
    'ebpub.accounts.models.AuthBackend',
)

INSTALLED_APPS = (
    'background_task',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.comments',
    'django.contrib.contenttypes',
    'django.contrib.gis',
    'django.contrib.humanize',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django_static',
    'ebdata.blobs',
    'ebdata.geotagger',
    'ebpub.accounts',
    'ebpub.alerts',
    'ebpub.db',
    'ebpub.geocoder',
    'ebpub.moderation',
    'ebpub.neighbornews',
    'ebpub.openblockapi',
    'ebpub.openblockapi.apikey',
    'ebpub.petitions',
    'ebpub.preferences',
    'ebpub.richmaps',
    'ebpub.savedplaces',
    'ebpub.streets',
    'ebpub.widgets',
    'obadmin.admin',
    'olwidget',
    'easy_thumbnails',
)

APPS_FOR_TESTING = (
    # Don't need these installed at runtime, but I've put them here so
    # manage.py test can automatically find their tests.
    'ebdata.nlp',
    'ebdata.templatemaker',
    'ebdata.textmining',
    'ebpub.metros',
    'ebpub.utils',
    'ebpub.geocoder',
    'ebpub.geocoder.parser',
)

APPS_NOT_FOR_TESTING = (
        # the user model used is custom.
        'django.contrib.auth',
        # this makes too many weird assumptions about the database underpinnings
        'django.contrib.contenttypes',
        # these tests break with some settings, see https://github.com/peterbe/django-static/issues#issue/8 and 9
        'django_static',
        # these tests break under django 1.3, unsure why.
        'django.contrib.messages',
        # the rest are just not of interest.
        'django.contrib.sessions',
        'django.contrib.admin',
        'django.contrib.gis',
        'olwidget',
        'olwidget.models',
        'south',
        'background_task',
        'easy_thumbnails',
)


INSTALLED_APPS = INSTALLED_APPS + APPS_FOR_TESTING + ('south',)

TEST_RUNNER = 'obadmin.testrunner.TestSuiteRunner'

# Messages backend. OpenBlock doesn't use it (yet) but this silences a
# deprecationwarning from the admin UI in django 1.3.
MESSAGE_STORAGE = 'django.contrib.messages.storage.fallback.FallbackStorage'


# South - database migration config
SKIP_SOUTH_TESTS = True
SOUTH_TESTS_MIGRATE = True

MIDDLEWARE_CLASSES = (
    'django.middleware.gzip.GZipMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'ebpub.accounts.middleware.UserMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.http.ConditionalGetMiddleware',
)

SITE_ID = 1

# Limit size of uploads, then fall back to standard upload behavior.
FILE_UPLOAD_HANDLERS = (
    "ebpub.utils.uploadhandler.QuotaUploadHandler",
    "django.core.files.uploadhandler.MemoryFileUploadHandler",
    "django.core.files.uploadhandler.TemporaryFileUploadHandler",
    )

LOGIN_URL = '/accounts/login/'

##################################
# CUSTOM OPENBLOCK SETTINGS      #
##################################

# Which LocationType to show when you visit /locations
DEFAULT_LOCTYPE_SLUG = 'neighborhoods'
required_settings.append('DEFAULT_LOCTYPE_SLUG')

# This may be needed to get tests to build.
POSTGIS_TEMPLATE = 'template_postgis'

# The domain for your site.
required_settings.append('EB_DOMAIN')

# This is the short name for your city, e.g. "chicago".
required_settings.append('SHORT_NAME')

# Set both of these to distinct, secret strings that include two instances
# of '%s' each. Example: 'j8#%s%s' -- but don't use that, because it's not
# secret.
required_settings.extend(['PASSWORD_CREATE_SALT', 'PASSWORD_RESET_SALT'])

# The list of all metros this installation covers. This is a tuple of
# dictionaries.  If your site only covers one city, there will be
# only one dictionary.
# There's an example in obdemo/settings.py.in
required_settings.append('METRO_LIST')

# How many days of news to show on many views.
required_settings.append('DEFAULT_DAYS')

# Overrides datetime.datetime.today(), for development.
EB_TODAY_OVERRIDE = None

# Filesystem location of scraper log.
required_settings.append('SCRAPER_LOGFILE_NAME')

# Do you want scrapers to email you errors directly?
# (Used by the framework in ebdata/ebdata/retrieval/scrapers/)
# We default to false, because we typically have Cron send email on errors.
required_settings.append('SCRAPER_LOG_DO_EMAIL_ERRORS')
SCRAPER_LOG_DO_EMAIL_ERRORS = False

# Edit this if you want to control where
# scraper scripts will put their HTTP cache.
# (Warning, don't put it in a directory encrypted with ecryptfs
# or you'll likely have "File name too long" errors.)
HTTP_CACHE = '/tmp/openblock_scraper_cache'

# If this cookie is set with the given value, then the site will give the user
# staff privileges (including the ability to view non-public schemas).
required_settings.extend(['STAFF_COOKIE_NAME', 'STAFF_COOKIE_VALUE'])


# SCHEMA_MANAGER_HOOK: Set this to a string like
# 'package_name.module_name:function_name'
# This is an advanced feature that can be used to modify all Schema
# queries based on the current request.  The named function should
# take arguments (request, manager) and return either a Manager or
# something that looks like one - maybe by proxying it - for example
# by doing extra filtering in get_query_set().
SCHEMA_MANAGER_HOOK = None


######################################################
#  EMAIL                                             #
######################################################

# This is used as a "From:" in e-mails sent to users.
required_settings.append('GENERIC_EMAIL_SENDER')

EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST='localhost'
EMAIL_PORT='25'
# Need authentication to send mail? Set these.
#EMAIL_HOST_USER=''
#EMAIL_HOST_PASSWORD=''
#EMAIL_USE_TLS=False  # For secure SMTP connections.


##############################################
# OPENBLOCK MAP CONFIGURATION                #
##############################################

# Where to center citywide maps by default.
required_settings.append('DEFAULT_MAP_CENTER_LON')
required_settings.append('DEFAULT_MAP_CENTER_LAT')
required_settings.append('DEFAULT_MAP_ZOOM')

# Which base layer to use on maps.
# May be any of the default olwidget base layers,
# as per http://olwidget.org/olwidget/v0.4/doc/olwidget.js.html#general-map-display
# or you may use 'custom.X' where X is a key in MAP_CUSTOM_BASE_LAYERS, see below.

# For example:
#MAP_BASELAYER_TYPE = 'google.streets'
MAP_BASELAYER_TYPE = 'custom.opengeo_osm'
required_settings.append('MAP_BASELAYER_TYPE')


# If you set MAP_BASELAYER_TYPE='google.*', you must also set GOOGLE_API_KEY.
GOOGLE_API_KEY=''

# Use a specific version of google maps API to work around
# copyright alert bug:
# http://trac.osgeo.org/openlayers/ticket/2984
GOOGLE_API='http://maps.google.com/maps/api/js?v=3.6&sensor=false'

# If you set MAP_BASELAYER_TYPE='yahoo', you must also set YAHOO_APP_ID.
YAHOO_APP_ID=''
# If you want MAP_BASELAYER_TYPE='cloudmade.*', you must also set CLOUDMADE_API_KEY.
CLOUDMADE_API_KEY=''

# You can use ANY OpenLayers base layer configuration, with a little extra work,
# like so:
MAP_CUSTOM_BASE_LAYERS = {
    'opengeo_osm':  # to use this, set MAP_BASELAYER_TYPE='custom.opengeo_osm'
        {"class": "WMS",  # The OpenLayers.Layer subclass to use.
         "args": [  # These are passed as arguments to the constructor.
            "OpenStreetMap (OpenGeo)",
            "http://maps.opengeo.org/geowebcache/service/wms",
            {"layers": "openstreetmap",
             "format": "image/png",
             "bgcolor": "#A1BDC4",
             },
            {"wrapDateLine": True
             },
            ],
         }
}

##########################
#  MEDIA                 #
##########################

# Core Django settings for static media and uploaded files,
# see https://docs.djangoproject.com/en/dev/ref/settings/#media-root

# Where static media live.
STATIC_ROOT = os.path.join(EBPUB_DIR, 'media')
# Where to serve these files.  For production deployment, ensure your
# webserver makes STATIC_ROOT available at this URL.
STATIC_URL = '/'

# Where to put files uploaded by users.
MEDIA_ROOT = os.path.join(STATIC_ROOT, 'uploads')
# Where to serve these files.  For production deployment, ensure your
# webserver makes MEDIA_ROOT available at this URL.
MEDIA_URL = '/uploads/'

required_settings.extend(['STATIC_ROOT', 'MEDIA_ROOT', 'STATIC_URL', 'MEDIA_URL'])


# Static media optimizations: whitespace slimming, URL timestamping.
# see https://github.com/peterbe/django-static#readme
# This supercedes the old everyblock-specific template tags in
# everyblock.templatetags.staticmedia.
DJANGO_STATIC = True
DJANGO_STATIC_MEDIA_ROOTS = [MEDIA_ROOT, STATIC_ROOT,]


# Putting django-static's output in a separate directory and URL space
# makes it easier for git to ignore them,
# and easier to have eg. apache set appropriate expiration dates.
DJANGO_STATIC_NAME_PREFIX = '/cache-forever'
# Make sure you have write permission here!!
DJANGO_STATIC_SAVE_PREFIX = os.path.join(STATIC_ROOT, DJANGO_STATIC_NAME_PREFIX[1:])


#############################
# JAVASCRIPT LIBRARIES      #
#############################


# For local development you might try this:
#JQUERY_URL = '/media/js/jquery.js'
JQUERY_URL = 'http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js'

# It's important that it be named exactly OpenLayers.js,
# see http://trac.osgeo.org/openlayers/ticket/2982
OPENLAYERS_URL = '/scripts/OpenLayers-2.11/OpenLayers.js'
OPENLAYERS_IMG_PATH = '/scripts/OpenLayers-2.11/img/'

# For compatibility with django-olwidget
OL_API = OPENLAYERS_URL



########################################
#  OPENBLOCK REST API                  #
########################################

MAX_KEYS_PER_USER=1

API_THROTTLE_AT=150  # max requests per timeframe.
API_THROTTLE_TIMEFRAME = 60 * 60 # default 1 hour.
# How long to retain the times the user has accessed the API. Default 1 week.
API_THROTTLE_EXPIRATION = 60 * 60 * 24 * 7

# NOTE in order to enable throttling, you MUST also configure
# CACHES['default'] to something other than a DummyCache.  See the CACHES
# setting.


#########################################
# CACHING                               #
#########################################

## For development & testing, DummyCache makes for easiest troubleshooting.
## See https://docs.djangoproject.com/en/1.3/ref/settings/#std:setting-CACHES
#
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
    },
    # File caching might be a reasonable choice for low-budget, memory-constrained
    # hosting environments.
    # 'default': {
    #     'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
    #     'LOCATION': 'file:///tmp/myblock_cache',
    # }
}

###############################################
# API KEYS for third-party services           #
###############################################

# Neighbornews app opptionally uses ReCaptcha.
RECAPTCHA_PUBLIC_KEY = ''
RECAPTCHA_PRIVATE_KEY = ''


################################################
#  OTHER                                       #
################################################

# Set this True to cache geocoder results in the database;
# it's faster but makes troubleshooting harder.
# (Why doesn't it just use the normal django caching framework?)
EBPUB_CACHE_GEOCODER = True
required_settings.append('EBPUB_CACHE_GEOCODER')

# Required by openblockapi.apikey to associate keys with user profiles.
AUTH_PROFILE_MODULE = 'preferences.Profile'

# ebpub.neighbornews optionally uses recaptcha.  This can be True,
# False, or a string representing a path in the form
# 'packagename.modulename:functionname' path to a function that takes
# a request argument and returns True or False.
NEIGHBORNEWS_USE_CAPTCHA = False

# Batch jobs (django-background-task): how long (in seconds) can a job
# be locked before we decide it's dead?
MAX_RUN_TIME = 60 * 15
# How many failures to retry?
MAX_ATTEMPTS = 4

# Maximum size of user-uploaded images, relevant to eg. the
# NeighborNews schemas.
UPLOAD_MAX_MB = 10.0

########################################################
# LOGGING                                              #
########################################################

# See https://docs.djangoproject.com/en/dev/topics/logging
# We import this first because South annoyingly overrides its log level at import time.
from south import logger as _unused

LOGGING = {
    'version': 1,
    'disable_existing_loggers': True,
    'formatters': {
        'simple': {
            'format': '%(levelname)s %(module)s: %(message)s'
            },
        'debug': {
            'format': '%(levelname)s %(asctime)s P: (process)d T: %(thread)d in %(module)s:%(pathname)s:%(lineno)d %(message)s'
            },
        'verbose': {
            'format': '%(levelname)s %(asctime)s P: (process)d T: %(thread)d in %(module)s: %(message)s'
            },
    },
    'handlers': {
        'null': {
            'level':'INFO',
            'class':'django.utils.log.NullHandler',
            },
        'console':{
            'level':'INFO',
            'class':'logging.StreamHandler',
            'formatter': 'simple'
            },
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler',
            'formatter': 'verbose'
            },
        },
    'loggers': {
        '': {
            'handlers':['console'],
            'propagate': True,
            'level':'INFO',
            },
        'django': {
            'handlers': [],
            'propagate': True,
            'level':'WARN',
            },
        'ebpub': {
            'handlers': [],
            'propagate': True,
            'level': 'INFO',
            },
        'ebdata': {
            'handlers': [],
            'propagate': True,
            'level': 'INFO',
            },
        # 'django.request': {
        #     'handlers': ['mail_admins'],
        #     'level': 'ERROR',
        #     'propagate': False,
        # },
        'south': {
            'handlers': [],
            'level': 'INFO',
        }
    }
}


__doc__ = __doc__ % required_settings

########NEW FILE########
__FILENAME__ = admin
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

import csv
from django.conf.urls.defaults import patterns, url
from django.contrib import admin
from django.contrib.admin import helpers
from django.contrib.gis import geos
from django.contrib.gis.measure import D
from django.core.exceptions import PermissionDenied
from django import forms, template
from django.http import HttpResponse
from django.shortcuts import render_to_response
from django.utils.encoding import force_unicode
from ebpub.streets.models import Block, Street, BlockIntersection, \
    Intersection, Suburb, Place, PlaceType, PlaceSynonym, StreetMisspelling
from ebpub.geocoder import SmartGeocoder, AmbiguousResult, GeocodingException
from ebpub.geocoder.parser.parsing import normalize
from ebpub.geoadmin import OBMapField
from ebpub.geoadmin import OSMModelAdmin

import logging
from StringIO import StringIO



logger = logging.getLogger('ebpub.streets.admin')


class PlaceAdminForm(forms.ModelForm):
    class Meta:
        model = Place

    location = OBMapField(options={'isCollection': False, 'geometry': 'point'},
                          required=False)
    address = forms.CharField(max_length=255, required=False, 
                              help_text="""Address is optional and used to compute map point when no point is specified. Click 'Delete all Features' to remove current point.""")

    def _append_error(self, field, err):
        if not field in self._errors: 
            self._errors[field] = forms.util.ErrorList()
        self._errors[field].append(err)

    def clean(self):
        loc_info = self.cleaned_data.get('location')
        if isinstance(loc_info, list):
            # olwidget wraps geometries up as lists in case there's several per map
            assert len(loc_info) == 1
            loc_info = loc_info[0]
        if not loc_info:
            address = self.cleaned_data.get('address')
            if not address: 
                self._append_error('location', u'Either an address or a location must be specified.')
            else:
                # try to geocode the address...
                try:
                    geocoder = SmartGeocoder()
                    addr = geocoder.geocode(address) 
                    loc_info = addr['point']
                except AmbiguousResult:
                    self._append_error('location', u'Address is ambiguous, please specify a point directly.')
                except GeocodingException:
                    self._append_error('location', u'Unable to geocode address, please correct the address or specify a point directly.')
            # Again, olwidget expects these to be lists...
            loc_info = [loc_info]
            self.cleaned_data['location'] = loc_info
        return super(PlaceAdminForm, self).clean()

    def save(self, *args, **kwargs):
        # update normalized name
        self.instance.normalized_name = normalize(self.instance.pretty_name)
        return super(PlaceAdminForm, self).save(*args, **kwargs)

class PlaceImportForm(forms.Form):
    place_type = forms.ModelChoiceField(queryset=PlaceType.objects.all())
    csv_file = forms.FileField(
        required=True,
        help_text='These fields are required for each row: pretty_name, address, lat, lon, &lt;synonym&gt;, &lt;synonym&gt;, ...')


class PlaceExportForm(forms.Form):
    place_type = forms.ModelChoiceField(
        queryset=PlaceType.objects.all(),
        help_text='These fields will be exported in each row: pretty_name, address, lat, lon, &lt;synonym&gt;, &lt;synonym&gt;, ...')


class PlaceAdmin(OSMModelAdmin):
    list_display = ('pretty_name', 'place_type', 'address',)
    list_filter  = ('place_type',)
    search_fields = ('pretty_name', 'address', 'place_type__name')
    fields = ('pretty_name', 'place_type', 'url', 'address', 'location')
    form = PlaceAdminForm

    def formfield_for_dbfield(self, db_field, **kwargs):
        """
        """
        # Hack around django bug https://code.djangoproject.com/ticket/16110 :
        # there's no decent way to allow GeometryField(blank=True, null=False)
        # - i.e. required in the database but not required by a form.
        # We have to override the widget with *both* required=False and null=False.
        # The form's clean() method will attempt to fix it by geocoding.
        if db_field.name == 'location':
            kwargs['required'] = False
            kwargs['null'] = True
        return super(OSMModelAdmin, self).formfield_for_dbfield(db_field, **kwargs)

    def get_urls(self):
         urls = super(OSMModelAdmin, self).get_urls()
         my_urls = patterns('',
             url(r'^import/csv$', self.admin_site.admin_view(self.import_csv_view), name="streets_place_import_csv"),
             url(r'^export/csv$', self.admin_site.admin_view(self.export_csv_view), name="streets_place_export_csv")
         )
         return my_urls + urls

    def export_csv_view(self, request):

        if request.method == 'GET':
            export_form = PlaceExportForm()
        elif request.method == 'POST':
            export_form = PlaceExportForm(request.POST)

        if not export_form.is_bound or not export_form.is_valid(): 
            return self._show_export_csv_form(request, export_form)
            
        # ... do export csv
        # fields: pretty_name, address, lat, lon, url, <synonym>, <synonym>, ...
        place_type = export_form.cleaned_data['place_type']
        data = StringIO()
        serializer = csv.writer(data)
        for place in Place.objects.filter(place_type=place_type).all():
            row = [place.pretty_name, place.address or '', place.location.y, place.location.x, place.url or '']
            for synonym in PlaceSynonym.objects.filter(place=place).all():
                row.append(synonym.pretty_name)
            serializer.writerow(row)
        
        response = HttpResponse(data.getvalue(), mimetype='text/csv')
        response['Content-Disposition'] = 'attachment; filename=%s.csv' % place_type.slug
        response['Cache-Control'] = 'no-cache'
        return response


    def import_csv_view(self, request):
        if not self.has_add_permission(request):
            raise PermissionDenied

        if request.method == 'GET':
            import_form = PlaceImportForm()
        if request.method == 'POST': 
            import_form = PlaceImportForm(request.POST, request.FILES)

        if not import_form.is_bound or not import_form.is_valid():
            return self._show_import_csv_form(request, import_form)

        # csv fields: 
        # pretty_name, address, lat, lon, url, <synonym>, <synonym>, ...

        context = dict(
            errors = [],
            actions_taken = [],
        )

        validated_rows = []

        place_type = import_form.cleaned_data['place_type']
        try:
            csvfile = import_form.cleaned_data['csv_file']
            rows = csv.reader(csvfile)
        except:
            message = "Unable to read the specified CSV file"
            context['errors'].append(message)
            return self._show_import_csv_results(request, context)

        try:
            for row in rows:
                if len(row) < 2:
                    message = "Line %d: Missing required fields." % rows.line_num
                    context['errors'].append(message)
                    continue
                
                synonyms = []
                point = None
                place_url = ''

                pretty_name, address = [x.strip() for x in row[0:2]]
                if pretty_name ==  '': 
                    message = "Line %d: Empty name" % rows.line_num
                    context['errors'].append(message)
                    continue

                if len(row) > 2:
                    try:
                        lat, lon  = row[2:4]
                        if lat != '' or lon != '':
                            lat = float(lat.strip())
                            lon = float(lon.strip())
                            point = geos.Point(lon, lat)
                            if len(row) > 4:
                                place_url = row[4]
                                synonyms = [x.strip() for x in row[5:]]
                    except ValueError: 
                        message = 'Line %d "%s": Invalid lat, lon' % (rows.line_num, pretty_name)
                        context['errors'].append(message)
                        continue

                
                if point is None:
                    if address == '':
                        message = 'Line %d "%s": Address and lat,lon are both empty.' % (rows.line_num, pretty_name)
                        context['errors'].append(message)
                        continue

                    # try to geocode the address
                    try:
                        geocoder = SmartGeocoder()
                        addr = geocoder.geocode(address) 
                        point = addr['point']
                    except AmbiguousResult:
                        message = 'Line %d "%s": Address "%s" is ambiguous, please specify a point directly.' % (rows.line_num, pretty_name, address)
                        context['errors'].append(message)
                        continue
                    except GeocodingException:
                        message = 'Line %d "%s": Unable to geocode address "%s", please correct the address or specify a point directly.' % (rows.line_num, pretty_name, address)
                        context['errors'].append(message)
                        continue
                
                # phew!
                validated_rows.append([pretty_name, address, point, place_url, synonyms])

        except csv.Error, e:
            message = "Stopped on line %d: %s" % (rows.line_num, e)
            context['errors'].append(message)
            return self._show_import_csv_results(request, context)
        except Exception, e:
            message = "Stopped on line %d: %s" % (rows.line_num, e)
            context['errors'].append(message)
            return self._show_import_csv_results(request, context)
        
        
        # wonderful, now do something...
        for pretty_name, address, point, place_url, synonyms in validated_rows: 
            normalized_name = normalize(pretty_name)
            
            try: 
                place = Place.objects.get(normalized_name=normalized_name,
                                          location__distance_lte=(point, D(m=1)))
                created = False
            except Place.DoesNotExist:
                place = Place(normalized_name=normalized_name)
                created = True
            
            try:
                place.pretty_name = pretty_name
                place.address = address
                place.location = point
                place.url = place_url
                place.place_type = place_type
                place.save()

                if created: 
                    message = 'Created new place %s' % (pretty_name)
                else: 
                    message = 'Updated place %s' % (pretty_name)
                context['actions_taken'].append(message)
            except: 
                logger.exception('Place saving %r failed' % pretty_name)
                message = 'Error adding place "%s"' % pretty_name
                context['errors'].append(message)
                continue

                
            # now update Synonyms

            # destroy synonyms not in the new list, identify new synonyms
            new_synonyms = set(synonyms)
            for synonym in PlaceSynonym.objects.filter(place=place).all():
                if synonym.pretty_name not in new_synonyms:
                    synonym.delete()
                    message = 'Removing old synonym "%s" for "%s"' % (synonym.pretty_name, pretty_name)
                    context['actions_taken'].append(message)
                else:
                    # seen it in the database, don't make a new one
                    new_synonyms.remove(synonym.pretty_name)
                    message = 'Keeping synonym "%s" for "%s"' % (synonym.pretty_name, pretty_name)
                    context['actions_taken'].append(message)

            for synonym in new_synonyms:
                try:
                    ns = PlaceSynonym(pretty_name=synonym,
                                      normalized_name=normalize(synonym),
                                      place=place)
                    ns.save()
                    message = 'Created new synonym "%s" for "%s"' % (synonym, pretty_name)
                    context['actions_taken'].append(message)
                except:
                    message = 'Unable to add synonym "%s" for "%s"' % (synonym, pretty_name)
                    context['errors'].append(message)

            
            
        return self._show_import_csv_results(request, context)
        
        
    def _show_import_csv_results(self, request, context):
        return self._render_admin_template('admin/streets/place/import_places_csv_result.html',
                                           request, context)
        

    def _show_import_csv_form(self, request, import_form):
        opts = self.model._meta
        #adminform = helpers.AdminForm(import_form, [(None, {'fields': import_form.base_fields.keys()})], {})
        context = {
            'title': 'Import %s' % force_unicode(opts.verbose_name_plural),
        }
        return self._render_admin_template('admin/streets/place/import_places_csv.html',
                                           request, context, import_form)


    def _show_export_csv_form(self, request, export_form):
        opts = self.model._meta
        context = {
           'title': 'Export %s' % force_unicode(opts.verbose_name_plural),
        }
        return self._render_admin_template('admin/streets/place/export_places_csv.html',
                                           request, context, export_form)

    
    def _render_admin_template(self, template_name, request, context, form=None):
        # try to wrap and jump through as many hoops as have a determinable shape... 
        
        opts = self.model._meta        
        context_instance = template.RequestContext(request, current_app=self.admin_site.name)
        ctx = {
            'is_popup': request.REQUEST.has_key('_popup'),
            'root_path': self.admin_site.root_path,
            'app_label': opts.app_label,
            'opts': opts,
            'has_add_permission': self.has_add_permission(request),
            'has_change_permission': self.has_change_permission(request),
            'has_delete_permission': self.has_delete_permission(request),
        }
        
        if form is not None: 
            adminform = helpers.AdminForm(form, [(None, {'fields': form.base_fields.keys()})], {})
            ctx['errors'] = helpers.AdminErrorList(form, [])
            ctx['adminform'] = adminform

        ctx.update(context)

        return render_to_response(template_name, ctx, context_instance=context_instance)


class BlockAdmin(OSMModelAdmin):

    list_display = ('pretty_name', 'predir', 'prefix', 'street', 'suffix', 'postdir',
                    'left_zip', 'right_zip', 'left_city', 'right_city')
    list_filter = ('suffix', 'prefix', 'left_city', 'right_city', 'left_zip', 'right_zip',
                   'predir', 'postdir',
                   )
    search_fields = ('pretty_name',)
    readonly_fields = ('from_num', 'to_num',)

    fieldsets = (
        ('Name', {
                'fields': ('street_slug', 'pretty_name', 'street_pretty_name',
                           'predir', 'prefix', 'street', 'suffix', 'postdir',
                           )
                }),
        ('Address Ranges', {
                'fields': ('left_from_num', 'left_to_num',
                           'right_from_num', 'right_to_num',
                           'from_num', 'to_num'),
                'description': 'Addresses on this block. At least one must be provided; the rest will be guessed if necessary. Order will be fixed if you get it backwards.'
                }),
        ('Location', {
                'fields': ('left_zip', 'right_zip', 'left_city', 'right_city',
                           'left_state', 'right_state',
                           'parent_id',
                           'geom',
                           )
                })
        )


class PlaceTypeAdmin(OSMModelAdmin):
    list_display = ('name', 'slug', 'is_geocodable', 'is_mappable')
    search_fields = ('name',)


class StreetAdmin(OSMModelAdmin):
    list_display = ('pretty_name', 'suffix', 'city', 'state',)
    list_filter = ('prefix', 'suffix', 'city', 'state',)
    search_fields = ('pretty_name',)
    readonly_fields = ('street',)
    prepopulated_fields = {'street_slug': ('pretty_name',)}

class BlockIntersectionAdmin(OSMModelAdmin):
    list_display = ('block', 'intersecting_block', 'intersection',)
    raw_id_fields = ('block', 'intersecting_block', 'intersection',)
    search_fields = ('block__pretty_name',)

class IntersectionAdmin(OSMModelAdmin):
    list_display = ('pretty_name', 'zip', 'city', 'state')
    list_filter = ('zip', 'city', 'state')
    search_fields = ('pretty_name',)

class SuburbAdmin(OSMModelAdmin):
    pass

class StreetMisspellingAdmin(OSMModelAdmin):
    list_display = ('incorrect', 'correct',)
    search_fields = ('incorrect', 'correct',)

class PlaceSynonymAdmin(OSMModelAdmin):
    list_display = ('pretty_name', 'place')
    search_fields = ('pretty_name', 'place')
    readonly_fields = ('normalized_name',)

# Hack to ensure that the templates in obadmin get used, if it's installed
# and the relevant template exists.
# This is because olwidget defines its own olwidget_change_list.html
# template for GeoModelAdmin, which OSMModelAdmin inherits.
try:
    import obadmin.admin
    BlockAdmin.change_list_template = 'admin/streets/block/change_list.html'
    PlaceAdmin.change_list_template = 'admin/streets/place/change_list.html'
except ImportError:
    pass

admin.site.register(Block, BlockAdmin)
admin.site.register(Street, StreetAdmin)
admin.site.register(BlockIntersection, BlockIntersectionAdmin)
admin.site.register(Intersection, IntersectionAdmin)
admin.site.register(Suburb, SuburbAdmin)
admin.site.register(Place, PlaceAdmin)
admin.site.register(PlaceType, PlaceTypeAdmin)
admin.site.register(PlaceSynonym, PlaceSynonymAdmin)
admin.site.register(StreetMisspelling, StreetMisspellingAdmin)

########NEW FILE########
__FILENAME__ = delete_blocks_outside_city
#!/usr/bin/env python
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from ebpub.streets.models import Block


def delete_blocks_outside_city(verbose=False):
    """Derives from_num and to_num from left_from_num, etc.
    """
    not_in_city = Block.objects.exclude(right_city=settings.SHORT_NAME.upper()).exclude(left_city=settings.SHORT_NAME.upper())
    if verbose:
        print "Deleting %d blocks outside the city" % not_in_city.count()
    not_in_city.delete()


if __name__ == "__main__":
    delete_blocks_outside_city(verbose=True)

########NEW FILE########
__FILENAME__ = fix_block_numbers
#!/usr/bin/env python
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from ebpub.streets.name_utils import make_block_numbers
from ebpub.streets.models import Block


def update_all_block_numbers(verbose=False):
    """Derives from_num and to_num from left_from_num, etc.
    """
    for b in Block.objects.all():
        (from_num, to_num) = make_block_numbers(
            b.left_from_num, b.left_to_num, b.right_from_num, b.right_to_num)
        if b.from_num != from_num or b.to_num != to_num:
            b.from_num = from_num
            b.to_num = to_num
            b.full_clean()
            b.save()
            if verbose:
                print "Updating numbers for %s to %s-%s" % (b, from_num, to_num)

def main():
    update_all_block_numbers(verbose=True)

if __name__ == "__main__":
    main()


########NEW FILE########
__FILENAME__ = populate_streets
#!/usr/bin/env python
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Populates the street, block intersection, and intersection
model tables.

How to populate intersections
=============================

First import the blocks.

Ensure the ZIP Codes are populated in the db_location table: they
are needed for resolving 'disputes' when the two intersecting
blocks of an intersection have different ZIP Codes. This is
not described here: there should be a ZIP Code importer script
suitable for your city.

Next, populate the streets from the blocks table, by calling populate_streets().

This is the part that takes the longest: populate the
db_blockintersection table.
In this module, execute the populate_block_intersections() function.

This goes through each block (and remember, there are on the order of
tens of thousands of blocks in each city) and calculates all the other
blocks which intersect with it. This is inherently slow, even with the
heavy-lifting offloaded to pgsql/postgis; but this is a one-time cost.

When that completes, execute the populate_intersections()
function. This is a comparatively fast operation which just looks
up the pre-calculated intersections for each block and creates
a new object representing a particular intersection, eliminating
potential duplicates.
"""

import logging
import sys
import optparse
from django.contrib.gis.geos import fromstr
from django.db import connection, transaction
from ebpub.db.models import Location
from ebpub.metros.allmetros import get_metro
from ebpub.streets.models import Block, BlockIntersection, Intersection, Street
from ebpub.streets.name_utils import make_dir_street_name, pretty_name_from_blocks, slug_from_blocks

logger = logging.getLogger()

def timer(func):
    # a decorator that logs how long func took to run
    def wrapper(*args, **kwargs):
        import time
        start = time.time()
        result = func(*args, **kwargs)
        logger.info("Ran %s in %s seconds" % (func.__name__, time.time() - start))
        return result
    return wrapper

def intersecting_blocks(block):
    """
    Returns a list of blocks that intersect the given one.

    Note that blocks with the same street name and suffix are
    excluded -- this is a heuristic that keeps the adjacent blocks
    of the same street out.
    """
    select_list = ["b.%s" % f.name for f in block._meta.fields] + ["ST_Intersection(a.geom, b.geom)"]
    table = block._meta.db_table
    cursor = connection.cursor()
    sql = """
        SELECT %s
        FROM %s a,
             %s b
        WHERE
            a.id = %%s AND
            ST_Intersects(a.geom, b.geom) AND
            GeometryType(ST_Intersection(a.geom, b.geom)) = 'POINT' AND
            NOT (b.street = a.street AND b.suffix = a.suffix)
        ORDER BY
            b.predir, b.street, b.suffix, b.left_from_num, b.right_from_num
        """ % (", ".join(select_list), table, table)
    cursor.execute(sql, [block.id])
    intersections = []
    for row in cursor.fetchall():
        block = Block(*row[:-1])
        intersection_pt = fromstr(row[-1])
        intersections.append((block, intersection_pt))
    return intersections

def intersection_from_blocks(block_a, block_b, intersection_pt, city, state, zip):
    pretty_name = pretty_name_from_blocks(block_a, block_b),
    slug = slug_from_blocks(block_a, block_b)
    obj, created = Intersection.objects.get_or_create(
        pretty_name=pretty_name,
        slug=slug,
        predir_a=block_a.predir,
        prefix_a=block_a.prefix,
        street_a=block_a.street,
        suffix_a=block_a.suffix,
        postdir_a=block_a.postdir,
        predir_b=block_b.predir,
        prefix_b=block_b.prefix,
        street_b=block_b.street,
        suffix_b=block_b.suffix,
        postdir_b=block_b.postdir,
        city=city,
        state=state,
        zip=zip,
        # Putting location in "defaults" in case the assumption that
        # the above args are unique is false. This can happen if 2 streets
        # intersect more than once, see comment in streets.models.Intersection.Meta
        # When this happens, the first loaded matching intersection will "win".
        # ... don't know full implications of changing that assumption
        # to support multiple such intersections.
        defaults={'location': intersection_pt},
        )
    if not created:
        logger.debug("Already have intersection %s" % obj.pretty_name)
    return obj

@timer
@transaction.commit_on_success
def populate_streets(*args, **kwargs):
    """
    Populates the streets table from the blocks table
    """
    print 'Populating the streets table; deleting all first'
    Street.objects.all().delete()
    # This is considerably slower than the old INSERT INTO ... UPDATE
    # single SQL statement, but it's a one-time cost, and it avoids
    # duplicate keys that we were getting.
    for block in Block.objects.all():

        cities_and_states = set([(block.left_city, block.left_state),
                                 (block.right_city, block.right_state)
                                 ])
        for city, state in cities_and_states:
            obj, created =  Street.objects.get_or_create(
                street_slug=block.street_slug,
                city=city,
                state=state,
                )
            if (obj.pretty_name != block.street_pretty_name
                   or obj.street != block.street
                   or obj.suffix != block.suffix
                   or obj.prefix != block.prefix):
                obj.pretty_name = block.street_pretty_name
                obj.street=block.street
                obj.prefix=block.prefix
                obj.suffix=block.suffix
                obj.save()
                logger.debug("saved %s" % obj.pretty_name)
            elif created:
                logger.debug("created %s" % obj.pretty_name)

    #connection._commit()

    #logger.info("Deleting extraneous cities...")
    #metro = get_metro()
    #cities = [l.name.upper() for l in Location.objects.filter(location_type__slug=metro['city_location_type']).exclude(location_type__name__startswith='Unknown')]
    #Street.objects.exclude(city__in=cities).delete()
    return Street.objects.all().count()

@timer
@transaction.commit_on_success
def populate_block_intersections(*args, **kwargs):
    logger.info("Starting to populate block_intersections")
    logger.info("Warning, deleting all block_intersections AND intersections first")
    BlockIntersection.objects.all().delete()  # This cascades.
    for block in Block.objects.all():
        logger.debug('Calculating the blocks that intersect %s' % block)
        for iblock, intersection_pt in intersecting_blocks(block):
            BlockIntersection.objects.get_or_create(
                block=block,
                intersecting_block=iblock,
                defaults={'location': intersection_pt}
            )
    return BlockIntersection.objects.all().count()

@timer
@transaction.commit_on_success
def populate_intersections(*args, **kwargs):
    # On average, there are 2.3 blocks per intersection. So for
    # example in the case of Chicago, where there are 788,496 blocks,
    # we'd expect to see approximately 340,000 intersections

    # NOTE, we can't do a delete here because that cascades to BlockIntersection,
    # and then we have nothing to work with.
    # So the two functions should really always be called together.
    logger.info("Starting to populate intersections, this can take some minutes...")
    logger.warn("Deleting all %d existing intersections first" % Intersection.objects.all().count())
    Intersection.objects.all().delete()

    logger.info("We have %d blockintersections" % BlockIntersection.objects.all().count())
    metro = get_metro()
    zipcodes = Location.objects.filter(location_type__name__istartswith="zip").exclude(name__startswith='Unknown')
    def lookup_zipcode(pt):
        for zipcode in zipcodes:
            if zipcode.location.contains(pt):
                return zipcode
    intersections_seen = {}
    for i in Intersection.objects.all():
        intersections_seen[i.pretty_name] = i.id
        intersections_seen[i.reverse_pretty_name()] = i.id
    for bi in BlockIntersection.objects.iterator():
        street_name = make_dir_street_name(bi.block)
        i_street_name = make_dir_street_name(bi.intersecting_block)
        # This tuple enables us to skip over intersections
        # we've already seen. Since intersections are
        # symmetrical---eg., "N. Kimball Ave. & W. Diversey
        # Ave." == "W. Diversey Ave. & N. Kimball Ave."---we
        # use both orderings.
        seen_intersection = (u"%s & %s" % (street_name, i_street_name),
                             u"%s & %s" % (i_street_name, street_name))
        if seen_intersection[0] not in intersections_seen and \
           seen_intersection[1] not in intersections_seen:
            if bi.block.left_city != bi.block.right_city:
                # If we have Locations representing cities,
                # find one that contains this bi's center.
                from ebpub.db.models import get_city_locations
                overlapping_cities = get_city_locations().filter(location__contains=bi.location)
                if overlapping_cities:
                    city = overlapping_cities[0].name.upper()
                else:
                    city = metro['city_name'].upper()
            else:
                city = bi.block.left_city
            if bi.block.left_state != bi.block.right_state:
                state = metro['state'].upper()
            else:
                state = bi.block.left_state
            if (bi.block.left_zip != bi.block.right_zip or \
                bi.intersecting_block.left_zip != bi.intersecting_block.right_zip) or \
               (bi.block.left_zip != bi.intersecting_block.left_zip):
                zipcode_obj = lookup_zipcode(bi.location)
                if zipcode_obj:
                    zipcode = zipcode_obj.name
                else:
                    zipcode = bi.block.left_zip
            else:
                zipcode = bi.block.left_zip
            intersection = intersection_from_blocks(bi.block, bi.intersecting_block, bi.location, city, state, zipcode)
            intersection.save()
            logger.debug("Created intersection %s" % intersection.pretty_name)
            bi.intersection = intersection
            bi.save()
            intersections_seen[seen_intersection[0]] = intersection.id
            intersections_seen[seen_intersection[1]] = intersection.id
        else:
            if not bi.intersection:
                bi.intersection_id = intersections_seen[seen_intersection[0]]
                bi.save()
            logger.debug("Already seen intersection %s" % " / ".join(seen_intersection))
    logger.info("Finished populating intersections")
    total = Intersection.objects.all().count()
    if not total:
        logger.warn("No intersections created, maybe you forgot to do populate_block_intersections first?")
    return total

LOG_VERBOSITY = (logging.CRITICAL,
                 logging.ERROR,
                 logging.WARNING,
                 logging.INFO,
                 logging.DEBUG,
                 logging.NOTSET)

def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]
    valid_actions = {'streets': populate_streets,
                     'block_intersections': populate_block_intersections,
                     'intersections': populate_intersections,
                     }
    parser = optparse.OptionParser('Usage: %%prog [opts] {%s}' % \
                                   '|'.join(valid_actions.keys()),
                                   description=__doc__)
    parser.add_option('-v', '--verbose', action='count', dest='verbosity',
                      default=0, help='verbosity, add more -v to be more verbose')

    opts, args = parser.parse_args(argv)
    if len(args) != 1 or args[0] not in valid_actions:
        parser.error('must supply an valid action, one of: %r' % \
                     valid_actions.keys())

    verbosity = min(opts.verbosity, len(LOG_VERBOSITY) -1)
    level = LOG_VERBOSITY[verbosity]
    if not logger.handlers:
        format = "%(asctime)-15s %(levelname)-8s %(message)s"
        basicConfig = logging.basicConfig
        try:
            if __name__ == '__main__':
                import fabulous.logs
                basicConfig = fabulous.logs.basicConfig
        except ImportError:
            pass
        basicConfig(level=level, format=format)

    logger.setLevel(level)

    # Call the action
    count = valid_actions[args[0]](**opts.__dict__)
    if count is not None:
        print "%s: created: %d" % (args[0], count)

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = populate_suburbs
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

import sys
from ebpub.geocoder.parser.parsing import normalize
from ebpub.streets.models import Suburb

def populate_suburbs(suburb_list):
    for suburb in suburb_list:
        Suburb.objects.create(name=suburb, normalized_name=normalize(suburb))

def main():
    import sys
    import os
    if (not len(sys.argv) > 1) or (not os.path.exists(sys.argv[1])):
        sys.stderr.write("Usage: %s FILE\n\n" % sys.argv[0])
        sys.stderr.write("The file should be a text file with one suburb name per line.\n")
        sys.stderr.write("For openblock's purposes, a 'suburb' is just a\n"
                         "nearby city that we don't care about importing.\n")

        sys.exit(1)
    suburb_list = [line for line in open(sys.argv[1], 'r').read().split('\n') if line]
    populate_suburbs(suburb_list)

if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
__FILENAME__ = update_block_pretty_names
#!/usr/bin/env python
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from ebpub.streets.name_utils import make_pretty_name
from ebpub.streets.models import Block

def update_block_pretty_names():
    for b in Block.objects.all():
        name = make_pretty_name(b.left_from_num, b.left_to_num,
                                b.right_from_num, b.right_to_num,
                                b.predir, b.prefix, b.street, b.suffix, b.postdir)[1]
        if name != b.pretty_name:
            print 'Pretty name: %s -- from: %s' % (b.pretty_name, name)
            b.pretty_name = name
            b.save()

if __name__ == "__main__":
    update_block_pretty_names()




########NEW FILE########
__FILENAME__ = base
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib.gis.gdal import DataSource
from django.core.exceptions import ValidationError
from ebpub.streets.models import Block
from ebpub.streets.name_utils import make_pretty_name
from ebpub.streets.name_utils import make_pretty_prefix
from ebpub.streets.name_utils import make_block_numbers
from ebpub.utils.geodjango import geos_with_projection
from ebpub.utils.text import slugify


import logging
logger = logging.getLogger('ebpub.streets.blockimport')

class BlockImporter(object):
    """
    Base class for importing blocks from shapefiles.

    Subclasses will implement the details for one particular data source.
    """
    def __init__(self, shapefile, layer_id=0, verbose=False, encoding='utf8',
                 reset=False,
                 ):
        self.layer = DataSource(shapefile)[layer_id]
        self.verbose = verbose
        self.encoding = encoding
        self.reset = reset

    def log(self, arg):
        "Deprecated: user logger instead"
        logger.debug(arg)

    def save(self):
        if self.reset:
            logger.warn("Deleting all Block instances and anything that refers to them!")
            Block.objects.all().delete()
        import time
        start = time.time()
        num_created = 0
        num_existing = 0
        for feature in self.layer:
            parent_id = None
            if not self.skip_feature(feature):
                for block_fields in self.gen_blocks(feature):

                    # Usually (at least in Boston data) there is only
                    # 1 block per feature.  But sometimes there are
                    # multiple names for one street, eg.
                    # "N. Commercial Wharf" and "Commercial Wharf N.";
                    # in that case those would be yielded by gen_blocks() as
                    # two separate blocks. Is that intentional, or a bug?

                    # Ensure we have unicode.
                    for key, val in block_fields.items():
                        if isinstance(val, str):
                            block_fields[key] = val.decode(self.encoding)

                    block_fields['geom'] = geos_with_projection(feature.geom, 4326)
                    block_fields['prefix'] = make_pretty_prefix(block_fields['prefix'])

                    block_fields['street_pretty_name'], block_fields['pretty_name'] = make_pretty_name(
                        block_fields['left_from_num'],
                        block_fields['left_to_num'],
                        block_fields['right_from_num'],
                        block_fields['right_to_num'],
                        block_fields['predir'],
                        block_fields['prefix'],
                        block_fields['street'],
                        block_fields['suffix'],
                        block_fields['postdir']
                    )

                    block_fields['street_slug'] = slugify(
                        u' '.join((block_fields['prefix'],
                                   block_fields['street'],
                                   block_fields['suffix'])))

                    # Watch out for addresses like '247B' which can't be
                    # saved as an IntegerField.
                    # But do this *after* making pretty names.
                    # Also attempt to fix up addresses like '19-47',
                    # by just using the lower number.  This will give
                    # misleading output, but it's probably better than
                    # discarding blocks.
                    for addr_key in ('left_from_num', 'left_to_num',
                                     'right_from_num', 'right_to_num'):
                        if isinstance(block_fields[addr_key], basestring):
                            from ebpub.geocoder.parser.parsing import number_standardizer
                            value = number_standardizer(block_fields[addr_key].strip())
                            if not value:
                                value = None
                        else:
                            try:
                                value = str(int(value))
                            except (ValueError, TypeError):
                                value = None
                        block_fields[addr_key] = value

                    try:
                        block_fields['from_num'], block_fields['to_num'] = \
                            make_block_numbers(block_fields['left_from_num'],
                                               block_fields['left_to_num'],
                                               block_fields['right_from_num'],
                                               block_fields['right_to_num'])
                    except ValueError, e:
                        logger.warn('Skipping %s: %s' % (block_fields['pretty_name'], e))
                        continue

                    # After doing pretty names etc, standardize the fields
                    # that get used for geocoding, since the geocoder
                    # searches for the standardized version.
                    from ebpub.geocoder.parser.parsing import STANDARDIZERS
                    for key, standardizer in STANDARDIZERS.items():
                        if key in block_fields:
                            if key == 'street' and block_fields['prefix']:
                                # Special case: "US Highway 101", not "US Highway 101st".
                                continue

                            block_fields[key] = standardizer(block_fields[key])

                    # Separate out the uniquely identifying fields so
                    # we can avoid duplicate blocks.
                    # NOTE this doesn't work if you're updating from a more
                    # recent shapefile and the street has significant
                    # changes - eg. the street name has changed, or the
                    # address range has changed, or the block has split...
                    # see #257. http://developer.openblockproject.org/ticket/257
                    primary_fields = {}
                    primary_field_keys = ('street_slug',
                                          'from_num', 'to_num',
                                          'left_city', 'right_city',
                                          'left_zip', 'right_zip',
                                          'left_state', 'right_state',
                                          )
                    for key in primary_field_keys:
                        if block_fields[key] != u'':
                            # Some empty fields are fixed
                            # automatically by clean().
                            primary_fields[key] = block_fields[key]

                    existing = list(Block.objects.filter(**primary_fields))
                    if not existing:
                        # Check the old-style way we used to make street slugs
                        # prior to fixing issue #264... we need to keep this
                        # code around indefinitely in case we are reloading the
                        # blocks data and need to overwrite blocks that have
                        # the old bad slug.  Sadly this probably can't just be
                        # fixed by a migration.
                        _old_street_slug = slugify(
                            u' '.join((block_fields['street'],
                                       block_fields['suffix'])))
                        _old_primary_fields = primary_fields.copy()
                        _old_primary_fields['street_slug'] = _old_street_slug
                        existing = list(Block.objects.filter(**_old_primary_fields))
                        if not existing:
                            block = Block(**block_fields)
                            num_created += 1
                            logger.debug("CREATING %s" % unicode(block))

                    if len(existing) == 1:
                        num_existing += 1
                        block = existing[0]
                        logger.debug(u"Block %s already exists" % unicode(existing[0]))
                        for key, val in block_fields.items():
                            setattr(block, key, val)
                    elif len(existing) > 1:
                        num_existing += len(existing)
                        logger.warn("Multiple existing blocks like %s, skipping"
                                    % existing[0])
                        continue
                    try:
                        block.full_clean()
                    except ValidationError:
                        # odd bug: sometimes we get ValidationError even when
                        # the data looks good, and then cleaning again works???
                        try:
                            block.full_clean()
                        except ValidationError, e:
                            logger.warn("validation error on %s, skipping" % str(block))
                            logger.warn(e)
                            continue
                    block.save()
                    if parent_id is None:
                        parent_id = block.id
                    else:
                        block.parent_id = parent_id
                        block.save()
                    logger.debug('%d\tCreated block %s for feature %d' % (num_created, block, feature.fid))
        logger.info("Created %d new blocks in %.2f seconds" % (num_created,
                                                               time.time() - start))
        return num_created, num_existing

    def skip_feature(self, feature):
        """
        Subclasses can override this method to determine whether to
        skip this feature, for example, because the feature is not a
        street or is missing an address number.

        It could also be used to provide geometric filtering, for
        example, a subclass could inspect the geom attribute of the
        feature to determine if it is contained by a particular
        geometry.
        """
        return True

    def gen_blocks(self, feature):
        """
        A generator that yields dictionaries (of keys that are BLOCK_FIELDS)
        """
        raise NotImplementedError('subclass must implement this method')


########NEW FILE########
__FILENAME__ = blocks
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

import re
import string
import sys
import optparse
from django.contrib.gis.gdal import DataSource
from ebpub.metros.models import Metro
from ebpub.streets.models import Block
from ebpub.streets.name_utils import make_pretty_name
from ebpub.streets.name_utils import make_block_numbers
from ebpub.utils.text import slugify

FIELD_MAP = {
    # ESRI        # Block
    'L_F_ADD'   : 'left_from_num',
    'L_T_ADD'   : 'left_to_num',
    'R_F_ADD'   : 'right_from_num',
    'R_T_ADD'   : 'right_to_num',
    'POSTAL_L'  : 'left_zip',
    'POSTAL_R'  : 'right_zip',
    'GEONAME_L' : 'left_city',
    'GEONAME_R' : 'right_city',
    'STATE_L'   : 'left_state',
    'STATE_R'   : 'right_state',
}

NAME_FIELD_MAP = {
    'NAME'      : 'street',
    'TYPE'      : 'suffix',
    'PREFIX'    : 'predir',
    'SUFFIX'    : 'postdir',
}

# FCC == feature classification code: indicates the type of road
VALID_FCC_PREFIXES = (
    'A1', # primary highway with limited access
    'A2', # primary road without limited access
    'A3', # secondary and connecting road
    'A4'  # local, neighborhood, and rural road
)


class EsriImporter(object):
    # TODO: inherit from ebpub.streets.blockimport.base.BlockImporter ?

    def __init__(self, shapefile, city=None, layer_id=0, encoding='utf8',
                 verbose=False):
        import warnings
        warnings.warn("This code is very out of date - does not handle the Block.prefix field")
        warnings.warn("It is very likely to fail; we have no esri data to test with anymore.")
        self.verbose = verbose
        self.encoding = encoding
        ds = DataSource(shapefile)
        self.log("Opening %s" % shapefile)
        self.layer = ds[layer_id]
        self.city = city and city or Metro.objects.get_current().name
        self.fcc_pat = re.compile('^(' + '|'.join(VALID_FCC_PREFIXES) + ')\d$')

    def log(self, arg):
        if self.verbose:
            print >> sys.stderr, arg


    def save(self):
        alt_names_suff = (u'', u'1', u'2', u'3', u'4', u'5')
        num_created = 0
        for i, feature in enumerate(self.layer):
            if not self.fcc_pat.search(feature.get('FCC')):
                continue
            parent_id = None
            fields = {}
            for esri_fieldname, block_fieldname in FIELD_MAP.items():
                value = feature.get(esri_fieldname)
                if isinstance(value, basestring):
                    value = value.upper()
                elif isinstance(value, int) and value == 0:
                    value = None
                fields[block_fieldname] = value
            if not ((fields['left_from_num'] and fields['left_to_num']) or
                    (fields['right_from_num'] and fields['right_to_num'])):
                continue
            # Sometimes the "from" number is greater than the "to"
            # number in the source data, so we swap them into proper
            # ordering
            for side in ('left', 'right'):
                from_key, to_key = '%s_from_num' % side, '%s_to_num' % side
                if fields[from_key] > fields[to_key]:
                    fields[from_key], fields[to_key] = fields[to_key], fields[from_key]
            if feature.geom.geom_name != 'LINESTRING':
                continue
            for suffix in alt_names_suff:
                name_fields = {}
                for esri_fieldname, block_fieldname in NAME_FIELD_MAP.items():
                    key = esri_fieldname + suffix
                    name_fields[block_fieldname] = feature.get(key).upper()
                if not name_fields['street']:
                    continue
                # Skip blocks with bare number street names and no suffix / type
                if not name_fields['suffix'] and re.search('^\d+$', name_fields['street']):
                    continue
                fields.update(name_fields)

                # Ensure we have unicode.
                for key, val in fields.items():
                    if isinstance(val, str):
                        fields[key] = val.decode(self.encoding)

                fields['street_pretty_name'], fields['pretty_name'] = make_pretty_name(
                    fields['left_from_num'],
                    fields['left_to_num'],
                    fields['right_from_num'],
                    fields['right_to_num'],
                    fields['predir'],
                    fields['street'],
                    fields['suffix'],
                    fields['postdir'],
                )

                #print >> sys.stderr, 'Looking at block pretty name %s' % fields['street']

                fields['street_slug'] = slugify(u' '.join((fields['street'], fields['suffix'])))

                # Watch out for addresses like '247B' which can't be
                # saved as an IntegerField. But do this after making
                # pretty names.
                for addr_key in ('left_from_num', 'left_to_num', 'right_from_num', 'right_to_num'):
                    fields[addr_key] = fields[addr_key].rstrip(string.letters)

                fields['from_num'], fields['to_num'] = make_block_numbers(
                    fields['left_from_num'],
                    fields['left_to_num'],
                    fields['right_from_num'],
                    fields['right_to_num'])

                block = Block(**fields)
                block.geom = feature.geom.geos
                self.log(u'Looking at block %s' % fields['street'])

                block.save()
                if parent_id is None:
                    parent_id = block.id
                else:
                    block.parent_id = parent_id
                    block.save()
                num_created += 1
                self.log('Created block %s' % block)
        return num_created



def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]
    parser = optparse.OptionParser(usage='%prog edges.shp')
    parser.add_option('-v', '--verbose', action='store_true', dest='verbose',
                      default=False)
    parser.add_option('-c', '--city', dest='city',
                      help='A city name to filter against', default=None)
    parser.add_option('-e', '--encoding', dest='encoding',
                      help='Encoding to use when reading the shapefile',
                      default='utf8')

    (options, args) = parser.parse_args(argv)
    if len(args) != 1:
        return parser.error('must provide at least 1 arguments, see usage')

    esri = EsriImporter(shapefile=args[0],
                        city=options.city, verbose=options.verbose,
                        encoding=options.encoding,
                        )
    num_created = esri.save()
    if options.verbose:
        print "Created %d blocks" % num_created

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = zipcodes
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

import datetime
from django.contrib.gis.gdal import DataSource
from django.contrib.gis.geos import MultiPolygon
from ebpub.db.models import Location, LocationType
import sys

class EsriImporter(object):
    def __init__(self, shapefile, city, layer_id=0):
        ds = DataSource(shapefile)
        self.layer = ds[layer_id]
        self.city = city
        self.location_type, _ = LocationType.objects.get_or_create(
            name = 'ZIP Code',
            plural_name = 'ZIP Codes',
            scope = 'U.S.A.',
            slug = 'zipcodes',
            is_browsable = True,
            is_significant = True,
        )

    def save(self, verbose=False):
        # The ESRI ZIP Code layer breaks ZIP Codes up along county
        # boundaries, so we need to collapse them first before
        # proceeding
        zipcodes = {}
        for feature in self.layer:
            zipcode = feature.get('POSTAL')
            geom = feature.geom.geos
            if zipcode not in zipcodes:
                zipcodes[zipcode] = geom
            else:
                # If it's a MultiPolygon geom we're adding to our
                # existing geom, we need to "unroll" it into its
                # constituent polygons 
                if isinstance(geom, MultiPolygon):
                    subgeoms = list(geom)
                else:
                    subgeoms = [geom]
                existing_geom = zipcodes[zipcode]
                if not isinstance(existing_geom, MultiPolygon):
                    new_geom = MultiPolygon([existing_geom])
                    new_geom.extend(subgeoms)
                    zipcodes[zipcode] = new_geom
                else:
                    existing_geom.extend(subgeoms)

        sorted_zipcodes = sorted(zipcodes.iteritems(), key=lambda x: int(x[0]))
        now = datetime.datetime.now()
        num_created = 0
        for i, (zipcode, geom) in enumerate(sorted_zipcodes):
            if not geom.valid:
                geom = geom.buffer(0.0)
                if not geom.valid:
                    print >> sys.stderr, 'Warning: invalid geometry for %s' % zipcode
            geom.srid = 4326
            zipcode_obj, created = Location.objects.get_or_create(
                name = zipcode,
                normalized_name = zipcode,
                slug = zipcode,
                location_type = self.location_type,
                location = geom,
                display_order = i,
                city = self.city,
                source = 'ESRI',
                area = geom.transform(3395, True).area,
                is_public = True,
                creation_date = now,
                last_mod_date = now,
            )
            if created:
                num_created += 1
            if verbose:
                print >> sys.stderr, '%s ZIP Code %s ' % (created and 'Created' or 'Already had', zipcode_obj.name)
        return num_created


########NEW FILE########
__FILENAME__ = importesri
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.core.management.base import BaseCommand, CommandError
from ebpub.streets.blockimport.esri import importers

class Command(BaseCommand):
    help = 'Import a shapefile from the ESRI data'
    
    def handle(self, *args, **options):
        if len(args) != 3:
            raise CommandError('Usage: import_esri <importer_type> <city> </path/to/shapefile/>')
        (importer_type, city, shapefile) = args
        importer_mod = getattr(importers, importer_type, None) 
        if importer_mod is None:
            raise CommandError('Invalid importer_type %s' % importer_type)
        importer_cls = getattr(importer_mod, 'EsriImporter', None)
        if importer_cls is None:
            raise CommandError('importer module must define an EsriImporter class')
        importer = importer_cls(shapefile, city)
        if options['verbosity'] == 2:
            verbose = True
        else:
            verbose = False
        num_created = importer.save(verbose)
        if options['verbosity'] > 0:
            print 'Created %d %s(s)' % (num_created, importer_type)

########NEW FILE########
__FILENAME__ = import_blocks
#!/usr/bin/env python
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

import sys
import pprint
import optparse
from collections import defaultdict
from django.contrib.gis.gdal import DataSource
from django.contrib.gis.gdal.error import OGRIndexError
from ebdata.parsing import dbf
from ebpub.geocoder.parser import parsing as geocoder_parsing
from ebpub.streets.blockimport.base import BlockImporter, logger

STATE_FIPS = {
    '02': ('AK', 'ALASKA'),
    '01': ('AL', 'ALABAMA'),
    '05': ('AR', 'ARKANSAS'),
    '60': ('AS', 'AMERICAN SAMOA'),
    '04': ('AZ', 'ARIZONA'),
    '06': ('CA', 'CALIFORNIA'),
    '08': ('CO', 'COLORADO'),
    '09': ('CT', 'CONNECTICUT'),
    '11': ('DC', 'DISTRICT OF COLUMBIA'),
    '10': ('DE', 'DELAWARE'),
    '12': ('FL', 'FLORIDA'),
    '13': ('GA', 'GEORGIA'),
    '66': ('GU', 'GUAM'),
    '15': ('HI', 'HAWAII'),
    '19': ('IA', 'IOWA'),
    '16': ('ID', 'IDAHO'),
    '17': ('IL', 'ILLINOIS'),
    '18': ('IN', 'INDIANA'),
    '20': ('KS', 'KANSAS'),
    '21': ('KY', 'KENTUCKY'),
    '22': ('LA', 'LOUISIANA'),
    '25': ('MA', 'MASSACHUSETTS'),
    '24': ('MD', 'MARYLAND'),
    '23': ('ME', 'MAINE'),
    '26': ('MI', 'MICHIGAN'),
    '27': ('MN', 'MINNESOTA'),
    '29': ('MO', 'MISSOURI'),
    '28': ('MS', 'MISSISSIPPI'),
    '30': ('MT', 'MONTANA'),
    '37': ('NC', 'NORTH CAROLINA'),
    '38': ('ND', 'NORTH DAKOTA'),
    '31': ('NE', 'NEBRASKA'),
    '33': ('NH', 'NEW HAMPSHIRE'),
    '34': ('NJ', 'NEW JERSEY'),
    '35': ('NM', 'NEW MEXICO'),
    '32': ('NV', 'NEVADA'),
    '36': ('NY', 'NEW YORK'),
    '39': ('OH', 'OHIO'),
    '40': ('OK', 'OKLAHOMA'),
    '41': ('OR', 'OREGON'),
    '42': ('PA', 'PENNSYLVANIA'),
    '72': ('PR', 'PUERTO RICO'),
    '44': ('RI', 'RHODE ISLAND'),
    '45': ('SC', 'SOUTH CAROLINA'),
    '46': ('SD', 'SOUTH DAKOTA'),
    '47': ('TN', 'TENNESSEE'),
    '48': ('TX', 'TEXAS'),
    '49': ('UT', 'UTAH'),
    '51': ('VA', 'VIRGINIA'),
    '78': ('VI', 'VIRGIN ISLANDS'),
    '50': ('VT', 'VERMONT'),
    '53': ('WA', 'WASHINGTON'),
    '55': ('WI', 'WISCONSIN'),
    '54': ('WV', 'WEST VIRGINIA'),
    '56': ('WY', 'WYOMING'),
}

# Only import features with these MTFCC codes - primary road,
# secondary road, and city street
VALID_MTFCC = set(['S1100', 'S1200', 'S1400'])

# There's a few of these that have FULLNAME and may even have addresses.
VALID_MTFCC.add('S1730') # alley, often unnamed.
VALID_MTFCC.add('S1640') # service roads, may have buildings.
VALID_MTFCC.add('S1740') # private roads, often unnamed.

class TigerImporter(BlockImporter):
    """
    Imports blocks using TIGER/Line shapefile data from the US Census.

    If `filter_city` is passed, we will skip features which don't have
    at least one of left_city or right_city matching the string.

    If `filter_bounds` is passed, it will be treated as an OGR geometry
    to use for filtering out features outside the geometry.

    `edges_shp` contains all the feature edges (i.e. street segment
    geometries); `featnames_dbf` contains metadata; `faces_dbf` and
    `place_shp` contain information about cities and states.

    Note this importer requires a lot of memory, because it loads the
    necessary .DBF files into memory for various lookups.

    Please refer to Census TIGER/Line shapefile documentation
    regarding the relationships between shapefiles and support DBF
    databases:

    http://www.census.gov/geo/www/tiger/tgrshp2008/rel_file_desc_2008.txt
    """
    def __init__(self, edges_shp, featnames_dbf, faces_dbf, place_shp,
                 filter_city=None, filter_bounds=None, filter_locations=(),
                 verbose=False, encoding='utf8', fix_cities=False,
                 reset=False,
                 ):
        BlockImporter.__init__(self, shapefile=edges_shp, layer_id=0,
                               verbose=verbose, encoding=encoding, reset=reset,
                               )
        self.fix_cities = fix_cities
        self.featnames_db = self._clean_featnames(featnames_dbf)
        self.faces_db = self._load_rel_db(faces_dbf, 'TFID')
        # Load places keyed by FIPS code
        places_layer = DataSource(place_shp)[0]
        fields = places_layer.fields
        self.places = places = {}
        for feature in places_layer:
            try:
                fips = feature.get('PLACEFP10') or feature.get('PLACEFP00') # 2010 Census files.
            except OGRIndexError:
                fips = feature.get('PLACEFP')
            values = dict(zip(fields, map(feature.get, fields)))
            places[fips] = values
        self.filter_city = filter_city and filter_city.upper() or None
        if hasattr(filter_bounds, 'ogr'):
            filter_bounds = filter_bounds.ogr
        self.filter_bounds = filter_bounds
        self.tlids_with_blocks = set()

    def _load_rel_db(self, dbf_file, rel_key):
        """
        Reads rows as dicts from a .dbf file.
        Returns a mapping of rel_key -> row dict.
        """
        f = open(dbf_file, 'rb')
        db = defaultdict(list)
        rowcount = 0
        try:
            for row in dbf.dict_reader(f, strip_values=True):
                db[row[rel_key]].append(row)
                rowcount += 1
                self.log(
                    " GOT DBF ROW %s for %s" % (row[rel_key], row.get('FULLNAME', 'unknown')))
        finally:
            f.close()
        self.log("Rows in %s: %d" % (dbf_file, rowcount))
        self.log("Unique keys for %r: %d" % (rel_key, len(db)))
        return db

    def _clean_featnames(self, featnames_dbf):
        rel_db = self._load_rel_db(featnames_dbf, 'TLID')
        featnames_db = defaultdict(list)
        for tlid, rows in rel_db.iteritems():
            primary = None
            alternates = []
            for row in rows:
                # TLID is Tiger/Line ID, unique per edge.
                # We use TLID instead of LINEARID as the key because
                # LINEARID is only unique per 'linear feature', which is
                # an implicit union of some edges. So if we used LINEARID,
                # we'd clobber a lot of keys in the call to
                # _load_rel_db().
                # Fixes #14 ("missing blocks").
                if row['MTFCC'] not in VALID_MTFCC:
                    continue
                if not row.get('FULLNAME'):
                    self.log("skipping tlid %r, no fullname" % tlid)
                    continue
                if row['PAFLAG'] == 'P':
                    primary = row
                    featnames_db[tlid].append(row)
                else:
                    alternates.append(row)
            # A lot of alternates seem to be duplicates of the primary name,
            # not useful.
            alternates = [row for row in alternates if row['NAME'].upper() != primary['NAME'].upper()]

            # For now we just log alternates that were found. Ideally we could save these
            # as aliases somehow, but at the moment we don't have a good way to do that.


            for alternate in alternates:
                correct = primary['NAME'].upper()
                incorrect = alternate['NAME'].upper()
                msg = 'Found alternate name for {0} ({1}): {2}\n{3}\n{4}'
                logger.debug(msg.format(correct, primary['TLID'], incorrect,
                                        pprint.pformat(primary),
                                        pprint.pformat(alternate)))
        return featnames_db

    def _get_city(self, feature, side):
        city = ''
        if self.fix_cities:
            from ebpub.db.models import get_city_locations
            overlapping_cities = list(get_city_locations().filter(location__intersects=feature.geom.geos))
            if overlapping_cities:
                city = overlapping_cities[0].name
                logger.debug("overriding city to %s" % city)
        else:
            fid = feature.get('TFID' + side)
            if fid in self.faces_db:
                face = self.faces_db[fid][0]
                # Handle both 2010 and older census files.
                # If none of these work, we simply get no city.
                pid = face.get('PLACEFP10') or face.get('PLACEFP00') or face.get('PLACEFP')

                if pid in self.places:
                    place = self.places[pid]
                    # Handle both 2010 and earlier Census files.
                    city = place.get('NAME10') or place['NAME']
        return city

    def _get_state(self, feature, side):
        fid = feature.get('TFID' + side)
        if fid in self.faces_db:
            face = self.faces_db[fid][0]
            # Handle both 2010 and older census files.
            state_fip = STATE_FIPS[face.get('STATEFP10') or face['STATEFP']]
            return state_fip[0]
        else:
            return ''

    def skip_feature(self, feature):
        if self.filter_bounds:
            if not feature.geom.intersects(self.filter_bounds):
                logger.debug("Skipping %s, out of bounds" % feature)
                return True

        if not feature.get('MTFCC') in VALID_MTFCC:
            logger.debug("Skipping %s, not a valid feature type" % feature.get('MTFCC'))
            return True

        if self.filter_city:
            in_city = False
            for side in ('R', 'L'):
                if self._get_city(feature, side).upper() == self.filter_city:
                    in_city = True
            if not in_city:
                logger.debug("Skipping %s, out of city" % feature)
                return True

        if not (
            ((feature.get('RFROMADD') and feature.get('RTOADD')) or
            (feature.get('LFROMADD') and feature.get('LTOADD')))):
            logger.debug("Skipping %s, not enough address info" % feature)
            return True

        return False

    def gen_blocks(self, feature):
        block_fields = {}
        tlid = feature.get('TLID')
        for field_key, feature_key in (('right_from_num', 'RFROMADD'),
                                       ('left_from_num', 'LFROMADD'),
                                       ('right_to_num', 'RTOADD'),
                                       ('left_to_num', 'LTOADD')):
            block_fields[field_key] = feature.get(feature_key)

        block_fields['right_zip'] = feature.get('ZIPR')
        block_fields['left_zip'] = feature.get('ZIPL')
        for side in ('right', 'left'):
            block_fields[side + '_city'] = self._get_city(feature, side[0].upper()).upper()
            block_fields[side + '_state'] = self._get_state(feature, side[0].upper()).upper()

        if tlid in self.featnames_db:
            suffix_standardizer = geocoder_parsing.STANDARDIZERS['suffix']
            suffix_matcher = geocoder_parsing.TOKEN_REGEXES['suffix']

            for featname in self.featnames_db[tlid]:
                # Prefix eg. 'STATE HWY'.
                block_fields['prefix'] = featname.get('PRETYPABRV', '').upper().strip()
                # Main part of the name, eg. 'MAIN'
                block_fields['street'] = featname['NAME'].upper().strip()
                # Prefix direction eg. 'N'.
                block_fields['predir'] = featname['PREDIRABRV'].upper().strip()
                # Suffix direction eg. 'SW'.
                block_fields['postdir'] = featname['SUFDIRABRV'].upper().strip()
                # Road type, eg. 'ST', 'AVE', 'PKWY'.
                block_fields['suffix'] = featname['SUFTYPABRV'].upper().strip()
                if not block_fields['suffix']:
                    # Bug in the data:
                    # Many streets named eg. 'Wilson Park' put the whole thing in the
                    # name and nothing in the suffix.
                    # This breaks our geocoder, because it parses 'Park' as the suffix
                    # and expects to find it in that field.
                    # So, check if the street name ends with a recognized suffix.
                    if block_fields['street'].count(' '):
                        name_parts = block_fields['street'].split()
                        raw_suffix = name_parts.pop()
                        street = ' '.join(name_parts)
                        if suffix_matcher.match(raw_suffix):
                            block_fields['suffix'] = suffix_standardizer(raw_suffix)
                            block_fields['street'] = street

                # More bugs in data: some auxiliary roads have the prefix as
                # part of the name in nonstandard format.
                if not block_fields['prefix']:
                    prefix, street = None, None
                    if block_fields['street'].startswith('INTERSTATE '):
                        prefix, street = block_fields['street'].split(' ', 1)
                    elif block_fields['street'].startswith('I-'):
                        prefix, street = block_fields['street'].split('-', 1)
                    if prefix and street:
                        logger.debug("Splitting prefix %r out of street %r" % (prefix, street))
                        block_fields['street'] = street.strip()
                        block_fields['prefix'] = prefix.strip()
                yield block_fields.copy()

                self.tlids_with_blocks.add(tlid)


def main(argv=None):
    if argv is None:
        argv = sys.argv[1:]
    parser = optparse.OptionParser(usage='%prog edges.shp featnames.dbf faces.dbf place.shp')
    parser.add_option('-v', '--verbose', action='store_true', dest='verbose', default=False)
    parser.add_option('-c', '--city', dest='city', help='A city name to filter against')
    parser.add_option('-f', '--fix-cities', action="store_true", default=False,
                      help='Whether to override "city" attribute of blocks and '
                      'streets by finding an intersecting Location of a city-ish '
                      'type. Only makes sense if you have configured '
                      'multiple_cities=True in the METRO_LIST of your settings.py, '
                      'and after you have created some appropriate Locations.')


    parser.add_option('-r', '--reset', action='store_true', default=False,
                      help="Whether to delete existing blocks and start from scratch. This will attempt to fix other models that have foreign keys to blocks; use at your own risk though."
                      )

    parser.add_option('-b', '--filter-bounds', action="store", default=1,
                      type='int',
                      help='Whether to skip blocks outside the metro extent from your '
                      'settings.py. Default 1 (true); use 0 to disable.')
    parser.add_option('-l', '--filter-location', action="append",
                      help='A location (spelled as location-type-slug:location-slug) '
                      'that will be used to filter out blocks outside its boundaries. '
                      'May be passed more than once.'
                      )

    parser.add_option('-e', '--encoding', dest='encoding',
                      help='Encoding to use when reading the shapefile',
                      default='utf8')
    (options, args) = parser.parse_args(argv)
    if len(args) != 4:
        return parser.error('must provide 4 arguments, see usage')

    if options.filter_bounds:
        from ebpub.utils.geodjango import get_default_bounds
        filter_bounds = get_default_bounds()
    else:
        filter_bounds = None

    # Optionally filter on bounds of some Locations too.
    loc_bounds = None
    for locslug in options.filter_location or []:
        typeslug, locslug = locslug.split(':', 1)
        from ebpub.db.models import Location
        location = Location.objects.get(location_type__slug=typeslug, slug=locslug)
        if loc_bounds is None:
            loc_bounds = location.location
        else:
            loc_bounds = loc_bounds.union(location.location)

    if None not in (filter_bounds, loc_bounds):
        filter_bounds = filter_bounds.intersection(loc_bounds)
    elif loc_bounds is not None:
        filter_bounds = loc_bounds
    else:
        filter_bounds = filter_bounds

    tiger = TigerImporter(*args, verbose=options.verbose,
                           filter_city=options.city,
                           filter_bounds=filter_bounds,
                           encoding=options.encoding,
                           reset=options.reset,
                           fix_cities=options.fix_cities)
    if options.verbose:
        import logging
        logger.setLevel(logging.DEBUG)
    num_created, num_existing = tiger.save()
    logger.info( "Created %d new blocks; kept %d old ones" % (num_created, num_existing))
    logger.debug("... from %d feature names" % len(tiger.featnames_db))
    logger.debug("feature tlids with blocks: %d" % len(tiger.tlids_with_blocks))

    import pprint
    tlids_wo_blocks = set(tiger.featnames_db.keys()).difference(tiger.tlids_with_blocks)
    logger.debug("feature tlids WITHOUT blocks: %d" % len(tlids_wo_blocks))
    all_rows = []
    for t in tlids_wo_blocks:
        all_rows.extend(tiger.featnames_db[t])
    logger.debug("Rows: %d" % len(all_rows))
    names = [(r['FULLNAME'], r['TLID']) for r in all_rows]
    names.sort()
    logger.debug( "=================")
    for n, t in names:
        logger.debug("%s %s" % (n, t))
    for tlid in sorted(tlids_wo_blocks)[:10]:
        feat = tiger.featnames_db[tlid]
        logger.debug(pprint.pformat(feat))

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Block'
        db.create_table('blocks', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('pretty_name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('predir', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=2, blank=True)),
            ('street', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('street_slug', self.gf('django.db.models.fields.SlugField')(max_length=50, db_index=True)),
            ('street_pretty_name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('suffix', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=32, blank=True)),
            ('postdir', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=2, blank=True)),
            ('left_from_num', self.gf('django.db.models.fields.IntegerField')(db_index=True, null=True, blank=True)),
            ('left_to_num', self.gf('django.db.models.fields.IntegerField')(db_index=True, null=True, blank=True)),
            ('right_from_num', self.gf('django.db.models.fields.IntegerField')(db_index=True, null=True, blank=True)),
            ('right_to_num', self.gf('django.db.models.fields.IntegerField')(db_index=True, null=True, blank=True)),
            ('from_num', self.gf('django.db.models.fields.IntegerField')(db_index=True, null=True, blank=True)),
            ('to_num', self.gf('django.db.models.fields.IntegerField')(db_index=True, null=True, blank=True)),
            ('left_zip', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=10, null=True, blank=True)),
            ('right_zip', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=10, null=True, blank=True)),
            ('left_city', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('right_city', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('left_state', self.gf('django.contrib.localflavor.us.models.USStateField')(max_length=2, db_index=True)),
            ('right_state', self.gf('django.contrib.localflavor.us.models.USStateField')(max_length=2, db_index=True)),
            ('parent_id', self.gf('django.db.models.fields.IntegerField')(db_index=True, null=True, blank=True)),
            ('geom', self.gf('django.contrib.gis.db.models.fields.LineStringField')()),
        ))
        db.send_create_signal('streets', ['Block'])

        # Adding model 'Street'
        db.create_table('streets', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('street', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('pretty_name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('street_slug', self.gf('django.db.models.fields.SlugField')(max_length=50, db_index=True)),
            ('suffix', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=32, blank=True)),
            ('city', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('state', self.gf('django.contrib.localflavor.us.models.USStateField')(max_length=2, db_index=True)),
        ))
        db.send_create_signal('streets', ['Street'])

        # Adding model 'Misspelling'
        db.create_table('streets_misspelling', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('incorrect', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
            ('correct', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
        ))
        db.send_create_signal('streets', ['Misspelling'])

        # Adding model 'StreetMisspelling'
        db.create_table('streets_streetmisspelling', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('incorrect', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
            ('correct', self.gf('django.db.models.fields.CharField')(max_length=255)),
        ))
        db.send_create_signal('streets', ['StreetMisspelling'])

        # Adding model 'Place'
        db.create_table('streets_place', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('pretty_name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('normalized_name', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('address', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
            ('location', self.gf('django.contrib.gis.db.models.fields.PointField')()),
        ))
        db.send_create_signal('streets', ['Place'])

        # Adding model 'BlockIntersection'
        db.create_table('streets_blockintersection', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('block', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['streets.Block'])),
            ('intersecting_block', self.gf('django.db.models.fields.related.ForeignKey')(related_name='intersecting_block', to=orm['streets.Block'])),
            ('intersection', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['streets.Intersection'], null=True, blank=True)),
            ('location', self.gf('django.contrib.gis.db.models.fields.PointField')()),
        ))
        db.send_create_signal('streets', ['BlockIntersection'])

        # Adding unique constraint on 'BlockIntersection', fields ['block', 'intersecting_block']
        db.create_unique('streets_blockintersection', ['block_id', 'intersecting_block_id'])

        # Adding model 'Intersection'
        db.create_table('intersections', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('pretty_name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=64, db_index=True)),
            ('predir_a', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=2, blank=True)),
            ('street_a', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('suffix_a', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=32, blank=True)),
            ('postdir_a', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=2, blank=True)),
            ('predir_b', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=2, blank=True)),
            ('street_b', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('suffix_b', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=32, blank=True)),
            ('postdir_b', self.gf('django.db.models.fields.CharField')(db_index=True, max_length=2, blank=True)),
            ('zip', self.gf('django.db.models.fields.CharField')(max_length=10, db_index=True)),
            ('city', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('state', self.gf('django.contrib.localflavor.us.models.USStateField')(max_length=2, db_index=True)),
            ('location', self.gf('django.contrib.gis.db.models.fields.PointField')()),
        ))
        db.send_create_signal('streets', ['Intersection'])

        # Adding unique constraint on 'Intersection', fields ['predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b']
        db.create_unique('intersections', ['predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'])

        # Adding model 'Suburb'
        db.create_table('streets_suburb', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('normalized_name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
        ))
        db.send_create_signal('streets', ['Suburb'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Intersection', fields ['predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b']
        db.delete_unique('intersections', ['predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'])

        # Removing unique constraint on 'BlockIntersection', fields ['block', 'intersecting_block']
        db.delete_unique('streets_blockintersection', ['block_id', 'intersecting_block_id'])

        # Deleting model 'Block'
        db.delete_table('blocks')

        # Deleting model 'Street'
        db.delete_table('streets')

        # Deleting model 'Misspelling'
        db.delete_table('streets_misspelling')

        # Deleting model 'StreetMisspelling'
        db.delete_table('streets_streetmisspelling')

        # Deleting model 'Place'
        db.delete_table('streets_place')

        # Deleting model 'BlockIntersection'
        db.delete_table('streets_blockintersection')

        # Deleting model 'Intersection'
        db.delete_table('intersections')

        # Deleting model 'Suburb'
        db.delete_table('streets_suburb')


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = 0002_add_place_misspellings
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'PlaceMisspelling'
        db.create_table('streets_placemisspelling', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('incorrect', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
            ('correct', self.gf('django.db.models.fields.CharField')(max_length=255)),
        ))
        db.send_create_signal('streets', ['PlaceMisspelling'])


    def backwards(self, orm):
        
        # Deleting model 'PlaceMisspelling'
        db.delete_table('streets_placemisspelling')


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placemisspelling': {
            'Meta': {'object_name': 'PlaceMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = 0003_refactor_misspellings
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting model 'PlaceMisspelling'
        db.delete_table('streets_placemisspelling')

        # Adding model 'PlaceSynonym'
        db.create_table('streets_placesynonym', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('pretty_name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('normalized_name', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('place', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['streets.Place'])),
        ))
        db.send_create_signal('streets', ['PlaceSynonym'])


    def backwards(self, orm):
        
        # Adding model 'PlaceMisspelling'
        db.create_table('streets_placemisspelling', (
            ('incorrect', self.gf('django.db.models.fields.CharField')(max_length=255, unique=True)),
            ('correct', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal('streets', ['PlaceMisspelling'])

        # Deleting model 'PlaceSynonym'
        db.delete_table('streets_placesynonym')


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = 0004_fix_block_numbers
# encoding: utf-8
import datetime
import logging
from south.db import db
from south.v2 import DataMigration
from django.db import models

logger = logging.getLogger('south')

class Migration(DataMigration):

    def forwards(self, orm):
        bad_blocks = list(orm.Block.objects.filter(from_num__gt=models.F('to_num')))
        if bad_blocks:
            logger.info("fixing %d blocks with from_num > to_num" % len(bad_blocks))
        for block in bad_blocks:
            block.to_num, block.from_num = block.from_num, block.to_num
            # I'd like to call our custom clean() method here,
            # but the South version of the model doesn't actually have it!
            block.save()


        bad_blocks = list(orm.Block.objects.filter(left_from_num__gt=models.F('left_to_num')))
        if bad_blocks:
            logger.info("fixing %d blocks with left_from_num > left_to_num" % len(bad_blocks))
        for block in bad_blocks:
            block.left_to_num, block.left_from_num = block.left_from_num, block.left_to_num
            block.save()

        bad_blocks = list(orm.Block.objects.filter(right_from_num__gt=models.F('right_to_num')))
        if bad_blocks:
            logger.info("fixing %d blocks with right_from_num > right_to_num" % len(bad_blocks))
        for block in bad_blocks:
            block.right_to_num, block.right_from_num = block.right_from_num, block.right_to_num
            block.save()

    def backwards(self, orm):
        pass


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'blank': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = 0005_auto__add_placetype
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'PlaceType'
        db.create_table('streets_placetype', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('plural_name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('indefinite_article', self.gf('django.db.models.fields.CharField')(max_length=2)),
            ('slug', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255, db_index=True)),
            ('is_geocodable', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('is_mappable', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('map_icon', self.gf('django.db.models.fields.files.FileField')(max_length=100, null=True, blank=True)),
        ))
        db.send_create_signal('streets', ['PlaceType'])


    def backwards(self, orm):
        
        # Deleting model 'PlaceType'
        db.delete_table('streets_placetype')


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'blank': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placetype': {
            'Meta': {'object_name': 'PlaceType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_geocodable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_mappable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'map_icon': ('django.db.models.fields.files.FileField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = 0006_initial_place_types
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
import os

class Migration(DataMigration):

    def forwards(self, orm):
        def _fx(model_id, key, attributes):
            Model = orm[model_id]
            params = {'defaults': attributes}
            params.update(key)
            ob, created = Model.objects.get_or_create(**params)
            for k, v in attributes.items(): 
                setattr(ob, k, v)
            ob.save()
        
        
        _fx('streets.placetype', {"slug": "poi"}, {
            "is_geocodable": True, 
            "plural_name": "Points of Interest", 
            "indefinite_article": "a", 
            "slug": "poi", 
            "is_mappable": True, 
            "name": "Point of Interest"
         })


    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'blank': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.PlaceType']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placetype': {
            'Meta': {'object_name': 'PlaceType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_geocodable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_mappable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'map_icon': ('django.db.models.fields.files.FileField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = 0007_auto__add_field_place_place_type
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        if db.dry_run:
            default_place_type_id = 1
        else:
            default_place_type_id = orm['streets.PlaceType'].objects.get(slug='poi').id
        # Adding field 'Place.place_type'
        db.add_column('streets_place', 'place_type', self.gf('django.db.models.fields.related.ForeignKey')(default=default_place_type_id, to=orm['streets.PlaceType']), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Place.place_type'
        db.delete_column('streets_place', 'place_type_id')


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'blank': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.PlaceType']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placetype': {
            'Meta': {'object_name': 'PlaceType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_geocodable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_mappable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'map_icon': ('django.db.models.fields.files.FileField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = 0008_auto__add_field_place_url
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Place.url'
        db.add_column('streets_place', 'url', self.gf('django.db.models.fields.TextField')(db_index=True, null=True, blank=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Place.url'
        db.delete_column('streets_place', 'url')


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'blank': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.PlaceType']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placetype': {
            'Meta': {'object_name': 'PlaceType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_geocodable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_mappable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'map_icon': ('django.db.models.fields.files.FileField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = 0009_auto__del_field_placetype_map_icon
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'PlaceType.map_icon'
        db.delete_column('streets_placetype', 'map_icon')


    def backwards(self, orm):
        
        # Adding field 'PlaceType.map_icon'
        db.add_column('streets_placetype', 'map_icon', self.gf('django.db.models.fields.files.FileField')(max_length=100, null=True, blank=True), keep_default=False)


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'blank': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.PlaceType']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placetype': {
            'Meta': {'object_name': 'PlaceType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_geocodable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_mappable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = 0010_auto__add_field_placetype_map_icon_url__add_field_placetype_map_color
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'PlaceType.map_icon_url'
        db.add_column('streets_placetype', 'map_icon_url', self.gf('django.db.models.fields.TextField')(null=True, blank=True), keep_default=False)

        # Adding field 'PlaceType.map_color'
        db.add_column('streets_placetype', 'map_color', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True), keep_default=False)


    def backwards(self, orm):
        import tempfile, os, sys
        sys.stderr.write("WARNING, destroying PlaceType.map_icon_url column\n")
        sys.stderr.write("WARNING, destroying PlaceType.map_color column\n")
        # Want to dump a fixture here.  Can't just use
        # call_command('dumpdata') because it knows about *current*
        # model code, not South's own ORM state.
        tmpdir = tempfile.mkdtemp()
        tmpname = os.path.join(tmpdir, 'placetypes_icons_colors.json')
        sys.stderr.write("... will try to save data in %s\n" % tmpname)
        try:
            dumpfile = open(tmpname, 'w')
            ptypes = orm.PlaceType.objects.all()
            from django.core import serializers
            serializer = serializers.get_serializer('json')()
            serializer.serialize(ptypes, stream=dumpfile)
            sys.stderr.write("\n... saved\n")
        except Exception, e:
            sys.stderr.write("\n... failed to save data:\n%s\n" % e)

        # Deleting field 'PlaceType.map_icon_url'
        db.delete_column('streets_placetype', 'map_icon_url')

        # Deleting field 'PlaceType.map_color'
        db.delete_column('streets_placetype', 'map_color')


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'blank': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.PlaceType']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placetype': {
            'Meta': {'object_name': 'PlaceType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_geocodable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_mappable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = 0011_fix_missing_suffixes
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
import re

class Migration(DataMigration):

    def forwards(self, orm):
        # Clean up streets that had the suffix stuffed into the name,
        # due to bad census data.
        # This happened a lot with streets ending in 'PARK',
        # eg. {street='WILSON PARK', suffix=''}
        # should be fixed as {street='WILSON', suffix='PARK'}.
        # As a result, nothing on those streets could be geocoded properly.
        # And this propagated to Blocks and Intersections as well :(
        try:
            from ebpub.geocoder.parser import parsing
            suffix_standardizer = parsing.STANDARDIZERS['suffix']
            suffix_matcher = parsing.TOKEN_REGEXES['suffix']
        except (ImportError, NameError, KeyError):
            print "Can't fix data, we depend on ebpub.geocoder.parser.parsing code that's apparently not there anymore!"
            return

        def smart_title(s, exceptions=None):
            # Copied from ebpub.utils.text
            result = re.sub(r"(?<=[\s\"\(-])(\w)", lambda m: m.group(1).upper(), s.lower())
            if result:
                result = result[0].upper() + result[1:]

            # Handle the exceptions.
            if exceptions is not None:
                for e in exceptions:
                    pat = re.escape(e)
                    if re.search("^\w", pat):
                        pat = r"\b%s" % pat
                    if re.search("\w$", pat):
                        pat = r"%s\b" % pat
                    pat = r"(?i)%s" % pat
                    result = re.sub(pat, e, result)

            return result


        def make_street_pretty_name(street, suffix):
            # Copied from ebpub.streets.name_utils.
            street_name = smart_title(street)
            if suffix:
                street_name += u' %s.' % smart_title(suffix)
            return street_name

        lacking_suffixes = orm['streets.street'].objects.filter(suffix='')
        for street in lacking_suffixes:
            if street.street.count(' '):
                old_norm_name = street.street
                name_parts = street.pretty_name.upper().split()
                raw_suffix = name_parts.pop().upper()
                name = ' '.join(name_parts)
                # Check if it's a known suffix.
                if suffix_matcher.match(raw_suffix):
                    street.suffix = suffix = suffix_standardizer(raw_suffix)
                    street.street = name
                    street.pretty_name = make_street_pretty_name(name, suffix)
                    # Dicey: assume that the standardizer gave us back
                    # something like 'PARK' rather than 'ST', and so
                    # doesn't need a trailing dot for the pretty name.
                    street.pretty_name = street.pretty_name.rstrip('.')
                    street.save()
                    print "Fixed street %s" % street.pretty_name
                    # Ugh, fix intersections too.
                    # Assume their pretty_name & slug are already OK.
                    for intersection in orm['streets.intersection'].objects.filter(
                          street_a=old_norm_name, suffix_a=''):
                        intersection.street_a = street.street
                        intersection.suffix_a = street.suffix
                        intersection.save()
                        print "Fixed intersection %s" % intersection.pretty_name
                    for intersection in orm['streets.intersection'].objects.filter(
                          street_b=old_norm_name, suffix_b=''):
                        intersection.street_b = street.street
                        intersection.suffix_b = street.suffix
                        try:
                            intersection.save()
                        except:
                            raise

                        print "Fixed intersection %s" % intersection.pretty_name
                    # And fix blocks too. Whee.
                    for block in orm['streets.block'].objects.filter(
                        street=old_norm_name):
                        block.street = street.street
                        block.suffix = street.suffix
                        block.save()
                        print "Fixed block %s" % block.pretty_name

    def backwards(self, orm):
        "Write your backwards methods here."
        pass


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'blank': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.PlaceType']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placetype': {
            'Meta': {'object_name': 'PlaceType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_geocodable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_mappable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = 0012_add_prefix_to_block_and_intersection
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Removing unique constraint on 'Intersection', fields ['suffix_b', 'street_a', 'street_b', 'suffix_a', 'predir_a', 'predir_b', 'postdir_b', 'postdir_a']
        db.delete_unique('intersections', ['suffix_b', 'street_a', 'street_b', 'suffix_a', 'predir_a', 'predir_b', 'postdir_b', 'postdir_a'])

        # Adding field 'Block.prefix'
        db.add_column('blocks', 'prefix', self.gf('django.db.models.fields.CharField')(db_index=True, default='', max_length=32, blank=True), keep_default=False)

        # Adding field 'Intersection.prefix_a'
        db.add_column('intersections', 'prefix_a', self.gf('django.db.models.fields.CharField')(db_index=True, default='', max_length=32, blank=True), keep_default=False)

        # Adding field 'Intersection.prefix_b'
        db.add_column('intersections', 'prefix_b', self.gf('django.db.models.fields.CharField')(db_index=True, default='', max_length=32, blank=True), keep_default=False)

        # Adding unique constraint on 'Intersection', fields ['prefix_a', 'prefix_b', 'suffix_b', 'street_a', 'street_b', 'suffix_a', 'predir_a', 'predir_b', 'postdir_b', 'postdir_a']
        db.create_unique('intersections', ['prefix_a', 'prefix_b', 'suffix_b', 'street_a', 'street_b', 'suffix_a', 'predir_a', 'predir_b', 'postdir_b', 'postdir_a'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Intersection', fields ['prefix_a', 'prefix_b', 'suffix_b', 'street_a', 'street_b', 'suffix_a', 'predir_a', 'predir_b', 'postdir_b', 'postdir_a']
        db.delete_unique('intersections', ['prefix_a', 'prefix_b', 'suffix_b', 'street_a', 'street_b', 'suffix_a', 'predir_a', 'predir_b', 'postdir_b', 'postdir_a'])

        # Deleting field 'Block.prefix'
        db.delete_column('blocks', 'prefix')

        # Deleting field 'Intersection.prefix_a'
        db.delete_column('intersections', 'prefix_a')

        # Deleting field 'Intersection.prefix_b'
        db.delete_column('intersections', 'prefix_b')

        # Adding unique constraint on 'Intersection', fields ['suffix_b', 'street_a', 'street_b', 'suffix_a', 'predir_a', 'predir_b', 'postdir_b', 'postdir_a']
        db.create_unique('intersections', ['suffix_b', 'street_a', 'street_b', 'suffix_a', 'predir_a', 'predir_b', 'postdir_b', 'postdir_a'])


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'prefix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'prefix_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'prefix_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'prefix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'prefix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'blank': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.PlaceType']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placetype': {
            'Meta': {'object_name': 'PlaceType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_geocodable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_mappable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = 0013_auto__add_field_street_prefix
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Street.prefix'
        db.add_column('streets', 'prefix', self.gf('django.db.models.fields.CharField')(db_index=True, default='', max_length=32, blank=True), keep_default=False)

        # Adding unique constraint on 'Street', fields ['city', 'street_slug', 'state']
        db.create_unique('streets', ['city', 'street_slug', 'state'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Street', fields ['city', 'street_slug', 'state']
        db.delete_unique('streets', ['city', 'street_slug', 'state'])

        # Deleting field 'Street.prefix'
        db.delete_column('streets', 'prefix')


    models = {
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'prefix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.blockintersection': {
            'Meta': {'ordering': "('block',)", 'unique_together': "(('block', 'intersecting_block'),)", 'object_name': 'BlockIntersection'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'intersecting_block': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'intersecting_block'", 'to': "orm['streets.Block']"}),
            'intersection': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Intersection']", 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {})
        },
        'streets.intersection': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('predir_a', 'prefix_a', 'street_a', 'suffix_a', 'postdir_a', 'predir_b', 'prefix_b', 'street_b', 'suffix_b', 'postdir_b'),)", 'object_name': 'Intersection', 'db_table': "'intersections'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {}),
            'postdir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'postdir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'prefix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'prefix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '64', 'db_index': 'True'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street_a': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_b': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'suffix_a': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'suffix_b': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'zip': ('django.db.models.fields.CharField', [], {'max_length': '10', 'db_index': 'True'})
        },
        'streets.misspelling': {
            'Meta': {'object_name': 'Misspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.place': {
            'Meta': {'object_name': 'Place'},
            'address': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.PointField', [], {'blank': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'place_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.PlaceType']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'streets.placesynonym': {
            'Meta': {'object_name': 'PlaceSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'place': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Place']"}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'streets.placetype': {
            'Meta': {'object_name': 'PlaceType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_geocodable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_mappable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'streets.street': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('street_slug', 'city', 'state'),)", 'object_name': 'Street', 'db_table': "'streets'"},
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'prefix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'})
        },
        'streets.streetmisspelling': {
            'Meta': {'object_name': 'StreetMisspelling'},
            'correct': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'incorrect': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        },
        'streets.suburb': {
            'Meta': {'object_name': 'Suburb'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'})
        }
    }

    complete_apps = ['streets']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Blocks
======
.. _blocks:

A :py:class:`Block` is a segment of a single street between one side street and another
side street. Blocks are a fundamental piece of the ebpub system; they're used
both in creating a page for each block and in geocoding.

Blocks are stored in a database table called "blocks". To populate this table,
follow these steps:

    1. Obtain a database of the streets in your city, along with each street's
       address ranges and individual street segments. If you live in the
       U.S.A. and your city hasn't had much new development since the year
       2000, you might want to use the U.S. Census' TIGER/Line file
       (http://www.census.gov/geo/www/tiger/).

    2. Import the streets data into the "blocks" table. ebpub provides two
       pre-made import scripts:

           * If you're using TIGER/Line data, you can use the script
             ``import_blocks_tiger`` which should be on your $PATH.

           * If you're using data from ESRI, you can use the script
             ``ebpub/streets/blockimport/esri/importers/blocks.py.``

           * If you're using data from another source, take a look at the
             Block model in ``ebpub/streets/models.py`` for all of the required
             fields.


Streets and Intersections
=========================

The ebpub system maintains a separate table of each :py:class:`Street`
in the city. Once you've populated the blocks, you can automatically
populate the streets table by running the importer
``ebpub/streets/bin/populate_streets.py``, which should be on your
``$PATH`` as ``populate_streets``.

The ebpub system also maintains a table of each
:py:class:`Intersection` in the city, where an intersection is defined
as the meeting point of two streets. Just like streets, you can
automatically populate the intersections table by running the code in
the ``populate_streets`` script.

Streets and intersections are both necessary for various bits of the site to
work, such as the "browse by street" navigation and the geocoder (which
supports the geocoding of intersections).

Once you've got all of the above geographic boundary data imported, you can
verify it on the site by browsing to /streets/ and /locations/.

module contents
================

"""

from django.contrib.localflavor.us.models import USStateField
from django.contrib.gis.db import models
from django.contrib.gis.geos import Point
from django.core import urlresolvers
from django.db.models import Q
from ebpub.geocoder.parser.parsing import normalize
from ebpub.metros.allmetros import get_metro
import logging
import operator
import re

logger = logging.getLogger('ebpub.streets.models')


def _first_not_false(*args):
    """Return the first non-falsish argument; if all are false,
    return the last.
    """
    for arg in args:
        if arg:
            return arg
    return arg

def proper_city(block):
    """
    Returns the "proper" city for block, as a string.

    This function is necessary because in the Block model there are
    two sides of the street, and the city on the left side could
    differ from the city on the right. This function uses knowledge
    about metros and cities to return the canonical city
    for our purposes for a block.

    In some blocks, this may return an empty string - eg. in
    unincorporated areas of rural counties, or when the city simply
    isn't one we know anything about.
    """
    from ebpub.db.models import get_city_locations
    metro = get_metro()
    if metro['multiple_cities']:
        cities = set([l.name.upper() for l in get_city_locations()])
    else:
        cities = set([metro['city_name'].upper()])
    # Determine the block's city, which because of blocks that
    # border two different municipalities, and because of metros
    # with multiple cities like NYC and Miami-Dade, means checking
    # both sides of the block and comparing with known city names.
    block_city = u''
    if block.left_city != block.right_city:
        # Note that if both left_city and right_city are valid, then we
        # return the left_city.
        if block.left_city in cities:
            block_city = block.left_city
        elif block.right_city in cities:
            block_city = block.right_city
    elif block.left_city in cities:
        block_city = block.left_city
    if not block_city:
        # We may be in some other area that isn't a city we know about.
        # That shouldn't prevent us from doing anything useful with this block.
        block_city = _first_not_false(block.left_city, block.right_city, u'')
    return block_city

class BlockManager(models.GeoManager):
    def search(self, street, number=None, prefix=None, predir=None,
               suffix=None, postdir=None, city=None, state=None, zipcode=None):
        """
        Searches the blocks for the given address bits. Returns a list
        of 2-tuples, (block, geocoded_pt).

        geocoded_pt will be None if number is None.

        We make these assumptions about the input:

            * Everything is already in all-uppercase
            * The predir and postdir have been standardized

        Note we don't enforce parity (even/odd) matching.
        So 3181 would match the block 3180-3188.
        """
        filters = {'street': street.upper()}
        sided_filters = []
        if predir:
            filters['predir'] = predir.upper()
        if prefix:
            filters['prefix'] = prefix.upper()
        if suffix:
            filters['suffix'] = suffix.upper()
        if postdir:
            filters['postdir'] = postdir.upper()
        if city:
            city_filter = Q(left_city=city.upper()) | Q(right_city=city.upper())
            sided_filters.append(city_filter)
        if state:
            state_filter = Q(left_state=state.upper()) | Q(right_state=state.upper())
            sided_filters.append(state_filter)
        if zipcode:
            zip_filter = Q(left_zip=zipcode) | Q(right_zip=zipcode)
            sided_filters.append(zip_filter)

        qs = self.filter(*sided_filters, **filters)

        # If a number was given, search against the address ranges in the
        # Block table.
        if number:
            number = int(re.sub(r'\D', '', number))
            block_tuples = []
            for block in qs.filter(from_num__lte=number, to_num__gte=number):
                contains, from_num, to_num = block.contains_number(number)
                if contains:
                    block_tuples.append((block, from_num, to_num))
            blocks = []
            if block_tuples:
                from ebpub.utils.geodjango import interpolate
                for block, from_num, to_num in block_tuples:
                    try:
                        fraction = (float(number) - from_num) / (to_num - from_num)
                    except ZeroDivisionError:
                        fraction = 0.5
                    point = interpolate(block.geom, fraction, True)
                    blocks.append((block, Point(*list(point.coords))))
        else:
            blocks = list([(b, None) for b in qs])
        return blocks


class Block(models.Model):
    """Represents a segment of a single street, typically between two
    intersections.

    (But note that due to vagaries of the source data, eg. US Census
    data, a Blocks may sometimes be a segment of a street that doesn't
    start and/or end at an intersection; it may just be a range of
    addresses between two apparently arbitrary points.)
    """
    street_slug = models.SlugField(help_text="Slug used for looking up a related Street. Includes prefix, street, and suffix, but not directionals. Example: us-highway-63")

    pretty_name = models.CharField(
        max_length=255,
        help_text='human-readable name including everything - address range, directionals, street name, suffix. Example: 8701-8703 US Highway 63 S.')

    street_pretty_name = models.CharField(
        max_length=255,
        help_text='Like pretty_name but without address numbers or directionals. Example: US Highway 63.')

    predir = models.CharField(
        max_length=2, blank=True, db_index=True,
        help_text='Direction abbreviation before street name, UPPERCASE, eg. N or SW')

    prefix =  models.CharField(max_length=32, blank=True, db_index=True,
                               help_text='Prefix in UPPERCASE, eg. US HIGHWAY')

    street = models.CharField(
        max_length=255, db_index=True,
        help_text='Just the street part of the name, UPPERCASE, with no directionals, prefix, or suffix. Example: 63')
    suffix = models.CharField(max_length=32, blank=True, db_index=True,
                              help_text='Suffix abbreviation in UPPERCASE, eg. ST or AVE')
    postdir = models.CharField(
        max_length=2, blank=True, db_index=True,
        help_text='Direction abbreviation after street name, UPPERCASE, eg. N or SW')


    left_from_num = models.IntegerField(
        db_index=True, blank=True, null=True,
        help_text='Lowest address on the "left" side of the street')
    left_to_num = models.IntegerField(
        db_index=True, blank=True, null=True,
        help_text='Highest address on the "left" side of the street')
    right_from_num = models.IntegerField(
        db_index=True, blank=True, null=True,
        help_text='Lowest address on the "right" side of the street')
    right_to_num = models.IntegerField(
        db_index=True, blank=True, null=True,
        help_text='Highest address on the "right" side of the street')
    from_num = models.IntegerField(
        db_index=True, blank=True, null=True,
        help_text='Smallest of left_from_num and right_from_num')
    to_num = models.IntegerField(
        db_index=True, blank=True, null=True,
        help_text='Largest of left_to_num and right_to_num')

    left_zip = models.CharField(
        max_length=10, db_index=True, blank=True, null=True,
        help_text='Zip/postal code on left side of street.') # Possible Plus-4
    right_zip = models.CharField(
        max_length=10, db_index=True, blank=True, null=True,
        help_text='Zip/postal code on right side of street.')

    left_city = models.CharField(
        max_length=255, db_index=True, blank=True,
        help_text='Name of city, UPPERCASE, on left side of street.')
    right_city = models.CharField(
        max_length=255, db_index=True, blank=True,
        help_text='Name of city, UPPERCASE, on right side of street.')

    left_state = USStateField(  # bad for i18n!
        db_index=True,
        help_text='US State abbreviation, UPPERCASE, on left side of street.')
    right_state = USStateField(  # bad for i18n!
        db_index=True,
        help_text='US State abbreviation, UPPERCASE, on right side of street.')

    parent_id = models.IntegerField(
        db_index=True, blank=True, null=True,
        help_text='This field is used for blocks that are alternate names for another block, which is pointed to by this ID')

    geom = models.LineStringField(
        help_text='Geometry of this street segment - a linestring')

    objects = BlockManager()

    class Meta:
        db_table = 'blocks'
        ordering = ('pretty_name',)

    def __unicode__(self):
        return self.pretty_name

    def number(self):
        """
        Returns a formatted street number
        """
        if self.from_num == self.to_num:
            return unicode(self.from_num)
        if not self.from_num:
            return unicode(self.to_num)
        if not self.to_num:
            return unicode(self.from_num)
        return u'%s-%s' % (self.from_num, self.to_num)

    def dir_url_bit(self):
        """
        Returns the directional bit of the URL.

        For example, if the pre-directional is "N" and the post-directional is
        blank, returns "n".

        If the pre-directional is "E" and the post-directional is "SW",
        returns "e-sw".

        If the pre-directional is blank and the post-directional is "e",
        return "-e".

        If both are blank, returns the empty string.
        """
        url = []
        if self.predir:
            url.append(self.predir.lower())
        if self.postdir:
            url.extend(['-', self.postdir.lower()])
        return ''.join(url)

    def get_absolute_url(self):
        try:
            return urlresolvers.reverse('ebpub-block-recent',
                                        args=self._get_full_url_args())
        except urlresolvers.NoReverseMatch:
            return None

    url = get_absolute_url  # for backward compatibility

    def _get_full_url_args(self):
        args = [self.city_slug, self.street_slug, self.from_num, self.to_num,
                (self.predir or '').lower(),
                (self.postdir or '').lower(),
                ]
        return args

    def street_url(self):
        args = [self.city_slug, self.street_slug]
        return urlresolvers.reverse('ebpub-block-list', args=args)

    def rss_url(self):
        return urlresolvers.reverse('ebpub-block-rss',
                                    args=self._get_full_url_args())

    def alert_url(self):
        return urlresolvers.reverse('ebpub-block-alerts-signup',
                                    args=self._get_full_url_args())

    def city_object(self):
        return City.from_norm_name(self.city)

    @property
    def city_slug(self):
        if get_metro()['multiple_cities']:
            return self.city_object().slug
        return ''

    def contains_number(self, number):
        """
        Returns a tuple of (boolean, from_num, to_num), where boolean is
        True if this Block contains the given address number. The from_num
        and to_num values are the ones that were used to calculate it.

        Checks both the block range and the parity (even vs. odd numbers).
        """
        parity = number % 2
        do_check_parity = True
        if self.left_from_num and self.right_from_num:
            left_parity = self.left_from_num % 2
            # If this block's left side has the same parity as the right side,
            # all bets are off -- just use the from_num and to_num.
            if self.right_to_num % 2 == left_parity or self.left_to_num % 2 == self.right_from_num % 2:
                from_num, to_num = self.from_num, self.to_num
                do_check_parity = False
            elif left_parity == parity:
                from_num, to_num = self.left_from_num, self.left_to_num
            else:
                from_num, to_num = self.right_from_num, self.right_to_num
        elif self.left_from_num:
            from_num, to_num = self.left_from_num, self.left_to_num
        elif self.right_from_num:
            from_num, to_num = self.right_from_num, self.right_to_num
        elif self.from_num:
            do_check_parity = False
            from_num, to_num = self.from_num, self.to_num
        else:
            # Everything's null?  Give up.
            return False, self.from_num, self.to_num
        if do_check_parity:
            # If the parity is equal for from_num and to_num, make sure the
            # parity of the number is the same.
            from_parity, to_parity = from_num % 2, to_num % 2
            if (from_parity == to_parity) and (from_parity != parity):
                return False, from_num, to_num

        return (from_num <= number <= to_num), from_num, to_num

    @property
    def location(self):
        return self.geom

    @property
    def city(self):
        if not hasattr(self, '_city_cache'):
            self._city_cache = proper_city(self)
        return self._city_cache

    @property
    def state(self):
        if self.left_state == self.right_state:
            return self.left_state
        else:
            return get_metro()['state']

    @property
    def zip(self):
        return self.left_zip

    def clean(self):
        """Enforce some constraints that depend on multiple fields.
        """
        from django.core.exceptions import ValidationError
        l_from = self.left_from_num
        r_from = self.right_from_num
        l_to = self.left_to_num
        r_to = self.right_to_num

        if not any((l_from, l_to, r_from, r_to)):
            raise ValidationError(
                "At least one of left_from_num, left_to_num, right_from_num, and/or right_to_num must be set to a non-empty, non-zero value")

        # Ensure we don't get the order wrong. Fixes #164
        if l_from > l_to:
            logger.debug('left_from_num %s cannot be greater than left_to_num %s, '
                         'swapping those for you.' % (l_from, l_to))
            l_to, l_from = l_from, l_to

        # Ensure we don't get the order wrong. Fixes #164
        if r_from > r_to:
            logger.debug('right_from_num %s cannot be greater than right_to_num %s, '
                         'swapping those for you.' % (r_from, r_to))
            r_to, r_from = r_from, r_to

        self.left_from_num = l_from
        self.right_from_num = r_from
        self.left_to_num = l_to
        self.right_to_num = r_to

        self.left_zip = _first_not_false(self.left_zip, self.right_zip)
        self.right_zip = _first_not_false(self.right_zip, self.left_zip)

        self.left_state = _first_not_false(self.left_state, self.right_state)
        self.right_state = _first_not_false(self.right_state, self.left_state)

        # We don't attempt to fix left_city and right_city as those are
        # allowed to differ, or even be blank;
        # blank means it's an unincorporated area.

        # from_num and to_num are always calculated automatically.
        from ebpub.streets.name_utils import make_block_numbers
        self.from_num, self.to_num = make_block_numbers(
            l_from, l_to, r_from, r_to)


        # TODO: maybe this merits an UppercaseStringField or some such?
        for key in ('left_city', 'right_city',
                    'predir', 'postdir',
                    'street', 'suffix',
                    'prefix',
                    'left_state', 'right_state'):
            val = getattr(self, key)
            if val is not None:
                setattr(self, key, val.strip().upper())


class Street(models.Model):
    """
    Represents a Street with a unique name (in a particular city).

    Does not know about directionals: a block on North Main Street is
    considered to be on the same street as South Main Street.

    We do not have geometries for these; they are typically just used
    as a grouping of :py:class:`Blocks <Block>`.
    """
    street = models.CharField(max_length=255, db_index=True,
                              help_text='Always uppercase. eg. 63')
    prefix =  models.CharField(max_length=32, blank=True, db_index=True,
                               help_text='Prefix in UPPERCASE, eg. US HIGHWAY')
    pretty_name = models.CharField(max_length=255,
                                   help_text='Includes prefix, street, and suffix, but not directionals. Example: US Highway 63')
    street_slug = models.SlugField(
        help_text="Slug used for looking up related Blocks. Based on pretty_name; includes prefix, street, and suffix, but not directionals. Example: us-highway-63")

    suffix = models.CharField(max_length=32, blank=True, db_index=True,
                              help_text='Always uppercase. Example: ST or AVE')
    city = models.CharField(max_length=255, db_index=True,
                            help_text='Always uppercase. City name, not slug.')
    state = USStateField(db_index=True, help_text='Always uppercase.')  # bad for i18n!

    class Meta:
        db_table = 'streets'
        ordering = ('pretty_name',)
        unique_together = ('street_slug', 'city', 'state')

    def __unicode__(self):
        return self.pretty_name

    def get_absolute_url(self):
        return urlresolvers.reverse('ebpub-block-list', args=[self.city_slug, self.street_slug])

    # For backward compatibility.
    url = get_absolute_url

    @property
    def city_slug(self):
        if get_metro()['multiple_cities']:
            return self.city_object().slug
        return ''

    def city_object(self):
        return City.from_norm_name(self.city)

    def save(self, force_insert=False, force_update=False, using=None):
        if self.suffix:
            self.suffix = self.suffix.upper().strip()
        if self.state:
            self.state = self.state.upper().strip()
        if self.city:
            # TODO: validate that there's a matching metro setting?
            # (or Location object, if the metro is multi-city)?
            self.city = self.city.upper().strip()

        self.street = normalize(self.pretty_name)
        if self.suffix:
            self.street = re.sub(r' %s$' % self.suffix.upper(), '', self.street)
        super(Street, self).save(force_insert=force_insert, force_update=force_update, using=using)


class Misspelling(models.Model):
    """
    A generalized mapping between two normalized forms used in some 
    places to track general misspellings. Use LocationSynonym, PlaceSynonym and
    StreetMisspelling to represent specific types of "misspellings"
    """
    incorrect = models.CharField(max_length=255, unique=True) # Always uppercase, single spaces
    correct = models.CharField(max_length=255, db_index=True)

    def __unicode__(self):
        return self.incorrect

class StreetMisspellingManager(models.Manager):
    def make_correction(self, street_name):
        """
        Returns the correct spelling of the given street name. If the given
        street name is already correctly spelled, then it's returned as-is.

        Note that the given street name will be converted to all caps,
        and spaces normalized.
        """
        street_name = ' '.join(street_name.upper().strip().split())
        try:
            return self.get(incorrect=street_name).correct
        except self.model.DoesNotExist:
            return street_name

class StreetMisspelling(models.Model):
    incorrect = models.CharField(max_length=255, unique=True, help_text="Incorrect street name in UPPERCASE, do not include a suffix, eg: BWAY") # Always uppercase, single spaces
    correct = models.CharField(max_length=255, help_text="Correct street name in UPPERCASE, do not include suffix, eg: BROADWAY")
    objects = StreetMisspellingManager()

    def save(self, force_insert=False, force_update=False, using=None):
        """Ensure everything's normalized (uppercase, normalized whitespace).
        Doing this on the model so it happens regardless of whether
        data comes from admin UI or a script or whatever.
        """
        self.incorrect = normalize(self.incorrect or '')
        self.correct = normalize(self.correct or '')
        super(StreetMisspelling, self).save(force_insert=force_insert,
                                            force_update=force_update,
                                            using=using)

    def __unicode__(self):
        return self.incorrect


class PlaceTypeManager(models.Manager):

    def get_by_natural_key(self, slug):
        return self.get(slug=slug)

class PlaceType(models.Model):
    """
    A kind of Place, this could be anything, eg. 'Building', 'Park',
    'Monument', 'Theater', 'Restaurant', ...
    """
    objects = PlaceTypeManager()

    name = models.CharField(max_length=255)
    plural_name = models.CharField(max_length=255)
    indefinite_article = models.CharField(max_length=2) # 'a' or 'an'

    slug = models.CharField(max_length=255, db_index=True, unique=True)
    is_geocodable = models.BooleanField(default=True, help_text="Whether this type of place is searched by name during geocoding.")
    is_mappable = models.BooleanField(default=True, help_text="Whether this type is available as a map layer to users")
    map_icon_url = models.TextField(blank=True, null=True)
    map_color = models.CharField(max_length=255, blank=True, null=True, help_text="CSS Color used on maps to display this type of place. eg #FF0000")

    def get_map_icon_url(self):
        from django.conf import settings
        url = self.map_icon_url or u''
        if url and not (url.startswith('/') or url.startswith('http')):
            url = '%s/%s' % (settings.STATIC_URL.rstrip('/'), url)
        return url


    def natural_key(self):
        return (self.slug, )
        
    def __unicode__(self):
        return self.name

class Place(models.Model):
    """
    A generic place, like "Millennium Park" or "Sears Tower".
    This is just a Point with a name and an address
    (and maybe a URL).
    """
    pretty_name = models.CharField(max_length=255)
    normalized_name = models.CharField(max_length=255, db_index=True,
                                       blank=True,
                                       help_text='Always uppercase, single spaces; will be calculated from pretty_name if needed.')
    place_type = models.ForeignKey(PlaceType)
    address = models.CharField(max_length=255, blank=True)
    url = models.TextField(blank=True, null=True, db_index=True,
                           help_text='link to additional information')

    location = models.PointField(blank=True)
    objects = models.GeoManager()

    def __unicode__(self):
        if self.address:
            return u'%s (%s)' % (self.pretty_name, self.address)
        return self.pretty_name

    def save(self, force_insert=False, force_update=False, using=None):
        if not self.normalized_name:
            self.normalized_name = normalize(self.pretty_name)
        super(Place, self).save(force_update=force_update, force_insert=force_insert, using=using)


class PlaceSynonymManager(models.Manager):
    def get_canonical(self, name):
        """
        Returns the 'correct' or canonical spelling of the given place name.

        If the given place name is already correctly spelled, then
        it's returned as-is.
        """
        try:
            normalized_name = normalize(name)
            return self.get(normalized_name=normalized_name).place.normalized_name
        except self.model.DoesNotExist:
            return normalized_name


class PlaceSynonym(models.Model):
    """
    represents a synonym for a Place (point of interest)
    """
    pretty_name = models.CharField(max_length=255)
    normalized_name = models.CharField(max_length=255, db_index=True,
                                       help_text='Always uppercase, single spaces; will be calculated from pretty_name if needed.')
    place = models.ForeignKey(Place)
    objects = PlaceSynonymManager()

    def save(self, force_insert=False, force_update=False, using=None):
        if not self.normalized_name:
            self.normalized_name = normalize(self.pretty_name)
        super(PlaceSynonym, self).save(force_insert=force_insert, force_update=force_update, using=using)

    def __unicode__(self):
        return self.pretty_name


class City(object):
    def __init__(self, name, slug, norm_name):
        self.name, self.slug, self.norm_name = name, slug, norm_name

    def from_name(cls, name):
        return cls(name, name.lower().replace(' ', '-'), name.upper())
    from_name = classmethod(from_name)

    def from_slug(cls, slug):
        return cls(slug.title().replace('-', ' '), slug, slug.upper().replace('-', ' '))
    from_slug = classmethod(from_slug)

    def from_norm_name(cls, norm_name):
        return cls(norm_name.title(), norm_name.lower().replace(' ', '-'), norm_name)
    from_norm_name = classmethod(from_norm_name)

    def __eq__(self, other):
        return (self.name, self.slug, self.norm_name) == (
            other.name, other.slug, other.norm_name)


class BlockIntersection(models.Model):
    """
    Relates two Blocks and an Intersection.
    """
    block = models.ForeignKey(Block)
    intersecting_block = models.ForeignKey(Block, related_name="intersecting_block")
    intersection = models.ForeignKey("Intersection", blank=True, null=True)
    location = models.PointField()

    class Meta:
        unique_together = ("block", "intersecting_block")
        ordering = ('block',)

    def __unicode__(self):
        return u'%s intersecting %s' % (self.block, self.intersecting_block)


class IntersectionManager(models.GeoManager):
    def search(self, predir_a=None, prefix_a=None, street_a=None, suffix_a=None, postdir_a=None,
                     predir_b=None, prefix_b=None, street_b=None, suffix_b=None, postdir_b=None):
        """
        Returns a queryset of intersections.
        """
        # Since intersections are symmetrical---"N. Kimball Ave. & W. Diversey
        # Ave." == "W. Diversey Ave. & N. Kimball Ave."---we use Q
        # objects for the OR reverse of the ordering of the keyword
        # arguments.
        filters = [{}, {}]
        if predir_a:
            filters[0]["predir"] = predir_a.upper()
        if prefix_a:
            filters[0]["prefix"] = prefix_a.upper()
        if street_a:
            filters[0]["street"] = street_a.upper()
        if suffix_a:
            filters[0]["suffix"] = suffix_a.upper()
        if postdir_a:
            filters[0]["postdir"] = postdir_a.upper()
        if predir_b:
            filters[1]["predir"] = predir_b.upper()
        if prefix_b:
            filters[0]["prefix"] = prefix_b.upper()
        if street_b:
            filters[1]["street"] = street_b.upper()
        if suffix_b:
            filters[1]["suffix"] = suffix_b.upper()
        if postdir_b:
            filters[1]["postdir"] = postdir_b.upper()
        q1 = reduce(operator.and_, [Q(**{k+"_a": v}) for k,v in filters[0].iteritems()] +
                                   [Q(**{k+"_b": v}) for k,v in filters[1].iteritems()])
        q2 = reduce(operator.and_, [Q(**{k+"_a": v}) for k,v in filters[1].iteritems()] +
                                   [Q(**{k+"_b": v}) for k,v in filters[0].iteritems()])
        qs = self.filter(q1 | q2)
        qs = qs.extra(select={"point": "AsText(location)"})
        return qs


class Intersection(models.Model):
    """
    A point representing the meeting of two Streets
    (refers to them only by name).
    """
    pretty_name = models.CharField(max_length=255, unique=True) # eg., "N. Kimball Ave. & W. Diversey Ave.
    slug = models.SlugField(max_length=64) # eg., "n-kimball-ave-and-w-diversey-ave"
    # Street A
    predir_a = models.CharField(max_length=2, blank=True, db_index=True) # eg., "N"
    prefix_a = models.CharField(max_length=32, blank=True, db_index=True) # eg., "US HWY"
    street_a = models.CharField(max_length=255, db_index=True) # eg., "KIMBALL"
    suffix_a = models.CharField(max_length=32, blank=True, db_index=True) # eg., "AVE"
    postdir_a = models.CharField(max_length=2, blank=True, db_index=True) # eg., "NW"
    # Street B
    predir_b = models.CharField(max_length=2, blank=True, db_index=True) # eg., "W"
    prefix_b = models.CharField(max_length=32, blank=True, db_index=True) # eg., "US HWY"
    street_b = models.CharField(max_length=255, db_index=True) # eg., "DIVERSEY"
    suffix_b = models.CharField(max_length=32, blank=True, db_index=True) # eg., "AVE"
    postdir_b = models.CharField(max_length=2, blank=True, db_index=True) # eg., "SE"
    zip = models.CharField(max_length=10, db_index=True) # Possible Plus-4
    city = models.CharField(max_length=255, db_index=True) # Always uppercase
    state = USStateField(db_index=True) # Always uppercase. TODO: bad for i18n!
    location = models.PointField()
    objects = IntersectionManager()

    class Meta:
        db_table = 'intersections'
        # TODO: This unique_together is just a silly assumption.
        # There are places where the same two streets cross multiple
        # times even within one area (city, zip code, whatever).
        # Example off the top of my head -
        # http://g.co/maps/pcxsm
        # - route 28 and old route 28 intersect what, 4 times in the space of
        # a mile or two?
        unique_together = ("predir_a", "prefix_a", "street_a", "suffix_a", "postdir_a",
                           "predir_b", "prefix_b", "street_b", "suffix_b", "postdir_b")
        ordering = ('slug',)

    def __unicode__(self):
        return self.pretty_name

    def reverse_pretty_name(self):
        return u" & ".join(self.pretty_name.split(" & ")[::-1])

    def url(self):
        # Use the URL of the first block found of those which comprise
        # this intersection.
        try:
            first_block = self.blockintersection_set.all()[0].block
        except IndexError:
            return ''
        return first_block.url()

    def alert_url(self):
        return '%salerts/' % self.url()


class Suburb(models.Model):
    """This model keeps track of nearby cities that we don't care about.
    It's essentially a blacklist.
    """
    name = models.CharField(max_length=255)
    normalized_name = models.CharField(max_length=255, unique=True)

    def save(self, force_insert=False, force_update=False, using=None):
        """Ensure everything's normalized (uppercase, normalized whitespace).
        Doing this on the model so it happens regardless of whether
        data comes from admin UI or a script or whatever.
        """
        self.normalized_name = normalize(self.name)
        super(Suburb, self).save(force_insert=force_insert, force_update=force_update, using=using)

    def __unicode__(self):
        return self.name

########NEW FILE########
__FILENAME__ = name_utils
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Utility functions for munging address/block/street names.
"""

import re
from ebpub.utils.text import smart_title, slugify

def make_street_pretty_name(prefix, street, suffix):
    """
    >>> make_street_pretty_name(None, 'whee', None)
    u'Whee'
    >>> make_street_pretty_name('oh', 'boy', None)
    u'Oh Boy'
    >>> make_street_pretty_name('', 'YES', 'nO')
    u'Yes No'
    >>> make_street_pretty_name(' US hWy ', '101', 'C')
    u'US Hwy 101 C'
    >>> make_street_pretty_name(' I- ', '40', '')
    u'I-40'

    """
    prefix = make_pretty_prefix(prefix or u'')
    suffix = smart_title(suffix or u'').strip()
    street = smart_title(street or u'').strip()
    assert street
    if prefix == u'I':
        # Special case to avoid "I- 40", the standard is apparently "I-40"
        prefix = u''
        street = u'I-%s' % street
    street_name = u' '.join((prefix, street, suffix)).strip()
    return street_name

def make_block_number(left_from_num, left_to_num, right_from_num, right_to_num):
    """
    Given 4 numbers (left low, left high, right low, right high),
    returns a string indicating the range of lowest to highest.
    "lowest" and "highest" are derived as per the make_block_numbers() function.

    >>> make_block_number(1, 9, 2, 3)
    u'1-9'
    >>> make_block_number(1, 1, 1, 1)
    u'1'
    >>> make_block_number(9, 8, 7, 6)
    u'6-9'

    Zero is not considered part of a range:
    >>> make_block_number(0, 1, 2, 3)
    u'1-3'

    None is ignored, but one non-zero number must be provided:
    >>> make_block_number(None, None, 1, None)
    u'1'
    >>> make_block_number(None, None, None, None)
    Traceback (most recent call last):
    ...
    ValueError: No non-None addresses provided
    >>> make_block_number(0, 0, 0, 0)
    Traceback (most recent call last):
    ...
    ValueError: No non-zero numeric addresses provided in [0, 0, 0, 0]

    """
    lo_num, hi_num = make_block_numbers(left_from_num, left_to_num,
                                        right_from_num, right_to_num)
    if lo_num == hi_num:
        number = unicode(lo_num)
    elif lo_num and not hi_num:
        number = unicode(lo_num)
    elif hi_num and not lo_num:
        number = unicode(hi_num)
    else:
        number = u'%s-%s' % (lo_num, hi_num)
    return number

def make_block_numbers(left_from_num, left_to_num, right_from_num, right_to_num):
    """
    Given four numbers, or strings containing numbers, returns the min
    and max as a pair.

    Because the input is possibly messy and quirky, there are some
    subtleties in what's considered the min and max, see below.  In
    all cases, the motivation is to assume that the input is spelled
    correctly for human reading, no matter how unlikely; but for
    sorting we assume we want a single non-negative number.

    >>> make_block_numbers(10,9,8,7)
    (7, 10)

    >>> make_block_numbers(1,1,1,1)
    (1, 1)

    The first quirk is that zero is ignored:
    >>> make_block_numbers(0,1,2,3)
    (1, 3)

    Another quirk is that negative numbers are compared as if positive:
    >>> make_block_numbers(1000, 0, -9999, 0)
    (1000, -9999)

    None is ignored, but at least one number must be provided:

    >>> make_block_numbers(None, None, None, None)
    Traceback (most recent call last):
    ...
    ValueError: No non-None addresses provided

    >>> make_block_numbers(None, None, None, 1)
    (1, 1)

    Handles strings that look like integers too. Note that they
    are returned unchanged:

    >>> make_block_numbers('1000', '0', u'9999', u'')
    ('1000', u'9999')

    It also, *for sorting purposes*, tries to ignore any non-numeric
    characters, and if one looks like an address range (like "10-20"),
    it compares only the absolute value of the first numeric part -
    but again, returns them unchanged.  For example, this sorts them
    as if they were 99 and 33 respectively:

    >>> make_block_numbers('blah 99 blah', '33-44-55', '', '')
    ('33-44-55', 'blah 99 blah')

    This also sorts them as if they were 33 and 99 (not -99):

    >>> make_block_numbers('33-44-55', '-99-123', '', '')
    ('33-44-55', '-99-123')

    >>> make_block_numbers('a', 'b', 'c', 'd')
    Traceback (most recent call last):
    ...
    ValueError: No non-zero numeric addresses provided in ['a', 'b', 'c', 'd']

    >>> make_block_numbers('a', 'b', 'c', 'd9d')
    ('d9d', 'd9d')
    """
    nums = [x for x in (left_from_num, left_to_num, right_from_num, right_to_num)
            if x not in (None, '', u'')]
    if not nums:
        # This used to raise ValueError, maybe accidentally, because
        # min([]) does so. Preserving that for backward compatibility,
        # not sure if it matters.
        raise ValueError("No non-None addresses provided")
    # Note that we may get passed strings with non-numeric junk.
    # In that case, try to grab out the numbers for sorting.
    sortable = []
    for x in nums:
        if isinstance(x, basestring):
            maybe = re.search('(\d+)', x)
            if maybe:
                sortkey = int(maybe.group(1))
                if sortkey:
                    sortable.append((sortkey, x))
        else:
            if x:
                sortable.append((abs(x), x))
    if sortable:
        sortable.sort()
        return (sortable[0][1], sortable[-1][1])
    else:
        raise ValueError("No non-zero numeric addresses provided in %s" % nums)


def make_pretty_directional(directional):
    """
    Returns a formatted directional.

    e.g.:

        N -> N.
        NW -> N.W.
    """
    return "".join(u"%s." % c for c in directional)

def make_pretty_name(left_from_num, left_to_num, right_from_num, right_to_num,
                     predir, prefix, street, suffix, postdir=None):
    """
    Returns a tuple of (street_pretty_name, block_pretty_name) for the
    given address bits.

    >>> make_pretty_name(1, 29, 2, 30, 'NW', 'STATE RT', '101', 'DRIVE', 'SE')
    (u'State Route 101 Drive', u'1-30 N.W. State Route 101 Drive S.E.')
    """
    prefix_part = make_pretty_prefix(prefix or u'')
    street_name = make_street_pretty_name(prefix_part, street, suffix)
    num_part = make_block_number(left_from_num, left_to_num, right_from_num, right_to_num)
    predir_part = predir and make_pretty_directional(predir) or u''
    postdir_part = postdir and make_pretty_directional(postdir) or u''
    block_name = u'%s %s %s %s' % (num_part, predir_part, street_name, postdir_part)
    block_name = re.sub(u'\s+', u' ', block_name).strip()
    return street_name, block_name

def make_pretty_prefix(prefix):
    """
    >>> make_pretty_prefix('US Hwy')
    u'US Highway'
    >>> make_pretty_prefix('State Rt ')
    u'State Route'
    >>> make_pretty_prefix(' I- ')
    u'I'
    >>> make_pretty_prefix(' Anything Else ')
    u'Anything Else'
    """
    prefix = unicode(prefix).strip()
    if prefix.upper().endswith(u'HWY'):
        return prefix[:-3] + u'Highway'
    if prefix.upper().endswith(u'RT'):
        return prefix[:-2] + u'Route'
    prefix = prefix.strip().strip('-').strip()
    prefix = smart_title(prefix, exceptions=['US'])
    return prefix

def make_dir_street_name(block):
    """
    Returns a street name from a block with the directional included.

    If the block has a ``predir``, the directional is prepended:

        "W. Diversey Ave."

    If the block has a ``postdir``, the directional is appended:

        "18th St. N.W."
    """
    name = make_street_pretty_name(block.prefix, block.street, block.suffix)
    if block.predir:
        name = u"%s %s" % (make_pretty_directional(block.predir), name)
    if block.postdir:
        name = u"%s %s" % (name, make_pretty_directional(block.postdir))
    return name

def pretty_name_from_blocks(block_a, block_b):
    return u"%s & %s" % (make_dir_street_name(block_a), make_dir_street_name(block_b))

def slug_from_blocks(block_a, block_b):
    slug = u"%s-and-%s" % (slugify(make_dir_street_name(block_a)),
                           slugify(make_dir_street_name(block_b)))
    # If it's too long for the slug field, drop the directionals
    if len(slug) > 64:
        slug = u"%s-and-%s" % (
            slugify(make_street_pretty_name(block_a.prefix, block_a.street, block_a.suffix)),
            slugify(make_street_pretty_name(block_b.prefix, block_b.street, block_b.suffix)))
    # If it's still too long, drop the suffixes
    if len(slug) > 64:
        slug = u"%s-and-%s" % (
            slugify(make_street_pretty_name(block_a.prefix, block_a.street, u'')),
            slugify(make_street_pretty_name(block_b.prefix, block_b.street, u'')))

    # If it's *still* too long, drop the prefixes too
    if len(slug) > 64:
        slug = u"%s-and-%s" % (
            slugify(block_a.street),
            slugify(block_b.street),
            )
    slug = slug[:64]
    return slug

########NEW FILE########
__FILENAME__ = tests
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib.gis import geos
from django.test import TestCase
from ebpub.streets.models import Block, Place, PlaceSynonym, PlaceType
from ebpub.accounts.models import User
from ebpub.accounts.utils import test_client_login
from StringIO import StringIO
import mock
import csv

class TestPlaces(TestCase):
    
    import_url = '/admin/streets/place/import/csv'
    export_url = '/admin/streets/place/export/csv'
    
    fixtures = ['wabash.yaml']
    
    def setUp(self):
        # create a superuser to access admin views
        User.objects.create_superuser('admin@example.org', password='123')

    def test_import_csv(self):
        """
        test importing a csv full of places with no errors
        """
        
        self.assertEqual(Place.objects.all().count(), 0)
        assert test_client_login(self.client, username='admin@example.org', password='123') == True

        csv_file = StringIO("Donut Mountain,123 Fakey St.,1.0,2.0\nDonut House,124 Fakey St.,1.001,2.001")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        
        self.assertEqual(Place.objects.all().count(), 2)
        
        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)
        
        place = Place.objects.get(normalized_name='DONUT HOUSE')
        self.assertEqual(place.address, '124 Fakey St.')
        self.assertEqual(place.location.x, 2.001)
        self.assertEqual(place.location.y, 1.001)
        
    def test_import_csv_synonyms(self):
        """
        test importing synonyms
        """
        self.assertEqual(Place.objects.all().count(), 0)
        assert test_client_login(self.client, username='admin@example.org', password='123') == True

        csv_file = StringIO("Donut Mountain,123 Fakey St.,1.0,2.0,,Big Dough, Dough Mo\nDonut House,124 Fakey St.,1.001,2.001,,House of D, D House")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        
        self.assertEqual(Place.objects.all().count(), 2)
        
        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)
        
        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'BIG DOUGH' in synonyms
        assert 'DOUGH MO' in synonyms

                
        place = Place.objects.get(normalized_name='DONUT HOUSE')
        self.assertEqual(place.address, '124 Fakey St.')
        self.assertEqual(place.location.x, 2.001)
        self.assertEqual(place.location.y, 1.001)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'D HOUSE' in synonyms
        assert 'HOUSE OF D' in synonyms

    def test_import_csv_synonym_change(self):
        """
        test changing synonyms via import
        """

        self.assertEqual(Place.objects.all().count(), 0)
        assert test_client_login(self.client, username='admin@example.org', password='123') == True

        csv_file = StringIO("Donut Mountain,123 Fakey St.,1.0,2.0,,Big Dough, Dough Mo\nDonut House,124 Fakey St.,1.001,2.001,,House of D, D House")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        
        self.assertEqual(Place.objects.all().count(), 2)
        
        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)
        
        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'BIG DOUGH' in synonyms
        assert 'DOUGH MO' in synonyms

                
        place = Place.objects.get(normalized_name='DONUT HOUSE')
        self.assertEqual(place.address, '124 Fakey St.')
        self.assertEqual(place.location.x, 2.001)
        self.assertEqual(place.location.y, 1.001)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'D HOUSE' in synonyms
        assert 'HOUSE OF D' in synonyms

        # now change one synonym of each
        csv_file = StringIO("Donut Mountain,123 Fakey St.,1.0,2.0,,Ole Doughy, Dough Mo\nDonut House,124 Fakey St.,1.001,2.001,,Dunky H, D House")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        
        self.assertEqual(Place.objects.all().count(), 2)
        
        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)
        
        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'OLE DOUGHY' in synonyms
        assert 'DOUGH MO' in synonyms

                
        place = Place.objects.get(normalized_name='DONUT HOUSE')
        self.assertEqual(place.address, '124 Fakey St.')
        self.assertEqual(place.location.x, 2.001)
        self.assertEqual(place.location.y, 1.001)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'DUNKY H' in synonyms
        assert 'D HOUSE' in synonyms
        


    def test_import_csv_no_location(self):
        """
        tests locationless places are not imported.
        """
        self.assertEqual(Place.objects.all().count(), 0)
        assert test_client_login(self.client, username='admin@example.org', password='123') == True

        csv_file = StringIO("Donut Mountain,123 Fakey St.,1.0,2.0\nFlapper Jacks,,,,\nDonut House,124 Fakey St.,1.001,2.001\nSoup Sacks,,,")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        
        self.assertEqual(Place.objects.all().count(), 2)
        
        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)
                
        place = Place.objects.get(normalized_name='DONUT HOUSE')
        self.assertEqual(place.address, '124 Fakey St.')
        self.assertEqual(place.location.x, 2.001)
        self.assertEqual(place.location.y, 1.001)

    @mock.patch('ebpub.streets.models.get_metro')
    def test_import_csv_geocoding(self, mock_get_metro):
        """
        tests importing some locations with only 
        addresses specified
        """
        mock_get_metro.return_value = {'city_name': 'CHICAGO',
                                       'multiple_cities': False}

        self.assertEqual(Place.objects.all().count(), 0)
        self.assertEqual(True,
                         test_client_login(self.client, username='admin@example.org', password='123'))

        csv_file = StringIO("Donut Arms Hotel, 205 South Wabash St.,,")
        csv_file.name = 'test.csv'

        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        self.assertEqual(Place.objects.all().count(), 1)

        place = Place.objects.get(normalized_name='DONUT ARMS HOTEL')
        self.assertEqual(place.address, '205 South Wabash St.')
        self.assertAlmostEqual(place.location.x, -87.626153836734701, places=4)
        self.assertAlmostEqual(place.location.y, 41.879488336734696, places=4)

    @mock.patch('ebpub.streets.models.get_metro')    
    def test_import_csv_lat_lon_priority(self, mock_get_metro):
        """
        tests importing locations prioritizes 
        lat lon over address geocoding.
        """
        mock_get_metro.return_value = {'city_name': 'CHICAGO',
                                       'multiple_cities': False}

        self.assertEqual(Place.objects.all().count(), 0)
        assert test_client_login(self.client, username='admin@example.org', password='123') == True

        csv_file = StringIO("Donut Arms Hotel, 205 South Wabash St.,1.0,2.0")
        csv_file.name = 'test.csv'

        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        
        self.assertEqual(Place.objects.all().count(), 1)
        
        place = Place.objects.get(normalized_name='DONUT ARMS HOTEL')
        self.assertEqual(place.address, '205 South Wabash St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)


    def test_import_csv_changes_place_types(self):
        """
        test importing a place that changes a placetype
        """
        self.assertEqual(Place.objects.all().count(), 0)
        assert test_client_login(self.client, username='admin@example.org', password='123') == True

        csv_file = StringIO("Donut Mountain,123 Fakey St.,1.0,2.0")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        
        self.assertEqual(Place.objects.all().count(), 1)
        
        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)
        self.assertEqual(place.place_type.id, 1)

        new_type = PlaceType(name='ZZZZ', plural_name='ZZZZs', 
                             indefinite_article='a', slug='funhouse',
                             is_geocodable=False, is_mappable=True)
        new_type.save()
        
        csv_file = StringIO("Donut Mountain,123 Fakey St.,1.0,2.0")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '%d' % new_type.id, 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        
        self.assertEqual(Place.objects.all().count(), 1)
        
        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)
        self.assertEqual(place.place_type.id, new_type.id)

    def test_export_csv(self):
        """
        test exporting a place type as csv
        """
        assert test_client_login(self.client, username='admin@example.org', password='123') == True
        
        place_type = PlaceType.objects.get(slug='poi')
        place = Place(pretty_name='Donut Palace', place_type=place_type,
                      address='100 Bubble Street', location=geos.Point(1.0, 2.0))
        place.save()
        place = Place(pretty_name='Donut Sanctuary', place_type=place_type,
                      address='101 Bubble Street', location=geos.Point(3.0, 4.0),
                      url='http://www.example.org/bs')
        place.save()

        
        response = self.client.post(self.export_url, {'place_type': place_type.id})
        assert response.status_code == 200
        
        rows = csv.reader(StringIO(response.content))
        
        count = 0
        for row in rows:
            self.assertEqual(len(row), 5)
            if row[0] == 'Donut Palace':
                self.assertEqual(row[1], '100 Bubble Street')
                self.assertEqual(row[2], '2.0')
                self.assertEqual(row[3], '1.0')
                self.assertEqual(row[4], '')
            elif row[0] == 'Donut Sanctuary':
                self.assertEqual(row[1], '101 Bubble Street')
                self.assertEqual(row[2], '4.0')
                self.assertEqual(row[3], '3.0')
                self.assertEqual(row[4], 'http://www.example.org/bs')
            else: 
                self.fail('Unexpected Place! %s' % row[0])
            count += 1

        self.assertEqual(count, 2)


    def test_export_csv_synonyms(self):
        """
        test exporting a place with synonyms
        """
        assert test_client_login(self.client, username='admin@example.org', password='123') == True
        
        place_type = PlaceType.objects.get(slug='poi')
        place = Place(pretty_name='Donut Palace', place_type=place_type,
                      address='100 Bubble Street', location=geos.Point(1.0, 2.0))
        place.save()
        ps = PlaceSynonym(pretty_name='Donut Hole', place=place)
        ps.save()
        ps = PlaceSynonym(pretty_name='Donut Pally', place=place)
        ps.save()
        
    
        place = Place(pretty_name='Donut Sanctuary', place_type=place_type,
                      address='101 Bubble Street', location=geos.Point(3.0, 4.0),
                      url='http://www.example.org/bs')
        place.save()
        ps = PlaceSynonym(pretty_name='Sancy D', place=place)
        ps.save()
        ps = PlaceSynonym(pretty_name='D Sanc', place=place)
        ps.save()
        
        response = self.client.post(self.export_url, {'place_type': place_type.id})
        self.assertEqual(response.status_code, 200)
        
        rows = csv.reader(StringIO(response.content))
        
        count = 0
        for row in rows:
            self.assertEqual(len(row), 7)
            synonyms = set(row[5:])
            if row[0] == 'Donut Palace':
                self.assertEqual(row[1], '100 Bubble Street')
                self.assertEqual(row[2], '2.0')
                self.assertEqual(row[3], '1.0')
                self.assertEqual(row[4], '')
                assert 'Donut Hole' in synonyms
                assert 'Donut Pally' in synonyms
            elif row[0] == 'Donut Sanctuary':
                self.assertEqual(row[1], '101 Bubble Street')
                self.assertEqual(row[2], '4.0')
                self.assertEqual(row[3], '3.0')
                self.assertEqual(row[4], 'http://www.example.org/bs')
                assert 'Sancy D' in synonyms
                assert 'D Sanc' in synonyms
            else: 
                self.fail('Unexpected Place!' % row[0])
            count += 1

        self.assertEqual(count, 2)


    def test_import_export(self):
        """
        tests that the results of an export can be imported
        """
        self.assertEqual(Place.objects.all().count(), 0)
        assert test_client_login(self.client, username='admin@example.org', password='123') == True

        csv_file = StringIO("Donut Mountain,123 Fakey St.,1.0,2.0\nFlapper Jacks,,,,\nDonut House,124 Fakey St.,1.001,2.001,http://www.example.org/bs\nSoup Sacks,,,")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        self.assertEqual(Place.objects.all().count(), 2)

        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)

        place = Place.objects.get(normalized_name='DONUT HOUSE')
        self.assertEqual(place.address, '124 Fakey St.')
        self.assertEqual(place.location.x, 2.001)
        self.assertEqual(place.location.y, 1.001)
        self.assertEqual(place.url, 'http://www.example.org/bs')

        response = self.client.post(self.export_url, {'place_type': place.place_type.id})
        self.assertEqual(response.status_code, 200)

        Place.objects.all().delete()
        self.assertEqual(Place.objects.all().count(), 0)

        csv_file = StringIO(response.content)
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)

        self.assertEqual(Place.objects.all().count(), 2)

        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)

        place = Place.objects.get(normalized_name='DONUT HOUSE')
        self.assertEqual(place.address, '124 Fakey St.')
        self.assertEqual(place.location.x, 2.001)
        self.assertEqual(place.location.y, 1.001)
        self.assertEqual(place.url, 'http://www.example.org/bs')


    def test_import_export_synonyms(self):
        """
        tests that the results of an export can be imported
        including synonyms
        """

        self.assertEqual(Place.objects.all().count(), 0)
        assert test_client_login(self.client, username='admin@example.org', password='123') == True


        csv_file = StringIO("Donut Mountain,123 Fakey St.,1.0,2.0,,Big Dough, Dough Mo\nDonut House,124 Fakey St.,1.001,2.001,http://www.example.org/bs,House of D, D House")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)

        self.assertEqual(Place.objects.all().count(), 2)

        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'BIG DOUGH' in synonyms
        assert 'DOUGH MO' in synonyms

        place = Place.objects.get(normalized_name='DONUT HOUSE')
        self.assertEqual(place.address, '124 Fakey St.')
        self.assertEqual(place.location.x, 2.001)
        self.assertEqual(place.location.y, 1.001)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'D HOUSE' in synonyms
        assert 'HOUSE OF D' in synonyms

        response = self.client.post(self.export_url, {'place_type': place.place_type.id})
        self.assertEqual(response.status_code, 200)

        Place.objects.all().delete()
        self.assertEqual(Place.objects.all().count(), 0)

        csv_file = StringIO(response.content)
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)

        self.assertEqual(Place.objects.all().count(), 2)

        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'BIG DOUGH' in synonyms
        assert 'DOUGH MO' in synonyms

        place = Place.objects.get(normalized_name='DONUT HOUSE')
        self.assertEqual(place.address, '124 Fakey St.')
        self.assertEqual(place.location.x, 2.001)
        self.assertEqual(place.location.y, 1.001)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'D HOUSE' in synonyms
        assert 'HOUSE OF D' in synonyms


    def test_import_same_name(self):
        """
        tests that the importer can handle places with the same name.
        """

        self.assertEqual(Place.objects.all().count(), 0)
        assert test_client_login(self.client, username='admin@example.org', password='123') == True

        csv_file = StringIO("Donut Mountain,123 Fakey St.,1.0,2.0,http://www.example.org/bs/0\nDonut Mountain,99 Fakley St.,99.0,22.0,http://www.example.org/bs/1")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        self.assertEqual(Place.objects.all().count(), 2)

        locs = []
        for place in Place.objects.filter(normalized_name='DONUT MOUNTAIN').all():
            locs.append((place.address, place.location.x, place.location.y, place.url))

        assert ('123 Fakey St.', 2.0, 1.0, 'http://www.example.org/bs/0') in locs
        assert ('99 Fakley St.', 22.0, 99.0, 'http://www.example.org/bs/1') in locs


    def test_import_same_name_synonym(self):
        """
        tests that the importer can handle places with the same name.
        and maintain separate synonym lists.
        """

        self.assertEqual(Place.objects.all().count(), 0)
        assert test_client_login(self.client, username='admin@example.org', password='123') == True

        csv_file = StringIO("Donut Mountain,123 Fakey St.,1.0,2.0,http://www.example.org/bs/0,123 D House, Mount D\nDonut Mountain,99 Fakley St.,99.0,22.0,http://www.example.org/bs/1,99 D House, Mount D")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)

        self.assertEqual(Place.objects.all().count(), 2)

        locs = []
        for place in Place.objects.filter(normalized_name='DONUT MOUNTAIN').all():
            synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
            ll = [place.address, place.location.x, place.location.y, place.url]
            ll.extend(sorted(synonyms))
            locs.append(tuple(ll))

        assert ('123 Fakey St.', 2.0, 1.0, 'http://www.example.org/bs/0', '123 D HOUSE', 'MOUNT D') in locs
        assert ('99 Fakley St.', 22.0, 99.0, 'http://www.example.org/bs/1', '99 D HOUSE', 'MOUNT D') in locs



    def test_import_update_synonyms(self):
        """
        tests that the results of an export can be re-imported'
        to modify things, and no duplicates are formed.
        """

        self.assertEqual(Place.objects.all().count(), 0)
        assert test_client_login(self.client, username='admin@example.org', password='123') == True

        csv_file = StringIO("Donut Mountain,123 Fakey St.,1.0,2.0,,Big Dough, Dough Mo\nDonut House,124 Fakey St.,1.001,2.001,http://www.example.org/bs,House of D, D House")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)

        self.assertEqual(Place.objects.all().count(), 2)

        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        assert len(synonyms) == 2
        assert 'BIG DOUGH' in synonyms
        assert 'DOUGH MO' in synonyms


        place = Place.objects.get(normalized_name='DONUT HOUSE')
        self.assertEqual(place.address, '124 Fakey St.')
        self.assertEqual(place.location.x, 2.001)
        self.assertEqual(place.location.y, 1.001)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'D HOUSE' in synonyms
        assert 'HOUSE OF D' in synonyms

        # re-import
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        self.assertEqual(Place.objects.all().count(), 2)

        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '123 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'BIG DOUGH' in synonyms
        assert 'DOUGH MO' in synonyms

        place = Place.objects.get(normalized_name='DONUT HOUSE')
        self.assertEqual(place.address, '124 Fakey St.')
        self.assertEqual(place.location.x, 2.001)
        self.assertEqual(place.location.y, 1.001)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'D HOUSE' in synonyms
        assert 'HOUSE OF D' in synonyms

        # re-import change an address slightly, change synonyms
        csv_file = StringIO("Donut Mountain,121 Fakey St.,1.0,2.0,,Big Doughy, Dough Mo\nDonut House,124 Fakey St.,1.001,2.001,http://www.example.org/bs, D House,Meye Donuts")
        csv_file.name = 'test.csv'
        response = self.client.post(self.import_url, {'place_type': '1', 'csv_file': csv_file})
        self.assertEqual(response.status_code, 200)
        self.assertEqual(Place.objects.all().count(), 2)

        place = Place.objects.get(normalized_name='DONUT MOUNTAIN')
        self.assertEqual(place.address, '121 Fakey St.')
        self.assertEqual(place.location.x, 2.0)
        self.assertEqual(place.location.y, 1.0)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'BIG DOUGHY' in synonyms
        assert 'DOUGH MO' in synonyms

        place = Place.objects.get(normalized_name='DONUT HOUSE')
        self.assertEqual(place.address, '124 Fakey St.')
        self.assertEqual(place.location.x, 2.001)
        self.assertEqual(place.location.y, 1.001)

        synonyms = set([x.normalized_name for x in PlaceSynonym.objects.filter(place=place).all()])
        self.assertEqual(len(synonyms), 2)
        assert 'D HOUSE' in synonyms
        assert 'HOUSE OF D' not in synonyms
        assert 'MEYE DONUTS' in synonyms


class TestBlocks(TestCase):

    fixtures = ['wabash.yaml']
    urls = 'ebpub.urls'

    def test_contains_number__no_numbers(self):
        block = Block.objects.get(street='WABASH', pk=1002)
        for i in range(16):
            i = i ** i
            self.assertEqual(block.contains_number(i),
                             (False, None, None))


    def test_contains_number__no_left_or_right(self):
        block = Block.objects.get(street='WABASH', from_num=200, to_num=298)
        self.assertEqual(block.contains_number(200),
                         (True, 200, 298))
        self.assertEqual(block.contains_number(201),
                         (True, 200, 298))
        self.assertEqual(block.contains_number(298),
                         (True, 200, 298))
        self.assertEqual(block.contains_number(299),
                         (False, 200, 298))
        self.assertEqual(block.contains_number(199),
                         (False, 200, 298))

    def test_contains_number__left_and_righ(self):
        block = Block.objects.get(street='WABASH',
                                  left_from_num=216, left_to_num=298,
                                  right_from_num=217, right_to_num=299,
                                  )
        self.assertEqual(block.contains_number(214),
                         (False, 216, 298))
        self.assertEqual(block.contains_number(215),
                         (False, 217, 299))
        self.assertEqual(block.contains_number(216),
                         (True, 216, 298))
        self.assertEqual(block.contains_number(217),
                         (True, 217, 299))
        self.assertEqual(block.contains_number(298),
                         (True, 216, 298))
        self.assertEqual(block.contains_number(299),
                         (True, 217, 299))
        self.assertEqual(block.contains_number(300),
                         (False, 216, 298))

    def test_block__street_url(self):
        # TODO: these tests depend on get_metro()['multiple_cities'] setting
        block = Block.objects.get(street='WABASH',
                                  left_from_num=216, left_to_num=298,
                                  right_from_num=217, right_to_num=299,
                                  )
        self.assertEqual(block.street_url(), '/streets/wabash-ave/')

    def test_block__rss_url(self):
        block = Block.objects.get(street='WABASH',
                                  left_from_num=216, left_to_num=298,
                                  right_from_num=217, right_to_num=299,
                                  )
        self.assertEqual(block.rss_url(), '/rss/streets/wabash-ave/216-299n-s/')


    def test_block__alert_url(self):
        block = Block.objects.get(street='WABASH',
                                  left_from_num=216, left_to_num=298,
                                  right_from_num=217, right_to_num=299,
                                  )
        self.assertEqual(block.alert_url(), '/streets/wabash-ave/216-299n-s/alerts/')


    def test_block__url(self):
        block = Block.objects.get(street='WABASH',
                                  left_from_num=216, left_to_num=298,
                                  right_from_num=217, right_to_num=299,
                                  )
        self.assertEqual(block.url(), '/streets/wabash-ave/216-299n-s/')

########NEW FILE########
__FILENAME__ = utils
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

# This is just preserved here for backward compatibility.
from ebpub.geocoder.base import full_geocode

########NEW FILE########
__FILENAME__ = urls
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from django.conf.urls.defaults import patterns, url, include, handler404, handler500
from ebpub.alerts import views as alert_views
from ebpub.db import feeds, views
from ebpub.db.constants import BLOCK_URL_REGEX
from ebpub.petitions import views as petition_views
from ebpub.metros.allmetros import get_metro


if settings.DEBUG:
    # URLs for the various static files we need to serve for development.
    import olwidget
    import os
    olwidget_media_path=os.path.join(
        os.path.abspath(os.path.dirname(olwidget.__file__)), 'static')

    urlpatterns = patterns('',
        (r'^(?P<path>(?:olwidget).*)$',
         'django.views.static.serve',
         {'document_root': olwidget_media_path}),

        (r'^(?:%s)(?P<path>.*)$' % settings.DJANGO_STATIC_NAME_PREFIX.strip('/'),
         'django.views.static.serve',
         {'document_root': settings.DJANGO_STATIC_SAVE_PREFIX}),

        (r'^(?:%s)(?P<path>.*)$' % settings.MEDIA_URL.lstrip('/'),
         'django.views.static.serve',
          {'document_root': settings.MEDIA_ROOT}),

        (r'^(?:%s)(?P<path>(?:images|scripts|styles|openlayers).*)$' % (settings.STATIC_URL or '').lstrip('/'),
         'django.views.static.serve',
         {'document_root': settings.STATIC_ROOT}),

    )
else:
    urlpatterns = patterns('')

urlpatterns += patterns('',
    url(r'^$', views.homepage, name="ebpub-homepage"),
    url(r'^search/$', views.search, name='ebpub-search'),
    (r'^news/$', views.schema_list),
    url(r'^locations/$', views.location_type_list, name='ebpub-loc-type-list'),
    url(r'^locations/([-_a-z0-9]{1,32})/$', views.location_type_detail, name='ebpub-loc-type-detail'),
    url(r'^locations/([-_a-z0-9]{1,32})/([-_a-z0-9]{1,32})/$', views.place_detail_timeline, {'place_type': 'location', 'show_upcoming': False}, name="ebpub-location-recent"),
    url(r'^locations/([-_a-z0-9]{1,32})/([-_a-z0-9]{1,32})/upcoming/$', views.place_detail_timeline, {'place_type': 'location', 'show_upcoming': True}, name="ebpub-location-upcoming"),
    url(r'^locations/([-_a-z0-9]{1,32})/([-_a-z0-9]{1,32})/overview/$', views.place_detail_overview, {'place_type': 'location'}, name="ebpub-location-overview"),
    url(r'^locations/([-_a-z0-9]{1,32})/([-_a-z0-9]{1,32})/feeds/$', views.feed_signup, {'place_type': 'location'}, name='ebpub-feed-signup'),
    url(r'^locations/([-_a-z0-9]{1,32})/([-_a-z0-9]{1,32})/alerts/$', alert_views.signup, {'place_type': 'location'}, name='ebpub-location-alerts'),
    (r'^locations/([-a-z0-9]{1,32})/([-a-z0-9]{1,32})/place.kml$', views.place_kml, {'place_type': 'location'}),

    url(r'^rss/locations/([-a-z0-9]{1,32})/([-a-z0-9]{1,32})/$', feeds.LocationFeed(), name='ebpub-location-rss'),

    (r'^accounts/apikeys/', include('ebpub.openblockapi.apikey.urls')),

    (r'^accounts/', include('ebpub.accounts.urls')),

    (r'^alerts/unsubscribe/(\d{1,10})/$', alert_views.unsubscribe),
    (r'^petitions/([-\w]{4,32})/$', petition_views.form_view, {'is_schema': False}),
    (r'^petitions/([-\w]{4,32})/thanks/$', petition_views.form_thanks, {'is_schema': False}),
    url(r'^place-lookup-chart/$', views.ajax_place_lookup_chart, name='ajax-place-lookup-chart'),
    url(r'^place-date-chart/$', views.ajax_place_date_chart, name='ajax-place-date-chart'),
    url(r'^newsitems.geojson/$', views.newsitems_geojson, name='ajax-newsitems-geojson'),
    (r'^api/dev1/', include('ebpub.openblockapi.urls')),
    (r'^widgets/', include('ebpub.widgets.urls')),
    (r'^maps/', include('ebpub.richmaps.urls')),
    (r'^neighbornews/', include('ebpub.neighbornews.urls')),
    (r'^moderation/', include('ebpub.moderation.urls')),
    (r'^comments/', include('django.contrib.comments.urls')),
)

if get_metro()['multiple_cities']:
    # multi-city block patterns.
    urlpatterns += patterns(
        '',
        url(r'^streets/$', views.city_list, name='ebpub-city-list'),
        # optionally accept city slug below. this allows for a no arg
        # ebpub-street-list call to return the street list for single city and
        # city list for multi city setups. this way the templates can call
        # {% url ebpub-street-list %} without having to worry about single/multi
        # city configurations
        url(r'^streets/(?:([-a-z]{3,40})/)?$', views.street_list,
            name='ebpub-street-list'),
        url(r'^streets/([-a-z]{3,40})/([-a-z0-9]{1,64})/$', views.block_list,
            name='ebpub-block-list'),
        url(r'^streets/([-a-z]{3,40})/([-a-z0-9]{1,64})/%s/$' % BLOCK_URL_REGEX,
            views.place_detail_timeline, {'place_type': 'block', 'show_upcoming': False},
            name='ebpub-block-recent'),
        url(r'^streets/([-a-z]{3,40})/([-a-z0-9]{1,64})/%s/upcoming/$' % BLOCK_URL_REGEX,
            views.place_detail_timeline, {'place_type': 'block', 'show_upcoming': True},
            name='ebpub-block-upcoming'),
        url(r'^streets/([-a-z]{3,40})/([-a-z0-9]{1,64})/%s/overview/$' % BLOCK_URL_REGEX,
            views.place_detail_overview, {'place_type': 'block'},
            name='ebpub-block-overview'),
        url(r'^streets/([-a-z]{3,40})/([-a-z0-9]{1,64})/%s/feeds/$' % BLOCK_URL_REGEX,
            views.feed_signup, {'place_type': 'block'},
            name='ebpub-block-feed-signup'),
        url(r'^streets/([-a-z]{3,40})/([-a-z0-9]{1,64})/%s/alerts/$' % BLOCK_URL_REGEX,
            alert_views.signup, {'place_type': 'block'},
            name='ebpub-block-alerts-signup'),
        url(r'^rss/streets/([-a-z]{3,40})/([-a-z0-9]{1,64})/%s/$' % BLOCK_URL_REGEX,
            feeds.BlockFeed(),
            name='ebpub-block-rss'),
        )
else:
    # single-city block patterns.
    urlpatterns += patterns(
        '',
        url(r'^streets/$', views.street_list,
            name='ebpub-street-list'),
        url(r'^streets/(\w{0})([-a-z0-9]{1,64})/$', views.block_list,
            name='ebpub-block-list'),
        url(r'^streets/(\w{0})([-a-z0-9]{1,64})/%s/$' % BLOCK_URL_REGEX,
            views.place_detail_timeline, {'place_type': 'block'},
            name='ebpub-block-recent'),
        url(r'^streets/(\w{0})([-a-z0-9]{1,64})/%s/upcoming/$' % BLOCK_URL_REGEX,
            views.place_detail_timeline, {'place_type': 'block', 'show_upcoming': True},
            name='ebpub-block-upcoming'),
        url(r'^streets/(\w{0})([-a-z0-9]{1,64})/%s/overview/$' % BLOCK_URL_REGEX,
            views.place_detail_overview, {'place_type': 'block'},
            name='ebpub-block-overview'),
        url(r'^streets/(\w{0})([-a-z0-9]{1,64})/%s/feeds/$' % BLOCK_URL_REGEX,
            views.feed_signup, {'place_type': 'block'},
            name='ebpub-block-feed-signup'),
        url(r'^streets/(\w{0})([-a-z0-9]{1,64})/%s/alerts/$' % BLOCK_URL_REGEX,
            alert_views.signup, {'place_type': 'block'},
            name='ebpub-block-alerts-signup'),
        url(r'^rss/streets/(\w{0})([-a-z0-9]{1,64})/%s/$' % BLOCK_URL_REGEX,
            feeds.BlockFeed(), name='ebpub-block-rss'),
        )


urlpatterns += patterns(
    '',
    url(r'^([-\w]{4,32})/schema/$', views.schema_detail, name='ebpub-schema-detail'),
    (r'^([-\w]{4,32})/search/$', views.search),
    (r'^([-\w]{4,32})/petition/$', petition_views.form_view, {'is_schema': True}),
    (r'^([-\w]{4,32})/petition/thanks/$', petition_views.form_thanks, {'is_schema': True}),
    url(r'^([-\w]{4,32})/detail/(\d{1,8})/$', views.newsitem_detail, name='ebpub-newsitem-detail'),
    url(r'^([-\w]{4,32})/filter_json/$', views.schema_filter_geojson,
        name='ebpub-schema-filter-geojson'),

    # Redirect from the old 'filter' url.
    # url(r'^([-\w]{4,32})/filter/$', views.schema_filter,  # XXX redirect
    #     name='ebpub-schema-filter'),
    url(r'^([-\w]{4,32})/$', views.schema_filter,
        name='ebpub-schema-filter'),

)

########NEW FILE########
__FILENAME__ = bunch
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

import math

# From http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/425044
def bunch(lst, size):
    """Regroups a list into bunches of a given size.

    >>> bunch([1, 2, 3, 4], 2)
    [[1, 2], [3, 4]]
    """
    size = int(size)
    return [lst[i:i+size] for i in range(0, len(lst), size)]

def bunchlong(lst, size):
    """Like bunch(), but size is given as a divisor of the total list
    length.

    >>> bunchlong([1, 2, 3, 4], 1)
    [[1, 2, 3, 4]]
    >>> bunchlong([1, 2, 3, 4], 2)
    [[1, 2], [3, 4]]
    >>> bunchlong([1, 2, 3, 4], 3)
    [[1, 2], [3, 4]]
    >>> bunchlong([1, 2, 3, 4], 4)
    [[1], [2], [3], [4]]
    >>> bunchlong([1, 2, 3, 4], 999)
    [[1], [2], [3], [4]]

    """
    size = float(int(size))
    return bunch(lst, int(math.ceil(len(lst) / size)))

def stride(lst, size):
    """
    Like bunch(), but alternates lists when placing items, so every
    Nth item goes into the first list, etc.

    >>> stride([1, 2, 3, 4, 5, 6], 2)
    [[1, 3, 5], [2, 4, 6]]
    >>> stride([1, 2, 3, 4, 5], 2)
    [[1, 3, 5], [2, 4]]
    >>> stride([1, 2, 3, 4, 5], 1)
    [[1, 2, 3, 4, 5]]
    >>> stride([1, 2, 3, 4, 5, 6], 3)
    [[1, 4], [2, 5], [3, 6]]
    >>> stride([1, 2, 3, 4, 5, 6, 7], 3)
    [[1, 4, 7], [2, 5], [3, 6]]
    """
    size = int(size)
    return [lst[i::size] for i in range(size)]

if __name__ == "__main__":
    import doctest
    doctest.testmod()

########NEW FILE########
__FILENAME__ = dates
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

import datetime
import time


def today():
    from django.conf import settings
    if settings.EB_TODAY_OVERRIDE:
        return settings.EB_TODAY_OVERRIDE
    return datetime.date.today()

def now():
    from django.conf import settings
    if getattr(settings, 'EB_NOW_OVERRIDE', None):
        return settings.EB_NOW_OVERRIDE
    return datetime.datetime.now()


def daterange(d1, d2):
    "Iterator that returns every date between d1 and d2, inclusive."
    current = d1
    while current <= d2:
        yield current
        current += datetime.timedelta(days=1)

def parse_date(value, format, return_datetime=False):
    """
    Equivalent to time.strptime, but it returns a datetime.date or
    datetime.datetime object instead of a struct_time object.

    If you pass a date or datetime instance, you get it back.

    Returns None if the value evaluates to False.

    >>> parse_date(None, '')
    >>> parse_date('', '')
    >>> parse_date('2000', '%Y')
    datetime.date(2000, 1, 1)
    >>> parse_date('2000', '%Y', True) # doctest: +ELLIPSIS
    datetime.datetime(2000, 1, 1, 0, 0, 0, ...)
    >>> parse_date(datetime.date(2000, 1, 1), '%Y')
    datetime.date(2000, 1, 1)

    """
    # See http://docs.python.org/library/time.html#time.strftime
    idx = return_datetime and 7 or 3
    func = return_datetime and datetime.datetime or datetime.date
    if isinstance(value, func):
        return value
    if value:
        return func(*time.strptime(value, format)[:idx])
    return None

def parse_time(value, format):
    """
    Equivalent to time.strptime, but it returns a datetime.time object.

    >>> parse_time('23:59:01', '%H:%M:%S')
    datetime.time(23, 59, 1)
    """
    return datetime.time(*time.strptime(value, format)[3:6])

########NEW FILE########
__FILENAME__ = django_testcase_backports
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

# Copyright (c) Django Software Foundation and individual contributors.
# All rights reserved.

# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:

#     1. Redistributions of source code must retain the above copyright notice, 
#        this list of conditions and the following disclaimer.

#     2. Redistributions in binary form must reproduce the above copyright 
#        notice, this list of conditions and the following disclaimer in the
#        documentation and/or other materials provided with the distribution.

#     3. Neither the name of Django nor the names of its contributors may be used
#        to endorse or promote products derived from this software without
#        specific prior written permission.

# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
# ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
# ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""
Backports of new test features from Django 1.4 (dev).
This can go away once we're using Django 1.4.
"""

from django.conf import settings
from django.conf import UserSettingsHolder
from django.utils.functional import wraps
from django.dispatch import Signal

setting_changed = Signal(providing_args=["setting", "value"])

class OverrideSettingsHolder(UserSettingsHolder):
    """
    A custom setting holder that sends a signal upon change.
    """
    def __setattr__(self, name, value):
        UserSettingsHolder.__setattr__(self, name, value)
        setting_changed.send(sender=name, setting=name, value=value)

class override_settings(object):
    """
    Acts as either a decorator, or a context manager. If it's a decorator it
    takes a function and returns a wrapped function. If it's a contextmanager
    it's used with the ``with`` statement. In either event entering/exiting
    are called before and after, respectively, the function/block is executed.
    """
    def __init__(self, **kwargs):
        self.options = kwargs
        self.wrapped = settings._wrapped

    def __enter__(self):
        self.enable()

    def __exit__(self, exc_type, exc_value, traceback):
        self.disable()

    def __call__(self, test_func):
        from django.test import TestCase
        if isinstance(test_func, type) and issubclass(test_func, TestCase):
            class inner(test_func):
                def _pre_setup(innerself):
                    self.enable()
                    super(inner, innerself)._pre_setup()
                def _post_teardown(innerself):
                    super(inner, innerself)._post_teardown()
                    self.disable()
        else:
            @wraps(test_func)
            def inner(*args, **kwargs):
                with self:
                    return test_func(*args, **kwargs)
        return inner

    def enable(self):
        override = OverrideSettingsHolder(settings._wrapped)
        for key, new_value in self.options.items():
            setattr(override, key, new_value)
        settings._wrapped = override

    def disable(self):
        settings._wrapped = self.wrapped


from django.test import testcases
class TestCase(testcases.TestCase):
    def __init__(self, *args, **kwargs):
        import django
        if django.VERSION >= (1, 4):
            import warnings
            warnings.warn("django_testcase_backports.TestCase is not needed on"
                          " django 1.4 or later."
                          " Just use django.test.TestCase instead")
        return super(TestCase, self).__init__(*args, **kwargs)

    def settings(self, **kwargs):
        """
        A context manager that temporarily sets a setting and reverts
        back to the original value when exiting the context.
        """
        return override_settings(**kwargs)


########NEW FILE########
__FILENAME__ = geodjango
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Utility functions for working with GeoDjango GDAL and GEOS data


"""

from django.contrib.gis import geos
from django.contrib.gis.geos import Point, LineString, Polygon, GeometryCollection, MultiPoint, MultiLineString, MultiPolygon
from ebpub.metros.allmetros import get_metro
import logging

logger = logging.getLogger('ebpub.utils.geodjango')

def reduce_layer_geom(layer, method):
    """
    Iterates over all the geometries in an GDAL layer and successively
    applies given ``method`` to the geometries.
    """
    def reduction(x, y):
        return getattr(x, method)(y)
    
    return reduce(reduction, [feat.geom for feat in layer])

# TODO: remove this once line_merge is added to django.contrib.gis.geos
from django.contrib.gis.geos.libgeos import lgeos
from django.contrib.gis.geos.prototypes.topology import topology
geos_linemerge = topology(lgeos.GEOSLineMerge)
def line_merge(geom):
    return geom._topology(geos_linemerge(geom.ptr))

def flatten(geos_geom):
    """
    Flattens a GEOS geometry and returns a list of the component geometries.
    """
    def _flatten(geom, acc):
        if isinstance(geom, (Point, LineString, Polygon)):
            acc.append(geom)
            return acc
        elif isinstance(geom, (GeometryCollection, MultiPoint, MultiLineString, MultiPolygon)):
            subgeom_list = list(geom)
            if subgeom_list:
                acc.append(subgeom_list.pop(0))
                for subgeom in subgeom_list:
                    _flatten(subgeom, acc)
            return acc
        else:
            raise TypeError, 'not a recognized GEOSGeometry type'
    flattened = []
    _flatten(geos_geom, flattened)
    return flattened

def make_geomcoll(geom_list):
    """
    From a list of geometries, return a single GeometryCollection (or
    subclass) geometry.

    This flattens multi-point/linestring/polygon geometries in the
    list.
    """
    flattened = []

    for geom in geom_list:
        flattened.extend(flatten(geom))

    return GeometryCollection(flattened)

def make_multi(geom_list, collapse_single=False):
    """
    Convert a list of Geometries (of the same type) into a single
    Multi(Point|Linestring|Polygon).
    """
    if len(geom_list) == 1 and collapse_single:
        return geom_list[0]

    geom_types = set(g.geom_type for g in geom_list)

    if len(geom_types) > 1:
        raise ValueError, 'all geometries must be of the same geom_type'

    geom_type = geom_types.pop()

    valid_geom_types = ('Point', 'LineString', 'Polygon')

    if geom_type not in valid_geom_types:
        raise ValueError, 'geometries must be of type %s' % ', '.join(valid_geom_types)

    cls = getattr(geos, 'Multi%s' % geom_type)
    return cls(geom_list)


def flatten_geomcollection(geom):
    """
    Workaround for bug #95: if we get a GeometryCollection,
    save it instead as a MultiPolygon, because PostGIS doesn't support
    using Collections for anything useful like
    ST_Intersects(some_other_geometry), so we effectively can't
    use them at all. Yuck.
    """
    if geom.geom_type == 'GeometryCollection':
        geom = make_multi(flatten(geom))
        logger.warn("Got a GeometryCollection. Can't call ST_Intersects() on those."
                    " Munged it into a %s." % geom.geom_type)
    return geom

def smart_transform(geom, srid, clone=True):
    """
    Returns a new geometry transformed to the srid given. Assumes if
    the initial geom is lacking an SRS that it is EPSG 4326. (Hence the
    "smartness" of this function.) This fixes many silent bugs when
    transforming between SRSes when the geometry is missing this info.
    """
    if not geom.srs:
        geom.srid = 4326
    return geom.transform(srid, clone=clone)


def ensure_valid(geom, name=''):
    """Make sure a geometry is valid; if necessary, make a 0.0 buffer
    around it. (This is a well-known hack to fix broken geometries.)
    """
    if not geom.valid:
        geom = geom.buffer(0.0)
        if not geom.valid:
            logger.warn('invalid geometry for %s' % name)
    return geom

def intersects_metro_bbox(geom):
    """
    Return True if the geometry intersects with the bounding box of
    the current metro.
    """
    return geom.intersects(get_default_bounds())


def get_default_bounds():
    """Returns the bounding box of the metro, as a Polygon.

    >>> import mock
    >>> metrodict = {'extent': (-10.0, 15.0, -5.0, 20.0)}
    >>> with mock.patch('ebpub.utils.geodjango.get_metro', lambda: metrodict) as get_metro:
    ...     bounds = get_default_bounds()
    >>> bounds  #doctest: +ELLIPSIS
    <Polygon object at ...>
    >>> bounds.extent
    (-10.0, 15.0, -5.0, 20.0)
    """
    return Polygon.from_bbox(get_metro()['extent'])

def interpolate(linestring, distance, normalized=True):
    """
    Find a point along the linestring that is ``distance`` from the first point.

    If normalized=True, distance is fraction of the linestring's length
    (range 0.0 - 1.0).

    Example:

    >>> ls = LineString((0.0, 0.0), (1.1, 1.1), (2.2, 2.2))
    >>> interpolate(ls, 0, True).coords
    (0.0, 0.0)
    >>> interpolate(ls, 0.5, True).coords
    (1.1, 1.1)
    >>> interpolate(ls, 1.0, True).coords
    (2.2, 2.2)
    """
    # Use Shapely because geodjango's native GEOS support doesn't
    # provide the interpolate() function.
    # See https://code.djangoproject.com/ticket/18209
    import shapely.geometry
    try:
        center = shapely.geometry.LineString(linestring).interpolate(distance, normalized)
    except (ImportError, AttributeError):
        # Might be that the platform doesn't have a recent-enough GEOS; needs 1.6.
        # This version uses database, and requires normalized.
        if not normalized:
            raise ValueError("Can't call interpolate() with normalized=False unless you have GEOS version 1.6 or later.")
        from django.db import connection
        from django.contrib.gis.geos import fromstr
        cursor = connection.cursor()
        cursor.execute('SELECT line_interpolate_point(%s, %s)', [linestring.wkt, distance])
        wkb_hex = cursor.fetchone()[0]
        center = fromstr(wkb_hex)
    center = Point(*list(center.coords))
    return center


def geos_with_projection(geom, projection=4326):
    """
    Returns a GEOSGeometry with the projection set.

    ``geom`` can be a GEOSGeometry or OGRGeometry or subclass.

    ``projection`` can be an integer SRID or a SpatialReference object.
    Default projection is 4326 (aka WGS 84).


    You can use a GEOSGeometry with no projection::

      >>> from django.contrib.gis.geos import Point, GEOSGeometry
      >>> from django.contrib.gis.gdal import OGRGeometry, SpatialReference
      >>>
      >>> geos_no_srid = Point((1.0, 2.0))
      >>> print geos_no_srid.srid
      None
      >>> geom = geos_with_projection(geos_no_srid)
      >>> geom.srid
      4326
      >>> geom.x, geom.y
      (1.0, 2.0)

    You can use a GEOSGeometry with a projection::

      >>> geos_with_srid = Point((1.0, 2.0), srid=4326)
      >>> geos_with_srid.srid
      4326
      >>> geom = geos_with_projection(geos_with_srid)
      >>> geom.srid
      4326
      >>> geom.x, geom.y
      (1.0, 2.0)


   YOu can use an OGRGeometry with no projection::

      >>> ogr_no_srs = OGRGeometry('POINT (1 2)')
      >>> print ogr_no_srs.srs
      None
      >>> geom = geos_with_projection(ogr_no_srs)
      >>> print geom.srid
      4326
      >>> geom.x, geom.y
      (1.0, 2.0)

   You can use an OGR geometry with a projection that has no srid,
   there are some like that::

      >>> test_srs = SpatialReference(
      ...     '''PROJCS["NAD_1983_StatePlane_North_Carolina_FIPS_3200_Feet",
      ...     GEOGCS["GCS_North_American_1983",
      ...         DATUM["North_American_Datum_1983",
      ...             SPHEROID["GRS_1980",6378137.0,298.257222101]],
      ...         PRIMEM["Greenwich",0.0],
      ...         UNIT["Degree",0.0174532925199433]],
      ...     PROJECTION["Lambert_Conformal_Conic_2SP"],
      ...     PARAMETER["False_Easting",2000000.002616666],
      ...     PARAMETER["False_Northing",0.0],
      ...     PARAMETER["Central_Meridian",-79.0],
      ...     PARAMETER["Standard_Parallel_1",34.33333333333334],
      ...     PARAMETER["Standard_Parallel_2",36.16666666666666],
      ...     PARAMETER["Latitude_Of_Origin",33.75],
      ...     UNIT["Foot_US",0.3048006096012192]]
      ... '''
      ...     )
      >>> ogr_with_srs_but_no_srid = OGRGeometry('POINT (1 2)', srs=4326)
      >>> ogr_with_srs_but_no_srid.transform(test_srs)
      >>> print ogr_with_srs_but_no_srid.srs.name
      NAD_1983_StatePlane_North_Carolina_FIPS_3200_Feet
      >>> print ogr_with_srs_but_no_srid.srid
      None
      >>> geom = geos_with_projection(ogr_with_srs_but_no_srid)
      >>> geom.srid
      4326
      >>> round(geom.x), round(geom.y)  # transform is a bit lossy
      (1.0, 2.0)

    You can use an OGRGeometry with a projection::

      >>> ogr_with_srid = OGRGeometry('POINT (1 2)', srs=4326)
      >>> ogr_with_srid.srid
      4326
      >>> geom = geos_with_projection(ogr_with_srid)
      >>> geom.x, geom.y
      (1.0, 2.0)
      >>> geom.srid
      4326

    """
    geom = geom.clone()
    if geom.srs is None:
        if isinstance(projection, int):
            geom.srid = projection
        else:
            geom.srs = projection
    geom = geom.transform(projection, True)
    if hasattr(geom, 'geos'):
        geom = geom.geos
    return geom

########NEW FILE########
__FILENAME__ = image_utils
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Utilities for images, eg. rotating jpegs according to EXIF data.
"""

from PIL import Image
from PIL.ExifTags import TAGS

def get_exif_info(img):
    """
    Get EXIF information from a PIL.Image instance.
    Found this code at:
    http://wolfram.kriesing.de/blog/index.php/2006/reading-out-exif-data-via-python
    """
    result = {}
    try:
        info = img._getexif() or {}
    except AttributeError:
        info = {}
    for tag, value in info.items():
        decoded = TAGS.get(tag, tag)
        result[decoded] = value
    return result

def rotate_image_by_exif(img):
    """
    Rotate a PIL.Image instance according to its EXIF rotation information.

    Based on code from: http://stackoverflow.com/questions/1606587/how-to-use-pil-to-resize-and-apply-rotation-exif-information-to-the-file

    NOTE, this is a LOSSY transformation. Probably fine for our
    purposes.  We could use something like
    http://ebiznisz.hu/python-jpegtran/ if we change our minds about
    that.
    """
    exif_info = get_exif_info(img)
    # We rotate regarding to the EXIF orientation information
    orientation = exif_info.get('Orientation', 1)
    if orientation == 1:
        rotated = img
    elif orientation == 2:
        # Vertical Mirror
        rotated = img.transpose(Image.FLIP_LEFT_RIGHT)
    elif orientation == 3:
        # Rotation 180
        rotated = img.transpose(Image.ROTATE_180)
    elif orientation == 4:
        # Horizontal Mirror
        rotated = img.transpose(Image.FLIP_TOP_BOTTOM)
    elif orientation == 5:
        # Horizontal Mirror + Rotation 270
        rotated = img.transpose(Image.FLIP_TOP_BOTTOM).transpose(
            Image.ROTATE_270)
    elif orientation == 6:
        # Rotation 270
        rotated = img.transpose(Image.ROTATE_270)
    elif orientation == 7:
        # Vertical Mirror + Rotation 270
        rotated = img.transpose(Image.FLIP_LEFT_RIGHT).transpose(
            Image.ROTATE_270)
    elif orientation == 8:
        # Rotation 90
        rotated = img.transpose(Image.ROTATE_90)
    else:
        # unknown? do nothing.
        rotated = img

    return rotated


########NEW FILE########
__FILENAME__ = logutils
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#


import logging
import warnings

def log_exception(msg='', level=logging.ERROR, logger=logging.getLogger()):
    """Log the most recent exception & traceback at the given level
    (default ERROR).

    Note this can be replaced by logger.exception(msg) or, if you want a
    level other than ERROR, you can do eg. logger.debug(msg, exc_info=True)
    """
    warnings.warn("logutils.log_exception is deprecated. You can use logging.exception() instead")
    logging.basicConfig()
    logger.log(level=level, msg=msg, exc_info=True)

########NEW FILE########
__FILENAME__ = mapmath
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

import math
from django.conf import settings

INCHES_PER_UNIT = {
    "inches": 1.0,
    "ft": 12.0,
    "mi": 63360.0,
    "m": 39.3701,
    "km": 39370.1,
    "dd": 4374754
}
INCHES_PER_UNIT["in"] = INCHES_PER_UNIT["inches"]
INCHES_PER_UNIT["degrees"] = INCHES_PER_UNIT["dd"]

DOTS_PER_INCH = 72

def normalize_scale(scale):
    """
    Ensures scale is in the 1/n representation.
    """
    return scale >= 1.0 and (1.0 / scale) or scale

def get_resolution(scale, units="degrees"):
    """
    Returns resolution from given scale and units.
    """
    return 1 / (normalize_scale(scale) * INCHES_PER_UNIT[units] * DOTS_PER_INCH)

def get_scale(resolution, units="degrees"):
    """
    Returns scale from given resolution and units.
    """
    return resolution * INCHES_PER_UNIT[units] * DOTS_PER_INCH

def px_from_lnglat(lnglat, resolution, extent=(-180, -90, 180, 90)):
    return (round(1/resolution * (lnglat[0] - extent[0])),
            round(1/resolution * (extent[3] - lnglat[1])))

def lnglat_from_px(px, resolution, extent=(-180, -90, 180, 90)):
    w = round(1/resolution * extent[2]) - round(1/resolution * extent[0])
    h = round(1/resolution * extent[3]) - round(1/resolution * extent[1])
    return ((px[0] - w / 2) * resolution,
            -(px[1] - h / 2) * resolution)

def km_per_lng_at_lat(lat):
    return 111.321 * math.cos(math.radians(lat))

def km_per_lat():
    return 111.0

def lng_per_km_at_lat(lat):
    return 1 / km_per_lng_at_lat(lat)

def lat_per_km():
    return 1 / km_per_lat()

def buffer_by_meters(geom, m):
    """
    Like geom.buffer(n) except n is in meters, not native units.
    """
    # Based on http://www.gistutor.com/postgresqlpostgis/6-advanced-postgresqlpostgis-tutorials/58-postgis-buffer-latlong-and-other-projections-using-meters-units-custom-stbuffermeters-function.html

    geom = geom.clone()
    # First make sure we're in 4326 (long/lat).
    if geom.srid is None:
        geom.srid = 4326

    orig_srid = geom.srid
    if geom.srid != 4326:
        geom.transform(4326)

    # Now get a local projection where we can use meters reasonably
    # accurately.
    if geom.centroid.y > 0:
        pref = 32600
    else:
        pref = 32700
    from math import floor
    zone = int(floor((geom.centroid.x + 180) / 6)  + 1)
    local_srid = zone + pref

    geom.transform(local_srid)
    buffered = geom.buffer(m)
    buffered.transform(orig_srid)
    return buffered


def extent_resolution(extent, size, units='degrees'):
    width = extent[2] - extent[0]
    height = extent[3] - extent[1]
    return max(width / size[0], height / size[1])

def extent_scale(extent, size, units='degrees'):
    """
    Given an extent, return the scale at which it will fill the given
    size, a 2-tuple: (width, height)
    """
    resolution = extent_resolution(extent, size, units)
    return get_scale(resolution, units)

def get_scale_for_resolution(resolution, units='degrees'):
    resolutions = [get_resolution(s, units) for s in settings.MAP_SCALES]
    for i, res in enumerate(resolutions):
        if res < resolution:
            break
    i = max(0, i-1)
    return settings.MAP_SCALES[i]

def calculate_bounds(center, resolution, size):
    w_units = size[0] * resolution
    h_units = size[1] * resolution
    return (center[0] - w_units / 2,
            center[1] - h_units / 2,
            center[0] + w_units / 2,
            center[1] + h_units / 2)

def center(extent):
    return ((extent[2] - extent[0]) / 2 + extent[0],
            (extent[3] - extent[1]) / 2 + extent[1])

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

#There are no models, but `manage.py test` needs a models.py to find tests.

def is_instance_of_model(obj, model):
    """
    isinstance(foo, model) seems to work *sometimes* with django models,
    but not always; no idea what's going on there.
    This should always work.
    """
    return (isinstance(obj, model)
            or type(obj) is model
            or model in obj.__class__.__bases__)

########NEW FILE########
__FILENAME__ = multidb
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
import re

class PerModelDBRouter:
    """
    PerModelDBRouteer is a database router as described in the 
    django multi-database documentation: 
    http://docs.djangoproject.com/en/dev/topics/db/multi-db/
    
    The PerModelDBRouter allows you to assign Model types to a 
    particular configured database. 
    
    The django setting DATABASE_ROUTES controls the particulars.
    
    DATABASE_ROUTES is expected to be a dictionary with keys 
    referencing database names in the DATABASES settings and 
    values lists of references to model types of the form 
    <app_label>.<ModelClass> or regular expressions that match
    values of the form.
    
    eg::

        DATABASE_ROUTES = {
            'users': ['accounts.User'],
            'barn': ['animals.Goat', 
                     'animals.Pig'],
            'junkyard': ['garbage.*', 'scrap.*']
        }
    
    This configuration would put
    :py:class:`ebpub.accounts.models.User` objects into the 
    database 'users', animals.models.Goat and animals.models.Pig into
    the database 'barn' and any model in the 'garbage' or 'scrap' app into 
    the database 'junkyard'.
    
    A subclass may optionally provide its own configuration instead of
    using settings.DATABASE_ROUTES, by setting the attribute ``_routes``
    to a dictionary of the same form.
    """
    
    @property
    def routes(self):
        if hasattr(self, '_routes'):
            return self._routes
        else:
            return settings.DATABASE_ROUTES

    def _find_db(self, model):
        for db, routes in self.routes.items():
            for pat in routes: 
                mid = '%s.%s' % (model._meta.app_label, model.__name__)
                if re.match(pat, mid):
                    return db

        return None

    def db_for_read(self, model, **hints):
        return self._find_db(model)

    def db_for_write(self, model, **hints):
        return self._find_db(model)
        
    def allow_relation(self, obj1, obj2, **hints):
        # XXX should validate.
        return None

    def allow_syncdb(self, db, model):
        assigned_db_alias = self._find_db(model)
        # if there is an assigned db, only allow
        # it to be synced to the specific one.
        if assigned_db_alias is None:
            if db in self.routes:
                return False
            else:
                return None
        return assigned_db_alias == db

########NEW FILE########
__FILENAME__ = script_utils
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Utils for command-line scripts.
"""

from django.core.management.base import CommandError
import logging
import os
import subprocess
import sys
import zipfile

logger = logging.getLogger(__name__)

def die(msg):
    """
    Useful in places where you can't syntactically put 'raise CommandError'.
    Eg. ``do_something() or die('oops')``
    """
    raise CommandError(msg)

def makedirs(path):
    """Emulates the `mkdir -p` shell command.
    """
    if os.path.exists(path):
        return True
    try:
        os.makedirs(path)
        return True
    except:
        logger.exception('Failed to create %r' % path)
        return False

def shell_command(cmd, args="", cwd=None):
    """Quick hack to replace a single bash command from existing shell scripts.
    """
    old_cwd = os.getcwd()
    try:
        os.chdir(cwd or old_cwd)
        status = subprocess.call("%s %s" % (cmd, args), shell=True)
        return status == 0
    finally:
        os.chdir(old_cwd)

def wget(url, cwd=None, options="-N"):
    """Quick hack to invoke wget from python scripts.
    """
    # We could use httlib2, but meh, that's a bit more work.
    # And this supports FTP too.
    return shell_command('wget', args='%s %s' % (options, url), cwd=cwd)

def unzip(filename, cwd=None):
    """Unzip filename, write extracted files into cwd (default is the current dir).
    """
    try:
        zfile = zipfile.ZipFile(filename)
        zfile.extractall(path=cwd)
        return True
    except:
        logger.exception('Failed to unzip %r' % filename)
        return False


def add_verbosity_options(parser):
    """
    Add --verbose and --quiet options to an optparser.
    """
    parser.add_option('-v', '--verbose', action='store_true', help='Verbose output.')
    parser.add_option('-q', '--quiet', action='store_true', help='No output.')


def setup_logging_from_opts(opts, logger=None):
    """
    Useful with scripts that have used add_verbosity_options(optparser).

    If ``opts.verbose``, set log level *everywhere* to (at least) DEBUG.
    If ``opts.quiet``, reduce stdout/stderr log level to WARN.
    Otherwise, set stdout/stderr log level to INFO.

    Note the asymmetry there: ``verbose`` affects all log handlers,
    but ``quiet`` only affects console output.
    """
    logging.basicConfig()
    loglevel = logging.INFO
    if opts.verbose:
        loglevel = logging.DEBUG
    if opts.quiet:
        loglevel = logging.WARN
    current_logger = logger or logging.getLogger()
    while current_logger:
        if opts.verbose:
            # For more verbosity, we have to open up verbosity at
            # every step of the chain. I think.
            if current_logger.getEffectiveLevel() > loglevel:
                current_logger.setLevel(loglevel)
        for handler in current_logger.handlers:
            # Hopefully this will get all the console handlers...
            if isinstance(handler, logging.StreamHandler):
                if handler.stream in (sys.stdout, sys.stderr):
                    handler.setLevel(loglevel)
        current_logger = current_logger.parent

########NEW FILE########
__FILENAME__ = testing
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from django.utils.importlib import import_module
import django.test.client


class RequestFactory(django.test.client.RequestFactory):
    """Thin wrapper around django.test.client.RequestFactory that
    adds a .session attribute to the request.
    (Asked for this to be added upstream, but was closed WONTFIX
    https://code.djangoproject.com/ticket/15736)
    """

    def request(self, **request):
        """
        Construct a generic request object, with a .session attribute
        as if SessionMiddleware were active.
        """
        req = super(RequestFactory, self).request(**request)
        req.session = self._session()
        return req


    def _session(self):
        """
        Obtains the current session variables.
        """
        if 'django.contrib.sessions' in settings.INSTALLED_APPS:
            engine = import_module(settings.SESSION_ENGINE)
            cookie = self.cookies.get(settings.SESSION_COOKIE_NAME, None)
            if cookie:
                return engine.SessionStore(cookie.value)
        return {}

########NEW FILE########
__FILENAME__ = tests
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.http import Http404
from django.test import TestCase
from django.test.testcases import TransactionTestCase
from ebpub.constants import BLOCK_RADIUS_CHOICES
from ebpub.db.models import Location, LocationType
from ebpub.streets.models import Block
from ebpub.utils.view_utils import make_pid
from ebpub.utils.view_utils import parse_pid
import unittest

LINESTRING = 'LINESTRING (0.0 0.0, 1.0 1.0)'

class PidTests(TestCase):


    def _makeLocation(self):
        location = Location(
            location_type=self.loctype, display_order=1,
            slug='testloc', name='testloc', normalized_name='testloc',
            city='city', source='source', is_public=True)
        location.save()
        return location

    def setUp(self):
        # can't make a Location without a LocationType
        loctype = LocationType(name='testloctype', plural_name='xs', slug='x',
                               is_browsable=False, is_significant=False)
        loctype.save()
        self.loctype = loctype

    def _makeBlock(self):
        block = Block(geom=LINESTRING)
        block.save()
        return block

    def test_parse_pid__invalid(self):
        self.assertRaises(Http404, parse_pid, 'xyz')
        self.assertRaises(Http404, parse_pid, 'c:99.1')
        self.assertRaises(Http404, parse_pid, 'b:x')

    def test_parse_pid__block(self):
        b = self._makeBlock()
        result = parse_pid('b:%d.1' % b.id)
        self.assertEqual(result, (b, '1', BLOCK_RADIUS_CHOICES['1']))

    def test_parse_pid__block__invalid_radius(self):
        b = self._makeBlock()
        self.assertRaises(Http404, parse_pid, 'b:%d.27' % b.id)

    def test_parse_pid__no_such_block(self):
        self.assertRaises(Http404, parse_pid, 'b:1234.1')

    def test_parse_pid__location(self):
        loc = self._makeLocation()
        result = parse_pid('l:%d' % loc.id)
        self.assertEqual(result, (loc, None, None))

    def test_parse_pid__no_such_location(self):
        self.assertRaises(Http404, parse_pid, 'l:1234')

    def test_parse_pid__location_extra_args(self):
        loc = self._makeLocation()
        self.assertRaises(Http404, parse_pid, 'l:%d:1' % loc.id)

    def test_parse_pid__block__not_enough_args(self):
        b = self._makeBlock()
        self.assertRaises(Http404, parse_pid, 'b:%d' % b.id)

    def test_make_pid__block(self):
        b = self._makeBlock()
        self.assertEqual(make_pid(b, 1), 'b:%d.1' % b.id)

    def test_make_pid__block__default_radius(self):
        b = self._makeBlock()
        self.assertEqual(make_pid(b), 'b:%d.8' % b.id)

    def test_make_pid__location(self):
        loc = self._makeLocation()
        self.assertEqual(make_pid(loc), 'l:%d' % loc.id)

    def test_make_pid__wrong_type(self):
        self.assertRaises(ValueError, make_pid, object())

    def test_make_pid__location__extra_args(self):
        loc = self._makeLocation()
        self.assertRaises(AssertionError, make_pid, loc, '1')

    def test_make_and_parse_pid__block(self):
        block = self._makeBlock()
        self.assertEqual(parse_pid(make_pid(block, 1)),
                         (block, '1', BLOCK_RADIUS_CHOICES['1']))


    def test_make_and_parse_pid__location(self):
        loc = self._makeLocation()
        self.assertEqual(parse_pid(make_pid(loc)),
                         (loc, None, None))

class TestModelUtils(TransactionTestCase):

    # For things that mess with the db too much and need to be in a
    # transaction... eg. creating models on the fly and such
    # shenanigans.

    def test_is_instance_of_model(self):
        from ebpub.utils.models import is_instance_of_model
        from django.contrib.gis.db import models
        class Foo(models.Model):
            class Meta:
                app_label = 'openblockapi'
        f = Foo()
        self.assertEqual(True, is_instance_of_model(f, Foo))
        self.assertRaises(TypeError, is_instance_of_model, f, Foo())


def suite():
    # Note, not used by django.nose;
    # for that, run eg. django-admin.py test --with-doctest ebpub/ebpub/utils/
    suite = unittest.TestLoader().loadTestsFromTestCase(PidTests, TestModelUtils)
    import doctest
    import ebpub.utils.text
    suite.addTest(doctest.DocTestSuite(ebpub.utils.text))
    import ebpub.utils.bunch
    suite.addTest(doctest.DocTestSuite(ebpub.utils.bunch))
    import ebpub.utils.dates
    suite.addTest(doctest.DocTestSuite(ebpub.utils.dates))
    import ebpub.utils.dates
    suite.addTest(doctest.DocTestSuite(ebpub.utils.geodjango))
    return suite

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = text
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

import re

def slugify(x):
    """
    Make a slug from a string.
    Examples:

    .. code-block:: python

      >>> slugify('')
      u''
      >>> slugify('Hello from\tsomewhere else')
      u'hello-from-somewhere-else'
      >>> slugify('This: has _ a ... ?!#$ lot of extra stuff@()[]')
      u'this-has-_-a-lot-of-extra-stuff'
      >>> slugify(1)
      u'1'
      >>> slugify(None)
      u'none'

    """
    x = unicode(x)
    return re.sub('[-\s]+', '-', re.sub('[^\w\s-]', '', x.strip())).lower()

def intcomma(orig):
    """
    Converts an integer to a string containing commas every three digits.
    For example, 3000 becomes '3,000' and 45000 becomes '45,000'.
    """
    new = re.sub("^(-?\d+)(\d{3})", '\g<1>,\g<2>', orig)
    if orig == new:
        return new
    else:
        return intcomma(new)

def clean_address(addr):
    """
    Given an address string, normalizes it to look pretty.

    >>> clean_address('123 MAIN')
    '123 Main'
    >>> clean_address('123 MAIN ST')
    '123 Main St.'
    >>> clean_address('123 MAIN ST S')
    '123 Main St. S.'
    >>> clean_address('123 AVENUE A')
    '123 Avenue A'
    >>> clean_address('2 N ST LAWRENCE PKWY')
    '2 N. St. Lawrence Pkwy.'
    >>> clean_address('123 NORTH AVENUE') # Don't abbreviate 'AVENUE'
    '123 North Avenue'
    >>> clean_address('123 N. Main St.')
    '123 N. Main St.'
    >>> clean_address('  123  N  WABASH  AVE   ')
    '123 N. Wabash Ave.'
    >>> clean_address('123 MAIN ST SW')
    '123 Main St. S.W.'
    >>> clean_address('123 MAIN ST NE')
    '123 Main St. N.E.'
    >>> clean_address('123 NEW YORK ST NE') # Don't punctuate 'NEW' (which contains 'NE')
    '123 New York St. N.E.'
    >>> clean_address('123 MAIN St Ne')
    '123 Main St. N.E.'
    >>> clean_address('123 MAIN St n.e.')
    '123 Main St. N.E.'
    """
    addr = smart_title(addr)
    addr = re.sub(r'\b(Ave|Blvd|Bvd|Cir|Ct|Dr|Ln|Pkwy|Pl|Plz|Pt|Pts|Rd|Rte|Sq|Sqs|St|Sts|Ter|Terr|Trl|Wy|N|S|E|W)(?!\.)\b', r'\1.', addr)

    # Take care of NE/NW/SE/SW.
    addr = re.sub(r'\b([NSns])\.?([EWew])\b\.?', lambda m: ('%s.%s.' % m.groups()).upper(), addr)

    addr = re.sub(r'\s\s+', ' ', addr).strip()
    return addr

def address_to_block(addr):
    """
    Given an address string, normalizes it to the 100 block level.

    >>> address_to_block('1 N. Main Street')
    '0 block of N. Main Street'
    >>> address_to_block('10 N. Main Street')
    '0 block of N. Main Street'
    >>> address_to_block('123 Main Street')
    '100 block of Main Street'
    >>> address_to_block('123 MAIN STREET')
    '100 block of MAIN STREET'
    >>> address_to_block('4523 Main Street')
    '4500 block of Main Street'
    >>> address_to_block('  123 Main Street')
    '100 block of Main Street'
    >>> address_to_block(address_to_block(address_to_block('123 Main St')))
    '100 block of Main St'
    """
    if addr.count('block of'):
        return addr
    return re.sub(r'^\s*(\d+) ', lambda m: '%s block of ' % re.sub('..?$', (len(m.group(1)) > 2 and '00' or '0'), m.group(1)), addr)

def smart_title(s, exceptions=None):
    r"""
    Like .title(), but smarter.

    >>> smart_title('hello THERE')
    'Hello There'
    >>> smart_title('128th street')
    '128th Street'
    >>> smart_title('"what the heck," he said. "let\'s go to the zoo."')
    '"What The Heck," He Said. "Let\'s Go To The Zoo."'
    >>> smart_title('')
    ''
    >>> smart_title('a')
    'A'
    >>> smart_title('(this is a parenthetical.)')
    '(This Is A Parenthetical.)'
    >>> smart_title('non-functional')
    'Non-Functional'
    >>> smart_title("BILL'S HOUSE OF WAX LIPS LLC", ["of", "LLC"])
    "Bill's House of Wax Lips LLC"
    >>> smart_title("The C.I.A.", ["C.I.A."])
    'The C.I.A.'
    """
    result = re.sub(r"(?<=[\s\"\(-])(\w)", lambda m: m.group(1).upper(), s.lower())
    if result:
        result = result[0].upper() + result[1:]

    # Handle the exceptions.
    if exceptions is not None:
        for e in exceptions:
            pat = re.escape(e)
            if re.search("^\w", pat):
                pat = r"\b%s" % pat
            if re.search("\w$", pat):
                pat = r"%s\b" % pat
            pat = r"(?i)%s" % pat
            result = re.sub(pat, e, result)

    return result

def smart_excerpt(text, highlighted_text):
    """
    Returns a short excerpt of the given text with `highlighted_text`
    guaranteed to be in the middle.
    """
    m = re.search('(?:\w+\W+){0,15}%s(?:\W+\w+){0,15}' % highlighted_text, text)
    if not m:
        raise ValueError('Value not found in text')
    excerpt = m.group()
    elipsis_start = not text.startswith(excerpt)
    elipsis_end = not text.endswith(excerpt)
    if elipsis_start:
        excerpt = '...' + excerpt
    if elipsis_end:
        excerpt += '...'
    return excerpt

if __name__ == "__main__":
    import doctest
    doctest.testmod()

########NEW FILE########
__FILENAME__ = uploadhandler
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
A FileUploadHandler that stops the upload if it's too big.

Code originally copied from FixCity.
"""

from django.core.files.uploadhandler import FileUploadHandler, StopUpload

import logging
logger = logging.getLogger('uploadhandler')

class QuotaExceededError(StopUpload):
    # Unfortunately this does stop the upload but does seem to let the
    # request complete with a 200 response, weirdly.
    pass

class QuotaUploadHandler(FileUploadHandler):
    """
    This upload handler terminates the connection if a file larger than
    the specified quota is uploaded.
    """

    def __init__(self, request=None):
        super(QuotaUploadHandler, self).__init__(request)
        self.total_upload = 0
        from django.conf import settings
        self.quota_mb = getattr(settings, 'UPLOAD_MAX_MB', 5.0)
        self.quota = self.quota_mb * 1024 * 1024
        self._aborted = False


    def _abort(self):
        self._aborted = True
        logger.warn("Exceeded max upload size of %.2f MB, aborting request" % self.quota_mb)
        raise QuotaExceededError('Maximum upload size is %.2f MB'
                                 % self.quota_mb)

    def receive_data_chunk(self, raw_data, start):
        if self.request:
            # Admin user is allowed to upload anything.
            if self.request.user.is_staff:
                return raw_data
            # For everybody else, first check the content-length header, if provided.
            content_length = self.request.META.get('CONTENT_LENGTH', None)
            if content_length is not None:
                content_length = int(content_length)
                if content_length >= self.quota:
                    return self._abort()
        # Content-length might not be provided, or might be a lie, so
        # we also have to keep track.
        self.total_upload += len(raw_data)
        if self.total_upload >= self.quota:
            return self._abort()
        # Delegate to the next handler.
        return raw_data

    def upload_complete(self):
        if self._aborted:
            return 1
        return None

    def file_complete(self, file_size):
        return None

########NEW FILE########
__FILENAME__ = view_utils
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from django.http import Http404
from django.shortcuts import get_object_or_404
from django.shortcuts import render_to_response
from django.template.context import RequestContext
from ebpub.constants import BLOCK_RADIUS_CHOICES
from ebpub.constants import BLOCK_RADIUS_DEFAULT
from ebpub.db.models import Location
from ebpub.db.models import Schema
from ebpub.streets.models import Block
import ebpub.db.constants


def eb_render(request, *args, **kwargs):
    """
    Replacement for render_to_response that uses RequestContext.
    """
    kwargs['context_instance'] = RequestContext(request)
    return render_to_response(*args, **kwargs)

def parse_pid(pid):
    """
    Returns a tuple of (place, block_radius, xy_radius), where block_radius and
    xy_radius are None for Locations.

    PID examples:
        'b:12.1' (block ID 12, 1-block radius)
        'l:32' (location ID 32)
    """
    try:
        place_type, place_id = pid.split(':')
        if place_type == 'b':
            place_id, block_radius = place_id.split('.')
        place_id = int(place_id)
    except (KeyError, ValueError):
        raise Http404('Invalid place')
    if place_type == 'b':
        try:
            xy_radius = BLOCK_RADIUS_CHOICES[block_radius]
        except KeyError:
            raise Http404('Invalid radius')
        return (get_object_or_404(Block, id=place_id), block_radius, xy_radius)
    elif place_type == 'l':
        return (get_object_or_404(Location, id=place_id), None, None)
    else:
        raise Http404


def make_pid(place, block_radius=None):
    """
    Given a place (either a Location or Block), and an optional
    block_radius (None for Locations), returns a place ID string
    parseable by parse_pid.
    """
    if isinstance(place, Block):
        if block_radius is None:
            block_radius = BLOCK_RADIUS_DEFAULT
        block_radius = int(block_radius)
        return 'b:%d.%d' % (place.id, block_radius)
    elif isinstance(place, Location):
        assert block_radius is None
        return 'l:%d' % place.id
    else:
        raise ValueError("Wrong place type %s, expected Location or Block" % place)


def has_staff_cookie(request):
    """Returns whether the current request has a cookie set with
    settings.STAFF_COOKIE_NAME and settings.STAFF_COOKIE_VALUE.
    """
    return request.COOKIES.get(settings.STAFF_COOKIE_NAME) == settings.STAFF_COOKIE_VALUE


def get_schema_manager(request):
    """
    Returns a Manager that restricts the Schemas that can be seen
    based on the current request.

    This should be used in ALL public view queries that reference
    NewsItems or Schemas.
    Note that it's called internally by NewsItem.objects.by_request(request)
    (also available on NewsItemQuerySet).

    By default, this just uses ``has_staff_cookie`` to decide whether
    to show Schemas that are not public, but you can also name the
    path to a function in settings.SCHEMA_MANAGER_HOOK
    that has a signature like func(manager, request.user)
    and returns a manager.
    """
    if has_staff_cookie(request):
        manager = Schema.objects
    else:
        manager = Schema.public_objects
    return _manager_filter_hook(manager, request.user)

def get_schema_manager_for_user(user):
    """Like get_schema_manager(request),
    but useful in contexts where you have a User object available
    but no request, eg. batch jobs like sending email.

    This can also be overridden/enhanced by setting
    settings.SCHEMA_MANAGER_HOOK.
    """
    if user.is_superuser:
        manager = Schema.objects
    else:
        manager = Schema.public_objects
    return _manager_filter_hook(manager, user)

def _manager_filter_hook(manager, user):
    # Hook to customize the Manager's behavior based on the current user.
    # The named function should take (user, manager) arguments
    # and return something that behaves like a manager but can do whatever
    # extra filtering you like in eg. get_query_set().
    mgr_filter = getattr(settings, 'SCHEMA_MANAGER_HOOK', None)
    if mgr_filter is not None:
        module, func = mgr_filter.split(':')
        import importlib
        module = importlib.import_module(module)
        func = getattr(module, func)
        manager = func(user, manager)
    return manager

def paginate(qs, page=1, pagesize=ebpub.db.constants.FILTER_PER_PAGE):
    """Pagination.

    Given a queryset or iterable ``qs``, a starting page number ``page``,
    and a ``pagesize``, returns a list (derived from the queryset)
    of at most ``pagesize`` results, plus booleans indicating
    whether there are next and previous pages, and start and end indexes.

    (Note the end index is actually the one *beyond* the last item
    in the result list; it's like a slice end index.
    This also means that if next==True, the end index is the start
    index of the next page.)

    We don't use Django's Paginator class because it uses
    SELECT COUNT(*), which we want to avoid.

    Pages count from 1::

      >>> items = list('abcdefghijklmnopqrstuvwxyz')
      >>> current, prev, next, start, end = paginate(items, page=1, pagesize=5)
      >>> current
      ['a', 'b', 'c', 'd', 'e']
      >>> prev, next
      (False, True)
      >>> start, end
      (0, 5)

      >>> current, prev, next, start, end = paginate(items, page=2, pagesize=5)
      >>> current
      ['f', 'g', 'h', 'i', 'j']
      >>> prev, next
      (True, True)
      >>> start, end
      (5, 10)

      >>> current, prev, next, start, end = paginate(items, page=5, pagesize=5)
      >>> current
      ['u', 'v', 'w', 'x', 'y']
      >>> prev, next
      (True, True)
      >>> start, end
      (20, 25)

    The last page might be smaller::

      >>> current, prev, next, start, end = paginate(items, page=6, pagesize=5)
      >>> current
      ['z']
      >>> prev, next
      (True, False)
      >>> start, end
      (25, 26)

    If you go beyond the end::

      >>> current, prev, next, start, end = paginate(items, page=7, pagesize=5)
      >>> current
      []
      >>> prev, next
      (True, False)
      >>> start, end
      (30, 30)

    Note that the 'previous' flag doesn't actually guarantee the previous
    page is non-empty::

      >>> paginate(items, pagesize=10, page=9999)
      ([], True, False, 99980, 99980)

    If the page size contains the whole set, there are no more pages::

      >>> current, prev, next, start, end = paginate(items, pagesize=30)
      >>> len(current)
      26
      >>> prev, next
      (False, False)

    You can actually pass anything that can be list-ified::

      >>> paginate('ABCDEFGHIJKLMNOP', pagesize=3, page=2)
      (['D', 'E', 'F'], True, True, 3, 6)

    """

    idx_start = (page - 1) * pagesize
    idx_end = page * pagesize
    # Get one extra, so we can tell whether there's a next page.
    ni_list = list(qs[idx_start:idx_end+1])
    if page > 1 and not ni_list:
        ni_list = []
    if len(ni_list) > pagesize:
        has_next = True
        ni_list = ni_list[:-1]
    else:
        has_next = False
        idx_end = idx_start + len(ni_list)
    has_previous = page > 1
    return ni_list, has_previous, has_next, idx_start, idx_end

########NEW FILE########
__FILENAME__ = admin
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib.gis import admin
from ebpub.widgets.models import Template, Widget, PinnedItem

from ebpub.geoadmin import OSMModelAdmin


class WidgetAdmin(OSMModelAdmin):
    save_as = True
    prepopulated_fields = {'slug': ('name',)}

class TemplateAdmin(OSMModelAdmin):
    save_as = True

class PinnedItemAdmin(OSMModelAdmin):

    list_display = ('widget', 'news_item', 'item_number')

admin.site.register(Widget, WidgetAdmin)
admin.site.register(Template, TemplateAdmin)
admin.site.register(PinnedItem, PinnedItemAdmin)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    depends_on = (
        ("db", "0001_initial"),
    )


    def forwards(self, orm):
        
        # Adding model 'Template'
        db.create_table('widgets_template', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('slug', self.gf('django.db.models.fields.CharField')(unique=True, max_length=128)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('code', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('content_type', self.gf('django.db.models.fields.CharField')(default='text/html', max_length=128)),
        ))
        db.send_create_signal('widgets', ['Template'])

        # Adding model 'Widget'
        db.create_table('widgets_widget', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('slug', self.gf('django.db.models.fields.CharField')(unique=True, max_length=128)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('extra_link_parameters', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True)),
            ('template', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['widgets.Template'])),
            ('max_items', self.gf('django.db.models.fields.IntegerField')(default=10)),
            ('location', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.Location'], null=True, blank=True)),
        ))
        db.send_create_signal('widgets', ['Widget'])

        # Adding M2M table for field types on 'Widget'
        db.create_table('widgets_widget_types', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('widget', models.ForeignKey(orm['widgets.widget'], null=False)),
            ('schema', models.ForeignKey(orm['db.schema'], null=False))
        ))
        db.create_unique('widgets_widget_types', ['widget_id', 'schema_id'])


    def backwards(self, orm):
        
        # Deleting model 'Template'
        db.delete_table('widgets_template')

        # Deleting model 'Widget'
        db.delete_table('widgets_widget')

        # Removing M2M table for field types on 'Widget'
        db.delete_table('widgets_widget_types')


    models = {
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'widgets.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'content_type': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '128'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '128'})
        },
        'widgets.widget': {
            'Meta': {'object_name': 'Widget'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'extra_link_parameters': ('django.db.models.fields.CharField', [], {'max_length': '256', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'max_items': ('django.db.models.fields.IntegerField', [], {'default': '10'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '128'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['widgets.Template']"}),
            'types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Schema']", 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['widgets']

########NEW FILE########
__FILENAME__ = 0002_auto__del_field_widget_extra_link_parameters__add_field_widget_item_li
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    depends_on = (
        ("db", "0017_del_location_centroid.py"),
    )


    def forwards(self, orm):
        
        # Deleting field 'Widget.extra_link_parameters'
        db.delete_column('widgets_widget', 'extra_link_parameters')

        # Adding field 'Widget.item_link_template'
        db.add_column('widgets_widget', 'item_link_template', self.gf('django.db.models.fields.TextField')(null=True, blank=True), keep_default=False)


    def backwards(self, orm):
        
        # Adding field 'Widget.extra_link_parameters'
        db.add_column('widgets_widget', 'extra_link_parameters', self.gf('django.db.models.fields.CharField')(max_length=256, null=True, blank=True), keep_default=False)

        # Deleting field 'Widget.item_link_template'
        db.delete_column('widgets_widget', 'item_link_template')


    models = {
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'widgets.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'content_type': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '128'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '128'})
        },
        'widgets.widget': {
            'Meta': {'object_name': 'Widget'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_link_template': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'max_items': ('django.db.models.fields.IntegerField', [], {'default': '10'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '128'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['widgets.Template']"}),
            'types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Schema']", 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['widgets']

########NEW FILE########
__FILENAME__ = 0003_auto__add_pinneditem
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'PinnedItem'
        db.create_table('widgets_pinneditem', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('widget', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['widgets.Widget'])),
            ('item_number', self.gf('django.db.models.fields.IntegerField')()),
            ('news_item', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['db.NewsItem'])),
            ('expiration_date', self.gf('django.db.models.fields.DateTimeField')(null=True)),
        ))
        db.send_create_signal('widgets', ['PinnedItem'])


    def backwards(self, orm):
        
        # Deleting model 'PinnedItem'
        db.delete_table('widgets_pinneditem')


    models = {
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'widgets.pinneditem': {
            'Meta': {'object_name': 'PinnedItem'},
            'expiration_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_number': ('django.db.models.fields.IntegerField', [], {}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"}),
            'widget': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['widgets.Widget']"})
        },
        'widgets.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'content_type': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '128'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '128'})
        },
        'widgets.widget': {
            'Meta': {'object_name': 'Widget'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_link_template': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'max_items': ('django.db.models.fields.IntegerField', [], {'default': '10'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '128'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['widgets.Template']"}),
            'types': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Schema']", 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['widgets']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from django.core.urlresolvers import reverse
from django.contrib.gis.db import models
from ebpub.db.models import NewsItem, Location, Schema
import datetime
from operator import attrgetter

class TemplateManager(models.GeoManager):

    def get_by_natural_key(self, slug):
        return self.get(slug=slug)

class Template(models.Model):
    """
    django template stored in the database
    representing the html output of a widget.
    """
    name = models.CharField(max_length=128)
    slug = models.CharField(max_length=128, unique=True)
    description = models.TextField(blank=True)
    code = models.TextField(blank=True)
    content_type = models.CharField(max_length=128, default='text/html')

    def natural_key(self):
        return (self.slug, )

    objects = TemplateManager()

    def __unicode__(self):
        return self.name


class WidgetManager(models.GeoManager):

    def get_by_natural_key(self, slug):
        return self.get(slug=slug)

class Widget(models.Model):
    """
    """
    name = models.CharField(max_length=128)
    slug = models.CharField(max_length=128, unique=True)
    description = models.TextField(blank=True)

    template = models.ForeignKey(Template)
    max_items = models.IntegerField(default=10)
    types = models.ManyToManyField(Schema, blank=True, null=True)
    location = models.ForeignKey(Location, blank=True, null=True)
    item_link_template = models.TextField(blank=True, null=True, help_text="If specified, this simple URL template is used to determine the url for items with openblock 'detail' pages, eg: 'http://mypublicsite.com/openblock/{{item.schema.name}}/{{item.id}}/'. For detailed information, see documentation.")

    #...
    
    def natural_key(self):
        return (self.slug, )

    objects = WidgetManager()
    
    def __unicode__(self):
        return '%s (%s)' % (self.name, self.slug)

    @property
    def target_id(self):
        return "obw:%s" % self.slug

    def fetch_items(self, count=None, expire=True):
        """
        fetches items that should be displayed by 
        the widget.  This encorporates 'pinned' items
        and performs expiration on them.
        """
        if count is None:
            count = self.max_items
        
        widget_items = list(self.raw_item_query(count=count))
        now = datetime.datetime.now()
        
        # Iterate through any 'pinned' items for this 
        # widget.  Delete any that have expired.
        expired_pinned = []
        pinned_items = []
        for pi in PinnedItem.objects.filter(widget=self).all(): 
            # did it expire? 
            if pi.expiration_date is not None and pi.expiration_date < now:
                # get rid of it if so
                expired_pinned.append(pi)
            else: 
                pinned_items.append(pi)

        if expire:
            for pi in expired_pinned: 
                pi.delete()
        
        # If any of the pinned items are already in the list 
        # of items, remove them so that they will not appear 
        # twice.
        pinned_ids = set([pi.news_item.id for pi in pinned_items])
        widget_items = [x for x in widget_items if x.id not in pinned_ids]
        
        # Insert pinned items into the list of items
        pinned_items.sort(key=attrgetter('item_number'))
        for pi in pinned_items:
            widget_items.insert(pi.item_number, pi.news_item)
        
        return widget_items[:count]

    def raw_item_query(self, start=0, count=None):
        """
        gets items based on the filters set 
        on the widget. This does not include
        'pinned' items. 
        """
        # TODO integrate with other ways to search for items ?
        query = NewsItem.objects.all()
        
        type_filter = [x for x in self.types.all()]
        if len(type_filter): 
            query = query.filter(schema__in=type_filter)
        if self.location:
            query = query.filter(newsitemlocation__location=self.location)
        query = query.order_by('-item_date')
        
        if count is None: 
            count = self.max_items
        query = query[start:start+count]
        return query

    def embed_code(self):
        return '<div id="%s"></div><script src="http://%s/%s"></script>' % (
            self.target_id, settings.EB_DOMAIN,
            reverse('widget_javascript', args=(self.slug,)).lstrip('/')
            )

    def transclude_url(self):
        return "http://%s/%s" % (settings.EB_DOMAIN, self.absolute_url().lstrip('/'))

    def absolute_url(self):
        return reverse('widget_content', args=(self.slug,))

class PinnedItem(models.Model):
    """
    represents an item that will be "pinned" in 
    a certain place in a widget (ie the 5th item
    regardless of what the query produces)
    """
    widget = models.ForeignKey(Widget)
    item_number = models.IntegerField()
    news_item = models.ForeignKey(NewsItem)
    expiration_date = models.DateTimeField(null=True)



########NEW FILE########
__FILENAME__ = tests
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

"""
This file demonstrates two different styles of tests (one doctest and one
unittest). These will both pass when you run "manage.py test".

Replace these with more appropriate tests for your application.
"""

from django.test import TestCase

class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.failUnlessEqual(1 + 1, 2)

__test__ = {"doctest": """
Another way to test that 1 + 1 is equal to 2.

>>> 1 + 1 == 2
True
"""}


########NEW FILE########
__FILENAME__ = urls
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf.urls.defaults import *
from ebpub.widgets import views

urlpatterns = patterns(
    '',
    url(r'admin\/?$', views.widget_admin_list, name="widget_admin_root"),
    url(r'admin/(?P<slug>[-_a-z0-9]{1,32})\/?$', views.widget_admin, name="widget_admin"),
    url(r'admin/raw_items/(?P<slug>[-_a-z0-9]{1,32})\/?$', views.ajax_widget_raw_items,
        name="ajax_widget_raw_items"),
    url(r'admin/pins/(?P<slug>[-_a-z0-9]{1,32})\/?$', views.ajax_widget_pins,
        name="ajax_widget_pins"),
    url(r'(?P<slug>[-_a-z0-9]{1,32})\.js\/?$', views.widget_javascript,
        name="widget_javascript"),
    url(r'(?P<slug>[-_a-z0-9]{1,32})\/?$', views.widget_content, name="widget_content"),
)

########NEW FILE########
__FILENAME__ = views
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from django.http import HttpResponse, HttpResponseNotAllowed
from django.shortcuts import render_to_response, get_object_or_404
from django.template import Context, Template
from django.template.context import RequestContext
from django.utils import simplejson as json
from ebpub.accounts.utils import login_required
from ebpub.db.models import NewsItem
from ebpub.widgets.models import Widget, PinnedItem
from operator import attrgetter
import datetime
import logging

logger = logging.getLogger('ebpub.widgets.views')

def widget_javascript(request, slug):
    """
    View that returns javascript suitable for linking to from an embedded script tag.
    The javsacript renders the widget using its template, once, on page load.
    """
    try:
        widget = Widget.objects.get(slug=slug)
    except Widget.DoesNotExist:
        return HttpResponse(status=404)

    payload = json.dumps(render_widget(widget))
    return render_to_response('widgets/widget.js', {'payload': payload, 'target': widget.target_id},
                              mimetype="text/javascript")

def widget_content(request, slug):
    """
    View that renders the widget using its template.
    """
    try:
        widget = Widget.objects.get(slug=slug)
    except Widget.DoesNotExist:
        return HttpResponse(status=404)
    return HttpResponse(render_widget(widget), status=200,
                        mimetype=widget.template.content_type)

def render_widget(widget, items=None):
    """Returns an HTML string of the widget rendered using its template.
    """
    if items is None:
        items = widget.fetch_items()
    info = {
        'items': [template_context_for_item(x, widget) for x in items],
        'widget': widget
    }
    # TODO: cache template compilation
    code = widget.template.code
    if not ' load eb ' in code:
        # Convenience so template authors don't have to remember this detail.
        code = '{% load eb %}\n' + code
    t = Template(code)
    return t.render(Context(info))

def template_context_for_item(newsitem, widget=None):
    # try to make something ... reasonable for use in
    # templates.
    ctx = {
        'attributes': [],
        'attributes_by_name': {},
        '_item': newsitem,  # cached in case downstream code really needs it.
    }
    for att in newsitem.attributes_for_template():

        attr = {
            'name': att.sf.name,
            'title': att.sf.smart_pretty_name(),
            'display': att.sf.display
        }

        vals = [x['value'] for x in att.value_list()]
        if len(vals) == 1:
            attr['value'] = vals[0]
            attr['is_list'] = False
        else:
            attr['value'] = vals
            attr['is_list'] = True
        ctx['attributes'].append(attr)
        ctx['attributes_by_name'][att.sf.name] = attr

    # newsitem fields
    ctx['id'] = newsitem.id
    ctx['schema'] = newsitem.schema
    ctx['title'] = newsitem.title
    ctx['description'] = newsitem.description
    ctx['pub_date'] = newsitem.pub_date
    ctx['item_date'] = newsitem.item_date
    ctx['location'] = {}
    if newsitem.location:
        # TODO: Is centroid really what we want for non-Point geometries?
        ctx['location']['lon'] = newsitem.location.centroid.x
        ctx['location']['lat'] = newsitem.location.centroid.y
        ctx['location']['geom'] = newsitem.location

    ctx['location']['name'] = newsitem.location_name

    ctx['external_url'] =  newsitem.url
    if newsitem.schema.has_newsitem_detail:
        ctx['internal_url'] = 'http://' + settings.EB_DOMAIN + newsitem.item_url()

    if widget is not None:
        if widget.item_link_template and widget.item_link_template.strip():
            try:
                ctx['internal_url'] = _eval_item_link_template(widget.item_link_template,
                                                               {'item': ctx, 'widget': widget})
            except:
                logger.exception('failed to create link for widget')
                # TODO: some sort of error handling
                return '#error'

    return ctx

def _eval_item_link_template(template, context):
    t = Template(template)
    return t.render(Context(context)).strip()

##########################################################################
#
# special widget administration API views
#
##########################################################################

@login_required
def widget_admin_list(request):
    """
    List of widgets for custom separate admin UI
    """
    if not request.user.is_superuser == True:
        return HttpResponse("You must be an administrator to access this function.",
                            status=401)
    ctx = RequestContext(request, {'widgets': Widget.objects.all()})
    return render_to_response('widgets/stickylist.html', ctx)


@login_required
def widget_admin(request, slug):
    """
    Custom view for administering pinned items
    """
    if not request.user.is_superuser == True:
        return HttpResponse("You must be an administrator to access this function.", status=401)

    widget = get_object_or_404(Widget.objects, slug=slug)

    ctx = RequestContext(request, {'widget': widget,
                                   'max_items_range': range(widget.max_items),
                                   })
    return render_to_response('widgets/sticky.html', ctx)



@login_required
def ajax_widget_raw_items(request, slug):
    """
    gets a list of 'raw' items in a widget (does not include
    pinned items), as a JSON object.

    start and count parameters may be added as query parameters
    to retrieve more items.  by default the call returns items
    in the range [0,widget.max_items)

    Example of the structure returned:

    .. code-block:: javascript

     {
        "items": [
            {
                "id': 1234,
                "title": "Some Item",
            }
            // ...
        ],
        "start": 0
     }

    """
    if not request.user.is_superuser == True:
        return HttpResponse("You must be an administrator to access this function.", status=401)

    widget = get_object_or_404(Widget.objects, slug=slug)

    try:
        start = int(request.GET.get('start', 0))
        count = int(request.GET.get('count', widget.max_items))
    except ValueError:
        return HttpResponse(status=400)

    items = widget.raw_item_query(start, count).all()
    item_infos = []
    for item in items:
        item_info = {
            'id': item.id,
            'title': item.title,
        }
        item_infos.append(item_info)

    info = {'items': item_infos, 'start': start}
    return HttpResponse(json.dumps(info), mimetype="application/json")


@login_required
def ajax_widget_pins(request, slug):
    '''
    view that exposes and allows setting of "pinned" items
    in a widget.

    Example of the structure returned/accepted:

    .. code-block:: javascript

      {
        "items": [
            {
                "id': 1234,
                "index": 0,
                "title": "Some Item",
                "expiration_date": "12/30/2040",
                "expiration_time": "09:45 PM" // 12 hour
            },
            {
                "id': 1235,
                "index": 7,
                "title": "Some Other Item",
                // no expiration
            },
            // ...
         ]
      }
    '''

    if not request.user.is_superuser == True:
        return HttpResponse("You must be an administrator to access this function.", status=401)

    widget = get_object_or_404(Widget.objects, slug=slug)

    if request.method == 'GET':
        return _get_ajax_widget_pins(request, widget)
    elif request.method == 'POST': 
        return _set_ajax_widget_pins(request, widget)
    else:
        return HttpResponseNotAllowed(["GET", "PUT"])

def _get_ajax_widget_pins(request, widget):
    # Retrieves a json structure that describes the
    # items currently "pinned" in a widget as described
    # in ajax_widget_pins.
    pins = list(PinnedItem.objects.filter(widget=widget).all())
    pins.sort(key=attrgetter('item_number'))

    item_infos = []
    for pin in pins:
        item_info = {
            'id': pin.news_item.id,
            'title': pin.news_item.title,
            'index': pin.item_number
        }
        if pin.expiration_date is not None:
            item_info['expiration_date'] = pin.expiration_date.date().strftime('%m/%d/%Y')
            item_info['expiration_time'] = pin.expiration_date.time().strftime('%I:%M%p')

        item_infos.append(item_info)

    info = {'items': item_infos}
    return HttpResponse(json.dumps(info), mimetype="application/json")

def _set_ajax_widget_pins(request, widget):
    # Sets pinned items in a widget based a json structure
    # as described in ajax_widget_pins.
    #
    # Any existing pins are removed and replaced by the pins described in
    # the given structure.
    try:
        pin_info = json.loads(request.raw_post_data)
    except ValueError:
        logger.exception('bad json')
        return HttpResponse("Unable to parse json body", status=400)

    new_pins = []
    for pi in pin_info['items']:
        ni = NewsItem.objects.get(id=pi['id'])
        new_pin = PinnedItem(news_item=ni, widget=widget, item_number=pi['index'])
        expiration = None
        if pi.get('expiration_date'):
            try:
                expiration = datetime.datetime.strptime(pi['expiration_date'], '%m/%d/%Y')
            except ValueError:
                return HttpResponse("unable to parse expiration date %s" % pi['expiration_date'], status=400)
        if pi.get('expiration_time', '').strip():
            if expiration is None:
                return HttpResponse("cannot specify expiration time without expiration date", status=400)
            # Be slightly broad about time formats accepted.
            etime = pi['expiration_time'].replace(' ', '').lower()
            try:
                if etime.endswith('am') or etime.endswith('pm'):
                    etime = datetime.datetime.strptime(etime, '%I:%M%p')
                else:
                    # Assume it's 24-hour.
                    etime = datetime.datetime.strptime(etime, '%H:%M')
            except ValueError:
                return HttpResponse("unable to parse expiration time %s" % pi['expiration_time'], status=400)
            expiration = expiration.replace(hour=etime.hour, minute=etime.minute)

        if expiration is not None: 
            new_pin.expiration_date = expiration
        new_pins.append(new_pin)

    # destroy current pins
    PinnedItem.objects.filter(widget=widget).delete()
    for pin in new_pins: 
        pin.save()

    if len(new_pins) > 0: 
        return HttpResponse(status=201)
    else: 
        return HttpResponse(status=200)

########NEW FILE########
__FILENAME__ = fix_newsitem_locations
#   Copyright 2011 OpenPlans, and contributors
#
#   This file is part of ebpub
#
#   ebpub is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   ebpub is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with ebpub.  If not, see <http://www.gnu.org/licenses/>.
#

from ebpub.db.models import NewsItem
from ebpub.utils.geodjango import get_default_bounds, intersects_metro_bbox
from django.contrib.gis.geos import Point

def main(dry_run=True):
    items_outside = list(NewsItem.objects.exclude(location__intersects=get_default_bounds()))
    print "Items outside bounds: %s" % len(items_outside)
    for item in items_outside:
        fix_newsitem_coords(item, dry_run)
        print "-" * 60
    items_no_loc_name = list(NewsItem.objects.filter(location_name=''))
    print
    print "=" * 60
    print "Items with no location name: %s" % len(items_no_loc_name)
    for item in items_no_loc_name:
        fix_newsitem_loc_name(item, dry_run)
        print "-" * 60


def fix_newsitem_loc_name(item, dry_run=True):
    # Fall back to reverse-geocoding.
    from ebpub.geocoder import reverse
    fixed = False
    try:
        block, distance = reverse.reverse_geocode(item.location)
        print " Reverse-geocoded point to %r" % block.pretty_name
        item.location_name = block.pretty_name
        fixed = True
    except reverse.ReverseGeocodeError:
        print " Failed to reverse geocode %s for %s" % (item.location.wkt, item)
        item.location_name = u''
    if fixed and not dry_run:
        print "Saving %s" % item
        item.save()
    if not fixed:
        print "Couldn't fix %s" % item

def fix_newsitem_coords(item, dry_run=True):
    """
    Try to fix a (presumably bad) NewsItem geometry by reversing its
    coordinates, or reverse-geocoding if it has a location name; use
    whatever works.

    If dry_run=False, the item will be saved.
    """
    if item.location is not None:
        loc = item.location.centroid
        print "Found %r outside bounds at %s, %s" % (item.title,
                                                     loc.x, loc.y)
    else:
        loc = None
        print "NO location on %s: %s" % (item.schema.slug, item.title)
    fixed = False
    if item.location_name:
        from ebpub.geocoder import SmartGeocoder, AmbiguousResult
        try:
            result = SmartGeocoder().geocode(item.location_name)
        except AmbiguousResult, e:
            print "...%d choices, picking the first one" % len(e.choices)
            result = e.choices[0]
        except:
            result = None
        if result and intersects_metro_bbox(result['point']):
            print "Fixing %r by geocoding %r" % (item.title, item.location_name)
            item.location = result['point']
            fixed = True

    if loc and not fixed:
        newloc = Point(loc.y, loc.x)
        if intersects_metro_bbox(newloc):
            print "Fixing %r by flipping bounds" % item.title
            item.location = newloc
            fixed = True

    if fixed:
        if not dry_run:
            print "saving %s" % item
            item.save()
    else:
        print "Can't fix %s" % item
        if not dry_run:
            print "Deleting %s" % item
            item.delete()

if __name__ == '__main__':
    import sys
    dry_run = int(sys.argv[1])
    main(dry_run=dry_run)

########NEW FILE########
__FILENAME__ = make_bootstrap
#!/usr/bin/env python
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#


if __name__ == '__main__':
    import sys
    import virtualenv

    if len(sys.argv) < 3: 
        print 'usage: %s <in> <out>'
        sys.exit(0)

    in_file = sys.argv[1]
    out_file = sys.argv[2]

    extras = open(in_file).read()
    output = virtualenv.create_bootstrap_script(open(in_file).read())
    f = open(out_file, 'w').write(output)

########NEW FILE########
__FILENAME__ = random_news
#!/usr/bin/env python
# encoding: utf-8

#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#


import datetime
import random
import sys
import uuid
import gibberis.ch.freeform


import os
if not os.environ.get('DJANGO_SETTINGS_MODULE'):
    print "Please set DJANGO_SETTINGS_MODULE to your projects settings module"
    sys.exit(1)
print "Using DJANGO_SETTINGS_MODULE=%s" % os.environ['DJANGO_SETTINGS_MODULE']

from ebpub.db.models import NewsItem, Schema
from ebpub.streets.models import Block
lookup_vals = ['lookup_%03d' % i for i in range(300)]

cache = {}
def get_text_corpus():
    if not cache.has_key('corpus'):
        #url = 'http://www.gutenberg.org/ebooks/33661.txt.utf8'
        url = 'http://www.archive.org/stream/captainblood01965gut/cpbld11.txt'
        outfile = '/tmp/' + url.split('/')[-1]
        if not os.path.exists(outfile):
            import urllib2
            data = urllib2.urlopen(url).read()
            open(outfile, 'w').write(data)
        cache['corpus'] = open(outfile).read()
    return cache['corpus']

def save_random_newsitem(schema, i, block, future=False):
    title = '%d Random %s %s' % (i, schema.name, uuid.uuid4())
    print "Creating %r" % title
    item = NewsItem()
    item.title = title
    item.schema = schema
    item.description = gibberis.ch.freeform.random_text(get_text_corpus(), 300)
    item.url = 'http://example.com/%s/%d' % (schema.slug, i)
    if future:
        date = random_datetime(7.0)
    else:
        date = random_datetime(-7.0)
    item.pub_date = date
    item.item_date = date.date()
    item.location_name = block.pretty_name
    try:
        item.location = block.geom.centroid
    except AttributeError:
        item.location = block.geom
    # Populate the attributes.

    attrs = {}
    for schemafield in schema.schemafield_set.all():
        attrs[schemafield.name] = random_schemafield_value(schemafield)

    print "Added: %s on %s at %s (%s)" % (item.title, item.item_date, item.location_name, item.location.wkt)

    # Need to save before we can have foreign keys from the attributes
    # or subclass.
    item.save()
    if attrs:
        item.attributes = attrs
        # That implicitly saves in the old model, but not the new.
        item.save()


def main(count, slugs, opts):
    """
    Generates `count` random newsitems for each schema in `slugs`.
    """
    schemas = Schema.objects.filter(slug__in=slugs)
    if len(schemas) < len(slugs):
        raise ValueError("Bad schema argument. Valid schemas: %s"
                         % ', '.join([s.slug for s in Schema.objects.all()]))
    blocks = get_random_blocks()
    for schema in schemas:
        last_newsitem = NewsItem.objects.order_by('-id')[:1]
        if last_newsitem:
            last_newsitem_id = last_newsitem[0].id
        else:
            last_newsitem_id = 1
        for i in range(int(count)):
            block = random.choice(blocks)
            save_random_newsitem(schema, i + 1 + last_newsitem_id, block, future=opts.future)

def get_random_blocks():
    try:
        last_block_id = Block.objects.order_by('-id')[:1][0].id
    except IndexError:
        raise IndexError("It seems you don't have any Blocks loaded.")
    ids = random.sample(xrange(1, last_block_id), 1000)
    blocks = list(Block.objects.filter(id__in=ids))
    random.shuffle(blocks)
    return blocks

def random_datetime(max_days):
    dt = datetime.datetime.now() + datetime.timedelta(
        random.uniform(0.0, max_days))
    return dt


def random_schemafield_value(schemafield):
    value = None
    if schemafield.is_lookup:
        from ebpub.db.models import Lookup
        value = []
        if schemafield.is_many_to_many_lookup():
            _count = 4
        else:
            _count = 1
        for i in range(_count):
            lookup = Lookup.objects.get_or_create_lookup(
                schemafield, random.choice(lookup_vals))
            if not (lookup.description and lookup.name):
                lookup.description = lookup.slug + ' description'
                lookup.name = lookup.slug + ' name'
                lookup.save()
            value.append(lookup.id)
        value = ','.join([str(v) for v in value])
    elif schemafield.datatype == 'int':
        value = random.randint(1, 100)
    elif schemafield.datatype == 'bool':
        value = random.choice((True, False))
    elif schemafield.datatype == 'varchar':
        value = gibberis.ch.freeform.random_text(get_text_corpus(), 15)
    elif schemafield.datatype == 'text':
        value = gibberis.ch.freeform.random_text(get_text_corpus(), 100)
    elif schemafield.datatype == 'datetime':
        value = random_datetime(7.0)
    elif schemafield.datatype == 'date':
        value = random_datetime(7.0).date()
    elif schemafield.datatype == 'time':
        value = random_datetime(7.0).time()
    else:
        raise NotImplementedError("can't handle type %s" % schemafield.datatype)
    if value is None:
        raise ValueError("couldn't cook a value for %s.%s" % (
                schemafield.schema, schemafield.name))
    return value


if __name__ == '__main__':
    import optparse
    usage = "Usage: %s [options] N schema [schema2...]\n" % sys.argv[0]
    usage += "Generates N randomly-placed articles for each schema.\n"
    usage += "Try -h for full list of options."
    parser = optparse.OptionParser(usage=usage)
    parser.add_option('-f', '--future', help='Generate dates in the future.',
                      action='store_true', default=False)
    opts, args = parser.parse_args(sys.argv[1:])
    try:
        count = int(args[0])
        schemas = args[1:]
        if not schemas:
            raise IndexError()
    except (IndexError, TypeError, ValueError):
        parser.print_usage()
        sys.exit(1)
    sys.exit(main(count, schemas, opts))

########NEW FILE########
__FILENAME__ = crime_report_schema
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

#
# This code creates a custom news item Schema, 
# custom attributes and a NewsItem of the 
# type.  For a narrative description, see 
# The accompanying documentation in docs/schema.rst
#

from ebpub.db.models import Schema, SchemaField, NewsItem
from datetime import datetime

if __name__ == '__main__':
    # create schema
    crime_report = Schema()
    crime_report.indefinite_article = 'a'
    crime_report.name = "Crime Report"
    crime_report.plural_name = "Crime Reports"
    crime_report.slug = 'crimereport'
    crime_report.min_date = datetime.utcnow()
    crime_report.last_updated = datetime.utcnow()
    crime_report.has_newsitem_detail = True
    crime_report.is_public = True
    crime_report.save()

    # custom field officer name 
    officer = SchemaField()
    officer.schema = crime_report
    officer.pretty_name = "Reporting Officer's Name"
    officer.pretty_name_plural = "Reporting Officer's Names"
    officer.real_name = 'varchar01'
    officer.name = 'officer'
    officer.save()

    # custom field crime type 
    crime_name = SchemaField()
    crime_name.schema = crime_report
    crime_name.pretty_name = "Crime Type"
    crime_name.pretty_plural_name = "Crime Types"
    crime_name.real_name = "varchar02"
    crime_name.name = "crime_type"
    crime_name.save()

    # custom field crime code
    crime_code = SchemaField()
    crime_code.schema = crime_report
    crime_code.pretty_name = "Crime Code"
    crime_code.pretty_plural_name = "Crime Codes"
    crime_code.real_name = "int01"
    crime_code.name = "crime_code"
    crime_code.save()

    # create a Crime Report!
    report = NewsItem()
    report.schema = crime_report
    report.title = "Hooligans causing disturbance downtown"
    report.location_name = "123 Fakey St."
    report.item_date = datetime.utcnow()
    report.pub_date = datetime.utcnow()
    report.description = "Blah Blah Blah"
    report.save()
    report.attributes['officer'] = "John Smith"
    report.attributes['crime_type'] = "Disturbing The Peace"
    report.attributes['crime_code'] = 187

########NEW FILE########
__FILENAME__ = forms
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Forms for use in the openblock admin UI.
"""
# -*- coding: utf-8 -*-
from django import forms
from django.utils import safestring
from ebdata.scrapers.general.spreadsheet import retrieval
from ebpub.db.bin import import_locations
from ebpub.db.models import LocationType
from ebpub.db.models import Schema, Lookup
from ebpub.metros.allmetros import get_metro
from re import findall
from tasks import CENSUS_STATES, download_state_shapefile, import_blocks_from_shapefiles, import_locations_from_shapefile
from tempfile import mkstemp, mkdtemp
import glob
import os
import zipfile
import logging

logger = logging.getLogger('obadmin.admin.forms')

class SchemaLookupsForm(forms.Form):
    def __init__(self, lookup_ids, *args, **kwargs):
        super(SchemaLookupsForm, self).__init__(*args, **kwargs)
        for look_id in lookup_ids:
            self.fields['%s-name' % look_id] = forms.CharField(widget=forms.TextInput(attrs={'size': 50}))
            self.fields['%s-name' % look_id].lookup_obj = Lookup.objects.get(id=look_id)
            self.fields['%s-description' % look_id] = forms.CharField(required=False, widget=forms.Textarea())

class BlobSeedForm(forms.Form):
    rss_url = forms.CharField(max_length=512, widget=forms.TextInput(attrs={'size': 80}))
    site_url = forms.CharField(max_length=512, widget=forms.TextInput(attrs={'size': 80}))
    rss_full_entry = forms.BooleanField(required=False)
    pretty_name = forms.CharField(max_length=128, widget=forms.TextInput(attrs={'size': 80}))
    guess_article_text = forms.BooleanField(required=False)
    strip_noise = forms.BooleanField(required=False)

def save_file(f, suffix=''):
    import mimetypes
    if not suffix:
        # Try to come up with a reasonable suffix, since sometimes I
        # care what this thing is.  First try the declared type...
        mtype = None
        if hasattr(f, 'content_type'):
            mtype = f.content_type
            # ... although sometimes this returns nothing;
            # eg. mimetypes doesn't know about 'application/msexcel'
            suffix = mimetypes.guess_extension(mtype)
    if not suffix:
        mtype = None
        if hasattr(f, 'name'):
            mtype = mimetypes.guess_type(f.name)[0]
        if not mtype:
            # Fall back to guessing on the file's content.
            import magic
            guesser = magic.Magic(mime=True)
            f.file.seek(0)
            mtype = guesser.from_buffer(f.file.read(2048))
            f.file.seek(0)
        if mtype:
            if mtype == 'text/plain':
                # Special case since mimetypes.guess_extension()
                # returns something arbitrarily absurd for this, like .ksh
                suffix = '.txt'
            else:
                suffix = mimetypes.guess_extension(mtype)
        #print "GUESSED SUFFIX", suffix
    fd, name = mkstemp(suffix)
    fp = os.fdopen(fd, 'wb')
    for chunk in f.chunks():
        fp.write(chunk)
    fp.close()
    return name


class ImportZipcodeShapefilesForm(forms.Form):

    # Don't have one chosen by default.
    no_state = ''
    state = forms.TypedChoiceField(required=True,
                                   choices=((no_state, no_state),) + CENSUS_STATES,
                                   empty_value=no_state)
    zip_codes = forms.CharField(required=True, widget=forms.Textarea())

    def save(self):
        if not self.is_valid():
            return False

        zip_codes = findall('\d{5}', self.cleaned_data['zip_codes'])
        download_state_shapefile(self.cleaned_data['state'], zip_codes)

        return True


class UploadShapefileForm(forms.Form):
    """
    Upload a shapefile, from which you can use PickShapefileLayerForm
    to choose a layer to import.
    """
    zipped_shapefile = forms.FileField(
        required=True,
        help_text=('Note that self-extracting .exe files are not supported. If you '
                   'have one of those, extract it, then create a normal zip file '
                   'from its contents. Sorry for the inconvenience.'))

    def save(self):
        if not self.is_valid():
            return False
        self.shp_path = self.save_shapefile(self.cleaned_data['zipped_shapefile'])
        return True

    def save_shapefile(self, zipped_shapefile):
        # Unpack the zipped shapefile archive, gdal needs all
        # the files to be extracted and in the same directory.
        fd, zip_name = mkstemp('.zip')
        self.write_chunks(os.fdopen(fd, 'wb'),  zipped_shapefile)
        zfile = zipfile.ZipFile(zip_name)
        outdir = mkdtemp(suffix='-location-shapefiles')
        zfile.extractall(path=outdir)
        os.unlink(zip_name)
        # TODO: Some zipped shapefiles contain multiple .shp files!
        # We'll just assume you want the first one.
        shapefiles = glob.glob(os.path.join(outdir, '*shp'))
        if not shapefiles:
            for name in os.listdir(outdir):
                # Maybe there's a subdirectory?
                shapefiles = glob.glob(os.path.join(outdir, name, '*shp'))
                if shapefiles:
                    break
        assert shapefiles
        shapefile = shapefiles[0]
        return os.path.abspath(shapefile)

    def write_chunks(self, fp, f):
        try:
            for chunk in f.chunks():
                fp.write(chunk)
        finally:
            fp.close()


class PickShapefileLayerForm(forms.Form):
    """
    Once a layer is chosen from a shapefile, does the work of actually
    loading the Locations.
    """
    shapefile = forms.CharField(required=True)

    # Would be nice to use a RelatedFieldWidgetWrapper here so we get
    # the "+" button to add new LocationTypes, but I haven't dug deep
    # enough to see how to rig that in to this context... AFAICT it
    # needs to wrap the widget instance, not just the widget class.
    location_type = forms.ModelChoiceField(queryset=LocationType.objects.all(),
                                           required=True,
                                           )
    layer = forms.IntegerField(required=True)
    name_field = forms.CharField(
        required=True,
        help_text='Which field of each feature to use as the name of the imported location.')
    filter_bounds = forms.BooleanField(
        required=False, initial=False,
        help_text="Whether to exclude locations that don't intersect with our metro bounding box.")

    failure_msgs = ()

    def clean(self):
        super(PickShapefileLayerForm, self).clean()
        if 'shapefile' in self.cleaned_data and 'layer' in self.cleaned_data:
            shapefile = os.path.abspath(self.cleaned_data['shapefile'])
            try:
                # We don't do anything with this yet, just verify that it's openable.
                x = import_locations.layer_from_shapefile(shapefile, self.cleaned_data['layer'])
                del(x)
            except Exception as e:
                self._errors['layer'] = self.error_class([u"Error loading the layer from the file. %s" % unicode(e)])
        return self.cleaned_data

    def save(self):
        self.failure_msgs = []
        if not self.is_valid():
            self.failure_msgs.append(safestring.mark_safe(self.errors.as_text()))
            return False
        shapefile = os.path.abspath(self.cleaned_data['shapefile'])
        try:
            import_locations_from_shapefile(
                shapefile,
                self.cleaned_data['layer'],
                self.cleaned_data['location_type'].id,
                self.cleaned_data['name_field'],
                self.cleaned_data.get('filter_bounds'))
            return True
        except Exception as e:
            self.failure_msgs.append(u"Unhandled exception, see server log: %s" % e)
            logger.exception('Unhandled exception importing shapefile:')
            return False


class ImportBlocksForm(forms.Form):
    edges = forms.FileField(label='All Lines (tl...edges.zip)',
                            required=True)
    featnames = forms.FileField(label='Feature Names Relationship (tl...featnames.zip)',
                                required=True)
    faces = forms.FileField(label='Topological Faces (tl...faces.zip)', required=True)
    place = forms.FileField(label='Place (Current) (tl..._place.zip)', required=True)

    city = forms.CharField(max_length=30, help_text="Optional: skip features that don't include this city name", required=False)

    fix_cities = forms.BooleanField(
        help_text="Optional: try to override each block's city by finding an overlapping Location that represents a city. Only useful if you've set up multiple_cities=True and set city_location_type in your settings.METRO_LIST *and* have some appropriate Locations of that type already created.",
        required=False, initial=bool(get_metro().get('multiple_cities', False)))

    reset = forms.BooleanField(
        help_text="Delete all existing blocks and start over. Implies regenerating intersections too.",
        required=False, initial=False)

    regenerate_intersections = forms.BooleanField(
        help_text="Regenerate all Intersections and BlockIntersections after loading Blocks. It's always safe to say Yes. Say No only if you are sure you are going to later load more blocks from another set of shapefiles; then you must say Yes when loading your last batch.  No is a lot faster, Yes is safer.",
        required=False, initial=True)

    def save(self):
        if not self.is_valid():
            return False

        import_blocks_from_shapefiles(
            save_file(self.cleaned_data['edges'], suffix='.zip'),
            save_file(self.cleaned_data['featnames'], suffix='.zip'),
            save_file(self.cleaned_data['faces'], suffix='.zip'),
            save_file(self.cleaned_data['place'], suffix='.zip'),
            city=self.cleaned_data['city'],
            fix_cities=self.cleaned_data['fix_cities'],
            regenerate_intersections=self.cleaned_data['regenerate_intersections'],
            reset=self.cleaned_data['reset'],
        )

        return True


def import_items_from_spreadsheets(items_file, schema, mapping_file=None,
                                   unique_fields=None):
    """
    Imports NewsItems from the given files; returns
    (number added, number changed, number skipped).
    """
    scraper = retrieval.SpreadsheetScraper(items_file,
                                           map_sheet_file=mapping_file,
                                           schema_slug=schema.slug,
                                           unique_fields=unique_fields,
                                           )
    scraper.update()
    return (scraper.num_added, scraper.num_changed, scraper.num_skipped)


class ImportNewsForm(forms.Form):

    items_file = forms.FileField(label='NewsItems spreadsheet',
                                 required=True)

    schema = forms.ModelChoiceField(queryset=Schema.objects.all(),
                                    required=True,
                                    )

    mapping_file = forms.FileField(label='Mapping spreadsheet',
                                   help_text=u'Describes which columns of the above spreadsheet are used for which fields of a NewsItem.  If not provided, the NewsItem spreadsheet must have column headers that match fields of NewsItem and/or attributes of the chosen Schema.',
                                   required=False)

    unique_fields = forms.MultipleChoiceField(
        label='Unique fields',
        help_text=u'Which NewsItem fields can be used to uniquely identify NewsItems of this schema.',
        choices = [(name, name) for name in retrieval.get_default_unique_field_names()],
        required=False,
        )


    added = updated = skipped = 0

    def save(self):
        if not self.is_valid():
            return False
        added, updated, skipped = import_items_from_spreadsheets(
            save_file(self.cleaned_data['items_file']),
            self.cleaned_data['schema'],
            mapping_file=self.cleaned_data.get('mapping_file') and save_file(self.cleaned_data['mapping_file']),
            unique_fields=self.cleaned_data['unique_fields'],
            )
        self.added = added
        self.updated = updated
        self.skipped = skipped
        return True

########NEW FILE########
__FILENAME__ = models
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

# No models, but we need this file so Django treats this package as an app.

########NEW FILE########
__FILENAME__ = sites
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

from django.contrib.admin import AdminSite
import ebpub.accounts.forms

class OpenblockAdminSite(AdminSite):
    """
    A custom AdminSite.

    This admin site specialized to use the openblock login methods
    instead of the django.contrib.auth methods.
    """

    login_form = ebpub.accounts.forms.AdminLoginForm
    login_template = 'accounts/login_form.html'

    logout_template = 'accounts/logout_form.html'

    def get_urls(self):
        """
        Add some extra URLs to the admin site, as per
        https://docs.djangoproject.com/en/dev/ref/contrib/admin/#adding-views-to-admin-sites
        """
        from obadmin.admin.urls import urlpatterns as local_urls

        url_patterns = local_urls
        url_patterns += AdminSite.get_urls(self)

        return url_patterns

site = OpenblockAdminSite()

def autodiscover():
    global site
    # workaround the somewhat short-sighted admin registry convention
    # by copying the global admin site's registry after autodiscover,
    # because our ModelAdmins got registered with the global admin site.
    from copy import copy
    from django.contrib import admin
    admin.autodiscover()
    site._registry = copy(admin.site._registry)

    # unregister the django.contrib.auth.models, openblock
    # uses specialized versions.
    from django.contrib.auth.models import User, Group
    site.unregister([User, Group])

    # Also, our registered ModelAdmin instances have a reference to
    # the default admin site.  This has implications for eg. the admin
    # site login form, which is looked up via that reference.  Patch
    # those so we get the right login form. Sigh.
    for admin_instance in site._registry.values():
        admin_instance.admin_site = site

########NEW FILE########
__FILENAME__ = tasks
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#
# -*- coding: utf-8 -*-

from background_task import background
from django.conf import settings
from django.contrib.gis.geos import GEOSGeometry
from ebdata.retrieval.retrievers import Retriever
from tempfile import mkdtemp
from zipfile import ZipFile
from ebpub.db.bin.import_locations import layer_from_shapefile
from ebpub.db.bin.import_locations import LocationImporter
from ebpub.db.bin.import_zips import ZipImporter
from ebpub.streets.blockimport.tiger.import_blocks import TigerImporter
from ebpub.streets.bin import populate_streets
import glob
import logging
import os
import shutil
import tempfile

logger = logging.getLogger('obadmin.admin.tasks')

# These may look suspiciously like numbers, but we're matching identifiers
# by the Census, and who knows what they'll do. Extracted from the source of
# http://www2.census.gov/cgi-bin/shapefiles2009/national-files
CENSUS_STATES = (
    ("01", "Alabama"),
    ("02", "Alaska"),
    ("60", "American Samoa"),
    ("04", "Arizona"),
    ("05", "Arkansas"),
    ("06", "California"),
    ("08", "Colorado"),
    ("69", "Commonwealth of the Northern Mariana Islands"),
    ("09", "Connecticut"),
    ("10", "Delaware"),
    ("11", "District of Columbia"),
    ("12", "Florida"),
    ("13", "Georgia"),
    ("66", "Guam"),
    ("15", "Hawaii"),
    ("16", "Idaho"),
    ("17", "Illinois"),
    ("18", "Indiana"),
    ("19", "Iowa"),
    ("20", "Kansas"),
    ("21", "Kentucky"),
    ("22", "Louisiana"),
    ("23", "Maine"),
    ("24", "Maryland"),
    ("25", "Massachusetts"),
    ("26", "Michigan"),
    ("27", "Minnesota"),
    ("28", "Mississippi"),
    ("29", "Missouri"),
    ("30", "Montana"),
    ("31", "Nebraska"),
    ("32", "Nevada"),
    ("33", "New Hampshire"),
    ("34", "New Jersey"),
    ("35", "New Mexico"),
    ("36", "New York"),
    ("37", "North Carolina"),
    ("38", "North Dakota"),
    ("39", "Ohio"),
    ("40", "Oklahoma"),
    ("41", "Oregon"),
    ("42", "Pennsylvania"),
    ("72", "Puerto Rico"),
    ("44", "Rhode Island"),
    ("45", "South Carolina"),
    ("46", "South Dakota"),
    ("47", "Tennessee"),
    ("48", "Texas"),
    ("49", "Utah"),
    ("50", "Vermont"),
    ("78", "Virgin Islands of the United States"),
    ("51", "Virginia"),
    ("53", "Washington"),
    ("54", "West Virginia"),
    ("55", "Wisconsin"),
    ("56", "Wyoming"),
)

@background
def download_state_shapefile(state, zipcodes):
    print "Starting download"
    n = dict(CENSUS_STATES)[state].upper().replace(' ', '_')
    name         = "tl_2009_%s_zcta5" % state
    zip_filename = "%s.zip" % name
    cache_dir    = getattr(settings, 'HTTP_CACHE', tempfile.gettempdir())
    path         = os.path.join(cache_dir, zip_filename)
    url = "http://tigerline.census.gov/geo/tiger/TIGER2009/%(id)s_%(name)s/%(zip_filename)s" % { 'id': state, 'name': n, 'zip_filename': zip_filename }

    Retriever().cached_get_to_file(url, path)
    print "fetched %s" % url
    files = [name + ext for ext in ('.shp', '.dbf', '.prj', '.shp.xml', '.shx')]
    shapefile = os.path.join(cache_dir, '%s.shp' % name)
    # TODO: handle corrupt/incomplete/missing files zipfile
    # expected files aren't in the archive ...)
    try:
        ZipFile(path, 'r').extractall(cache_dir, files)
        print "extracted"
    except:
        logger.exception('Problem downloading zipcodes for %s' % state)
        return
    for zipcode in zipcodes:
        print "importing %s" % zipcode
        import_zip_from_shapefile(shapefile, zipcode)
        print "... ok"
    print "All zip codes done"

@background
def import_zip_from_shapefile(filename, zipcode):
    layer = layer_from_shapefile(filename, 0)
    importer = ZipImporter(layer, 'ZCTA5CE')
    try:
        importer.import_zip(zipcode)
    except:
        logger.exception('Zipcode import failed')
        return

def import_locations_from_shapefile(shapefile, layer_number, location_type,
                                    name_field, filter_bounds):
    # Not in background since this should just quickly create a bunch of
    # import_location() jobs.
    try:
        layer = layer_from_shapefile(shapefile, layer_number)
        features = sorted(layer, key = lambda f: f.get(name_field))
        for i, feature in enumerate(features):
            name = feature.get(name_field)
            import_location(shapefile, layer_number, location_type, name, feature.geom.wkt, filter_bounds, display_order=i)
    except:
        logger.exception("Location import failed")
    # Unfortunately, since everythign runs asynchronously,
    # we don't know when the shapefile is safe to delete.
    # At least it's in $TMPDIR :(


@background
def import_location(shapefile, layer_number, location_type, name, wkt, filter_bounds, display_order):
    # Passing WKT because background functions need all their args to
    # be json-serializable.
    try:
        layer = layer_from_shapefile(shapefile, layer_number)
        importer = LocationImporter(layer, location_type,
                                    filter_bounds=filter_bounds)
        geom = GEOSGeometry(wkt)
        importer.create_location(name, location_type, geom,
                                 display_order=display_order)
    except:
        logger.exception("Location import of %s failed" % name)


@background
def import_blocks_from_shapefiles(edges, featnames, faces, place, city=None,
                                  fix_cities=False, regenerate_intersections=True,
                                  reset=False,
                                  ):
    # File args are paths to zip files.
    outdir = mkdtemp(suffix='-block-shapefiles')
    try:
        try:
            for path in (edges, featnames, faces, place):
                ZipFile(path, 'r').extractall(outdir)
        except Exception:
            # TODO: display error in UI
            logger.exception('Extracting zipfile failed')
            raise

        edges = glob.glob(os.path.join(outdir, '*edges.shp'))[0]
        featnames = glob.glob(os.path.join(outdir, '*featnames.dbf'))[0]
        faces = glob.glob(os.path.join(outdir, '*faces.dbf'))[0]
        place = glob.glob(os.path.join(outdir, '*place*.shp'))[0]
        tiger = TigerImporter(
            edges,
            featnames,
            faces,
            place,
            filter_city=city,
            fix_cities=fix_cities,
            reset=reset,
            )
        num_created = tiger.save()
    finally:
        shutil.rmtree(outdir)

    if regenerate_intersections:
        populate_streets_task()
    return num_created

@background
def populate_streets_task():
    populate_streets.populate_streets()
    populate_block_intersections()

@background
def populate_block_intersections():
    populate_streets.populate_block_intersections()
    populate_intersections()

@background
def populate_intersections():
    populate_streets.populate_intersections()

########NEW FILE########
__FILENAME__ = tests
#   Copyright 2012 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

from django.test import TestCase
from django.core.urlresolvers import reverse
import mock

class ViewSmokeTests(TestCase):

    # Just stupid smoke tests ... better than nothing.
    fixtures = ('crimes.json',)

    def _get_schema(self):
        from ebpub.db.models import Schema
        return Schema.objects.get(slug='crime')

    def _get_lookup(self):
        from ebpub.db.models import SchemaField
        lookup = SchemaField.objects.get(schema=self._get_schema(),
                                         is_lookup=True,
                                         name='beat')
        return lookup

    def test_index(self):
        url = reverse('admin:obadmin-old')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_schema_list(self):
        url = reverse('admin:old-schema-list')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_set_staff_cookie(self):
        url = reverse('admin:old-set-staff-cookie')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], 'http://testserver/admin/old/')

    def test_edit_schema_lookups(self):
        url = reverse('admin:old-edit-lookups',
                      args=(self._get_schema().id, self._get_lookup().id))
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_schemafield_list(self):
        url = reverse('admin:old-sf-list')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_geocoder_success_rates(self):
        url = reverse('admin:old-geocoder-success-rates')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_blob_seed_list(self):
        url = reverse('admin:old-blob-seed-list')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_add_blob_seed(self):
        url = reverse('admin:old-add-blob-seed')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_scraper_history_list(self):
        url = reverse('admin:old-scraper-history-list')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_scraper_history_schema(self):
        url = reverse('admin:old-scraper-history-schema',
                      args=(self._get_schema().slug,))
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    # TODO: This view is totally unused?
    # def test_newsitem_details(self):
    #     url = reverse()
    #     response = self.client.get(url)
    #     self.assertEqual(response.status_code, 200)

    def test_jobs_status(self):
        url = reverse('admin:jobs-status', 
                      kwargs={'appname': 'streets', 'modelname': 'blocks'})
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_import_zipcode_shapefiles(self):
        url = reverse('admin:import-zipcodes')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_upload_shapefile(self):
        url = reverse('admin:upload-shapefile')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    @mock.patch('obadmin.admin.views.DataSource')
    def test_pick_shapefile_layer(self, mock_datasource):
        url = reverse('admin:pick-shapefile-layer')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 302)
        url += '?shapefile=blah'
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_import_blocks(self):
        url = reverse('admin:import-blocks')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

    def test_import_newsitems(self):
        url = reverse('admin:import-newsitems')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)











########NEW FILE########
__FILENAME__ = urls
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf.urls.defaults import *

urlpatterns = patterns('obadmin.admin.views',
    url(r'^db/location/import-zip-shapefiles/$', 'import_zipcode_shapefiles',
        name='import-zipcodes'),
    url(r'^(?P<appname>\w+)/(?P<modelname>\w+)/jobs-status/$', 'jobs_status',
        name='jobs-status'),
    url(r'^db/location/upload-shapefile/$', 'upload_shapefile',
        name='upload-shapefile'),
    url(r'^db/location/pick-shapefile-layer/$', 'pick_shapefile_layer',
        name='pick-shapefile-layer'),
    url(r'^streets/block/import-blocks/$', 'import_blocks',
        name='import-blocks'),
    url(r'^db/newsitem/import-newsitems/$', 'import_newsitems',
        name='import-newsitems'),
    url(r'^old/$', 'index',
        name='obadmin-old'),
    url(r'^old/schemas/$', 'schema_list',
        name='old-schema-list'),
#    url(r'^old/schemas/(\d{1,6})/$', 'edit_schema'),
    url(r'^old/schemas/(\d{1,6})/lookups/(\d{1,6})/$', 'edit_schema_lookups',
        name='old-edit-lookups'),
    url(r'^old/schemafields/$', 'schemafield_list',
        name='old-sf-list'),
    url(r'^old/sources/$', 'blob_seed_list',
        name='old-blob-seed-list'),
    url(r'^old/sources/add/$', 'add_blob_seed',
        name='old-add-blob-seed'),
    url(r'^old/scraper-history/$', 'scraper_history_list',
        name='old-scraper-history-list'),
    url(r'^old/scraper-history/([-\w]{4,32})/$', 'scraper_history_schema',
        name='old-scraper-history-schema'),
    url(r'^old/set-staff-cookie/$', 'set_staff_cookie', 
        name='old-set-staff-cookie'),
    url(r'^old/geocoder-success-rates/$', 'geocoder_success_rates',
        name='old-geocoder-success-rates'),
)

########NEW FILE########
__FILENAME__ = views
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

# -*- coding: utf-8 -*-
from background_task.models import Task
from datetime import datetime, timedelta
from django.conf import settings
from django.contrib import messages
from django.contrib.admin.helpers import Fieldset
from django.contrib.gis.gdal import DataSource
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import get_object_or_404, render, render_to_response
from django.template.context import RequestContext
from django.views.decorators.csrf import csrf_protect
from ebdata.blobs.create_seeds import create_rss_seed
from ebdata.blobs.models import Seed
from ebdata.scrapers.general.spreadsheet import retrieval
from ebpub.db.models import LocationType
from ebpub.db.models import Schema, SchemaField, NewsItem, Lookup, DataUpdate
from . import forms

import logging

logger = logging.getLogger('obadmin.admin.views')

# Returns the username for a given request, taking into account our proxy
# (which sets HTTP_X_REMOTE_USER).
request_username = lambda request: request.META.get('REMOTE_USER', '') or request.META.get('HTTP_X_REMOTE_USER', '')

user_is_staff = lambda username: settings.DEBUG


def index(request):
    return render_to_response('obadmin/index.html', {})


def schema_list(request):
    s_list = []
    for s in Schema.objects.order_by('name'):
        s_list.append({
            'schema': s,
            'lookups': s.schemafield_set.filter(is_lookup=True).order_by('pretty_name_plural'),
        })
    return render_to_response('obadmin/schema_list.html', {'schema_list': s_list})


def set_staff_cookie(request):
    r = HttpResponseRedirect('../')
    r.set_cookie(settings.STAFF_COOKIE_NAME, settings.STAFF_COOKIE_VALUE)
    return r


def edit_schema_lookups(request, schema_id, schema_field_id):
    s = get_object_or_404(Schema, id=schema_id)
    sf = get_object_or_404(SchemaField, id=schema_field_id, schema__id=s.id, is_lookup=True)
    lookups = Lookup.objects.filter(schema_field__id=sf.id).order_by('name')
    lookup_ids = [look.id for look in lookups]
    if request.method == 'POST':
        form = forms.SchemaLookupsForm(lookup_ids, request.POST)
        if form.is_valid():
            # Save any lookup values that changed.
            for look in lookups:
                name = request.POST.get('%s-name' % look.id)
                description = request.POST.get('%s-description' % look.id)
                if name is not None and description is not None and (name != look.name or description != look.description):
                    look.name = name
                    look.description = description
                    look.save()
            return HttpResponseRedirect('../../../')
    else:
        initial = {}
        for look in lookups:
            initial['%s-name' % look.id] = look.name
            initial['%s-description' % look.id] = look.description
        form = forms.SchemaLookupsForm(lookup_ids, initial=initial)
    context = RequestContext(request,
                             {'schema': s, 'schema_field': sf, 'form': list(form)})
    return render_to_response('obadmin/edit_schema_lookups.html',
                              context_instance=context)


def schemafield_list(request):
    sf_list = SchemaField.objects.select_related().order_by('db_schema.name', 'display_order')
    return render_to_response('obadmin/schemafield_list.html', {'schemafield_list': sf_list})


def geocoder_success_rates(request):
    from django.db import connection
    sql = """
        select s.plural_name, count(ni.location) as geocoded, count(*) as total
        from db_newsitem ni
        inner join db_schema s
        on s.id=ni.schema_id
        group by s.plural_name
        order by count(ni.location)::float / count(*)::float;
    """
    cursor = connection.cursor()
    cursor.execute(sql)
    results = cursor.fetchall()
    schema_list = [{'name': r[0], 'geocoded': r[1], 'total': r[2], 'ratio': float(r[1]) / float(r[2])} for r in results]
    return render_to_response('obadmin/geocoder_success_rates.html', {'schema_list': schema_list})


def blob_seed_list(request):
    s_list = Seed.objects.order_by('autodetect_locations', 'pretty_name').filter(is_rss_feed=True)
    return render_to_response('obadmin/blob_seed_list.html', {'seed_list': s_list})


def add_blob_seed(request):
    if request.method == 'POST':
        form = forms.BlobSeedForm(request.POST)
        if form.is_valid():
            cd = form.cleaned_data
            create_rss_seed(cd['rss_url'], cd['site_url'], cd['rss_full_entry'], cd['pretty_name'], cd['guess_article_text'], cd['strip_noise'])
            return HttpResponseRedirect('../')
    else:
        form = forms.BlobSeedForm()
    context = RequestContext(request, {'form': form})
    return render_to_response('obadmin/add_blob_seed.html', context_instance=context)


def scraper_history_list(request):
    schema_ids = [i['schema'] for i in DataUpdate.objects.select_related().order_by('schema__plural_name').distinct().values('schema')]
    s_dict = Schema.objects.in_bulk(schema_ids)
    s_list = [s_dict[i] for i in schema_ids]
    return render_to_response('obadmin/scraper_history_list.html', {'schema_list': s_list})


def scraper_history_schema(request, slug):
    s = get_object_or_404(Schema, slug=slug)
    du_list = DataUpdate.objects.filter(schema__id=s.id).order_by('schema__name', '-update_start')
    return render_to_response('obadmin/scraper_history_schema.html', {'schema': s, 'dataupdate_list': du_list})


def newsitem_details(request, news_item_id):
    """
    Shows all of the raw values in a NewsItem for debugging.
    """
    ni = get_object_or_404(NewsItem, pk=news_item_id)
    real_names = [
        'varchar01', 'varchar02', 'varchar03', 'varchar04', 'varchar05',
        'date01', 'date02', 'date03', 'date04', 'date05',
        'time01', 'time02',
        'datetime01', 'datetime02', 'datetime03', 'datetime04',
        'bool01', 'bool02', 'bool03', 'bool04', 'bool05',
        'int01', 'int02', 'int03', 'int04', 'int05', 'int06', 'int07',
        'text01'
    ]
    schema_fields = {}
    for sf in SchemaField.objects.filter(schema=ni.schema):
        schema_fields[sf.real_name] = sf
    attributes = []
    for real_name in real_names:
        schema_field = schema_fields.get(real_name, None)
        attributes.append({
            'real_name': real_name,
            'name': schema_field and schema_field.name or None,
            'raw_value': schema_field and ni.attributes[schema_field.name] or None,
            'schema_field': schema_field,
        })
    return render_to_response('obadmin/news_item_detail.html', {
        'news_item': ni, 'attributes': attributes
    })


def jobs_status(request, appname, modelname):
    """
    Returns HTML fragment about current background tasks, intended for
    use via AJAX.
    """
    pending = Task.objects.find_available()
    running = Task.objects.filter(locked_by__isnull=False)
    # if there are old jobs and nothing's running, tell user to run tasks
    old_time = datetime.now() - timedelta(seconds=(60 * 15))
    stalled_count = pending.filter(run_at__lt=old_time).count()
    if stalled_count > 0 and pending.filter(locked_at__isnull=False).count() == 0:
        return HttpResponse("Queued jobs aren't being run. Is 'django-admin.py process_tasks' running?")

    # list instead of dict because tasks run in sequence, confusing otherwise
    if appname == 'db':
        counts = [
            {'label': u'Download state shapefile',
             'task': u'obadmin.admin.tasks.download_state_shapefile' },
            {'label': u'Import ZIP code',
             'task': u'obadmin.admin.tasks.import_zip_from_shapefile'},
            {'label': 'Import Location',
             'task': u'obadmin.admin.tasks.import_location'},
            ]
    elif appname == 'streets':
        # Don't bother discriminating further based on modelname;
        # the models here are closely related anyway.
        counts = [
            {'label': u'Import blocks from shapefile',
             'task': u'obadmin.admin.tasks.import_blocks_from_shapefiles'},
            {'label': 'Populate streets',
             'task': u'obadmin.admin.tasks.populate_streets_task'},
            {'label': 'Populate block intersections',
             'task': u'obadmin.admin.tasks.populate_block_intersections'},
            {'label': 'Populate intersections',
             'task': u'obadmin.admin.tasks.populate_intersections'},
            ]
    else:
        raise ValueError("No known tasks for %s/%s" % (appname, modelname))

    display_counts = False
    for task in counts:
        task['pending_count'] = pending.filter(task_name=task['task']).count()
        task['running_count'] = running.filter(task_name=task['task']).count()

        if task['pending_count'] or task['running_count']:
            display_counts = True

    if display_counts:
        return render(request, 'obadmin/jobs_status.html', {
          'counts': counts,
        })
    else:
        return HttpResponse("No background tasks running.")


@csrf_protect
def import_zipcode_shapefiles(request):
    form = forms.ImportZipcodeShapefilesForm(request.POST or None)
    if form.save():
        return HttpResponseRedirect('../')
    fieldset = Fieldset(form, fields=('state', 'zip_codes',))
    return render(request, 'obadmin/location/import_zip_shapefiles.html', {
      'fieldset': fieldset,
      'form': form,
    })


@csrf_protect
def upload_shapefile(request):
    form = forms.UploadShapefileForm(request.POST or None, request.FILES or None)
    if form.save():
        return HttpResponseRedirect('../pick-shapefile-layer/?shapefile=%s' % form.shp_path)

    fieldset = Fieldset(form, fields=('zipped_shapefile',))
    return render(request, 'obadmin/location/upload_shapefile.html', {
      'fieldset': fieldset,
      'form': form,
    })


@csrf_protect
def pick_shapefile_layer(request):
    form = forms.PickShapefileLayerForm(request.POST or None)
    shapefile = request.GET.get('shapefile', False)
    if not shapefile:
        shapefile = request.POST.get('shapefile', False)
    if not shapefile:
        return HttpResponseRedirect('../upload-shapefile/')
    if form.save():
        return HttpResponseRedirect('../')
    if form.failure_msgs:
        for msg in form.failure_msgs:
            messages.error(request, msg)

    try:
        ds = DataSource(shapefile)
    except Exception as e:
        ds = None
        messages.error(request, "Error opening shapefile: %s" % e)
        logger.exception("Unhandled error opening shapefile:")

    fieldset = Fieldset(form, fields=('location_type',))
    return render(request, 'obadmin/location/pick_shapefile_layer.html', {
        'shapefile': shapefile,
        'layers': ds,
        'location_types': LocationType.objects.all(),
        'fieldset': fieldset,
    })


@csrf_protect
def import_blocks(request):
    form = forms.ImportBlocksForm(request.POST or None, request.FILES or None)
    if form.save():
        return HttpResponseRedirect('../')

    fieldsets = (
        Fieldset(form, fields=('edges', 'featnames', 'faces', 'place')),
        Fieldset(form, fields=('reset', 'city', 'fix_cities', 'regenerate_intersections')),
        )

    return render(request, 'obadmin/block/import_blocks.html', {
        'fieldsets': fieldsets,
        'form': form,
    })


def import_items_from_spreadsheets(items_file, schema, mapping_file=None,
                                   unique_fields=None):
    """
    Imports NewsItems from the given files; returns
    (number added, number changed, number skipped).
    """
    scraper = retrieval.SpreadsheetScraper(items_file,
                                           map_sheet_file=mapping_file,
                                           schema_slug=schema.slug,
                                           unique_fields=unique_fields,
                                           )
    scraper.update()
    return (scraper.num_added, scraper.num_changed, scraper.num_skipped)


@csrf_protect
def import_newsitems(request):
    from ebdata.scrapers.general.spreadsheet.retrieval import get_default_unique_field_names
    form = forms.ImportNewsForm(
        request.POST or None, request.FILES or None,
        initial={'unique_fields': get_default_unique_field_names()}
        )
    if form.save():
        # TODO: Capture logging output and put that in message too?
        msg = u'%d added. %d updated. %d skipped or unchanged.' % (form.added, form.updated, form.skipped)
        msg += u' See the server error log if you need more info.'
        messages.add_message(request, messages.INFO, msg)
        return HttpResponseRedirect('./')

    fieldsets = (
        Fieldset(form, fields=('items_file', 'schema', 'mapping_file', 'unique_fields')),
        )

    return render(request, 'obadmin/import_news.html', {
        'form': form,
        'fieldsets': fieldsets,
    })


########NEW FILE########
__FILENAME__ = pavement
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Quick and Dirty OpenBlock Installer

"""
# TODO:
# test basic system expectations (libs etc)
# not even pretending unix isn't required
# verbosity is rather extreme
# network requirement is ugly, cache
# generate unique values for certain configuration params (cookies etc)
# bad existing postgis_template can interfere with install, test


import glob
import imp
import os
import traceback

from paver.easy import *

options(
    # packages to activate
    # order matters! dependants first
    openblock_packages=[
        'ebpub',
        'ebdata',
        'obadmin',
    ],

    # assumes pavement.py is in source_dir/obadmin/obadmin/pavement.py
    source_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__))),

    app='obdemo',
    # paths that will be searched for suitable postgis
    # add your own if it's custom or not listed.
    # These will be treated as patterns for glob.glob()
    postgis_paths = ['/usr/share/postgresql/8.*/contrib',
                     '/usr/share/postgresql-8.*-postgis',
                     '/usr/local/pgsql/share/contrib/postgis-1.*',
                     '/opt/local/share/postgresql84/contrib/postgis-1.*',
                     '/usr/local/Cellar/postgis/1.*/share/postgis',
    ],
    default_postgis_template='template_postgis'
)

@task
def auto(options):
    # determine the root of the virtual env
    options.env_root = os.path.abspath(os.environ.get('VIRTUAL_ENV', '.'))
    # XXX better test.
    if not os.path.exists(os.path.join(options.env_root, 'bin', 'paver')):
        print "It does not appear that your virtual environment is activated or that you are in its root."
        print "please activate your environment and try again."
        sys.exit(0)
    print "Using virtual env %s" % options.env_root

@task
def install_aggdraw(options):
    """
    workaround for broken aggdraw on certain
    platforms, may require additional fixes for
    64 bit plaforms, unclear.
    """
    os.chdir(options.env_root)
    sh('env CFLAGS=-fpermissive %s/bin/pip install aggdraw' % options.env_root)


# @task
# @needs('install_aggdraw')
# def install_ebgeo(options):
#     # XXX TODO install mapnik
#     package_dir = os.path.join(options.source_dir, 'ebgeo')
#     sh('%s/bin/pip install -e %s' % (options.env_root, package_dir))
#     print "Installed ebgeo.  Adjust your django settings to include this app."

@task
def install_gdal(options):
    """
    workaround for broken GDAL python
    package, if we need to install it.
    """
    try:
        import pkg_resources
        gdal_req = pkg_resources.Requirement.parse("GDAL")
        pkg_resources.get_distribution(gdal_req)
        # assume the version that's installed is good enough
        print "pkg_resources found an existing GDAL install, using that."
        return
    except:
        print "pkg_resources didn't find an installed GDAL."

    libgdal_version = sh('gdal-config --version', capture=True)
    gdal_req = libgdal_version.split('.')
    gdal_req = '.'.join([gdal_req[0], str(int(gdal_req[1]) + 1)])

    print "Looks like you have libgdal version %s" % libgdal_version
    print "trying to get python package version <%s" % gdal_req

    sh('%s/bin/pip install GDAL\<%s --no-install' % (options.env_root, gdal_req))
    if not os.path.exists('%s/build/GDAL' % options.env_root):
        return

    # has bad settings for gdal-config that
    # confuse setup.py
    sh('rm %s/build/GDAL/setup.cfg' % options.env_root,
       ignore_error=True)

    # also, library and include dirs are just
    # guesses from the prefix setting
    # so we dig them out of the config.

    includes = [x[2:] for x in
                sh('gdal-config --cflags', capture=True).split()
                if x.startswith('-I')]
    lib_config = sh('gdal-config --libs', capture=True)
    lib_dirs = [x[2:] for x in
            lib_config.split()
            if x.startswith('-L')]
    libs = [x[2:] for x in
            lib_config.split()
            if x.startswith('-l')]

    build = '%s/bin/python setup.py build_ext' % options.env_root
    build += ' --gdal-config=gdal-config'
    build += ' --library-dirs=%s' % ':'.join(lib_dirs)
    build += ' --libraries=%s' % ':'.join(libs)
    build += ' --include-dirs=%s' % ':'.join(includes)
    build += ' install'

    sh(build, cwd='%s/build/GDAL' % options.env_root)

@task
@needs('install_gdal')
def install_requirements(options):
    """
    install dependancies listed in the
    requirements.txt files in each package.
    """
    for package_name in options.openblock_packages:
        print "gathering dependencies for %s" % package_name
        req_file = os.path.join(options.source_dir, 
                                package_name, 
                                'requirements.txt')
        if os.path.exists(req_file):
            sh('%s/bin/pip install -r %s' % (options.env_root, req_file))

@task
@needs('install_requirements')
def apply_patches(options):
    # For anything installed with pip -e, we can apply patches
    # by dropping them in the patches/ directory.
    patch_dir = os.path.join(options.source_dir, 'patches')
    source_dir = os.path.join(options.env_root, 'src')
    if not os.path.exists(source_dir):
        # we might not have anything installed yet
        print "No src/ directory, skipping apply_patches"
        return
    assert os.path.exists(patch_dir)
    for patchfile in glob.glob(os.path.join(patch_dir, '*patch')):
        # Force-applying a patch more than once can be dangerous,
        # so we do a dry run first and check for problems.
        patchfile = os.path.abspath(patchfile)
        args = '-f -p1 -i %s' % patchfile
        try:
            print "Testing patch %s..." % patchfile
            sh('patch --dry-run %s' % args, cwd=source_dir,
               capture=True)
        except BuildFailure:
            print "Skipping, see errors above"
        else:
            print "OK, applying patch %s" % patchfile
            sh('patch %s' % args, cwd=source_dir)
        print "-" * 60

@task
@needs('apply_patches')
def install_ob_packages(options):
    for package_name in options.openblock_packages:
        package_dir = os.path.join(options.source_dir, package_name)
        sh('%s/bin/pip install -e %s' % (options.env_root, package_dir))
    print "Success! OpenBlock packages installed."

@task
@needs('install_ob_packages')
def install_app(options):
    """
    sets up django app options.app
    """
    app_dir = os.path.join(options.source_dir, options.app)
    sh('%s/bin/pip install -e %s' % (options.env_root, app_dir))

    # create openblock settings if none have been created
    local_settings = os.path.join(options.source_dir, options.app, options.app,
                                  'settings.py')
    settings_skel = local_settings + '.in'

    if not os.path.exists(local_settings):
        print "Creating settings settings file => %s" % local_settings
        s = open(settings_skel).read()
        # Replace default salts with random strings.
        need_replacing = '<REPLACE_ME>'
        while s.count(need_replacing):
            s = s.replace(need_replacing, _random_string(), 1)
        open(local_settings, 'w').write(s)


    print "\nThe %s package is now installed." % options.app
    print "Please review the settings in %s." % local_settings



@task
@needs('install_app')
def post_bootstrap(options):
    # we expect this task is run automatically by our bootstrap.py script.
    print "Once you like your settings, run 'sudo -u postgres bin/oblock app=%s setup_dbs'" % options.app

def find_postgis(options):
    file_sets = (
        ('postgis.sql', 'spatial_ref_sys.sql'),
        ('lwpostgis.sql', 'spatial_ref_sys.sql')
    )
    postgis_paths = []
    for pattern in options.postgis_paths:
        postgis_paths.extend(glob.glob(pattern))
    for path in postgis_paths:
        for files in file_sets:
            found = True
            for filename in files:
                check_file = os.path.join(path, filename)
                if not os.path.exists(check_file):
                    found = False
                    break
            if found == True:
                return [os.path.join(path, filename) for filename in files]
    return None


def get_app_settings(options):
    settings_module = 'ebpub.settings_default'
    user_settings_module = '%s.settings' % options.app
    try:
        __import__(user_settings_module)
    except:
        exit_with_traceback("Problem with %s or %s, see above"
                            % (settings_module, user_settings_module))
    return sys.modules[user_settings_module]

def get_conn_params(dbinfo):
    dbhost = dbinfo.get('HOST', None)
    dbport = dbinfo.get('PORT', None)

    params = {}
    if dbhost:
        params['host'] = dbhost
    if dbport:
        params['port'] = dbport
    return params

def _distinct_servers(settings):
    dbs = {}
    for dbname, dbinfo in settings.DATABASES.items():
        dbid = (dbinfo.get('HOST'), dbinfo.get('PORT'))
        dbs[dbid] = dbinfo
    return dbs.values()

def _distinct_dbs(settings):
    dbs = {}
    for dbname, dbinfo in settings.DATABASES.items():
        dbid = (dbinfo.get('HOST'), dbinfo.get('PORT'), dbinfo.get('NAME'))
        dbs[dbid] = dbinfo
    return dbs.values()

def _distinct_users(settings):
    dbs = {}
    for dbname, dbinfo in settings.DATABASES.items():
        dbid = (dbinfo.get('HOST'), dbinfo.get('PORT'), dbinfo.get('USERNAME'))
        dbs[dbid] = dbinfo
    return dbs.values()

@task
def sync_all(options):
    """Use django-admin to initialize all our databases.
    """
    settings_mod = "%s.settings" % options.app
    settings = get_app_settings(options)

    sync_order = []
    if hasattr(settings, 'DATABASE_SYNC_ORDER'):
        sync_order = settings.DATABASE_SYNC_ORDER

    for dbname in sync_order:
        sh("django-admin.py syncdb --migrate --settings=%s --database=%s --noinput" % (settings_mod, dbname))

    for dbname in settings.DATABASES.keys():
        if dbname not in sync_order:
            sh("django-admin.py syncdb --migrate --settings=%s --database=%s --noinput" % (settings_mod, dbname))


@task
@needs('create_database_users')
@needs('create_postgis_templates')
def setup_dbs(options):
    """
    create application database(s).
    """
    settings = get_app_settings(options)
    for dbinfo in _distinct_dbs(settings):
        _setup_db(options, settings, dbinfo)
    print "Success! Now run 'oblock app=%s sync_all'" % options.app

def _setup_db(options, settings, dbinfo):
    conn_params = get_conn_params(dbinfo)

    import psycopg2
    conn = psycopg2.connect(database="postgres", **conn_params)

    dbuser = dbinfo.get('USER')

    cur = conn.cursor()
    dbname = dbinfo.get('NAME')
    template = settings.POSTGIS_TEMPLATE
    conn.set_isolation_level(psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)
    cur.execute("SELECT COUNT(*) from pg_database where datname='%s';" %
                dbname)
    if cur.fetchone()[0] != 0:
        print "Database '%s' already exists, fixing permissions ..." % dbname
        grant_rights_on_spatial_tables(dbname, **conn_params)
        return

    print "Creating database %s'" % dbname
    try:
        cur.execute("CREATE DATABASE %s OWNER %s TEMPLATE %s;" % (dbname, dbuser, template))
    except:
        exit_with_traceback("Failed to create database %r" % dbname)

    grant_rights_on_spatial_tables(dbname, **conn_params)
    print "Success. created database %s owned by %s" % (dbname, dbuser)

@task
def create_database_users(options):
    settings = get_app_settings(options)
    for dbinfo in _distinct_users(settings):
        _create_database_user(options, settings, dbinfo)

def _create_database_user(options, settings, dbinfo):
    conn_params = get_conn_params(dbinfo)

    import psycopg2
    conn = psycopg2.connect(database="postgres", **conn_params)

    ################################
    #
    # create user
    #
    ################################
    dbuser = dbinfo.get('USER')
    dbpass = dbinfo.get('PASSWORD')

    cur = conn.cursor()
    # test if the user exists
    cur.execute("SELECT COUNT(*) FROM pg_roles WHERE rolname='%s';" % dbuser)
    if cur.fetchone()[0] == 0:
        try:
            print "Creating user '%s'..." % dbuser
            cur.execute("CREATE ROLE %s PASSWORD '%s' NOSUPERUSER CREATEDB NOCREATEROLE LOGIN;" %
                        (dbuser, dbpass))
            conn.commit()
        except:
            exit_with_traceback("Failed to create user.")
    else:
        print "User '%s' already exists, leaving it alone..." % dbuser

@task
def drop_dbs(options):
    """
    drop application database(s).
    """
    settings = get_app_settings(options)
    for dbinfo in _distinct_dbs(settings):
        dbname = dbinfo.get('NAME')
        _drop_postgis_db(dbname, settings, dbinfo)

def _drop_postgis_db(dbname, settings, dbinfo, is_template=False):
    conn_params = get_conn_params(dbinfo)
    import psycopg2
    conn = psycopg2.connect(database="postgres", **conn_params)
    conn.set_isolation_level(psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)
    cur = conn.cursor()

    cur.execute("SELECT COUNT(*) from pg_database where datname='%s';" %
                dbname)
    if cur.fetchone()[0] == 0:
        print "database %s does not exist." % dbname
        return

    if is_template:
        # set it to a non-template so it can be dropped
        cur.execute("UPDATE pg_database SET datistemplate = FALSE "
                    "where datname='%s';" % dbname)
    # drop it
    cur.execute("DROP DATABASE %s;" % dbname)
    print "Dropped database %s" % dbname

@task
def drop_postgis_templates(options):
    settings = get_app_settings(options)
    for dbinfo in _distinct_servers(settings):
        _drop_postgis_template(settings, dbinfo)


def _drop_postgis_template(settings, dbinfo):
    name = settings.POSTGIS_TEMPLATE
    return _drop_postgis_db(name, settings, dbinfo, is_template=True)


@task
def create_postgis_templates(options):
    settings = get_app_settings(options)
    for dbinfo in _distinct_servers(settings):
        _create_postgis_template(options, settings, dbinfo)

def _create_postgis_template(options, settings, dbinfo):
    conn_params = get_conn_params(dbinfo)
    import psycopg2
    conn = psycopg2.connect(database="postgres", **conn_params)

    ##################################
    #
    # create template
    #
    ##################################

    template = settings.POSTGIS_TEMPLATE
    make_template_sql = "UPDATE pg_database set datistemplate = true where datname='%s';" % template

    conn.set_isolation_level(psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)
    cur = conn.cursor()
    # check if the database already exists
    cur.execute("SELECT COUNT(*) from pg_database where datname='%s';" %
                template)
    if cur.fetchone()[0] != 0:
        print "Database '%s' already exists, fixing permissions..." % template
        grant_rights_on_spatial_tables(template, **conn_params)
        cur.execute(make_template_sql)
        return

    postgis_files = find_postgis(options)
    if not postgis_files:
        print "Cannot locate postgis sql.  Please verify that PostGIS is installed."
        sys.exit(1)

    print "Creating template %s'" % template
    try:
        cur.execute("CREATE DATABASE %s ENCODING 'UTF8';" % template)
        cur.execute(make_template_sql)
    except:
        exit_with_traceback("Failed to create template %r" % template)

    # cool, reconnect to our new database.
    print "reconnecting to database %s" % template
    conn = psycopg2.connect(database=template, **conn_params)
    cur = conn.cursor()

    #################################
    #
    # create plpgsql language
    #
    #################################
    conn.set_isolation_level(psycopg2.extensions.ISOLATION_LEVEL_AUTOCOMMIT)
    cur.execute("SELECT COUNT(*) from pg_language where lanname='plpgsql';")
    if cur.fetchone()[0] == 0:
        print "creating language plpgsql..."
        cur.execute("CREATE LANGUAGE plpgsql;")
    else:
        print "Language 'plpgsql' already exists.  moving on..."
    conn.close()

    ###################################
    #
    # load postgis sql
    #
    ###################################
    print "Loading postgis from %s" % ', '.join(postgis_files)
    for filename in postgis_files:
        sh("psql -d %s -f %s" % (template, filename))

    print "created postgis template %s." % template
    grant_rights_on_spatial_tables(template, **conn_params)


def grant_rights_on_spatial_tables(database, **conn_params):
    import psycopg2
    conn = psycopg2.connect(database=database, **conn_params)
    cur = conn.cursor()
    cur.execute("GRANT ALL ON TABLE geometry_columns TO PUBLIC;")
    cur.execute("GRANT ALL ON TABLE spatial_ref_sys TO PUBLIC;")
    conn.commit()
    print "granting rights on postgis tables to public"


def exit_with_traceback(extra_msg):
    traceback.print_exc()
    print "=============================================="
    print extra_msg
    sys.exit(1)

def _random_string(length=12):
    import random
    import string
    result = ''
    for i in range(length):
        result += random.choice(string.letters + string.digits)
    return result

def main():
    import os
    import sys
    from paver.tasks import main as paver_main
    args = ['-f',  os.path.join(os.path.dirname(__file__), 'pavement.py')]
    args = args + sys.argv[1:]
    paver_main(args)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python

from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = models
# There are no models by default, but if you want to be able to write
# data migrations for your app, South needs it to be a django app
# (i.e. have models.)
# Also needed if you write tests and want the default testrunner to
# be able to find them.

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from obadmin import admin

admin.autodiscover()

urlpatterns = patterns(

    '',

    (r'^admin/', include(admin.site.urls)),

    # ebpub provides all the UI for an openblock site.
    (r'^', include('ebpub.urls')),
)

########NEW FILE########
__FILENAME__ = skel
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

from paste.script import templates
from paste.script.templates import var

def _random_string(length=12):
    import random
    import string
    result = ''
    for i in range(length):
        result += random.choice(string.letters + string.digits)
    return result

class OpenblockTemplate(templates.Template):
    """
    A template for the ``paster create`` command that
    bootstraps a custom OpenBlock Django app as described in
    the OpenBlock `custom app` docs.
    """
    required_templates = []
    use_cheetah = False
    summary = "Basic OpenBlock project template"
    _template_dir = 'project_templates/openblock'

    vars = [
        var('password_salt',
            'Salt used to hash passwords',
            default=_random_string()),
        var('reset_salt',
            'Salt used to hash password resets',
            default=_random_string()),
        var('staff_cookie_val',
            'Secret cookie value used to identify staff',
            default=_random_string()),
        var('description',
            'project description',
            default='A Django app that provides a custom OpenBlock site'),
        var('author',
            'Your name for the package metadata',
            ),
        var('author_email',
            'Your email for the package metadata',
            ),
        var('license',
            'License',
            default='GPLv3',
            ),

    ]

    def post(self, command, output_dir, vars):
        """Make some files executable. Pastescript forgets to do so,
        see issue https://bitbucket.org/ianb/pastescript/issue/2/executable-files-in-templates-do-not-have
        """
        if command.command_name == 'create':
            # not sure if there's a better thing to check.
            import os.path
            package_dir = os.path.join(output_dir, vars['project'])
            for fname in ('manage.py', 'manage.sh'):
                f = os.path.join(package_dir, fname)
                os.chmod(f, 0770)

########NEW FILE########
__FILENAME__ = testrunner
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings

from django.test.simple import DjangoTestSuiteRunner, TestCase
from django.test.simple import reorder_suite, build_test, build_suite
from django.db.models import get_app, get_apps
import unittest

class TestSuiteRunner(DjangoTestSuiteRunner):
    """
    This is a custom test runner for OpenBlock.
    """
    
#    def setup_databases(self, **kwargs):
#    def teardown_databases(self, old_config, **kwargs):

    # If you use Nose, you don't want it to think this class & its
    # methods are tests:
    __test__ = False

    def build_suite(self, test_labels, extra_tests=None, **kwargs):
        suite = unittest.TestSuite()
        if test_labels:
            for label in test_labels:
                if '.' in label:
                    suite.addTest(build_test(label))
                else:
                    app = get_app(label)
                    suite.addTest(build_suite(app))
        else:
            print "Excluding apps: %s" % ', '.join(settings.APPS_NOT_FOR_TESTING)
            for app in get_apps():
                if app.__package__ in settings.APPS_NOT_FOR_TESTING or \
                        app.__name__ in settings.APPS_NOT_FOR_TESTING:
                    continue
                print "Will test %s" % app.__name__
                suite.addTest(build_suite(app))

        if extra_tests:
            for test in extra_tests:
                print "Adding extra test %s" % test
                suite.addTest(test)

        return reorder_suite(suite, (TestCase,))

# Don't let Nose think this is a test case either:
build_test.__test__ = False

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = import_boston_blocks
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#


# Based on http://wiki.github.com/dkukral/everyblock/install-everyblock

from django.core.management.base import BaseCommand
from ebpub.utils.script_utils import die, makedirs, wget, unzip
from optparse import make_option
import os

class Command(BaseCommand):
    help = 'Import Boston demo streets & blocks data to ebpub.'

    option_list = BaseCommand.option_list + (
        make_option('--reset', '-r',
                    action='store_true',
                    dest='reset',
                    default=False,
                    help='Whether to delete existing blocks and start from scratch. This will attempt to fix other records that refer to blocks; use at your own risk though.'
                    ),
        )

    def handle(self, *args, **options):
        # First we download a bunch of zipfiles of TIGER data.
        HERE = os.getcwd()
        print "Working directory is", HERE
        OUTDIR = os.path.join(HERE, 'tiger_data')
        BASEURL='ftp://ftp2.census.gov/geo/tiger/TIGER2010'
        # 25 = MA; 25025 = Suffolk County, MA.
        ZIPS = ("PLACE/2010/tl_2010_25_place10.zip",
                "EDGES/tl_2010_25025_edges.zip",
                "FACES/tl_2010_25025_faces.zip",
                "FEATNAMES/tl_2010_25025_featnames.zip"
                )
        makedirs(OUTDIR) or die("couldn't create directory %s" % OUTDIR)
        for fname in ZIPS:
            wget('%s/%s' % (BASEURL, fname), cwd=OUTDIR) or die(
                "Could not download %s/%s" % (BASEURL, fname))

        import glob
        for fname in glob.glob(os.path.join(OUTDIR, '*zip')):
            unzip(fname, cwd=OUTDIR) or die("Could not unzip %s" % fname)
        print "Shapefiles unzipped in %s" % OUTDIR

        # Now we load them into our blocks table.
        from ebpub.streets.blockimport.tiger import import_blocks
        from ebpub.utils.geodjango import get_default_bounds
        print "Importing blocks, this may take several minutes ..."

        # Passing --city means we skip features labeled for other cities.

        importer = import_blocks.TigerImporter(
            '%s/tl_2010_25025_edges.shp' % OUTDIR,
            '%s/tl_2010_25025_featnames.dbf' % OUTDIR,
            '%s/tl_2010_25025_faces.dbf' % OUTDIR,
            '%s/tl_2010_25_place10.shp' % OUTDIR,
            encoding='utf8',
            filter_bounds=get_default_bounds(),
            filter_city='BOSTON',
            reset=options['reset'])
        num_created, num_existing = importer.save()
        print "Created %d blocks (%d existing)" % (num_created, num_existing)

        #########################

        print "Populating streets and fixing addresses, these can take several minutes..."

        #cd $SOURCE_ROOT/ebpub/ebpub/streets/bin || die

        # Note these scripts should be run ONCE, in this order,
        # after you have imported *all* your blocks.

        from ebpub.streets.bin import populate_streets
        populate_streets.main(['-v', '-v', '-v', '-v', 'streets'])
        populate_streets.main(['-v', '-v', '-v', '-v', 'block_intersections'])
        populate_streets.main(['-v', '-v', '-v', '-v', 'intersections'])
        print "Done."

########NEW FILE########
__FILENAME__ = import_boston_hoods
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#


from django.core.management.base import BaseCommand
from ebpub.utils.script_utils import die, makedirs, wget, unzip
import os

class Command(BaseCommand):
    help = 'Import Boston neighborhoods as ebpub.db.Locations.'

    def handle(self, *args, **options):
        HERE = os.getcwd()
        print "Working directory is", HERE



        HOOD_SERVER="http://developer.openblockproject.org/raw-attachment/ticket/62"
        HOOD_FILE="Planning_districts_revised.zip" 
        HOOD_URL="%s/%s" % (HOOD_SERVER, HOOD_FILE)
        HOOD_FOLDER = os.path.join(HERE, 'neighborhood_data')

        print "Downloading neighborhood data..."
        makedirs(HOOD_FOLDER) or die("couldn't create %s" % HOOD_FOLDER)
        wget(HOOD_URL, cwd=HOOD_FOLDER) or die("Could not download %s" % HOOD_URL)
        hood_path = os.path.join(HOOD_FOLDER, HOOD_FILE)
        unzip(hood_path, cwd=HOOD_FOLDER) or die("Could not unzip %s" % hood_path)

        print "Importing neighborhoods..."
        from ebpub.db.bin import import_hoods
        import_hoods.main(['-v', '-n', 'PD', HOOD_FOLDER])
        print "Done."

########NEW FILE########
__FILENAME__ = import_boston_meetups
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#


from django.core.management.base import BaseCommand
from ebdata.scrapers.general.meetup.meetup_retrieval import MeetupScraper, parser
from optparse import OptionParser


class Command(BaseCommand):
    help = 'Import Boston meetups.'
    option_list = BaseCommand.option_list + tuple(parser.option_list)

    def handle(self, *args, **options):
        # We get passed options as a dict, but need them as attrs. Sigh.
        class Bag(object):
            pass
        opts = Bag()
        for k, v in options.items():
            setattr(opts, k, v)
        scraper = MeetupScraper(opts)
        scraper.update()

    def create_parser(self, prog_name, subcommand):
        """
        Create and return the ``OptionParser`` which will be used to
        parse the arguments to this command.

        Overridden to add conflict_handler='resolve'
        """
        return OptionParser(prog=prog_name,
                            usage=self.usage(subcommand),
                            version=self.get_version(),
                            conflict_handler="resolve",
                            option_list=self.option_list)

########NEW FILE########
__FILENAME__ = import_boston_news
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#


from django.core.management.base import BaseCommand
from ebpub.utils.script_utils import die, makedirs, wget, unzip
import os

class Command(BaseCommand):
    help = 'Import Boston local news as ebpub.db.NewsItems.'

    def handle(self, *args, **options):
        HERE = os.getcwd()
        print "Working directory is", HERE

        print "Adding latest events..."
        from ebdata.scrapers.us.ma.boston.events.retrieval import main as events_main
        events_main()

        print "Adding latest news..."
        from ebdata.scrapers.general.georss.retrieval import main as news_main
        news_main(["http://search.boston.com/search/api?q=*&sort=-articleprintpublicationdate&subject=massachusetts&scope=bonzai"])
        # more feeds from Joel. Local blog news:
        # ... this one times out
        #news_main(["http://search.boston.com/search/api?q=*&sort=-articleprintpublicationdate&scope=blogs&count=250&subject=massachusetts&format=atom"])


        print "Adding police reports..."
        from ebdata.scrapers.us.ma.boston.police_reports.retrieval import main as pr_main
        pr_main()

        print " Adding building permits..."
        from ebdata.scrapers.us.ma.boston.building_permits.retrieval import PermitScraper
        PermitScraper().update()


        print "Adding GeoReport issues..."
        from ebdata.scrapers.general.open311.georeportv2 import main as georeport_main
        georeport_main(['--html-url-template=http://seeclickfix.com/issues/{id}',
                        '--days-prior=6',
                        'http://seeclicktest.com/boston/open311/v2'])


        # TODO: fix traceback:  ebdata.blobs.scrapers.NoSeedYet: You need to add a Seed with the URL 'http://www.cityofboston.gov/news/
        #echo Adding press releases...
        #python everyblock/everyblock/cities/boston/city_press_releases/retrieval.py || die

        print "Adding flickr photos..."
        from ebdata.scrapers.general.flickr import flickr_retrieval
        flickr_retrieval.main(['--days=3'])

        print "Updating aggregates, see ebpub/README.txt..."
        from ebpub.db.bin.update_aggregates import update_all_aggregates
        update_all_aggregates()

        print """
___________________________________________________________________

 *** NOT adding restaurant inspections or meetups, they can take hours. ***

  If you want to load them, run these commands:
   django-admin.py import_boston_restaurants
   django-admin.py import_boston_meetups
   update_aggregates

___________________________________________________________________
"""

########NEW FILE########
__FILENAME__ = import_boston_restaurants
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#


from django.core.management.base import BaseCommand

class Command(BaseCommand):
    help = 'Import Boston restaurant inspections.'

    def handle(self, *args, **options):
        from ebdata.scrapers.us.ma.boston.restaurants.retrieval import main
        main()

########NEW FILE########
__FILENAME__ = import_boston_zips
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

from django.core.management.base import BaseCommand
from ebpub.utils.script_utils import die, makedirs, wget, unzip
import os

class Command(BaseCommand):
    help = 'Import Boston neighborhoods as ebpub.db.Locations.'

    def handle(self, *args, **options):
        HERE = os.getcwd()
        print "Working directory is", HERE
        ZIP_SERVER="http://developer.openblockproject.org/raw-attachment/ticket/62"
        ZIP_FILE="bozip.zip"
        ZIP_URL="%s/%s" % (ZIP_SERVER, ZIP_FILE)
        ZIP_FOLDER= os.path.join(HERE, 'zip_data')
        makedirs(ZIP_FOLDER) or die("couldn't create %s" % ZIP_FOLDER)

        print "Downloading zip code data..."
        wget(ZIP_URL, cwd=ZIP_FOLDER) or die("Could not download %s" % ZIP_URL)
        zip_path = os.path.join(ZIP_FOLDER, ZIP_FILE)
        unzip(zip_path, cwd=ZIP_FOLDER) or die("failed to unzip %s" % zip_path)

        print "Importing zip codes..."
        from ebpub.db.bin import import_zips
        import_zips.main([ZIP_FOLDER, '-v'])


########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    depends_on = (
        ('streets', '0001_initial'),
        ('db', '0007_load_default_schemas'),
        )

    def forwards(self, orm):
        pass

    def backwards(self, orm):
        pass


    models = {
        
    }

    complete_apps = ['obdemo']

########NEW FILE########
__FILENAME__ = 0002_noop
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    # We tweak some of the default schemas for Boston.
    depends_on = (
        ("db", "0007_load_default_schemas"),
    )

    def forwards(self, orm):
        "rewritten as migration 0003, nothing left here."
        pass

    def backwards(self, orm):
        pass


    models = {
        
    }

    complete_apps = ['obdemo']

########NEW FILE########
__FILENAME__ = 0003_load_demo_schemas
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    depends_on = (
        ("db", "0011_delete_schemafield_name"),
    )

    needed_by = (
        ("db", "0012__undo_0011"),
    )


    def forwards(self, orm):
        
        def _create_or_update(model_id, key, attributes):
            Model = orm[model_id]
            params = {'defaults': attributes}
            params.update(key)
            ob, created = Model.objects.get_or_create(**params)
            for k, v in attributes.items(): 
                setattr(ob, k, v)
            ob.save()
        
        
        _create_or_update("db.schema", {"slug": "local-news"}, {
            "allow_charting": True,
            "can_collapse": True,
            "date_name": "Date",
            "date_name_plural": "Dates",
            "grab_bag": "",
            "grab_bag_headline": "",
            "has_newsitem_detail": True,
            "importance": 100,
            "indefinite_article": "a",
            "intro": "",
            "is_public": True,
            "is_special_report": False,
            "last_updated": "2000-01-01",
            "min_date": "2000-01-01",
            "name": "Local News",
            "number_in_overview": 5,
            "plural_name": "Local News",
            "short_description": "List of news in Boston",
            "short_source": "http://www.boston.com",
            "slug": "local-news",
            "source": "http://www.boston.com",
            "summary": "Local News in Boston",
            "update_frequency": "",
            "uses_attributes_in_list": False
        })
  
        _create_or_update("db.schema", {"slug": "events"}, {
            "is_special_report": False,
            "plural_name": "Events",
            "last_updated": "2010-10-21",
            "name": "Event",
            "has_newsitem_detail": True,
            "importance": 100,
            "uses_attributes_in_list": True,
            "min_date": "2009-01-01",
            "allow_charting": True,
            "can_collapse": True,
            "date_name": "Date",
            "indefinite_article": "an",
            "is_public": True,
            "number_in_overview": 5,
            "slug": "events",
            "date_name_plural": "Dates",
            "grab_bag_headline": "",
            "short_source": "http://calendar.boston.com/",
            "summary": "Boston Events",
            "source": "http://calendar.boston.com/",
            "intro": "",
            "update_frequency": "",
            "short_description": "List of events in Boston",
            "grab_bag": ""
        })

        _create_or_update("db.schema", {"slug": "open311-service-requests"},{
            "allow_charting": True,
            "can_collapse": False,
            "date_name": "Date",
            "date_name_plural": "Dates",
            "grab_bag": "",
            "grab_bag_headline": "",
            "has_newsitem_detail": True,
            "importance": 0,
            "indefinite_article": "an",
            "intro": "",
            "is_public": True,
            "is_special_report": False,
            "last_updated": "2000-01-01",
            "min_date": "2000-01-01",
            "name": "Open311 Service Request",
            "number_in_overview": 5,
            "plural_name": "Open311 Service Requests",
            "short_description": "Boston Citizens Connect Open311 issues",
            "short_source": "http://www.cityofboston.gov/doit/apps/citizensconnect.asp",
            "slug": "open311-service-requests",
            "source": "http://www.cityofboston.gov/doit/apps/citizensconnect.asp",
            "summary": "Open311 requests via the Bostons Citizes Connect implementation of the GeoReport API.",
            "update_frequency": "",
            "uses_attributes_in_list": True
        })

    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['obdemo', 'db']

########NEW FILE########
__FILENAME__ = 0004_load_more_schemas
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    depends_on = (
        ("db", "0014__undo_0009"),
        ("db", "0015_auto__add_field_schema_map_icon_url__add_field_schema_map_color"),

    )
    
    needed_by = (
        ("db", "0016_use_slug_fields_for_slugs"),
    )
    

    def forwards(self, orm):
        def _create_or_update(model_id, key, attributes):
            Model = orm[model_id]
            params = {'defaults': attributes}
            params.update(key)
            ob, created = Model.objects.get_or_create(**params)
            for k, v in attributes.items(): 
                setattr(ob, k, v)
            ob.save()
        
        
        _create_or_update('db.schema', {'slug': 'restaurant-inspections'}, {
            "is_special_report": False,
            "plural_name": "Restaurant Inspections",
            "last_updated": "2010-10-20",
            "name": "Restaurant Inspection",
            "has_newsitem_detail": True,
            "importance": 100,
            "uses_attributes_in_list": True,
            "min_date": "2009-01-01",
            "allow_charting": True,
            "can_collapse": True,
            "date_name": "Date",
            "indefinite_article": "a",
            "is_public": True,
            "number_in_overview": 5,
            "slug": "restaurant-inspections",
            "date_name_plural": "Dates",
            "grab_bag_headline": "",
            "short_source": "http://www.cityofboston.gov/isd/health/mfc/search.asp",
            "summary": "Restaurant Inspections",
            "source": "http://www.cityofboston.gov/isd/health/mfc/search.asp",
            "intro": "",
            "update_frequency": "",
            "short_description": "List of Restaurant Inspections",
            "grab_bag": ""
        })

        schema = orm['db.schema'].objects.get(slug='restaurant-inspections')
        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'int02'}, {
            "is_lookup": False,
            "pretty_name_plural": "Inspection IDs",
            "is_charted": False,
            "name": "inspection_id",
            "display_order": 0,
            "is_searchable": False,
            "real_name": "int02",
            "pretty_name": "Inspection ID",
            "is_filter": False,
            "display": False,
            "schema": schema
        })
        
        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'int01'}, {
            "is_lookup": False,
            "pretty_name_plural": "Restaurant IDs",
            "is_charted": False,
            "name": "restaurant_id",
            "display_order": 0,
            "is_searchable": False,
            "real_name": "int01",
            "pretty_name": "Restaurant ID",
            "is_filter": False,
            "display": False,
            "schema": schema
        })
            
        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'varchar01'}, {
            "is_lookup": False,
            "pretty_name_plural": "Restaurant Names",
            "is_charted": False,
            "name": "restaurant_name",
            "display_order": 0,
            "is_searchable": True,
            "real_name": "varchar01",
            "pretty_name": "Restaurant Name",
            "is_filter": False,
            "display": True,
            "schema": schema
        })
        
        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'int03'}, {
            "is_lookup": True,
            "pretty_name_plural": "Results",
            "is_charted": False,
            "name": "result",
            "display_order": 1,
            "is_searchable": False,
            "real_name": "int03",
            "pretty_name": "Result",
            "is_filter": True,
            "display": True,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'varchar02'}, {
            "is_lookup": True,
            "pretty_name_plural": "Violations",
            "is_charted": True,
            "name": "violation",
            "display_order": 2,
            "is_searchable": False,
            "real_name": "varchar02",
            "pretty_name": "Violation",
            "is_filter": True,
            "display": True,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'text01'}, {
            "is_lookup": False,
            "pretty_name_plural": "Violation Details",
            "is_charted": False,
            "name": "details",
            "display_order": 2,
            "is_searchable": False,
            "real_name": "text01",
            "pretty_name": "Violation Detail",
            "is_filter": False,
            "display": False,
            "schema": schema
        })

        _create_or_update("db.schema", {"slug": "police-reports"}, {
            "is_special_report": False,
            "plural_name": "Boston Police Department reports",
            "last_updated": "2010-10-21",
            "name": "Boston Police Department report",
            "has_newsitem_detail": True,
            "importance": 100,
            "uses_attributes_in_list": True,
            "min_date": "2009-01-01",
            "allow_charting": True,
            "can_collapse": True,
            "date_name": "Date",
            "indefinite_article": "a",
            "is_public": True,
            "number_in_overview": 5,
            "slug": "police-reports",
            "date_name_plural": "Dates",
            "grab_bag_headline": "",
            "short_source": "http://www.bpdnews.com",
            "summary": "Boston Police Department reports",
            "source": "http://www.bpdnews.com",
            "intro": "",
            "update_frequency": "",
            "short_description": "List of Boston Police Department reports",
            "grab_bag": ""
        })

        _create_or_update("db.schema", {"slug": "building-permits"}, {
            "is_special_report": False,
            "plural_name": "Building Permits",
            "last_updated": "2010-10-22",
            "name": "Building Permit",
            "has_newsitem_detail": True,
            "importance": 100,
            "uses_attributes_in_list": True,
            "min_date": "2009-01-01",
            "allow_charting": True,
            "can_collapse": True,
            "date_name": "Date",
            "indefinite_article": "a",
            "is_public": True,
            "number_in_overview": 5,
            "slug": "building-permits",
            "date_name_plural": "Dates",
            "grab_bag_headline": "",
            "short_source": "http://www.cityofboston.gov/isd/building/asofright/default.asp",
            "summary": "Boston Building Permits",
            "source": "http://www.cityofboston.gov/isd/building/asofright/default.asp",
            "intro": "",
            "update_frequency": "",
            "short_description": "List of Boston Building Permits",
            "grab_bag": ""
        })

        schema = orm['db.schema'].objects.get(slug='building-permits')

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'varchar01'}, {
            "is_lookup": False,
            "pretty_name_plural": "Raw Addresses",
            "is_charted": False,
            "name": "raw_address",
            "display_order": 0,
            "is_searchable": False,
            "real_name": "varchar01",
            "pretty_name": "Raw Address",
            "is_filter": False,
            "display": False,
            "schema": schema
        })

        _create_or_update("db.schema", {"slug": "business-licenses"}, {
            "last_updated": "2011-04-05",
            "intro": "",
            "update_frequency": "",
            "has_newsitem_detail": True,
            "grab_bag_headline": "",
            "short_source": "",
            "slug": "business-licenses",
            "source": "",
            "date_name": "Date",
            "short_description": "",
            "grab_bag": "",
            "is_special_report": False,
            "importance": 0,
            "min_date": "1900-01-01",
            "allow_charting": False,
            "indefinite_article": "a",
            "is_public": True,
            "number_in_overview": 5,
            "date_name_plural": "Dates",
            "plural_name": "Business Licenses",
            "name": "Business License",
            "uses_attributes_in_list": False,
            "summary": "Business licenses in the city of Boston",
            "can_collapse": False
        })

        schema = orm['db.schema'].objects.get(slug='business-licenses')

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'int01'}, {
            "is_lookup": True,
            "pretty_name_plural": "Business Types",
            "is_charted": False,
            "name": "business_type",
            "display_order": 10,
            "is_searchable": False,
            "real_name": "int01",
            "pretty_name": "Business Type",
            "is_filter": False,
            "display": True,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'varchar02'}, {
            "is_lookup": False,
            "pretty_name_plural": "File Numbers",
            "is_charted": False,
            "name": "file_number",
            "display_order": 10,
            "is_searchable": True,
            "real_name": "varchar02",
            "pretty_name": "File Number",
            "is_filter": False,
            "display": True,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'varchar01'}, {
            "is_lookup": False,
            "pretty_name_plural": "Names",
            "is_charted": False,
            "name": "name",
            "display_order": 10,
            "is_searchable": True,
            "real_name": "varchar01",
            "pretty_name": "Name",
            "is_filter": False,
            "display": True,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'varchar03'}, {
            "is_lookup": False,
            "pretty_name_plural": "Notes",
            "is_charted": False,
            "name": "notes",
            "display_order": 10,
            "is_searchable": False,
            "real_name": "varchar03",
            "pretty_name": "Notes",
            "is_filter": False,
            "display": True,
            "schema": schema
        })

        _create_or_update("db.schema", {"slug": "issues"}, {
            "is_special_report": False,
            "plural_name": "SeeClickFix Issues",
            "last_updated": "2010-10-22",
            "name": "SeeClickFix Issue",
            "has_newsitem_detail": True,
            "importance": 100,
            "uses_attributes_in_list": True,
            "min_date": "2009-01-01",
            "allow_charting": True,
            "can_collapse": True,
            "date_name": "Date",
            "indefinite_article": "a",
            "is_public": True,
            "number_in_overview": 5,
            "slug": "issues",
            "date_name_plural": "Dates",
            "grab_bag_headline": "",
            "short_source": "http://seeclickfix.com",
            "summary": "SeeClickFix Issues for Boston",
            "source": "http://seeclickfix.com/boston",
            "intro": "",
            "update_frequency": "",
            "short_description": "List of Issues in Boston, from SeeClickFix",
            "grab_bag": ""
        });

        schema = orm['db.schema'].objects.get(slug='issues')

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'int01'}, {
            "is_lookup": False,
            "pretty_name_plural": "Ratings",
            "is_charted": False,
            "name": "rating",
            "display_order": 0,
            "is_searchable": False,
            "real_name": "int01",
            "pretty_name": "Rating",
            "is_filter": False,
            "display": True,
            "schema": schema
        })


        schema = orm['db.schema'].objects.get(slug='open311-service-requests')

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'varchar03'}, {
            "is_lookup": False,
            "pretty_name_plural": "Address IDs",
            "is_charted": False,
            "name": "address_id",
            "display_order": 10,
            "is_searchable": False,
            "real_name": "varchar03",
            "pretty_name": "Address ID",
            "is_filter": False,
            "display": False,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'datetime02'}, {
            "is_lookup": False,
            "pretty_name_plural": "Expected Completion Dates",
            "is_charted": False,
            "name": "expected_datetime",
            "display_order": 4,
            "is_searchable": False,
            "real_name": "datetime02",
            "pretty_name": "Expected Completion Date",
            "is_filter": False,
            "display": True,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'varchar04'}, {
            "is_lookup": False,
            "pretty_name_plural": "Media URLs",
            "is_charted": False,
            "name": "media_url",
            "display_order": 10,
            "is_searchable": False,
            "real_name": "varchar04",
            "pretty_name": "Media URL",
            "is_filter": False,
            "display": True,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'varchar01'}, {
            "is_lookup": False,
            "pretty_name_plural": "Request IDs",
            "is_charted": False,
            "name": "service_request_id",
            "display_order": 10,
            "is_searchable": False,
            "real_name": "varchar01",
            "pretty_name": "Request ID",
            "is_filter": False,
            "display": True,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'datetime01'}, {
            "is_lookup": False,
            "pretty_name_plural": "Request Times",
            "is_charted": False,
            "name": "requested_datetime",
            "display_order": 5,
            "is_searchable": False,
            "real_name": "datetime01",
            "pretty_name": "Request Time",
            "is_filter": False,
            "display": True,
            "schema": schema
        })
        
        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'int02'}, {
            "is_lookup": True,
            "pretty_name_plural": "Responsible Agencies",
            "is_charted": False,
            "name": "agency_responsible",
            "display_order": 6,
            "is_searchable": False,
            "real_name": "int02",
            "pretty_name": "Responsible Agency",
            "is_filter": True,
            "display": True,
            "schema": schema
        })
    
        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'varchar02'}, {
            "is_lookup": False,
            "pretty_name_plural": "Service Codes",
            "is_charted": False,
            "name": "service_code",
            "display_order": 10,
            "is_searchable": False,
            "real_name": "varchar02",
            "pretty_name": "Service Code",
            "is_filter": False,
            "display": False,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'int01'}, {
            "is_lookup": True,
            "pretty_name_plural": "Service Names",
            "is_charted": False,
            "name": "service_name",
            "display_order": 1,
            "is_searchable": False,
            "real_name": "int01",
            "pretty_name": "Service Name",
            "is_filter": True,
            "display": True,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'text01'}, {
            "is_lookup": False,
            "pretty_name_plural": "Service Notices",
            "is_charted": False,
            "name": "service_notice",
            "display_order": 10,
            "is_searchable": False,
            "real_name": "text01",
            "pretty_name": "Service Notice",
            "is_filter": False,
            "display": True,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'int03'}, {
            "is_lookup": True,
            "pretty_name_plural": "Statuses",
            "is_charted": False,
            "name": "status",
            "display_order": 2,
            "is_searchable": False,
            "real_name": "int03",
            "pretty_name": "Status",
            "is_filter": False,
            "display": True,
            "schema": schema
        })

        _create_or_update("db.schemafield", {'schema': schema, 'real_name': 'varchar05'}, {
            "is_lookup": False,
            "pretty_name_plural": "Status Notes",
            "is_charted": False,
            "name": "status_notes",
            "display_order": 3,
            "is_searchable": False,
            "real_name": "varchar05",
            "pretty_name": "Status Notes",
            "is_filter": False,
            "display": True,
            "schema": schema
        })

    def backwards(self, orm):
        pass

    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'centroid': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.CharField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '32'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }


    complete_apps = ['obdemo', 'db']

########NEW FILE########
__FILENAME__ = 0005_load_flickr_schema
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    depends_on = (('db', '0019_auto__add_field_schema_allow_comments'),
                  )

    needed_by = (('db', '0020_auto__add_field_schema_is_event'),
                 )

    def forwards(self, orm):
        "Write your forwards methods here."
        def _create_or_update(model_id, key, attributes):
            Model = orm[model_id]
            params = {'defaults': attributes}
            params.update(key)
            ob, created = Model.objects.get_or_create(**params)
            for k, v in attributes.items(): 
                setattr(ob, k, v)
            ob.save()


        _create_or_update('db.schema', {'slug': 'photos'}, {
              "last_updated": "2011-09-08",
              "intro": "",
              "update_frequency": "",
              "has_newsitem_detail": False,
              "grab_bag_headline": "",
              "short_source": "http://flickr.com",
              "slug": "photos",
              "source": "http://flickr.com",
              "date_name": "Date",
              "short_description": "Photos from Flickr",
              "grab_bag": "",
              "is_special_report": False,
              "importance": 0,
              "min_date": "2011-01-01",
              "allow_charting": True,
              "indefinite_article": "a",
              "is_public": True,
              "number_in_overview": 5,
              "date_name_plural": "Dates",
              "plural_name": "Photos from Flickr",
              "name": "Photo from Flickr",
              "uses_attributes_in_list": True,
              "summary": "Boston-area photos from Flickr..",
              "can_collapse": False
              })

        schema = orm['db.schema'].objects.get(slug='photos')
        _create_or_update('db.schemafield', {'schema': schema, 'real_name': 'varchar01'},
                          {"is_lookup": False,
                           "is_charted": False,
                           "is_filter": False,
                           "is_searchable": True,
                           "name": "username",
                           "display_order": 1,
                           "real_name": "varchar01",
                           "pretty_name": "User Name",
                           "pretty_name_plural": "User Names",
                           "display": True,
                           "schema": schema,
                           })

        _create_or_update('db.schemafield', {'schema': schema, 'real_name': "varchar02",},
                          {"is_lookup": False,
                           "is_charted": False,
                           "is_filter": False,
                           "is_searchable": False,
                           "name": "user_id",
                           "display_order": 2,
                           "real_name": "varchar02",
                           "pretty_name": "User ID",
                           "pretty_name_plural": "User IDs",
                           "display": False,
                           "schema": schema,
                           })

        _create_or_update('db.schemafield', {'schema': schema, 'real_name': "varchar03",},
                          {"is_lookup": False,
                           "is_charted": False,
                           "is_filter": False,
                           "is_searchable": False,
                           "name": "sourcename",
                           "display_order": 3,
                           "real_name": "varchar03",
                           "pretty_name": "Source Site Name",
                           "pretty_name_plural": "Source Site Names",
                           "display": True,
                           "schema": schema,
                           })
        _create_or_update('db.schemafield', {'schema': schema, 'real_name': "varchar04",},
                          {"is_lookup": False,
                           "is_charted": False,
                           "is_filter": False,
                           "is_searchable": False,
                           "name": "photo_href",
                           "display_order": 4,
                           "real_name": "varchar04",
                           "pretty_name": "Thumbnail URL",
                           "pretty_name_plural": "Thumbnail URLs",
                           "display": False,
                           "schema": schema,
                           })


    def backwards(self, orm):
        "Write your backwards methods here."
        pass


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db', 'obdemo']

########NEW FILE########
__FILENAME__ = 0006_disable_broken_schemas
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        def _create_or_update(model_id, key, attributes):
            Model = orm[model_id]
            params = {'defaults': attributes}
            params.update(key)
            ob, created = Model.objects.get_or_create(**params)
            for k, v in attributes.items(): 
                setattr(ob, k, v)
            ob.save()

        _create_or_update('db.schema', {'slug': 'building-permits'},
                          {'is_public': False})

        _create_or_update('db.schema', {'slug': 'issues'},
                          {'is_public': False})

        _create_or_update('db.schema', {'slug': 'business-licenses'},
                          {'is_public': False})

    def backwards(self, orm):
        pass

    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db', 'obdemo']

########NEW FILE########
__FILENAME__ = 0007_add_meetup_and_neighbornews
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    depends_on = (
        ("db", "0020_auto__add_field_schema_is_event"),
        ('neighbornews', '0002_add_is_event'),
        )

    needed_by = (
        # We were created before allow_flagging existed.
        ('db', '0024_auto__add_field_schema_allow_flagging'),
        )

    def forwards(self, orm):
        def _create_or_update(model_id, key, attributes):
            Model = orm[model_id]
            params = {'defaults': attributes}
            params.update(key)
            ob, created = Model.objects.get_or_create(**params)
            for k, v in attributes.items(): 
                setattr(ob, k, v)
            ob.save()
            return ob

        # Meetups schema
        schema = _create_or_update(
            'db.schema', {'slug': 'meetups'},
            {
                "allow_charting": True,
                "can_collapse": False,
                "date_name": "Date",
                "date_name_plural": "Dates",
                "grab_bag": "",
                "grab_bag_headline": "",
                "has_newsitem_detail": True,
                "importance": 0,
                "indefinite_article": "a",
                "intro": "",
                "is_event": True,
                "is_public": True,
                "is_special_report": False,
                "last_updated": "2011-09-09",
                "min_date": "2011-01-01",
                "name": "Meetup",
                "number_in_overview": 5,
                "plural_name": "Meetups",
                "short_description": "Meetups",
                "short_source": "http://meetup.com",
                "slug": "meetups",
                "source": "http://meetup.com",
                "summary": "Local Meetup meetings",
                "update_frequency": "",
                "uses_attributes_in_list": True,
                })

        _create_or_update(
            'db.schemafield', {'schema': schema, 'name': "group_name",},
            {
                "display": True,
                "display_order": 1,
                "is_charted": False,
                "is_filter": False,
                "is_lookup": False,
                "is_searchable": True,
                "pretty_name": "Group Name",
                "pretty_name_plural": "Group Names",
                "real_name": "varchar01",
                })

        _create_or_update(
            'db.schemafield', {'schema': schema, 'name': "venue_name",},
            {
                "display": True,
                "display_order": 5,
                "is_charted": False,
                "is_filter": False,
                "is_lookup": False,
                "is_searchable": True,
                "pretty_name": "Venue Name",
                "pretty_name_plural": "Venue Names",
                "real_name": "varchar02",
                })

        _create_or_update(
            'db.schemafield', {'schema': schema, 'name': "venue_phone",},
            {
                "display": True,
                "display_order": 10,
                "is_charted": False,
                "is_filter": False,
                "is_lookup": False,
                "is_searchable": False,
                "pretty_name": "Venue Phone",
                "pretty_name_plural": "Venue Phones",
                "real_name": "varchar03",
                })

        _create_or_update(
            'db.schemafield', {'schema': schema, 'name': 'start_time',},
            {
                "display": True,
                "display_order": 0,
                "is_charted": False,
                "is_filter": False,
                "is_lookup": False,
                "is_searchable": False,
                "pretty_name": "Start Time",
                "real_name": "time01",
                })

        # Neighbornews schemas.
        schema = _create_or_update(
            'db.schema', {'slug': 'neighbor-events'},
            {
                "allow_charting": True,
                "allow_comments": True,
                "can_collapse": False,
                "date_name": "Date",
                "date_name_plural": "Dates",
                "grab_bag": "",
                "grab_bag_headline": "",
                "has_newsitem_detail": True,
                "importance": 0,
                "indefinite_article": "a",
                "intro": "",
                "is_public": True,
                "is_special_report": False,
                "last_updated": "2011-08-03",
                "map_color": "",
                "map_icon_url": "",
                "min_date": "2011-08-03",
                "name": "Neighbor Event",
                "number_in_overview": 5,
                "plural_name": "Neighbor Events",
                "short_description": "User contributed events",
                "short_source": "",
                "slug": "neighbor-events",
                "source": "",
                "summary": "",
                "update_frequency": "",
                "uses_attributes_in_list": False,
                'is_event': True,
                })
        _create_or_update(
            'db.schemafield', {"name": "categories", "schema": schema},
            {
                "display": True,
                "display_order": 10,
                "is_charted": False,
                "is_filter": True,
                "is_lookup": True,
                "is_searchable": False,
                "pretty_name": "Categories",
                "pretty_name_plural": "Categories",
                "real_name": "varchar01",
                })
        _create_or_update(
            'db.schemafield', {"name": "start_time", "schema": schema},
            {
                "display": True,
                "display_order": 24,
                "is_charted": False,
                "is_filter": False,
                "is_lookup": False,
                "is_searchable": False,
                "pretty_name": "Start Time",
                "pretty_name_plural": "Start Times",
                "real_name": "time01",
                })
        _create_or_update(
            'db.schemafield', {"name": "end_time", "schema": schema},
            {
                "display": True,
                "display_order": 25,
                "is_charted": False,
                "is_filter": False,
                "is_lookup": False,
                "is_searchable": False,
                "pretty_name": "End Time",
                "pretty_name_plural": "End Times",
                "real_name": "time02",
                })

        _create_or_update(
            'db.schemafield', {"name": "image_url", "schema": schema},
            {
                "display": False,
                "display_order": 10,
                "is_charted": False,
                "is_filter": False,
                "is_lookup": False,
                "is_searchable": False,
                "pretty_name": "Image URL",
                "pretty_name_plural": "Image URLs",
                "real_name": "text01",
                })

        # Neighbornews neighbor-messages schema.
        schema = _create_or_update(
            'db.schema', {'slug': 'neighbor-messages'},
            {
                "allow_charting": True,
                "allow_comments": True,
                "can_collapse": False,
                "date_name": "Date",
                "date_name_plural": "Dates",
                "grab_bag": "",
                "grab_bag_headline": "",
                "has_newsitem_detail": True,
                "importance": 0,
                "indefinite_article": "a",
                "intro": "",
                "is_public": True,
                "is_special_report": False,
                "last_updated": "2011-08-03",
                "map_color": "",
                "map_icon_url": "",
                "min_date": "2011-08-03",
                "name": "Neighbor Message",
                "number_in_overview": 5,
                "plural_name": "Neighbor Messages",
                "short_description": "User contributed messages and news",
                "short_source": "",
                "slug": "neighbor-messages",
                "source": "",
                "summary": "",
                "update_frequency": "",
                "uses_attributes_in_list": False,
                'is_event': False,
                })

        _create_or_update(
            'db.schemafield', {"name": "categories", "schema": schema},
            {
                "display": True,
                "display_order": 10,
                "is_charted": False,
                "is_filter": True,
                "is_lookup": True,
                "is_searchable": False,
                "pretty_name": "Categories",
                "pretty_name_plural": "Categories",
                "real_name": "varchar01",
                })

        _create_or_update(
            'db.schemafield', {"name": "image_url", "schema": schema},
            {
                "display": False,
                "display_order": 10,
                "is_charted": False,
                "is_filter": False,
                "is_lookup": False,
                "is_searchable": False,
                "pretty_name": "Image URL",
                "pretty_name_plural": "Image URLs",
                "real_name": "text01",
                })


    def backwards(self, orm):
        pass


    models = {
        'accounts.user': {
            'Meta': {'object_name': 'User', '_ormbases': ['auth.User']},
            'main_metro': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'user_ptr': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['auth.User']", 'unique': 'True', 'primary_key': 'True'})
        },
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'neighbornews.newsitemcreator': {
            'Meta': {'ordering': "('news_item',)", 'unique_together': "(('news_item', 'user'),)", 'object_name': 'NewsItemCreator'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['accounts.User']"})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db', 'neighbornews', 'obdemo']

########NEW FILE########
__FILENAME__ = 0008_make_events_eventish
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    # Not really 'needed by' per se, but we'll break existing obdemo
    # migrations if they don't run before this ebpub db migration.
    needed_by = (('db', '0029_auto__del_fields_schema__intro__grab_bag__grab_bag_headline'),
                 )

    def forwards(self, orm):
        "Write your forwards methods here."

        def _create_or_update(model_id, key, attributes):
            Model = orm[model_id]
            params = {'defaults': attributes}
            params.update(key)
            ob, created = Model.objects.get_or_create(**params)
            for k, v in attributes.items(): 
                setattr(ob, k, v)
            ob.save()
            return ob

        schema = _create_or_update(
            'db.schema', {'slug': 'events'},
            {'is_event': True}
            )

        _create_or_update(
            'db.schemafield', {'schema': schema, 'name': 'start_time'},
            {
                "is_lookup": False,
                "is_charted": False,
                "is_filter": False,
                "is_searchable": False,
                "display_order": 20,
                "real_name": "time01",
                "pretty_name": "Start Time",
                "pretty_name_plural": "Start Times",
                "display": True,
                })

        _create_or_update(
            'db.schemafield', {'schema': schema, 'name': 'end_time'},
            {
                "is_lookup": False,
                "is_charted": False,
                "is_filter": False,
                "is_searchable": False,
                "display_order": 30,
                "real_name": "time02",
                "pretty_name": "End Time",
                "pretty_name_plural": "End Times",
                "display": True,
                })

    def backwards(self, orm):
        "Write your backwards methods here."
        pass


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db', 'obdemo']

########NEW FILE########
__FILENAME__ = 0009_add_map_icons
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    # Not really 'needed by' per se, but we'll break existing obdemo
    # migrations if they don't run before this ebpub db migration.
    needed_by = (('db', '0029_auto__del_fields_schema__intro__grab_bag__grab_bag_headline'),
                 )

    def forwards(self, orm):
        "Write your forwards methods here."

        def _create_or_update(model_id, key, attributes):
            Model = orm[model_id]
            params = {'defaults': attributes}
            params.update(key)
            ob, created = Model.objects.get_or_create(**params)
            for k, v in attributes.items(): 
                setattr(ob, k, v)
            ob.save()
            return ob

        _create_or_update('db.schema', {'slug': 'police-reports'},
                          {'map_icon_url': '/map_icons/police.png'})

        _create_or_update('db.schema', {'slug': 'events'},
                          {'map_icon_url': '/map_icons/calendar-3.png'})

        _create_or_update('db.schema', {'slug': 'meetups'},
                          {'map_icon_url': '/map_icons/meetup.png'})

        _create_or_update('db.schema', {'slug': 'open311-service-requests'},
                          {'map_icon_url': '/map_icons/caution.png'})

        _create_or_update('db.schema', {'slug': 'photos'},
                          {'map_icon_url': '/map_icons/photo.png'})

        _create_or_update('db.schema', {'slug': 'restaurant-inspections'},
                          {'map_icon_url': '/map_icons/restaurant.png'})

        _create_or_update('db.schema', {'slug': 'local-news'},
                          {'map_icon_url': '',
                           'map_color': '#FFAC54'})


    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db', 'obdemo']

########NEW FILE########
__FILENAME__ = 0010_tweak_restaurants
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    # Not really 'needed by' per se, but we'll break existing obdemo
    # migrations if they don't run before this ebpub db migration.
    needed_by = (('db', '0029_auto__del_fields_schema__intro__grab_bag__grab_bag_headline'),
                 )

    def forwards(self, orm):
        "Update restaurant inspection schema to make the JSON details visible."

        def _create_or_update(model_id, key, attributes):
            Model = orm[model_id]
            params = {'defaults': attributes}
            params.update(key)
            ob, created = Model.objects.get_or_create(**params)
            for k, v in attributes.items(): 
                setattr(ob, k, v)
            ob.save()
            return ob


        schema = _create_or_update('db.schema', {'slug': 'restaurant-inspections'}, {})

        _create_or_update('db.schemafield', {'schema': schema, 'name': 'details'},
                          {'display': True})


    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'),)", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'block': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['streets.Block']", 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']", 'null': 'True', 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'db_index': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'blank': 'True'})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'grab_bag': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'grab_bag_headline': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '128', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'intro': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'),)", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        },
        'streets.block': {
            'Meta': {'ordering': "('pretty_name',)", 'object_name': 'Block', 'db_table': "'blocks'"},
            'from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'geom': ('django.contrib.gis.db.models.fields.LineStringField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'left_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'left_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'left_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'left_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'parent_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'postdir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'predir': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '2', 'blank': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'right_city': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'right_from_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_state': ('django.contrib.localflavor.us.models.USStateField', [], {'max_length': '2', 'db_index': 'True'}),
            'right_to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'}),
            'right_zip': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '10', 'null': 'True', 'blank': 'True'}),
            'street': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'street_pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'street_slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'}),
            'suffix': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '32', 'blank': 'True'}),
            'to_num': ('django.db.models.fields.IntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        }
    }

    complete_apps = ['db', 'obdemo']

########NEW FILE########
__FILENAME__ = 0011_add_police_precinct
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    depends_on = (('db', '0029_auto__del_fields_schema__intro__grab_bag__grab_bag_headline'),
                  )

    def forwards(self, orm):
        "Write your forwards methods here."
        def _create_or_update(model_id, key, attributes):
            Model = orm[model_id]
            params = {'defaults': attributes}
            params.update(key)
            ob, created = Model.objects.get_or_create(**params)
            for k, v in attributes.items(): 
                setattr(ob, k, v)
            ob.save()
            return ob

        schema = _create_or_update(
            'db.schema', {'slug': 'police-reports'}, {},
            )

        _create_or_update(
            'db.schemafield', {'schema': schema, 'name': 'precinct'},
            {
                "display": True,
                "display_order": 0,
                "is_charted": True,
                "is_filter": True,
                "is_lookup": True,
                "is_searchable": False,
                "name": "precinct",
                "pretty_name": "Precinct",
                "pretty_name_plural": "Precincts",
                "real_name": "int01",
                })


    def backwards(self, orm):
        "Write your backwards methods here."


    models = {
        'db.aggregateall': {
            'Meta': {'object_name': 'AggregateAll'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregateday': {
            'Meta': {'object_name': 'AggregateDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatefieldlookup': {
            'Meta': {'object_name': 'AggregateFieldLookup'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lookup': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Lookup']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocation': {
            'Meta': {'object_name': 'AggregateLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.aggregatelocationday': {
            'Meta': {'object_name': 'AggregateLocationDay'},
            'date_part': ('django.db.models.fields.DateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'total': ('django.db.models.fields.IntegerField', [], {})
        },
        'db.attribute': {
            'Meta': {'object_name': 'Attribute'},
            'bool01': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool02': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool03': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool04': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'bool05': ('django.db.models.fields.NullBooleanField', [], {'null': 'True', 'blank': 'True'}),
            'date01': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date02': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date03': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date04': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'date05': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'datetime01': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime02': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime03': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'datetime04': ('django.db.models.fields.DateTimeField', [], {'null': 'True', 'blank': 'True'}),
            'int01': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int02': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int03': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int04': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int05': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int06': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'int07': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'news_item': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['db.NewsItem']", 'unique': 'True', 'primary_key': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'text01': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'text02': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'time01': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'time02': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'varchar01': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar02': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar03': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar04': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'}),
            'varchar05': ('django.db.models.fields.CharField', [], {'max_length': '4096', 'null': 'True', 'blank': 'True'})
        },
        'db.dataupdate': {
            'Meta': {'object_name': 'DataUpdate'},
            'got_error': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'num_added': ('django.db.models.fields.IntegerField', [], {}),
            'num_changed': ('django.db.models.fields.IntegerField', [], {}),
            'num_deleted': ('django.db.models.fields.IntegerField', [], {}),
            'num_skipped': ('django.db.models.fields.IntegerField', [], {}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'update_finish': ('django.db.models.fields.DateTimeField', [], {}),
            'update_start': ('django.db.models.fields.DateTimeField', [], {})
        },
        'db.location': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'location_type'),)", 'object_name': 'Location'},
            'area': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_mod_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'null': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True'}),
            'location_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.LocationType']"}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'population': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'user_id': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'db.locationsynonym': {
            'Meta': {'object_name': 'LocationSynonym'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'normalized_name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'db.locationtype': {
            'Meta': {'ordering': "('name',)", 'object_name': 'LocationType'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_browsable': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_significant': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'scope': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'})
        },
        'db.lookup': {
            'Meta': {'ordering': "('slug',)", 'unique_together': "(('slug', 'schema_field'), ('code', 'schema_field'), ('name', 'schema_field'))", 'object_name': 'Lookup'},
            'code': ('django.db.models.fields.CharField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'featured': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'schema_field': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.SchemaField']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'})
        },
        'db.newsitem': {
            'Meta': {'ordering': "('title',)", 'object_name': 'NewsItem'},
            'description': ('django.db.models.fields.TextField', [], {'default': "u''", 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'item_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date.today', 'db_index': 'True', 'blank': 'True'}),
            'last_modification': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'db_index': 'True', 'blank': 'True'}),
            'location': ('django.contrib.gis.db.models.fields.GeometryField', [], {'null': 'True', 'blank': 'True'}),
            'location_name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'location_object': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'+'", 'null': 'True', 'to': "orm['db.Location']"}),
            'location_set': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['db.Location']", 'null': 'True', 'through': "orm['db.NewsItemLocation']", 'blank': 'True'}),
            'pub_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now', 'db_index': 'True', 'blank': 'True'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'url': ('django.db.models.fields.TextField', [], {'default': "u''", 'blank': 'True'})
        },
        'db.newsitemimage': {
            'Meta': {'unique_together': "(('news_item', 'image'),)", 'object_name': 'NewsItemImage'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'image': ('django.db.models.fields.files.ImageField', [], {'max_length': '256'}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.newsitemlocation': {
            'Meta': {'unique_together': "(('news_item', 'location'),)", 'object_name': 'NewsItemLocation'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'location': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Location']"}),
            'news_item': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.NewsItem']"})
        },
        'db.schema': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Schema'},
            'allow_charting': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_comments': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'allow_flagging': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'can_collapse': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'date_name': ('django.db.models.fields.CharField', [], {'default': "'Date'", 'max_length': '32'}),
            'date_name_plural': ('django.db.models.fields.CharField', [], {'default': "'Dates'", 'max_length': '32'}),
            'edit_window': ('django.db.models.fields.FloatField', [], {'default': '0.0', 'blank': 'True'}),
            'has_newsitem_detail': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'importance': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'indefinite_article': ('django.db.models.fields.CharField', [], {'max_length': '2'}),
            'is_event': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'db_index': 'True'}),
            'is_special_report': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_updated': ('django.db.models.fields.DateField', [], {}),
            'map_color': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'map_icon_url': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'min_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.date(1970, 1, 1)'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'number_in_overview': ('django.db.models.fields.SmallIntegerField', [], {'default': '5'}),
            'plural_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'short_description': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'short_source': ('django.db.models.fields.CharField', [], {'default': "'One-line description of where this information came from.'", 'max_length': '128', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '32', 'db_index': 'True'}),
            'source': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'summary': ('django.db.models.fields.TextField', [], {'default': "''", 'blank': 'True'}),
            'update_frequency': ('django.db.models.fields.CharField', [], {'default': "''", 'max_length': '64', 'blank': 'True'}),
            'uses_attributes_in_list': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'db.schemafield': {
            'Meta': {'ordering': "('pretty_name',)", 'unique_together': "(('schema', 'real_name'), ('schema', 'name'))", 'object_name': 'SchemaField'},
            'display': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'display_order': ('django.db.models.fields.SmallIntegerField', [], {'default': '10'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_charted': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_filter': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_lookup': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_searchable': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.SlugField', [], {'max_length': '32', 'db_index': 'True'}),
            'pretty_name': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'pretty_name_plural': ('django.db.models.fields.CharField', [], {'max_length': '32'}),
            'real_name': ('django.db.models.fields.CharField', [], {'max_length': '10'}),
            'schema': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['db.Schema']"})
        },
        'db.searchspecialcase': {
            'Meta': {'object_name': 'SearchSpecialCase'},
            'body': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'query': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '64'}),
            'redirect_to': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '128', 'blank': 'True'})
        }
    }

    complete_apps = ['db', 'obdemo']

########NEW FILE########
__FILENAME__ = models
#   Copyright 2007,2008,2009,2011 Everyblock LLC, OpenPlans, and contributors
#
#   This file is part of obdemo
#
#   obdemo is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   obdemo is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with obdemo.  If not, see <http://www.gnu.org/licenses/>.
#

# There are no models, but we want to be able to write data migrations
# for the demo, and South needs it to be a django app (i.e. have models.)

########NEW FILE########
__FILENAME__ = add_events
#!/usr/bin/env python
# encoding: utf-8

#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

#pylint: disable-msg=E1101
#pylint: disable-msg=W0142

"""
add_events.py

Created by Don Kukral <don_at_kukral_dot_org>

Downloads calendar entries from RSS feed at boston.com 
and updates the database
"""

import sys, feedparser, datetime
import logging

from django.contrib.gis.geos import Point
from ebpub.db.models import NewsItem, Schema

logger = logging.getLogger('add_events')

# Note there's an undocumented assumption in ebdata that we want to
# put unescape html before putting it in the db.  Maybe wouldn't have
# to do this if we used the scraper framework in ebdata?
from ebdata.retrieval.utils import convert_entities


def update():
    """ Download Calendar RSS feed and update database """
    logger.info("Starting add_events")
    url = """http://calendar.boston.com/search?acat=&cat=&commit=Search\
&new=n&rss=1&search=true&sort=0&srad=20&srss=50&ssrss=5&st=event\
&st_select=any&svt=text&swhat=&swhen=today&swhere=&trim=1"""
    schema = 'events'


    try:
        schema = Schema.objects.get(slug=schema)
    except Schema.DoesNotExist:
        logger.error("Schema (%s): DoesNotExist" % schema)
        sys.exit(1)

    feed = feedparser.parse(url)
    addcount = updatecount = 0
    for entry in feed.entries:
        title = convert_entities(entry.title).strip()
        # Putting 'event' in the title is redundant, ticket #227
        if title.lower().startswith('event: '):
            title = title[7:]
        try:
            item = NewsItem.objects.get(title=title,
                                        schema__id=schema.id)
            status = "updated"
        except NewsItem.DoesNotExist:
            item = NewsItem()
            status = "added"
        except NewsItem.MultipleObjectsReturned:
            logger.warn("Multiple entries matched title %r, event titles are not unique?" % title)
            continue
        try:
            item.location_name = entry.get('xcal_x-calconnect-street') or entry.get('x-calconnect-street') or u''
            item.schema = schema
            item.title = title
            item.description = convert_entities(entry.description)
            item.url = entry.link
            item.item_date = datetime.datetime(*entry.updated_parsed[:6])
            item.pub_date = datetime.datetime(*entry.updated_parsed[:6])
            item.location = Point((float(entry['geo_long']),
                                   float(entry['geo_lat'])))
            if (item.location.x, item.location.y) == (0.0, 0.0):
                logger.warn("Skipping %r, bad location 0,0" % item.title)
                continue

            if not item.location_name:
                # Fall back to reverse-geocoding.
                from ebpub.geocoder import reverse
                try:
                    block, distance = reverse.reverse_geocode(item.location)
                    logger.info(" Reverse-geocoded point to %r" % block.pretty_name)
                    item.location_name = block.pretty_name
                except reverse.ReverseGeocodeError:
                    logger.debug(" Failed to reverse geocode %s for %r" % (item.location.wkt, item.title))
                    item.location_name = u''

            item.save()
            if status == 'added':
                addcount += 1
            else:
                updatecount += 1
            logger.info("%s: %s" % (status, item.title))
        except:
            logger.exception("unexpected error:", sys.exc_info()[1])

    logger.info("add_events finished: %d added, %d updated" % (addcount, updatecount))



def main(argv=None):
    from ebpub.utils.script_utils import add_verbosity_options, setup_logging_from_opts
    from optparse import OptionParser
    if argv is None:
        argv = sys.argv[1:]
    optparser = OptionParser()
    add_verbosity_options(optparser)
    opts, args = optparser.parse_args(argv)
    setup_logging_from_opts(opts, logger)
    update()

if __name__ == '__main__':
    sys.exit(main())


########NEW FILE########
__FILENAME__ = add_news
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

"""
A very thin wrapper around :doc:`../packages/ebdata.scrapers.general.georss`
"""

if __name__ == '__main__':
    from ebdata.scrapers.general.georss import retrieval
    retrieval.main(default_url='http://search.boston.com/search/api?q=*&sort=-articleprintpublicationdate&subject=massachusetts&scope=bonzai')


########NEW FILE########
__FILENAME__ = settings_background
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of obdemo
#
#   obdemo is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   obdemo is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with obdemo.  If not, see <http://www.gnu.org/licenses/>.
#

"""
An alternate settings file that disables default logging config,
because a bug in django-background-task means that any existing
logging config overrides the command-line options.  See
https://github.com/lilspikey/django-background-task/issues/2
"""

from obdemo.settings import *


del(LOGGING)

########NEW FILE########
__FILENAME__ = urls
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

from django.conf import settings
from django.conf.urls.defaults import *
from obadmin import admin
import os
admin.autodiscover()

if settings.DEBUG:
    # This stuff can probably go away if/when we switch to Django 1.3,
    # not sure yet how that interacts with django-static.
    urlpatterns = patterns('',
        (r'^(?P<path>(map_icons).*)$',
         'django.views.static.serve', {'document_root': os.path.join(settings.OBDEMO_DIR, 'media')}),
    )
else:
    urlpatterns = patterns('')


urlpatterns += patterns(
    '',

    # Uncomment the admin/doc line below and add 'django.contrib.admindocs' 
    # to INSTALLED_APPS to enable admin documentation:
    # (r'^admin/doc/', include('django.contrib.admindocs.urls')),

    (r'^admin/', include(admin.site.urls)),

    url(r'^disclaimer', 'django.views.generic.simple.direct_to_template',
        {'template': 'disclaimer.html'},
        name='obdemo-disclaimer'),

    (r'^geotagger/$', 'obdemo.views.geotagger_ui'),

    # geotagger api
    (r'^', include('ebdata.geotagger.urls')),

    # ebpub provides nearly all the UI for an openblock site.
    (r'^', include('ebpub.urls')),


)

########NEW FILE########
__FILENAME__ = views
#   Copyright 2011 OpenPlans and contributors
#
#   This file is part of OpenBlock
#
#   OpenBlock is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 3 of the License, or
#   (at your option) any later version.
#
#   OpenBlock is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with OpenBlock.  If not, see <http://www.gnu.org/licenses/>.
#

"""
Views for openblock demo.
"""
from django.conf import settings
from django.shortcuts import render_to_response
from django.template import RequestContext



def geotagger_ui(request): 
    """Toy demo of back-end geotagging service.
    """
    return render_to_response('geotagger/geotagger.html', RequestContext(request, {}))

########NEW FILE########
