__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Sevabot - Skype robot documentation build configuration file, created by
# sphinx-quickstart on Wed Dec 19 16:28:28 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Sevabot - Skype bot'
copyright = u'2012, Mikko Ohtamaa and others'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'haiku'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
html_favicon = "sevabot-32.png"

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Sevabot-Skyperobotdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Sevabot-Skyperobot.tex', u'Sevabot - Skype robot Documentation',
   u'Mikko Ohtamaa, Pete Sevander', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'sevabot-skyperobot', u'Sevabot - Skype robot Documentation',
     [u'Mikko Ohtamaa, Pete Sevander'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Sevabot-Skyperobot', u'Sevabot - Skype robot Documentation',
   u'Mikko Ohtamaa, Pete Sevander', 'Sevabot-Skyperobot', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = call
#!/sevabot

# -*- coding: utf-8 -*-

"""
Simple conference call hosting
"""
from __future__ import unicode_literals

import logging
import Skype4Py

from sevabot.bot.stateful import StatefulSkypeHandler
from sevabot.utils import ensure_unicode

logger = logging.getLogger('Call')

# Set to debug only during dev
logger.setLevel(logging.INFO)

logger.debug('Call module level load import')

HELP_TEXT = """Simple conference call hosting allows you to have bot host a conference call from the chat.

Sevabot can have only one conference call at the same instance.

Commands:

!call help: Show this help text

!call: Start a conference call from the chat

!call start: Same as !call

!call end: Finish the conference call from the chat
"""


class CallHandler(StatefulSkypeHandler):

    """
    Skype message handler class for the conference call hosting.
    """

    def __init__(self):
        """
        Use `init` method to initialize a handler.
        """

        logger.debug('Call handler constructed')

    def init(self, sevabot):
        """
        Set-up our state. This is called every time module is (re)loaded.

        :param skype: Handle to Skype4Py instance
        """

        logger.debug('Call handler init')

        self.skype = sevabot.getSkype()
        self.calls = {}

        self.commands = {'help': self.help, 'start': self.start_call, 'end': self.end_call}

    def handle_message(self, msg, status):
        """
        Override this method to customize a handler.
        """

        body = ensure_unicode(msg.Body)

        logger.debug('Call handler got: {}'.format(body))

        # If the separators are not specified, runs of consecutive
        # whitespace are regarded as a single separator
        words = body.split()

        if not len(words):
            return False

        if words[0] != '!call':
            return False

        args = words[1:]

        if not len(args):
            # !call simply starts a call
            self.start_call(msg, status, args)
            return True

        for name, cmd in self.commands.items():
            if name == args[0]:
                cmd(msg, status, args)
                return True

        return False

    def shutdown():
        """
        Called when the module is reloaded.
        """
        logger.debug('Call handler shutdown')

    def help(self, msg, status, args):
        """
        Show help message to the sender.
        """
        msg.Chat.SendMessage(HELP_TEXT)

    def is_call_active(self, chat_name=None):
        """
        Is a call from the chat active?
        """

        if not chat_name:
            # Is any call active?
            return len(self.skype.ActiveCalls) > 0

        call = self.calls.get(chat_name, False)

        if not call:
            # Calls from the chat are not active
            return False

        conference_id = call.ConferenceId

        if conference_id > 0:
            conference = self.skype.Conference(conference_id)
            return len(conference.ActiveCalls) > 0
        else:
            return call.Status == Skype4Py.clsOnHold or call.Status == Skype4Py.clsLocalHold or call.Status == Skype4Py.clsRemoteHold or call.Status == Skype4Py.clsInProgress

    def start_call(self, msg, status, args):
        """
        Start a conference call of the chat if any call is not active.
        """

        chat_name = msg.Chat.Name

        if self.is_call_active():
            # Already active
            if not self.is_call_active(chat_name):
                msg.Chat.SendMessage('Sorry, I\'m talking with someone else...')
            return

        def callback(call, status):
            logger.debug('Call status changed (wait): {} - {} - {}'.format(call.Id, call.Status, call.PartnerHandle))

            if status in (Skype4Py.clsRinging, Skype4Py.clsInProgress):
                self.calls[chat_name] = call
                self.unregister_callback(self.skype, 'CallStatus', callback)

        success = self.register_callback(self.skype, 'CallStatus', callback)
        if not success:
            logger.debug('CALL already issued on {}'.format(chat_name))
            return

        # Dirty workaround to start a conference call from a chat
        call_command = self.skype.Command('CALL {}'.format(chat_name))
        self.skype.SendCommand(call_command)

    def end_call(self, msg, status, args):
        """
        Finish a conference call of the chat.
        """

        chat_name = msg.Chat.Name

        if not self.is_call_active(chat_name):
            # No active calls
            msg.Chat.SendMessage('No calls to finish.')
            return

        call = self.calls.get(chat_name, False)
        if not call:
            # Should be never reached
            return

        conference_id = call.ConferenceId
        if conference_id > 0:
            self.skype.Conference(conference_id).Finish()
        else:
            call.Finish()


# Export the instance to Sevabot
sevabot_handler = CallHandler()

__all__ = ['sevabot_handler']

########NEW FILE########
__FILENAME__ = dice
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
A dice roll module
"""
import sys
import random

progname = 'dice'


def to_int(s):
    """Convert string to integer safely."""

    try:
        v = int(s)
    except ValueError:
        print '{} is not an integer.'.format(s)
        sys.exit(1)

    return v


def to_float(s):
    """Convert string to float safely."""

    try:
        v = float(s)
    except ValueError:
        print '{} is not a number.'.format(s)
        sys.exit(1)

    return v


def main(args):
    """The program entry point."""

    random.seed()

    if len(args) <= 0:
        # Roll a six-sided dice
        print random.randint(1, 6)
        return

    cmd = args[0]

    if cmd == 'help':
        print 'Usage:'
        print '       !dice [sides]'
        print '       !dice [min] [max]'
        print '       !dice uniform [min] [max]'
        print '       !dice gauss [mu] [sigma]'
        return
    elif cmd == 'uniform':

        # Roll a uniform-random-floating-point-numbered dice

        if len(args) <= 1:
            min_val, max_val = 0.0, 1.0
        elif len(args) == 2:
            min_val = 0.0
            max_val = to_float(args[1])
        else:
            min_val = to_float(args[1])
            max_val = to_float(args[2])

        print '{:.4f}'.format(random.uniform(min_val, max_val))

        return
    elif cmd == 'gauss':

        # Roll a Gaussian-distributed dice

        if len(args) <= 1:
            mu, sigma = 0.0, 1.0
        elif len(args) == 2:
            mu = 0.0
            sigma = to_float(args[1])
        else:
            mu = to_float(args[1])
            sigma = to_float(args[2])

        print '{:.4f}'.format(random.gauss(mu, sigma))

        return
    else:

        if len(args) <= 1:
            # Roll an N-sided dice
            sides = to_int(args[0])
            if sides < 1:
                print 'The number of sides must be greater than 0.'
                sys.exit(1)

            print random.randint(1, sides)
            return
        else:

            # Roll an integer dice
            min_val = to_int(args[0])
            max_val = to_int(args[1])
            if min_val > max_val:
                temp_val = min_val
                min_val = max_val
                max_val = temp_val

            print random.randint(min_val, max_val)
            return


if __name__ == '__main__':
    main(sys.argv[1:])

########NEW FILE########
__FILENAME__ = sad
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
A simple sample module with Skype smileys
"""
import os

print "Sevabot loves %s (hug)" % os.environ["SKYPE_FULLNAME"]

########NEW FILE########
__FILENAME__ = tasks
#!/sevabot
"""

    Simple group chat task manager.

    This also serves as an example how to write stateful handlers.

"""

from __future__ import unicode_literals

from threading import Timer
from datetime import datetime
import os
import logging
import pickle
from collections import OrderedDict

from sevabot.bot.stateful import StatefulSkypeHandler
from sevabot.utils import ensure_unicode, get_chat_id

logger = logging.getLogger("Tasks")

# Set to debug only during dev
logger.setLevel(logging.INFO)

logger.debug("Tasks module level load import")

# How long one can work on a task before we give a warning
MAX_TASK_DURATION = 24*60*60

HELP_TEXT = """!tasks is a noteboard where virtual team members can share info which tasks they are currently working on.

Commands
------------------------------

!tasks: This help text

Start task: You start working on a task. When you started is recorded. Example:

    start task I am now working on new Sevabot module interface

Stop task: Stop working on the current task. Example:

    stop task

List tasks: List all tasks an people working on them. Example:

    list tasks

Task lists are chat specific and the list is secure to the members of the chat.
All commands are case-insensitive.
"""


class TasksHandler(StatefulSkypeHandler):
    """
    Skype message handler class for the task manager.
    """

    def __init__(self):
        """Use `init` method to initialize a handler.
        """
        logger.debug("Tasks constructed")

    def init(self, sevabot):
        """
        Set-up our state. This is called

        :param skype: Handle to Skype4Py instance
        """
        logger.debug("Tasks init")
        self.sevabot = sevabot
        self.status_file = os.path.join(os.path.dirname(__file__), "sevabot-tasks.tmp")
        self.status = Status.read(self.status_file)

        self.commands = {
            "!tasks": self.help,
            "start task": self.start_task,
            "list tasks": self.list_tasks,
            "stop task": self.stop_task,
        }

        self.reset_timeout_notifier()

    def handle_message(self, msg, status):
        """Override this method to customize a handler.
        """

        # Skype API may give different encodings
        # on different platforms
        body = ensure_unicode(msg.Body)

        logger.debug("Tasks handler got: %s" % body)

        # Parse the chat message to commanding part and arguments
        words = body.split(" ")
        lower = body.lower()

        if len(words) == 0:
            return False

        # Parse argument for two part command names
        if len(words) >= 2:
            desc = " ".join(words[2:])
        else:
            desc = None

        chat_id = get_chat_id(msg.Chat)

        # Check if we match any of our commands
        for name, cmd in self.commands.items():
            if lower.startswith(name):
                cmd(msg, status, desc, chat_id)
                return True

        return False

    def shutdown(self):
        """ Called when the module is reloaded.
        """
        logger.debug("Tasks shutdown")
        self.stop_timeout_notifier()

    def save(self):
        """
        Persistent our state.
        """
        Status.write(self.status_file, self.status)

    def reset_timeout_notifier(self):
        """
        Check every minute if there are overdue jobs
        """
        self.notifier = Timer(60.0, self.check_overdue_jobs)
        self.notifier.daemon = True  # Make sure CTRL+C works and does not leave timer blocking it
        self.notifier.start()

    def stop_timeout_notifier(self):
        """
        """
        self.notifier.cancel()

    def help(self, msg, status, desc, chat_id):
        """
        Print help text to chat.
        """

        # Make sure we don't trigger ourselves with the help text
        if not desc:
            msg.Chat.SendMessage(HELP_TEXT)

    def warn_overdue(self, chat_id, job):
        """
        Generate overdue warning.
        """
        self.sevabot.sendMessage(chat_id, "Task hanging: %s started working on %s, %s" % (job.real_name, job.desc, pretty_time_delta(job.started)))
        job.warned = True

    def check_overdue_jobs(self):
        """
        Timer callback to go through jobs which might be not going forward.
        """

        found = False

        logger.debug("Running overdue check")

        now = datetime.now()

        for chat_id, chat in self.status.chats.items():
            for job in chat.values():
                if (now - job.started).total_seconds() > MAX_TASK_DURATION and not job.warned:
                    found = True
                    self.warn_overdue(chat_id, job)

        if found:
            logger.debug("Found overdue jobs")
            self.save()
        else:
            logger.debug("Did not found overdue jobs")

        # http://www.youtube.com/watch?v=ZEQydmaPjF0
        self.reset_timeout_notifier()

    def start_task(self, msg, status, desc, chat_id):
        """
        Command handler.
        """

        if desc.strip() == "":
            msg.Chat.SendMessage("Please give task description also")
            return

        tasks = self.status.get_tasks(chat_id)
        existing_job = tasks.get(msg.Sender.Handle, None)
        if existing_job:
            msg.Chat.SendMessage("Stopped existing task %s" % existing_job.desc)

        job = Job(msg.Sender.FullName, datetime.now(), desc)
        tasks = self.status.get_tasks(chat_id)
        tasks[msg.Sender.Handle] = job
        self.save()
        msg.Chat.SendMessage("%s started working on %s." % (job.real_name, job.desc))

    def list_tasks(self, msg, status, desc, chat_id):
        """
        Command handler.
        """

        jobs = self.status.get_tasks(chat_id).values()

        if len(jobs) == 0:
            msg.Chat.SendMessage("No active tasks for anybody")

        for job in jobs:
            msg.Chat.SendMessage("%s started working on %s, %s" % (job.real_name, job.desc, pretty_time_delta(job.started)))

    def stop_task(self, msg, status, desc, chat_id):
        """
        Command handler.
        """
        tasks = self.status.get_tasks(chat_id)
        if msg.Sender.Handle in tasks:
            job = tasks[msg.Sender.Handle]
            del tasks[msg.Sender.Handle]
            msg.Chat.SendMessage("%s finished" % job.desc)
        else:
            msg.Chat.SendMessage("%s had no active task" % msg.Sender.FullName)

        self.save()


class Status:
    """
    Stored pickled state of the tasks.

    Use Python pickling serialization for making status info persistent.
    """

    def __init__(self):
        # Chat id -> OrderedDict() of jobs mappings
        self.chats = dict()

    @classmethod
    def read(cls, path):
        """
        Read status file.

        Return fresh status if file does not exist.
        """

        if not os.path.exists(path):
            # Status file do not exist, get default status
            return Status()

        f = open(path, "rb")

        try:
            return pickle.load(f)
        finally:
            f.close()

    @classmethod
    def write(cls, path, status):
        """
        Write status file
        """
        f = open(path, "wb")
        pickle.dump(status, f)
        f.close()

    def get_tasks(self, chat_id):
        """
        Get jobs of a particular chat.
        """
        if not chat_id in self.chats:
            # Skype username -> Task instance mappings
            self.chats[chat_id] = OrderedDict()

        return self.chats[chat_id]


class Job:
    """
    Tracks who is doing what
    """

    def __init__(self, real_name, started, desc):
        """
        :param started: datetime when the job was started
        """
        self.started = started
        self.desc = desc
        self.real_name = real_name
        # Have we given timeout warning for this job
        self.warned = False

# The following has been
# ripped off from https://github.com/imtapps/django-pretty-times/blob/master/pretty_times/pretty.py

_ = lambda x: x


def pretty_time_delta(time):

    now = datetime.now(time.tzinfo)

    if time > now:
        past = False
        diff = time - now
    else:
        past = True
        diff = now - time

    days = diff.days

    if days is 0:
        return get_small_increments(diff.seconds, past)
    else:
        return get_large_increments(days, past)


def get_small_increments(seconds, past):
    if seconds < 10:
        result = _('just now')
    elif seconds < 60:
        result = _pretty_format(seconds, 1, _('seconds'), past)
    elif seconds < 120:
        result = past and _('a minute ago') or _('in a minute')
    elif seconds < 3600:
        result = _pretty_format(seconds, 60, _('minutes'), past)
    elif seconds < 7200:
        result = past and _('an hour ago') or _('in an hour')
    else:
        result = _pretty_format(seconds, 3600, _('hours'), past)
    return result


def get_large_increments(days, past):
    if days == 1:
        result = past and _('yesterday') or _('tomorrow')
    elif days < 7:
        result = _pretty_format(days, 1, _('days'), past)
    elif days < 14:
        result = past and _('last week') or _('next week')
    elif days < 31:
        result = _pretty_format(days, 7, _('weeks'), past)
    elif days < 61:
        result = past and _('last month') or _('next month')
    elif days < 365:
        result = _pretty_format(days, 30, _('months'), past)
    elif days < 730:
        result = past and _('last year') or _('next year')
    else:
        result = _pretty_format(days, 365, _('years'), past)
    return result


def _pretty_format(diff_amount, units, text, past):
    pretty_time = (diff_amount + units / 2) / units

    if past:
        base = "%(amount)d %(quantity)s ago"
    else:
        base = "%(amount)d %(quantity)s"

    return base % dict(amount=pretty_time, quantity=text)


# Export the instance to Sevabot
sevabot_handler = TasksHandler()

__all__ = ["sevabot_handler"]

########NEW FILE########
__FILENAME__ = weather
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""

    Sample weather script using secret openweathermap.org API.

    Also serves as a simple unicode test.

    Based on pyfibot IRC bot http://code.google.com/p/pyfibot/source/browse/trunk/pyfibot/modules/module_openweather.py

"""
from __future__ import absolute_import, division, print_function

import sys
import json
import urllib
from datetime import datetime, timedelta

url = 'http://openweathermap.org/data/2.1/find/name?q=%s'

# XXX?
threshold = 30


def call_weather_api(location):
    """ Call API """

    request = urllib.urlopen(url % location)

    payload = json.loads(request.read())

    if 'cod' in payload and payload['cod'] == '200':
        if 'list' in payload:
            data = payload['list'][0]
            location = data['name']

            if 'dt' in data:
                measured = datetime.utcfromtimestamp(data['dt'])
                if datetime.utcnow() - timedelta(minutes=threshold) > measured:
                    text = '%s (%s UTC): ' % (location, measured.strftime('%Y-%m-%d %H:%M'))
                else:
                    text = '%s: ' % location
            else:
                text = '%s: ' % location

            main = data['main']
            if 'temp' in main:
                temperature = main['temp'] - 273.15  # temperature converted from kelvins to celcius and rounded
                text += 'Temperature: %.1fc' % temperature
            else:
                temperature = None
            if 'wind' in data and 'speed' in data['wind']:
                wind = data['wind']['speed']  # Wind speed in mps (m/s)
            else:
                wind = None
            if temperature and wind:
                feels_like = 13.12 + 0.6215 * temperature - 11.37 * (wind * 3.6) ** 0.16 + 0.3965 * temperature * (wind * 3.6) ** 0.16
                text += ', Feels like: %.1fc' % feels_like
            if wind:
                text += ', Wind: %.1f m/s' % wind
            if 'humidity' in main:
                humidity = main['humidity']  # Humidity in %
                text += ', Humidity: %d%%' % humidity
            if 'pressure' in main:
                pressure = main['pressure']  # Atmospheric pressure in hPa
                text += ', Pressure: %d hPa' % pressure
            if 'clouds' in data and 'all' in data['clouds']:
                cloudiness = data['clouds']['all']  # Cloudiness in %
                text += ', Cloudiness: %d%%' % cloudiness

            if temperature:
                print(text.encode('utf-8'))
            else:
                print('Error: No data.')
    else:
        print('Error: Location %s not found.' % location)


if len(sys.argv) < 2:
    sys.exit("You must give a city")

city = sys.argv[1]

call_weather_api(city)

########NEW FILE########
__FILENAME__ = bot
# -*- coding: utf-8 -*-
from __future__ import absolute_import, division, print_function, unicode_literals

import sys
import logging
import hashlib
import time
from collections import OrderedDict
from inspect import getmembers, isclass

import Skype4Py

from sevabot.bot import handlers
from sevabot.utils import get_chat_id


logger = logging.getLogger("sevabot")


class Sevabot:
    """
    Skype bot interface handler.
    """

    def __init__(self):
        self.cmds = {}
        self.chats = {}
        self.handlers = {}

    def start(self):

        if sys.platform == "linux2":
            self.skype = Skype4Py.Skype(Transport='x11')
        else:
            # OSX
            self.skype = Skype4Py.Skype()

        logger.debug("Attaching to Skype")
        self.skype.Attach()

        logger.debug("Skype API connection established")
        self.skype.OnMessageStatus = self.handleMessages

        self.cacheChats()

        # XXX: Might need refactoring logic here how master handler is registered
        self.handler = handlers.CommandHandler(self)

    def getSkype(self):
        """ Expose Skype to stateful modules.

        :return: Active Skype4Py instance
        """
        return self.skype

    def cacheChats(self):
        """
        Scan all chats on initial connect.
        """
        logger.debug("Async cacheChats() -- this may take a while")
        self.chats = OrderedDict()

        # First get all fresh chats
        chats = []
        for chat in self.skype.Chats:

            # filter chats older than 6 months
            if time.time() - chat.ActivityTimestamp > 3600 * 24 * 180:
                continue

            chats.append(chat)

        chats = sorted(chats, key=lambda c: c.ActivityTimestamp, reverse=True)

        for chat in chats:
            # Encode ids in b64 so they are easier to pass in URLs
            chat_id = get_chat_id(chat)
            self.chats[chat_id] = chat

    def getOpenChats(self):
        """
        Get list of id -> chat object of all chats which are open.
        """

        # Make sure we get refresh chat list every time
        self.cacheChats()
        for chat_id, chat in self.chats.items():
            yield chat_id, chat

    def handleMessages(self, msg, status):
        """
        Handle incoming messages.
        """

        logger.debug("Incoming %s - %s - %s: %s" % (status, msg.Chat.FriendlyName,
                                                    msg.FromHandle, msg.Body))

        self.handler.handle(msg, status)

    def sendMessage(self, chat, msg):
        """
        Send a message to chat.

        :param chat: Chat id as a string

        :param msg: Message as UTF-8 encoded string
        """
        try:
            self.chats[chat].SendMessage(msg)
            return "Message sent\n"
        except KeyError:
            raise RuntimeError("No chat %s" % chat)

########NEW FILE########
__FILENAME__ = handlers
# -*- coding: utf-8 -*-

"""
Handler class for processing built-in commands and delegating messages.
"""
from __future__ import absolute_import, division, unicode_literals

import re
import logging
import shlex
from inspect import getmembers, ismethod

from sevabot.bot import modules
from sevabot.utils import ensure_unicode

logger = logging.getLogger('sevabot')


class CommandHandler:
    """A handler for processing built-in commands and delegating messages to reloadable modules.
    """

    def __init__(self, sevabot):
        self.sevabot = sevabot
        self.calls = {}
        self.cache_builtins()

    def cache_builtins(self):
        """Scan all built-in commands defined in this handler.
        """

        def wanted(member):
            return ismethod(member) and member.__name__.startswith('builtin_')

        self.builtins = {}
        for member in getmembers(self, wanted):
            command_name = re.split('^builtin_', member[0])[1]
            self.builtins[command_name] = member[1]
            logger.info('Built-in command {} is available.'.format(command_name))

    def handle(self, msg, status):
        """Handle command messages.
        """

        # If you are talking to yourself when testing
        # Ignore non-sent messages (you get both SENDING and SENT events)
        if status == "SENDING":
            return

        # Some Skype clients (iPad?)
        # double reply to the chat messages with some sort of ACK by
        # echoing them back
        # and we need to ignore them as they are not real chat messages
        # and not even displayed in chat UI
        if status == "READ":
            return

        # Check all stateful handlers
        for handler in modules.get_message_handlers():
            processed = handler(msg, status)
            if processed:
                # Handler processed the message
                return

        # We need utf-8 for shlex
        body = ensure_unicode(msg.Body).encode('utf-8')

        logger.debug(u"Processing message, body %s" % msg.Body)

        # shlex dies on unicode on OSX with null bytes all over the string
        try:
            words = shlex.split(body, comments=False, posix=True)
        except ValueError:
            # ValueError: No closing quotation
            return

        words = [word.decode('utf-8') for word in words]

        if len(words) < 1:
            return

        command_name = words[0]
        command_args = words[1:]

        # Beyond this point we process script commands only
        if not command_name.startswith('!'):
            return

        command_name = command_name[1:]

        script_module = modules.get_script_module(command_name)

        if command_name in self.builtins:
            # Execute a built-in command
            logger.debug('Executing built-in command {}: {}'.format(command_name, command_args))
            self.builtins[command_name](command_args, msg, status)
        elif script_module:

            # Execute a module asynchronously
            def callback(output):
                msg.Chat.SendMessage(output)

            script_module.run(msg, command_args, callback)
        else:
            msg.Chat.SendMessage("Don't know about command: !" + command_name)

    def builtin_reload(self, args, msg, status):
        """Reload command modules.
        """
        commands = modules.load_modules(self.sevabot)
        msg.Chat.SendMessage('Available commands: %s' % ', '.join(commands))

########NEW FILE########
__FILENAME__ = modules
# -*- coding: utf-8 -*-
"""

    Module loader

"""


from __future__ import absolute_import, division, print_function, unicode_literals

import os
import logging
import threading
import subprocess
import imp

import settings

from sevabot.utils import fail_safe, ensure_unicode

logger = logging.getLogger("sevabot")

#: Module name -> executable mappings
_modules = {}


class UNIXScriptModule:
    """ Simple UNIX script file wrapper"""

    def __init__(self, name, path):
        self.path = path
        self.name = name

    def shutdown(self):
        pass

    @staticmethod
    def is_valid(path):
        """ Is this a module we are looking for """
        return os.access(path, os.X_OK)

    def run(self, msg, args, callback):
        """
        Run an external script asynchronously.

        Timeout with a message if the default threshold is reached.
        """
        logger.debug("Executing module %s: %s" % (self.name, args))

        # Not sure if this unicode on all platforms by default
        username = ensure_unicode(msg.Sender.Handle)
        full_name = ensure_unicode(msg.Sender.FullName)

        #timeout(execute_module, name, args, callback, default=)
        def threaded_run():
            args.insert(0, unicode(self.path))

            logger.debug("Running command line: %s" % " ".join(args))

            env = os.environ.copy()
            env["SKYPE_USERNAME"] = username.encode("utf-8")
            env["SKYPE_FULLNAME"] = full_name.encode("utf-8")

            process = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, shell=False, env=env)
            out = process.communicate()[0]

            # :E1103: *%s %r has no %r member (but some types could not be inferred)*
            # pylint: disable=E1103
            return out.decode("utf-8")

        default = "Module %s timeouted in %d seconds" % (self.name, settings.TIMEOUT)

        thread = ExecutionManagedThread(threaded_run, default, settings.TIMEOUT, callback)
        thread.start()


class StatefulModule:
    """ State maintaining module.

    The module is a reloadable Python file with

    - #!/sevabot magic string at the head of the file

    - Exports Python attribute *sevabot_handler* which is an instance

    """
    def __init__(self, skype, name, path):
        self.path = path
        self.name = name
        self.init(skype)

    @staticmethod
    def is_valid(path):
        """ Is this a module we are looking for """

        if not path.endswith(".py"):
            return False

        f = open(path, "rb")
        data = f.read(16)
        f.close()
        if data.startswith("#!/sevabot"):
            return True

        return False

    @fail_safe
    def init(self, skype):
        """
        (Re)load Python code and get access to exported class instance.

        Bound stateful handler to a Skype instance.
        """
        # http://docs.python.org/2/library/imp.html#imp.load_module
        module = imp.load_source(self.name, self.path)
        self.handler = module.sevabot_handler

        self.handler.init(skype)

    @fail_safe
    def shutdown(self):
        """
        Called when we know the stae shutdown will happen.

        E.g. during relaod
        """
        self.handler.shutdown()

    @fail_safe
    def handle(self, msg, status):
        return self.handler.handle_message(msg, status)


def load_module(sevabot, name, path):
    """
    Load a module by name.

    Determine if it's standalone script or stateful.
    """

    if StatefulModule.is_valid(path):
        return StatefulModule(sevabot, name, path)
    elif UNIXScriptModule.is_valid(path):
        return UNIXScriptModule(name, path)
    else:
        return None


def load_modules(sevabot):
    """
    Scan all modules folders for executable scripts.

    :param: Sevabot instance
    """

    unload_modules()

    for folder in settings.MODULE_PATHS:
        folder = os.path.abspath(folder)
        for f in os.listdir(folder):
            fpath = os.path.join(folder, f)

            # Remove file extension
            body, ext = os.path.splitext(f)

            module = load_module(sevabot, body, fpath)
            if module:
                logger.info("Discovered module %s: %s" % (body, fpath))
                _modules[body] = module

    if not len(_modules.keys()):
        raise RuntimeError("No modules found in: %s" % settings.MODULE_PATHS)

    return _modules.keys()


def unload_modules():
    """
    """
    for name, mod in _modules.items():
        mod.shutdown()

    _modules.clear()


def get_script_module(name):
    """
    Check if a named module exists.
    """
    mod = _modules.get(name, None)

    if not mod:
        return None

    if isinstance(mod, UNIXScriptModule):
        return mod

    return None


def get_message_handlers():
    """
    Return all stateful module handlers.

    :yield: list of handle(self, msg, status) functions called to every Skype message
    """
    for mod in _modules.values():
        if isinstance(mod, StatefulModule):
            yield mod.handle


class ExecutionManagedThread(threading.Thread):
    """
    A thread which will wait the actual task thread.join()
    """
    def __init__(self, func, default, timeout, callback):
        threading.Thread.__init__(self)
        self.result = default
        self.func = func
        self.callback = callback
        self.default = default
        self.timeout = timeout

    def run(self):
        runner = ExecutionThread(self.func)
        runner.start()
        runner.join(self.timeout)

        if runner.isAlive():
            logger.warn("Timeouted running external command")
            return self.callback(self.default)
        else:
            return self.callback(runner.result)


class ExecutionThread(threading.Thread):
    """
    Run any function.
    """
    def __init__(self, func):
        threading.Thread.__init__(self)
        self.result = None
        self.func = func

    def run(self):
        self.result = self.func()

########NEW FILE########
__FILENAME__ = stateful
"""

    Stateful module base class and interface description.

    All stateful Python modules

    - Get Skype4Py Skype instance on init - have full control over Skype and
      thus are not limited to !command handlers

    - Reside in the some modules/ folder as UNIX script modules

    - Have .py extension and be valid Python 2.7 modules

    - Have #!/sevabot magic string at the head of the file

    - Exports Python attribute *sevabot_handler* which is an instance of the class
      as described below

    Please note that in the future we might have different chat backends (GTalk)
    and thus have a same-same-but-different stateful handlers.

"""


class StatefulSkypeHandler:
    """
    Base class for stateful handlers.

    All exceptions slip through are caught and logged.
    """

    def init(self, sevabot):
        """
        Set-up our state. This is called every time module is (re)loaded.

        You can get Skype4Py instance via ``sevabot.getSkype()``.

        :param sevabot: Handle to Sevabot instance
        """

    def handle_message(self, msg, status):
        """Override this method to have a customized handler for each Skype message.

        :param msg: ChatMessage instance https://github.com/awahlig/skype4py/blob/master/Skype4Py/chat.py#L409

        :param status: -

        :return: True if the message was handled and should not be further processed
        """

    def shutdown():
        """ Called when the module is reloaded.

        In ``shutdown()`` you must

        * Stop all created threads

        * Unregister all event handlers

        ..note ::

             We do *not* guaranteed to be call when Sevabot process shutdowns as
             the process may terminate with SIGKILL.

        """

    def register_callback(self, skype, event, callback):
        """
        Register any callable as a callback for a skype event.

        Thin wrapper for RegisterEventHandler https://github.com/awahlig/skype4py/blob/master/Skype4Py/utils.py

        :param skype: Skype4Py instance

        :param event: Same as Event

        :param callback: Same as Target

        :return: Same as RegisterEventHandler
        """

        return skype.RegisterEventHandler(event, callback)

    def unregister_callback(self, skype, event, callback):
        """
        Unregister a callback previously registered with register_callback.

        Thin wrapper for UnregisterEventHandler https://github.com/awahlig/skype4py/blob/master/Skype4Py/utils.py

        :param skype: Skype4Py instance

        :param event: Same as Event

        :param callback: Same as Target

        :return: Same as UnregisterEventHandler
        """

        return skype.UnregisterEventHandler(event, callback)

########NEW FILE########
__FILENAME__ = api
# -*- coding: utf-8 -*-
"""

    Supported external web service hooks

"""

import json
import logging

from hashlib import md5

from flask.views import View, request

logger = logging.getLogger(__name__)


class SendMessage(View):
    """ A webhook endpoint which sends a message to a Skype chat.

    A generic base class for other webhooks.

    Use HTTP POST parameters

    * msg

    * chat

    Other parameters are for compatibility reasons only and will be removed in the future.

    We validate only shared secret, not message signing.
    """

    methods = ['POST']

    def __init__(self, sevabot, shared_secret):
        self.sevabot = sevabot
        self.shared_secret = shared_secret

    #noinspection PyMethodOverriding
    def dispatch_request(self, *args, **kwargs):

        self.args = args
        self.kwargs = kwargs

        try:
            # BBB: Use only "chat" in the future
            chat_id = self.get_parameter('chat_id') or self.get_parameter('chat')

            if chat_id:
                if not self.validate(kwargs):
                    logger.error("Validation failed")
                    return "Validation failed!", 403, {"Content-type": "text/plain"}
                else:
                    msg = self.compose()

                    if not msg:
                        return "Message payload missing", 500, {"Content-type": "text/plain"}

                    self.sevabot.sendMessage(chat_id, msg)
                    logger.info("Successfully sent message %s" % msg)
                    return "OK"
            else:
                logger.error("Not enough parameters to send message (chat id missing)")
                return "Not enough parameters to send message!", 500, {"Content-type": "text/plain"}
        except Exception as e:
            logger.error(e)
            logger.exception(e)
            return (u"%s" % e).encode("utf-8"), 500, {"Content-type": "text/plain"}

    def get_parameter(self, key):
        """ Return parameter either from request or from url parameters """
        return request.form.get(key) or self.kwargs.get(key)

    def validate(self, kwargs):
        shared_secret = self.get_parameter('shared_secret')
        return shared_secret == self.shared_secret

    def compose(self):
        """
        Parse Skype chat message from the payload.

        .. note ::

            Use msg parameter. Others are provided for backward compatibility.

        """
        return request.form.get('message', '') or request.form.get('msg', '') or request.form.get('data', '')


class SendMessageMD5(SendMessage):
    """
    Send a MD5 signed chat message.

    HTTP POST parameters

    :param chat: Chat id

    :param msg: Message payload

    :param md5: MD5 checksum

    Make sure your client encodes message in UTF-8.
    """
    def validate(self, kwargs):

        # BBB: Use only "chat" in the future
        chat_id = self.get_parameter('chat_id') or self.get_parameter('chat')
        message = self.get_parameter('message') or self.get_parameter('msg')
        md5_value = self.get_parameter('md5')

        chat_encoded = chat_id.encode("utf-8")
        msg_encoded = message.encode("utf-8")

        md5_check = md5(chat_encoded + msg_encoded + self.shared_secret).hexdigest()

        return md5_check == md5_value


class SendMessageUnsigned(SendMessage):
    """
    HTTP endpoint to  send non-verified message to a chat.

    Takes both *chat_id* and *message* parameters as HTTP POST payload.

    .. warn::

        Allows third party to flood the chat if he/she gets hold of a chat id.

    HTTP POST parameters

    :param chat: Chat id

    :param msg: Message payload

    All other HTTP POST parameters are ignored.

    Make sure your client encodes message in UTF-8.
    """
    def validate(self, kwargs):
        return True


class GitHubPostCommit(SendMessage):
    """
    Handle post-commit hook from Github.

    https://help.github.com/articles/post-receive-hooks/
    """

    def compose(self):

        payload = json.loads(request.form["payload"])

        msg = u"(*) %s fresh commits - %s\n" % (payload["repository"]["name"], payload["repository"]["url"])
        for c in payload["commits"]:
            msg += u"(*) %s: %s\n%s\n" % (c["author"]["name"], c["message"], c["url"])

        return msg
		
class GitHubPullRequest(SendMessage):
    """
    Handle post-commit hook from Github.

    https://help.github.com/articles/post-receive-hooks/
    """

    def compose(self):

        payload = json.loads(request.form["payload"])
        
        if payload["action"] == "opened":
            msg = u"(*) %s new pull request %s from %s - %s\n" % (payload["repository"]["name"], payload["number"], payload["pull_request"]["user"]["login"], payload["pull_request"]["html_url"])
        elif payload["action"] == "closed":
            msg = u"(y) %s pull request %s merged by %s - %s\n" % (payload["repository"]["name"], payload["number"], payload["pull_request"]["merged_by"]["login"], payload["pull_request"]["html_url"])
        else:
            msg = u""
        return msg

class JenkinsNotifier(SendMessage):

    """
    Handle requests from Jenkins notifier plugin

    https://wiki.jenkins-ci.org/display/JENKINS/Notification+Plugin
    """

    def compose(self):
        msg = None
        payload = request.json

        if payload is None:
            logger.error("Jenkins did not post a valid HTTP POST payload. Check the logs for further info.")
            return "Jenkins bad notification: Could not read HTTP POST data"
        # Filter out completed status, lots of unneeded noise
        if payload['build']['phase'] != 'COMPLETED':
            if payload['build']['status'] == 'SUCCESS':
                msg = u'Project: %s build #%d %s Status: %s - (sun) - %s\n' % (payload['name'], payload['build']['number'], payload['build']['phase'], payload['build']['status'], payload['build']['full_url'])
            elif payload['build']['status'] == 'FAILURE':
                msg = u'Project: %s build #%d %s Status: %s - (rain) - %s\n' % (payload['name'], payload['build']['number'], payload['build']['phase'], payload['build']['status'], payload['build']['full_url'])
            else:
                msg = u'Project: %s build #%d %s Status: %s - - %s\n' % (payload['name'], payload['build']['number'], payload['build']['phase'], payload['build']['status'], payload['build']['full_url'])

        return msg


class TeamcityWebHook(SendMessage):

    def compose(self):
        payload = json.loads(request.data)
        build = payload.get('build')

        message = '%s\n%s' % (build.get('message'), build.get('buildStatusUrl'))

        return message


def configure(sevabot, settings, server):
    """
    Install Flask webhook routing
    """

       # this url rules for sending message. Parameters can be in url or in request
    server.add_url_rule('/message/', view_func=SendMessage.as_view(str('send_message'), sevabot=sevabot, shared_secret=settings.SHARED_SECRET))

    server.add_url_rule('/message_unsigned/', view_func=SendMessageUnsigned.as_view(str('send_message_unsigned'), sevabot=sevabot, shared_secret=settings.SHARED_SECRET))

    server.add_url_rule('/message/<string:chat_id>/', view_func=SendMessage.as_view(str('send_message_1'), sevabot=sevabot, shared_secret=settings.SHARED_SECRET))

    server.add_url_rule('/message/<string:chat_id>/<string:shared_secret>/', view_func=SendMessage.as_view(str('send_message_2'), sevabot=sevabot, shared_secret=settings.SHARED_SECRET))

    # XXX: Remove
    server.add_url_rule('/zapier/<string:chat_id>/<string:shared_secret>/', view_func=SendMessage.as_view(str('send_message_3'), sevabot=sevabot, shared_secret=settings.SHARED_SECRET))

    # rule for sending md5 signed message
    server.add_url_rule('/msg/', view_func=SendMessageMD5.as_view(str('send_message_md5'), sevabot=sevabot, shared_secret=settings.SHARED_SECRET))

    # rule for notifying on github commits
    server.add_url_rule('/github-post-commit/<string:chat_id>/<string:shared_secret>/', view_func=GitHubPostCommit.as_view(str('send_message_github_1'), sevabot=sevabot, shared_secret=settings.SHARED_SECRET))

    # rule for notifying on github pull requests
    server.add_url_rule('/github-pull-request/<string:chat_id>/<string:shared_secret>/', view_func=GitHubPullRequest.as_view(str('send_message_github_2'), sevabot=sevabot, shared_secret=settings.SHARED_SECRET))

    server.add_url_rule('/jenkins-notifier/<string:chat_id>/<string:shared_secret>/', view_func=JenkinsNotifier.as_view(str('send_message_jenkins'), sevabot=sevabot, shared_secret=settings.SHARED_SECRET))

    server.add_url_rule('/teamcity/<string:chat_id>/<string:shared_secret>/', view_func=TeamcityWebHook.as_view(str('send_message_teamcity'), sevabot=sevabot, shared_secret=settings.SHARED_SECRET))


########NEW FILE########
__FILENAME__ = daemon
# http://stackoverflow.com/questions/5975124/bring-the-current-python-program-to-background

import os

# Default daemon parameters.
# File mode creation mask of the daemon.
UMASK = 0

def create_daemon():
   """Detach a process from the controlling terminal and run it in the
   background as a daemon.
   """

   try:
      # Fork a child process so the parent can exit.  This returns control to
      # the command-line or shell.  It also guarantees that the child will not
      # be a process group leader, since the child receives a new process ID
      # and inherits the parent's process group ID.  This step is required
      # to insure that the next call to os.setsid is successful.
      pid = os.fork()
   except OSError, e:
      raise Exception, "%s [%d]" % (e.strerror, e.errno)

   if (pid == 0):   # The first child.
      # To become the session leader of this new session and the process group
      # leader of the new process group, we call os.setsid().  The process is
      # also guaranteed not to have a controlling terminal.
      os.setsid()

      # Is ignoring SIGHUP necessary?
      #
      # It's often suggested that the SIGHUP signal should be ignored before
      # the second fork to avoid premature termination of the process.  The
      # reason is that when the first child terminates, all processes, e.g.
      # the second child, in the orphaned group will be sent a SIGHUP.
      #
      # "However, as part of the session management system, there are exactly
      # two cases where SIGHUP is sent on the death of a process:
      #
      #   1) When the process that dies is the session leader of a session that
      #      is attached to a terminal device, SIGHUP is sent to all processes
      #      in the foreground process group of that terminal device.
      #   2) When the death of a process causes a process group to become
      #      orphaned, and one or more processes in the orphaned group are
      #      stopped, then SIGHUP and SIGCONT are sent to all members of the
      #      orphaned group." [2]
      #
      # The first case can be ignored since the child is guaranteed not to have
      # a controlling terminal.  The second case isn't so easy to dismiss.
      # The process group is orphaned when the first child terminates and
      # POSIX.1 requires that every STOPPED process in an orphaned process
      # group be sent a SIGHUP signal followed by a SIGCONT signal.  Since the
      # second child is not STOPPED though, we can safely forego ignoring the
      # SIGHUP signal.  In any case, there are no ill-effects if it is ignored.
      #
      # import signal           # Set handlers for asynchronous events.
      # signal.signal(signal.SIGHUP, signal.SIG_IGN)

      try:
         # Fork a second child and exit immediately to prevent zombies.  This
         # causes the second child process to be orphaned, making the init
         # process responsible for its cleanup.  And, since the first child is
         # a session leader without a controlling terminal, it's possible for
         # it to acquire one by opening a terminal in the future (System V-
         # based systems).  This second fork guarantees that the child is no
         # longer a session leader, preventing the daemon from ever acquiring
         # a controlling terminal.
         pid = os.fork()    # Fork a second child.
      except OSError, e:
         raise Exception, "%s [%d]" % (e.strerror, e.errno)

      if (pid == 0):    # The second child.
         # Since the current working directory may be a mounted filesystem, we
         # avoid the issue of not being able to unmount the filesystem at
         # shutdown time by changing it to the root directory.
         # os.chdir(WORKDIR)
         # We probably don't want the file mode creation mask inherited from
         # the parent, so we give the child complete control over permissions.
         os.umask(UMASK)
      else:
         # exit() or _exit()?  See below.
         os._exit(0)    # Exit parent (the first child) of the second child.
   else:
      # exit() or _exit()?
      # _exit is like exit(), but it doesn't call any functions registered
      # with atexit (and on_exit) or any registered signal handlers.  It also
      # closes any open file descriptors.  Using exit() may cause all stdio
      # streams to be flushed twice and any temporary files may be unexpectedly
      # removed.  It's therefore recommended that child branches of a fork()
      # and the parent branch(es) of a daemon use _exit().
      os._exit(0)   # Exit parent of the first child.
########NEW FILE########
__FILENAME__ = main
# -*- coding: utf-8 -*-
"""

    Application entry point.

"""
from __future__ import absolute_import, division, print_function, unicode_literals

import imp
import sys
import logging
import logging.handlers
import os

from flask import Flask
from flask import render_template
from flask import request

import plac

from sevabot.frontend import api
from sevabot.frontend.daemon import create_daemon

logger = logging.getLogger("sevabot")

server = Flask(__name__)

_sevabot = None


def get_bot():
    """
    We do lazy import here, because
    importing Skype4Py causes native DLL loading
    and may cause random segfaults, Skype pop-up dialogs or
    other unwanted side effects
    """
    global _sevabot
    if not _sevabot:
        from sevabot.bot.bot import Sevabot

        _sevabot = Sevabot()

    return _sevabot


def get_settings():
    """
    Lazy init wrapper around settings.
    """
    import settings

    return settings


@plac.annotations(
    settings=("Settings file", 'option', 's', None, None, "settings.py"),
    verbose=("Verbose debug output", 'flag', 'v', None, None),
    daemon=("Start as a detached background process", 'flag', 'd', None, None),
)
def main(settings="settings.py", verbose=False, daemon=False):
    """
    Application entry point.
    """

    # Expose settings global module
    try:
        settings = imp.load_source("settings", settings)
    except Exception:
        sys.exit("Could not load settings file: %s" % settings)

    # Config logging

    level = getattr(logging, getattr(settings, "LOG_LEVEL", "INFO").upper(), "INFO")

    logging.basicConfig(level=level, stream=sys.stdout, format=settings.LOG_FORMAT)

    # Setup logging file
    if getattr(settings, "LOG_FILE", None):
        if not settings.LOG_FILE.startswith("/"):
            log_path = settings.LOG_FILE
        else:
            log_path = os.path.join(os.path.dirname(settings.__file__), settings.LOG_FILE)

        formatter = logging.Formatter(settings.LOG_FORMAT)

        hdlr = logging.handlers.RotatingFileHandler(log_path,
                                                    encoding="utf-8",
                                                    maxBytes=settings.LOG_ROTATE_MAX_SIZE,
                                                    backupCount=settings.LOG_ROTATE_COUNT)

        hdlr.setFormatter(formatter)

        logger.addHandler(hdlr)

    logger.info("Starting sevabot")

    for skype_logger_name in ["Skype4Py.utils.EventHandlingBase", "Skype4Py.skype.Skype",
                              "Skype4Py.api.darwin.SkypeAPI"]:
        skype_logger = logging.getLogger(skype_logger_name)
        skype_logger.setLevel(logging.WARN)

    # Detach from the controlling terminal
    if daemon:
        create_daemon()

    from sevabot.bot import modules

    sevabot = get_bot()

    logger.info("Skype API connection established")

    sevabot.start()

    modules.load_modules(sevabot)

    api.configure(sevabot, settings, server)

    server.run(settings.HTTP_HOST, settings.HTTP_PORT, debug=False)

    # Should be never reached
    return 0


@server.route("/")
def root():
    """
    A simple HTTP interface test callback.
    """
    settings = get_settings()
    return render_template('index.html', host=settings.HTTP_HOST, port=settings.HTTP_PORT)


@server.route("/chats/", methods=["POST"])
def chats_post():
    """
    Print out chats and their ids, so you can register external services against the chat ids.
    """
    sevabot = get_bot()
    chats = sevabot.getOpenChats()
    settings = get_settings()

    shared_secret = request.form.get("secret")

    if shared_secret != settings.SHARED_SECRET:
        return "Bad shared secret", 403, {"Content-type": "text/plain"}

    return render_template('chats.html', chats=chats, shared_secret=shared_secret)


@server.route("/chat_message/<string:shared_secret>/<string:chat_id>/", methods=['GET'])
def chat_messages(shared_secret, chat_id):
    """
    A view to send a test message to a chat.
    """
    settings = get_settings()

    if shared_secret != settings.SHARED_SECRET:
        return "Bad shared secret", 403, {"Content-type": "text/plain"}

    return render_template('chat_message.html', chat_id=chat_id, shared_secret=shared_secret)


@server.before_request
def log_request():
    """
    HTTP debug logging.

    http://stackoverflow.com/questions/14687468/dumping-http-requests-with-flask
    """

    settings = get_settings()

    if getattr(settings, "DEBUG_HTTP", False):
        logger.debug("HTTP %s %s from %s" % (request.method, request.path, request.remote_addr))
        logger.debug("Headers ----")
        for key, value in request.headers.items():
            logger.debug("%s: %s" % (key, value))
        logger.debug("Payload ----")
        for key, value in request.form.items():
            if len(value) > 500:
                value = value[0:500]
            logger.debug("%s: %s" % (key, value))


def entry_point():
    exit_code = plac.call(main)
    return exit_code


if __name__ == '__main__':
    entry_point()

########NEW FILE########
__FILENAME__ = utils
"""

    Helper functions

"""

import hashlib
import logging

logger = logging.getLogger("sevabot")


def ensure_unicode(value):
    """
    Make sure we have a valid unicode string.
    """

    if type(value) == str:
        # Ignore errors even if the string is not proper UTF-8 or has
        # broken marker bytes.
        # Python built-in function unicode() can do this.
        value = unicode(value, "utf-8", errors="ignore")
    else:
        # Assume the value object has proper __unicode__() method
        value = unicode(value)

    return value


def fail_safe(func):
    """
    Python decorator to make sure we don't let exceptions slip through.

    We log all exceptions to logging output.
    """

    def closure(*args, **kwargs):
        try:
            return func(*args, **kwargs)
        except Exception as e:
            logger.exception(e)
            return False

    return closure


def get_chat_id(chat):
    """
    Get unique internal persistent id of the chat object.

    All ids are URL safe.

    This is the same id as in the web interface.

    :param chat: Skype4Py.chat.Chat instance
    """
    m = hashlib.md5()
    m.update(chat.Name)
    return m.hexdigest()


########NEW FILE########
