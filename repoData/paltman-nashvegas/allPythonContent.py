__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# nashvegas documentation build configuration file, created by
# sphinx-quickstart on Sun Feb 27 21:32:33 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'nashvegas'
copyright = u'2011, Patrick Altman'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.7'
# The full version, including alpha/beta/rc tags.
release = '0.7'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'nashvegasdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'nashvegas.tex', u'nashvegas Documentation',
   u'Patrick Altman', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'nashvegas', u'nashvegas Documentation',
     [u'Patrick Altman'], 1)
]

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from nashvegas.models import Migration


class MigrationAdmin(admin.ModelAdmin):
    list_display = ["migration_label", "date_created", "scm_version"]
    list_filter = ["date_created"]
    search_fields = ["content", "migration_label"]


admin.site.register(Migration, MigrationAdmin)

########NEW FILE########
__FILENAME__ = exceptions
class MigrationError(Exception):
    pass

########NEW FILE########
__FILENAME__ = comparedb
import difflib

from optparse import make_option
from subprocess import PIPE, Popen

from django.db import connections, DEFAULT_DB_ALIAS
from django.conf import settings
from django.core.management import call_command
from django.core.management.base import BaseCommand


NASHVEGAS = getattr(settings, "NASHVEGAS", {})


def ignorable_sql(line, level):
    if level == 0:
        return False  # ignore nothing

    # level 1 = ignore comments
    if level > 0 and line.lstrip().startswith("--"):
        return True

    # level 2 = ignore constraints
    if level > 1 and line.lstrip().lower().startswith("add constraint"):
        return True

    return False


def normalize_sql(lines, level=1):
    """ perform simple normalization: remove comments """
    return [line for line in lines if not ignorable_sql(line, level)]


class Command(BaseCommand):
    
    option_list = BaseCommand.option_list + (
        make_option("-n", "--name",
                    action="store",
                    dest="db_name",
                    help="The name of the database to hold the truth schema"
                         " (defaults to <name>_compare"),
        make_option("-d", "--database",
                    action="store",
                    dest="database",
                    default=DEFAULT_DB_ALIAS,
                    help="Nominates a database to synchronize. "
                         "Defaults to the \"default\" database."),
        make_option("-l", "--lines-of-context",
                    action="store",
                    dest="lines",
                    default=10,
                    help="Show this amount of context (default 10)."),
        make_option("-i", "--ignore-level",
                    action="store",
                    dest="ignore",
                    default=1,
                    help="Ignore level. 0=ignore nothing, 1=ignore comments (default), "
                         "2=ignore constraints"),
    )
    help = "Checks for schema differences."
    
    def setup_database(self):
        command = NASHVEGAS.get("createdb", "createdb {dbname}")
        Popen(command.format(dbname=self.compare_name), shell=True).wait()
    
    def teardown_database(self):
        command = NASHVEGAS.get("dropdb", "dropdb {dbname}")
        Popen(command.format(dbname=self.compare_name), shell=True).wait()
    
    def handle(self, *args, **options):
        """
        Compares current database with a migrations.
        
        Creates a temporary database, applies all the migrations to it, and
        then dumps the schema from both current and temporary, diffs them,
        then report the diffs to the user.
        """
        self.db = options.get("database", DEFAULT_DB_ALIAS)
        self.current_name = connections[self.db].settings_dict["NAME"]
        self.compare_name = options.get("db_name")
        self.lines = options.get("lines")
        self.ignore = int(options.get('ignore'))

        if not self.compare_name:
            self.compare_name = "%s_compare" % self.current_name
        
        command = NASHVEGAS.get("dumpdb", "pg_dump -s {dbname}")
        
        print "Getting schema for current database..."
        current_sql = Popen(
            command.format(dbname=self.current_name),
            shell=True,
            stdout=PIPE
        ).stdout.readlines()
        
        print "Getting schema for fresh database..."
        self.setup_database()
        connections[self.db].close()
        connections[self.db].settings_dict["NAME"] = self.compare_name
        try:
            call_command("syncdb", interactive=False, verbosity=0, migrations=False)
            new_sql = Popen(
                command.format(dbname=self.compare_name).split(),
                stdout=PIPE
            ).stdout.readlines()
        finally:
            connections[self.db].close()
            connections[self.db].settings_dict["NAME"] = self.current_name
            self.teardown_database()
        
        print "Outputing diff between the two..."
        print "".join(difflib.unified_diff(normalize_sql(current_sql, self.ignore),
                                           normalize_sql(new_sql, self.ignore),
                                           n=int(self.lines)))

########NEW FILE########
__FILENAME__ = syncdb
from django.core.management import call_command
from django.core.management.commands.syncdb import Command as SyncDBCommand
from optparse import make_option


class Command(SyncDBCommand):
    option_list = SyncDBCommand.option_list + (
        make_option('--skip-migrations',
                    action='store_false',
                    dest='migrations',
                    default=True,
                    help='Skip nashvegas migrations, do traditional syncdb'),
    )

    def handle_noargs(self, **options):
        # Run migrations first
        if options.get("database"):
            databases = [options.get("database")]
        else:
            databases = None
        migrations = options.get('migrations')

        if migrations:
            call_command(
                "upgradedb",
                do_execute=True,
                databases=databases,
                interactive=options.get("interactive"),
                verbosity=options.get("verbosity"),
            )

        # Follow up with a syncdb on anything that wasnt included in migrations
        # (this catches things like test-only models)
        super(Command, self).handle_noargs(**options)

########NEW FILE########
__FILENAME__ = upgradedb
import os
import re
import sys
import traceback

from optparse import make_option
from subprocess import Popen, PIPE

from django.db import connections, transaction, DEFAULT_DB_ALIAS
from django.db.models import get_model
from django.conf import settings
from django.core.management import call_command
from django.core.management.base import BaseCommand, CommandError
from django.core.management.sql import emit_post_sync_signal
from django.utils.importlib import import_module

from nashvegas.exceptions import MigrationError
from nashvegas.models import Migration
from nashvegas.utils import get_sql_for_new_models, get_capable_databases
from nashvegas.utils import get_pending_migrations


sys.path.append("migrations")
MIGRATION_NAME_RE = re.compile(r"(\d+)(.*)")


class Transactional(object):
    def __enter__(self):
        for db in connections:
            # enter transaction management
            transaction.enter_transaction_management(using=db)
            transaction.managed(True, using=db)
    
    def __exit__(self, exc_type, exc_value, traceback):
        for db in connections:
            if exc_type:
                transaction.rollback(using=db)
            else:
                transaction.commit(using=db)
            transaction.leave_transaction_management(using=db)


class Command(BaseCommand):
    
    option_list = BaseCommand.option_list + (
        make_option("-l", "--list",
                    action="store_true",
                    dest="do_list",
                    default=False,
                    help="Enumerate the list of migrations to execute."),
        make_option("-e", "--execute",
                    action="store_true",
                    dest="do_execute",
                    default=False,
                    help="Execute migrations not in versions table."),
        make_option("-c", "--create",
                    action="store_true",
                    dest="do_create",
                    default=False,
                    help="Generates sql for models that are installed but not "
                         "in your database."),
        make_option("--create-all",
                    action="store_true",
                    dest="do_create_all",
                    default=False,
                    help="Generates sql for models that are installed but not "
                         "in your database."),
        make_option("-s", "--seed",
                    action="store_true",
                    dest="do_seed",
                    default=False,
                    help="Seed nashvegas with migrations that have previously "
                         "been applied in another manner."),
        make_option("-d", "--database",
                    action="append",
                    dest="databases",
                    help="Nominates a database to synchronize."),
        make_option("--noinput",
                    action="store_false",
                    dest="interactive",
                    default=False,
                    help="Tells Django to NOT prompt the user for input of "
                         "any kind."),
        make_option("-p", "--path", dest="path",
                    default=None,
                    help="The path to the database migration scripts."))
    
    help = "Upgrade database."
    
    def _get_rev(self, fpath):
        """
        Get an SCM version number. Try svn and git.
        """
        rev = None
        
        try:
            cmd = ["git", "log", "-n1", "--pretty=format:\"%h\"", fpath]
            rev = Popen(cmd, stdout=PIPE, stderr=PIPE).communicate()[0]
        except:
            pass
        
        if not rev:
            try:
                cmd = ["svn", "info", fpath]
                svninfo = Popen(cmd,
                                stdout=PIPE,
                                stderr=PIPE).stdout.readlines()
                for info in svninfo:
                    tokens = info.split(":")
                    if tokens[0].strip() == "Last Changed Rev":
                        rev = tokens[1].strip()
            except:
                pass
        
        return rev
    
    def _get_current_migration_number(self, database):
        try:
            result = Migration.objects.using(
                database
            ).order_by('-migration_label')[0]
        except IndexError:
            return 0
        match = MIGRATION_NAME_RE.match(result.migration_label)
        return int(match.group(1))
    
    def _get_migration_path(self, db, migration):
        default_exists = os.path.exists(os.path.join(self.path, migration))
        if db == DEFAULT_DB_ALIAS and default_exists:
            migration_path = os.path.join(self.path, migration)
        else:
            migration_path = os.path.join(self.path, db, migration)

        return migration_path
    
    def _execute_migration(self, database, migration, show_traceback=True):
        created_models = set()
        
        with open(migration, "rb") as fp:
            lines = fp.readlines()
        content = "".join(lines)
        
        if migration.endswith(".sql"):
            # TODO: this should support proper comments
            to_execute = "".join(
                [l for l in lines if not l.startswith("### New Model: ")]
            )
            connection = connections[database]
            cursor = connection.cursor()
            
            try:
                cursor.execute(to_execute)
                cursor.close()
            except Exception:
                sys.stdout.write("failed\n")
                if show_traceback:
                    traceback.print_exc()
                raise MigrationError()
            else:
                sys.stdout.write("success\n")
            
            for l in lines:
                if l.startswith("### New Model: "):
                    created_models.add(
                        get_model(
                            *l.replace(
                                "### New Model: ",
                                ""
                            ).strip().split(".")
                        )
                    )
        
        elif migration.endswith(".py"):
            # TODO: python files have no concept of active database
            #       we should probably pass it to migrate()
            module = {}
            execfile(migration, {}, module)
            
            if "migrate" in module and callable(module["migrate"]):
                try:
                    module["migrate"]()
                except Exception:
                    sys.stdout.write("failed\n")
                    if show_traceback:
                        traceback.print_exc()
                    raise MigrationError()
                else:
                    sys.stdout.write("success\n")
        
        Migration.objects.using(database).create(
            migration_label=os.path.split(migration)[-1],
            content=content,
            scm_version=self._get_rev(migration),
        )
        
        return created_models
    
    def init_nashvegas(self):
        # Copied from line 35 of django.core.management.commands.syncdb
        # Import the 'management' module within each installed app, to
        # register dispatcher events.
        for app_name in settings.INSTALLED_APPS:
            try:
                import_module(".management", app_name)
            except ImportError, exc:
                # This is slightly hackish. We want to ignore ImportErrors
                # if the "management" module itself is missing -- but we don't
                # want to ignore the exception if the management module exists
                # but raises an ImportError for some reason. The only way we
                # can do this is to check the text of the exception. Note that
                # we're a bit broad in how we check the text, because
                # different Python implementations may not use the same text.
                # CPython uses the text "No module named management"
                # PyPy uses "No module named myproject.myapp.management"
                msg = exc.args[0]
                if not msg.startswith("No module named") or "management" not in msg:
                    raise
        
        # @@@ make cleaner / check explicitly for model instead of looping
        #     over and doing string comparisons
        databases = self.databases or get_capable_databases()
        for database in databases:
            connection = connections[database]
            cursor = connection.cursor()
            all_new = get_sql_for_new_models(['nashvegas'], using=database)
            for lines in all_new:
                to_execute = "\n".join([
                    l
                    for l in lines.split("\n")
                    if not l.startswith("### New Model: ")
                ])
                if not to_execute:
                    continue
                cursor.execute(to_execute)
                transaction.commit_unless_managed(using=database)
    
    def create_all_migrations(self):
        for database in get_capable_databases():
            statements = get_sql_for_new_models(using=database)
            if len(statements) == 0:
                continue
            
            number = self._get_current_migration_number(database)
            
            db_path = os.path.join(self.path, database)
            if not os.path.exists(db_path):
                os.makedirs(db_path)
            
            path = os.path.join(
                db_path,
                "%s.sql" % (str(number + 1).zfill(4),)
            )
            if os.path.exists(path):
                raise CommandError(
                    "Unable to create %r: File already exists" % path
                )
            
            with open(path, 'w') as fp:
                for s in statements:
                    fp.write(s + '\n')
            
            print "Created new migration: %r" % path
    
    def create_migrations(self, database):
        statements = get_sql_for_new_models(self.args, using=database)
        if len(statements) > 0:
            for s in statements:
                print s
    
    def execute_migrations(self, show_traceback=True):
        """
        Executes all pending migrations across all capable
        databases
        """
        all_migrations = get_pending_migrations(self.path, self.databases)
        
        if not len(all_migrations):
            sys.stdout.write("There are no migrations to apply.\n")
        
        for db, migrations in all_migrations.iteritems():
            connection = connections[db]
            
            # init connection
            cursor = connection.cursor()
            cursor.close()
                        
            for migration in migrations:
                migration_path = self._get_migration_path(db, migration)
                
                with Transactional():
                    sys.stdout.write(
                        "Executing migration %r on %r...." %
                        (migration, db)
                    )
                    created_models = self._execute_migration(
                        db,
                        migration_path,
                        show_traceback=show_traceback
                    )

                    emit_post_sync_signal(
                        created_models=created_models,
                        verbosity=self.verbosity,
                        interactive=self.interactive,
                        db=db,
                    )
            
            if self.load_initial_data:
                sys.stdout.write(
                    "Running loaddata for initial_data fixtures on %r.\n" % db
                )
                call_command(
                    "loaddata",
                    "initial_data",
                    verbosity=self.verbosity,
                    database=db,
                )
    
    def seed_migrations(self, stop_at=None):
        # @@@ the command-line interface needs to be re-thinked
        # TODO: this needs to be able to handle multi-db when you're
        #       specifying stop_at
        if stop_at is None and self.args:
            stop_at = self.args[0]
        
        if stop_at:
            try:
                stop_at = int(stop_at)
            except ValueError:
                raise CommandError("Invalid --seed migration")
            except IndexError:
                raise CommandError(
                    "Usage: ./manage.py upgradedb --seed [stop_at]"
                )

        all_migrations = get_pending_migrations(
            self.path, self.databases, stop_at=stop_at
        )
        for db, migrations in all_migrations.iteritems():
            for migration in migrations:
                migration_path = self._get_migration_path(db, migration)

                m, created = Migration.objects.using(db).get_or_create(
                    migration_label=os.path.split(migration)[-1],
                    content=open(migration_path, "rb").read()
                )
                if created:
                    # this might have been executed prior to committing
                    m.scm_version = self._get_rev(migration)
                    m.save()
                    print "%s:%s has been seeded" % (db, m.migration_label)
                else:
                    print "%s:%s was already applied" % (
                        db, m.migration_label
                    )
    
    def list_migrations(self):
        all_migrations = get_pending_migrations(self.path, self.databases)
        if len(all_migrations) == 0:
            print "There are no migrations to apply."
            return
        
        print "Migrations to Apply:"
        for database, migrations in all_migrations.iteritems():
            for script in migrations:
                print "\t%s: %s" % (database, script)
    
    def _get_default_migration_path(self):
        try:
            path = os.path.dirname(os.path.normpath(
                os.sys.modules[settings.SETTINGS_MODULE].__file__)
            )
        except KeyError:
            path = os.getcwd()
        return os.path.join(path, "migrations")

    def handle(self, *args, **options):
        """
        Upgrades the database.
        
        Executes SQL scripts that haven't already been applied to the
        database.
        """
        self.do_list = options.get("do_list")
        self.do_execute = options.get("do_execute")
        self.do_create = options.get("do_create")
        self.do_create_all = options.get("do_create_all")
        self.do_seed = options.get("do_seed")
        self.load_initial_data = options.get("load_initial_data", True)
        self.args = args
        
        if options.get("path"):
            self.path = options.get("path")
        else:
            default_path = self._get_default_migration_path()
            self.path = getattr(
                settings, "NASHVEGAS_MIGRATIONS_DIRECTORY", default_path
            )
        
        self.verbosity = int(options.get("verbosity", 1))
        self.interactive = options.get("interactive")
        self.databases = options.get("databases")
        
        # We only use the default alias in creation scenarios (upgrades
        # default to all databases)
        if self.do_create and not self.databases:
            self.databases = [DEFAULT_DB_ALIAS]
        
        if self.do_create and self.do_create_all:
            raise CommandError("You cannot combine --create and --create-all")
        
        self.init_nashvegas()
        
        if self.do_create_all:
            self.create_all_migrations()
        elif self.do_create:
            assert len(self.databases) == 1
            self.create_migrations(self.databases[0])
        
        if self.do_execute:
            self.execute_migrations()
        
        if self.do_list:
            self.list_migrations()
        
        if self.do_seed:
            self.seed_migrations()

########NEW FILE########
__FILENAME__ = models
from django.db import models

try:
    from django.utils.timezone import now
    now
except ImportError:
    import datetime
    now = datetime.datetime.now


class Migration(models.Model):
    
    migration_label = models.CharField(max_length=200)
    date_created = models.DateTimeField(default=now)
    content = models.TextField()
    scm_version = models.CharField(max_length=50, null=True, blank=True)
    
    def __unicode__(self):
        return unicode("%s [%s]" % (self.migration_label, self.scm_version))

########NEW FILE########
__FILENAME__ = utils
import itertools
import os.path
import re

from collections import defaultdict
from django.core.management.color import no_style
from django.core.management.sql import custom_sql_for_model
from django.db import connections, router, models, DEFAULT_DB_ALIAS
from django.utils.datastructures import SortedDict
from nashvegas.exceptions import MigrationError
from nashvegas.models import Migration

MIGRATION_NAME_RE = re.compile(r"(\d+)(.*)")


def get_sql_for_new_models(apps=None, using=DEFAULT_DB_ALIAS):
    """
    Unashamedly copied and tweaked from django.core.management.commands.syncdb
    """
    connection = connections[using]
    
    # Get a list of already installed *models* so that references work right.
    tables = connection.introspection.table_names()
    seen_models = connection.introspection.installed_models(tables)
    created_models = set()
    pending_references = {}
    
    if apps:
        apps = [models.get_app(a) for a in apps]
    else:
        apps = models.get_apps()
    
    # Build the manifest of apps and models that are to be synchronized
    all_models = [
        (app.__name__.split('.')[-2], [
            m
            for m in models.get_models(app, include_auto_created=True)
            if router.allow_syncdb(using, m)
        ])
        for app in apps
    ]
    
    def model_installed(model):
        opts = model._meta
        converter = connection.introspection.table_name_converter
        db_table_in = (converter(opts.db_table) in tables)
        auto_create_in = (
            opts.auto_created and
            converter(opts.auto_created._meta.db_table) in tables
        )
        return not (db_table_in or auto_create_in)
    
    manifest = SortedDict(
        (app_name, filter(model_installed, model_list))
        for app_name, model_list in all_models
    )
    
    statements = []
    sql = None
    for app_name, model_list in manifest.items():
        for model in model_list:
            # Create the model's database table, if it doesn't already exist.
            sql, references = connection.creation.sql_create_model(
                model,
                no_style(),
                seen_models
            )
            
            seen_models.add(model)
            created_models.add(model)
            statements.append("### New Model: %s.%s" % (
                app_name,
                str(model).replace("'>", "").split(".")[-1]
            ))
            
            for refto, refs in references.items():
                pending_references.setdefault(refto, []).extend(refs)
                if refto in seen_models:
                    sql.extend(
                        connection.creation.sql_for_pending_references(
                            refto,
                            no_style(),
                            pending_references
                        )
                    )
            
            sql.extend(
                connection.creation.sql_for_pending_references(
                    model,
                    no_style(),
                    pending_references
                )
            )
            statements.extend(sql)
    
    custom_sql = None
    for app_name, model_list in manifest.items():
        for model in model_list:
            if model in created_models:
                custom_sql = custom_sql_for_model(
                    model,
                    no_style(),
                    connection
                )
                
                if custom_sql:
                    statements.extend(custom_sql)
    
    index_sql = None
    for app_name, model_list in manifest.items():
        for model in model_list:
            if model in created_models:
                index_sql = connection.creation.sql_indexes_for_model(
                    model,
                    no_style()
                )
                
                if index_sql:
                    statements.extend(index_sql)
    
    return statements


def get_capable_databases():
    """
    Returns a list of databases which are capable of supporting
    Nashvegas (based on their routing configuration).
    """
    for database in connections:
        if router.allow_syncdb(database, Migration):
            yield database


def get_file_list(path, max_depth=1, cur_depth=0):
    """
    Recursively returns a list of all files up to ``max_depth``
    in a directory.
    """
    if os.path.exists(path):
        for name in os.listdir(path):
            if name.startswith('.'):
                continue
            
            full_path = os.path.join(path, name)
            if os.path.isdir(full_path):
                if cur_depth == max_depth:
                    continue
                
                file_list = get_file_list(full_path, max_depth, cur_depth + 1)
                for result in file_list:
                    yield result
            else:
                yield full_path


def get_applied_migrations(databases=None):
    """
    Returns a dictionary containing lists of all applied migrations
    where the key is the database alias.
    """
    if not databases:
        databases = get_capable_databases()
    else:
        # We only loop through databases that are listed as "capable"
        all_databases = list(get_capable_databases())
        databases = list(
            itertools.ifilter(lambda x: x in all_databases, databases)
        )
    
    results = defaultdict(list)
    for db in databases:
        for x in Migration.objects.using(db).order_by("migration_label"):
            results[db].append(x.migration_label)
    
    return results


def get_all_migrations(path, databases=None):
    """
    Returns a dictionary of database => [migrations] representing all
    migrations contained in ``path``.
    """
    # database: [(number, full_path)]
    possible_migrations = defaultdict(list)
    
    try:
        in_directory = sorted(get_file_list(path))
    except OSError:
        import traceback
        print "An error occurred while reading migrations from %r:" % path
        traceback.print_exc()
        return {}
    
    # Iterate through our results and discover which migrations are
    # actually runnable
    for full_path in in_directory:
        child_path, script = os.path.split(full_path)
        name, ext = os.path.splitext(script)
        
        # the database component is default if this is in the root directory
        # is <directory> if in a subdirectory
        if path == child_path:
            db = DEFAULT_DB_ALIAS
        else:
            db = os.path.split(child_path)[-1]
        
        # filter by database if set
        if databases and db not in databases:
            continue
        
        match = MIGRATION_NAME_RE.match(name)
        if match is None:
            raise MigrationError("Invalid migration file prefix %r "
                                 "(must begin with a number)" % name)
        
        number = int(match.group(1))
        if ext in [".sql", ".py"]:
            possible_migrations[db].append((number, full_path))
    
    return possible_migrations


def get_pending_migrations(path, databases=None, stop_at=None):
    """
    Returns a dictionary of database => [migrations] representing all pending
    migrations.
    """
    if stop_at is None:
        stop_at = float("inf")
    
    # database: [(number, full_path)]
    possible_migrations = get_all_migrations(path, databases)
    # database: [full_path]
    applied_migrations = get_applied_migrations(databases)
    # database: [full_path]
    to_execute = defaultdict(list)
    
    for database, scripts in possible_migrations.iteritems():
        applied = applied_migrations[database]
        pending = to_execute[database]
        for number, migration in scripts:
            path, script = os.path.split(migration)
            if script not in applied and number <= stop_at:
                pending.append(script)
    
    return dict((k, v) for k, v in to_execute.iteritems() if v)

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
import sys
from os.path import dirname, abspath

sys.path.insert(0, dirname(abspath(__file__)))

from django.conf import settings

if not settings.configured:
    settings.configure(
        DATABASES={
            'default': {
                'ENGINE': 'django.db.backends.sqlite3',
                'NAME': ':memory:',
            },
            'other': {
                'ENGINE': 'django.db.backends.sqlite3',
                'NAME': ':memory:',
            },
        },
        INSTALLED_APPS=[
            'nashvegas',
            'tests',
        ],
        ROOT_URLCONF='',
        DEBUG=False,
        SITE_ID=1,
        TEMPLATE_DEBUG=True,
    )

from django_nose import NoseTestSuiteRunner


def runtests(*test_args, **kwargs):
    if not test_args:
        test_args = ['tests']

    kwargs.setdefault('interactive', False)

    test_runner = NoseTestSuiteRunner(**kwargs)

    failures = test_runner.run_tests(test_args)
    sys.exit(failures)

if __name__ == '__main__':
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option('--verbosity', dest='verbosity', action='store', default=1, type=int)
    parser.add_options(NoseTestSuiteRunner.options)
    (options, args) = parser.parse_args()

    runtests(*args, **options.__dict__)

########NEW FILE########
__FILENAME__ = 0003

########NEW FILE########
__FILENAME__ = 0002_foo

########NEW FILE########
__FILENAME__ = tests
import mock
from django.test import TestCase
from nashvegas.utils import get_capable_databases, get_all_migrations, \
  get_file_list, get_pending_migrations
from os.path import join, dirname

mig_root = join(dirname(__import__('tests', {}, {}, [], -1).__file__), 'fixtures', 'migrations')


class GetCapableDatabasesTest(TestCase):
    def test_default_routing(self):
        results = list(get_capable_databases())
        self.assertEquals(len(results), 2)
        self.assertTrue('default' in results)
        self.assertTrue('other' in results)


class GetFileListTest(TestCase):
    def test_recursion(self):
        path = join(mig_root, 'multidb')
        results = list(get_file_list(path))
        self.assertEquals(len(results), 4)
        self.assertTrue(join(path, 'default', '0001.sql') in results)
        self.assertTrue(join(path, 'default', '0002_foo.py') in results)
        self.assertTrue(join(path, 'other', '0001.sql') in results)
        self.assertTrue(join(path, 'other', '0002_bar.sql') in results)


class GetAllMigrationsTest(TestCase):
    def test_multidb(self):
        path = join(mig_root, 'multidb')
        results = dict(get_all_migrations(path))
        self.assertEquals(len(results), 2)
        self.assertTrue('default' in results)
        self.assertTrue('other' in results)

        default = results['default']
        self.assertEquals(len(default), 2)
        self.assertTrue((1, join(path, 'default', '0001.sql')) in default)
        self.assertTrue((2, join(path, 'default', '0002_foo.py')) in default)

        other = results['other']
        self.assertEquals(len(other), 2)
        self.assertTrue((1, join(path, 'other', '0001.sql')) in other)
        self.assertTrue((2, join(path, 'other', '0002_bar.sql')) in other)


class GetPendingMigrationsTest(TestCase):
    @mock.patch('nashvegas.utils.get_all_migrations')
    @mock.patch('nashvegas.utils.get_applied_migrations')
    def test_handles_duplicate_migration_numbers(self, get_applied_migrations, get_all_migrations):
        get_applied_migrations.return_value = {
            'dupes': ['0001.sql', '0002_foo.sql'],
        }
        get_all_migrations.return_value = {
            'dupes': [(1, '0001.sql'), (2, '0002_bar.sql'), (2, '0002_foo.sql')],
        }

        path = join(mig_root, 'multidb')
        results = dict(get_pending_migrations(path))

        get_applied_migrations.assert_called_once_with(None)
        get_all_migrations.assert_called_once_with(path, None)

        self.assertEquals(len(results), 1)
        self.assertTrue('dupes' in results)
        self.assertEquals(len(results['dupes']), 1)
        self.assertTrue('0002_bar.sql' in results['dupes'])

########NEW FILE########
