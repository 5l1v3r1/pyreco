__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# pip-accel documentation build configuration file. This file is execfile()d
# with the current directory set to its containing dir.

import sys, os

# Add the pip_accel source distribution's root directory to the module path.
sys.path.insert(0, os.path.abspath('..'))

# -- General configuration -----------------------------------------------------

# Sphinx extension module names.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']

# Paths that contain templates, relative to this directory.
templates_path = ['templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'pip-accel'
copyright = u'2013, Peter Odding and Paylogic International'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.

# Find the package version and make it the release.
from pip_accel import __version__ as pip_accel_version

# The short X.Y version.
version = '.'.join(pip_accel_version.split('.')[:2])

# The full version, including alpha/beta/rc tags.
release = pip_accel_version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
language = 'en'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['build']

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = True

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# Refer to the Python standard library.
# From: http://twistedmatrix.com/trac/ticket/4582.
intersphinx_mapping = {'python': ('http://docs.python.org', None)}

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['static']

# Output file base name for HTML help builder.
htmlhelp_basename = 'pip-acceldoc'

########NEW FILE########
__FILENAME__ = bdist
# Functions to manipulate Python binary distribution archives.
#
# Author: Peter Odding <peter.odding@paylogic.eu>
# Last Change: May 24, 2014
# URL: https://github.com/paylogic/pip-accel

"""
Binary distribution archive manipulation
========================================

The functions in this module are used to create, transform and install from
binary distribution archives.
"""

# Standard library modules.
import hashlib
import logging
import os
import os.path
import pipes
import re
import shutil
import subprocess
import tarfile
import tempfile
import time

# External dependencies.
from humanfriendly import Spinner, Timer

# Modules included in our package.
from pip_accel.config import binary_index
from pip_accel.deps import sanity_check_dependencies
from pip_accel.utils import get_python_version

# Initialize a logger for this module.
logger = logging.getLogger(__name__)

def get_binary_dist(package, version, directory, url=None, python='/usr/bin/python', prefix='/usr'):
    """
    Get the cached binary distribution archive that was previously built for
    the given package (name, version) (and optionally URL). If no archive has
    been cached yet, a new binary distribution archive is created and added to
    the cache.

    :param package: The name of the requirement to build.
    :param version: The version of the requirement to build.
    :param directory: The directory where the unpacked sources of the
                      requirement are available.
    :param url: The URL of the requirement, optional. When given this is used
                to generate the filename of the cached binary distribution.
    :param python: The pathname of the Python executable to use to run
                   ``setup.py`` (obviously this should point to a working
                   Python installation).
    :param prefix: The prefix that the original binary distribution was created for.
    :returns: An iterable of tuples with two values each: A
              :py:class:`tarfile.TarInfo` object and a file-like object.
    """
    tag = hashlib.sha1(str(version + url).encode()).hexdigest() if url else version
    cache_file = os.path.join(binary_index, '%s:%s:%s.tar.gz' % (package, tag, get_python_version()))
    if not os.path.isfile(cache_file):
        logger.debug("%s (%s) hasn't been cached yet, doing so now.", package, version)
        # Build the binary distribution.
        try:
            raw_file = build_binary_dist(package, version, directory, python=python)
        except BuildFailed:
            sanity_check_dependencies(package)
            raw_file = build_binary_dist(package, version, directory, python=python)
        # Transform the binary distribution archive into a form that we can re-use.
        transformed_file = '%s.tmp-%i' % (cache_file, os.getpid())
        archive = tarfile.open(transformed_file, 'w:gz')
        for member, from_handle in transform_binary_dist(raw_file, prefix=prefix):
            archive.addfile(member, from_handle)
        archive.close()
        # Try to avoid race conditions between multiple processes by atomically
        # moving the transformed binary distribution into its final place.
        os.rename(transformed_file, cache_file)
        logger.debug("%s (%s) cached as %s.", package, version, cache_file)
    archive = tarfile.open(cache_file, 'r:gz')
    for member in archive.getmembers():
        yield member, archive.extractfile(member.name)
    archive.close()

def build_binary_dist(package, version, directory, python='/usr/bin/python'):
    """
    Convert a single, unpacked source distribution to a binary distribution.
    Raises an exception if it fails to create the binary distribution (probably
    because of missing binary dependencies like system libraries).

    :param package: The name of the requirement to build.
    :param version: The version of the requirement to build.
    :param directory: The directory where the unpacked sources of the
                      requirement are available.
    :param python: The pathname of the Python executable to use to run
                   ``setup.py`` (obviously this should point to a working
                   Python installation).
    :returns: The pathname of the resulting binary distribution (a string).
    """
    build_timer = Timer()
    # Make sure the source distribution contains a setup script.
    setup_script = os.path.join(directory, 'setup.py')
    if not os.path.isfile(setup_script):
        msg = "Directory %s (%s %s) doesn't contain a source distribution!"
        raise InvalidSourceDistribution(msg % (directory, package, version))
    # Let the user know what's going on.
    build_text = "Building binary distribution of %s (%s) .." % (package, version)
    logger.info("%s", build_text)
    # Cleanup previously generated distributions.
    dist_directory = os.path.join(directory, 'dist')
    if os.path.isdir(dist_directory):
        logger.debug("Cleaning up previously generated distributions in %s ..", dist_directory)
        shutil.rmtree(dist_directory)
    # Compose the command line needed to build the binary distribution.
    command_line = '%s setup.py bdist_dumb --format=tar' % pipes.quote(python)
    logger.debug("Executing external command: %s", command_line)
    # Redirect all output of the build to a temporary file.
    fd, temporary_file = tempfile.mkstemp()
    command_line = '%s > "%s" 2>&1' % (command_line, temporary_file)
    try:
        # Start the build.
        build = subprocess.Popen(['sh', '-c', command_line], cwd=directory)
        # Wait for build to finish, provide feedback to the user in the mean time.
        spinner = Spinner(build_text)
        while build.poll() is None:
            spinner.step()
            time.sleep(0.1)
        spinner.clear()
        # Check whether the build succeeded.
        if build.returncode != 0:
            # It it didn't we'll provide the user with some hints as to what went wrong.
            msg = "Failed to build binary distribution of %s (%s)!" % (package, version)
            logger.error("%s", msg)
            with open(temporary_file) as handle:
                logger.info("Build output (will probably provide a hint as to what went wrong):\n%s", handle.read())
            raise BuildFailed(msg)
        # Check if we can find the binary distribution archive.
        filenames = os.listdir(dist_directory)
        if len(filenames) != 1:
            msg = "Build process did not result in one binary distribution! (matches: %s)"
            raise NoBuildOutput(msg % filenames)
        logger.info("Finished building %s (%s) in %s.", package, version, build_timer)
        return os.path.join(dist_directory, filenames[0])
    finally:
        os.unlink(temporary_file)

def transform_binary_dist(archive_path, prefix='/usr'):
    """
    Transform a binary distribution archive created with ``python setup.py
    bdist_dumb --format=tar`` into a form that can be cached for future use.
    This comes down to making the pathnames inside the archive relative to the
    `prefix` that the binary distribution was built for.

    :param archive_path: The pathname of the original binary distribution archive.
    :param prefix: The prefix that the original binary distribution was created for.
    :returns: An iterable of tuples with two values each: A
              :py:class:`tarfile.TarInfo` object and a file-like object.
    """
    # Copy the tar archive file by file so we can rewrite the pathnames.
    logger.debug("Transforming binary distribution: %s.", archive_path)
    logger.debug("Using environment prefix: %s.", prefix)
    archive = tarfile.open(archive_path, 'r')
    for member in archive.getmembers():
        # In my testing the `dumb' tar files created with the `python setup.py
        # bdist' command contain pathnames that are relative to `/' which is
        # kind of awkward: I would like to use os.path.relpath() on them but
        # that won't give the correct result without some preprocessing...
        original_pathname = member.name
        absolute_pathname = re.sub(r'^\./', '/', original_pathname)
        if member.isdev():
            logger.warn("Ignoring device file: %s.", absolute_pathname)
        elif not member.isdir():
            modified_pathname = os.path.relpath(absolute_pathname, prefix)
            if os.path.isabs(modified_pathname):
                logger.warn("Failed to transform pathname in binary distribution to relative path! (original: %r, modified: %r)",
                            original_pathname, modified_pathname)
            else:
                # Rewrite /usr/local to /usr (same goes for all prefixes of course).
                modified_pathname = re.sub('^local/', '', modified_pathname)
                logger.debug("Transformed %r -> %r.", original_pathname, modified_pathname)
                # Get the file data from the input archive.
                handle = archive.extractfile(original_pathname)
                # Yield the pathname, file mode and a handle to the data.
                member.name = modified_pathname
                yield member, handle
    archive.close()

def install_binary_dist(members, prefix, python='/usr/bin/python', enable_workarounds=True):
    """
    Install a binary distribution created with ``python setup.py bdist`` into
    the given prefix (a directory like ``/usr``, ``/usr/local`` or a virtual
    environment).

    :param members: An iterable of tuples with three values each:
                    (pathname, mode, handle).
    :param prefix: The "prefix" under which the requirements should be
                   installed. This will be a pathname like ``/usr``,
                   ``/usr/local`` or the pathname of a virtual environment.
    :param python: The pathname of the Python executable to use in the shebang
                   line of all executable Python scripts inside the binary
                   distribution.
    :param enable_workarounds: Enable workarounds to make the resulting filenames
                               compatible with virtual environments.
    """
    # TODO This is quite slow for modules like Django. Speed it up! Two choices:
    #  1. Run the external tar program to unpack the archive. This will
    #     slightly complicate the fixing up of hashbangs.
    #  2. Using links? The plan: We can maintain a "seed" environment under
    #     $PIP_ACCEL_CACHE and use symbolic and/or hard links to populate other
    #     places based on the "seed" environment.
    for member, from_handle in members:
        pathname = member.name
        # Some binary distributions include C header files (see for example the
        # greenlet package) however the subdirectory of include/ in a virtual
        # environment is a symbolic link to a subdirectory of /usr/include/ so
        # we should never try to install C header files inside the directory
        # pointed to by the symbolic link. Instead we implement the same
        # workaround that pip uses to avoid this problem.
        if enable_workarounds:
            pathname = re.sub('^include/', 'include/site/', pathname)
        pathname = os.path.join(prefix, pathname)
        directory = os.path.dirname(pathname)
        if not os.path.isdir(directory):
            logger.debug("Creating directory: %s ..", directory)
            os.makedirs(directory)
        logger.debug("Creating file: %s ..", pathname)
        with open(pathname, 'wb') as to_handle:
            contents = from_handle.read()
            if contents.startswith(b'#!/'):
                contents = fix_hashbang(python, contents)
            to_handle.write(contents)
        os.chmod(pathname, member.mode)

def fix_hashbang(python, contents):
    """
    Rewrite the hashbang in an executable script so that the Python program
    inside the virtual environment is used instead of a system wide Python.

    :param python: The absolute pathname of the Python program inside the
                   virtual environment.
    :param contents: A string with the contents of the script whose hashbang
                     should be fixed.
    :returns: The modified contents of the script as a string.
    """
    # Separate the first line in the file from the remainder of the contents
    # while preserving the end of line sequence (CR+LF or just an LF) and
    # without having to split all lines in the file (there's no point).
    lines = contents.splitlines()
    hashbang = lines[0]
    # Get the base name of the command in the hashbang and deal with hashbangs
    # like `#!/usr/bin/env python'.
    modified_name = re.sub(b'^env ', b'', os.path.basename(hashbang))
    # Only rewrite hashbangs that actually involve Python.
    if re.match(b'^python(\\d+(\\.\\d+)*)?$', modified_name):
        lines[0] = b'#!' + python.encode('ascii')
        logger.debug("Hashbang %r looks like a Python hashbang! Rewriting it to %r!", hashbang, lines[0])
        contents = b'\n'.join(lines)
    else:
        logger.debug("Warning: Failed to match hashbang: %r.", hashbang)
    return contents

class InvalidSourceDistribution(Exception):
    """
    Raised by :py:func:`build_binary_dist()` when the given directory doesn't
    contain a source distribution.
    """

class BuildFailed(Exception):
    """
    Raised by :py:func:`build_binary_dist()` when a binary distribution build fails.
    """

class NoBuildOutput(Exception):
    """
    Raised by :py:func:`build_binary_dist()` when a binary distribution build
    fails to produce a binary distribution archive.
    """

########NEW FILE########
__FILENAME__ = config
# Configuration defaults for the pip accelerator.
#
# Author: Peter Odding <peter.odding@paylogic.eu>
# Last Change: August 12, 2013
# URL: https://github.com/paylogic/pip-accel

# Standard library modules.
import os
import os.path

# Modules included in our package.
from pip_accel.utils import expand_user

# Select the default location of the download cache and other files based on
# the user running the pip-accel command (root goes to /var/cache/pip-accel,
# otherwise ~/.pip-accel).
if os.getuid() == 0:
    download_cache = '/root/.pip/download-cache'
    pip_accel_cache = '/var/cache/pip-accel'
else:
    download_cache = expand_user('~/.pip/download-cache')
    pip_accel_cache = expand_user('~/.pip-accel')

# Enable overriding the default locations with environment variables.
if 'PIP_DOWNLOAD_CACHE' in os.environ:
    download_cache = expand_user(os.environ['PIP_DOWNLOAD_CACHE'])
if 'PIP_ACCEL_CACHE' in os.environ:
    pip_accel_cache = expand_user(os.environ['PIP_ACCEL_CACHE'])

# Generate the absolute pathnames of the source/binary caches.
source_index = os.path.join(pip_accel_cache, 'sources')
binary_index = os.path.join(pip_accel_cache, 'binaries')
index_version_file = os.path.join(pip_accel_cache, 'version.txt')

########NEW FILE########
__FILENAME__ = req
# Simple wrapper for pip and pkg_resources Requirement objects.
#
# Author: Peter Odding <peter.odding@paylogic.eu>
# Last Change: March 20, 2014
# URL: https://github.com/paylogic/pip-accel

"""
Requirement objects
===================

After downloading the specified requirement(s) pip reports a "requirement set"
to pip-accel. In the past :py:func:`pip_accel.unpack_source_dists()` would
summarize this requirement set into a list of tuples, where each tuple would
contain a requirement's project name, version and source directory (basically
only the information required by pip-accel remained).

Recently I've started using pip-accel as a library in another project I'm
working on (not yet public) and in that project I am very interested in whether
a given requirement is a direct or transitive requirement. Unfortunately
pip-accel did not preserve this information.

That's when I decided that next to pip's :py:class:`pip.req.InstallRequirement`
and setuptools' :py:class:`pkg_resources.Requirement` I would introduce yet
another type of requirement object... It's basically just a summary of the
other two types of requirement objects and it also provides access to the
original requirement objects (for those who are interested; the interfaces are
basically undocumented AFAIK).
"""

from pip.req import InstallRequirement

class Requirement:

    """
    Simple wrapper for the requirement objects defined by pip and setuptools.
    """

    def __init__(self, requirement):
        """
        Initialize a requirement object.

        :param requirement: A :py:class:`pip.req.InstallRequirement` object.
        """
        self.pip_requirement = requirement
        self.setuptools_requirement = requirement.req
        # In pip-accel 0.10.4 and earlier the list of requirements returned by
        # unpack_source_dists() contained tuples in the following format.
        self.old_interface = (self.name, self.version, self.source_directory)

    def __iter__(self):
        """
        Implemented so that :py:class:`Requirement` objects can be used as a
        (project_name, installed_version, source_dir) tuple, for compatibility
        with callers of pip-accel 0.10.4 and earlier.
        """
        return iter(self.old_interface)

    def __getitem__(self, index):
        """
        Implemented so that :py:class:`Requirement` objects can be used as a
        (project_name, installed_version, source_dir) tuple, for compatibility
        with callers of pip-accel 0.10.4 and earlier.
        """
        return self.old_interface[index]

    @property
    def name(self):
        """
        The name of the Python package (a string). This is the name used to
        register a package on PyPI and the name reported by commands like ``pip
        freeze``. Based on :py:attr:`pkg_resources.Requirement.project_name`.
        """
        return self.setuptools_requirement.project_name

    @property
    def version(self):
        """
        The version of the package that ``pip`` wants to install based on the
        command line options that were given to ``pip`` (a string). Based on
        :py:attr:`pip.req.InstallRequirement.installed_version`.
        """
        return self.pip_requirement.installed_version

    @property
    def url(self):
        """
        The URL of the package. Based on :py:attr:`pip.req.InstallRequirement.url`.
        """
        return self.pip_requirement.url

    @property
    def source_directory(self):
        """
        The pathname of the directory containing the unpacked source
        distribution. This is the directory that contains a ``setup.py``
        script. Based on :py:attr:`pip.req.InstallRequirement.source_dir`.
        """
        return self.pip_requirement.source_dir

    @property
    def is_installed(self):
        """
        ``True`` when the requirement is already installed, ``False``
        otherwise.
        """
        return bool(self.pip_requirement.satisfied_by)

    @property
    def is_transitive(self):
        """
        ``True`` when the requirement is a transitive dependency (a dependency
        of a dependency) or ``False`` when the requirement is a direct
        dependency (specified on pip's command line or in a
        ``requirements.txt`` file). Based on
        :py:attr:`pip.req.InstallRequirement.comes_from`.
        """
        return isinstance(self.pip_requirement.comes_from, InstallRequirement)

    @property
    def is_direct(self):
        """
        The opposite of :py:attr:`Requirement.is_transitive`.
        """
        return not self.is_transitive

########NEW FILE########
__FILENAME__ = utils
# Utility functions for the pip accelerator.
#
# Author: Peter Odding <peter.odding@paylogic.eu>
# Last Change: August 12, 2013
# URL: https://github.com/paylogic/pip-accel

# Standard library modules.
import os
import pwd
import re
import sys

# Look up the home directory of the effective user id so we can generate
# pathnames relative to the home directory.
HOME = pwd.getpwuid(os.getuid()).pw_dir

def expand_user(pathname):
    """
    Variant of :py:func:`os.path.expanduser()` that doesn't use ``$HOME`` but
    instead uses the home directory of the effective user id. This is basically
    a workaround for ``sudo -s`` not resetting ``$HOME``.

    :param pathname: A pathname that may start with ``~/``, indicating the path
                     should be interpreted as being relative to the home
                     directory of the current (effective) user.
    """
    return re.sub('^~(?=/)', HOME, pathname)

def get_python_version():
    """
    Return a string identifying the currently running Python version.

    :returns: A string like "py2.6" or "py2.7" containing a short mnemonic
              prefix followed by the major and minor version numbers.
    """
    return "py%i.%i" % (sys.version_info[0], sys.version_info[1])

########NEW FILE########
__FILENAME__ = pip_accel_tests
#!/usr/bin/env python

# Tests for the pip accelerator.
#
# Author: Peter Odding <peter.odding@paylogic.eu>
# Last Change: May 11, 2014
# URL: https://github.com/paylogic/pip-accel
#
# TODO Test successful installation of iPython, because it used to break! (nested /lib/ directory)

# Standard library modules.
import logging
import os
import pipes
import shutil
import sys
import tempfile
import unittest

# External dependency.
import coloredlogs

class PipAccelTestCase(unittest.TestCase):

    def setUp(self):
        """
        Create a temporary working directory and a virtual environment where
        pip-accel can be tested in isolation (starting with an empty download
        cache, source index and binary index and no installed modules) and make
        sure pip and pip-accel use the directory. Also creates the directories
        for the download cache, the source index and the binary index (normally
        this is done from pip_accel.main).
        """
        coloredlogs.install(level=logging.DEBUG)
        # Create a temporary working directory.
        self.working_directory = tempfile.mkdtemp()
        # Create a temporary build directory.
        self.build_directory = os.path.join(self.working_directory, 'build')
        # Create a temporary virtual environment.
        self.virtual_environment = os.path.join(self.working_directory, 'environment')
        python = 'python%i.%i' % (sys.version_info[0], sys.version_info[1])
        assert os.system('virtualenv --python=%s %s' % (pipes.quote(python), pipes.quote(self.virtual_environment))) == 0
        # Make sure pip-accel uses the pip in the temporary virtual environment.
        os.environ['PATH'] = '%s:%s' % (os.path.join(self.virtual_environment, 'bin'), os.environ['PATH'])
        os.environ['VIRTUAL_ENV'] = self.virtual_environment
        # Make pip and pip-accel use the temporary working directory.
        os.environ['PIP_DOWNLOAD_CACHE'] = os.path.join(self.working_directory, 'download-cache')
        os.environ['PIP_ACCEL_CACHE'] = self.working_directory
        # Initialize the required subdirectories.
        self.pip_accel = __import__('pip_accel')
        self.pip_accel.initialize_directories()

    def runTest(self):
        """
        A very basic test of the functions that make up the pip-accel command
        using the `virtualenv` package as a test case.
        """
        # We will test the downloading, conversion to binary distribution and
        # installation of the virtualenv package (we simply need a package we
        # know is available from PyPI).
        arguments = ['install', '--ignore-installed', 'virtualenv==1.8.4']
        # First we do a simple sanity check.
        from pip.exceptions import DistributionNotFound
        try:
            requirements = self.pip_accel.unpack_source_dists(arguments, build_directory=self.build_directory)
            # This line should never be reached.
            self.assertTrue(False)
        except Exception as e:
            self.assertTrue(isinstance(e, DistributionNotFound))
        # Download the source distribution from PyPI.
        self.pip_accel.download_source_dists(arguments, self.build_directory)
        # Implicitly verify that the download was successful.
        requirements = self.pip_accel.unpack_source_dists(arguments, build_directory=self.build_directory)
        # self.assertIsInstance(requirements, list)
        self.assertTrue(isinstance(requirements, list))
        self.assertEqual(len(requirements), 1)
        self.assertEqual(requirements[0][0], 'virtualenv')
        self.assertEqual(requirements[0][1], '1.8.4')
        self.assertTrue(os.path.isdir(requirements[0][2]))
        # Test the build and installation of the binary package. We have to
        # pass "install_prefix" explicitly here because the Python process
        # running this test is not inside the virtual environment created to
        # run the tests...
        self.pip_accel.install_requirements(requirements, install_prefix=self.virtual_environment)
        # Check that the virtualenv command was installed.
        self.assertTrue(os.path.isfile(os.path.join(self.virtual_environment, 'bin', 'virtualenv')))
        # Check that the virtualenv command can be executed successfully.
        command = '%s --help >/dev/null 2>&1' % pipes.quote(os.path.join(self.virtual_environment, 'bin', 'virtualenv'))
        self.assertEqual(os.system(command), 0)

    def tearDown(self):
        """
        Cleanup the temporary working directory that was used during the test.
        """
        shutil.rmtree(self.working_directory)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
