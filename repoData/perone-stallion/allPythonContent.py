__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# stallion documentation build configuration file, created by
# sphinx-quickstart on Wed Nov 30 20:44:41 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('../..'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'stallion'
copyright = u'2011, Christian S. Perone'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1'
# The full version, including alpha/beta/rc tags.
release = '0.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
show_authors = True

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'pyramid'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'stalliondoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'stallion.tex', u'stallion Documentation',
   u'Christian S. Perone', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'stallion', u'stallion Documentation',
     [u'Christian S. Perone'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'stallion', u'stallion Documentation',
   u'Christian S. Perone', 'stallion', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = console
'''
.. module:: console
   :platform: Unix, Windows
   :synopsis: Stallion entry-point for console commands

.. moduleauthor:: Christian S. Perone <christian.perone@gmail.com>

:mod:`console` -- Stallion entry-point for console commands
==================================================================
'''
import stallion
from stallion.main import get_shared_data, get_pkg_res
from stallion.main import get_pypi_search, get_pypi_releases
from stallion import metadata

from docopt import docopt

from colorama import init
from colorama import Fore, Back, Style

import pkg_resources

def ellipsize(msg, max_size=80):
    '''This function will ellipsize the string.

    :param msg: Text to ellipsize.
    :param max_size: The maximum size before ellipsizing,
                    default is 80.
    :return: The ellipsized string if len > max_size, otherwise
             the original string.
    '''
    if len(msg) >= max_size:
        return '%s (...)' % msg[0:max_size-6]
    else:
        return msg

def parse_dict(mdata, key, ellip=False):
    ''' This function will read the field from the dict and
    if not present will return the string 'Not Specified'

    :param mdata: the distribution info dict
    :param key: the key of the dict
    :ellip: if it will ellipsize
    :return: the string message or 'Not Specified' if empty
    '''
    try:
        data = mdata[key]
        if ellip:
            return ellipsize(data)
        else:
            return data
    except KeyError:
        return 'Not Specified'

def get_kv_colored(key, value):
    text = Fore.WHITE + Style.BRIGHT + '  %s: ' % key.capitalize()
    text += Fore.WHITE + Style.NORMAL + value
    return text

def get_field_formatted(mdata, key):
    ''' This function will get the formatted and colored 
    key data from the dictionary.

    :param mdata: distribution dict
    :param key: the key of the dict
    :return: the formatted and colored string
    '''
    
    def recursive_dict(d, depth=2, final=''):
        final_str = final
        for k,v in sorted(d.items(), key=lambda x: x[0]):
            if isinstance(v, dict):
                if depth==2:
                    final_str += Fore.BLUE + Style.BRIGHT
                else:
                    final_str += Fore.WHITE + Style.NORMAL

                final_str += '  ' * depth + str(k) + '\n'
                final_str += recursive_dict(v, depth+1, final)
            else:
                final_str =+ ('  ')*depth + str(k) + ' ' + str(v) + '\n'
        return final_str

    field = parse_dict(mdata, key.lower())
    
    if isinstance(field, list):
        field = ', '.join(field)

    if isinstance(field, dict):
        field = '\n\n' + recursive_dict(field)

    text = get_kv_colored(key, field)
    return text

def cmd_show(args, short=False):
    '''This function implements the package show command.

    :param args: the docopt parsed arguments
    '''
    proj_name = args['<project_name>']

    try:
        pkg_dist = get_pkg_res().get_distribution(proj_name)
    except:
        print Fore.RED + Style.BRIGHT + \
            'Error: unable to locate the project \'%s\' !' % proj_name
        raise RuntimeError('Project not found !')

    pkg_metadata = pkg_dist.get_metadata(metadata.METADATA_NAME)
    parsed, key_known = metadata.parse_metadata(pkg_metadata)
    distinfo = metadata.metadata_to_dict(parsed, key_known)

    proj_head = Fore.GREEN + Style.BRIGHT + pkg_dist.project_name
    proj_head += Fore.YELLOW + Style.BRIGHT + ' ' + pkg_dist.version
    print proj_head,

    proj_sum = Fore.WHITE + Style.DIM
    proj_sum += '- ' + parse_dict(distinfo, 'summary', True)
    print proj_sum

    # Remove long fields and used fields
    if 'description' in distinfo:
        del distinfo['description']

    if 'summary' in distinfo:
        del distinfo['summary']

    if 'name' in distinfo:
        del distinfo['name']

    if 'version' in distinfo:
        del distinfo['version']

    classifier = None
    if 'classifier' in distinfo:
        classifier = distinfo['classifier']
        del distinfo['classifier']

    for key in distinfo:
        print get_field_formatted(distinfo, key)

    if short:
        return

    print
    print get_kv_colored('location', pkg_dist.location)
    requires = pkg_dist.requires()

    if len(requires) == 0:
        print get_kv_colored('requires', 'none')
    else:
        req_text = '\n'
        for req in requires:
            req_text += ' '*4 + str(req) + '\n'
        print get_kv_colored('requires', req_text)

    entry_points = pkg_dist.get_entry_map()
    console_scripts = entry_points.get('console_scripts')
    if console_scripts:
        console_scr_text = Fore.WHITE + Style.BRIGHT + '  Console Scripts:' + '\n'
        
        for name, entry in console_scripts.items():
            console_scr_text += Fore.YELLOW + Style.BRIGHT + ' '*4 + \
                name + Fore.WHITE + Style.BRIGHT

            console_scr_text += ' -> ' + Fore.GREEN + Style.BRIGHT + \
                entry.module_name + ':' + ','.join(entry.attrs) + '\n'

        print console_scr_text

    if classifier:
        distinfo['classifier'] = classifier
        print get_field_formatted(distinfo, 'classifier')

def cmd_list_detail(dist, distinfo):
    proj_head = Fore.GREEN + Style.BRIGHT + dist.project_name
    proj_head += Fore.YELLOW + Style.BRIGHT + ' ' + dist.version
    print proj_head,

    proj_sum = Fore.WHITE + Style.DIM
    proj_sum += '- ' + parse_dict(distinfo, 'summary', True)
    print proj_sum

    print get_field_formatted(distinfo, 'Author'),
    author_email = distinfo.get('author-email')
    if author_email:
        print '<%s>' % author_email
    else: print

    print get_field_formatted(distinfo, 'Home-page')
    print get_field_formatted(distinfo, 'License')
    print get_field_formatted(distinfo, 'Platform')

def cmd_list_compact(dist, distinfo):
    proj_head = Fore.GREEN + Style.BRIGHT + dist.project_name.ljust(25)
    proj_head += Fore.WHITE + Style.BRIGHT + ' ' + dist.version.ljust(12)
    print proj_head,

    proj_sum = Fore.WHITE + Style.DIM
    proj_sum += ' ' + parse_dict(distinfo, 'summary', True)
    print proj_sum.ljust(100)

def cmd_list(args):
    '''This function implements the package list command.

    :param args: the docopt parsed arguments
    '''
    compact = args['--compact']
    filt = args['<filter>']
    distributions = get_shared_data()['distributions']

    if compact:
        print Fore.YELLOW + Style.BRIGHT + \
            'Project Name'.ljust(26) + 'Version'.ljust(14) + 'Summary'
        print '-' * 80
    
    for dist in distributions:
        if filt:
            if filt.lower() not in dist.project_name.lower():
                continue

        pkg_dist = get_pkg_res().get_distribution(dist.key)
        pkg_metadata = pkg_dist.get_metadata(metadata.METADATA_NAME)
        parsed, key_known = metadata.parse_metadata(pkg_metadata)
        distinfo = metadata.metadata_to_dict(parsed, key_known)

        if compact:
            cmd_list_compact(dist, distinfo)
        else:
            cmd_list_detail(dist, distinfo)
        
def cmd_check(args):
    proj_name = args['<project_name>']
    cmd_show(args, short=True)

    print
    print Fore.GREEN + Style.BRIGHT + 'Searching for updates on PyPI...'
    print

    pkg_dist_version = get_pkg_res().get_distribution(proj_name).version
    pypi_rel = get_pypi_releases(proj_name)

    if pypi_rel:
        pypi_last_version = get_pkg_res().parse_version(pypi_rel[0])
        current_version = get_pkg_res().parse_version(pkg_dist_version)

        try:
            version_index = pypi_rel.index(pkg_dist_version)
        except:
            version_index = len(pypi_rel)
        
        for version in pypi_rel[0:version_index+3]:
            print Fore.WHITE + Style.BRIGHT + '  Version %s' % version,
            if version==pypi_rel[0]:
                print Fore.BLUE + Style.BRIGHT + '[last version]',

            if version==pkg_dist_version:
                print Fore.GREEN + Style.BRIGHT + '[your version]',

            print

        print

        if pypi_last_version > current_version:
            print Fore.RED + Style.BRIGHT + \
                '  Your version is outdated, you\'re using ' + \
                Fore.WHITE + Style.BRIGHT + 'v.%s,' % pkg_dist_version + \
                Fore.RED + Style.BRIGHT + \
                ' but the last version is ' + Fore.WHITE + Style.BRIGHT + \
                'v.%s !' % pypi_rel[0]

        if pypi_last_version == current_version:
            print Fore.GREEN + Style.BRIGHT + '  Your version is updated !'

        if pypi_last_version < current_version:
            print Fore.YELLOW + Style.BRIGHT + \
                '  Your version newer than the version available at PyPI !'

            print Fore.YELLOW + Style.BRIGHT + '  You\'re using ' + \
                Fore.WHITE + Style.BRIGHT + 'v.%s,' % pkg_dist_version + \
                Fore.YELLOW + Style.BRIGHT + \
                ' but the last version in PyPI ' + Fore.WHITE + Style.BRIGHT + \
                'v.%s !' % pypi_rel[0]

           
    else:
        print 'No versions found on PyPI !'

def cmd_scripts(arguments):
    filt = arguments['<filter>']

    print Fore.YELLOW + Style.BRIGHT + \
        'Script Name'.ljust(23) + 'Project Name'.ljust(21) + 'Module Name'
    print '-' * 80
    for entry in pkg_resources.iter_entry_points('console_scripts'):
        if(filt):
            if filt.lower() not in entry.name.lower():
                continue 

        print Fore.GREEN + Style.BRIGHT + entry.name.ljust(22),
        print Fore.WHITE + Style.NORMAL + str(entry.dist).ljust(20),
        print Fore.BLUE + Style.BRIGHT + entry.module_name,
        print Fore.BLUE + Style.NORMAL + '(' + entry.attrs[0] + ')'

def run_main():
    '''Stallion - Python List Packages (PLP)

    Usage:
      plp list [--compact] [<filter>] 
      plp show <project_name>
      plp check <project_name>
      plp scripts [<filter>]

      plp (-h | --help)
      plp --version

    Options:
      --compact     Compact list format
      -h --help     Show this screen.
      --version     Show version.
    '''
    init(autoreset=True)

    arguments = docopt(run_main.__doc__,
        version='Stallion v.%s - Python List Packages (PLP)' %
        stallion.__version__)
    
    if arguments['list']:
        cmd_list(arguments)

    if arguments['show']:
        cmd_show(arguments)

    if arguments['check']:
        cmd_check(arguments)

    if arguments['scripts']:
        cmd_scripts(arguments)

if __name__ == '__main__':
    run_main()

########NEW FILE########
__FILENAME__ = main
"""
.. module:: main
   :platform: Unix, Windows
   :synopsis: Main Stallion entry-point.

.. moduleauthor:: Christian S. Perone <christian.perone@gmail.com>

:mod:`main` -- main Stallion entry-point
==================================================================
"""
from optparse import OptionParser

import sys
import platform
import logging

try:
    import xmlrpclib
except ImportError:
    import xmlrpc.client

import pkg_resources as _pkg_resources

from flask import Flask, render_template, url_for, jsonify

from docutils.core import publish_parts

import stallion
from stallion import metadata

app = Flask(__name__)

PYPI_XMLRPC = 'http://pypi.python.org/pypi'

# This is a cache with flags to show if a distribution
# has an update available
DIST_PYPI_CACHE = set()


class Crumb(object):
    """ Represents each level on the bootstrap breadcrumb. """
    def __init__(self, title, href='#'):
        """ Instatiates a new breadcrum level.

        :param title: the title
        :param href: the link
        """
        self.title = title
        self.href = href


def get_pkg_res():
    reload(_pkg_resources)
    return _pkg_resources


def get_shared_data():
    """ Returns a new dictionary with the shared-data between different
    Stallion views (ie. a lista of distribution packages).

    :rtype: dict
    :return: the dictionary with the shared data.
    """
    shared_data = {'pypi_update_cache': DIST_PYPI_CACHE,
                   'distributions': [d for d in get_pkg_res().working_set]}

    return shared_data


def get_pypi_proxy():
    """ Returns a RPC ServerProxy object pointing to the PyPI RPC
    URL.

    :rtype: xmlrpclib.ServerProxy
    :return: the RPC ServerProxy to PyPI repository.
    """
    return xmlrpclib.ServerProxy(PYPI_XMLRPC)


def get_pypi_releases(dist_name):
    """ Return the releases available at PyPI repository and sort them using
    the pkg_resources.parse_version, the lastest version is on the 0 index.

    :param dist_name: the distribution name
    :rtype: list
    :return: a list with the releases available at PyPI
    """
    pypi = get_pypi_proxy()

    show_hidden = True
    ret = pypi.package_releases(dist_name, show_hidden)

    if not ret:
        ret = pypi.package_releases(dist_name.capitalize(), show_hidden)

    ret.sort(key=lambda v: _pkg_resources.parse_version(v), reverse=True)

    return ret

def get_pypi_search(spec, operator='or'):
    """Search the package database using the indicated search spec

    The spec may include any of the keywords described in the above list
    (except 'stable_version' and 'classifiers'), for example: {'description': 'spam'}
    will search description fields. Within the spec, a field's value can be a string
    or a list of strings (the values within the list are combined with an OR), for
    example: {'name': ['foo', 'bar']}. Valid keys for the spec dict are listed here.

    name
    version
    author
    author_email
    maintainer
    maintainer_email
    home_page
    license
    summary
    description
    keywords
    platform
    download_url
    
    Arguments for different fields are combined using either "and" (the default) or "or".
    Example: search({'name': 'foo', 'description': 'bar'}, 'or'). The results are
    returned as a list of dicts {'name': package name, 'version': package release version,
    'summary': package release summary}
    browse(classifiers)
    """
    pypi = get_pypi_proxy()
    ret = pypi.search(spec, operator)
    ret.sort(key=lambda v: v['_pypi_ordering'], reverse=True)
    return ret


@app.route('/pypi/check_update/<dist_name>')
def check_pypi_update(dist_name):
    """ Just check for updates and return a json
    with the attribute "has_update".

    :param dist_name: distribution name
    :rtype: json
    :return: json with the attribute "has_update"
    """
    pkg_res = get_pkg_res()
    pkg_dist_version = pkg_res.get_distribution(dist_name).version
    pypi_rel = get_pypi_releases(dist_name)

    if pypi_rel:
        pypi_last_version = pkg_res.parse_version(pypi_rel[0])
        current_version = pkg_res.parse_version(pkg_dist_version)

        if pypi_last_version > current_version:
            DIST_PYPI_CACHE.add(dist_name.lower())
            return jsonify({"has_update": 1})

    try:
        DIST_PYPI_CACHE.remove(dist_name.lower())
    except KeyError:
        pass

    return jsonify({"has_update": 0})


@app.route('/pypi/releases/<dist_name>')
def releases(dist_name):
    """ This is the /pypi/releases/<dist_name> entry point, it is the interface
    between Stallion and the PyPI RPC service when checking for updates.

    :param dist_name: the package name (distribution name).
    """
    pkg_res = get_pkg_res()

    data = {}

    pkg_dist_version = pkg_res.get_distribution(dist_name).version
    pypi_rel = get_pypi_releases(dist_name)

    data["dist_name"] = dist_name
    data["pypi_info"] = pypi_rel
    data["current_version"] = pkg_dist_version

    if pypi_rel:
        pypi_last_version = pkg_res.parse_version(pypi_rel[0])
        current_version = pkg_res.parse_version(pkg_dist_version)
        last_version = pkg_dist_version.lower() != pypi_rel[0].lower()

        data["last_is_great"] = pypi_last_version > current_version
        data["last_version_differ"] = last_version

        if data["last_is_great"]:
            DIST_PYPI_CACHE.add(dist_name.lower())
        else:
            try:
                DIST_PYPI_CACHE.remove(dist_name.lower())
            except KeyError:
                pass

    return render_template('pypi_update.html', **data)


@app.route('/')
def index():
    """ The main Flask entry-point (/) for the Stallion server. """
    data = {'breadpath': [Crumb('Main')]}

    data.update(get_shared_data())
    data['menu_home'] = 'active'

    sys_info = {'Python Platform': sys.platform,
                'Python Version': sys.version,
                'Python Prefix': sys.prefix,
                'Machine Type': platform.machine(),
                'Platform': platform.platform(),
                'Processor': platform.processor()}

    try:
        sys_info['Python Implementation'] = platform.python_implementation()
    except:
        pass

    sys_info['System'] = platform.system()
    sys_info['System Arch'] = platform.architecture()

    data['system_information'] = sys_info

    return render_template('system_information.html', **data)

@app.route('/console_scripts')
def console_scripts():
    """ Entry point for the global console scripts """
    data = {}
    data.update(get_shared_data())
    data['menu_console_scripts'] = 'active'
    data['breadpath'] = [Crumb('Console Scripts')]

    entry_console = get_pkg_res().iter_entry_points('console_scripts')
    data['scripts'] = entry_console

    return render_template('console_scripts.html', **data)

@app.route('/about')
def about():
    """ The About entry-point (/about) for the Stallion server. """

    data = {}
    data.update(get_shared_data())
    data['menu_about'] = 'active'

    data['breadpath'] = [Crumb('About')]
    data['version'] = stallion.__version__
    data['author'] = stallion.__author__
    data['author_url'] = stallion.__author_url__

    return render_template('about.html', **data)


@app.route('/distribution/<dist_name>')
def distribution(dist_name=None):
    """ The Distribution entry-point (/distribution/<dist_name>)
    for the Stallion server.

    :param dist_name: the package name
    """

    pkg_dist = get_pkg_res().get_distribution(dist_name)

    data = {}
    data.update(get_shared_data())

    data['dist'] = pkg_dist
    data['breadpath'] = [Crumb('Main', url_for('index')),
                         Crumb('Package'), Crumb(pkg_dist.project_name)]

    settings_overrides = {
        'raw_enabled': 0,  # no raw HTML code
        'file_insertion_enabled': 0,  # no file/URL access
        'halt_level': 2,  # at warnings or errors, raise an exception
        'report_level': 5,  # never report problems with the reST code
    }

    pkg_metadata = pkg_dist.get_metadata(metadata.METADATA_NAME)
    parsed, key_known = metadata.parse_metadata(pkg_metadata)
    distinfo = metadata.metadata_to_dict(parsed, key_known)

    parts = None
    try:
        parts = publish_parts(source=distinfo['description'],
                              writer_name='html',
                              settings_overrides=settings_overrides)
    except:
        pass

    data['distinfo'] = distinfo
    data['entry_map'] = pkg_dist.get_entry_map()

    if parts is not None:
        data['description_render'] = parts['body']

    return render_template('distribution.html', **data)


def run_main():
    """ The main entry-point of Stallion. """

    print('Stallion %s - Python Package Manager' % (stallion.__version__,))
    print('By %s 2013\n' % (stallion.__author__,))
    parser = OptionParser()

    parser.add_option('-s', '--host', dest='host',
                    help='The hostname to listen on, ' \
                         'set to \'0.0.0.0\' to have the '
                         'server available externally as well. '
                         'Default is \'127.0.0.1\' (localhost only).',
                    metavar="HOST", default='127.0.0.1')

    parser.add_option('-d', '--debug', action='store_true',
                  help='Start Stallion in Debug mode (useful to report bugs).',
                  dest='debug', default=False)

    parser.add_option('-r', '--reloader', action='store_true',
                  help='Uses the reloader.', dest='reloader', default=False)

    parser.add_option('-i', '--interactive', action='store_true',
                  help='Enable the interactive interpreter' \
                       ' for debugging (useful to debug errors).',
                  dest='evalx', default=False)

    parser.add_option('-p', '--port', dest='port',
                    help='The port to listen on. ' \
                         'Default is the port \'5000\'.',
                    metavar="PORT", default='5000')

    parser.add_option('-v', '--verbose', dest='verbose', action='store_true',
                    help='Turn on verbose messages (show HTTP requests).' \
                         ' Default is False.',
                    default=False)

    parser.add_option('-w', '--web-browser', dest='web_browser', action='store_true',
                    help='Open a web browser to show Stallion.' \
                         ' Default is False.',
                    default=False)

    (options, args) = parser.parse_args()

    if not options.verbose:
        print(" * Running on http://%s:%s/" % (options.host, options.port))
        werk_log = logging.getLogger('werkzeug')
        werk_log.setLevel(logging.WARNING)

    if options.web_browser:
        import webbrowser
        webbrowser.open('http://%s:%s/' % (options.host, options.port))

    app.run(debug=options.debug, host=options.host, port=int(options.port),
            use_evalex=options.evalx, use_reloader=options.reloader)

if __name__ == '__main__':
    run_main()

########NEW FILE########
__FILENAME__ = metadata
"""
.. module:: metadata
   :platform: Unix, Windows
   :synopsis: Pacakge metadata parsing.

.. moduleauthor:: Christian S. Perone <christian.perone@gmail.com>

:mod:`metadata` -- package metadata parser
==================================================================
"""

import string
from email.parser import Parser
import pkg_resources

# Tuple metadata format
# (Field Name, lowered field name, Optional)

# Based on the PEP-0241
HEADER_META_1_0 = (
    'metadata-version',
    'name',
    'version',
    'platform',
    'supported-platform',
    'summary',
    'description',
    'keywords',
    'home-page',
    'author',
    'author-email',
    'license',
    # Not part of PEP, but PEP-0314 (everyone uses anyway in 1.0)
    'classifier'
)

# Based on the PEP-0314
HEADER_META_1_1 = HEADER_META_1_0 + (
    'download-url',
    'requires',
    'provides',
    'obsoletes',
)

# Based on the PEP-0345
HEADER_META_1_2 = HEADER_META_1_1 + (
    'maintainer',
    'maintainer-email',
    'requires-python',
    'requires-external',
    'requires-dist',
    'provides-dist',
    'obsoletes-dist',
    'project-url',
)

HEADER_META = {
    '1.0': HEADER_META_1_0,
    '1.1': HEADER_META_1_1,
    '1.2': HEADER_META_1_2,
}

METADATA_NAME = 'PKG-INFO'


def parse_metadata(metadata):
    """ Parse the package PKG-INFO metadata. Currently supports versions 1.0 (PEP-0241),
    1.1 (PEP-0314), 1.2 (PEP-0345).

    :param metadata: the raw PKG-INFO metadata text
    :type metadata: string
    :rtype: tuple
    :return: (parsed_metadata, key_known), the parsed_metadata is the rfc822.Message
             object and the key_known is the fields found in the metadata info which
             is part of the metadata version specification
    """
    parsed_metadata = Parser().parsestr(metadata)
    metadata_spec = set(HEADER_META[parsed_metadata['metadata-version']])
    key_exist = set([s.lower() for s in parsed_metadata.keys()])
    return (parsed_metadata, key_exist.intersection(metadata_spec))


def clean_lead_ws_description(metadata, field_name):
    """ Sometimes the metadata fields are a mess, this function is intended to remove the leading
    extra space some authors add in front of the 'description' field and to handle some other
    field cases.

    :param metadata: the metadata text
    :param field_name: the name of the field, like 'description'
    :rtype: string
    :return: the processed metadata
    """
    def calc_leading(line):
        return len(line) - len(line.lstrip())

    def most_common(lst):
        return max(set(lst), key=lst.count)

    if field_name.lower() == 'description':
        leading_ws_count = [calc_leading(line) for line in metadata.splitlines()]
        most_common_ws_count = most_common(leading_ws_count)

        strip_split = metadata.strip().splitlines()
        return '\n'.join([line[most_common_ws_count:] if line.startswith(' ' * most_common_ws_count) else line
                          for line in strip_split])
    else:
        return ' '.join([line.strip() for line in metadata.splitlines()])


def field_process(field_name, field_value):
    """ Processes a field, it changes the 'UNKNOWN' values for None, clear leading whitespaces, etc.

    :param field_name: the field name
    :param field_value: the value of the field
    :rtype: string or list
    :return: field value processed
    """

    if field_name == 'classifier':
        root = {}
        for line in field_value:
            d = root
            path_split = tuple([s.strip() for s in line.split('::')])
            for level in path_split:
                if level in d:
                    d = d[level]
                else:
                    b = {}
                    d[level] = b
                    d = b

        return root

    if isinstance(field_value, list):
        return field_value

    f_value = clean_lead_ws_description(field_value, field_name)

    if hasattr(f_value, 'decode'):
        f_value = f_value.decode('utf-8')

    if f_value == 'UNKNOWN':
        return None

    if field_name == 'keywords':
        f_value = field_value.split(',' if ',' in field_value else ' ')

    return f_value


def metadata_to_dict(parsed_metadata, key_known):
    """ This is the main function used to process the parsed metadata into a structured
    and pre-processed data dictionary.

    :param parsed_metadata: the return of the function :func:`stallion.metadata.parse_metadata`.
    :rtype: dictionary
    :returns: the processed metadata dictionary
    """

    mdict = {}

    for field in set(parsed_metadata.keys()):
        all_values = parsed_metadata.get_all(field)
        if len(all_values) == 1:
            all_values = all_values[0]

        fl_name = field.lower()
        fl_processed = field_process(fl_name, all_values)
        if fl_processed:
            mdict[fl_name] = fl_processed

    return mdict

########NEW FILE########
__FILENAME__ = test_main
import sys
sys.path.insert(0, '.')

import unittest
from stallion import main
from xmlrpclib import ServerProxy
import pkg_resources as _pkg_resources


class TestMain(unittest.TestCase):

    def test_crumb_params_true(self):
        crumb = main.Crumb(title='TestCrumb',
                           href='#testcrumb')
        self.assertEqual(crumb.title, 'TestCrumb')
        self.assertEqual(crumb.href, '#testcrumb')

    def test_pypi_proxy_instance_true(self):
        proxy = main.get_pypi_proxy()
        self.assertTrue(isinstance(proxy, ServerProxy))

    def test_get_shared_data_instance_true(self):
        data = main.get_shared_data()
        self.assertTrue(isinstance(data, dict))
        self.assertEqual(sorted(data.keys()), ['distributions', 'pypi_update_cache'])

    def test_get_pkg_res_instance_true(self):
        pkg = main.get_pkg_res()
        self.assertEqual(pkg, _pkg_resources)

########NEW FILE########
__FILENAME__ = test_metadata
import sys
sys.path.insert(0, '.')

import unittest

from stallion import __version__
from stallion.metadata import parse_metadata, metadata_to_dict


class Test_metadata(unittest.TestCase):

    def test_metadata(self):
        jinja_metadata = 'Metadata-Version: 1.0\r\nName: Jinja2\r\nVersion: 2.6\r\nSummary: A small but fast and easy to use stand-alone template engine written in pure python.\r\nHome-page: http://jinja.pocoo.org/\r\nAuthor: Armin Ronacher\r\nAuthor-email: armin.ronacher@active-4.com\r\nLicense: BSD\r\nDescription: \r\n        Jinja2\r\n        ~~~~~~\r\n        \r\n        Jinja2 is a template engine written in pure Python.  It provides a\r\n        `Django`_ inspired non-XML syntax but supports inline expressions and\r\n        an optional `sandboxed`_ environment.\r\n        \r\n        Nutshell\r\n        --------\r\n        \r\n        Here a small example of a Jinja template::\r\n        \r\n            {% extends \'base.html\' %}\r\n            {% block title %}Memberlist{% endblock %}\r\n            {% block content %}\r\n              <ul>\r\n              {% for user in users %}\r\n                <li><a href="{{ user.url }}">{{ user.username }}</a></li>\r\n              {% endfor %}\r\n              </ul>\r\n            {% endblock %}\r\n        \r\n        Philosophy\r\n        ----------\r\n        \r\n        Application logic is for the controller but don\'t try to make the life\r\n        for the template designer too hard by giving him too few functionality.\r\n        \r\n        For more informations visit the new `Jinja2 webpage`_ and `documentation`_.\r\n        \r\n        .. _sandboxed: http://en.wikipedia.org/wiki/Sandbox_(computer_security)\r\n        .. _Django: http://www.djangoproject.com/\r\n        .. _Jinja2 webpage: http://jinja.pocoo.org/\r\n        .. _documentation: http://jinja.pocoo.org/2/documentation/\r\n        \r\nPlatform: UNKNOWN\r\nClassifier: Development Status :: 5 - Production/Stable\r\nClassifier: Environment :: Web Environment\r\nClassifier: Intended Audience :: Developers\r\nClassifier: License :: OSI Approved :: BSD License\r\nClassifier: Operating System :: OS Independent\r\nClassifier: Programming Language :: Python\r\nClassifier: Programming Language :: Python :: 3\r\nClassifier: Topic :: Internet :: WWW/HTTP :: Dynamic Content\r\nClassifier: Topic :: Software Development :: Libraries :: Python Modules\r\nClassifier: Topic :: Text Processing :: Markup :: HTML\r\n'
        parsed, key_known = parse_metadata(jinja_metadata)
        ret = metadata_to_dict(parsed, key_known)
        self.assertEquals({
            'name': 'Jinja2',
            'license': 'BSD',
            'author': 'Armin Ronacher',
            'metadata-version': '1.0',
            'home-page': 'http://jinja.pocoo.org/',
            'summary': 'A small but fast and easy to use stand-alone template engine written in pure python.',
            'version': '2.6',
            'classifier': {
                'Intended Audience': {'Developers': {}},
                'Operating System': {'OS Independent': {}},
                'Development Status': {'5 - Production/Stable': {}},
                'License': {'OSI Approved': {'BSD License': {}}},
                'Environment': {'Web Environment': {}},
                'Topic': {
                    'Software Development': {'Libraries': {'Python Modules': {}}},
                    'Text Processing': {'Markup': {'HTML': {}}},
                    'Internet': {'WWW/HTTP': {'Dynamic Content': {}}}},
                'Programming Language': {'Python': {'3': {}}}},
            'author-email': 'armin.ronacher@active-4.com',
            'description': 'Jinja2\n~~~~~~\n\nJinja2 is a template engine written in pure Python.  It provides a\n`Django`_ inspired non-XML syntax but supports inline expressions and\nan optional `sandboxed`_ environment.\n\nNutshell\n--------\n\nHere a small example of a Jinja template::\n\n    {% extends \'base.html\' %}\n    {% block title %}Memberlist{% endblock %}\n    {% block content %}\n      <ul>\n      {% for user in users %}\n        <li><a href="{{ user.url }}">{{ user.username }}</a></li>\n      {% endfor %}\n      </ul>\n    {% endblock %}\n\nPhilosophy\n----------\n\nApplication logic is for the controller but don\'t try to make the life\nfor the template designer too hard by giving him too few functionality.\n\nFor more informations visit the new `Jinja2 webpage`_ and `documentation`_.\n\n.. _sandboxed: http://en.wikipedia.org/wiki/Sandbox_(computer_security)\n.. _Django: http://www.djangoproject.com/\n.. _Jinja2 webpage: http://jinja.pocoo.org/\n.. _documentation: http://jinja.pocoo.org/2/documentation/'
        }, ret)

if __name__ == '__main__':
    print("Stallion v.%s" % __version__)
    unittest.main()

########NEW FILE########
__FILENAME__ = write_plist
import sys

plist_sample_text="""
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>Stallone</string>

    <key>ProgramArguments</key>
    <array>
        <string>{python}</string>
        <string>-m</string>
        <string>stallion.main</string>
    </array>

    <key>RunAtLoad</key>
    <true/>
</dict>
</plist>
""".strip()

sys.stdout.write(plist_sample_text.format(python=sys.executable))

########NEW FILE########
