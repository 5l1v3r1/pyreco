__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-fancy-cache documentation build configuration file, created by
# sphinx-quickstart on Sun Feb 10 16:18:37 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-fancy-cache'
copyright = u'2013, Peter Bengtsson'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.3'
# The full version, including alpha/beta/rc tags.
release = '0.3'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-fancy-cachedoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-fancy-cache.tex', u'django-fancy-cache Documentation',
   u'Peter Bengtsson', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-fancy-cache', u'django-fancy-cache Documentation',
     [u'Peter Bengtsson'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'django-fancy-cache', u'django-fancy-cache Documentation',
   u'Peter Bengtsson', 'django-fancy-cache', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from . import views

urlpatterns = patterns(
    '',
    url(r'^$', views.home, name='home'),
    url(r'^page1.html$', views.page1, name='page1'),
    url(r'^page2.html$', views.page2, name='page2'),
    url(r'^page3.html$', views.page3, name='page3'),
    url(r'^page4.html$', views.page4, name='page4'),
    url(r'^page5.html$', views.page5, name='page5'),
)

########NEW FILE########
__FILENAME__ = views
import time

from django.shortcuts import render, redirect

from fancy_cache import cache_page
from fancy_cache.memory import find_urls


def home(request):
    remembered_urls = find_urls([])
    return render(
        request,
        'home.html',
        {'remembered_urls': remembered_urls}
    )


def commafy(s):
    r = []
    for i, c in enumerate(reversed(str(s))):
        if i and (not (i % 3)):
            r.insert(0, ',')
        r.insert(0, c)
    return ''.join(r)


@cache_page(60)
def page1(request):
    print "CACHE MISS", request.build_absolute_uri()
    t0 = time.time()
    result = sum(x for x in xrange(25000000))
    t1 = time.time()
    print t1 - t0
    return render(
        request,
        'page.html',
        dict(result=commafy(result), page='1')
    )


def key_prefixer(request):
    # if it's not there, don't cache
    return request.GET.get('number')


@cache_page(60, key_prefix=key_prefixer)
def page2(request):
    if not request.GET.get('number'):
        return redirect(request.build_absolute_uri() + '?number=25000000')
    print "CACHE MISS", request.build_absolute_uri()
    t0 = time.time()
    result = sum(x for x in xrange(25000000))
    t1 = time.time()
    print t1 - t0
    return render(
        request,
        'page.html',
        dict(result=commafy(result), page='2')
    )


def post_processor(response, request):
    response.content = response.content.replace(
        '</body>',
        '<footer>Kilroy was here!</footer></body>'
    )
    return response


@cache_page(60, post_process_response=post_processor)
def page3(request):
    print "CACHE MISS", request.build_absolute_uri()
    t0 = time.time()
    result = sum(x for x in xrange(25000000))
    t1 = time.time()
    print t1 - t0
    return render(
        request,
        'page.html',
        dict(result=commafy(result), page='3')
    )


def post_processor_always(response, request):
    import datetime
    now = datetime.datetime.now()
    assert 'Right here right now' not in response.content, 'already there!'
    response.content = response.content.replace(
        '</body>',
        '<footer>Right here right now %s</footer></body>' % now
    )
    return response


@cache_page(60, post_process_response_always=post_processor_always)
def page4(request):
    print "CACHE MISS", request.build_absolute_uri()
    t0 = time.time()
    result = sum(x for x in xrange(25000000))
    t1 = time.time()
    print t1 - t0
    return render(
        request,
        'page.html',
        dict(result=commafy(result), page='4')
    )


@cache_page(60, only_get_keys=['foo', 'bar'])
def page5(request):
    print "CACHE MISS", request.build_absolute_uri()
    t0 = time.time()
    result = sum(x for x in xrange(25000000))
    t1 = time.time()
    print t1 - t0
    return render(
        request,
        'page.html',
        dict(result=commafy(result), page='5')
    )

########NEW FILE########
__FILENAME__ = settings
# Django settings for example project.

FANCY_REMEMBER_ALL_URLS = True
FANCY_REMEMBER_STATS_ALL_URLS = True

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'database.db',
    }
}

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'unique-snowflake'
    }
}

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',
        'LOCATION': 'localhost:11211',
        'TIMEOUT': 500,
        'KEY_PREFIX': 'example',
    }
}


# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# In a Windows environment this must be set to your system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/var/www/example.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://example.com/media/", "http://media.example.com/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/var/www/example.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://example.com/static/", "http://static.example.com/"
STATIC_URL = '/static/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = '#yd#+#!6uf2$0!65rx1_rg7zspp*e8wr&e)#mxvo$&!y_(^wc2'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'example.urls'

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'example.wsgi.application'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'example.app',
    'fancy_cache',
    # Uncomment the next line to enable the admin:
    # 'django.contrib.admin',
    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
)

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url


urlpatterns = patterns(
    '',
    url(r'', include('example.app.urls')),
    url(r'fancy-cache', include('fancy_cache.urls')),
)

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for example project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os

# We defer to a DJANGO_SETTINGS_MODULE already in the environment. This breaks
# if running multiple sites in the same mod_wsgi process. To fix this, use
# mod_wsgi daemon mode with each site in its own daemon process, or use
# os.environ["DJANGO_SETTINGS_MODULE"] = "example.settings"
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "example.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

# Apply WSGI middleware here.
# from helloworld.wsgi import HelloWorldApplication
# application = HelloWorldApplication(application)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

# make sure we're running the fancy_cache here and not anything installed
parent = os.path.normpath(os.path.join(__file__, '../..'))
sys.path.insert(0, parent)

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "example.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = fabfile
"""
This Source Code Form is subject to the terms of the Mozilla Public
License, v. 2.0. If a copy of the MPL was not distributed with this
file, You can obtain one at http://mozilla.org/MPL/2.0/.
"""
import os

from fabric.api import local


ROOT = os.path.abspath(os.path.dirname(__file__))
os.environ['PYTHONPATH'] = ROOT


def _test(extra_args):
    """Run test suite."""
    os.environ['DJANGO_SETTINGS_MODULE'] = 'fancy_tests.tests.settings'
    os.environ['REUSE_DB'] = '0'

    # Add tables and flush DB
    local('django-admin.py syncdb --noinput')
    local('django-admin.py flush --noinput')

    local('django-admin.py test %s' % extra_args)

def test():
    _test('-s')

def coverage():
    _test('-s --with-coverage --cover-erase --cover-html '
          '--cover-package=fancy_cache')

########NEW FILE########
__FILENAME__ = cache_page
from django.utils.decorators import decorator_from_middleware_with_args

from .middleware import CacheMiddleware


def cache_page(*args, **kwargs):
    return (
        decorator_from_middleware_with_args
        (CacheMiddleware)(*args, **kwargs)
    )

########NEW FILE########
__FILENAME__ = fancy-urls
import os
_this_wo_ext = os.path.basename(__file__).rsplit('.', 1)[0]

__doc__ = """
If you enable `FANCY_REMEMBER_ALL_URLS` then every URL take is turned
into a cache key for cache_page() to remember is recorded.
You can use this to do statistics or to do invalidation by URL.

To use: simply add the URL patterns after like this::

    $ ./manage.py %(this_file)s /path1.html /path3/*/*.json

To show all cached URLs simply run it with no pattern like this::

    $ ./manage.py %(this_file)s

Equally the ``--purge`` switch can always be added. For example,
running this will purge all cached URLs::

    $ ./manage.py %(this_file)s --purge

If you enable `FANCY_REMEMBER_STATS_ALL_URLS` you can get a tally for each
URL how many cache HITS and MISSES it has had.

""" % dict(this_file=_this_wo_ext)

from optparse import make_option

from django.core.management.base import BaseCommand

from fancy_cache.memory import find_urls


class Command(BaseCommand):
    help = __doc__.strip()

    option_list = BaseCommand.option_list + (
        make_option(
            '-p', '--purge', dest='purge', action='store_true',
            help='Purge found URLs'
        ),
    )
    args = 'urls'

    def handle(self, *urls, **options):
        verbose = int(options['verbosity']) > 1

        _count = 0
        for url, cache_key, stats in find_urls(urls, purge=options['purge']):
            _count += 1
            if stats:
                print url[:70].ljust(65),
                print "HITS", str(stats['hits']).ljust(5),
                print "MISSES", str(stats['misses']).ljust(5)

            else:
                print url

        if verbose:
            print "-- %s URLs cached --" % _count

########NEW FILE########
__FILENAME__ = memory
import re

from django.core.cache import cache

from fancy_cache.middleware import REMEMBERED_URLS_KEY, LONG_TIME
from fancy_cache.utils import md5

__all__ = ('find_urls',)


def _match(url, regexes):
    if not regexes:
        return url
    for regex in regexes:
        if regex.match(url):
            return True
    return False


def _urls_to_regexes(urls):
    regexes = []
    for each in urls:
        parts = each.split('*')
        if len(parts) == 1:
            regexes.append(re.compile('^%s$' % re.escape(parts[0])))
        else:
            _re = '.*'.join(re.escape(x) for x in parts)
            regexes.append(re.compile('^%s$' % _re))
    return regexes


def find_urls(urls=None, purge=False):
    remembered_urls = cache.get(REMEMBERED_URLS_KEY, {})
    _del_keys = []
    if urls:
        regexes = _urls_to_regexes(urls)
    for url in remembered_urls:
        if not urls or _match(url, regexes):
            cache_key = remembered_urls[url]
            if not cache.get(cache_key):
                continue
            if purge:
                cache.delete(cache_key)
                _del_keys.append(url)
            misses_cache_key = '%s__misses' % url
            misses_cache_key = md5(misses_cache_key)
            hits_cache_key = '%s__hits' % url
            hits_cache_key = md5(hits_cache_key)

            misses = cache.get(misses_cache_key)
            hits = cache.get(hits_cache_key)
            if misses is None and hits is None:
                stats = None
            else:
                stats = {
                    'hits': hits or 0,
                    'misses': misses or 0
                }
            yield (url, cache_key, stats)

    if _del_keys:
        # means something was changed
        for url in _del_keys:
            remembered_urls.pop(url)
            misses_cache_key = '%s__misses' % url
            hits_cache_key = '%s__hits' % url
            cache.delete(misses_cache_key)
            cache.delete(hits_cache_key)

        cache.set(
            REMEMBERED_URLS_KEY,
            remembered_urls,
            LONG_TIME
        )

########NEW FILE########
__FILENAME__ = middleware
import cgi
import functools
import urllib

from django.core.exceptions import ImproperlyConfigured
from django.conf import settings
from django.core.cache import cache
from django.utils.encoding import iri_to_uri
from django.utils.cache import (
    get_cache_key,
    learn_cache_key,
    patch_response_headers,
    get_max_age
)

from fancy_cache.utils import md5


REMEMBERED_URLS_KEY = 'fancy-urls'
LONG_TIME = 60 * 60 * 24 * 30


class RequestPath(object):
    def __init__(self, request, only_get_keys, forget_get_keys):
        self.request = request
        self.only_get_keys = only_get_keys
        self.forget_get_keys = forget_get_keys
        assert not (self.only_get_keys and self.forget_get_keys)
        self._prev_get_full_path = request.get_full_path

    def __enter__(self):
        if self.only_get_keys is not None:
            # then monkey patch self.request.get_full_path
            self.request.get_full_path = functools.partial(
                self.get_full_path,
                self.request,
                self.only_get_keys,
                True
            )

        if self.forget_get_keys is not None:
            # then monkey patch self.request.get_full_path
            self.request.get_full_path = functools.partial(
                self.get_full_path,
                self.request,
                self.forget_get_keys,
                False
            )

    def __exit__(self, exc_type, exc_value, traceback):
        if self.only_get_keys is not None or self.forget_get_keys is not None:
            self.request.get_full_path = self._prev_get_full_path

    def get_full_path(self, this, keys, is_only_keys):
        """modified version of django.http.request.Request.get_full_path
        with the ability to return a different query string based on
        `keys` to be included or excluded
        """
        qs = this.META.get('QUERY_STRING', '')
        parsed = cgi.parse_qs(qs)
        if is_only_keys :
            keep = dict((k, parsed[k]) for k in parsed if k in keys)
        else :
            keep = dict((k, parsed[k]) for k in parsed if k not in keys)
        qs = urllib.urlencode(keep, True)
        return '%s%s' % (this.path, ('?' + iri_to_uri(qs)) if qs else '')


class UpdateCacheMiddleware(object):
    """
    Response-phase cache middleware that updates the cache if the response is
    cacheable.

    Must be used as part of the two-part update/fetch cache middleware.
    UpdateCacheMiddleware must be the first piece of middleware in
    MIDDLEWARE_CLASSES so that it'll get called last during the response phase.
    """

    def process_response(self, request, response):
        """Sets the cache, if needed."""
        if (
            not hasattr(request, '_cache_update_cache') or
            not request._cache_update_cache
        ):
            # We don't need to update the cache, just return.
            return response
        if request.method != 'GET':
            # This is a stronger requirement than above. It is needed
            # because of interactions between this middleware and the
            # HTTPMiddleware, which throws the body of a HEAD-request
            # away before this middleware gets a chance to cache it.
            return response
        if not response.status_code == 200:
            return response
        # Try to get the timeout from the "max-age" section of the "Cache-
        # Control" header before reverting to using the default cache_timeout
        # length.
        timeout = get_max_age(response)
        if timeout is None:
            timeout = self.cache_timeout
        elif timeout == 0:
            # max-age was set to 0, don't bother caching.
            return response

        if self.patch_headers:
            patch_response_headers(response, timeout)

        if timeout:
            if callable(self.key_prefix):
                key_prefix = self.key_prefix(request)
            else:
                key_prefix = self.key_prefix
            if self.post_process_response:
                response = self.post_process_response(
                    response,
                    request
                )

            with RequestPath(request, self.only_get_keys, self.forget_get_keys):
                cache_key = learn_cache_key(
                    request,
                    response,
                    timeout,
                    key_prefix
                )

                if self.remember_all_urls:
                    self.remember_url(request, cache_key, timeout)

            cache.set(cache_key, response, timeout)

        if self.post_process_response_always:
            response = self.post_process_response_always(
                response,
                request
            )

        return response

    def remember_url(self, request, cache_key, timeout):
        url = request.get_full_path()
        remembered_urls = cache.get(REMEMBERED_URLS_KEY, {})
        remembered_urls[url] = cache_key
        cache.set(
            REMEMBERED_URLS_KEY,
            remembered_urls,
            LONG_TIME
        )


class FetchFromCacheMiddleware(object):
    """
    Request-phase cache middleware that fetches a page from the cache.

    Must be used as part of the two-part update/fetch cache middleware.
    FetchFromCacheMiddleware must be the last piece of middleware in
    MIDDLEWARE_CLASSES so that it'll get called last during the request phase.
    """
    def process_request(self, request):
        """
        Checks whether the page is already cached and returns the cached
        version if available.
        """
        response = self._process_request(request)
        if self.remember_stats_all_urls:
            # then we're nosy
            cache_key = request.get_full_path()
            if response is None:
                cache_key += '__misses'
            else:
                cache_key += '__hits'
            cache_key = md5(cache_key)
            if cache.get(cache_key) is None:
                cache.set(cache_key, 0, LONG_TIME)
            cache.incr(cache_key)
        return response

    def _process_request(self, request):
        if self.cache_anonymous_only:
            if not hasattr(request, 'user'):
                raise ImproperlyConfigured(
                    "The Django cache middleware with "
                    "CACHE_MIDDLEWARE_ANONYMOUS_ONLY=True requires "
                    "authentication middleware to be installed. Edit your "
                    "MIDDLEWARE_CLASSES setting to insert "
                    "'django.contrib.auth.middleware.AuthenticationMiddleware'"
                    "before the CacheMiddleware."
                )

        if not request.method in ('GET', 'HEAD'):
            request._cache_update_cache = False
            # Don't bother checking the cache.
            return None

        #if (
        #    request.GET and
        #    not callable(self.key_prefix) and
        #    not self.only_get_keys
        #):
        #    request._cache_update_cache = False
        #    # Default behaviour for requests with GET parameters: don't bother
        #    # checking the cache.
        #    return None

        if self.cache_anonymous_only and request.user.is_authenticated():
            request._cache_update_cache = False
            # Don't cache requests from authenticated users.
            return None

        if callable(self.key_prefix):
            key_prefix = self.key_prefix(request)
            if key_prefix is None:
                request._cache_update_cache = False
                # Don't bother checking the cache if key_prefix function
                # returns magic "None" value.
                return None
        else:
            key_prefix = self.key_prefix

        with RequestPath(request, self.only_get_keys, self.forget_get_keys):
            cache_key = get_cache_key(request, key_prefix)

        if cache_key is None:
            request._cache_update_cache = True
            # No cache information available, need to rebuild.
            return None

        response = cache.get(cache_key, None)
        if response is None:
            request._cache_update_cache = True
            # No cache information available, need to rebuild.
            return None

        request._cache_update_cache = False
        if self.post_process_response_always:
            response = self.post_process_response_always(
                response,
                request=request
            )

        return response


class CacheMiddleware(UpdateCacheMiddleware, FetchFromCacheMiddleware):
    """
    Cache middleware that provides basic behavior for many simple sites.

    Also used as the hook point for the cache decorator, which is generated
    using the decorator-from-middleware utility.

    :param cache_timeout:
        How many seconds to cache the page. This is ignored if the view sets a
        Cache-Control header with a max-age.

    :param key_prefix:
        Either a string or a callable function. If it's a callable function,
        it's called with the request as the first and only argument.

    :param cache_anonymous_only:
        Guess!

    :param patch_headers:
        Basically, if you set a cache_timeout of 60 it additionally sets a
        Expires header with that timeout.

    :param post_process_response:
        Callable function that gets called with the response (and request) just
        before the response gets set in cache.

    :param post_process_response_always:
        Callable function that gets called with the response (and request)
        every time the response goes through the middleware cached or not.

    :param only_get_keys:
        List of query string keys to reduce the cache key to. Without this a
        GET /some/path?foo=bar and /some/path?foo=bar&other=junk gets two
        different cache keys when it could be that the `other=junk` parameter
        doesn't change anything.

    :param forget_get_keys:
        List of query string keys to ignore when reducing the cache key.

    :param remember_all_urls:
        With this option you can have all cached URLs stored in cache which
        can make it easy to do things like cache invalidation by URL.

    :param remember_stats_all_urls:
        Only applicable if `remember_all_urls` is set. This stores a count
        of the number of times a `cache_page` hits and misses.

    """
    def __init__(self,
                 cache_timeout=settings.CACHE_MIDDLEWARE_SECONDS,
                 key_prefix=settings.CACHE_MIDDLEWARE_KEY_PREFIX,
                 cache_anonymous_only=getattr(
                     settings,
                     'CACHE_MIDDLEWARE_ANONYMOUS_ONLY',
                     False
                 ),
                 patch_headers=False,
                 post_process_response=None,
                 post_process_response_always=None,
                 only_get_keys=None,
                 forget_get_keys=None,
                 remember_all_urls=getattr(
                     settings,
                     'FANCY_REMEMBER_ALL_URLS',
                     False
                 ),
                 remember_stats_all_urls=getattr(
                     settings,
                     'FANCY_REMEMBER_STATS_ALL_URLS',
                     False
                 ),
                 ):
        self.patch_headers = patch_headers
        self.cache_timeout = cache_timeout
        self.key_prefix = key_prefix
        self.cache_anonymous_only = cache_anonymous_only
        self.post_process_response = post_process_response
        self.post_process_response_always = post_process_response_always
        if isinstance(only_get_keys, basestring):
            only_get_keys = [only_get_keys]
        self.only_get_keys = only_get_keys
        if isinstance(forget_get_keys, basestring):
            forget_get_keys = [forget_get_keys]
        self.forget_get_keys = forget_get_keys
        self.remember_all_urls = remember_all_urls
        self.remember_stats_all_urls = remember_stats_all_urls

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from . import views


urlpatterns = patterns(
    'fancy-cache',
    url(r'^$', views.home, name='home'),
)

########NEW FILE########
__FILENAME__ = utils
import hashlib


def md5(x):
    return hashlib.md5(x.encode('utf-8')).hexdigest()

########NEW FILE########
__FILENAME__ = views
from django.shortcuts import render
from django.conf import settings

from fancy_cache.memory import find_urls


def home(request):
    data = {
        'found': find_urls([]),
        'remember_all_urls_setting': getattr(
            settings,
            'FANCY_REMEMBER_ALL_URLS',
            False
        ),
        'remember_stats_all_urls_setting': getattr(
            settings,
            'FANCY_REMEMBER_STATS_ALL_URLS',
            False
        )
    }
    return render(request, 'fancy-cache/home.html', data)

########NEW FILE########
__FILENAME__ = models
# lonely in here

########NEW FILE########
__FILENAME__ = settings
import os
HERE = os.path.dirname(__file__)

TEST_RUNNER = 'django_nose.runner.NoseTestSuiteRunner'

SECRET_KEY = 'anything'

DATABASES = {
    'default': {
        'NAME': ':memory:',
        'ENGINE': 'django.db.backends.sqlite3',
    }
}

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'unique-snowflake'
    }
}

TEMPLATE_DIRS = (
    os.path.join(HERE, 'templates'),
)

INSTALLED_APPS = (
    'fancy_cache',
    'django_nose',
)


ROOT_URLCONF = 'fancy_tests.tests.urls'

########NEW FILE########
__FILENAME__ = test_memory
import unittest

from nose.tools import eq_, ok_
from django.core.cache import cache

from fancy_cache.middleware import REMEMBERED_URLS_KEY
from fancy_cache.memory import find_urls


class TestMemory(unittest.TestCase):

    def setUp(self):
        self.urls = {
            '/page1.html': 'key1',
            '/page2.html': 'key2',
            '/page3.html?foo=bar': 'key3',
            '/page3.html?foo=else': 'key4',
        }
        for key, value in self.urls.items():
            cache.set(value, key)
        cache.set(REMEMBERED_URLS_KEY, self.urls, 5)

    def tearDown(self):
        cache.clear()

    def test_find_all_urls(self):
        found = list(find_urls([]))
        eq_(len(found), 4)
        for key, value in self.urls.items():
            pair = (key, value, None)
            ok_(pair in found)

    def test_find_and_purge_all_urls(self):
        found = list(find_urls([], purge=True))
        eq_(len(found), 4)
        for key, value in self.urls.items():
            pair = (key, value, None)
            ok_(pair in found)
        found = list(find_urls([]))
        eq_(len(found), 0)

    def test_find_one_url(self):
        found = list(find_urls(['/page1.html']))
        eq_(len(found), 1)
        ok_(('/page1.html', 'key1', None) in found)

    def test_purge_one_url(self):
        ok_(cache.get('key1'))
        ok_('/page1.html' in cache.get(REMEMBERED_URLS_KEY))
        found = list(find_urls(['/page1.html'], purge=True))
        eq_(len(found), 1)
        ok_(('/page1.html', 'key1', None) in found)

        ok_(not cache.get('key1'))
        ok_('/page1.html' not in cache.get(REMEMBERED_URLS_KEY))
        # find all the rest in there
        found = list(find_urls([]))
        eq_(len(found), 3)
        ok_(('/page1.html', 'key1', None) not in found)

    def test_some_urls(self):
        found = list(find_urls(['/page2.html*']))
        eq_(len(found), 1)
        ok_(('/page2.html', 'key2', None) in found)

    def test_some_urls_double_star(self):
        found = list(find_urls(['/page*.html?*']))
        eq_(len(found), 2)
        ok_(('/page3.html?foo=bar', 'key3', None) in found)
        ok_(('/page3.html?foo=else', 'key4', None) in found)

########NEW FILE########
__FILENAME__ = test_views
import unittest
import re
from nose.tools import eq_, ok_
from django.test.client import RequestFactory
from django.core.cache import cache
from fancy_cache.memory import find_urls

from . import views


class TestViews(unittest.TestCase):

    def setUp(self):
        self.factory = RequestFactory()

    def tearDown(self):
        cache.clear()

    def test_render_home1(self):
        request = self.factory.get('/anything')

        response = views.home(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        random_string_1 = re.findall('Random:(\w+)', response.content)[0]

        # do it again
        response = views.home(request)
        eq_(response.status_code, 200)
        random_string_2 = re.findall('Random:(\w+)', response.content)[0]
        eq_(random_string_1, random_string_2)

    def test_render_home2(self):
        authenticated = RequestFactory(AUTH_USER='peter')
        request = self.factory.get('/2')

        response = views.home2(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        random_string_1 = re.findall('Random:(\w+)', response.content)[0]

        # do it again
        response = views.home2(request)
        eq_(response.status_code, 200)
        random_string_2 = re.findall('Random:(\w+)', response.content)[0]
        eq_(random_string_1, random_string_2)

        # do it again, but with a hint to disable cache
        request = authenticated.get('/2')
        response = views.home2(request)
        eq_(response.status_code, 200)
        random_string_2 = re.findall('Random:(\w+)', response.content)[0]
        ok_(random_string_1 != random_string_2)

    def test_render_home3(self):
        request = self.factory.get('/anything')

        response = views.home3(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        random_string_1 = re.findall('Random:(\w+)', response.content)[0]
        ok_('In your HTML' in response.content)
        extra_random_1 = re.findall('In your HTML:(\w+)', response.content)[0]

        response = views.home3(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        random_string_2 = re.findall('Random:(\w+)', response.content)[0]
        extra_random_2 = re.findall('In your HTML:(\w+)', response.content)[0]
        ok_('In your HTML' in response.content)
        eq_(random_string_1, random_string_2)
        # the post_process_response is only called once
        eq_(extra_random_1, extra_random_2)

    def test_render_home3_no_cache(self):
        factory = RequestFactory(AUTH_USER='peter')
        request = factory.get('/3')

        response = views.home3(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        ok_('In your HTML' not in response.content)

    def test_render_home4(self):
        request = self.factory.get('/4')

        response = views.home4(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        random_string_1 = re.findall('Random:(\w+)', response.content)[0]
        ok_('In your HTML' in response.content)
        extra_random_1 = re.findall('In your HTML:(\w+)', response.content)[0]

        response = views.home4(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        random_string_2 = re.findall('Random:(\w+)', response.content)[0]
        extra_random_2 = re.findall('In your HTML:(\w+)', response.content)[0]
        ok_('In your HTML' in response.content)
        eq_(random_string_1, random_string_2)
        # the post_process_response is now called every time
        ok_(extra_random_1 != extra_random_2)

    def test_render_home5(self):
        request = self.factory.get('/4', {'foo': 'bar'})
        response = views.home5(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        random_string_1 = re.findall('Random:(\w+)', response.content)[0]

        request = self.factory.get('/4', {'foo': 'baz'})
        response = views.home5(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        random_string_2 = re.findall('Random:(\w+)', response.content)[0]
        ok_(random_string_1 != random_string_2)

        request = self.factory.get('/4', {'foo': 'baz', 'other': 'junk'})
        response = views.home5(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        random_string_3 = re.findall('Random:(\w+)', response.content)[0]
        eq_(random_string_2, random_string_3)

    def test_render_home5bis(self):
        request = self.factory.get('/4', {'foo': 'bar'})
        response = views.home5bis(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        random_string_1 = re.findall('Random:(\w+)', response.content)[0]

        request = self.factory.get('/4', {'foo': 'baz'})
        response = views.home5bis(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        random_string_2 = re.findall('Random:(\w+)', response.content)[0]
        ok_(random_string_1 != random_string_2)

        request = self.factory.get('/4', {'foo': 'baz', 'bar': 'foo'})
        response = views.home5bis(request)
        eq_(response.status_code, 200)
        ok_(re.findall('Random:\w+', response.content))
        random_string_3 = re.findall('Random:(\w+)', response.content)[0]
        eq_(random_string_2, random_string_3)

    def test_remember_stats_all_urls(self):
        request = self.factory.get('/anything')
        response = views.home6(request)
        eq_(response.status_code, 200)

        # now ask the memory thing
        match, = find_urls(urls=['/anything'])
        eq_(match[0], '/anything')
        eq_(match[2]['hits'], 0)
        eq_(match[2]['misses'], 1)

        # second time
        response = views.home6(request)
        eq_(response.status_code, 200)
        match, = find_urls(urls=['/anything'])
        eq_(match[0], '/anything')
        eq_(match[2]['hits'], 1)
        eq_(match[2]['misses'], 1)

    def test_remember_stats_all_urls_looong_url(self):
        request = self.factory.get(
            '/something/really/long/to/start/with/right/here/since/this/will/'
            'test/that/things/work/with/long/urls/too',
            {
                'line1': 'Bad luck, wind been blowing at my back',
                'line2': "I was born to bring trouble to wherever I'm at",
                'line3': "Got the number thirteen, tattooed on my neck",
                'line4': "When the ink starts to itch, ",
                'line5': "then the black will turn to red",
            }
        )
        response = views.home6(request)
        eq_(response.status_code, 200)

        # now ask the memory thing
        match, = find_urls()
        ok_(match[0].startswith('/something/really'))
        eq_(match[2]['hits'], 0)
        eq_(match[2]['misses'], 1)

        # second time
        response = views.home6(request)
        eq_(response.status_code, 200)
        match, = find_urls([])
        ok_(match[0].startswith('/something/really'))
        eq_(match[2]['hits'], 1)
        eq_(match[2]['misses'], 1)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, url
from . import views


urlpatterns = patterns(
    '',
    url(r'^$', views.home, name='home'),
    #url(r'^2$', views.home2, name='home2'),
    #url(r'^3$', views.home3, name='home3'),
)

########NEW FILE########
__FILENAME__ = views
import uuid
from django.shortcuts import render
from fancy_cache import cache_page


def _view(request):
    random_string = uuid.uuid4().hex
    return render(request, 'home.html', dict(random_string=random_string))


@cache_page(60)
def home(request):
    return _view(request)


def prefixer1(request):
    if request.META.get('AUTH_USER'):
        # disable
        return None
    return 'a_key'


@cache_page(60, key_prefix=prefixer1)
def home2(request):
    return _view(request)


def post_processor1(response, request):
    assert 'In your HTML' not in response.content
    response.content += 'In your HTML:%s' % uuid.uuid4().hex
    return response


@cache_page(60,
            key_prefix=prefixer1,
            post_process_response=post_processor1)
def home3(request):
    return _view(request)


@cache_page(60,
            key_prefix=prefixer1,
            post_process_response_always=post_processor1)
def home4(request):
    return _view(request)


@cache_page(60, only_get_keys=['foo', 'bar'])
def home5(request):
    return _view(request)

@cache_page(60, forget_get_keys=['bar'])
def home5bis(request):
    return _view(request)

@cache_page(60, remember_stats_all_urls=True, remember_all_urls=True)
def home6(request):
    return _view(request)

########NEW FILE########
