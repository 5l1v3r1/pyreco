__FILENAME__ = ANSI
import warnings

warnings.warn("This module has been moved to pexpect.ANSI, please update imports.",
                ImportWarning)
del warnings

from pexpect.ANSI import *  # analysis:ignore
########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Pexpect documentation build configuration file, created by
# sphinx-quickstart on Tue Sep 17 11:05:11 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('sphinxext'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx',
              'sphinx.ext.viewcode', 'github',  # for easy GitHub links
              ]

github_project_url = "https://github.com/pexpect/pexpect"

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Pexpect'
copyright = u'2013, Noah Spurrier and contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '3.2'
# The full version, including alpha/beta/rc tags.
release = '3.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Pexpectdoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Pexpect.tex', u'Pexpect Documentation',
   u'Noah Spurrier and contributors', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pexpect', u'Pexpect Documentation',
     [u'Noah Spurrier and contributors'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Pexpect', u'Pexpect Documentation',
   u'Noah Spurrier and contributors', 'Pexpect', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/3/': None}

########NEW FILE########
__FILENAME__ = github
"""Define text roles for GitHub

* ghissue - Issue
* ghpull - Pull Request
* ghuser - User

Adapted from bitbucket example here:
https://bitbucket.org/birkenfeld/sphinx-contrib/src/tip/bitbucket/sphinxcontrib/bitbucket.py

Authors
-------

* Doug Hellmann
* Min RK
"""
#
# Original Copyright (c) 2010 Doug Hellmann.  All rights reserved.
#

from docutils import nodes, utils
from docutils.parsers.rst.roles import set_classes

def make_link_node(rawtext, app, type, slug, options):
    """Create a link to a github resource.

    :param rawtext: Text being replaced with link node.
    :param app: Sphinx application context
    :param type: Link type (issues, changeset, etc.)
    :param slug: ID of the thing to link to
    :param options: Options dictionary passed to role func.
    """

    try:
        base = app.config.github_project_url
        if not base:
            raise AttributeError
        if not base.endswith('/'):
            base += '/'
    except AttributeError as err:
        raise ValueError('github_project_url configuration value is not set (%s)' % str(err))

    ref = base + type + '/' + slug + '/'
    set_classes(options)
    prefix = "#"
    if type == 'pull':
        prefix = "PR " + prefix
    node = nodes.reference(rawtext, prefix + utils.unescape(slug), refuri=ref,
                           **options)
    return node

def ghissue_role(name, rawtext, text, lineno, inliner, options={}, content=[]):
    """Link to a GitHub issue.

    Returns 2 part tuple containing list of nodes to insert into the
    document and a list of system messages.  Both are allowed to be
    empty.

    :param name: The role name used in the document.
    :param rawtext: The entire markup snippet, with role.
    :param text: The text marked with the role.
    :param lineno: The line number where rawtext appears in the input.
    :param inliner: The inliner instance that called us.
    :param options: Directive options for customization.
    :param content: The directive content for customization.
    """

    try:
        issue_num = int(text)
        if issue_num <= 0:
            raise ValueError
    except ValueError:
        msg = inliner.reporter.error(
            'GitHub issue number must be a number greater than or equal to 1; '
            '"%s" is invalid.' % text, line=lineno)
        prb = inliner.problematic(rawtext, rawtext, msg)
        return [prb], [msg]
    app = inliner.document.settings.env.app
    #app.info('issue %r' % text)
    if 'pull' in name.lower():
        category = 'pull'
    elif 'issue' in name.lower():
        category = 'issues'
    else:
        msg = inliner.reporter.error(
            'GitHub roles include "ghpull" and "ghissue", '
            '"%s" is invalid.' % name, line=lineno)
        prb = inliner.problematic(rawtext, rawtext, msg)
        return [prb], [msg]
    node = make_link_node(rawtext, app, category, str(issue_num), options)
    return [node], []

def ghuser_role(name, rawtext, text, lineno, inliner, options={}, content=[]):
    """Link to a GitHub user.

    Returns 2 part tuple containing list of nodes to insert into the
    document and a list of system messages.  Both are allowed to be
    empty.

    :param name: The role name used in the document.
    :param rawtext: The entire markup snippet, with role.
    :param text: The text marked with the role.
    :param lineno: The line number where rawtext appears in the input.
    :param inliner: The inliner instance that called us.
    :param options: Directive options for customization.
    :param content: The directive content for customization.
    """
    app = inliner.document.settings.env.app
    #app.info('user link %r' % text)
    ref = 'https://www.github.com/' + text
    node = nodes.reference(rawtext, text, refuri=ref, **options)
    return [node], []

def ghcommit_role(name, rawtext, text, lineno, inliner, options={}, content=[]):
    """Link to a GitHub commit.

    Returns 2 part tuple containing list of nodes to insert into the
    document and a list of system messages.  Both are allowed to be
    empty.

    :param name: The role name used in the document.
    :param rawtext: The entire markup snippet, with role.
    :param text: The text marked with the role.
    :param lineno: The line number where rawtext appears in the input.
    :param inliner: The inliner instance that called us.
    :param options: Directive options for customization.
    :param content: The directive content for customization.
    """
    app = inliner.document.settings.env.app
    #app.info('user link %r' % text)
    try:
        base = app.config.github_project_url
        if not base:
            raise AttributeError
        if not base.endswith('/'):
            base += '/'
    except AttributeError as err:
        raise ValueError('github_project_url configuration value is not set (%s)' % str(err))

    ref = base + text
    node = nodes.reference(rawtext, text[:6], refuri=ref, **options)
    return [node], []


def setup(app):
    """Install the plugin.
    
    :param app: Sphinx application context.
    """
    app.info('Initializing GitHub plugin')
    app.add_role('ghissue', ghissue_role)
    app.add_role('ghpull', ghissue_role)
    app.add_role('ghuser', ghuser_role)
    app.add_role('ghcommit', ghcommit_role)
    app.add_config_value('github_project_url', None, 'env')
    return

########NEW FILE########
__FILENAME__ = astat
#!/usr/bin/env python

'''This runs Apache Status on the remote host and returns the number of requests per second.

./astat.py [-s server_hostname] [-u username] [-p password]
    -s : hostname of the remote server to login to.
    -u : username to user for login.
    -p : Password to user for login.

Example:
    This will print information about the given host:
        ./astat.py -s www.example.com -u mylogin -p mypassword

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import print_function

from __future__ import absolute_import

import os, sys, time, re, getopt, getpass
import pexpect, pxssh


try:
    raw_input
except NameError:
    raw_input = input


def exit_with_usage():

    print(globals()['__doc__'])
    os._exit(1)


def main():

    ######################################################################
    ## Parse the options, arguments, get ready, etc.
    ######################################################################
    try:
        optlist, args = getopt.getopt(sys.argv[1:], 'h?s:u:p:', ['help','h','?'])
    except Exception as e:
        print(str(e))
        exit_with_usage()
    options = dict(optlist)
    if len(args) > 1:
        exit_with_usage()

    if [elem for elem in options if elem in ['-h','--h','-?','--?','--help']]:
        print("Help:")
        exit_with_usage()

    if '-s' in options:
        hostname = options['-s']
    else:
        hostname = raw_input('hostname: ')
    if '-u' in options:
        username = options['-u']
    else:
        username = raw_input('username: ')
    if '-p' in options:
        password = options['-p']
    else:
        password = getpass.getpass('password: ')

    #
    # Login via SSH
    #
    p = pxssh.pxssh()
    p.login(hostname, username, password)
    p.sendline('apachectl status')
    p.expect('([0-9]+\.[0-9]+)\s*requests/sec')
    requests_per_second = p.match.groups()[0]
    p.logout()
    print(requests_per_second)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = chess
#!/usr/bin/env python

'''This demonstrates controlling a screen oriented application (curses).
It starts two instances of gnuchess and then pits them against each other.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import print_function

from __future__ import absolute_import

import pexpect
import string
import ANSI

REGEX_MOVE = '(?:[a-z]|\x1b\[C)(?:[0-9]|\x1b\[C)(?:[a-z]|\x1b\[C)(?:[0-9]|\x1b\[C)'
REGEX_MOVE_PART = '(?:[0-9]|\x1b\[C)(?:[a-z]|\x1b\[C)(?:[0-9]|\x1b\[C)'

class Chess:

    def __init__(self, engine = "/usr/local/bin/gnuchess -a -h 1"):
        self.child = pexpect.spawn (engine)
        self.term = ANSI.ANSI ()

        self.child.expect ('Chess')
        if self.child.after != 'Chess':
            raise IOError('incompatible chess program')
        self.term.process_list (self.before)
        self.term.process_list (self.after)
        self.last_computer_move = ''

    def read_until_cursor (self, r,c):
        while 1:
            self.child.read(1, 60)
            self.term.process (c)
            if self.term.cur_r == r and self.term.cur_c == c:
                return 1

    def do_first_move (self, move):
        self.child.expect ('Your move is')
        self.child.sendline (move)
        self.term.process_list (self.before)
        self.term.process_list (self.after)
        return move

    def do_move (self, move):
        self.read_until_cursor (19,60)
        self.child.sendline (move)
        return move

    def get_first_computer_move (self):
        self.child.expect ('My move is')
        self.child.expect (REGEX_MOVE)
        return self.child.after

    def get_computer_move (self):
        print('Here')
        i = self.child.expect (['\[17;59H', '\[17;58H'])
        print(i)
        if i == 0:
            self.child.expect (REGEX_MOVE)
            if len(self.child.after) < 4:
                self.child.after = self.child.after + self.last_computer_move[3]
        if i == 1:
            self.child.expect (REGEX_MOVE_PART)
            self.child.after = self.last_computer_move[0] + self.child.after
        print('', self.child.after)
        self.last_computer_move = self.child.after
        return self.child.after

    def switch (self):
        self.child.sendline ('switch')

    def set_depth (self, depth):
        self.child.sendline ('depth')
        self.child.expect ('depth=')
        self.child.sendline ('%d' % depth)

    def quit(self):
        self.child.sendline ('quit')
import sys, os
print('Starting...')
white = Chess()
white.child.echo = 1
white.child.expect ('Your move is')
white.set_depth(2)
white.switch()

move_white = white.get_first_computer_move()
print('first move white:', move_white)

white.do_move ('e7e5')
move_white = white.get_computer_move()
print('move white:', move_white)
white.do_move ('f8c5')
move_white = white.get_computer_move()
print('move white:', move_white)
white.do_move ('b8a6')
move_white = white.get_computer_move()
print('move white:', move_white)

sys.exit(1)



black = Chess()
white = Chess()
white.child.expect ('Your move is')
white.switch()

move_white = white.get_first_computer_move()
print('first move white:', move_white)

black.do_first_move (move_white)
move_black = black.get_first_computer_move()
print('first move black:', move_black)

white.do_move (move_black)

done = 0
while not done:
    move_white = white.get_computer_move()
    print('move white:', move_white)

    black.do_move (move_white)
    move_black = black.get_computer_move()
    print('move black:', move_black)

    white.do_move (move_black)
    print('tail of loop')

g.quit()

########NEW FILE########
__FILENAME__ = chess2
#!/usr/bin/env python

'''This demonstrates controlling a screen oriented application (curses).
It starts two instances of gnuchess and then pits them against each other.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import print_function

from __future__ import absolute_import

import pexpect
import string
import ANSI
import sys, os, time

class Chess:

        def __init__(self, engine = "/usr/local/bin/gnuchess -a -h 1"):
                self.child = pexpect.spawn (engine)
                self.term = ANSI.ANSI ()

                #self.child.expect ('Chess')
                #if self.child.after != 'Chess':
                #        raise IOError, 'incompatible chess program'
                #self.term.process_list (self.child.before)
                #self.term.process_list (self.child.after)

                self.last_computer_move = ''

        def read_until_cursor (self, r,c, e=0):
            '''Eventually something like this should move into the screen class or
            a subclass. Maybe a combination of pexpect and screen...
            '''
            fout = open ('log','a')
            while self.term.cur_r != r or self.term.cur_c != c:
                try:
                    k = self.child.read(1, 10)
                except Exception as e:
                    print('EXCEPTION, (r,c):(%d,%d)\n' %(self.term.cur_r, self.term.cur_c))
                    sys.stdout.flush()
                self.term.process (k)
                fout.write ('(r,c):(%d,%d)\n' %(self.term.cur_r, self.term.cur_c))
                fout.flush()
                if e:
                    sys.stdout.write (k)
                    sys.stdout.flush()
                if self.term.cur_r == r and self.term.cur_c == c:
                    fout.close()
                    return 1
            print('DIDNT EVEN HIT.')
            fout.close()
            return 1

        def expect_region (self):
            '''This is another method that would be moved into the
            screen class.
            '''
            pass
        def do_scan (self):
            fout = open ('log','a')
            while 1:
                c = self.child.read(1,10)
                self.term.process (c)
                fout.write ('(r,c):(%d,%d)\n' %(self.term.cur_r, self.term.cur_c))
                fout.flush()
                sys.stdout.write (c)
                sys.stdout.flush()

        def do_move (self, move, e = 0):
                time.sleep(1)
                self.read_until_cursor (19,60, e)
                self.child.sendline (move)

        def wait (self, color):
            while 1:
                r = self.term.get_region (14,50,14,60)[0]
                r = r.strip()
                if r == color:
                    return
                time.sleep (1)

        def parse_computer_move (self, s):
                i = s.find ('is: ')
                cm = s[i+3:i+9]
                return cm
        def get_computer_move (self, e = 0):
                time.sleep(1)
                self.read_until_cursor (19,60, e)
                time.sleep(1)
                r = self.term.get_region (17,50,17,62)[0]
                cm = self.parse_computer_move (r)
                return cm

        def switch (self):
                print('switching')
                self.child.sendline ('switch')

        def set_depth (self, depth):
                self.child.sendline ('depth')
                self.child.expect ('depth=')
                self.child.sendline ('%d' % depth)

        def quit(self):
                self.child.sendline ('quit')

def LOG (s):
    print(s)
    sys.stdout.flush ()
    fout = open ('moves.log', 'a')
    fout.write (s + '\n')
    fout.close()

print('Starting...')

black = Chess()
white = Chess()
white.read_until_cursor (19,60,1)
white.switch()

done = 0
while not done:
    white.wait ('Black')
    move_white = white.get_computer_move(1)
    LOG ( 'move white:'+ move_white )

    black.do_move (move_white)
    black.wait ('White')
    move_black = black.get_computer_move()
    LOG ( 'move black:'+ move_black )

    white.do_move (move_black, 1)

g.quit()



########NEW FILE########
__FILENAME__ = chess3
#!/usr/bin/env python

'''This demonstrates controlling a screen oriented application (curses).
It starts two instances of gnuchess and then pits them against each other.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import print_function

from __future__ import absolute_import

import pexpect
import string
import ANSI

REGEX_MOVE = '(?:[a-z]|\x1b\[C)(?:[0-9]|\x1b\[C)(?:[a-z]|\x1b\[C)(?:[0-9]|\x1b\[C)'
REGEX_MOVE_PART = '(?:[0-9]|\x1b\[C)(?:[a-z]|\x1b\[C)(?:[0-9]|\x1b\[C)'

class Chess:

    def __init__(self, engine = "/usr/local/bin/gnuchess -a -h 1"):
        self.child = pexpect.spawn (engine)
        self.term = ANSI.ANSI ()

#		self.child.expect ('Chess')
    #	if self.child.after != 'Chess':
    #		raise IOError, 'incompatible chess program'
    #        self.term.process_list (self.before)
    #        self.term.process_list (self.after)
        self.last_computer_move = ''
    def read_until_cursor (self, r,c):
        fout = open ('log','a')
        while 1:
            k = self.child.read(1, 10)
            self.term.process (k)
            fout.write ('(r,c):(%d,%d)\n' %(self.term.cur_r, self.term.cur_c))
            fout.flush()
            if self.term.cur_r == r and self.term.cur_c == c:
                fout.close()
                return 1
            sys.stdout.write (k)
            sys.stdout.flush()

    def do_scan (self):
        fout = open ('log','a')
        while 1:
            c = self.child.read(1,10)
            self.term.process (c)
            fout.write ('(r,c):(%d,%d)\n' %(self.term.cur_r, self.term.cur_c))
            fout.flush()
            sys.stdout.write (c)
            sys.stdout.flush()

    def do_move (self, move):
        self.read_until_cursor (19,60)
        self.child.sendline (move)
        return move

    def get_computer_move (self):
        print('Here')
        i = self.child.expect (['\[17;59H', '\[17;58H'])
        print(i)
        if i == 0:
            self.child.expect (REGEX_MOVE)
            if len(self.child.after) < 4:
                self.child.after = self.child.after + self.last_computer_move[3]
        if i == 1:
            self.child.expect (REGEX_MOVE_PART)
            self.child.after = self.last_computer_move[0] + self.child.after
        print('', self.child.after)
        self.last_computer_move = self.child.after
        return self.child.after

    def switch (self):
        self.child.sendline ('switch')

    def set_depth (self, depth):
        self.child.sendline ('depth')
        self.child.expect ('depth=')
        self.child.sendline ('%d' % depth)

    def quit(self):
        self.child.sendline ('quit')
import sys, os
print('Starting...')
white = Chess()
white.do_move('b2b4')
white.read_until_cursor (19,60)
c1 = white.term.get_abs(17,58)
c2 = white.term.get_abs(17,59)
c3 = white.term.get_abs(17,60)
c4 = white.term.get_abs(17,61)
fout = open ('log','a')
fout.write ('Computer:%s%s%s%s\n' %(c1,c2,c3,c4))
fout.close()
white.do_move('c2c4')
white.read_until_cursor (19,60)
c1 = white.term.get_abs(17,58)
c2 = white.term.get_abs(17,59)
c3 = white.term.get_abs(17,60)
c4 = white.term.get_abs(17,61)
fout = open ('log','a')
fout.write ('Computer:%s%s%s%s\n' %(c1,c2,c3,c4))
fout.close()
white.do_scan ()

#white.do_move ('b8a6')
#move_white = white.get_computer_move()
#print 'move white:', move_white

sys.exit(1)



black = Chess()
white = Chess()
white.child.expect ('Your move is')
white.switch()

move_white = white.get_first_computer_move()
print('first move white:', move_white)

black.do_first_move (move_white)
move_black = black.get_first_computer_move()
print('first move black:', move_black)

white.do_move (move_black)

done = 0
while not done:
    move_white = white.get_computer_move()
    print('move white:', move_white)

    black.do_move (move_white)
    move_black = black.get_computer_move()
    print('move black:', move_black)

    white.do_move (move_black)
    print('tail of loop')

g.quit()

########NEW FILE########
__FILENAME__ = df
#!/usr/bin/env python

'''This collects filesystem capacity info using the 'df' command. Tuples of
filesystem name and percentage are stored in a list. A simple report is
printed. Filesystems over 95% capacity are highlighted. Note that this does not
parse filesystem names after the first space, so names with spaces in them will
be truncated. This will produce ambiguous results for automount filesystems on
Apple OSX.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import print_function

from __future__ import absolute_import

import pexpect

child = pexpect.spawn ('df')

# parse 'df' output into a list.
pattern = "\n(\S+).*?([0-9]+)%"
filesystem_list = []
for dummy in range (0, 1000):
    i = child.expect ([pattern, pexpect.EOF])
    if i == 0:
        filesystem_list.append (child.match.groups())
    else:
        break

# Print report
print()
for m in filesystem_list:
    s = "Filesystem %s is at %s%%" % (m[0], m[1])
    # highlight filesystems over 95% capacity
    if int(m[1]) > 95:
        s = '! ' + s
    else:
        s = '  ' + s
    print(s)


########NEW FILE########
__FILENAME__ = ftp
#!/usr/bin/env python

'''This demonstrates an FTP "bookmark". This connects to an ftp site; does a
few ftp stuff; and then gives the user interactive control over the session. In
this case the "bookmark" is to a directory on the OpenBSD ftp server. It puts
you in the i386 packages directory. You can easily modify this for other sites.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import pexpect
import sys

# Note that, for Python 3 compatibility reasons, we are using spawnu and
# importing unicode_literals (above). spawnu accepts Unicode input and
# unicode_literals makes all string literals in this script Unicode by default.
child = pexpect.spawnu('ftp ftp.openbsd.org')

child.expect('(?i)name .*: ')
child.sendline('anonymous')
child.expect('(?i)password')
child.sendline('pexpect@sourceforge.net')
child.expect('ftp> ')
child.sendline('cd /pub/OpenBSD/3.7/packages/i386')
child.expect('ftp> ')
child.sendline('bin')
child.expect('ftp> ')
child.sendline('prompt')
child.expect('ftp> ')
child.sendline('pwd')
child.expect('ftp> ')
print("Escape character is '^]'.\n")
sys.stdout.write (child.after)
sys.stdout.flush()
child.interact() # Escape character defaults to ^]
# At this point this script blocks until the user presses the escape character
# or until the child exits. The human user and the child should be talking
# to each other now.

# At this point the script is running again.
print('Left interactve mode.')

# The rest is not strictly necessary. This just demonstrates a few functions.
# This makes sure the child is dead; although it would be killed when Python exits.
if child.isalive():
    child.sendline('bye') # Try to ask ftp child to exit.
    child.close()
# Print the final state of the child. Normally isalive() should be FALSE.
if child.isalive():
    print('Child did not exit gracefully.')
else:
    print('Child exited gracefully.')


########NEW FILE########
__FILENAME__ = hive
#!/usr/bin/env python

'''hive -- Hive Shell

This lets you ssh to a group of servers and control them as if they were one.
Each command you enter is sent to each host in parallel. The response of each
host is collected and printed. In normal synchronous mode Hive will wait for
each host to return the shell command line prompt. The shell prompt is used to
sync output.

Example:

    $ hive.py --sameuser --samepass host1.example.com host2.example.net
    username: myusername
    password:
    connecting to host1.example.com - OK
    connecting to host2.example.net - OK
    targetting hosts: 192.168.1.104 192.168.1.107
    CMD (? for help) > uptime
    =======================================================================
    host1.example.com
    -----------------------------------------------------------------------
    uptime
    23:49:55 up 74 days,  5:14,  2 users,  load average: 0.15, 0.05, 0.01
    =======================================================================
    host2.example.net
    -----------------------------------------------------------------------
    uptime
    23:53:02 up 1 day, 13:36,  2 users,  load average: 0.50, 0.40, 0.46
    =======================================================================

Other Usage Examples:

1. You will be asked for your username and password for each host.

    hive.py host1 host2 host3 ... hostN

2. You will be asked once for your username and password.
   This will be used for each host.

    hive.py --sameuser --samepass host1 host2 host3 ... hostN

3. Give a username and password on the command-line:

    hive.py user1:pass2@host1 user2:pass2@host2 ... userN:passN@hostN

You can use an extended host notation to specify username, password, and host
instead of entering auth information interactively. Where you would enter a
host name use this format:

    username:password@host

This assumes that ':' is not part of the password. If your password contains a
':' then you can use '\\:' to indicate a ':' and '\\\\' to indicate a single
'\\'. Remember that this information will appear in the process listing. Anyone
on your machine can see this auth information. This is not secure.

This is a crude script that begs to be multithreaded. But it serves its
purpose.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import print_function

from __future__ import absolute_import

# TODO add feature to support username:password@host combination
# TODO add feature to log each host output in separate file

import sys
import os
import re
import optparse
import types
import time
import getpass
import readline
import atexit
try:
    import pexpect
    import pxssh
except ImportError:
    sys.stderr.write("You do not have 'pexpect' installed.\n")
    sys.stderr.write("On Ubuntu you need the 'python-pexpect' package.\n")
    sys.stderr.write("    aptitude -y install python-pexpect\n")
    exit(1)


try:
    raw_input
except NameError:
    raw_input = input


histfile = os.path.join(os.environ["HOME"], ".hive_history")
try:
    readline.read_history_file(histfile)
except IOError:
    pass
atexit.register(readline.write_history_file, histfile)

CMD_HELP='''Hive commands are preceded by a colon : (just think of vi).

:target name1 name2 name3 ...

    set list of hosts to target commands

:target all

    reset list of hosts to target all hosts in the hive.

:to name command

    send a command line to the named host. This is similar to :target, but
    sends only one command and does not change the list of targets for future
    commands.

:sync

    set mode to wait for shell prompts after commands are run. This is the
    default. When Hive first logs into a host it sets a special shell prompt
    pattern that it can later look for to synchronize output of the hosts. If
    you 'su' to another user then it can upset the synchronization. If you need
    to run something like 'su' then use the following pattern:

    CMD (? for help) > :async
    CMD (? for help) > sudo su - root
    CMD (? for help) > :prompt
    CMD (? for help) > :sync

:async

    set mode to not expect command line prompts (see :sync). Afterwards
    commands are send to target hosts, but their responses are not read back
    until :sync is run. This is useful to run before commands that will not
    return with the special shell prompt pattern that Hive uses to synchronize.

:refresh

    refresh the display. This shows the last few lines of output from all hosts.
    This is similar to resync, but does not expect the promt. This is useful
    for seeing what hosts are doing during long running commands.

:resync

    This is similar to :sync, but it does not change the mode. It looks for the
    prompt and thus consumes all input from all targetted hosts.

:prompt

    force each host to reset command line prompt to the special pattern used to
    synchronize all the hosts. This is useful if you 'su' to a different user
    where Hive would not know the prompt to match.

:send my text

    This will send the 'my text' wihtout a line feed to the targetted hosts.
    This output of the hosts is not automatically synchronized.

:control X

    This will send the given control character to the targetted hosts.
    For example, ":control c" will send ASCII 3.

:exit

    This will exit the hive shell.

'''

def login (args, cli_username=None, cli_password=None):

    # I have to keep a separate list of host names because Python dicts are not ordered.
    # I want to keep the same order as in the args list.
    host_names = []
    hive_connect_info = {}
    hive = {}
    # build up the list of connection information (hostname, username, password, port)
    for host_connect_string in args:
        hcd = parse_host_connect_string (host_connect_string)
        hostname = hcd['hostname']
        port     = hcd['port']
        if port == '':
            port = None
        if len(hcd['username']) > 0:
            username = hcd['username']
        elif cli_username is not None:
            username = cli_username
        else:
            username = raw_input('%s username: ' % hostname)
        if len(hcd['password']) > 0:
            password = hcd['password']
        elif cli_password is not None:
            password = cli_password
        else:
            password = getpass.getpass('%s password: ' % hostname)
        host_names.append(hostname)
        hive_connect_info[hostname] = (hostname, username, password, port)
    # build up the list of hive connections using the connection information.
    for hostname in host_names:
        print('connecting to', hostname)
        try:
            fout = file("log_"+hostname, "w")
            hive[hostname] = pxssh.pxssh()
            # Disable host key checking.
            hive[hostname].SSH_OPTS = (hive[hostname].SSH_OPTS
                    + " -o 'StrictHostKeyChecking=no'"
                    + " -o 'UserKnownHostsFile /dev/null' ")
            hive[hostname].force_password = True
            hive[hostname].login(*hive_connect_info[hostname])
            print(hive[hostname].before)
            hive[hostname].logfile = fout
            print('- OK')
        except Exception as e:
            print('- ERROR', end=' ')
            print(str(e))
            print('Skipping', hostname)
            hive[hostname] = None
    return host_names, hive

def main ():

    global options, args, CMD_HELP

    rows = 24
    cols = 80

    if options.sameuser:
        cli_username = raw_input('username: ')
    else:
        cli_username = None

    if options.samepass:
        cli_password = getpass.getpass('password: ')
    else:
        cli_password = None

    host_names, hive = login(args, cli_username, cli_password)

    synchronous_mode = True
    target_hostnames = host_names[:]
    print('targetting hosts:', ' '.join(target_hostnames))
    while True:
        cmd = raw_input('CMD (? for help) > ')
        cmd = cmd.strip()
        if cmd=='?' or cmd==':help' or cmd==':h':
            print(CMD_HELP)
            continue
        elif cmd==':refresh':
            refresh (hive, target_hostnames, timeout=0.5)
            for hostname in target_hostnames:
                print('/' + '=' * (cols - 2))
                print('| ' + hostname)
                print('\\' + '-' * (cols - 2))
                if hive[hostname] is None:
                    print('# DEAD: %s' % hostname)
                else:
                    print(hive[hostname].before)
            print('#' * 79)
            continue
        elif cmd==':resync':
            resync (hive, target_hostnames, timeout=0.5)
            for hostname in target_hostnames:
                print('/' + '=' * (cols - 2))
                print('| ' + hostname)
                print('\\' + '-' * (cols - 2))
                if hive[hostname] is None:
                    print('# DEAD: %s' % hostname)
                else:
                    print(hive[hostname].before)
            print('#' * 79)
            continue
        elif cmd==':sync':
            synchronous_mode = True
            resync (hive, target_hostnames, timeout=0.5)
            continue
        elif cmd==':async':
            synchronous_mode = False
            continue
        elif cmd==':prompt':
            for hostname in target_hostnames:
                try:
                    if hive[hostname] is not None:
                        hive[hostname].set_unique_prompt()
                except Exception as e:
                    print("Had trouble communicating with %s, so removing it from the target list." % hostname)
                    print(str(e))
                    hive[hostname] = None
            continue
        elif cmd[:5] == ':send':
            cmd, txt = cmd.split(None,1)
            for hostname in target_hostnames:
                try:
                    if hive[hostname] is not None:
                        hive[hostname].send(txt)
                except Exception as e:
                    print("Had trouble communicating with %s, so removing it from the target list." % hostname)
                    print(str(e))
                    hive[hostname] = None
            continue
        elif cmd[:3] == ':to':
            cmd, hostname, txt = cmd.split(None,2)
            print('/' + '=' * (cols - 2))
            print('| ' + hostname)
            print('\\' + '-' * (cols - 2))
            if hive[hostname] is None:
                print('# DEAD: %s' % hostname)
                continue
            try:
                hive[hostname].sendline (txt)
                hive[hostname].prompt(timeout=2)
                print(hive[hostname].before)
            except Exception as e:
                print("Had trouble communicating with %s, so removing it from the target list." % hostname)
                print(str(e))
                hive[hostname] = None
            continue
        elif cmd[:7] == ':expect':
            cmd, pattern = cmd.split(None,1)
            print('looking for', pattern)
            try:
                for hostname in target_hostnames:
                    if hive[hostname] is not None:
                        hive[hostname].expect(pattern)
                        print(hive[hostname].before)
            except Exception as e:
                print("Had trouble communicating with %s, so removing it from the target list." % hostname)
                print(str(e))
                hive[hostname] = None
            continue
        elif cmd[:7] == ':target':
            target_hostnames = cmd.split()[1:]
            if len(target_hostnames) == 0 or target_hostnames[0] == all:
                target_hostnames = host_names[:]
            print('targetting hosts:', ' '.join(target_hostnames))
            continue
        elif cmd == ':exit' or cmd == ':q' or cmd == ':quit':
            break
        elif cmd[:8] == ':control' or cmd[:5] == ':ctrl' :
            cmd, c = cmd.split(None,1)
            if ord(c)-96 < 0 or ord(c)-96 > 255:
                print('/' + '=' * (cols - 2))
                print('| Invalid character. Must be [a-zA-Z], @, [, ], \\, ^, _, or ?')
                print('\\' + '-' * (cols - 2))
                continue
            for hostname in target_hostnames:
                try:
                    if hive[hostname] is not None:
                        hive[hostname].sendcontrol(c)
                except Exception as e:
                    print("Had trouble communicating with %s, so removing it from the target list." % hostname)
                    print(str(e))
                    hive[hostname] = None
            continue
        elif cmd == ':esc':
            for hostname in target_hostnames:
                if hive[hostname] is not None:
                    hive[hostname].send(chr(27))
            continue
        #
        # Run the command on all targets in parallel
        #
        for hostname in target_hostnames:
            try:
                if hive[hostname] is not None:
                    hive[hostname].sendline (cmd)
            except Exception as e:
                print("Had trouble communicating with %s, so removing it from the target list." % hostname)
                print(str(e))
                hive[hostname] = None

        #
        # print the response for each targeted host.
        #
        if synchronous_mode:
            for hostname in target_hostnames:
                try:
                    print('/' + '=' * (cols - 2))
                    print('| ' + hostname)
                    print('\\' + '-' * (cols - 2))
                    if hive[hostname] is None:
                        print('# DEAD: %s' % hostname)
                    else:
                        hive[hostname].prompt(timeout=2)
                        print(hive[hostname].before)
                except Exception as e:
                    print("Had trouble communicating with %s, so removing it from the target list." % hostname)
                    print(str(e))
                    hive[hostname] = None
            print('#' * 79)

def refresh (hive, hive_names, timeout=0.5):

    '''This waits for the TIMEOUT on each host.
    '''

    # TODO This is ideal for threading.
    for hostname in hive_names:
        if hive[hostname] is not None:
            hive[hostname].expect([pexpect.TIMEOUT,pexpect.EOF],timeout=timeout)

def resync (hive, hive_names, timeout=2, max_attempts=5):

    '''This waits for the shell prompt for each host in an effort to try to get
    them all to the same state. The timeout is set low so that hosts that are
    already at the prompt will not slow things down too much. If a prompt match
    is made for a hosts then keep asking until it stops matching. This is a
    best effort to consume all input if it printed more than one prompt. It's
    kind of kludgy. Note that this will always introduce a delay equal to the
    timeout for each machine. So for 10 machines with a 2 second delay you will
    get AT LEAST a 20 second delay if not more. '''

    # TODO This is ideal for threading.
    for hostname in hive_names:
        if hive[hostname] is not None:
            for attempts in range(0, max_attempts):
                if not hive[hostname].prompt(timeout=timeout):
                    break

def parse_host_connect_string (hcs):

    '''This parses a host connection string in the form
    username:password@hostname:port. All fields are options expcet hostname. A
    dictionary is returned with all four keys. Keys that were not included are
    set to empty strings ''. Note that if your password has the '@' character
    then you must backslash escape it. '''

    if '@' in hcs:
        p = re.compile (r'(?P<username>[^@:]*)(:?)(?P<password>.*)(?!\\)@(?P<hostname>[^:]*):?(?P<port>[0-9]*)')
    else:
        p = re.compile (r'(?P<username>)(?P<password>)(?P<hostname>[^:]*):?(?P<port>[0-9]*)')
    m = p.search (hcs)
    d = m.groupdict()
    d['password'] = d['password'].replace('\\@','@')
    return d

if __name__ == '__main__':
    start_time = time.time()
    parser = optparse.OptionParser(formatter=optparse.TitledHelpFormatter(), usage=globals()['__doc__'], version='$Id: hive.py 533 2012-10-20 02:19:33Z noah $',conflict_handler="resolve")
    parser.add_option ('-v', '--verbose', action='store_true', default=False, help='verbose output')
    parser.add_option ('--samepass', action='store_true', default=False, help='Use same password for each login.')
    parser.add_option ('--sameuser', action='store_true', default=False, help='Use same username for each login.')
    (options, args) = parser.parse_args()
    if len(args) < 1:
        parser.error ('missing argument')
    if options.verbose: print(time.asctime())
    main()
    if options.verbose: print(time.asctime())
    if options.verbose: print('TOTAL TIME IN MINUTES:', end=' ')
    if options.verbose: print((time.time() - start_time) / 60.0)

########NEW FILE########
__FILENAME__ = monitor
#!/usr/bin/env python

''' This runs a sequence of commands on a remote host using SSH. It runs a
simple system checks such as uptime and free to monitor the state of the remote
host.

./monitor.py [-s server_hostname] [-u username] [-p password]
    -s : hostname of the remote server to login to.
    -u : username to user for login.
    -p : Password to user for login.

Example:
    This will print information about the given host:
        ./monitor.py -s www.example.com -u mylogin -p mypassword

It works like this:
    Login via SSH (This is the hardest part).
    Run and parse 'uptime'.
    Run 'iostat'.
    Run 'vmstat'.
    Run 'netstat'
    Run 'free'.
    Exit the remote host.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import print_function

from __future__ import absolute_import

import os, sys, re, getopt, getpass
import pexpect


try:
    raw_input
except NameError:
    raw_input = input


#
# Some constants.
#
COMMAND_PROMPT = '[#$] ' ### This is way too simple for industrial use -- we will change is ASAP.
TERMINAL_PROMPT = '(?i)terminal type\?'
TERMINAL_TYPE = 'vt100'
# This is the prompt we get if SSH does not have the remote host's public key stored in the cache.
SSH_NEWKEY = '(?i)are you sure you want to continue connecting'

def exit_with_usage():

    print(globals()['__doc__'])
    os._exit(1)

def main():

    global COMMAND_PROMPT, TERMINAL_PROMPT, TERMINAL_TYPE, SSH_NEWKEY
    ######################################################################
    ## Parse the options, arguments, get ready, etc.
    ######################################################################
    try:
        optlist, args = getopt.getopt(sys.argv[1:], 'h?s:u:p:', ['help','h','?'])
    except Exception as e:
        print(str(e))
        exit_with_usage()
    options = dict(optlist)
    if len(args) > 1:
        exit_with_usage()

    if [elem for elem in options if elem in ['-h','--h','-?','--?','--help']]:
        print("Help:")
        exit_with_usage()

    if '-s' in options:
        host = options['-s']
    else:
        host = raw_input('hostname: ')
    if '-u' in options:
        user = options['-u']
    else:
        user = raw_input('username: ')
    if '-p' in options:
        password = options['-p']
    else:
        password = getpass.getpass('password: ')

    #
    # Login via SSH
    #
    child = pexpect.spawn('ssh -l %s %s'%(user, host))
    i = child.expect([pexpect.TIMEOUT, SSH_NEWKEY, COMMAND_PROMPT, '(?i)password'])
    if i == 0: # Timeout
        print('ERROR! could not login with SSH. Here is what SSH said:')
        print(child.before, child.after)
        print(str(child))
        sys.exit (1)
    if i == 1: # In this case SSH does not have the public key cached.
        child.sendline ('yes')
        child.expect ('(?i)password')
    if i == 2:
        # This may happen if a public key was setup to automatically login.
        # But beware, the COMMAND_PROMPT at this point is very trivial and
        # could be fooled by some output in the MOTD or login message.
        pass
    if i == 3:
        child.sendline(password)
        # Now we are either at the command prompt or
        # the login process is asking for our terminal type.
        i = child.expect ([COMMAND_PROMPT, TERMINAL_PROMPT])
        if i == 1:
            child.sendline (TERMINAL_TYPE)
            child.expect (COMMAND_PROMPT)
    #
    # Set command prompt to something more unique.
    #
    COMMAND_PROMPT = "\[PEXPECT\]\$ "
    child.sendline ("PS1='[PEXPECT]\$ '") # In case of sh-style
    i = child.expect ([pexpect.TIMEOUT, COMMAND_PROMPT], timeout=10)
    if i == 0:
        print("# Couldn't set sh-style prompt -- trying csh-style.")
        child.sendline ("set prompt='[PEXPECT]\$ '")
        i = child.expect ([pexpect.TIMEOUT, COMMAND_PROMPT], timeout=10)
        if i == 0:
            print("Failed to set command prompt using sh or csh style.")
            print("Response was:")
            print(child.before)
            sys.exit (1)

    # Now we should be at the command prompt and ready to run some commands.
    print('---------------------------------------')
    print('Report of commands run on remote host.')
    print('---------------------------------------')

    # Run uname.
    child.sendline ('uname -a')
    child.expect (COMMAND_PROMPT)
    print(child.before)
    if 'linux' in child.before.lower():
        LINUX_MODE = 1
    else:
        LINUX_MODE = 0

    # Run and parse 'uptime'.
    child.sendline ('uptime')
    child.expect('up\s+(.*?),\s+([0-9]+) users?,\s+load averages?: ([0-9]+\.[0-9][0-9]),?\s+([0-9]+\.[0-9][0-9]),?\s+([0-9]+\.[0-9][0-9])')
    duration, users, av1, av5, av15 = child.match.groups()
    days = '0'
    hours = '0'
    mins = '0'
    if 'day' in duration:
        child.match = re.search('([0-9]+)\s+day',duration)
        days = str(int(child.match.group(1)))
    if ':' in duration:
        child.match = re.search('([0-9]+):([0-9]+)',duration)
        hours = str(int(child.match.group(1)))
        mins = str(int(child.match.group(2)))
    if 'min' in duration:
        child.match = re.search('([0-9]+)\s+min',duration)
        mins = str(int(child.match.group(1)))
    print()
    print('Uptime: %s days, %s users, %s (1 min), %s (5 min), %s (15 min)' % (
        duration, users, av1, av5, av15))
    child.expect (COMMAND_PROMPT)

    # Run iostat.
    child.sendline ('iostat')
    child.expect (COMMAND_PROMPT)
    print(child.before)

    # Run vmstat.
    child.sendline ('vmstat')
    child.expect (COMMAND_PROMPT)
    print(child.before)

    # Run free.
    if LINUX_MODE:
        child.sendline ('free') # Linux systems only.
        child.expect (COMMAND_PROMPT)
        print(child.before)

    # Run df.
    child.sendline ('df')
    child.expect (COMMAND_PROMPT)
    print(child.before)

    # Run lsof.
    child.sendline ('lsof')
    child.expect (COMMAND_PROMPT)
    print(child.before)

#    # Run netstat
#    child.sendline ('netstat')
#    child.expect (COMMAND_PROMPT)
#    print child.before

#    # Run MySQL show status.
#    child.sendline ('mysql -p -e "SHOW STATUS;"')
#    child.expect (PASSWORD_PROMPT_MYSQL)
#    child.sendline (password_mysql)
#    child.expect (COMMAND_PROMPT)
#    print
#    print child.before

    # Now exit the remote host.
    child.sendline ('exit')
    index = child.expect([pexpect.EOF, "(?i)there are stopped jobs"])
    if index==1:
        child.sendline("exit")
        child.expect(EOF)

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = passmass
#!/usr/bin/env python

'''Change passwords on the named machines. passmass host1 host2 host3 . . .
Note that login shell prompt on remote machine must end in # or $.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import print_function

from __future__ import absolute_import

import pexpect
import sys, getpass


try:
    raw_input
except NameError:
    raw_input = input


USAGE = '''passmass host1 host2 host3 . . .'''
COMMAND_PROMPT = '[$#] '
TERMINAL_PROMPT = r'Terminal type\?'
TERMINAL_TYPE = 'vt100'
SSH_NEWKEY = r'Are you sure you want to continue connecting \(yes/no\)\?'

def login(host, user, password):

    child = pexpect.spawn('ssh -l %s %s'%(user, host))
    fout = file ("LOG.TXT","wb")
    child.setlog (fout)

    i = child.expect([pexpect.TIMEOUT, SSH_NEWKEY, '[Pp]assword: '])
    if i == 0: # Timeout
        print('ERROR!')
        print('SSH could not login. Here is what SSH said:')
        print(child.before, child.after)
        sys.exit (1)
    if i == 1: # SSH does not have the public key. Just accept it.
        child.sendline ('yes')
        child.expect ('[Pp]assword: ')
    child.sendline(password)
    # Now we are either at the command prompt or
    # the login process is asking for our terminal type.
    i = child.expect (['Permission denied', TERMINAL_PROMPT, COMMAND_PROMPT])
    if i == 0:
        print('Permission denied on host:', host)
        sys.exit (1)
    if i == 1:
        child.sendline (TERMINAL_TYPE)
        child.expect (COMMAND_PROMPT)
    return child

# (current) UNIX password:
def change_password(child, user, oldpassword, newpassword):

    child.sendline('passwd')
    i = child.expect(['[Oo]ld [Pp]assword', '.current.*password', '[Nn]ew [Pp]assword'])
    # Root does not require old password, so it gets to bypass the next step.
    if i == 0 or i == 1:
        child.sendline(oldpassword)
        child.expect('[Nn]ew [Pp]assword')
    child.sendline(newpassword)
    i = child.expect(['[Nn]ew [Pp]assword', '[Rr]etype', '[Rr]e-enter'])
    if i == 0:
        print('Host did not like new password. Here is what it said...')
        print(child.before)
        child.send (chr(3)) # Ctrl-C
        child.sendline('') # This should tell remote passwd command to quit.
        return
    child.sendline(newpassword)

def main():

    if len(sys.argv) <= 1:
        print(USAGE)
        return 1

    user = raw_input('Username: ')
    password = getpass.getpass('Current Password: ')
    newpassword = getpass.getpass('New Password: ')
    newpasswordconfirm = getpass.getpass('Confirm New Password: ')
    if newpassword != newpasswordconfirm:
        print('New Passwords do not match.')
        return 1

    for host in sys.argv[1:]:
        child = login(host, user, password)
        if child == None:
            print('Could not login to host:', host)
            continue
        print('Changing password on host:', host)
        change_password(child, user, password, newpassword)
        child.expect(COMMAND_PROMPT)
        child.sendline('exit')

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = python
#!/usr/bin/env python

'''This starts the python interpreter; captures the startup message; then gives
the user interactive control over the session. Why? For fun...

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import pexpect

# Don't do this unless you like being John Malkovich
# c = pexpect.spawnu('/usr/bin/env python ./python.py')

# Note that, for Python 3 compatibility reasons, we are using spawnu and
# importing unicode_literals (above). spawnu accepts Unicode input and
# unicode_literals makes all string literals in this script Unicode by default.
c = pexpect.spawnu('/usr/bin/env python')

c.expect('>>>')
print('And now for something completely different...')
print(''.join(reversed((c.before))))
print('Yes, it\'s python, but it\'s backwards.')
print()
print('Escape character is \'^]\'.')
print(c.after, end=' ')
c.interact()
c.kill(1)
print('is alive:', c.isalive())


########NEW FILE########
__FILENAME__ = script
#!/usr/bin/env python

'''This spawns a sub-shell (bash) and gives the user interactive control. The
entire shell session is logged to a file called script.log. This behaves much
like the classic BSD command 'script'.

./script.py [-a] [-c command] {logfilename}

    logfilename : This is the name of the log file. Default is script.log.
    -a : Append to log file. Default is to overwrite log file.
    -c : spawn command. Default is to spawn the sh shell.

Example:

    This will start a bash shell and append to the log named my_session.log:

        ./script.py -a -c bash my_session.log

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import print_function

from __future__ import absolute_import

import os, sys, time, getopt
import signal, fcntl, termios, struct
import pexpect

global_pexpect_instance = None # Used by signal handler

def exit_with_usage():

    print(globals()['__doc__'])
    os._exit(1)

def main():

    ######################################################################
    # Parse the options, arguments, get ready, etc.
    ######################################################################
    try:
        optlist, args = getopt.getopt(sys.argv[1:], 'h?ac:', ['help','h','?'])
    except Exception as e:
        print(str(e))
        exit_with_usage()
    options = dict(optlist)
    if len(args) > 1:
        exit_with_usage()

    if [elem for elem in options if elem in ['-h','--h','-?','--?','--help']]:
        print("Help:")
        exit_with_usage()

    if len(args) == 1:
        script_filename = args[0]
    else:
        script_filename = "script.log"
    if '-a' in options:
        fout = open(script_filename, "ab")
    else:
        fout = open(script_filename, "wb")
    if '-c' in options:
        command = options['-c']
    else:
        command = "sh"

    # Begin log with date/time in the form CCCCyymm.hhmmss
    fout.write ('# %4d%02d%02d.%02d%02d%02d \n' % time.localtime()[:-3])

    ######################################################################
    # Start the interactive session
    ######################################################################
    p = pexpect.spawn(command)
    p.logfile = fout
    global global_pexpect_instance
    global_pexpect_instance = p
    signal.signal(signal.SIGWINCH, sigwinch_passthrough)

    print("Script recording started. Type ^] (ASCII 29) to escape from the script shell.")
    p.interact(chr(29))
    fout.close()
    return 0

def sigwinch_passthrough (sig, data):

    # Check for buggy platforms (see pexpect.setwinsize()).
    if 'TIOCGWINSZ' in dir(termios):
        TIOCGWINSZ = termios.TIOCGWINSZ
    else:
        TIOCGWINSZ = 1074295912 # assume
    s = struct.pack ("HHHH", 0, 0, 0, 0)
    a = struct.unpack ('HHHH', fcntl.ioctl(sys.stdout.fileno(), TIOCGWINSZ , s))
    global global_pexpect_instance
    global_pexpect_instance.setwinsize(a[0],a[1])

if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = ssh_tunnel
#!/usr/bin/env python

'''This starts an SSH tunnel to a given host. If the SSH process ever dies then
this script will detect that and restart it. I use this under Cygwin to keep
open encrypted tunnels to port 25 (SMTP), port 143 (IMAP4), and port 110
(POP3). I set my mail client to talk to localhost and I keep this script
running in the background.

Note that this is a rather stupid script at the moment because it just looks to
see if any ssh process is running. It should really make sure that our specific
ssh process is running. The problem is that ssh is missing a very useful
feature. It has no way to report the process id of the background daemon that
it creates with the -f command. This would be a really useful script if I could
figure a way around this problem.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import print_function

from __future__ import absolute_import

import pexpect
import getpass
import time


try:
    raw_input
except NameError:
    raw_input = input


# SMTP:25 IMAP4:143 POP3:110
tunnel_command = 'ssh -C -N -f -L 25:127.0.0.1:25 -L 143:127.0.0.1:143 -L 110:127.0.0.1:110 %(user)@%(host)'
host = raw_input('Hostname: ')
user = raw_input('Username: ')
X = getpass.getpass('Password: ')

def get_process_info ():

    # This seems to work on both Linux and BSD, but should otherwise be considered highly UNportable.

    ps = pexpect.run ('ps ax -O ppid')
    pass

def start_tunnel ():

    try:
        ssh_tunnel = pexpect.spawn (tunnel_command % globals())
        ssh_tunnel.expect ('password:')
        time.sleep (0.1)
        ssh_tunnel.sendline (X)
        time.sleep (60) # Cygwin is slow to update process status.
        ssh_tunnel.expect (pexpect.EOF)

    except Exception as e:
        print(str(e))

def main ():

    while True:
        ps = pexpect.spawn ('ps')
        time.sleep (1)
        index = ps.expect (['/usr/bin/ssh', pexpect.EOF, pexpect.TIMEOUT])
        if index == 2:
            print('TIMEOUT in ps command...')
            print(str(ps))
            time.sleep (13)
        if index == 1:
            print(time.asctime(), end=' ')
            print('restarting tunnel')
            start_tunnel ()
            time.sleep (11)
            print('tunnel OK')
        else:
            # print 'tunnel OK'
            time.sleep (7)

if __name__ == '__main__':

    main ()

# This was for older SSH versions that didn't have -f option
#tunnel_command = 'ssh -C -n -L 25:%(host)s:25 -L 110:%(host)s:110 %(user)s@%(host)s -f nothing.sh'
#nothing_script = '''#!/bin/sh
#while true; do sleep 53; done
#'''


########NEW FILE########
__FILENAME__ = topip
#!/usr/bin/env python

''' This runs netstat on a local or remote server. It calculates some simple
statistical information on the number of external inet connections. It groups
by IP address. This can be used to detect if one IP address is taking up an
excessive number of connections. It can also send an email alert if a given IP
address exceeds a threshold between runs of the script. This script can be used
as a drop-in Munin plugin or it can be used stand-alone from cron. I used this
on a busy web server that would sometimes get hit with denial of service
attacks. This made it easy to see if a script was opening many multiple
connections. A typical browser would open fewer than 10 connections at once.
A script might open over 100 simultaneous connections.

./topip.py [-s server_hostname] [-u username] [-p password]
        {-a from_addr,to_addr} {-n N} {-v} {--ipv6}

    -s : hostname of the remote server to login to.
    -u : username to user for login.
    -p : password to user for login.
    -n : print stddev for the the number of the top 'N' ipaddresses.
    -v : verbose - print stats and list of top ipaddresses.
    -a : send alert if stddev goes over 20.
    -l : to log message to /var/log/topip.log
    --ipv6 : this parses netstat output that includes ipv6 format.
        Note that this actually only works with ipv4 addresses, but for
        versions of netstat that print in ipv6 format.
    --stdev=N : Where N is an integer. This sets the trigger point
        for alerts and logs. Default is to trigger if the
        max value is over 5 standard deviations.

Example:

    This will print stats for the top IP addresses connected to the given host:

        ./topip.py -s www.example.com -u mylogin -p mypassword -n 10 -v

    This will send an alert email if the maxip goes over the stddev trigger
    value and the the current top ip is the same as the last top ip
    (/tmp/topip.last):

        ./topip.py -s www.example.com -u mylogin -p mypassword \\
                -n 10 -v -a alert@example.com,user@example.com

    This will print the connection stats for the localhost in Munin format:

        ./topip.py

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

# See http://pexpect.sourceforge.net/
import pexpect
import pxssh
import os
import sys
import time
import getopt
import pickle
import getpass
import smtplib
from pprint import pprint


try:
    raw_input
except NameError:
    raw_input = input


TOPIP_LOG_FILE = '/var/log/topip.log'
TOPIP_LAST_RUN_STATS = '/var/run/topip.last'

def exit_with_usage():

    print(globals()['__doc__'])
    os._exit(1)

def stats(r):

    '''This returns a dict of the median, average, standard deviation,
    min and max of the given sequence.

    >>> from topip import stats
    >>> print stats([5,6,8,9])
    {'med': 8, 'max': 9, 'avg': 7.0, 'stddev': 1.5811388300841898, 'min': 5}
    >>> print stats([1000,1006,1008,1014])
    {'med': 1008, 'max': 1014, 'avg': 1007.0, 'stddev': 5.0, 'min': 1000}
    >>> print stats([1,3,4,5,18,16,4,3,3,5,13])
    {'med': 4, 'max': 18, 'avg': 6.8181818181818183, 'stddev': 5.6216817577237475, 'min': 1}
    >>> print stats([1,3,4,5,18,16,4,3,3,5,13,14,5,6,7,8,7,6,6,7,5,6,4,14,7])
    {'med': 6, 'max': 18, 'avg': 7.0800000000000001, 'stddev': 4.3259218670706474, 'min': 1}
    '''

    total = sum(r)
    avg = float(total)/float(len(r))
    sdsq = sum([(i-avg)**2 for i in r])
    s = sorted(list(r))
    return dict(list(zip(['med', 'avg', 'stddev', 'min', 'max'],
        (s[len(s)//2], avg, (sdsq/len(r))**.5, min(r), max(r)))))

def send_alert (message, subject, addr_from, addr_to, smtp_server='localhost'):

    '''This sends an email alert.
    '''

    message = ( 'From: %s\r\nTo: %s\r\nSubject: %s\r\n\r\n'
            % (addr_from, addr_to, subject) + message )
    server = smtplib.SMTP(smtp_server)
    server.sendmail(addr_from, addr_to, message)
    server.quit()

def main():

    # Parse the options, arguments, etc.
    try:
        optlist, args = getopt.getopt(sys.argv[1:],
                'h?valqs:u:p:n:', ['help','h','?','ipv6','stddev='])
    except Exception as e:
        print(str(e))
        exit_with_usage()
    options = dict(optlist)

    munin_flag = False
    if len(args) > 0:
        if args[0] == 'config':
            print('graph_title Netstat Connections per IP')
            print('graph_vlabel Socket connections per IP')
            print('connections_max.label max')
            print('connections_max.info Maximum number of connections per IP')
            print('connections_avg.label avg')
            print('connections_avg.info Average number of connections per IP')
            print('connections_stddev.label stddev')
            print('connections_stddev.info Standard deviation')
            return 0
        elif args[0] != '':
            print(args, len(args))
            return 0
            exit_with_usage()
    if [elem for elem in options if elem in ['-h','--h','-?','--?','--help']]:
        print('Help:')
        exit_with_usage()
    if '-s' in options:
        hostname = options['-s']
    else:
        # if host was not specified then assume localhost munin plugin.
        munin_flag = True
        hostname = 'localhost'
    # If localhost then don't ask for username/password.
    if hostname != 'localhost' and hostname != '127.0.0.1':
        if '-u' in options:
            username = options['-u']
        else:
            username = raw_input('username: ')
        if '-p' in options:
            password = options['-p']
        else:
            password = getpass.getpass('password: ')
        use_localhost = False
    else:
        use_localhost = True

    if '-l' in options:
        log_flag = True
    else:
        log_flag = False
    if '-n' in options:
        average_n = int(options['-n'])
    else:
        average_n = None
    if '-v' in options:
        verbose = True
    else:
        verbose = False
    if '-a' in options:
        alert_flag = True
        (alert_addr_from, alert_addr_to) = tuple(options['-a'].split(','))
    else:
        alert_flag = False
    if '--ipv6' in options:
        ipv6_flag = True
    else:
        ipv6_flag = False
    if '--stddev' in options:
        stddev_trigger = float(options['--stddev'])
    else:
        stddev_trigger = 5

    if ipv6_flag:
        netstat_pattern = '(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+::ffff:(\S+):(\S+)\s+.*?\r'
    else:
        netstat_pattern = '(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(?:::ffff:)*(\S+):(\S+)\s+.*?\r'
        #netstat_pattern = '(\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+):(\S+)\s+.*?\r'

    # run netstat (either locally or via SSH).
    if use_localhost:
        p = pexpect.spawn('netstat -n -t')
        PROMPT = pexpect.TIMEOUT
    else:
        p = pxssh.pxssh()
        p.login(hostname, username, password)
        p.sendline('netstat -n -t')
        PROMPT = p.PROMPT

    # For each matching netstat_pattern put the ip address in the list.
    ip_list = {}
    try:
        while 1:
            i = p.expect([PROMPT, netstat_pattern])
            if i == 0:
                break
            k = p.match.groups()[4].decode('utf-8')
            if k in ip_list:
                ip_list[k] = ip_list[k] + 1
            else:
                ip_list[k] = 1
    except:
        pass

    # remove a few common, uninteresting addresses from the dictionary.
    ip_list = dict([ (key,value) for key,value in ip_list.items() if '192.168.' not in key])
    ip_list = dict([ (key,value) for key,value in ip_list.items() if '127.0.0.1' not in key])

    ip_list = list(ip_list.items())
    if len(ip_list) < 1:
        if verbose: print('Warning: no networks connections worth looking at.')
        return 0
    ip_list.sort(key=lambda x:x[1])

    # generate some stats for the ip addresses found.
    if average_n is not None and average_n <= 1:
        average_n = None
    # Reminder: the * unary operator treats the list elements as arguments.
    zipped = zip(*ip_list[0:average_n])
    s = stats(list(zipped)[1])
    s['maxip'] = ip_list[0]

    # print munin-style or verbose results for the stats.
    if munin_flag:
        print('connections_max.value', s['max'])
        print('connections_avg.value', s['avg'])
        print('connections_stddev.value', s['stddev'])
        return 0
    if verbose:
        pprint (s)
        print()
        pprint (ip_list[0:average_n])

    # load the stats from the last run.
    try:
        last_stats = pickle.load(file(TOPIP_LAST_RUN_STATS))
    except:
        last_stats = {'maxip':None}

    if ( s['maxip'][1] > (s['stddev'] * stddev_trigger)
            and s['maxip']==last_stats['maxip'] ):
        if verbose: print('The maxip has been above trigger for two consecutive samples.')
        if alert_flag:
            if verbose: print('SENDING ALERT EMAIL')
            send_alert(str(s), 'ALERT on %s'
                    % hostname, alert_addr_from, alert_addr_to)
        if log_flag:
            if verbose: print('LOGGING THIS EVENT')
            fout = file(TOPIP_LOG_FILE,'a')
            #dts = time.strftime('%Y:%m:%d:%H:%M:%S', time.localtime())
            dts = time.asctime()
            fout.write ('%s - %d connections from %s\n'
                    % (dts,s['maxip'][1],str(s['maxip'][0])))
            fout.close()

    # save state to TOPIP_LAST_RUN_STATS
    try:
        pickle.dump(s, file(TOPIP_LAST_RUN_STATS,'w'))
        os.chmod (TOPIP_LAST_RUN_STATS, 0o664)
    except:
        pass
    # p.logout()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = uptime
#!/usr/bin/env python

'''This displays uptime information using uptime. This is redundant,
but it demonstrates expecting for a regular expression that uses subgroups.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from __future__ import absolute_import
from __future__ import print_function
from __future__ import unicode_literals

import pexpect
import re

# There are many different styles of uptime results. I try to parse them all. Yeee!
# Examples from different machines:
# [x86] Linux 2.4 (Redhat 7.3)
#  2:06pm  up 63 days, 18 min,  3 users,  load average: 0.32, 0.08, 0.02
# [x86] Linux 2.4.18-14 (Redhat 8.0)
#  3:07pm  up 29 min,  1 user,  load average: 2.44, 2.51, 1.57
# [PPC - G4] MacOS X 10.1 SERVER Edition
# 2:11PM  up 3 days, 13:50, 3 users, load averages: 0.01, 0.00, 0.00
# [powerpc] Darwin v1-58.corefa.com 8.2.0 Darwin Kernel Version 8.2.0
# 10:35  up 18:06, 4 users, load averages: 0.52 0.47 0.36
# [Sparc - R220] Sun Solaris (8)
#  2:13pm  up 22 min(s),  1 user,  load average: 0.02, 0.01, 0.01
# [x86] Linux 2.4.18-14 (Redhat 8)
# 11:36pm  up 4 days, 17:58,  1 user,  load average: 0.03, 0.01, 0.00
# AIX jwdir 2 5 0001DBFA4C00
#  09:43AM   up  23:27,  1 user,  load average: 0.49, 0.32, 0.23
# OpenBSD box3 2.9 GENERIC#653 i386
#  6:08PM  up 4 days, 22:26, 1 user, load averages: 0.13, 0.09, 0.08

# Note that, for Python 3 compatibility reasons, we are using spawnu and
# importing unicode_literals (above). spawnu accepts Unicode input and
# unicode_literals makes all string literals in this script Unicode by default.
p = pexpect.spawnu('uptime')

# This parses uptime output into the major groups using regex group matching.
p.expect('up\s+(.*?),\s+([0-9]+) users?,\s+load averages?: ([0-9]+\.[0-9][0-9]),?\s+([0-9]+\.[0-9][0-9]),?\s+([0-9]+\.[0-9][0-9])')
duration, users, av1, av5, av15 = p.match.groups()

# The duration is a little harder to parse because of all the different
# styles of uptime. I'm sure there is a way to do this all at once with
# one single regex, but I bet it would be hard to read and maintain.
# If anyone wants to send me a version using a single regex I'd be happy to see it.
days = '0'
hours = '0'
mins = '0'
if 'day' in duration:
    p.match = re.search('([0-9]+)\s+day',duration)
    days = str(int(p.match.group(1)))
if ':' in duration:
    p.match = re.search('([0-9]+):([0-9]+)',duration)
    hours = str(int(p.match.group(1)))
    mins = str(int(p.match.group(2)))
if 'min' in duration:
    p.match = re.search('([0-9]+)\s+min',duration)
    mins = str(int(p.match.group(1)))

# Print the parsed fields in CSV format.
print('days, hours, minutes, users, cpu avg 1 min, cpu avg 5 min, cpu avg 15 min')
print('%s, %s, %s, %s, %s, %s, %s' % (days, hours, mins, users, av1, av5, av15))


########NEW FILE########
__FILENAME__ = fdpexpect
import warnings

warnings.warn("This module has been moved to pexpect.fdpexpect, please update imports.",
                ImportWarning)
del warnings

from pexpect.fdpexpect import *  # analysis:ignore
########NEW FILE########
__FILENAME__ = FSM
import warnings

warnings.warn("This module has been moved to pexpect.FSM, please update imports.",
                ImportWarning)
del warnings

from pexpect.FSM import *  # analysis:ignore
########NEW FILE########
__FILENAME__ = my_forkpty
import os, fcntl, termios
import time

def my_forkpty():

    (master_fd, slave_fd) = os.openpty()

    if (master_fd < 0  or  slave_fd < 0):
        raise ExceptionPexpect("Forkpty failed")

    # slave_name = ptsname(master_fd);

    pid = os.fork();
    if pid == -1:
        raise ExceptionPexpect("Forkpty failed")
    elif pid == 0: # Child
        if hasattr(termios, 'TIOCNOTTY'):
        #        Some platforms require an explicit detach of the
        #        current controlling tty before closing stdin, stdout, stderr.
        #        OpenBSD says that this is obsolete, but doesn't hurt.
            try:
                fd = os.open("/dev/tty", os.O_RDWR | os.O_NOCTTY)
            except:
                pass
            else: #if fd >= 0:
                fcntl.ioctl(fd, termios.TIOCNOTTY, 0)
                os.close(fd)

        # The setsid() system call will place the process into its own session
        # which has the effect of disassociating it from the controlling terminal.
        # This is known to be true for OpenBSD.
        os.setsid()
        # except:            return posix_error();

        # Verify that we are disconnected from the controlling tty.
        try:
            fd = os.open("/dev/tty", os.O_RDWR | os.O_NOCTTY)
            os.close(fd)
            raise ExceptionPexpect("Forkpty failed")
        except:
            pass
        if 'TIOCSCTTY' in dir(termios):
            # Make the pseudo terminal the controlling terminal for this process
            # (the process must not currently have a controlling terminal).
            if fcntl.ioctl(slave_fd, termios.TIOCSCTTY, '') < 0:
                raise ExceptionPexpect("Forkpty failed")

#        # Verify that we can open to the slave pty file. */
#        fd = os.open(slave_name, os.O_RDWR);
#        if fd < 0:
#            raise ExceptionPexpect("Forkpty failed")
#        else:
#            os.close(fd);

        # Verify that we now have a controlling tty.
        fd = os.open("/dev/tty", os.O_WRONLY)
        if fd < 0:
            raise ExceptionPexpect("This process could not get a controlling tty.")
        else:
            os.close(fd)

        os.close(master_fd)
        os.dup2(slave_fd, 0)
        os.dup2(slave_fd, 1)
        os.dup2(slave_fd, 2)
        if slave_fd > 2:
            os.close(slave_fd)
        pid = 0

    else:
        # PARENT 
        os.close(slave_fd);

    if pid == -1:
        raise ExceptionPexpect("This process could not get a controlling tty.")
#    if (pid == 0)
#        PyOS_AfterFork();

    return (pid, master_fd)

pid, fd = my_forkpty ()
if pid == 0: # child
    print 'I am not a robot!'
else:
    print '(pid, fd) = (%d, %d)' % (pid, fd)
    time.sleep(1) # Give the child a chance to print.
    print 'Robots always say:', os.read(fd,100)
    os.close(fd)


########NEW FILE########
__FILENAME__ = ANSI
'''This implements an ANSI (VT100) terminal emulator as a subclass of screen.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

# references:
#     http://en.wikipedia.org/wiki/ANSI_escape_code
#     http://www.retards.org/terminals/vt102.html
#     http://vt100.net/docs/vt102-ug/contents.html
#     http://vt100.net/docs/vt220-rm/
#     http://www.termsys.demon.co.uk/vtansi.htm

from . import screen
from . import FSM
import string

#
# The 'Do.*' functions are helper functions for the ANSI class.
#
def DoEmit (fsm):

    screen = fsm.memory[0]
    screen.write_ch(fsm.input_symbol)

def DoStartNumber (fsm):

    fsm.memory.append (fsm.input_symbol)

def DoBuildNumber (fsm):

    ns = fsm.memory.pop()
    ns = ns + fsm.input_symbol
    fsm.memory.append (ns)

def DoBackOne (fsm):

    screen = fsm.memory[0]
    screen.cursor_back ()

def DoBack (fsm):

    count = int(fsm.memory.pop())
    screen = fsm.memory[0]
    screen.cursor_back (count)

def DoDownOne (fsm):

    screen = fsm.memory[0]
    screen.cursor_down ()

def DoDown (fsm):

    count = int(fsm.memory.pop())
    screen = fsm.memory[0]
    screen.cursor_down (count)

def DoForwardOne (fsm):

    screen = fsm.memory[0]
    screen.cursor_forward ()

def DoForward (fsm):

    count = int(fsm.memory.pop())
    screen = fsm.memory[0]
    screen.cursor_forward (count)

def DoUpReverse (fsm):

    screen = fsm.memory[0]
    screen.cursor_up_reverse()

def DoUpOne (fsm):

    screen = fsm.memory[0]
    screen.cursor_up ()

def DoUp (fsm):

    count = int(fsm.memory.pop())
    screen = fsm.memory[0]
    screen.cursor_up (count)

def DoHome (fsm):

    c = int(fsm.memory.pop())
    r = int(fsm.memory.pop())
    screen = fsm.memory[0]
    screen.cursor_home (r,c)

def DoHomeOrigin (fsm):

    c = 1
    r = 1
    screen = fsm.memory[0]
    screen.cursor_home (r,c)

def DoEraseDown (fsm):

    screen = fsm.memory[0]
    screen.erase_down()

def DoErase (fsm):

    arg = int(fsm.memory.pop())
    screen = fsm.memory[0]
    if arg == 0:
        screen.erase_down()
    elif arg == 1:
        screen.erase_up()
    elif arg == 2:
        screen.erase_screen()

def DoEraseEndOfLine (fsm):

    screen = fsm.memory[0]
    screen.erase_end_of_line()

def DoEraseLine (fsm):

    arg = int(fsm.memory.pop())
    screen = fsm.memory[0]
    if arg == 0:
        screen.erase_end_of_line()
    elif arg == 1:
        screen.erase_start_of_line()
    elif arg == 2:
        screen.erase_line()

def DoEnableScroll (fsm):

    screen = fsm.memory[0]
    screen.scroll_screen()

def DoCursorSave (fsm):

    screen = fsm.memory[0]
    screen.cursor_save_attrs()

def DoCursorRestore (fsm):

    screen = fsm.memory[0]
    screen.cursor_restore_attrs()

def DoScrollRegion (fsm):

    screen = fsm.memory[0]
    r2 = int(fsm.memory.pop())
    r1 = int(fsm.memory.pop())
    screen.scroll_screen_rows (r1,r2)

def DoMode (fsm):

    screen = fsm.memory[0]
    mode = fsm.memory.pop() # Should be 4
    # screen.setReplaceMode ()

def DoLog (fsm):

    screen = fsm.memory[0]
    fsm.memory = [screen]
    fout = open ('log', 'a')
    fout.write (fsm.input_symbol + ',' + fsm.current_state + '\n')
    fout.close()

class term (screen.screen):

    '''This class is an abstract, generic terminal.
    This does nothing. This is a placeholder that
    provides a common base class for other terminals
    such as an ANSI terminal. '''

    def __init__ (self, r=24, c=80):

        screen.screen.__init__(self, r,c)

class ANSI (term):
    '''This class implements an ANSI (VT100) terminal.
    It is a stream filter that recognizes ANSI terminal
    escape sequences and maintains the state of a screen object. '''

    def __init__ (self, r=24,c=80):

        term.__init__(self,r,c)

        #self.screen = screen (24,80)
        self.state = FSM.FSM ('INIT',[self])
        self.state.set_default_transition (DoLog, 'INIT')
        self.state.add_transition_any ('INIT', DoEmit, 'INIT')
        self.state.add_transition ('\x1b', 'INIT', None, 'ESC')
        self.state.add_transition_any ('ESC', DoLog, 'INIT')
        self.state.add_transition ('(', 'ESC', None, 'G0SCS')
        self.state.add_transition (')', 'ESC', None, 'G1SCS')
        self.state.add_transition_list ('AB012', 'G0SCS', None, 'INIT')
        self.state.add_transition_list ('AB012', 'G1SCS', None, 'INIT')
        self.state.add_transition ('7', 'ESC', DoCursorSave, 'INIT')
        self.state.add_transition ('8', 'ESC', DoCursorRestore, 'INIT')
        self.state.add_transition ('M', 'ESC', DoUpReverse, 'INIT')
        self.state.add_transition ('>', 'ESC', DoUpReverse, 'INIT')
        self.state.add_transition ('<', 'ESC', DoUpReverse, 'INIT')
        self.state.add_transition ('=', 'ESC', None, 'INIT') # Selects application keypad.
        self.state.add_transition ('#', 'ESC', None, 'GRAPHICS_POUND')
        self.state.add_transition_any ('GRAPHICS_POUND', None, 'INIT')
        self.state.add_transition ('[', 'ESC', None, 'ELB')
        # ELB means Escape Left Bracket. That is ^[[
        self.state.add_transition ('H', 'ELB', DoHomeOrigin, 'INIT')
        self.state.add_transition ('D', 'ELB', DoBackOne, 'INIT')
        self.state.add_transition ('B', 'ELB', DoDownOne, 'INIT')
        self.state.add_transition ('C', 'ELB', DoForwardOne, 'INIT')
        self.state.add_transition ('A', 'ELB', DoUpOne, 'INIT')
        self.state.add_transition ('J', 'ELB', DoEraseDown, 'INIT')
        self.state.add_transition ('K', 'ELB', DoEraseEndOfLine, 'INIT')
        self.state.add_transition ('r', 'ELB', DoEnableScroll, 'INIT')
        self.state.add_transition ('m', 'ELB', None, 'INIT')
        self.state.add_transition ('?', 'ELB', None, 'MODECRAP')
        self.state.add_transition_list (string.digits, 'ELB', DoStartNumber, 'NUMBER_1')
        self.state.add_transition_list (string.digits, 'NUMBER_1', DoBuildNumber, 'NUMBER_1')
        self.state.add_transition ('D', 'NUMBER_1', DoBack, 'INIT')
        self.state.add_transition ('B', 'NUMBER_1', DoDown, 'INIT')
        self.state.add_transition ('C', 'NUMBER_1', DoForward, 'INIT')
        self.state.add_transition ('A', 'NUMBER_1', DoUp, 'INIT')
        self.state.add_transition ('J', 'NUMBER_1', DoErase, 'INIT')
        self.state.add_transition ('K', 'NUMBER_1', DoEraseLine, 'INIT')
        self.state.add_transition ('l', 'NUMBER_1', DoMode, 'INIT')
        ### It gets worse... the 'm' code can have infinite number of
        ### number;number;number before it. I've never seen more than two,
        ### but the specs say it's allowed. crap!
        self.state.add_transition ('m', 'NUMBER_1', None, 'INIT')
        ### LED control. Same implementation problem as 'm' code.
        self.state.add_transition ('q', 'NUMBER_1', None, 'INIT')

        # \E[?47h switch to alternate screen
        # \E[?47l restores to normal screen from alternate screen.
        self.state.add_transition_list (string.digits, 'MODECRAP', DoStartNumber, 'MODECRAP_NUM')
        self.state.add_transition_list (string.digits, 'MODECRAP_NUM', DoBuildNumber, 'MODECRAP_NUM')
        self.state.add_transition ('l', 'MODECRAP_NUM', None, 'INIT')
        self.state.add_transition ('h', 'MODECRAP_NUM', None, 'INIT')

#RM   Reset Mode                Esc [ Ps l                   none
        self.state.add_transition (';', 'NUMBER_1', None, 'SEMICOLON')
        self.state.add_transition_any ('SEMICOLON', DoLog, 'INIT')
        self.state.add_transition_list (string.digits, 'SEMICOLON', DoStartNumber, 'NUMBER_2')
        self.state.add_transition_list (string.digits, 'NUMBER_2', DoBuildNumber, 'NUMBER_2')
        self.state.add_transition_any ('NUMBER_2', DoLog, 'INIT')
        self.state.add_transition ('H', 'NUMBER_2', DoHome, 'INIT')
        self.state.add_transition ('f', 'NUMBER_2', DoHome, 'INIT')
        self.state.add_transition ('r', 'NUMBER_2', DoScrollRegion, 'INIT')
        ### It gets worse... the 'm' code can have infinite number of
        ### number;number;number before it. I've never seen more than two,
        ### but the specs say it's allowed. crap!
        self.state.add_transition ('m', 'NUMBER_2', None, 'INIT')
        ### LED control. Same problem as 'm' code.
        self.state.add_transition ('q', 'NUMBER_2', None, 'INIT')
        self.state.add_transition (';', 'NUMBER_2', None, 'SEMICOLON_X')

        # Create a state for 'q' and 'm' which allows an infinite number of ignored numbers
        self.state.add_transition_any ('SEMICOLON_X', DoLog, 'INIT')
        self.state.add_transition_list (string.digits, 'SEMICOLON_X', None, 'NUMBER_X')
        self.state.add_transition_any ('NUMBER_X', DoLog, 'INIT')
        self.state.add_transition ('m', 'NUMBER_X', None, 'INIT')
        self.state.add_transition ('q', 'NUMBER_X', None, 'INIT')
        self.state.add_transition (';', 'NUMBER_2', None, 'SEMICOLON_X')

    def process (self, c):
        """Process a single byte. Called by :meth:`write`."""
        self.state.process(c)

    def process_list (self, l):

        self.write(l)

    def write (self, s):
        """Process text, writing it to the virtual screen while handling
        ANSI escape codes.
        """
        for c in s:
            self.process(c)

    def flush (self):
        pass

    def write_ch (self, ch):
        '''This puts a character at the current cursor position. The cursor
        position is moved forward with wrap-around, but no scrolling is done if
        the cursor hits the lower-right corner of the screen. '''

        #\r and \n both produce a call to cr() and lf(), respectively.
        ch = ch[0]

        if ch == '\r':
            self.cr()
            return
        if ch == '\n':
            self.crlf()
            return
        if ch == chr(screen.BS):
            self.cursor_back()
            return
        if ch not in string.printable:
            fout = open ('log', 'a')
            fout.write ('Nonprint: ' + str(ord(ch)) + '\n')
            fout.close()
            return
        self.put_abs(self.cur_r, self.cur_c, ch)
        old_r = self.cur_r
        old_c = self.cur_c
        self.cursor_forward()
        if old_c == self.cur_c:
            self.cursor_down()
            if old_r != self.cur_r:
                self.cursor_home (self.cur_r, 1)
            else:
                self.scroll_up ()
                self.cursor_home (self.cur_r, 1)
                self.erase_line()

########NEW FILE########
__FILENAME__ = fdpexpect
'''This is like pexpect, but it will work with any file descriptor that you
pass it. You are reponsible for opening and close the file descriptor.
This allows you to use Pexpect with sockets and named pipes (FIFOs).

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from pexpect import spawn, ExceptionPexpect
import os

__all__ = ['fdspawn']

class fdspawn (spawn):

    '''This is like pexpect.spawn but allows you to supply your own open file
    descriptor. For example, you could use it to read through a file looking
    for patterns, or to control a modem or serial device. '''

    def __init__ (self, fd, args=[], timeout=30, maxread=2000, searchwindowsize=None, logfile=None):

        '''This takes a file descriptor (an int) or an object that support the
        fileno() method (returning an int). All Python file-like objects
        support fileno(). '''

        ### TODO: Add better handling of trying to use fdspawn in place of spawn
        ### TODO: (overload to allow fdspawn to also handle commands as spawn does.

        if type(fd) != type(0) and hasattr(fd, 'fileno'):
            fd = fd.fileno()

        if type(fd) != type(0):
            raise ExceptionPexpect('The fd argument is not an int. If this is a command string then maybe you want to use pexpect.spawn.')

        try: # make sure fd is a valid file descriptor
            os.fstat(fd)
        except OSError:
            raise ExceptionPexpect('The fd argument is not a valid file descriptor.')

        self.args = None
        self.command = None
        spawn.__init__(self, None, args, timeout, maxread, searchwindowsize, logfile)
        self.child_fd = fd
        self.own_fd = False
        self.closed = False
        self.name = '<file descriptor %d>' % fd

    def __del__ (self):
        return

    def close (self):
        """Close the file descriptor.

        Calling this method a second time does nothing, but if the file
        descriptor was closed elsewhere, :class:`OSError` will be raised.
        """
        if self.child_fd == -1:
            return

        self.flush()
        os.close(self.child_fd)
        self.child_fd = -1
        self.closed = True

    def isalive (self):
        '''This checks if the file descriptor is still valid. If :func:`os.fstat`
        does not raise an exception then we assume it is alive. '''

        if self.child_fd == -1:
            return False
        try:
            os.fstat(self.child_fd)
            return True
        except:
            return False

    def terminate (self, force=False):
        raise ExceptionPexpect('This method is not valid for file descriptors.')

    def kill (self, sig):
        """No-op - no process to kill."""
        return

########NEW FILE########
__FILENAME__ = FSM
#!/usr/bin/env python

'''This module implements a Finite State Machine (FSM). In addition to state
this FSM also maintains a user defined "memory". So this FSM can be used as a
Push-down Automata (PDA) since a PDA is a FSM + memory.

The following describes how the FSM works, but you will probably also need to
see the example function to understand how the FSM is used in practice.

You define an FSM by building tables of transitions. For a given input symbol
the process() method uses these tables to decide what action to call and what
the next state will be. The FSM has a table of transitions that associate:

        (input_symbol, current_state) --> (action, next_state)

Where "action" is a function you define. The symbols and states can be any
objects. You use the add_transition() and add_transition_list() methods to add
to the transition table. The FSM also has a table of transitions that
associate:

        (current_state) --> (action, next_state)

You use the add_transition_any() method to add to this transition table. The
FSM also has one default transition that is not associated with any specific
input_symbol or state. You use the set_default_transition() method to set the
default transition.

When an action function is called it is passed a reference to the FSM. The
action function may then access attributes of the FSM such as input_symbol,
current_state, or "memory". The "memory" attribute can be any object that you
want to pass along to the action functions. It is not used by the FSM itself.
For parsing you would typically pass a list to be used as a stack.

The processing sequence is as follows. The process() method is given an
input_symbol to process. The FSM will search the table of transitions that
associate:

        (input_symbol, current_state) --> (action, next_state)

If the pair (input_symbol, current_state) is found then process() will call the
associated action function and then set the current state to the next_state.

If the FSM cannot find a match for (input_symbol, current_state) it will then
search the table of transitions that associate:

        (current_state) --> (action, next_state)

If the current_state is found then the process() method will call the
associated action function and then set the current state to the next_state.
Notice that this table lacks an input_symbol. It lets you define transitions
for a current_state and ANY input_symbol. Hence, it is called the "any" table.
Remember, it is always checked after first searching the table for a specific
(input_symbol, current_state).

For the case where the FSM did not match either of the previous two cases the
FSM will try to use the default transition. If the default transition is
defined then the process() method will call the associated action function and
then set the current state to the next_state. This lets you define a default
transition as a catch-all case. You can think of it as an exception handler.
There can be only one default transition.

Finally, if none of the previous cases are defined for an input_symbol and
current_state then the FSM will raise an exception. This may be desirable, but
you can always prevent this just by defining a default transition.

Noah Spurrier 20020822

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

class ExceptionFSM(Exception):

    '''This is the FSM Exception class.'''

    def __init__(self, value):
        self.value = value

    def __str__(self):
        return 'ExceptionFSM: ' + str(self.value)

class FSM:

    '''This is a Finite State Machine (FSM).
    '''

    def __init__(self, initial_state, memory=None):

        '''This creates the FSM. You set the initial state here. The "memory"
        attribute is any object that you want to pass along to the action
        functions. It is not used by the FSM. For parsing you would typically
        pass a list to be used as a stack. '''

        # Map (input_symbol, current_state) --> (action, next_state).
        self.state_transitions = {}
        # Map (current_state) --> (action, next_state).
        self.state_transitions_any = {}
        self.default_transition = None

        self.input_symbol = None
        self.initial_state = initial_state
        self.current_state = self.initial_state
        self.next_state = None
        self.action = None
        self.memory = memory

    def reset (self):

        '''This sets the current_state to the initial_state and sets
        input_symbol to None. The initial state was set by the constructor
        __init__(). '''

        self.current_state = self.initial_state
        self.input_symbol = None

    def add_transition (self, input_symbol, state, action=None, next_state=None):

        '''This adds a transition that associates:

                (input_symbol, current_state) --> (action, next_state)

        The action may be set to None in which case the process() method will
        ignore the action and only set the next_state. The next_state may be
        set to None in which case the current state will be unchanged.

        You can also set transitions for a list of symbols by using
        add_transition_list(). '''

        if next_state is None:
            next_state = state
        self.state_transitions[(input_symbol, state)] = (action, next_state)

    def add_transition_list (self, list_input_symbols, state, action=None, next_state=None):

        '''This adds the same transition for a list of input symbols.
        You can pass a list or a string. Note that it is handy to use
        string.digits, string.whitespace, string.letters, etc. to add
        transitions that match character classes.

        The action may be set to None in which case the process() method will
        ignore the action and only set the next_state. The next_state may be
        set to None in which case the current state will be unchanged. '''

        if next_state is None:
            next_state = state
        for input_symbol in list_input_symbols:
            self.add_transition (input_symbol, state, action, next_state)

    def add_transition_any (self, state, action=None, next_state=None):

        '''This adds a transition that associates:

                (current_state) --> (action, next_state)

        That is, any input symbol will match the current state.
        The process() method checks the "any" state associations after it first
        checks for an exact match of (input_symbol, current_state).

        The action may be set to None in which case the process() method will
        ignore the action and only set the next_state. The next_state may be
        set to None in which case the current state will be unchanged. '''

        if next_state is None:
            next_state = state
        self.state_transitions_any [state] = (action, next_state)

    def set_default_transition (self, action, next_state):

        '''This sets the default transition. This defines an action and
        next_state if the FSM cannot find the input symbol and the current
        state in the transition list and if the FSM cannot find the
        current_state in the transition_any list. This is useful as a final
        fall-through state for catching errors and undefined states.

        The default transition can be removed by setting the attribute
        default_transition to None. '''

        self.default_transition = (action, next_state)

    def get_transition (self, input_symbol, state):

        '''This returns (action, next state) given an input_symbol and state.
        This does not modify the FSM state, so calling this method has no side
        effects. Normally you do not call this method directly. It is called by
        process().

        The sequence of steps to check for a defined transition goes from the
        most specific to the least specific.

        1. Check state_transitions[] that match exactly the tuple,
            (input_symbol, state)

        2. Check state_transitions_any[] that match (state)
            In other words, match a specific state and ANY input_symbol.

        3. Check if the default_transition is defined.
            This catches any input_symbol and any state.
            This is a handler for errors, undefined states, or defaults.

        4. No transition was defined. If we get here then raise an exception.
        '''

        if (input_symbol, state) in self.state_transitions:
            return self.state_transitions[(input_symbol, state)]
        elif state in self.state_transitions_any:
            return self.state_transitions_any[state]
        elif self.default_transition is not None:
            return self.default_transition
        else:
            raise ExceptionFSM ('Transition is undefined: (%s, %s).' %
                (str(input_symbol), str(state)) )

    def process (self, input_symbol):

        '''This is the main method that you call to process input. This may
        cause the FSM to change state and call an action. This method calls
        get_transition() to find the action and next_state associated with the
        input_symbol and current_state. If the action is None then the action
        is not called and only the current state is changed. This method
        processes one complete input symbol. You can process a list of symbols
        (or a string) by calling process_list(). '''

        self.input_symbol = input_symbol
        (self.action, self.next_state) = self.get_transition (self.input_symbol, self.current_state)
        if self.action is not None:
            self.action (self)
        self.current_state = self.next_state
        self.next_state = None

    def process_list (self, input_symbols):

        '''This takes a list and sends each element to process(). The list may
        be a string or any iterable object. '''

        for s in input_symbols:
            self.process (s)

##############################################################################
# The following is an example that demonstrates the use of the FSM class to
# process an RPN expression. Run this module from the command line. You will
# get a prompt > for input. Enter an RPN Expression. Numbers may be integers.
# Operators are * / + - Use the = sign to evaluate and print the expression.
# For example:
#
#    167 3 2 2 * * * 1 - =
#
# will print:
#
#    2003
##############################################################################

import sys
import string

PY3 = (sys.version_info[0] >= 3)

#
# These define the actions.
# Note that "memory" is a list being used as a stack.
#

def BeginBuildNumber (fsm):
    fsm.memory.append (fsm.input_symbol)

def BuildNumber (fsm):
    s = fsm.memory.pop ()
    s = s + fsm.input_symbol
    fsm.memory.append (s)

def EndBuildNumber (fsm):
    s = fsm.memory.pop ()
    fsm.memory.append (int(s))

def DoOperator (fsm):
    ar = fsm.memory.pop()
    al = fsm.memory.pop()
    if fsm.input_symbol == '+':
        fsm.memory.append (al + ar)
    elif fsm.input_symbol == '-':
        fsm.memory.append (al - ar)
    elif fsm.input_symbol == '*':
        fsm.memory.append (al * ar)
    elif fsm.input_symbol == '/':
        fsm.memory.append (al / ar)

def DoEqual (fsm):
    print(str(fsm.memory.pop()))

def Error (fsm):
    print('That does not compute.')
    print(str(fsm.input_symbol))

def main():

    '''This is where the example starts and the FSM state transitions are
    defined. Note that states are strings (such as 'INIT'). This is not
    necessary, but it makes the example easier to read. '''

    f = FSM ('INIT', [])
    f.set_default_transition (Error, 'INIT')
    f.add_transition_any  ('INIT', None, 'INIT')
    f.add_transition      ('=',               'INIT',            DoEqual,          'INIT')
    f.add_transition_list (string.digits,     'INIT',            BeginBuildNumber, 'BUILDING_NUMBER')
    f.add_transition_list (string.digits,     'BUILDING_NUMBER', BuildNumber,      'BUILDING_NUMBER')
    f.add_transition_list (string.whitespace, 'BUILDING_NUMBER', EndBuildNumber,   'INIT')
    f.add_transition_list ('+-*/',            'INIT',            DoOperator,       'INIT')

    print()
    print('Enter an RPN Expression.')
    print('Numbers may be integers. Operators are * / + -')
    print('Use the = sign to evaluate and print the expression.')
    print('For example: ')
    print('    167 3 2 2 * * * 1 - =')
    inputstr = (input if PY3 else raw_input)('> ')  # analysis:ignore
    f.process_list(inputstr)


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = psh
'''This is a utility class to make shell scripting easier in Python.
It combines Pexpect and wraps many Standard Python Library functions
to make them look more shell-like.

This module is undocumented, so its API is provisional, and may change in
future releases without a deprecation cycle.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

import pexpect, re

class ExceptionPsh(pexpect.ExceptionPexpect):
    '''Raised for Psh exceptions.
    '''

class ExceptionErrorCode(ExceptionPsh):
    '''Raised when an program returns an error code.
    '''

    def __init__(self, string, err_code, cmd_output):

        ExceptionPsh.__init__(self,string)
        self.error  = err_code
        self.output = cmd_output

class psh (object):

    def __init__ (self,exp):

        self.exp = exp
        self.default_timeout = 30 # Seconds

    def ls (self, path=''):

        fileStr = self.run("ls %s" % path)
        return fileStr.split()

    def cd (self, path='-'):

        return self.run("cd %s" % path)

    def rm (self, path=''):

        return self.run("/bin/rm -f %s" % path)

    def cp (self, path_from='', path_to=''):

        return self.run("/bin/cp %s %s" % (path_from, path_to))

    def mv (self, path_from='', path_to=''):

        return self.run("/bin/mv %s %s" % (path_from, path_to))

    def pwd (self):

        return self.run("/bin/pwd")

    def which (self, exe_name):

        return self.run("/usr/bin/which %s" % exe_name)

    def chown (self, path, user='', group=None, recurse=False):

        xtra_flags = ""
        if recurse: xtra_flags = "-R"
        if group: group = ':' + group
        else: group = ""

        return self.run("/bin/chown %s %s%s %s" % (xtra_flags,user,group,path))

    def chmod (self, path, perms='', recurse=False):

        xtra_flags = ""
        if recurse: xtra_flags = "-R"
        return self.run("/usr/bin/chmod %s %s %s" % (xtra_flags, perms, path))

    def chattr (self, path, attrs='', recurse=False):

        xtra_flags = ""
        if recurse: xtra_flags = "-R"
        return self.run("/usr/bin/chattr %s %s %s" % (xtra_flags, attrs, path))

    def cat (self, path):

        return self.run("/bin/cat %s" % path)

    def run (self, cmd, timeout=None):

       (ret, output) = self.run_raw(cmd, timeout)
       if ret == 0: return output
       raise ExceptionErrorCode("Running command [%s] returned error [%d]"
               % (cmd,ret), ret, output)

    def run_raw(self, cmd, timeout=None):

        '''Someone contributed this, but now I've lost touch and I forget the
        motive of this. It was sort of a sketch at the time which doesn't make
        this any easier to prioritize, but it seemed important at the time. '''

        if not timeout: timeout = self.default_timeout

        self.exp.sendline("")
        if not self.exp.prompt(): raise ExceptionPsh("No prompt")
        self.exp.sendline(cmd)
        self.exp.expect_exact([cmd])
        self.exp.prompt(timeout=timeout)

        output = self.exp.before
        # Get the return code
        self.exp.sendline("echo $?")
        self.exp.expect_exact(["echo $?"])
        if not self.exp.prompt():
            raise ExceptionPsh("No prompt", 0, self.exp.before)
        try:
            reg = re.compile(b"^(\d+)")
            s = self.exp.before.strip()
            #print s
            #pdb.set_trace()
            s = reg.search(s).groups()[0]
            error_code = int(s)
        except ValueError:
            #log.error("Cannot parse %s into an int!" % self.exp.before)
            raise

        if not output[0:2] == '\r\n':
            #log.warning("Returned output lacks leading \\r\\n which may indicate a tae error")
            #log.debug2("Offending output string: [%s]" % output)
            return (error_code, output)
        else:
            return(error_code, output[2:])


########NEW FILE########
__FILENAME__ = pxssh
'''This class extends pexpect.spawn to specialize setting up SSH connections.
This adds methods for login, logout, and expecting the shell prompt.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from pexpect import ExceptionPexpect, TIMEOUT, EOF, spawn
import time
import os

__all__ = ['ExceptionPxssh', 'pxssh']

# Exception classes used by this module.
class ExceptionPxssh(ExceptionPexpect):
    '''Raised for pxssh exceptions.
    '''

class pxssh (spawn):
    '''This class extends pexpect.spawn to specialize setting up SSH
    connections. This adds methods for login, logout, and expecting the shell
    prompt. It does various tricky things to handle many situations in the SSH
    login process. For example, if the session is your first login, then pxssh
    automatically accepts the remote certificate; or if you have public key
    authentication setup then pxssh won't wait for the password prompt.

    pxssh uses the shell prompt to synchronize output from the remote host. In
    order to make this more robust it sets the shell prompt to something more
    unique than just $ or #. This should work on most Borne/Bash or Csh style
    shells.

    Example that runs a few commands on a remote server and prints the result::

        import pxssh
        import getpass
        try:
            s = pxssh.pxssh()
            hostname = raw_input('hostname: ')
            username = raw_input('username: ')
            password = getpass.getpass('password: ')
            s.login(hostname, username, password)
            s.sendline('uptime')   # run a command
            s.prompt()             # match the prompt
            print(s.before)        # print everything before the prompt.
            s.sendline('ls -l')
            s.prompt()
            print(s.before)
            s.sendline('df')
            s.prompt()
            print(s.before)
            s.logout()
        except pxssh.ExceptionPxssh as e:
            print("pxssh failed on login.")
            print(e)

    Note that if you have ssh-agent running while doing development with pxssh
    then this can lead to a lot of confusion. Many X display managers (xdm,
    gdm, kdm, etc.) will automatically start a GUI agent. You may see a GUI
    dialog box popup asking for a password during development. You should turn
    off any key agents during testing. The 'force_password' attribute will turn
    off public key authentication. This will only work if the remote SSH server
    is configured to allow password logins. Example of using 'force_password'
    attribute::

            s = pxssh.pxssh()
            s.force_password = True
            hostname = raw_input('hostname: ')
            username = raw_input('username: ')
            password = getpass.getpass('password: ')
            s.login (hostname, username, password)
    '''

    def __init__ (self, timeout=30, maxread=2000, searchwindowsize=None,
                    logfile=None, cwd=None, env=None):

        spawn.__init__(self, None, timeout=timeout, maxread=maxread, searchwindowsize=searchwindowsize, logfile=logfile, cwd=cwd, env=env)

        self.name = '<pxssh>'

        #SUBTLE HACK ALERT! Note that the command that SETS the prompt uses a
        #slightly different string than the regular expression to match it. This
        #is because when you set the prompt the command will echo back, but we
        #don't want to match the echoed command. So if we make the set command
        #slightly different than the regex we eliminate the problem. To make the
        #set command different we add a backslash in front of $. The $ doesn't
        #need to be escaped, but it doesn't hurt and serves to make the set
        #prompt command different than the regex.

        # used to match the command-line prompt
        self.UNIQUE_PROMPT = "\[PEXPECT\][\$\#] "
        self.PROMPT = self.UNIQUE_PROMPT

        # used to set shell command-line prompt to UNIQUE_PROMPT.
        self.PROMPT_SET_SH = "PS1='[PEXPECT]\$ '"
        self.PROMPT_SET_CSH = "set prompt='[PEXPECT]\$ '"
        self.SSH_OPTS = ("-o'RSAAuthentication=no'"
                + " -o 'PubkeyAuthentication=no'")
# Disabling host key checking, makes you vulnerable to MITM attacks.
#                + " -o 'StrictHostKeyChecking=no'"
#                + " -o 'UserKnownHostsFile /dev/null' ")
        # Disabling X11 forwarding gets rid of the annoying SSH_ASKPASS from
        # displaying a GUI password dialog. I have not figured out how to
        # disable only SSH_ASKPASS without also disabling X11 forwarding.
        # Unsetting SSH_ASKPASS on the remote side doesn't disable it! Annoying!
        #self.SSH_OPTS = "-x -o'RSAAuthentication=no' -o 'PubkeyAuthentication=no'"
        self.force_password = False

    def levenshtein_distance(self, a, b):
        '''This calculates the Levenshtein distance between a and b.
        '''

        n, m = len(a), len(b)
        if n > m:
            a,b = b,a
            n,m = m,n
        current = range(n+1)
        for i in range(1,m+1):
            previous, current = current, [i]+[0]*n
            for j in range(1,n+1):
                add, delete = previous[j]+1, current[j-1]+1
                change = previous[j-1]
                if a[j-1] != b[i-1]:
                    change = change + 1
                current[j] = min(add, delete, change)
        return current[n]

    def try_read_prompt(self, timeout_multiplier):
        '''This facilitates using communication timeouts to perform
        synchronization as quickly as possible, while supporting high latency
        connections with a tunable worst case performance. Fast connections
        should be read almost immediately. Worst case performance for this
        method is timeout_multiplier * 3 seconds.
        '''

        # maximum time allowed to read the first response
        first_char_timeout = timeout_multiplier * 0.5

        # maximum time allowed between subsequent characters
        inter_char_timeout = timeout_multiplier * 0.1

        # maximum time for reading the entire prompt
        total_timeout = timeout_multiplier * 3.0

        prompt = b''
        begin = time.time()
        expired = 0.0
        timeout = first_char_timeout

        while expired < total_timeout:
            try:
                prompt += self.read_nonblocking(size=1, timeout=timeout)
                expired = time.time() - begin # updated total time expired
                timeout = inter_char_timeout 
            except TIMEOUT:
                break

        return prompt

    def sync_original_prompt (self, sync_multiplier=1.0):
        '''This attempts to find the prompt. Basically, press enter and record
        the response; press enter again and record the response; if the two
        responses are similar then assume we are at the original prompt.
        This can be a slow function. Worst case with the default sync_multiplier
        can take 12 seconds. Low latency connections are more likely to fail
        with a low sync_multiplier. Best case sync time gets worse with a
        high sync multiplier (500 ms with default). '''

        # All of these timing pace values are magic.
        # I came up with these based on what seemed reliable for
        # connecting to a heavily loaded machine I have.
        self.sendline()
        time.sleep(0.1)

        try:
            # Clear the buffer before getting the prompt.
            self.try_read_prompt(sync_multiplier)
        except TIMEOUT:
            pass

        self.sendline()
        x = self.try_read_prompt(sync_multiplier)

        self.sendline()
        a = self.try_read_prompt(sync_multiplier)

        self.sendline()
        b = self.try_read_prompt(sync_multiplier)

        ld = self.levenshtein_distance(a,b)
        len_a = len(a)
        if len_a == 0:
            return False
        if float(ld)/len_a < 0.4:
            return True
        return False

    ### TODO: This is getting messy and I'm pretty sure this isn't perfect.
    ### TODO: I need to draw a flow chart for this.
    def login (self, server, username, password='', terminal_type='ansi',
                original_prompt=r"[#$]", login_timeout=10, port=None,
                auto_prompt_reset=True, ssh_key=None, quiet=True,
                sync_multiplier=1, check_local_ip=True):
        '''This logs the user into the given server.

        It uses
        'original_prompt' to try to find the prompt right after login. When it
        finds the prompt it immediately tries to reset the prompt to something
        more easily matched. The default 'original_prompt' is very optimistic
        and is easily fooled. It's more reliable to try to match the original
        prompt as exactly as possible to prevent false matches by server
        strings such as the "Message Of The Day". On many systems you can
        disable the MOTD on the remote server by creating a zero-length file
        called :file:`~/.hushlogin` on the remote server. If a prompt cannot be found
        then this will not necessarily cause the login to fail. In the case of
        a timeout when looking for the prompt we assume that the original
        prompt was so weird that we could not match it, so we use a few tricks
        to guess when we have reached the prompt. Then we hope for the best and
        blindly try to reset the prompt to something more unique. If that fails
        then login() raises an :class:`ExceptionPxssh` exception.

        In some situations it is not possible or desirable to reset the
        original prompt. In this case, pass ``auto_prompt_reset=False`` to
        inhibit setting the prompt to the UNIQUE_PROMPT. Remember that pxssh
        uses a unique prompt in the :meth:`prompt` method. If the original prompt is
        not reset then this will disable the :meth:`prompt` method unless you
        manually set the :attr:`PROMPT` attribute.
        '''

        ssh_options = ''
        if quiet:
            ssh_options = ssh_options + ' -q'
        if not check_local_ip:
            ssh_options = ssh_options + " -o'NoHostAuthenticationForLocalhost=yes'"
        if self.force_password:
            ssh_options = ssh_options + ' ' + self.SSH_OPTS
        if port is not None:
            ssh_options = ssh_options + ' -p %s'%(str(port))
        if ssh_key is not None:
            try:
                os.path.isfile(ssh_key)
            except:
                raise ExceptionPxssh('private ssh key does not exist')
            ssh_options = ssh_options + ' -i %s' % (ssh_key)
        cmd = "ssh %s -l %s %s" % (ssh_options, username, server)

        # This does not distinguish between a remote server 'password' prompt
        # and a local ssh 'passphrase' prompt (for unlocking a private key).
        spawn._spawn(self, cmd)
        i = self.expect(["(?i)are you sure you want to continue connecting", original_prompt, "(?i)(?:password)|(?:passphrase for key)", "(?i)permission denied", "(?i)terminal type", TIMEOUT, "(?i)connection closed by remote host"], timeout=login_timeout)

        # First phase
        if i==0:
            # New certificate -- always accept it.
            # This is what you get if SSH does not have the remote host's
            # public key stored in the 'known_hosts' cache.
            self.sendline("yes")
            i = self.expect(["(?i)are you sure you want to continue connecting", original_prompt, "(?i)(?:password)|(?:passphrase for key)", "(?i)permission denied", "(?i)terminal type", TIMEOUT])
        if i==2: # password or passphrase
            self.sendline(password)
            i = self.expect(["(?i)are you sure you want to continue connecting", original_prompt, "(?i)(?:password)|(?:passphrase for key)", "(?i)permission denied", "(?i)terminal type", TIMEOUT])
        if i==4:
            self.sendline(terminal_type)
            i = self.expect(["(?i)are you sure you want to continue connecting", original_prompt, "(?i)(?:password)|(?:passphrase for key)", "(?i)permission denied", "(?i)terminal type", TIMEOUT])

        # Second phase
        if i==0:
            # This is weird. This should not happen twice in a row.
            self.close()
            raise ExceptionPxssh('Weird error. Got "are you sure" prompt twice.')
        elif i==1: # can occur if you have a public key pair set to authenticate.
            ### TODO: May NOT be OK if expect() got tricked and matched a false prompt.
            pass
        elif i==2: # password prompt again
            # For incorrect passwords, some ssh servers will
            # ask for the password again, others return 'denied' right away.
            # If we get the password prompt again then this means
            # we didn't get the password right the first time.
            self.close()
            raise ExceptionPxssh('password refused')
        elif i==3: # permission denied -- password was bad.
            self.close()
            raise ExceptionPxssh('permission denied')
        elif i==4: # terminal type again? WTF?
            self.close()
            raise ExceptionPxssh('Weird error. Got "terminal type" prompt twice.')
        elif i==5: # Timeout
            #This is tricky... I presume that we are at the command-line prompt.
            #It may be that the shell prompt was so weird that we couldn't match
            #it. Or it may be that we couldn't log in for some other reason. I
            #can't be sure, but it's safe to guess that we did login because if
            #I presume wrong and we are not logged in then this should be caught
            #later when I try to set the shell prompt.
            pass
        elif i==6: # Connection closed by remote host
            self.close()
            raise ExceptionPxssh('connection closed')
        else: # Unexpected
            self.close()
            raise ExceptionPxssh('unexpected login response')
        if not self.sync_original_prompt(sync_multiplier):
            self.close()
            raise ExceptionPxssh('could not synchronize with original prompt')
        # We appear to be in.
        # set shell prompt to something unique.
        if auto_prompt_reset:
            if not self.set_unique_prompt():
                self.close()
                raise ExceptionPxssh('could not set shell prompt '
                                     '(recieved: %r, expected: %r).' % (
                                         self.before, self.PROMPT,))
        return True

    def logout (self):
        '''Sends exit to the remote shell.

        If there are stopped jobs then this automatically sends exit twice.
        '''
        self.sendline("exit")
        index = self.expect([EOF, "(?i)there are stopped jobs"])
        if index==1:
            self.sendline("exit")
            self.expect(EOF)
        self.close()

    def prompt(self, timeout=-1):
        '''Match the next shell prompt.

        This is little more than a short-cut to the :meth:`~pexpect.spawn.expect`
        method. Note that if you called :meth:`login` with
        ``auto_prompt_reset=False``, then before calling :meth:`prompt` you must
        set the :attr:`PROMPT` attribute to a regex that it will use for
        matching the prompt.

        Calling :meth:`prompt` will erase the contents of the :attr:`before`
        attribute even if no prompt is ever matched. If timeout is not given or
        it is set to -1 then self.timeout is used.

        :return: True if the shell prompt was matched, False if the timeout was
                 reached.
        '''

        if timeout == -1:
            timeout = self.timeout
        i = self.expect([self.PROMPT, TIMEOUT], timeout=timeout)
        if i==1:
            return False
        return True

    def set_unique_prompt(self):
        '''This sets the remote prompt to something more unique than ``#`` or ``$``.
        This makes it easier for the :meth:`prompt` method to match the shell prompt
        unambiguously. This method is called automatically by the :meth:`login`
        method, but you may want to call it manually if you somehow reset the
        shell prompt. For example, if you 'su' to a different user then you
        will need to manually reset the prompt. This sends shell commands to
        the remote host to set the prompt, so this assumes the remote host is
        ready to receive commands.

        Alternatively, you may use your own prompt pattern. In this case you
        should call :meth:`login` with ``auto_prompt_reset=False``; then set the
        :attr:`PROMPT` attribute to a regular expression. After that, the
        :meth:`prompt` method will try to match your prompt pattern.
        '''

        self.sendline("unset PROMPT_COMMAND")
        self.sendline(self.PROMPT_SET_SH) # sh-style
        i = self.expect ([TIMEOUT, self.PROMPT], timeout=10)
        if i == 0: # csh-style
            self.sendline(self.PROMPT_SET_CSH)
            i = self.expect([TIMEOUT, self.PROMPT], timeout=10)
            if i == 0:
                return False
        return True

# vi:ts=4:sw=4:expandtab:ft=python:

########NEW FILE########
__FILENAME__ = screen
'''This implements a virtual screen. This is used to support ANSI terminal
emulation. The screen representation and state is implemented in this class.
Most of the methods are inspired by ANSI screen control codes. The
:class:`~pexpect.ANSI.ANSI` class extends this class to add parsing of ANSI
escape codes.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

import copy

NUL = 0    # Fill character; ignored on input.
ENQ = 5    # Transmit answerback message.
BEL = 7    # Ring the bell.
BS  = 8    # Move cursor left.
HT  = 9    # Move cursor to next tab stop.
LF = 10    # Line feed.
VT = 11    # Same as LF.
FF = 12    # Same as LF.
CR = 13    # Move cursor to left margin or newline.
SO = 14    # Invoke G1 character set.
SI = 15    # Invoke G0 character set.
XON = 17   # Resume transmission.
XOFF = 19  # Halt transmission.
CAN = 24   # Cancel escape sequence.
SUB = 26   # Same as CAN.
ESC = 27   # Introduce a control sequence.
DEL = 127  # Fill character; ignored on input.
SPACE = chr(32) # Space or blank character.

def constrain (n, min, max):

    '''This returns a number, n constrained to the min and max bounds. '''

    if n < min:
        return min
    if n > max:
        return max
    return n

class screen:
    '''This object maintains the state of a virtual text screen as a
    rectangluar array. This maintains a virtual cursor position and handles
    scrolling as characters are added. This supports most of the methods needed
    by an ANSI text screen. Row and column indexes are 1-based (not zero-based,
    like arrays). '''

    def __init__ (self, r=24,c=80):
        '''This initializes a blank screen of the given dimensions.'''

        self.rows = r
        self.cols = c
        self.cur_r = 1
        self.cur_c = 1
        self.cur_saved_r = 1
        self.cur_saved_c = 1
        self.scroll_row_start = 1
        self.scroll_row_end = self.rows
        self.w = [ [SPACE] * self.cols for c in range(self.rows)]

    def __str__ (self):
        '''This returns a printable representation of the screen. The end of
        each screen line is terminated by a newline. '''

        return '\n'.join ([ ''.join(c) for c in self.w ])

    def dump (self):
        '''This returns a copy of the screen as a string. This is similar to
        __str__ except that lines are not terminated with line feeds. '''

        return ''.join ([ ''.join(c) for c in self.w ])

    def pretty (self):
        '''This returns a copy of the screen as a string with an ASCII text box
        around the screen border. This is similar to __str__ except that it
        adds a box. '''

        top_bot = '+' + '-'*self.cols + '+\n'
        return top_bot + '\n'.join(['|'+line+'|' for line in str(self).split('\n')]) + '\n' + top_bot

    def fill (self, ch=SPACE):

        self.fill_region (1,1,self.rows,self.cols, ch)

    def fill_region (self, rs,cs, re,ce, ch=SPACE):

        rs = constrain (rs, 1, self.rows)
        re = constrain (re, 1, self.rows)
        cs = constrain (cs, 1, self.cols)
        ce = constrain (ce, 1, self.cols)
        if rs > re:
            rs, re = re, rs
        if cs > ce:
            cs, ce = ce, cs
        for r in range (rs, re+1):
            for c in range (cs, ce + 1):
                self.put_abs (r,c,ch)

    def cr (self):
        '''This moves the cursor to the beginning (col 1) of the current row.
        '''

        self.cursor_home (self.cur_r, 1)

    def lf (self):
        '''This moves the cursor down with scrolling.
        '''

        old_r = self.cur_r
        self.cursor_down()
        if old_r == self.cur_r:
            self.scroll_up ()
            self.erase_line()

    def crlf (self):
        '''This advances the cursor with CRLF properties.
        The cursor will line wrap and the screen may scroll.
        '''

        self.cr ()
        self.lf ()

    def newline (self):
        '''This is an alias for crlf().
        '''

        self.crlf()

    def put_abs (self, r, c, ch):
        '''Screen array starts at 1 index.'''

        r = constrain (r, 1, self.rows)
        c = constrain (c, 1, self.cols)
        ch = str(ch)[0]
        self.w[r-1][c-1] = ch

    def put (self, ch):
        '''This puts a characters at the current cursor position.
        '''

        self.put_abs (self.cur_r, self.cur_c, ch)

    def insert_abs (self, r, c, ch):
        '''This inserts a character at (r,c). Everything under
        and to the right is shifted right one character.
        The last character of the line is lost.
        '''

        r = constrain (r, 1, self.rows)
        c = constrain (c, 1, self.cols)
        for ci in range (self.cols, c, -1):
            self.put_abs (r,ci, self.get_abs(r,ci-1))
        self.put_abs (r,c,ch)

    def insert (self, ch):

        self.insert_abs (self.cur_r, self.cur_c, ch)

    def get_abs (self, r, c):

        r = constrain (r, 1, self.rows)
        c = constrain (c, 1, self.cols)
        return self.w[r-1][c-1]

    def get (self):

        self.get_abs (self.cur_r, self.cur_c)

    def get_region (self, rs,cs, re,ce):
        '''This returns a list of lines representing the region.
        '''

        rs = constrain (rs, 1, self.rows)
        re = constrain (re, 1, self.rows)
        cs = constrain (cs, 1, self.cols)
        ce = constrain (ce, 1, self.cols)
        if rs > re:
            rs, re = re, rs
        if cs > ce:
            cs, ce = ce, cs
        sc = []
        for r in range (rs, re+1):
            line = ''
            for c in range (cs, ce + 1):
                ch = self.get_abs (r,c)
                line = line + ch
            sc.append (line)
        return sc

    def cursor_constrain (self):
        '''This keeps the cursor within the screen area.
        '''

        self.cur_r = constrain (self.cur_r, 1, self.rows)
        self.cur_c = constrain (self.cur_c, 1, self.cols)

    def cursor_home (self, r=1, c=1): # <ESC>[{ROW};{COLUMN}H

        self.cur_r = r
        self.cur_c = c
        self.cursor_constrain ()

    def cursor_back (self,count=1): # <ESC>[{COUNT}D (not confused with down)

        self.cur_c = self.cur_c - count
        self.cursor_constrain ()

    def cursor_down (self,count=1): # <ESC>[{COUNT}B (not confused with back)

        self.cur_r = self.cur_r + count
        self.cursor_constrain ()

    def cursor_forward (self,count=1): # <ESC>[{COUNT}C

        self.cur_c = self.cur_c + count
        self.cursor_constrain ()

    def cursor_up (self,count=1): # <ESC>[{COUNT}A

        self.cur_r = self.cur_r - count
        self.cursor_constrain ()

    def cursor_up_reverse (self): # <ESC> M   (called RI -- Reverse Index)

        old_r = self.cur_r
        self.cursor_up()
        if old_r == self.cur_r:
            self.scroll_up()

    def cursor_force_position (self, r, c): # <ESC>[{ROW};{COLUMN}f
        '''Identical to Cursor Home.'''

        self.cursor_home (r, c)

    def cursor_save (self): # <ESC>[s
        '''Save current cursor position.'''

        self.cursor_save_attrs()

    def cursor_unsave (self): # <ESC>[u
        '''Restores cursor position after a Save Cursor.'''

        self.cursor_restore_attrs()

    def cursor_save_attrs (self): # <ESC>7
        '''Save current cursor position.'''

        self.cur_saved_r = self.cur_r
        self.cur_saved_c = self.cur_c

    def cursor_restore_attrs (self): # <ESC>8
        '''Restores cursor position after a Save Cursor.'''

        self.cursor_home (self.cur_saved_r, self.cur_saved_c)

    def scroll_constrain (self):
        '''This keeps the scroll region within the screen region.'''

        if self.scroll_row_start <= 0:
            self.scroll_row_start = 1
        if self.scroll_row_end > self.rows:
            self.scroll_row_end = self.rows

    def scroll_screen (self): # <ESC>[r
        '''Enable scrolling for entire display.'''

        self.scroll_row_start = 1
        self.scroll_row_end = self.rows

    def scroll_screen_rows (self, rs, re): # <ESC>[{start};{end}r
        '''Enable scrolling from row {start} to row {end}.'''

        self.scroll_row_start = rs
        self.scroll_row_end = re
        self.scroll_constrain()

    def scroll_down (self): # <ESC>D
        '''Scroll display down one line.'''

        # Screen is indexed from 1, but arrays are indexed from 0.
        s = self.scroll_row_start - 1
        e = self.scroll_row_end - 1
        self.w[s+1:e+1] = copy.deepcopy(self.w[s:e])

    def scroll_up (self): # <ESC>M
        '''Scroll display up one line.'''

        # Screen is indexed from 1, but arrays are indexed from 0.
        s = self.scroll_row_start - 1
        e = self.scroll_row_end - 1
        self.w[s:e] = copy.deepcopy(self.w[s+1:e+1])

    def erase_end_of_line (self): # <ESC>[0K -or- <ESC>[K
        '''Erases from the current cursor position to the end of the current
        line.'''

        self.fill_region (self.cur_r, self.cur_c, self.cur_r, self.cols)

    def erase_start_of_line (self): # <ESC>[1K
        '''Erases from the current cursor position to the start of the current
        line.'''

        self.fill_region (self.cur_r, 1, self.cur_r, self.cur_c)

    def erase_line (self): # <ESC>[2K
        '''Erases the entire current line.'''

        self.fill_region (self.cur_r, 1, self.cur_r, self.cols)

    def erase_down (self): # <ESC>[0J -or- <ESC>[J
        '''Erases the screen from the current line down to the bottom of the
        screen.'''

        self.erase_end_of_line ()
        self.fill_region (self.cur_r + 1, 1, self.rows, self.cols)

    def erase_up (self): # <ESC>[1J
        '''Erases the screen from the current line up to the top of the
        screen.'''

        self.erase_start_of_line ()
        self.fill_region (self.cur_r-1, 1, 1, self.cols)

    def erase_screen (self): # <ESC>[2J
        '''Erases the screen with the background color.'''

        self.fill ()

    def set_tab (self): # <ESC>H
        '''Sets a tab at the current position.'''

        pass

    def clear_tab (self): # <ESC>[g
        '''Clears tab at the current position.'''

        pass

    def clear_all_tabs (self): # <ESC>[3g
        '''Clears all tabs.'''

        pass

#        Insert line             Esc [ Pn L
#        Delete line             Esc [ Pn M
#        Delete character        Esc [ Pn P
#        Scrolling region        Esc [ Pn(top);Pn(bot) r


########NEW FILE########
__FILENAME__ = pxssh
import warnings

warnings.warn("This module has been moved to pexpect.pxssh, please update imports.",
                ImportWarning)
del warnings

from pexpect.pxssh import *  # analysis:ignore
########NEW FILE########
__FILENAME__ = screen
import warnings

warnings.warn("This module has been moved to pexpect.screen, please update imports.",
                ImportWarning)
del warnings

from pexpect.screen import *  # analysis:ignore
########NEW FILE########
__FILENAME__ = adhoc
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
from  __future__ import print_function

import pexpect
import time

p = pexpect.spawn ('./a.out')
print(p.exitstatus)
p.expect (pexpect.EOF)
print(p.before)
time.sleep(1)
print('exitstatus:', p.exitstatus)
print('isalive',p.isalive())
print('exitstatus',p.exitstatus)
print('isalive',p.isalive())
print('exitstatus',p.exitstatus)


########NEW FILE########
__FILENAME__ = alarm_die
import signal, time

signal.alarm(1) # Schedule SIGALRM in 1s

time.sleep(6)
########NEW FILE########
__FILENAME__ = depricated_test_filedescriptor
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import unittest
import PexpectTestCase
import sys
import os

class ExpectTestCase(PexpectTestCase.PexpectTestCase):
    def setUp(self):
        print(self.id())
        PexpectTestCase.PexpectTestCase.setUp(self)

    def test_fd (self):
        fd = os.open ('TESTDATA.txt', os.O_RDONLY)
        s = pexpect.spawn (fd)
        s.expect ('This is the end of test data:')
        s.expect (pexpect.EOF)
        assert s.before == ' END\n'

    def test_maxread (self):
        fd = os.open ('TESTDATA.txt', os.O_RDONLY)
        s = pexpect.spawn (fd)
        s.maxread = 100
        s.expect('2')
        s.expect ('This is the end of test data:')
        s.expect (pexpect.EOF)
        assert s.before == ' END\n'

    def test_fd_isalive (self):
        fd = os.open ('TESTDATA.txt', os.O_RDONLY)
        s = pexpect.spawn (fd)
        assert s.isalive()
        os.close (fd)
        assert not s.isalive()

    def test_fd_isatty (self):
        fd = os.open ('TESTDATA.txt', os.O_RDONLY)
        s = pexpect.spawn (fd)
        assert not s.isatty()
        os.close(fd)

###    def test_close_does_not_close_fd (self):
###        '''Calling close() on a pexpect.spawn object should not
###                close the underlying file descriptor.
###        '''
###        fd = os.open ('TESTDATA.txt', os.O_RDONLY)
###        s = pexpect.spawn (fd)
###        try:
###            s.close()
###            self.fail('Expected an Exception.')
###        except pexpect.ExceptionPexpect, e:
###            pass

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(ExpectTestCase, 'test')

#fout = open('delete_me_1','wb')
#fout.write(the_old_way)
#fout.close
#fout = open('delete_me_2', 'wb')
#fout.write(the_new_way)
#fout.close

########NEW FILE########
__FILENAME__ = echo_wait
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import signal, time, struct, fcntl, termios, os, sys

# a dumb PAM will print the password prompt first then set ECHO
# False. What it should do it set ECHO False first then print the
# prompt. Otherwise, if we see the password prompt and type out
# password real fast before it turns off ECHO then some or all of
# our password might be visibly echod back to us. Sounds unlikely?
# It happens.

print("fake password:")
sys.stdout.flush()
time.sleep(3)
attr = termios.tcgetattr(sys.stdout)
attr[3] = attr[3] & ~termios.ECHO
termios.tcsetattr(sys.stdout, termios.TCSANOW, attr)
time.sleep(12)
attr[3] = attr[3] | termios.ECHO
termios.tcsetattr(sys.stdout, termios.TCSANOW, attr)
time.sleep(2)

########NEW FILE########
__FILENAME__ = echo_w_prompt
# -*- coding: utf-8 -*-
from __future__ import print_function

try:
    raw_input
except NameError:
    raw_input = input

while True:
    a = raw_input('<in >')
    print('<out>', a, sep='')
########NEW FILE########
__FILENAME__ = exit1
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import os, sys

print("Hello")
sys.stdout.flush()
os._exit(1)

########NEW FILE########
__FILENAME__ = getch
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import sys, tty, termios

if hasattr(sys.stdin, 'buffer'):
    # Python 3: we want to read raw bytes
    stdin = sys.stdin.buffer
else:
    stdin = sys.stdin

def main():
    print('READY')
    while True:
        try:
            val = ord(stdin.read(1))
        except KeyboardInterrupt:
            val = 3
        sys.stdout.write('%d\r\n' % (val,))
        if val == 0:
            # StopIteration equivalent is ctrl+' ' (\x00, NUL)
            break

if __name__ == '__main__':
    fd = sys.stdin.fileno()
    old_settings = termios.tcgetattr(fd)
    try:
        tty.setraw(sys.stdin.fileno())
        main()
    finally:
        termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)

########NEW FILE########
__FILENAME__ = interact
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
try:
    # This allows coverage to measure code run in this process
    import coverage
    coverage.process_startup()
except ImportError:
    pass

import pexpect
import sys

def main():
    p = pexpect.spawn(sys.executable + ' echo_w_prompt.py')
    p.interact()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = interact_unicode
#!/usr/bin/env python
'''
Just like interact.py, but using spawnu instead of spawn
'''
try:
    # This allows coverage to measure code run in this process
    import coverage
    coverage.process_startup()
except ImportError:
    pass

import pexpect
import sys

def main():
    p = pexpect.spawnu(sys.executable + ' echo_w_prompt.py')
    p.interact()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = list100
# -*- coding: utf-8 -*-
print(list(range(100)))

########NEW FILE########
__FILENAME__ = needs_kill
#!/usr/bin/env python
"""This script can only be killed by SIGKILL."""
import signal, time

# Ignore interrupt, hangup and continue signals - only SIGKILL will work
signal.signal(signal.SIGINT, signal.SIG_IGN)
signal.signal(signal.SIGHUP, signal.SIG_IGN)
signal.signal(signal.SIGCONT, signal.SIG_IGN)

print('READY')
while True:
    time.sleep(10)
    
########NEW FILE########
__FILENAME__ = pexpectTest
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

import os, time, pexpect, sys

def getProcessResults(cmd, timeLimit=20):
  '''
  executes 'cmd' as a child process and returns the child's output,
  the duration of execution, and the process exit status. Aborts if
  child process does not generate output for 'timeLimit' seconds.
  '''
  output = ""
  startTime = time.time()
  child = pexpect.spawn(cmd, timeout=10)
  child.logfile = sys.stdout

  while 1:
    try:
      # read_nonblocking will add to 'outout' one byte at a time
      # newlines can show up as '\r\n' so we kill any '\r's which
      # will mess up the formatting for the viewer
      output += child.read_nonblocking(timeout=timeLimit).replace("\r","")
    except pexpect.EOF as e:
      print(str(e))
      # process terminated normally
      break
    except pexpect.TIMEOUT as e:
      print(str(e))
      output += "\nProcess aborted by FlashTest after %s seconds.\n" % timeLimit
      print(child.isalive())
      child.kill(9)
      break

  endTime = time.time()
  child.close(force=True)

  duration = endTime - startTime
  exitStatus = child.exitstatus

  return (output, duration, exitStatus)

cmd = "./ticker.py"

result, duration, exitStatus = getProcessResults(cmd)

print("result: %s" % result)
print("duration: %s" % duration)
print("exit-status: %s" % exitStatus)


########NEW FILE########
__FILENAME__ = PexpectTestCase

'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
from __future__ import print_function

import unittest
import sys
import os

class PexpectTestCase(unittest.TestCase):
    def setUp(self):
        self.PYTHONBIN = sys.executable
        self.original_path = os.getcwd()
        project_dir = os.environ['PROJECT_PEXPECT_HOME']
        newpath = os.path.join (project_dir, 'tests')
        os.chdir (newpath)
        os.environ['COVERAGE_PROCESS_START'] = os.path.join(project_dir, '.coveragerc')
        os.environ['COVERAGE_FILE'] = os.path.join(project_dir, '.coverage')
        print('\n', self.id(), end=' ')
        sys.stdout.flush()
        unittest.TestCase.setUp(self)

    def tearDown(self):
        os.chdir (self.original_path)


########NEW FILE########
__FILENAME__ = pexqa
import os, sys
import select
import signal
import traceback
import time
import re
import struct
from types import *
import posix

import pty
import tty
import termios
import fcntl
class s:
    def __init__(self, command, args=None, timeout=30):

        self.pid = self.child_fd = None
        try:
            #self.pid, self.child_fd = posix.forkpty()
            self.pid, self.child_fd = pty.fork()
        except OSError as e:
            raise Exception('pty fork() failed: ' + str(e))

        if self.pid == 0: # Child
            os.execvp(command, args)

        # Parent


print '1'
x = s('ls', ['ls'])
time.sleep(5)
print '2'
result = os.read (x.child_fd, 5555)
print '3'
print result
print '4'


########NEW FILE########
__FILENAME__ = test
#!/usr/bin/env python
import signal, os, time, errno, pty

def signal_handler (signum, frame):
    print 'Signal handler called with signal:', signum
    print 'signal.SIGCHLD=', signal.SIGKILL

# First thing we do is set up a handler for SIGCHLD.
signal.signal (signal.SIGCHLD, signal.SIG_IGN)

print 'PART 1 -- Test signal handling with empty pipe.'
# Create a child process for us to kill.
try:
    pid, fd = pty.fork()
except Exception as e:
    print str(e)

if pid == 0:
#    os.write (sys.stdout.fileno(), 'This is a test.\n This is a test.')
    time.sleep(10000)

print 'Sending SIGKILL to child pid:', pid
os.kill (pid, signal.SIGKILL)

# SIGCHLD should interrupt sleep.
# Note that this is a race.
# It is possible that the signal handler will get called
# before we try to sleep, but this has not happened yet.
# But in that case we can only tell by order of printed output.
print 'Entering sleep...'
try:
    time.sleep(10)
except:
    print 'sleep was interrupted by signal.'

# Just for fun let's see if the process is alive.
try:
    os.kill(pid, 0)
    print 'Child is alive. This is ambiguous because it may be a Zombie.'
except OSError as e:
    print 'Child appears to be dead.'

print 'PART 2 -- Test signal handling with full pipe.'
# Create a child process for us to kill.
try:
    pid, fd = pty.fork()
except Exception as e:
    print str(e)

if pid == 0:
    os.write (sys.stdout.fileno(), 'This is a test.\n This is a test.')
    time.sleep(10000)

print 'Sending SIGKILL to child pid:', pid
os.kill (pid, signal.SIGKILL)

# SIGCHLD should interrupt sleep.
# Note that this is a race.
# It is possible that the signal handler will get called
# before we try to sleep, but this has not happened yet.
# But in that case we can only tell by order of printed output.
print 'Entering sleep...'
try:
    time.sleep(10)
except:
    print 'sleep was interrupted by signal.'

# Just for fun let's see if the process is alive.
try:
    os.kill(pid, 0)
    print 'Child is alive. This is ambiguous because it may be a Zombie.'
except OSError as e:
    print 'Child appears to be dead.'


########NEW FILE########
__FILENAME__ = test2
#!/usr/bin/env python
import signal, os, time, errno

def signal_handler (signum, frame):
	print 'Signal handler called with signal:', signum
	print 'signal.SIGCHLD=', signal.SIGKILL

# Create a child process for us to kill.
pid = os.fork()
if pid == 0:
	time.sleep(10000)

#signal.signal (signal.SIGCHLD, signal.SIG_IGN)
signal.signal (signal.SIGCHLD, signal_handler)

print 'Sending SIGKILL to child pid:', pid
os.kill (pid, signal.SIGKILL)

# SIGCHLD should interrupt sleep.
# Note that this is a race.
# It is possible that the signal handler will get called
# before we try to sleep, but this has not happened yet.
# But in that case we can only tell by order of printed output.
interrupted = 0
try:
	time.sleep(10)
except:
	print 'sleep was interrupted by signal.'
	interrupted = 1

if not interrupted:
	print 'ERROR. Signal did not interrupt sleep.'
else:
	print 'Signal interrupted sleep. This is good.'

# Let's see if the process is alive.
try:
	os.kill(pid, 0)
	print 'Child is alive. This is ambiguous because it may be a Zombie.'
except OSError as e:
	print 'Child appears to be dead.'


########NEW FILE########
__FILENAME__ = test_badfork
#!/usr/bin/env python
import pexpect
import pyunit

def main ():
	pid, fd = fooork ('aThelaDSjd','-i')
	print 'pid', pid
	print 'fd', fd
	Xexpect(fd, 'bash.*#',10)
	os.write(fd, 'scp -P 6666 *.py noah@gw.tiered.com:pexpect/\n')
	Xexpect(fd, 'bash.*#',10)
	os.write(fd, 'exit\n')
	print _my_read (fd, 1000, 5)
	sys.exit (1)


########NEW FILE########
__FILENAME__ = test_control_terminal
#!/usr/bin/env python

import termios, fcntl, struct, os, sys

def getwinsize():	
	s = struct.pack("HHHH", 0, 0, 0, 0)
	x = fcntl.ioctl(sys.stdout.fileno(), termios.TIOCGWINSZ, s)
	rows, cols = struct.unpack("HHHH", x)[:2]
	return rows, cols

def setwinsize(r,c):
	# Assume ws_xpixel and ws_ypixel are zero.
	s = struct.pack("HHHH", r,c,0,0)
	x = fcntl.ioctl(sys.stdout.fileno(), termios.TIOCSWINSZ, s)
print 'stdin tty:', os.ttyname(0)
print 'stdout tty:', os.ttyname(1)
print 'controlling terminal:', os.ctermid() 
print 'winsize %d,%d' % getwinsize()
print 'ENDTEST'

########NEW FILE########
__FILENAME__ = test_handler
#!/usr/bin/env python
import signal, os, time, errno, pty, sys, fcntl, tty
GLOBAL_SIGCHLD_RECEIVED = 0
                                                                                 
def nonblock (fd):                                                           
	# if O_NDELAY is set read() returns 0 (ambiguous with EOF).
	# if O_NONBLOCK is set read() returns -1 and sets errno to EAGAIN
	original_flags = fcntl.fcntl (fd, fcntl.F_GETFL, 0)
	flags = original_flags | os.O_NONBLOCK
	fcntl.fcntl(fd, fcntl.F_SETFL, flags)
	return original_flags

def signal_handler (signum, frame):
	print '<HANDLER>'
	global GLOBAL_SIGCHLD_RECEIVED
	status = os.waitpid (-1, os.WNOHANG)
	if status[0] == 0:
		print 'No process for waitpid:', status
	else:
		print 'Status:', status
	print 'WIFEXITED(status):', os.WIFEXITED(status[1])
	print 'WEXITSTATUS(status):', os.WEXITSTATUS(status[1]) 
	GLOBAL_SIGCHLD_RECEIVED = 1

def main ():
	signal.signal (signal.SIGCHLD, signal_handler)
	pid, fd = pty.fork()
	if pid == 0:
		os.write (sys.stdout.fileno(), 'This is a test.\nThis is a test.')
		time.sleep(10000)
	nonblock (fd)
	tty.setraw(fd) #STDIN_FILENO)
	print 'Sending SIGKILL to child pid:', pid
	time.sleep(2)
	os.kill (pid, signal.SIGKILL)

	print 'Entering to sleep...'
	try:
		time.sleep(2)
	except:
		print 'Sleep interrupted'
	try:
		os.kill(pid, 0)
		print '\tChild is alive. This is ambiguous because it may be a Zombie.'
	except OSError as e:
		print '\tChild appears to be dead.'
#		print str(e)
	print
	print 'Reading from master fd:', os.read (fd, 1000)



if __name__ == '__main__':
	main ()

########NEW FILE########
__FILENAME__ = test_killed_pid
#!/usr/bin/env python
import os, time, signal
import expyct

e = expyct.expyct ('/bin/sh', '-i')
print 'pid,fd:', e.pid, e.fd
print 'isAlive:', e.isAlive()
# Treat it brusquely.
print 'sending SIGKILL...'
os.kill (e.pid, signal.SIGKILL)
time.sleep (1)
print os.read(e.fd, 1000)
print 'isAlive:', e.isAlive()
e.expect('\#')
e.send ('ls -la /\n')
r,m,i = e.expect ('\#')
print r

########NEW FILE########
__FILENAME__ = test_middle_buffer
#!/usr/bin/env python2
import expyct
import time

e = expyct.expyct ('/bin/sh -i')
e.timeout=60
e.expect(['#', '\$'])
e.send ('ls -la /\n')

i = e.expect (['foo','(d[aeiou]v)'])
print '\nRead before match>%s<' % e.before
print 'Matched:>%s<' % e.matched 
print 'index:', i

i = e.expect(['#', '\$'])
print '\nRead before match>%s<' % e.before
print 'Matched:>%s<' % e.matched
print 'index:', i
e.send('exit\n')
print 'Sent exit'
time.sleep(2)
print 'isAlive:', e.isAlive()

# This should test timeout...
i = e.expect ('#####')
print '\nRead before match>%s<' % e.before
print 'Matched:>%s<' % e.matched
print 'index:', i



########NEW FILE########
__FILENAME__ = test_read
import os, sys

filename = os.tmpnam()
print 'filename:', filename

fd_out = os.open(filename, os.O_CREAT | os.O_WRONLY)
print 'fd_out:', fd_out
os.write (fd_out, 'This is a test.\n')
os.close(fd_out)
print
print 'testing read on good fd...'
fd_in = os.open (filename, os.O_RDONLY)
print 'fd_in:', fd_in
while 1:
	data_in = os.read(fd_in, 1)
	print 'data_in:', data_in
	if data_in == '':
		print 'data_in was empty'
		break #sys.exit(1)
os.close(fd_in)
print
print
print 'testing read on closed fd...'
fd_in = os.open ('test_read.py', os.O_RDONLY)
print 'fd_in:', fd_in
while 1:
	data_in = os.read(fd_in, 1)
	print 'data_in:', data_in
	if data_in == '':
		print 'data_in was empty'
		break
os.close(fd_in)
d = os.read(fd_in, 1) # fd_in should be closed now...
if s == '':
	print 'd is empty. good.'

########NEW FILE########
__FILENAME__ = test_signals
#!/usr/bin/env python
import signal, os, time, errno, pty, sys
GLOBAL_SIGCHLD_RECEIVED = 0

def signal_handler (signum, frame):
    print '<HANDLER>'
    global GLOBAL_SIGCHLD_RECEIVED
    status = os.waitpid (-1, os.WNOHANG)
    print 'WIFEXITED(status):', os.WIFEXITED(status)
    print 'WEXITSTATUS(status):', os.WEXITSTATUS(status) 
    GLOBAL_SIGCHLD_RECEIVED = 1

def main ():
#	sig_test ('SIG_IGN', 'ptyfork', 'yes')
	sig_test ('handler', 'ptyfork', 'yes')
#	sig_test ('SIG_IGN', 'ptyfork', 'no')
#	sig_test ('handler', 'ptyfork', 'no')
#	sig_test ('SIG_IGN', 'osfork', 'yes')
#	sig_test ('handler', 'osfork', 'yes')
#	sig_test ('SIG_IGN', 'osfork', 'no')
#	sig_test ('handler', 'osfork', 'no')

def sig_test (sig_handler_type, fork_type, child_output):
	print 'Testing with:'
	print '\tsig_handler_type:', sig_handler_type
	print '\tfork_type:', fork_type
	print '\tchild_output:', child_output

	if sig_handler_type == 'SIG_IGN':
		signal.signal (signal.SIGCHLD, signal.SIG_IGN)
	else:
		signal.signal (signal.SIGCHLD, signal_handler)
	pid = -1
	fd = -1
	if fork_type == 'ptyfork':
		pid, fd = pty.fork()
	else:
		pid = os.fork()

	if pid == 0:
		if child_output == 'yes':
			os.write (sys.stdout.fileno(), 'This is a test.\nThis is a test.')
		time.sleep(10000)

	#print 'Sending SIGKILL to child pid:', pid
	time.sleep(2)
	os.kill (pid, signal.SIGKILL)

	#print 'Entering to sleep...'
	try:
		time.sleep(2)
	except:
		pass
	try:
		os.kill(pid, 0)
		print '\tChild is alive. This is ambiguous because it may be a Zombie.'
	except OSError as e:
		print '\tChild appears to be dead.'
#		print str(e)
	print

if __name__ == '__main__':
	main ()

########NEW FILE########
__FILENAME__ = qa
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import commands
import signal

signal.signal(signal.SIGCHLD, signal.SIG_IGN)
print(commands.getoutput('/bin/ls -l'))


########NEW FILE########
__FILENAME__ = sigwinch_report
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
from  __future__ import print_function

import signal, time, struct, fcntl, termios, sys

def getwinsize():
    '''This returns the window size of the child tty.
    The return value is a tuple of (rows, cols).
    '''
    if 'TIOCGWINSZ' in dir(termios):
        TIOCGWINSZ = termios.TIOCGWINSZ
    else:
        TIOCGWINSZ = 1074295912 # Assume
    s = struct.pack('HHHH', 0, 0, 0, 0)
    x = fcntl.ioctl(sys.stdout.fileno(), TIOCGWINSZ, s)
    return struct.unpack('HHHH', x)[0:2]

def handler(signum, frame):
    print('signal')
    sys.stdout.flush()
    print('SIGWINCH:', getwinsize ())
    sys.stdout.flush()

print("setting handler for SIGWINCH")
signal.signal(signal.SIGWINCH, handler)
print("READY")

while 1:
    sys.stdout.flush()
    time.sleep(1)


########NEW FILE########
__FILENAME__ = sleep_for
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from  __future__ import print_function

import time
import sys

def main():
    """
        This script sleeps for the number of seconds (float) specified by the
        command line argument.
    """
    if len(sys.argv) < 2:
        print("Usage: %s seconds_to_sleep" % (sys.argv[0],))
        sys.exit(1)
    timeout = float(sys.argv[1])
    print("READY")
    time.sleep(timeout)
    print("END")

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = swapcase_echo
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import sys, time
while True:
    x = raw_input ()
    time.sleep(1) # without this delay the test would fail about 75% of the time. Why?
    print(x.swapcase())
    sys.stdout.flush()

########NEW FILE########
__FILENAME__ = test_ansi
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
from pexpect import ANSI
import unittest
import PexpectTestCase

write_target = 'I\'ve got a ferret sticking up my nose.                           \n' +\
'(He\'s got a ferret sticking up his nose.)                        \n' +\
'How it got there I can\'t tell                                    \n' +\
'But now it\'s there it hurts like hell                            \n' +\
'And what is more it radically affects my sense of smell.         \n' +\
'(His sense of smell.)                                            '

write_text = 'I\'ve got a ferret sticking up my nose.\n' + \
'(He\'s got a ferret sticking up his nose.)\n' + \
'How it got there I can\'t tell\n' + \
'But now it\'s there it hurts like hell\n' + \
'And what is more it radically affects my sense of smell.\n' + \
'(His sense of smell.)\n' + \
'I can see a bare-bottomed mandril.\n' + \
'(Slyly eyeing his other nostril.)\n' + \
'If it jumps inside there too I really don\'t know what to do\n' + \
'I\'ll be the proud posessor of a kind of nasal zoo.\n' + \
'(A nasal zoo.)\n' + \
'I\'ve got a ferret sticking up my nose.\n' + \
'(And what is worst of all it constantly explodes.)\n' + \
'"Ferrets don\'t explode," you say\n' + \
'But it happened nine times yesterday\n' + \
'And I should know for each time I was standing in the way.\n' + \
'I\'ve got a ferret sticking up my nose.\n' + \
'(He\'s got a ferret sticking up his nose.)\n' + \
'How it got there I can\'t tell\n' + \
'But now it\'s there it hurts like hell\n' + \
'And what is more it radically affects my sense of smell.\n' + \
'(His sense of smell.)'

tetris_target='                           XX            XXXX    XX                             \n' +\
'                           XXXXXX    XXXXXXXX    XX                             \n' +\
'                           XXXXXX    XXXXXXXX    XX                             \n' +\
'                           XX  XX    XX  XXXX    XX                             \n' +\
'                           XXXXXX  XXXX  XXXX    XX                             \n' +\
'                           XXXXXXXXXX    XXXX    XX                             \n' +\
'                           XX  XXXXXX      XX    XX                             \n' +\
'                           XXXXXX          XX    XX                             \n' +\
'                           XXXX    XXXXXX  XX    XX                             \n' +\
'                           XXXXXX    XXXX  XX    XX                             \n' +\
'                           XX  XX    XXXX  XX    XX                             \n' +\
'                           XX  XX      XX  XX    XX                             \n' +\
'                           XX  XX    XXXX  XXXX  XX                             \n' +\
'                           XXXXXXXX  XXXX  XXXX  XX                             \n' +\
'                           XXXXXXXXXXXXXX  XXXXXXXX                             \n' +\
'                           XX    XXXXXXXX  XX    XX                             \n' +\
'                           XXXXXXXXXXXXXX  XX    XX                             \n' +\
'                           XX  XXXX    XXXXXX    XX                             \n' +\
'                           XXXXXX          XXXXXXXX                             \n' +\
'                           XXXXXXXXXX      XX    XX                             \n' +\
'                           XXXXXXXXXXXXXXXXXXXXXXXX                             \n' +\
'                                                                                \n' +\
'  J->LEFT  K->ROTATE  L->RIGHT  SPACE->DROP  P->PAUSE  Q->QUIT                  \n' +\
'                                                                                '

torture_target='+--------------------------------------------------------------------------------+\n' +\
'|a`opqrs`      This is the       `srqpo`a                                        |\n' +\
'|VT100 series Torture Test Demonstration.                                        |\n' +\
'|VT100 series Torture Test Demonstration.                                        |\n' +\
'|This is a normal line __________________________________________________y_      |\n' +\
'|This is a bold line (normal unless the Advanced Video Option is installed)      |\n' +\
'|This line is underlined _ "       "       "       "       "       "    _y_      |\n' +\
'|This is a blinking line _ "       "       "       "       "       "    _y_      |\n' +\
'|This is inverse video _ (underlined if no AVO and cursor is underline) _y_      |\n' +\
'|Normal gjpqy Underline   Blink   Underline+Blink gjpqy                          |\n' +\
'|Bold   gjpqy Underline   Blink   Underline+Blink gjpqy                          |\n' +\
'|Inverse      Underline   Blink   Underline+Blink                                |\n' +\
'|Bold+Inverse Underline   Blink   Underline+Blink                                |\n' +\
'|This is double width                                                            |\n' +\
'|This is double height                                                           |\n' +\
'|This is double height                                                           |\n' +\
'|_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789ioy                                        |\n' +\
'|_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789ioy                                        |\n' +\
'|_ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789ioy                                        |\n' +\
'|`abcdefghijklmnopqrstuvwxyz{|}~ lqwqk                                           |\n' +\
'|`abcdefghijklmnopqrstuvwxyz{|}~ tqnqu                                           |\n' +\
'|`abcdefghijklmnopqrstuvwxyz{|}~ tqnqu                                           |\n' +\
'|`abcdefghijklmnopqrstuvwxyz{|}~ mqvqj                                           |\n' +\
'|   This test created by Joe Smith, 8-May-85                                     |\n' +\
'|                                                                                |\n' +\
'+--------------------------------------------------------------------------------+\n'

class ansiTestCase (PexpectTestCase.PexpectTestCase):
    def test_write (self):
        s = ANSI.ANSI (6,65)
        s.fill('.')
        s.cursor_home()
        for c in write_text:
            s.write (c)
        assert str(s) == write_target

    def test_torturet (self):
        s = ANSI.ANSI (24,80)
        with open('torturet.vt') as f:
            sample_text = f.read()
        for c in sample_text:
            s.process (c)
        assert s.pretty() == torture_target, 'processed: \n' + s.pretty() + '\nexpected:\n' + torture_target

    def test_tetris (self):
        s = ANSI.ANSI (24,80)
        with open('tetris.data') as f:
            tetris_text = f.read()
        for c in tetris_text:
            s.process (c)
        assert str(s) == tetris_target

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(ansiTestCase,'test')


########NEW FILE########
__FILENAME__ = test_command_list_split
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import unittest
import PexpectTestCase
class SplitCommandLineTestCase(PexpectTestCase.PexpectTestCase):
    def testSplitSizes(self):
        assert len(pexpect.split_command_line(r'')) == 0
        assert len(pexpect.split_command_line(r'one')) == 1
        assert len(pexpect.split_command_line(r'one two')) == 2
        assert len(pexpect.split_command_line(r'one  two')) == 2
        assert len(pexpect.split_command_line(r'one   two')) == 2
        assert len(pexpect.split_command_line(r'one\ one')) == 1
        assert len(pexpect.split_command_line('\'one one\'')) == 1
        assert len(pexpect.split_command_line(r'one\"one')) == 1
        assert len(pexpect.split_command_line(r'This\' is a\'\ test')) == 3

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(SplitCommandLineTestCase,'test')

########NEW FILE########
__FILENAME__ = test_constructor
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import unittest
import time
import PexpectTestCase

class TestCaseConstructor(PexpectTestCase.PexpectTestCase):
    def test_constructor (self):
        '''This tests that the constructor will work and give
        the same results for different styles of invoking __init__().
        This assumes that the root directory / is static during the test.
        '''
        p1 = pexpect.spawn('/bin/ls -l /bin')
        p2 = pexpect.spawn('/bin/ls' ,['-l', '/bin'])
        p1.expect (pexpect.EOF)
        p2.expect (pexpect.EOF)
        assert (p1.before == p2.before)

    def test_named_parameters (self):
        '''This tests that named parameters work.
        '''
        p = pexpect.spawn ('/bin/ls',timeout=10)
        p = pexpect.spawn (timeout=10, command='/bin/ls')
        p = pexpect.spawn (args=[], command='/bin/ls')

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(TestCaseConstructor,'test')


########NEW FILE########
__FILENAME__ = test_ctrl_chars
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
from __future__ import print_function

import pexpect
import unittest
import PexpectTestCase
import time
import sys

if sys.version_info[0] >= 3:
    def byte(i):
        return bytes([i])
else:
    byte = chr

class TestCtrlChars(PexpectTestCase.PexpectTestCase):

    def test_control_chars(self):
        '''This tests that we can send all 256 8-bit characters to a child
        process.'''
        child = pexpect.spawn('python getch.py')
        child.expect('READY', timeout=5)
        try:
            for i in range(1,256):
                child.send(byte(i))
                child.expect ('%d\r\n' % (i,))
            # This needs to be last, as getch.py exits on \x00
            child.send(byte(0))
            child.expect('0\r\n')
            child.expect(pexpect.EOF)
        except Exception:
            err = sys.exc_info()[1]
            msg = "Did not echo character value: " + str(i) + "\n"
            msg = msg + str(err)
            self.fail(msg)

    def test_sendintr (self):
        try:
            child = pexpect.spawn('python getch.py')
            child.expect('READY', timeout=5)
            child.sendintr()
            child.expect ('3\r\n')
        except Exception:
            err = sys.exc_info()[1]
            self.fail("Did not echo character value: 3, %s\n%s\n%s" % (
                str(err), child.before, child.after,))

    def test_bad_sendcontrol_chars (self):
        '''This tests that sendcontrol will return 0 for an unknown char. '''

        child = pexpect.spawn('python getch.py')
        retval = child.sendcontrol('1')
        assert retval == 0, "sendcontrol() should have returned 0 because there is no such thing as ctrl-1."

    def test_sendcontrol(self):
        '''This tests that we can send all special control codes by name.
        '''
        child = pexpect.spawn('python getch.py')
        # On slow machines, like Travis, the process is not ready in time to
        # catch the first character unless we wait for it.
        child.expect('READY', timeout=5)
        child.delaybeforesend = 0.05
        for ctrl in 'abcdefghijklmnopqrstuvwxyz':
            assert child.sendcontrol(ctrl) == 1
            val = ord(ctrl) - ord('a') + 1
            try:
                child.expect_exact(str(val)+'\r\n', timeout=2)
            except:
                print(ctrl)
                raise

        # escape character
        assert child.sendcontrol('[') == 1
        child.expect ('27\r\n')
        assert child.sendcontrol('\\') == 1
        child.expect ('28\r\n')
        # telnet escape character
        assert child.sendcontrol(']') == 1
        child.expect ('29\r\n')
        assert child.sendcontrol('^') == 1
        child.expect ('30\r\n')
        # irc protocol uses this to underline ...
        assert child.sendcontrol('_') == 1
        child.expect ('31\r\n')
        # the real "backspace is delete"
        assert child.sendcontrol('?') == 1
        child.expect ('127\r\n')
        # NUL, same as ctrl + ' '
        assert child.sendcontrol('@') == 1
        child.expect ('0\r\n')
        # 0 is sentinel value to getch.py, assert exit:
        #   causes child to exit, but, if immediately tested,
        #   isalive() still returns True unless an artifical timer
        #   is used.
        time.sleep(0.5)
        assert child.isalive() == False, child.isalive()
        assert child.exitstatus == 0

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(TestCtrlChars,'test')


########NEW FILE########
__FILENAME__ = test_destructor
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import unittest
import PexpectTestCase
import gc
import platform
import time

class TestCaseDestructor(PexpectTestCase.PexpectTestCase):
    def test_destructor (self):
        if platform.python_implementation() != 'CPython':
            # Details of garbage collection are different on other implementations
            return 'SKIP'
        gc.collect()
        time.sleep(3)
        p1 = pexpect.spawn('%s hello_world.py' % self.PYTHONBIN)
        p2 = pexpect.spawn('%s hello_world.py' % self.PYTHONBIN)
        p3 = pexpect.spawn('%s hello_world.py' % self.PYTHONBIN)
        p4 = pexpect.spawn('%s hello_world.py' % self.PYTHONBIN)
        fd_t1 = (p1.child_fd,p2.child_fd,p3.child_fd,p4.child_fd)
        p1.expect(pexpect.EOF)
        p2.expect(pexpect.EOF)
        p3.expect(pexpect.EOF)
        p4.expect(pexpect.EOF)
        p1.kill(9)
        p2.kill(9)
        p3.kill(9)
        p4.kill(9)
        p1 = None
        p2 = None
        p3 = None
        p4 = None
        gc.collect()
        time.sleep(3) # Some platforms are slow at gc... Solaris!

        p1 = pexpect.spawn('%s hello_world.py' % self.PYTHONBIN)
        p2 = pexpect.spawn('%s hello_world.py' % self.PYTHONBIN)
        p3 = pexpect.spawn('%s hello_world.py' % self.PYTHONBIN)
        p4 = pexpect.spawn('%s hello_world.py' % self.PYTHONBIN)
        fd_t2 = (p1.child_fd,p2.child_fd,p3.child_fd,p4.child_fd)
        p1.kill(9)
        p2.kill(9)
        p3.kill(9)
        p4.kill(9)
        del (p1)
        del (p2)
        del (p3)
        del (p4)
        gc.collect()
        time.sleep(3)

        p1 = pexpect.spawn('%s hello_world.py' % self.PYTHONBIN)
        p2 = pexpect.spawn('%s hello_world.py' % self.PYTHONBIN)
        p3 = pexpect.spawn('%s hello_world.py' % self.PYTHONBIN)
        p4 = pexpect.spawn('%s hello_world.py' % self.PYTHONBIN)
        fd_t3 = (p1.child_fd,p2.child_fd,p3.child_fd,p4.child_fd)

        assert (fd_t1 == fd_t2 == fd_t3), "pty file descriptors not properly garbage collected (fd_t1,fd_t2,fd_t3)=(%s,%s,%s)" % (str(fd_t1),str(fd_t2),str(fd_t3))


if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(TestCaseDestructor,'test')


########NEW FILE########
__FILENAME__ = test_dotall
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import unittest
import re
import PexpectTestCase

testdata = 'BEGIN\nHello world\nEND'
class TestCaseDotall(PexpectTestCase.PexpectTestCase):
    def test_dotall (self):
        p = pexpect.spawn('echo "%s"' % testdata)
        i = p.expect ([b'BEGIN(.*)END', pexpect.EOF])
        assert i==0, 'DOTALL does not seem to be working.'

    def test_precompiled (self):
        p = pexpect.spawn('echo "%s"' % testdata)
        pat = re.compile(b'BEGIN(.*)END') # This overrides the default DOTALL.
        i = p.expect ([pat, pexpect.EOF])
        assert i==1, 'Precompiled pattern to override DOTALL does not seem to be working.'

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(TestCaseDotall,'test')


########NEW FILE########
__FILENAME__ = test_expect
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
from __future__ import with_statement  # bring 'with' stmt to py25
import pexpect
import unittest
import subprocess
import time
import PexpectTestCase
import sys
import signal
#import pdb

# Many of these test cases blindly assume that sequential directory
# listings of the /bin directory will yield the same results.
# This may not be true, but seems adequate for testing now.
# I should fix this at some point.

# query: For some reason an extra newline occures under OS X evey
# once in a while. Excessive uses of .replace resolve these

FILTER=''.join([(len(repr(chr(x)))==3) and chr(x) or '.' for x in range(256)])
def hex_dump(src, length=16):
    result=[]
    for i in xrange(0, len(src), length):
       s = src[i:i+length]
       hexa = ' '.join(["%02X"%ord(x) for x in s])
       printable = s.translate(FILTER)
       result.append("%04X   %-*s   %s\n" % (i, length*3, hexa, printable))
    return ''.join(result)

def hex_diff(left, right):
        diff = ['< %s\n> %s' % (_left, _right,) for _left, _right in zip(
            hex_dump(left).splitlines(), hex_dump(right).splitlines())
            if _left != _right]
        return '\n' + '\n'.join(diff,)


class assert_raises_msg(object):
    def __init__(self, errtype, msgpart):
        self.errtype = errtype
        self.msgpart = msgpart

    def __enter__(self):
        pass

    def __exit__(self, etype, value, traceback):
        if value is None:
            raise AssertionError('Expected %s, but no exception was raised' \
                                    % self.errtype)
        if not isinstance(value, self.errtype):
            raise AssertionError('Expected %s, but %s was raised' \
                                    % (self.errtype, etype))

        errstr = str(value)
        if self.msgpart not in errstr:
            raise AssertionError('%r was not in %r' % (self.msgpart, errstr))

        return True


class ExpectTestCase (PexpectTestCase.PexpectTestCase):

    def test_expect_basic (self):
        p = pexpect.spawn('cat')
        p.sendline (b'Hello')
        p.sendline (b'there')
        p.sendline (b'Mr. Python')
        p.expect (b'Hello')
        p.expect (b'there')
        p.expect (b'Mr. Python')
        p.sendeof ()
        p.expect (pexpect.EOF)

    def test_expect_exact_basic (self):
        p = pexpect.spawn('cat')
        p.sendline (b'Hello')
        p.sendline (b'there')
        p.sendline (b'Mr. Python')
        p.expect_exact (b'Hello')
        p.expect_exact (b'there')
        p.expect_exact (b'Mr. Python')
        p.sendeof ()
        p.expect_exact (pexpect.EOF)

    def test_expect_ignore_case(self):
        '''This test that the ignorecase flag will match patterns
        even if case is different using the regex (?i) directive.
        '''
        p = pexpect.spawn('cat')
        p.sendline (b'HELLO')
        p.sendline (b'there')
        p.expect (b'(?i)hello')
        p.expect (b'(?i)THERE')
        p.sendeof ()
        p.expect (pexpect.EOF)

    def test_expect_ignore_case_flag(self):
        '''This test that the ignorecase flag will match patterns
        even if case is different using the ignorecase flag.
        '''
        p = pexpect.spawn('cat')
        p.ignorecase = True
        p.sendline (b'HELLO')
        p.sendline (b'there')
        p.expect (b'hello')
        p.expect (b'THERE')
        p.sendeof ()
        p.expect (pexpect.EOF)

    def test_expect_order (self):
        '''This tests that patterns are matched in the same order as given in the pattern_list.

        (Or does it?  Doesn't it also pass if expect() always chooses
        (one of the) the leftmost matches in the input? -- grahn)
        ... agreed! -jquast, the buffer ptr isn't forwarded on match, see first two test cases
        '''
        p = pexpect.spawn('cat')
        self._expect_order(p)

    def test_expect_order_exact (self):
        '''Like test_expect_order(), but using expect_exact().
        '''
        p = pexpect.spawn('cat')
        p.expect = p.expect_exact
        self._expect_order(p)

    def _expect_order (self, p):
        # Disable echo so that the output we see is in an entirely predictable
        # order
        p.setecho(False)
        p.waitnoecho()

        p.sendline (b'1234')
        p.sendline (b'abcd')
        p.sendline (b'wxyz')
        p.sendline (b'7890')
        p.sendeof ()
        index = p.expect ([
            b'1234',
            b'abcd',
            b'wxyz',
            pexpect.EOF,
            b'7890' ])
        assert index == 0, (index, p.before, p.after)
        index = p.expect ([
            b'54321',
            pexpect.TIMEOUT,
            b'1234',
            b'abcd',
            b'wxyz',
            pexpect.EOF], timeout=5)
        assert index == 3, (index, p.before, p.after)
        index = p.expect ([
            b'54321',
            pexpect.TIMEOUT,
            b'1234',
            b'abcd',
            b'wxyz',
            pexpect.EOF], timeout=5)
        assert index == 4, (index, p.before, p.after)
        index = p.expect ([
            pexpect.EOF,
            b'abcd',
            b'wxyz',
            b'7890' ])
        assert index == 3, (index, p.before, p.after)

        index = p.expect ([
            b'abcd',
            b'wxyz',
            b'7890',
            pexpect.EOF])
        assert index == 3, (index, p.before, p.after)

    def test_waitnoecho (self):

        ''' This tests that we can wait on a child process to set echo mode.
        For example, this tests that we could wait for SSH to set ECHO False
        when asking of a password. This makes use of an external script
        echo_wait.py. '''

        p1 = pexpect.spawn('%s echo_wait.py' % self.PYTHONBIN)
        start = time.time()
        p1.waitnoecho(timeout=10)
        end_time = time.time() - start
        assert end_time < 10 and end_time > 2, "waitnoecho did not set ECHO off in the expected window of time."

        # test that we actually timeout and return False if ECHO is never set off.
        p1 = pexpect.spawn('cat')
        start = time.time()
        retval = p1.waitnoecho(timeout=4)
        end_time = time.time() - start
        assert end_time > 3, "waitnoecho should have waited longer than 2 seconds. retval should be False, retval=%d"%retval
        assert retval==False, "retval should be False, retval=%d"%retval

        # This one is mainly here to test default timeout for code coverage.
        p1 = pexpect.spawn('%s echo_wait.py' % self.PYTHONBIN)
        start = time.time()
        p1.waitnoecho()
        end_time = time.time() - start
        assert end_time < 10, "waitnoecho did not set ECHO off in the expected window of time."

    def test_expect_echo (self):
        '''This tests that echo can be turned on and off.
        '''
        p = pexpect.spawn('cat', timeout=10)
        self._expect_echo(p)

    def test_expect_echo_exact (self):
        '''Like test_expect_echo(), but using expect_exact().
        '''
        p = pexpect.spawn('cat', timeout=10)
        p.expect = p.expect_exact
        self._expect_echo(p)

    def _expect_echo (self, p):
        p.sendline (b'1234') # Should see this twice (once from tty echo and again from cat).
        index = p.expect ([
            b'1234',
            b'abcd',
            b'wxyz',
            pexpect.EOF,
            pexpect.TIMEOUT])
        assert index == 0, "index="+str(index)+"\n"+p.before
        index = p.expect ([
            b'1234',
            b'abcd',
            b'wxyz',
            pexpect.EOF])
        assert index == 0, "index="+str(index)
        p.setecho(0) # Turn off tty echo
        p.sendline (b'abcd') # Now, should only see this once.
        p.sendline (b'wxyz') # Should also be only once.
        index = p.expect ([
            pexpect.EOF,
            pexpect.TIMEOUT,
            b'abcd',
            b'wxyz',
            b'1234'])
        assert index == 2, "index="+str(index)
        index = p.expect ([
            pexpect.EOF,
            b'abcd',
            b'wxyz',
            b'7890'])
        assert index == 2, "index="+str(index)
        p.setecho(1) # Turn on tty echo
        p.sendline (b'7890') # Should see this twice.
        index = p.expect ([pexpect.EOF,b'abcd',b'wxyz',b'7890'])
        assert index == 3, "index="+str(index)
        index = p.expect ([pexpect.EOF,b'abcd',b'wxyz',b'7890'])
        assert index == 3, "index="+str(index)
        p.sendeof()

    def test_expect_index (self):
        '''This tests that mixed list of regex strings, TIMEOUT, and EOF all
        return the correct index when matched.
        '''
        #pdb.set_trace()
        p = pexpect.spawn('cat')
        self._expect_index(p)

    def test_expect_index_exact (self):
        '''Like test_expect_index(), but using expect_exact().
        '''
        p = pexpect.spawn('cat')
        p.expect = p.expect_exact
        self._expect_index(p)

    def _expect_index (self, p):
        p.setecho(0)
        p.sendline (b'1234')
        index = p.expect ([b'abcd',b'wxyz',b'1234',pexpect.EOF])
        assert index == 2, "index="+str(index)
        p.sendline (b'abcd')
        index = p.expect ([pexpect.TIMEOUT,b'abcd',b'wxyz',b'1234',pexpect.EOF])
        assert index == 1, "index="+str(index)
        p.sendline (b'wxyz')
        index = p.expect ([b'54321',pexpect.TIMEOUT,b'abcd',b'wxyz',b'1234',pexpect.EOF], timeout=5)
        assert index == 3, "index="+str(index) # Expect 'wxyz'
        p.sendline (b'$*!@?')
        index = p.expect ([b'54321',pexpect.TIMEOUT,b'abcd',b'wxyz',b'1234',pexpect.EOF], timeout=5)
        assert index == 1, "index="+str(index) # Expect TIMEOUT
        p.sendeof ()
        index = p.expect ([b'54321',pexpect.TIMEOUT,b'abcd',b'wxyz',b'1234',pexpect.EOF], timeout=5)
        assert index == 5, "index="+str(index) # Expect EOF

    def test_expect (self):
        the_old_way = subprocess.Popen(args=['ls', '-l', '/bin'],
                stdout=subprocess.PIPE).communicate()[0].rstrip()
        p = pexpect.spawn('ls -l /bin')
        the_new_way = b''
        while 1:
            i = p.expect ([b'\n', pexpect.EOF])
            the_new_way = the_new_way + p.before
            if i == 1:
                break
        the_new_way = the_new_way.rstrip()
        the_new_way = the_new_way.replace(b'\r\n', b'\n'
                ).replace(b'\r', b'\n').replace(b'\n\n', b'\n').rstrip()
        the_old_way = the_old_way.replace(b'\r\n', b'\n'
                ).replace(b'\r', b'\n').replace(b'\n\n', b'\n').rstrip()
        assert the_old_way == the_new_way, hex_diff(the_old_way, the_new_way)

    def test_expect_exact (self):
        the_old_way = subprocess.Popen(args=['ls', '-l', '/bin'],
                stdout=subprocess.PIPE).communicate()[0].rstrip()
        p = pexpect.spawn('ls -l /bin')
        the_new_way = b''
        while 1:
            i = p.expect_exact ([b'\n', pexpect.EOF])
            the_new_way = the_new_way + p.before
            if i == 1:
                break
        the_new_way = the_new_way.replace(b'\r\n', b'\n'
                ).replace(b'\r', b'\n').replace(b'\n\n', b'\n').rstrip()
        the_old_way = the_old_way.replace(b'\r\n', b'\n'
                ).replace(b'\r', b'\n').replace(b'\n\n', b'\n').rstrip()
        assert the_old_way == the_new_way, hex_diff(the_old_way, the_new_way)
        p = pexpect.spawn('echo hello.?world')
        i = p.expect_exact(b'.?')
        self.assertEqual(p.before, b'hello')
        self.assertEqual(p.after, b'.?')

    def test_expect_eof (self):
        the_old_way = subprocess.Popen(args=['/bin/ls', '-l', '/bin'],
                stdout=subprocess.PIPE).communicate()[0].rstrip()
        p = pexpect.spawn('/bin/ls -l /bin')
        p.expect(pexpect.EOF) # This basically tells it to read everything. Same as pexpect.run() function.
        the_new_way = p.before
        the_new_way = the_new_way.replace(b'\r\n', b'\n'
                ).replace(b'\r', b'\n').replace(b'\n\n', b'\n').rstrip()
        the_old_way = the_old_way.replace(b'\r\n', b'\n'
                ).replace(b'\r', b'\n').replace(b'\n\n', b'\n').rstrip()
        assert the_old_way == the_new_way, hex_diff(the_old_way, the_new_way)

    def test_expect_timeout (self):
        p = pexpect.spawn('cat', timeout=5)
        p.expect(pexpect.TIMEOUT) # This tells it to wait for timeout.
        self.assertEqual(p.after, pexpect.TIMEOUT)

    def test_unexpected_eof (self):
        p = pexpect.spawn('ls -l /bin')
        try:
            p.expect('_Z_XY_XZ') # Probably never see this in ls output.
        except pexpect.EOF:
            pass
        else:
            self.fail ('Expected an EOF exception.')

    def _before_after(self, p):
        p.timeout = 5

        p.expect(b'5')
        self.assertEqual(p.after, b'5')
        assert p.before.startswith(b'[0, 1, 2'), p.before

        p.expect(b'50')
        self.assertEqual(p.after, b'50')
        assert p.before.startswith(b', 6, 7, 8'), p.before[:20]
        assert p.before.endswith(b'48, 49, '), p.before[-20:]

        p.expect(pexpect.EOF)
        self.assertEqual(p.after, pexpect.EOF)
        assert p.before.startswith(b', 51, 52'), p.before[:20]
        assert p.before.endswith(b', 99]\r\n'), p.before[-20:]

    def test_before_after(self):
        '''This tests expect() for some simple before/after things.
        '''
        p = pexpect.spawn('%s list100.py' % self.PYTHONBIN)
        self._before_after(p)

    def test_before_after_exact(self):
        '''This tests some simple before/after things, for
        expect_exact(). (Grahn broke it at one point.)
        '''
        p = pexpect.spawn('%s list100.py' % self.PYTHONBIN)
        # mangle the spawn so we test expect_exact() instead
        p.expect = p.expect_exact
        self._before_after(p)

    def _ordering(self, p):
        p.timeout = 5
        p.expect(b'>>> ')

        p.sendline('list(range(4*3))')
        self.assertEqual(p.expect([b'5,', b'5,']), 0)
        p.expect(b'>>> ')

        p.sendline(b'list(range(4*3))')
        self.assertEqual(p.expect([b'7,', b'5,']), 1)
        p.expect(b'>>> ')

        p.sendline(b'list(range(4*3))')
        self.assertEqual(p.expect([b'5,', b'7,']), 0)
        p.expect(b'>>> ')

        p.sendline(b'list(range(4*5))')
        self.assertEqual(p.expect([b'2,', b'12,']), 0)
        p.expect(b'>>> ')

        p.sendline(b'list(range(4*5))')
        self.assertEqual(p.expect([b'12,', b'2,']), 1)

    def test_ordering(self):
        '''This tests expect() for which pattern is returned
        when many may eventually match. I (Grahn) am a bit
        confused about what should happen, but this test passes
        with pexpect 2.1.
        '''
        p = pexpect.spawn(self.PYTHONBIN)
        self._ordering(p)

    def test_ordering_exact(self):
        '''This tests expect_exact() for which pattern is returned
        when many may eventually match. I (Grahn) am a bit
        confused about what should happen, but this test passes
        for the expect() method with pexpect 2.1.
        '''
        p = pexpect.spawn(self.PYTHONBIN)
        # mangle the spawn so we test expect_exact() instead
        p.expect = p.expect_exact
        self._ordering(p)

    def _greed(self, expect):
        # End at the same point: the one with the earliest start should win
        self.assertEqual(expect([b'3, 4', b'2, 3, 4']), 1)

        # Start at the same point: first pattern passed wins
        self.assertEqual(expect([b'5,', b'5, 6']), 0)

        # Same pattern passed twice: first instance wins
        self.assertEqual(expect([b'7, 8', b'7, 8, 9', b'7, 8']), 0)

    def _greed_read1(self, expect):
        # Here, one has an earlier start and a later end. When processing
        # one character at a time, the one that finishes first should win,
        # because we don't know about the other match when it wins.
        # If maxread > 1, this behaviour is currently undefined, although in
        # most cases the one that starts first will win.
        self.assertEqual(expect([b'1, 2, 3', b'2,']), 1)

    def test_greed(self):
        p = pexpect.spawn(self.PYTHONBIN + ' list100.py')
        self._greed(p.expect)

        p = pexpect.spawn(self.PYTHONBIN + ' list100.py', maxread=1)
        self._greed_read1(p.expect)

    def test_greed_exact(self):
        p = pexpect.spawn(self.PYTHONBIN + ' list100.py')
        self._greed(p.expect_exact)

        p = pexpect.spawn(self.PYTHONBIN + ' list100.py', maxread=1)
        self._greed_read1(p.expect_exact)

    def test_bad_arg(self):
        p = pexpect.spawn('cat')
        with assert_raises_msg(TypeError, 'must be one of'):
            p.expect(1)
        with assert_raises_msg(TypeError, 'must be one of'):
            p.expect([1, b'2'])

        with assert_raises_msg(TypeError, 'must be one of'):
            p.expect_exact(1)
        with assert_raises_msg(TypeError, 'must be one of'):
            p.expect_exact([1, b'2'])

    def test_timeout_none(self):
        p = pexpect.spawn('echo abcdef', timeout=None)
        p.expect('abc')
        p.expect_exact('def')
        p.expect(pexpect.EOF)

    def test_signal_handling(self):
        '''
            This tests the error handling of a signal interrupt (usually a
            SIGWINCH generated when a window is resized), but in this test, we
            are substituting an ALARM signal as this is much easier for testing
            and is treated the same as a SIGWINCH.
            
            To ensure that the alarm fires during the expect call, we are
            setting the signal to alarm after 1 second while the spawned process
            sleeps for 2 seconds prior to sending the expected output.
        '''
        def noop(x, y):
            pass
        signal.signal(signal.SIGALRM, noop)
    
        p1 = pexpect.spawn('%s sleep_for.py 2' % self.PYTHONBIN)
        p1.expect('READY', timeout=10)
        signal.alarm(1)
        p1.expect('END', timeout=10)

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(ExpectTestCase,'test')

#fout = open('delete_me_1','wb')
#fout.write(the_old_way)
#fout.close
#fout = open('delete_me_2', 'wb')
#fout.write(the_new_way)
#fout.close


########NEW FILE########
__FILENAME__ = test_filedescriptor
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
from pexpect import fdpexpect
import unittest
import PexpectTestCase
import os

class ExpectTestCase(PexpectTestCase.PexpectTestCase):
    def setUp(self):
        print(self.id())
        PexpectTestCase.PexpectTestCase.setUp(self)

    def test_fd (self):
        fd = os.open ('TESTDATA.txt', os.O_RDONLY)
        s = fdpexpect.fdspawn (fd)
        s.expect(b'This is the end of test data:')
        s.expect(pexpect.EOF)
        self.assertEqual(s.before, b' END\n')

    def test_maxread (self):
        fd = os.open ('TESTDATA.txt', os.O_RDONLY)
        s = fdpexpect.fdspawn (fd)
        s.maxread = 100
        s.expect('2')
        s.expect ('This is the end of test data:')
        s.expect (pexpect.EOF)
        self.assertEqual(s.before, b' END\n')

    def test_fd_isalive (self):
        fd = os.open ('TESTDATA.txt', os.O_RDONLY)
        s = fdpexpect.fdspawn(fd)
        assert s.isalive()
        os.close(fd)
        assert not s.isalive(), "Should not be alive after close()"

    def test_fd_isatty (self):
        fd = os.open ('TESTDATA.txt', os.O_RDONLY)
        s = fdpexpect.fdspawn (fd)
        assert not s.isatty()
        #os.close(fd)
        s.close()

###    def test_close_does_not_close_fd (self):
###        '''Calling close() on a fdpexpect.fdspawn object should not
###                close the underlying file descriptor.
###        '''
###        fd = os.open ('TESTDATA.txt', os.O_RDONLY)
###        s = fdpexpect.fdspawn (fd)
###        try:
###            s.close()
###            self.fail('Expected an Exception.')
###        except pexpect.ExceptionPexpect, e:
###            pass

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(ExpectTestCase, 'test')

#fout = open('delete_me_1','wb')
#fout.write(the_old_way)
#fout.close
#fout = open('delete_me_2', 'wb')
#fout.write(the_new_way)
#fout.close

########NEW FILE########
__FILENAME__ = test_FSM
import io
import sys
import unittest
try:
    import builtins
except ImportError:
    import __builtin__ as builtins

PY3 = (sys.version_info[0] >= 3)
input_name = 'input' if PY3 else 'raw_input'

from pexpect import FSM

class FSMTestCase(unittest.TestCase):
    def test_run_fsm(self):
        def _input(prompt):
            return "167 3 2 2 * * * 1 - ="
        orig_input = getattr(builtins, input_name)
        orig_stdout = sys.stdout
        setattr(builtins, input_name, _input)
        sys.stdout = sio = (io.StringIO if PY3 else io.BytesIO)()
        
        try:
            FSM.main()
        finally:
            setattr(builtins, input_name, orig_input)
            sys.stdout = orig_stdout
        
        printed = sio.getvalue()
        assert '2003' in printed, printed
        
        
if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_interact
#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
from __future__ import print_function
from __future__ import unicode_literals

import pexpect
import unittest
import PexpectTestCase

class InteractTestCase (PexpectTestCase.PexpectTestCase):

    def test_interact (self):
        p = pexpect.spawn(str('%s interact.py' % (self.PYTHONBIN,)))
        p.expect('<in >')
        p.sendline (b'Hello')
        p.sendline (b'there')
        p.sendline (b'Mr. Python')
        p.expect (b'<out>Hello')
        p.expect (b'<out>there')
        p.expect (b'<out>Mr. Python')
        assert p.isalive()
        p.sendeof ()
        p.expect (pexpect.EOF)
        assert not p.isalive()
        assert p.exitstatus == 0, (p.exitstatus, p.before)

    def test_interact_unicode (self):
        p = pexpect.spawnu(str('%s interact_unicode.py' % (self.PYTHONBIN,)))
        try:
            p.expect('<in >')
            p.sendline ('Hello')
            p.sendline ('theré')
            p.sendline ('Mr. Pyþon')
            p.expect ('<out>Hello')
            p.expect ('<out>theré')
            p.expect ('<out>Mr. Pyþon')
            assert p.isalive()
            p.sendeof ()
            p.expect (pexpect.EOF)
            assert not p.isalive()
            assert p.exitstatus == 0, (p.exitstatus, p.before)
        except:
            print(p.before)
            raise


if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(InteractTestCase, 'test')


########NEW FILE########
__FILENAME__ = test_isalive
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import unittest
import signal
import sys, os, time
import PexpectTestCase

class IsAliveTestCase(PexpectTestCase.PexpectTestCase):

    def test_expect_wait (self):
        '''This tests that calling wait on a finished process works as expected.
        '''
        p = pexpect.spawn('sleep 3')
        if not p.isalive():
            self.fail ('Child process is not alive. It should be.')
        time.sleep(1)
        p.wait()
        if p.isalive():
            self.fail ('Child process is not dead. It should be.')
        p = pexpect.spawn('sleep 3')
        if not p.isalive():
            self.fail ('Child process is not alive. It should be.')
        p.kill(9)
        time.sleep(1)
        try:
            p.wait()
        except pexpect.ExceptionPexpect:
            pass
        else:
            self.fail ('Should have raised ExceptionPython because you can\'t call wait on a dead process.')

    def test_signal_wait(self):
        '''Test calling wait with a process terminated by a signal.'''
        if not hasattr(signal, 'SIGALRM'):
            return 'SKIP'
        p = pexpect.spawn(sys.executable, ['alarm_die.py'])
        p.wait()
        assert p.exitstatus is None, p.exitstatus
        self.assertEqual(p.signalstatus, signal.SIGALRM)

    def test_expect_isalive_dead_after_normal_termination (self):
        p = pexpect.spawn('ls')
        p.expect(pexpect.EOF)
        time.sleep(1) # allow kernel status time to catch up with state.
        if p.isalive():
            self.fail ('Child process is not dead. It should be.')

    def test_expect_isalive_dead_after_SIGINT (self):
        p = pexpect.spawn('cat', timeout=5)
        if not p.isalive():
            self.fail ('Child process is not alive. It should be.')
        p.terminate()
        # Solaris is kind of slow.
        # Without this delay then p.expect(...) will not see
        # that the process is dead and it will timeout.
        time.sleep(1)
        p.expect(pexpect.EOF)
        if p.isalive():
            self.fail ('Child process is not dead. It should be.')

    def test_expect_isalive_dead_after_SIGKILL (self):
        p = pexpect.spawn('cat', timeout=3)
        if not p.isalive():
            self.fail ('Child process is not alive. It should be.')
        p.kill(9)
        # Solaris is kind of slow.
        # Without this delay then p.expect(...) will not see
        # that the process is dead and it will timeout.
        time.sleep(1)
        p.expect(pexpect.EOF)
        if p.isalive():
            self.fail ('Child process is not dead. It should be.')

    def test_forced_terminate(self):
        p = pexpect.spawn(sys.executable, ['needs_kill.py'])
        p.expect('READY')
        res = p.terminate(force=True)
        assert res, res

### Some platforms allow this. Some reset status after call to waitpid.
    def test_expect_isalive_consistent_multiple_calls (self):
        '''This tests that multiple calls to isalive() return same value.
        '''

        p = pexpect.spawn('cat')
        if not p.isalive():
            self.fail ('Child process is not alive. It should be.')
        if not p.isalive():
            self.fail ('Second call. Child process is not alive. It should be.')
        p.kill(9)
        p.expect(pexpect.EOF)
        if p.isalive():
            self.fail ('Child process is not dead. It should be.')
        if p.isalive():
            self.fail ('Second call. Child process is not dead. It should be.')

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(IsAliveTestCase, 'test')


########NEW FILE########
__FILENAME__ = test_log
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import unittest
import os
import tempfile
import PexpectTestCase

# the program cat(1) may display ^D\x08\x08 when \x04 (EOF, Ctrl-D) is sent
_CAT_EOF = b'^D\x08\x08'

class TestCaseLog(PexpectTestCase.PexpectTestCase):

    def test_log (self):
        log_message = 'This is a test.'
        filename = tempfile.mktemp()
        mylog = open(filename, 'wb')
        p = pexpect.spawn('echo', [log_message])
        p.logfile = mylog
        p.expect(pexpect.EOF)
        p.logfile = None
        mylog.close()
        with open(filename, 'rb') as f:
            lf = f.read()
        os.unlink(filename)
        self.assertEqual(lf.rstrip(), log_message.encode('ascii'))

    def test_log_logfile_read (self):
        log_message = 'This is a test.'
        filename = tempfile.mktemp()
        mylog = open(filename, 'wb')
        p = pexpect.spawn('cat')
        p.logfile_read = mylog
        p.sendline(log_message)
        p.sendeof()
        p.expect(pexpect.EOF)
        p.logfile = None
        mylog.close()
        with open(filename, 'rb') as f:
            lf = f.read()
        os.unlink (filename)
        lf = lf.replace(_CAT_EOF, b'')
        self.assertEqual(lf, b'This is a test.\r\nThis is a test.\r\n')

    def test_log_logfile_send (self):
        log_message = b'This is a test.'
        filename = tempfile.mktemp()
        mylog = open (filename, 'wb')
        p = pexpect.spawn('cat')
        p.logfile_send = mylog
        p.sendline(log_message)
        p.sendeof()
        p.expect (pexpect.EOF)
        p.logfile = None
        mylog.close()
        with open(filename, 'rb') as f:
            lf = f.read()
        os.unlink(filename)
        lf = lf.replace(b'\x04', b'')
        self.assertEqual(lf.rstrip(), log_message)

    def test_log_send_and_received (self):

        '''The logfile should have the test message three time -- once for the
        data we sent. Once for the data that cat echos back as characters are
        typed. And once for the data that cat prints after we send a linefeed
        (sent by sendline). '''

        log_message = 'This is a test.'
        filename = tempfile.mktemp()
        mylog = open(filename, 'wb')
        p = pexpect.spawn('cat')
        p.logfile = mylog
        p.sendline(log_message)
        p.sendeof()
        p.expect (pexpect.EOF)
        p.logfile = None
        mylog.close()
        with open(filename, 'rb') as f:
            lf = f.read()
        os.unlink(filename)
        lf = lf.replace(b'\x04', b'').replace(_CAT_EOF, b'')
        self.assertEqual(lf,
                b'This is a test.\nThis is a test.\r\nThis is a test.\r\n')

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(TestCaseLog,'test')


########NEW FILE########
__FILENAME__ = test_misc
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import unittest
import PexpectTestCase
import os, sys
import re
import signal
import time

# the program cat(1) may display ^D\x08\x08 when \x04 (EOF, Ctrl-D) is sent
_CAT_EOF = b'^D\x08\x08'

class TestCaseMisc(PexpectTestCase.PexpectTestCase):

    def test_isatty (self):
        child = pexpect.spawn('cat')
        assert child.isatty(), "Not returning True. Should always be True."

    def test_read (self):
        child = pexpect.spawn('cat')
        child.sendline ("abc")
        child.sendeof()
        self.assertEqual(child.read(0), b'')
        self.assertEqual(child.read(1), b'a')
        self.assertEqual(child.read(1), b'b')
        self.assertEqual(child.read(1), b'c')
        self.assertEqual(child.read(2), b'\r\n')
        remaining = child.read().replace(_CAT_EOF, b'')
        self.assertEqual(remaining, b'abc\r\n')

    def test_readline (self):
        '''See the note in test_readlines() for an explaination as to why
        I allow line3 and line4 to return multiple patterns.
        Basically, this is done to handle a valid condition on slow systems.
        '''
        child = pexpect.spawn('cat')
        child.sendline ("abc")
        time.sleep(0.5)
        child.sendline ("123")
        time.sleep(0.5)
        child.sendeof()
        line1 = child.readline(0)
        line2 = child.readline()
        line3 = child.readline(2)
        line4 = child.readline(1)
        line5 = child.readline()
        time.sleep(1) # time for child to "complete" ;/
        assert not child.isalive(), child.isalive()
        assert child.exitstatus == 0, child.exitstatus
        self.assertEqual(line1, b'')
        self.assertEqual(line2, b'abc\r\n')
        assert (line3 == b'abc\r\n' or line3 == b'123\r\n'), line3
        assert (line4 == b'123\r\n' or line4 == b'abc\r\n'), line4
        self.assertEqual(line5, b'123\r\n')

    def test_iter (self):
        '''See the note in test_readlines() for an explaination as to why
        I allow line3 and line4 to return multiple patterns.
        Basically, this is done to handle a valid condition on slow systems.
        '''
        child = pexpect.spawn('cat')
        child.sendline ("abc")
        time.sleep(0.5)
        child.sendline ("123")
        time.sleep(0.5)
        child.sendeof()
        # Don't use ''.join() because we want to test the ITERATOR.
        page = b''
        for line in child:
            page += line
        page = page.replace(_CAT_EOF, b'')
        # This is just a really bad test all together, we should write our
        # own 'cat' utility that only writes to stdout after EOF is recv,
        # this must take into consideration all possible platform impl.'s
        # of `cat', and their related terminal and line-buffer handling
        assert (page == b'abc\r\nabc\r\n123\r\n123\r\n' or
                page == b'abc\r\n123\r\nabc\r\n123\r\n' or
                page == b'abc\r\n123abc\r\n\r\n123\r\n') , \
               "iterator did not work. page=%r"(page,)

    def test_readlines(self):
        '''Note that on some slow or heavily loaded systems that the lines
        coming back from 'cat' may come even after the EOF.
        We except to see two copies of the lines we send 'cat'.
        The first line is the TTY echo, the second line is from 'cat'.
        Usually 'cat' will respond with 'abc' before we have a chance to
        send the second line, '123'. If this does not happen then the
        lines may appear out of order. This is technically not an error.
        That's just the nature of asynchronous communication.
        This is why the assert will allow either of the two possible
        patterns to be returned by lineslined(). The (lame) alternative is
        to put a long sleep between the two sendline() calls, but then
        I have to make assumptions about how fast 'cat' can reply.
        '''
        child = pexpect.spawn('cat')
        child.sendline ("abc")
        time.sleep(0.5)
        child.sendline ("123")
        time.sleep(0.5)
        child.sendeof()
        page = b''.join(child.readlines()).replace(_CAT_EOF, b'')
        assert (page == b'abc\r\nabc\r\n123\r\n123\r\n' or
                page == b'abc\r\n123\r\nabc\r\n123\r\n'), (
               "readlines() did not work. page=%r" % (page,))

        time.sleep(1) # time for child to "complete" ;/
        assert not child.isalive(), child.isalive()
        assert child.exitstatus == 0, child.exitstatus

    def test_write (self):
        child = pexpect.spawn('cat')
        child.write('a')
        child.write('\r')
        self.assertEqual(child.readline(), b'a\r\n')

    def test_writelines (self):
        child = pexpect.spawn('cat')
        child.writelines(['abc','123','xyz','\r'])
        child.sendeof()
        line = child.readline()
        assert line == b'abc123xyz\r\n', (
            "writelines() did not work. line=%r" % (line,))

    def test_eof(self):
        child = pexpect.spawn('cat')
        child.sendeof()
        try:
            child.expect ('the unexpected')
        except:
            pass
        assert child.eof(), "child.eof() did not return True"

    def test_terminate(self):
        child = pexpect.spawn('cat')
        child.terminate(force=1)
        assert child.terminated, "child.terminated is not True"

    def test_sighup(self):
        # If a parent process sets an Ignore handler for SIGHUP (as on Fedora's
        # build machines), this test breaks. We temporarily restore the default
        # handler, so the child process will quit. However, we can't simply
        # replace any installed handler, because getsignal returns None for
        # handlers not set in Python code, so we wouldn't be able to restore
        # them.
        if signal.getsignal(signal.SIGHUP) == signal.SIG_IGN:
            signal.signal(signal.SIGHUP, signal.SIG_DFL)
            restore_sig_ign = True
        else:
            restore_sig_ign = False

        try:
            child = pexpect.spawn(sys.executable + ' getch.py', ignore_sighup=True)
            child.expect('READY')
            child.kill(signal.SIGHUP)
            for _ in range(10):
                if not child.isalive():
                    raise AssertionError('Child should not have exited.')
                time.sleep(0.1)

            child = pexpect.spawn(sys.executable + ' getch.py', ignore_sighup=False)
            child.expect('READY')
            child.kill(signal.SIGHUP)
            for _ in range(10):
                if not child.isalive():
                    break
                time.sleep(0.1)
            else:
                raise AssertionError('Child should have exited.')

        finally:
            if restore_sig_ign:
                signal.signal(signal.SIGHUP, signal.SIG_IGN)

    def test_bad_child_pid(self):
        child = pexpect.spawn('cat')
        child.terminate(force=1)
        child.terminated = 0 # Force invalid state to test code
        try:
            child.isalive()
        except pexpect.ExceptionPexpect:
            pass
        else:
            self.fail ("child.isalive() should have raised a pexpect.ExceptionPexpect")
        child.terminated = 1 # Force back to valid state so __del__ won't complain
    def test_bad_arguments (self):
        '''This tests that we get a graceful error when passing bad arguments.'''
        try:
            p = pexpect.spawn(1)
        except pexpect.ExceptionPexpect:
            pass
        else:
            self.fail ("pexpect.spawn(1) should have raised a pexpect.ExceptionPexpect.")
        try:
            p = pexpect.spawn('ls', '-la') # should really use pexpect.spawn('ls', ['-ls'])
        except TypeError:
            pass
        else:
            self.fail ("pexpect.spawn('ls', '-la') should have raised a TypeError.")
        try:
            p = pexpect.spawn('cat')
            p.close()
            p.read_nonblocking(size=1, timeout=3)
        except ValueError:
            pass
        else:
            self.fail ("read_nonblocking on closed spawn object should have raised a ValueError.")
    def test_isalive(self):
        child = pexpect.spawn('cat')
        assert child.isalive(), child.isalive()
        child.sendeof()
        child.expect(pexpect.EOF)
        assert not child.isalive(), child.isalive()
    def test_bad_type_in_expect(self):
        child = pexpect.spawn('cat')
        try:
            child.expect({}) # We don't support dicts yet. Should give TypeError
        except TypeError:
            pass
        else:
            self.fail ("child.expect({}) should have raised a TypeError")

    def test_env(self):
        default = pexpect.run('env')
        userenv = pexpect.run('env', env={'foo':'pexpect'})
        assert default!=userenv, "'default' and 'userenv' should be different"
        assert b'foo' in userenv and b'pexpect' in userenv, "'foo' and 'pexpect' should be in 'userenv'"

    def test_cwd (self): # This assumes 'pwd' and '/tmp' exist on this platform.
        default = pexpect.run('pwd')
        tmpdir =  pexpect.run('pwd', cwd='/tmp')
        assert default!=tmpdir, "'default' and 'tmpdir' should be different"
        assert (b'tmp' in tmpdir), "'tmp' should be returned by 'pwd' command"

    def test_which (self):
        p = os.defpath
        ep = os.environ['PATH']
        os.defpath = ":/tmp"
        os.environ['PATH'] = ":/tmp"
        wp = pexpect.which ("ticker.py")
        assert wp == 'ticker.py', "Should return a string. Returned %s" % wp
        os.defpath = "/tmp"
        os.environ['PATH'] = "/tmp"
        wp = pexpect.which ("ticker.py")
        assert wp == None, "Executable should not be found. Returned %s" % wp
        os.defpath = p
        os.environ['PATH'] = ep

    def test_searcher_re (self):
        # This should be done programatically, if we copied and pasted output,
        # there wouldnt be a whole lot to test, really, other than our ability
        # to copy and paste correctly :-)
        ss = pexpect.searcher_re ([
            re.compile('this'), re.compile('that'),
            re.compile('and'), re.compile('the'),
            re.compile('other') ])
        out = ('searcher_re:\n    0: re.compile("this")\n    '
               '1: re.compile("that")\n    2: re.compile("and")\n    '
               '3: re.compile("the")\n    4: re.compile("other")')
        assert ss.__str__() == out, (ss.__str__(), out)
        ss = pexpect.searcher_re ([
            pexpect.TIMEOUT, re.compile('this'),
            re.compile('that'), re.compile('and'),
            pexpect.EOF,re.compile('other')
            ])
        out = ('searcher_re:\n    0: TIMEOUT\n    1: re.compile("this")\n    '
               '2: re.compile("that")\n    3: re.compile("and")\n    '
               '4: EOF\n    5: re.compile("other")')
        assert ss.__str__() == out, (ss.__str__(), out)

    def test_searcher_string (self):
        ss = pexpect.searcher_string ([
            'this', 'that', 'and', 'the', 'other' ])
        out = ('searcher_string:\n    0: "this"\n    1: "that"\n    '
               '2: "and"\n    3: "the"\n    4: "other"')
        assert ss.__str__() == out, (ss.__str__(), out)
        ss = pexpect.searcher_string ([
            'this', pexpect.EOF, 'that', 'and',
            'the', 'other', pexpect.TIMEOUT ])
        out = ('searcher_string:\n    0: "this"\n    1: EOF\n    '
               '2: "that"\n    3: "and"\n    4: "the"\n    '
               '5: "other"\n    6: TIMEOUT')
        assert ss.__str__() == out, (ss.__str__(), out)

    def test_nonnative_pty_fork(self):
        class spawn_ourptyfork(pexpect.spawn):
            def _spawn(self, command, args=[]):
                self.use_native_pty_fork = False
                pexpect.spawn._spawn(self, command, args)

        p = spawn_ourptyfork('cat')
        p.sendline('abc')
        p.expect('abc')
        p.sendeof()

    def test_exception_tb(self):
        p = pexpect.spawn('sleep 1')
        try:
            p.expect('BLAH')
        except pexpect.ExceptionPexpect as e:
            # get_trace should filter out frames in pexpect's own code
            tb = e.get_trace()
            assert 'raise ' not in tb, tb
        else:
            assert False, "Should have raised an exception."

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(TestCaseMisc,'test')


########NEW FILE########
__FILENAME__ = test_missing_command
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import unittest
import PexpectTestCase

class MissingCommandTestCase (PexpectTestCase.PexpectTestCase):
    def testMissingCommand(self):
        try:
            i = pexpect.spawn ('ZXQYQZX')
        except Exception:
            pass
        else:
            self.fail('Expected an Exception.')

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(MissingCommandTestCase,'test')


########NEW FILE########
__FILENAME__ = test_performance
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
from __future__ import print_function

import unittest, time, sys
import pexpect
import PexpectTestCase

# This isn't exactly a unit test, but it fits in nicely with the rest of the tests.

class PerformanceTestCase (PexpectTestCase.PexpectTestCase):

    '''Testing the performance of expect, with emphasis on wading through long
    inputs. '''
    
    if sys.version_info[0] >= 3:
        @staticmethod
        def _iter_n(n):
            s = 'for n in range(1, %d+1): print(n)' % n
            return s.encode('ascii')

    else:
        @staticmethod
        def _iter_n(n):
            return 'for n in range(1, %d+1): print(n)' % n    

    def plain_range(self, n):
        e = pexpect.spawn('python')
        self.assertEqual(e.expect(b'>>>'), 0)
        e.sendline(self._iter_n(n))
        self.assertEqual(e.expect(br'\.{3}'), 0)
        e.sendline(b'')
        self.assertEqual(e.expect([b'inquisition', '%d' % n]), 1)

    def window_range(self, n):
        e = pexpect.spawn('python')
        self.assertEqual(e.expect(b'>>>'), 0)
        e.sendline(self._iter_n(n))
        self.assertEqual(e.expect(r'\.{3}'), 0)
        e.sendline(b'')
        self.assertEqual(e.expect([b'inquisition', '%d' % n], searchwindowsize=20), 1)

    def exact_range(self, n):
        e = pexpect.spawn('python')
        self.assertEqual(e.expect_exact([b'>>>']), 0)
        e.sendline(self._iter_n(n))
        self.assertEqual(e.expect_exact([b'...']), 0)
        e.sendline(b'')
        self.assertEqual(e.expect_exact([b'inquisition', '%d' % n],timeout=520), 1)

    def ewin_range(self, n):
        e = pexpect.spawn('python')
        self.assertEqual(e.expect_exact([b'>>>']), 0)
        e.sendline(self._iter_n(n))
        self.assertEqual(e.expect_exact([b'...']), 0)
        e.sendline(b'')
        self.assertEqual(e.expect_exact([b'inquisition', '%d' % n], searchwindowsize=20), 1)

    def faster_range(self, n):
        e = pexpect.spawn('python')
        self.assertEqual(e.expect(b'>>>'), 0)
        e.sendline(('list(range(1, %d+1))' % n).encode('ascii'))
        self.assertEqual(e.expect([b'inquisition', '%d' % n]), 1)

    def test_100000(self):
        print()
        start_time = time.time()
        self.plain_range (100000)
        print("100000 calls to plain_range:", (time.time() - start_time))
        start_time = time.time()
        self.window_range(100000)
        print("100000 calls to window_range:", (time.time() - start_time))
        start_time = time.time()
        self.exact_range (100000)
        print("100000 calls to exact_range:", (time.time() - start_time))
        start_time = time.time()
        self.ewin_range  (100000)
        print("100000 calls to ewin_range:", (time.time() - start_time))
        start_time = time.time()
        self.faster_range(100000)
        print("100000 calls to faster_range:", (time.time() - start_time))

if __name__ == "__main__":
    unittest.main()

suite = unittest.makeSuite(PerformanceTestCase,'test')

########NEW FILE########
__FILENAME__ = test_pickling
#!/usr/bin/env python
import pickle
import unittest

from pexpect import ExceptionPexpect

class PickleTest(unittest.TestCase):
    def test_picking(self):
        e = ExceptionPexpect('Oh noes!')
        clone = pickle.loads(pickle.dumps(e))
        self.assertEqual(e.value, clone.value)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_psh
#!/usr/bin/env python
import unittest

from pexpect import pxssh, psh
from test_pxssh import SSHTestBase

class PshTestBase(SSHTestBase):
    def test_psh(self):
        ssh = pxssh.pxssh()
        ssh.login('server', 'user', 's3cret')
        sh = psh.psh(ssh)
        res = set(sh.ls())
        self.assertEqual(res, set([b'file1.py', b'file2.html']))

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = test_pxssh
#!/usr/bin/env python
import os

import unittest

from pexpect import pxssh

class SSHTestBase(unittest.TestCase):
    def setUp(self):
        self.orig_path = os.environ.get('PATH')
        fakessh_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), 'fakessh'))
        os.environ['PATH'] = fakessh_dir + \
                    ((os.pathsep + self.orig_path) if self.orig_path else '')

    def tearDown(self):
        if self.orig_path:
            os.environ['PATH'] = self.orig_path
        else:
            del os.environ['PATH']

class PxsshTestCase(SSHTestBase):
    def test_fake_ssh(self):
        ssh = pxssh.pxssh()
        #ssh.logfile_read = sys.stdout  # DEBUG
        ssh.login('server', 'me', password='s3cret')
        ssh.sendline('ping')
        ssh.expect('pong', timeout=10)
        assert ssh.prompt(timeout=10)
        ssh.logout()

    def test_wrong_pw(self):
        ssh = pxssh.pxssh()
        try:
            ssh.login('server', 'me', password='wr0ng')
        except pxssh.ExceptionPxssh:
            pass
        else:
            assert False, 'Password should have been refused'

    def test_failed_set_unique_prompt(self):
        ssh = pxssh.pxssh()
        ssh.set_unique_prompt = lambda: False
        try:
            ssh.login('server', 'me', password='s3cret',
                      auto_prompt_reset=True)
        except pxssh.ExceptionPxssh:
            pass
        else:
            assert False, 'should have raised exception, pxssh.ExceptionPxssh'


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_run
#!/usr/bin/env python
# encoding: utf-8
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import unittest
import subprocess
import sys
import PexpectTestCase

# TODO Many of these test cases blindly assume that sequential
# TODO listing of the /bin directory will yield the same results.
# TODO This may not always be true, but seems adequate for testing for now.
# TODO I should fix this at some point.

unicode_type = str if pexpect.PY3 else unicode

def timeout_callback (d):
#    print d["event_count"],
    if d["event_count"]>3:
        return 1
    return 0

class RunFuncTestCase(PexpectTestCase.PexpectTestCase):
    runfunc = staticmethod(pexpect.run)
    cr = b'\r'
    empty = b''
    prep_subprocess_out = staticmethod(lambda x: x)

    def test_run_exit (self):
        (data, exitstatus) = self.runfunc('python exit1.py', withexitstatus=1)
        assert exitstatus == 1, "Exit status of 'python exit1.py' should be 1."

    def test_run (self):
        the_old_way = subprocess.Popen(args=['ls', '-l', '/bin'],
                stdout=subprocess.PIPE).communicate()[0].rstrip()
        (the_new_way, exitstatus) = self.runfunc('ls -l /bin', withexitstatus=1)
        the_new_way = the_new_way.replace(self.cr, self.empty).rstrip()
        self.assertEqual(self.prep_subprocess_out(the_old_way), the_new_way)
        self.assertEqual(exitstatus, 0)

    def test_run_callback (self): # TODO it seems like this test could block forever if run fails...
        self.runfunc("cat", timeout=1, events={pexpect.TIMEOUT:timeout_callback})

    def test_run_bad_exitstatus (self):
        (the_new_way, exitstatus) = self.runfunc('ls -l /najoeufhdnzkxjd',
                                                    withexitstatus=1)
        assert exitstatus != 0

class RunUnicodeFuncTestCase(RunFuncTestCase):
    runfunc = staticmethod(pexpect.runu)
    cr = b'\r'.decode('ascii')
    empty = b''.decode('ascii')
    prep_subprocess_out = staticmethod(lambda x: x.decode('utf-8', 'replace'))
    def test_run_unicode(self):
        if pexpect.PY3:
            c = chr(254)   # þ
            pattern = '<in >'
        else:
            c = unichr(254)  # analysis:ignore
            pattern = '<in >'.decode('ascii')

        def callback(d):
            if d['event_count'] == 0:
                return c + '\n'
            else:
                return True  # Stop the child process

        output = pexpect.runu(sys.executable + ' echo_w_prompt.py',
                              env={'PYTHONIOENCODING':'utf-8'},
                              events={pattern:callback})
        assert isinstance(output, unicode_type), type(output)
        assert '<out>'+c in output, output

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_run_out_of_pty
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import unittest
import PexpectTestCase

class ExpectTestCase(PexpectTestCase.PexpectTestCase):
    # This takes too long to run and isn't all that interesting of a test.
    def OFF_test_run_out_of_pty (self):
        '''This assumes that the tested platform has < 10000 pty devices.
        This test currently does not work under Solaris.
        Under Solaris it runs out of file descriptors first and
        ld.so starts to barf:
            ld.so.1: pt_chmod: fatal: /usr/lib/libc.so.1: Too many open files
        '''
        plist=[]
        for count in range (0,10000):
                try:
                        plist.append (pexpect.spawn('ls -l'))
                except pexpect.ExceptionPexpect:
                        for c in range (0, count):
                            plist[c].close()
                        return
                except Exception:
                        err = sys.exc_info()[1]
                        self.fail ('Expected ExceptionPexpect. ' + str(err))
        self.fail ('Could not run out of pty devices. This may be OK.')

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(ExpectTestCase,'test')


########NEW FILE########
__FILENAME__ = test_screen
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

from pexpect import screen
import unittest
import PexpectTestCase

fill1_target='XXXXXXXXXX\n' + \
'XOOOOOOOOX\n' + \
'XO::::::OX\n' + \
'XO:oooo:OX\n' + \
'XO:o..o:OX\n' + \
'XO:o..o:OX\n' + \
'XO:oooo:OX\n' + \
'XO::::::OX\n' + \
'XOOOOOOOOX\n' + \
'XXXXXXXXXX'
fill2_target = 'XXXXXXXXXXX\n' + \
'XOOOOOOOOOX\n' + \
'XO:::::::OX\n' + \
'XO:ooooo:OX\n' + \
'XO:o...o:OX\n' + \
'XO:o.+.o:OX\n' + \
'XO:o...o:OX\n' + \
'XO:ooooo:OX\n' + \
'XO:::::::OX\n' + \
'XOOOOOOOOOX\n' + \
'XXXXXXXXXXX'
put_target = '\\.3.5.7.9/\n' + \
'.........2\n' + \
'3.........\n' + \
'.........4\n' + \
'5...\\/....\n' + \
'..../\\...6\n' + \
'7.........\n' + \
'.........8\n' + \
'9.........\n' + \
'/2.4.6.8.\\'
scroll_target = '\\.3.5.7.9/\n' + \
'\\.3.5.7.9/\n' + \
'\\.3.5.7.9/\n' + \
'\\.3.5.7.9/\n' + \
'5...\\/....\n' + \
'..../\\...6\n' + \
'/2.4.6.8.\\\n' + \
'/2.4.6.8.\\\n' + \
'/2.4.6.8.\\\n' + \
'/2.4.6.8.\\'
insert_target = 'ZXZZZZZZXZ\n' +\
'.........2\n' +\
'3.........\n' +\
'.........4\n' +\
'Z5...\\/...\n' +\
'..../Z\\...\n' +\
'7.........\n' +\
'.........8\n' +\
'9.........\n' +\
'ZZ/2.4.6ZZ'
get_region_target = ['......', '.\\/...', './\\...', '......']

class screenTestCase (PexpectTestCase.PexpectTestCase):
    def make_screen_with_put (self):
        s = screen.screen(10,10)
        s.fill ('.')
        for r in range (1,s.rows + 1):
            if r % 2:
                s.put_abs (r, 1, str(r))
            else:
                s.put_abs (r, s.cols, str(r))
        for c in range (1,s.cols + 1):
            if c % 2:
                s.put_abs (1, c, str(c))
            else:
                s.put_abs (s.rows, c, str(c))
        s.put_abs(1,1, '\\')
        s.put_abs(1,s.cols, '/')
        s.put_abs(s.rows,1,'/')
        s.put_abs(s.rows, s.cols, '\\')
        s.put_abs(5,5,'\\')
        s.put_abs(5,6,'/')
        s.put_abs(6,5,'/')
        s.put_abs(6,6,'\\')
        return s

    def test_fill (self):
        s = screen.screen (10,10)
        s.fill_region (10,1,1,10,'X')
        s.fill_region (2,2,9,9,'O')
        s.fill_region (8,8,3,3,':')
        s.fill_region (4,7,7,4,'o')
        s.fill_region (6,5,5,6,'.')
        assert str(s) == fill1_target

        s = screen.screen (11,11)
        s.fill_region (1,1,11,11,'X')
        s.fill_region (2,2,10,10,'O')
        s.fill_region (9,9,3,3,':')
        s.fill_region (4,8,8,4,'o')
        s.fill_region (7,5,5,7,'.')
        s.fill_region (6,6,6,6,'+')
        assert str(s) == fill2_target
    def test_put (self):
        s = self.make_screen_with_put()
        assert str(s) == put_target
    def test_get_region (self):
        s = self.make_screen_with_put()
        r = s.get_region (4,4,7,9)
        assert r == get_region_target

    def test_cursor_save (self):
        s = self.make_screen_with_put()
        s.cursor_home (5,5)
        c = s.get()
        s.cursor_save()
        s.cursor_home()
        s.cursor_forward()
        s.cursor_down()
        s.cursor_unsave()
        assert s.cur_r == 5 and s.cur_c == 5
        assert c == s.get()
    def test_scroll (self):
        s = self.make_screen_with_put()
        s.scroll_screen_rows (1,4)
        s.scroll_down(); s.scroll_down(); s.scroll_down()
        s.scroll_down(); s.scroll_down(); s.scroll_down()
        s.scroll_screen_rows (7,10)
        s.scroll_up(); s.scroll_up(); s.scroll_up()
        s.scroll_up(); s.scroll_up(); s.scroll_up()
        assert str(s) == scroll_target
    def test_insert (self):
        s = self.make_screen_with_put()
        s.insert_abs (10,1,'Z')
        s.insert_abs (1,1,'Z')
        s.insert_abs (1,1,'Z')
        s.insert_abs (1,1,'Z')
        s.insert_abs (1,1,'Z')
        s.insert_abs (1,1,'Z')
        s.insert_abs (10,1,'Z')
        s.insert_abs (1,1,'Z')
        s.insert_abs (1,1,'Z')
        s.insert_abs (5,1,'Z')
        s.insert_abs (6,6,'Z')
        s.cursor_home (1,1) # Also test relative insert.
        s.insert ('Z')
        s.insert ('Z')
        s.insert ('Z')
        s.insert ('Z')
        s.insert_abs (1,8,'X')
        s.insert_abs (1,2,'X')
        s.insert_abs (10,9,'Z')
        s.insert_abs (10,9,'Z')
        assert str(s) == insert_target
 #   def test_write (self):
 #       s = screen.screen (6,65)
 #       s.fill('.')
 #       s.cursor_home()
 #       for c in write_text:
 #           s.write (c)
 #       print str(s)
 #       assert str(s) == write_target
 #   def test_tetris (self):
 #       s = screen.screen (24,80)
 #       tetris_text = open ('tetris.data').read()
 #       for c in tetris_text:
 #           s.write (c)
 #       assert str(s) == tetris_target

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(screenTestCase,'test')



########NEW FILE########
__FILENAME__ = test_timeout_pattern
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
from __future__ import with_statement  # bring 'with' stmt to py25
import pexpect
import unittest
import PexpectTestCase
import sys

class Exp_TimeoutTestCase(PexpectTestCase.PexpectTestCase):
    def test_matches_exp_timeout (self):
        '''This tests that we can raise and catch TIMEOUT.
        '''
        try:
            raise pexpect.TIMEOUT("TIMEOUT match test")
        except pexpect.TIMEOUT:
            pass
            #print "Correctly caught TIMEOUT when raising TIMEOUT."
        else:
            self.fail('TIMEOUT not caught by an except TIMEOUT clause.')

    def test_pattern_printout (self):
        '''Verify that a TIMEOUT returns the proper patterns it is trying to match against.
        Make sure it is returning the pattern from the correct call.'''
        try:
            p = pexpect.spawn('cat')
            p.sendline('Hello')
            p.expect('Hello')
            p.expect('Goodbye',timeout=5)
        except pexpect.TIMEOUT:
            assert p.match_index == None
        else:
            self.fail("Did not generate a TIMEOUT exception.")

    def test_exp_timeout_notThrown (self):
        '''Verify that a TIMEOUT is not thrown when we match what we expect.'''
        try:
            p = pexpect.spawn('cat')
            p.sendline('Hello')
            p.expect('Hello')
        except pexpect.TIMEOUT:
            self.fail("TIMEOUT caught when it shouldn't be raised because we match the proper pattern.")

    def test_stacktraceMunging (self):
        '''Verify that the stack trace returned with a TIMEOUT instance does not contain references to pexpect.'''
        try:
            p = pexpect.spawn('cat')
            p.sendline('Hello')
            p.expect('Goodbye',timeout=5)
        except pexpect.TIMEOUT:
            err = sys.exc_info()[1]
            if err.get_trace().count("pexpect/__init__.py") != 0:
                self.fail("The TIMEOUT get_trace() referenced pexpect.py. "
                    "It should only reference the caller.\n" + err.get_trace())

    def test_correctStackTrace (self):
        '''Verify that the stack trace returned with a TIMEOUT instance correctly handles function calls.'''
        def nestedFunction (spawnInstance):
            spawnInstance.expect("junk", timeout=3)

        try:
            p = pexpect.spawn('cat')
            p.sendline('Hello')
            nestedFunction(p)
        except pexpect.TIMEOUT:
            err = sys.exc_info()[1]
            if err.get_trace().count("nestedFunction") == 0:
                self.fail("The TIMEOUT get_trace() did not show the call "
                    "to the nestedFunction function.\n" + str(err) + "\n"
                    + err.get_trace())

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(Exp_TimeoutTestCase,'test')

########NEW FILE########
__FILENAME__ = test_unicode
# -*- coding: utf-8 -*-
from __future__ import unicode_literals

import platform
import tempfile

import pexpect
import unittest
import PexpectTestCase

# the program cat(1) may display ^D\x08\x08 when \x04 (EOF, Ctrl-D) is sent
_CAT_EOF = '^D\x08\x08'

class UnicodeTests(PexpectTestCase.PexpectTestCase):
    def test_expect_basic (self):
        p = pexpect.spawnu('cat')
        p.sendline('Hello')
        p.sendline('there')
        p.sendline('Mr. þython') # þ is more like th than p, but never mind
        p.expect('Hello')
        p.expect('there')
        p.expect('Mr. þython')
        p.sendeof ()
        p.expect (pexpect.EOF)

    def test_expect_exact_basic (self):
        p = pexpect.spawnu('cat')
        p.sendline('Hello')
        p.sendline('there')
        p.sendline('Mr. þython')
        p.expect_exact('Hello')
        p.expect_exact('there')
        p.expect_exact('Mr. þython')
        p.sendeof()
        p.expect_exact (pexpect.EOF)

    def test_expect_echo (self):
        '''This tests that echo can be turned on and off.
        '''
        p = pexpect.spawnu('cat', timeout=10)
        self._expect_echo(p)

    def test_expect_echo_exact (self):
        '''Like test_expect_echo(), but using expect_exact().
        '''
        p = pexpect.spawnu('cat', timeout=10)
        p.expect = p.expect_exact
        self._expect_echo(p)

    def _expect_echo (self, p):
        p.sendline('1234') # Should see this twice (once from tty echo and again from cat).
        index = p.expect (['1234', 'abcdé', 'wxyz', pexpect.EOF, pexpect.TIMEOUT])
        assert index == 0, (index, p.before)
        index = p.expect (['1234', 'abcdé', 'wxyz', pexpect.EOF])
        assert index == 0, index
        p.setecho(0) # Turn off tty echo
        p.sendline('abcdé') # Now, should only see this once.
        p.sendline('wxyz') # Should also be only once.
        index = p.expect ([pexpect.EOF,pexpect.TIMEOUT, 'abcdé', 'wxyz', '1234'])
        assert index == 2, index
        index = p.expect ([pexpect.EOF, 'abcdé', 'wxyz', '7890'])
        assert index == 2, index
        p.setecho(1) # Turn on tty echo
        p.sendline('7890') # Should see this twice.
        index = p.expect ([pexpect.EOF, 'abcdé', 'wxyz', '7890'])
        assert index == 3, index
        index = p.expect ([pexpect.EOF, 'abcdé', 'wxyz', '7890'])
        assert index == 3, index
        p.sendeof()

    def test_log_unicode(self):
        msg = "abcΩ÷"
        filename_send = tempfile.mktemp()
        filename_read = tempfile.mktemp()
        p = pexpect.spawnu('cat')
        if platform.python_version_tuple() < ('3', '0', '0'):
            import codecs
            def open(fname, mode, **kwargs):
                if 'newline' in kwargs:
                    del kwargs['newline']
                return codecs.open(fname, mode, **kwargs)
        else:
            import io
            open = io.open

        p.logfile_send = open(filename_send, 'w', encoding='utf-8')
        p.logfile_read = open(filename_read, 'w', encoding='utf-8')
        p.sendline(msg)
        p.sendeof()
        p.expect(pexpect.EOF)
        p.close()
        p.logfile_send.close()
        p.logfile_read.close()

        # ensure the 'send' log is correct,
        with open(filename_send, 'r', encoding='utf-8') as f:
            self.assertEqual(f.read(), msg + '\n\x04')

        # ensure the 'read' log is correct,
        with open(filename_read, 'r', encoding='utf-8', newline='') as f:
            output = f.read().replace(_CAT_EOF, '')
            self.assertEqual(output, (msg + '\r\n')*2 )


    def test_spawn_expect_ascii_unicode(self):
        # A bytes-based spawn should be able to handle ASCII-only unicode, for
        # backwards compatibility.
        p = pexpect.spawn('cat')
        p.sendline('Camelot')
        p.expect('Camelot')

        p.sendline('Aargh')
        p.sendline('Aårgh')
        p.expect_exact('Aargh')

        p.sendeof()
        p.expect(pexpect.EOF)

    def test_spawn_send_unicode(self):
        # A bytes-based spawn should be able to send arbitrary unicode
        p = pexpect.spawn('cat')
        p.sendline('3½')
        p.sendeof()
        p.expect(pexpect.EOF)

    def test_spawn_utf8_incomplete(self):
        # This test case ensures correct incremental decoding, which
        # otherwise fails when the stream inspected by os.read()
        # does not align exactly at a utf-8 multibyte boundry:
        #    UnicodeDecodeError: 'utf8' codec can't decode byte 0xe2 in
        #                        position 0: unexpected end of data
        p = pexpect.spawnu('cat', maxread=1)
        p.sendline('▁▂▃▄▅▆▇█')
        p.sendeof()
        p.expect('▁▂▃▄▅▆▇█')


if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(UnicodeTests, 'test')

########NEW FILE########
__FILENAME__ = test_winsize
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import unittest
import PexpectTestCase
import time

class TestCaseWinsize(PexpectTestCase.PexpectTestCase):

    def test_winsize (self):
        '''
        This tests that the child process can set and get the windows size.
        This makes use of an external script sigwinch_report.py.
        '''
        p1 = pexpect.spawn('%s sigwinch_report.py' % self.PYTHONBIN)
        p1.expect('READY', timeout=10)

        p1.setwinsize (11,22)
        index = p1.expect ([pexpect.TIMEOUT, b'SIGWINCH: \(([0-9]*), ([0-9]*)\)'],
                                       timeout=30)
        if index == 0:
            self.fail("TIMEOUT -- this platform may not support sigwinch properly.\n" + str(p1))
        self.assertEqual(p1.match.group(1, 2), (b"11" ,b"22"))
        self.assertEqual(p1.getwinsize(), (11, 22))

        time.sleep(1)
        p1.setwinsize (24,80)
        index = p1.expect ([pexpect.TIMEOUT, b'SIGWINCH: \(([0-9]*), ([0-9]*)\)'],
                                       timeout=10)
        if index == 0:
            self.fail ("TIMEOUT -- this platform may not support sigwinch properly.\n" + str(p1))
        self.assertEqual(p1.match.group(1, 2), (b"24" ,b"80"))
        self.assertEqual(p1.getwinsize(), (24, 80))

        p1.close()

#    def test_parent_resize (self):
#        pid = os.getpid()
#        p1 = pexpect.spawn('%s sigwinch_report.py' % self.PYTHONBIN)
#        time.sleep(10)
#        p1.setwinsize (11,22)
#        os.kill (pid, signal.SIGWINCH)

if __name__ == '__main__':
    unittest.main()

suite = unittest.makeSuite(TestCaseWinsize,'test')



########NEW FILE########
__FILENAME__ = ticker
#!/usr/bin/env python
'''
PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

import time, sys

for i in range(5):
  print "tick"
  time.sleep(1)

sys.exit(0)

########NEW FILE########
__FILENAME__ = getkey
'''
This currently just holds some notes.
This is not expected to be working code.

$Revision: 120 $
$Date: 2002-11-27 11:13:04 -0800 (Wed, 27 Nov 2002) $

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

import tty, termios, sys

def getkey():
    file = sys.stdin.fileno()
    mode = termios.tcgetattr(file)
    try:
        tty.setraw(file, termios.TCSANOW)
        ch = sys.stdin.read(1)
    finally:
        termios.tcsetattr(file, termios.TCSANOW, mode)
    return ch

def test_typing ():
    s = screen (10,10)
    while 1:
        ch = getkey()
        s.type(ch)
        print str(s)
        print


########NEW FILE########
__FILENAME__ = merge_templates
#!/usr/bin/env python

'''
I used to use this to keep the sourceforge pages up to date with the
latest documentation and I like to keep a copy of the distribution
on the web site so that it will be compatible with
The Vaults of Parnasus which requires a direct URL link to a
tar ball distribution. I don't advertise the package this way.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
'''
import sys, os, re
import pyed
try:
    import pexpect
except:
    # this happens if Pexpect was never installed to begin with.
    sys.path.insert(0, '.')
    import pexpect

# extract the version number from the pexpect.py source.
d = pyed.pyed()
d.read ("pexpect.py")
d.first('^__version__')
r = re.search("'([0-9]\.[0-9])'", d.cur_line)
version = r.group(1)

# Edit the index.html to update current VERSION.
d = pyed.pyed()
d.read ("doc/index.template.html")
for cl in d.match_lines('.*VERSION.*'):
    d.cur_line = d.cur_line.replace('VERSION', version)
d.write("doc/index.html")

# Edit the setup.py to update current VERSION.
d = pyed.pyed()
d.read ("setup.py.template")
for cl in d.match_lines('.*VERSION.*'):
    d.cur_line = d.cur_line.replace('VERSION', version)
d.write("setup.py")
os.chmod("setup.py", 0755)


########NEW FILE########
__FILENAME__ = pyed
"""This represents a document with methods to allow easy editing.
Think 'sed', only more fun to use.
Example 1: Convert all python-style comments in a file to UPPERCASE.
This operates as a filter on stdin, so this needs a shell pipe.
cat myscript.py | upper_filter.py
    import sys, pyed
    pe = pyed()
    pe.read(sys.stdin)
    for pe in pe.match_lines('^\\s*#'):
        pe.cur_line = pe.cur_line.upper()
    print pe

Example 2: Edit an Apache2 httpd.conf file to turn on supplemental SSL configuration.
    import pyed
    pe = pyed()
    pe.read("httpd.conf")
    pe.first('#Include conf/extra/httpd-ssl.conf')
    pe.cur_line = 'Include conf/extra/httpd-ssl.conf'
    pe.write("httpd.conf")

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""

import re
class pyed (object):
    def __init__ (self, new_str=None):
        if new_str is not None:
            self.lines = new_str.splitlines()
            self.cur_line_num = 0
        else:
            self.lines = None
            # force invalid line number
            self.cur_line_num = None
    def match_lines (self, pattern, beg=0, end=None):
        """This returns a generator that iterates this object
        over the lines and yielding when a line matches the pattern.
        Note that this generator mutates this object so that
        the cur_line is changed to the line matching the pattern.
        """
        p = re.compile (pattern)
        if end is None:
            end = len(self.lines)
        for i in xrange (beg,end):
            m = p.match(self.lines[i])
            if m is not None:
                self.cur_line_num = i
                yield self
            else:
                # force invalid line number
                cur_line_num = None
    def match_lines_rev (self, pattern, beg=0, end=None):
        """This is similar to match_lines, but the order is reversed.
        """
        p = re.compile (pattern)
        if end is None:
            end = len(self.lines)
        for i in xrange (end-1,beg-1,-1):
            m = p.match(self.lines[i])
            if m is not None:
                self.cur_line_num = i
                yield self
            else:
                # force invalid line number
                cur_line_num = None
    def next (self):
        self.cur_line_num = self.cur_line_num + 1
        if self.cur_line_num >= len(self.lines):
            self.cur_line_num = len(self.lines) - 1
        return self.cur_line
    def prev (self):
        self.cur_line_num = self.cur_line_num - 1
        if self.cur_line_num < 0:
            self.cur_line_num = 0
        return self.cur_line
    def first (self, pattern=None):
        if pattern is not None:
            try:
                return self.match_lines(pattern).next()
            except StopIteration, e:
                # force invalid line number
                self.cur_line_num = None
                return None
        self.cur_line_num = 0
        return self.cur_line
    def last (self, pattern=None):
        if pattern is not None:
            try:
                return self.match_lines_rev(pattern).next()
            except StopIteration, e:
                # force invalid line number
                self.cur_line_num = None
                return None
        self.cur_line_num = len(self.lines) - 1
        return self.cur_line
    def insert (self, s=''):
        """This inserts the string as a new line before the current line number.
        """
        self.lines.insert(self.cur_line_num, s)
    def append (self, s=''):
        """Unlike list append, this appends after the current line number,
        not at the end of the entire list.
        """
        self.cur_line_num = self.cur_line_num + 1
        self.lines.insert(self.cur_line_num, s)
    def delete (self):
        del self.cur_line
    def read (self, file_holder):
        """This reads all the lines from a file. The file_holder may be
        either a string filename or any object that supports "read()".
        All previous lines are lost.
        """
        if hasattr(file_holder, 'read') and callable(file_holder.read):
            fin = file_holder
        else:
            fin = open (file_holder, 'rb')
        data = fin.read()
        self.lines = data.splitlines()
        self.cur_line_num = 0
    def write (self, file_holder):
        """This writes all the lines to a file. The file_holder may be
        either a string filename or any object that supports "read()".
        TODO: Make write be atomic using file move instead of overwrite.
        """
        if hasattr(file_holder, 'write') and callable(file_holder.write):
            fout = file_holder
        else:
            fout = open (file_holder, 'wb')
        for l in self.lines:
            fout.write(l)
            fout.write('\n')
    # the following are for smart properties.
    def __str__ (self):
        return '\n'.join(self.lines)
    def __get_cur_line (self):
        self.__cur_line = self.lines[self.cur_line_num]
        return self.__cur_line
    def __set_cur_line (self, value):
        self.__cur_line = value
        self.lines[self.cur_line_num] = self.__cur_line
    def __del_cur_line (self):
        del self.lines[self.cur_line_num]
        if self.cur_line_num >= len(self.lines):
            self.cur_line_num = len(self.lines) - 1
    cur_line = property (__get_cur_line, __set_cur_line, __del_cur_line)
    # lines = property (get_lines, set_lines, del_lines)

__NOT_USED ="""
import sys
pe = pyed()
pe.read(sys.stdin)
#print "---"
#print list(x.cur_line for x in pe.match_lines_rev('^#'))
#print pe.first('^#')
#print pe.last('^#')
#print "---"
for pe in pe.match_lines('^\\s*#'):
    pe.cur_line = pe.cur_line.lower()
pe.last('# comment.*')
pe.cur_line = '# Comment 1'
print pe
if pe.last('asdfasdf') is None:
    print "can't find 'asdfasdf'"
"""


########NEW FILE########
__FILENAME__ = sfupload
#!/usr/bin/env python
'''This uploads the latest pexpect package to sourceforge.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
import pexpect
import sys

child = pexpect.spawn('ftp upload.sourceforge.net')
child.logfile = sys.stdout
child.expect('Name .*: ')
child.sendline('anonymous')
child.expect('Password:')
child.sendline('noah@noah.org')
child.expect('ftp> ')
child.sendline('cd /incoming')
child.expect('ftp> ')
child.sendline('lcd dist')
child.expect('ftp> ')
child.sendline('bin')
child.expect('ftp> ')
child.sendline('prompt')
child.expect('ftp> ')
child.sendline('mput pexpect-*.tar.gz')
child.expect('ftp> ')
child.sendline('ls pexpect*')
child.expect('ftp> ')
print child.before
child.sendline('bye')


########NEW FILE########
__FILENAME__ = step
#!/usr/bin/env python
'''
# This single steps through a log file.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

import tty, termios, sys

def getkey():
        file = sys.stdin.fileno()
        mode = termios.tcgetattr(file)
        try:
                tty.setraw(file, termios.TCSANOW)
                ch = sys.stdin.read(1)
        finally:
                termios.tcsetattr(file, termios.TCSANOW, mode)
        return ch

fin = open ('log', 'rb')
fout = open ('log2', 'wb')

while 1:
        foo = fin.read(1)
        if foo == '':
                sys.exit(0)
        sys.stdout.write(foo)
        getkey()
        fout.write (foo)
        fout.flush()


########NEW FILE########
__FILENAME__ = testall
#!/usr/bin/env python
'''This script runs all tests in a directory.
It does not need to know about the tests ahead of time.
It recursively descends from the current directory and
automatically builds up a list of tests to run.
Only directories named 'tests' are processed.
The path to each 'tests' directory is added to the PYTHONPATH.
Only python scripts that start with 'test_' are added to
the list of scripts in the test suite.
Noah Spurrier

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''
from __future__ import print_function

import unittest
import os, os.path
import sys
import platform

import pexpect

print("Testing pexpect %s using python %s:" % (
    pexpect.__version__, platform.python_version()))

# Don't bother checking performance on Travis, we know it's slow.
TEST_PERFORMANCE = 'TRAVIS' not in os.environ

def add_tests_to_list (import_list, dirname, names):
    # Only check directories named 'tests'.
    if os.path.basename(dirname) != 'tests':
        return
    # Add any files that start with 'test_' and end with '.py'.
    for f in names:
        filename, ext = os.path.splitext(f)
        if ext != '.py':
            continue
        if (not TEST_PERFORMANCE) and (filename == 'test_performance'):
            continue
        if filename.find('test_') == 0:
            import_list.append (os.path.join(dirname, filename))

def find_modules_and_add_paths (root_path):
    import_list = []
    module_list = []
    for (dirpath, dirnames, filenames) in os.walk(root_path):
        add_tests_to_list(import_list, dirpath, filenames)

    for module_file in import_list:
        path, module = os.path.split(module_file)
        module_list.append (module)
        print('Adding:', os.path.relpath(module_file))
        if not path in sys.path:
            sys.path.append (path)
        if not os.path.dirname(path) in sys.path:
            sys.path.append (os.path.dirname(path))

    module_list.sort()
    return module_list

def suite():
    modules_to_test = find_modules_and_add_paths (os.getcwd())
    alltests = unittest.TestSuite()
    for module in map(__import__, modules_to_test):
        alltests.addTest(unittest.findTestCases(module))
    return alltests

if __name__ == '__main__':
    unittest.main(defaultTest='suite')
#    s = all()
#    runner = unittest.TextTestRunner()
#    runner.run (s)


########NEW FILE########
__FILENAME__ = testsweep
#!/usr/bin/env python
"""This runs testall.py on many different platforms running on the Compile Farm (cf.sourceforge.net).

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

"""
import pexpect
import sys
import getpass

def test_platform (platform_menu, platform_python_path):
	try:
		s = pexpect.spawn ('ssh noah@cf.sourceforge.net')
		#s.setlog (sys.stdout)
		i = s.expect (['password:', 'yes/no'])
		if i == 1:
			s.sendline ('yes')
			s.expect ('password')
		s.sendline (PASSWORD)
		s.expect ('Choose compile farm server')
		s.sendline (platform_menu)
		s.expect_exact ('$')
		s.sendline ('cd pexpect')
		s.expect_exact ('$')
		s.sendline ('. ./cvs.conf')
		s.expect_exact ('$')
		s.sendline ('cvs up -d')
		s.expect ('password:')
		s.sendline (PASSWORD)
		s.expect_exact ('$')
		s.sendline (platform_python_path)
		i = s.expect_exact (['OK','$'], timeout=900) # Tests should not run more than 15 minutes.
		if i != 0:
			RESULT = s.before
		else:
			RESULT = 'OK!'
		s.sendline ('exit')
		s.sendline ('x')
		s.close()
	except Exception, e:
		return 'Exception in platform test: ' + str(e)
	return RESULT

PASSWORD = getpass.getpass('password: ')
results = []
result = test_platform ('I', 'python tools/testall.py')
results.append (('I', '[PPC - G4] MacOS X 10.1 SERVER Edition', result))
result = test_platform ('L', 'python tools/testall.py')
results.append (('L', '[Sparc - Ultra60] Linux 2.4 (Debian 3.0)', result))
result = test_platform ('B', 'python2 tools/testall.py')
results.append (('B', '[x86] Linux 2.4 (Redhat 7.3)', result))
result = test_platform ('M', '../Python-2.3b1/python tools/testall.py')
results.append (('M', '[Sparc - R220] Sun Solaris (8) #1', result))
result = test_platform ('G', 'python tools/testall.py')
results.append (('G', '[Alpha] Linux 2.2 (Debian 3.0)', result))
print results


########NEW FILE########
__FILENAME__ = tweak_files
'''

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

import pyed
import sys, os, re

# extract the version number from the pexpect.py source.
d = pyed.pyed()
d.read ("pexpect.py")
d.first('^__version__')
r = re.search("'([0-9]\.[0-9])'", d.cur_line)
version = r.group(1)

# Edit the index.html to update current VERSION.
d = pyed.pyed()
d.read ("doc/index.html.template")
for cl in d.match_lines('.*VERSION.*'):
    d.cur_line = d.cur_line.replace('VERSION', version)
d.write("doc/index.html")

# Edit the setup.py to update current VERSION.
d = pyed.pyed()
d.read ("setup.py.template")
for cl in d.match_lines('.*VERSION.*'):
    d.cur_line = d.cur_line.replace('VERSION', version)
d.write("setup.py")
os.chmod("setup.py", 0755)

########NEW FILE########
__FILENAME__ = websync
#!/usr/bin/env python

'''
I used to use this to keep the sourceforge pages up to date with the
latest documentation and I like to keep a copy of the distribution
on the web site so that it will be compatible with
The Vaults of Parnasus which requires a direct URL link to a
tar ball distribution. I don't advertise the package this way.

PEXPECT LICENSE

    This license is approved by the OSI and FSF as GPL-compatible.
        http://opensource.org/licenses/isc-license.txt

    Copyright (c) 2012, Noah Spurrier <noah@noah.org>
    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY
    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE
    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

'''

import pexpect, pyed
import getpass
import sys, os

X = getpass.getpass('Password: ')
pp_pattern=["(?i)password:", "(?i)enter passphrase for key '.*?':"]

p = pexpect.spawn ('scp -r doc/. noah@shell.sourceforge.net:/home/groups/p/pe/pexpect/htdocs/.')
p.logfile_read = sys.stdout
p.expect (pp_pattern)
p.sendline (X)
p.expect (pexpect.EOF)
print p.before

p = pexpect.spawn ('scp doc/clean.css doc/email.png noah@shell.sourceforge.net:/home/groups/p/pe/pexpect/htdocs/clean.css')
p.logfile_read = sys.stdout
p.expect (pp_pattern)
p.sendline (X)
p.expect (pexpect.EOF)
print p.before

#p = pexpect.spawn ('ssh noah@use-pr-shell1.sourceforge.net "cd htdocs;tar zxvf pexpect-doc.tgz"')
#p.logfile_read = sys.stdout
#p.expect ('password:')
#p.sendline (X)
#p.expect (pexpect.EOF)
#print p.before

p = pexpect.spawn ('scp dist/pexpect-*.tar.gz noah@shell.sourceforge.net:/home/groups/p/pe/pexpect/htdocs/.')
p.logfile_read = sys.stdout
p.expect (pp_pattern)
p.sendline (X)
p.expect (pexpect.EOF)
print p.before


########NEW FILE########
