__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# templated-emails documentation build configuration file, created by
# sphinx-quickstart on Sun Dec 18 21:23:53 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'templated-emails'
copyright = u'2011, Philipp Wassibauer'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.6.1'
# The full version, including alpha/beta/rc tags.
release = '0.6.1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'templated-emailsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'templated-emails.tex', u'templated-emails Documentation',
   u'Philipp Wassibauer', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'templated-emails', u'templated-emails Documentation',
     [u'Philipp Wassibauer'], 1)
]


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = templated_email
from notification import backends
from templated_emails.utils import send_templated_email


class TemplatedEmailBackend(backends.BaseBackend):
    """
    At attempt to wire django-notifications to
    https://github.com/philippWassibauer/templated-emails
    not to
    https://github.com/bradwhittington/django-templated-email
    though that might be a good idea
    """
    spam_sensitivity = 0

    def deliver(self, recipient, sender, notice_type, extra_context):
        if recipient == sender:
            return False

        context = self.default_context().update({"sender": sender})
        context.update(extra_context)
        send_templated_email([recipient], "emails/%s" % notice_type, context)
        return True

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = parse_util
from django.template.loader_tags import ExtendsNode
from django.conf import settings
import re

def recursive_block_replace(template, data=None, replace_static_url=True, replace_trans=True,
                            replace_with=True, replace_if=True):
    #check the extends
    # first try to replace with current data
    if isinstance(template.nodelist[0], ExtendsNode):
        # load more data using the current blocks
        data = parse_blocks(template, data)
        data = fill_blocks(template, data)
        return recursive_block_replace(template.nodelist[0].get_parent(""), data)
    else:
        final_string = replace_blocks(template, data)
        if replace_static_url:
            final_string = final_string.replace("{{ STATIC_URL }}", settings.STATIC_URL)
        if replace_trans:
            p = re.compile('(\{% blocktrans .* %\})', re.IGNORECASE)
            final_string = p.sub('', final_string)

            p = re.compile('(\{% blocktrans %\})', re.IGNORECASE)
            final_string = p.sub('', final_string)

            p = re.compile('(\{% endblocktrans %\})', re.IGNORECASE)
            final_string = p.sub('', final_string)

            final_string = re.sub(r"\{% trans (.+) %\}", lambda x: x.group(1)[1:-1], final_string)
        if replace_with:
            p = re.compile('(\{% with .+ %\})', re.MULTILINE|re.IGNORECASE)
            final_string = p.sub('', final_string)

            p = re.compile('(\{% endwith %\})', re.MULTILINE|re.IGNORECASE)
            final_string = p.sub('', final_string)

        if replace_if:
            p = re.compile('(\{% if .+ %\})', re.MULTILINE|re.IGNORECASE)
            final_string = p.sub(lambda x: "<div class='if'>%s</div><div class='if-body'>"%x.group(1), final_string)

            p = re.compile('(\{% endif %\})', re.MULTILINE|re.IGNORECASE)
            final_string = p.sub(lambda x: "</div><div class='end-if'>%s</div>"%x.group(1), final_string)

        return final_string


def replace_blocks(template, data):
    template_string = read_file(template.nodelist[0].source[0].name)
    return replace_string_blocks(template_string, data)


def replace_string_blocks(string, data):
    for key in data:
        regex_string = '\{% block '+key+' %\}([\s\S\n\r\w]*?)\{% endblock %\}'
        p = re.compile(regex_string, re.MULTILINE|re.IGNORECASE)
        string = p.sub(data[key], string)

    # replace the last blocks
    p2 = re.compile('(\{% block [a-zA-Z0-9_]+ %\})', re.MULTILINE|re.IGNORECASE)
    string = p2.sub('', string)

    p2 = re.compile('(\{% endblock %\})', re.MULTILINE|re.IGNORECASE)
    string = p2.sub('', string)

    return string


def fill_blocks(template, data):
    return data


def parse_blocks(template, data):
    data = parse_string_blocks(read_file(template.nodelist[0].source[0].name),
                               data)
    return data


def parse_string_blocks(string, data):
    # find all blocks
    regex = re.compile("\{% block ([a-zA-Z0-9_]+) %\}([\s\S\n\r\w]*?)\{% endblock %\}",
                       re.DOTALL|re.MULTILINE|re.IGNORECASE)
    m = regex.findall(string)
    for item in m:
        print item[0]
        data[item[0]] = item[1]
    return data


def read_file(path):
    file = open(path, "r")
    return file.read()

########NEW FILE########
__FILENAME__ = templated_email_tags
from django.template.base import Library
import textwrap

register = Library()


@register.filter(is_safe=True)
def dedent(text):
    """
    Removes indentation of text. Useful in text emails that otherwise can't be
    indented.

    Example usage::

        {% filter dedent %}
            My text
            {% if something %}
                another text
            {% endif %}
        {% endfilter %}

    This example would return this HTML::

        My text

        another text
    """
    return textwrap.dedent(text)

########NEW FILE########
__FILENAME__ = tests
# -*- coding: utf-8 -*-
from django.utils import unittest
from django.test import TestCase
from .parse_util import parse_string_blocks, replace_blocks, replace_string_blocks


test_extraction_string =  """{% block test %}tr
 st

 sdf{% endblock %}"""

test_extraction_string2 = """{% block test123 %}tr s123t sdf{% endblock %}"""

test_extraction_string3 = """{% block test123 %}
            tr s123t sdf
{% endblock %}

{% block test %}test{% endblock %}
"""

test_extraction_string4 = """{% extends "emails/email.html" %}\n{% load gidsy_tags %}\n{% load profile_tags %}\n{% load account_tags %}\n{% load currency_tags %}\n{% block title %}\n  {% trans "All the best," %}\n{% endblock %}{% block message_title %}{% trans "Sorry! Not enough people booked" %} "{{ activity }}."{% endblock %}\n{% block email_notification %}{% trans "Your activity will not be taking place" %}{% endblock %}\n{% block email_title %}{% random_greeting %} {{ user.first_name }},{% endblock %}\n{% block email_subtitle %}\n  <h3>\n    {% blocktrans with slot=booking.slot min_participants=slot.get_min_participants start_date=slot.start_time|date:"l, F j" start_time=slot.start_time|date:"P" %}\n      We\'re sorry! Not enough people booked &quot;{{ activity }}&quot; on <strong>{{ start_date }}</strong> at <strong>{{ start_time }}</strong> for it to happen.\n    {% endblocktrans %}\n  </h3>\n{% endblock %}\n{% block email_message %}\n    <p>\n      {% blocktrans with confirmed_bookings=slot.booked_spots %}\n        To avoid disappointment in future, make sure to check before booking an activity how far it is from getting its minimum number of participants. \n      {% endblocktrans %}\n    </p>\n    {% if other_activities %}\n    <p>\n      You may also be interested in these other [link: activities] that already have enough people attending: (list 3 activities here)\n    </p>\n    {% endif %}\n{% endblock %}\n\n{% block signature %}\n  {% trans "All the best," %}\n{% endblock %}"""
test_replace_string = """<html>{% block test123 %}{% endblock %}</html>"""


class BlockExtraction(TestCase):
    def test_extraction(self):
        self.assertEquals("""tr
 st

 sdf""", parse_string_blocks(test_extraction_string, {})["test"])

        self.assertEquals("tr s123t sdf", parse_string_blocks(test_extraction_string2, {})["test123"])
        data = parse_string_blocks(test_extraction_string3, {})
        self.assertEquals("""
            tr s123t sdf
""",data["test123"])
        self.assertEquals("""test""",data["test"])

    def test_full_extraction(self):
        data = parse_string_blocks(test_extraction_string4, {})
        print data
        self.assertTrue(data.get("message_title", False))
        self.assertTrue(data.get("email_notification", False))
        self.assertTrue(data.get("email_title", False))
        self.assertTrue(data.get("email_subtitle", False))
        self.assertTrue(data.get("signature", False))
        self.assertTrue(data.get("title", False))
                
    def test_replace_blocks(self):
        self.assertEqual("<html>test</html>", replace_string_blocks(test_replace_string, {"test123": "test"}))
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *
from .views import *

urlpatterns = patterns('',
    url(r'^$', index, name="templated_emails_index"),
    url(r'^view(?P<path>[\w.+-_/]+)$', view, name="templated_email_view"),
)

########NEW FILE########
__FILENAME__ = utils
import logging
import os
import threading

from django.core.mail import EmailMultiAlternatives
from django.conf import settings
from django.template import Context, TemplateDoesNotExist
from django.contrib.sites.models import Site
from django.template.loader import render_to_string
from django.utils.translation import get_language, activate
from django.db import models
from django.core.exceptions import ImproperlyConfigured
from django.contrib.auth import get_user_model


try:
    from celery.task import task
except ImportError:
    task = lambda f: f

use_pynliner = getattr(settings, 'TEMPLATEDEMAILS_USE_PYNLINER', False)
use_celery = getattr(settings, 'TEMPLATEDEMAILS_USE_CELERY', False)
use_threading = not use_celery

pynliner = None
if use_pynliner:
    try:
        import pynliner
    except ImportError:
        pass


class LanguageStoreNotAvailable(Exception):
    pass


def get_email_directories(dir):
    directory_tree = False
    for name in os.listdir(dir):
        if os.path.isdir(os.path.join(dir, name)):
            if directory_tree == False:
                directory_tree = {}
            directory_tree[name] = get_email_directories(os.path.join(dir, name))
    return directory_tree


def send_templated_email(recipients, template_path, context=None,
                    from_email=settings.DEFAULT_FROM_EMAIL,
                    fail_silently=False, extra_headers=None):
    """
        recipients can be either a list of emails or a list of users,
        if it is users the system will change to the language that the
        user has set as theyr mother toungue
    """
    recipient_pks = [r.pk for r in recipients if isinstance(r, get_user_model())]
    recipient_emails = [e for e in recipients if not isinstance(e, get_user_model())]
    send = _send_task.delay if use_celery else _send
    msg = send(recipient_pks, recipient_emails, template_path, context, from_email,
         fail_silently, extra_headers=extra_headers)

    return msg


class SendThread(threading.Thread):
    def __init__(self, recipient, current_language, current_site, default_context,
                 subject_path, text_path, html_path, from_email=settings.DEFAULT_FROM_EMAIL,
                 fail_silently=False):
        self.recipient = recipient
        self.current_language = current_language
        self.current_site = current_site
        self.default_context = default_context
        self.subject_path = subject_path
        self.text_path = text_path
        self.html_path = html_path
        self.from_email = from_email
        self.fail_silently = fail_silently
        super(SendThread, self).__init__()

    def run(self):
        recipient = self.recipient
        if isinstance(recipient, User):
            email = recipient.email
            try:
                language = get_users_language(recipient)
            except LanguageStoreNotAvailable:
                language = None

            if language is not None:
                activate(language)
        else:
            email = recipient

        # populate per-recipient context
        context = Context(self.default_context)
        context['recipient'] = recipient
        context['email'] = email

        # load email subject, strip and remove line breaks
        subject = render_to_string(self.subject_path, context).strip()
        subject = "".join(subject.splitlines())  # this must be a single line
        text = render_to_string(self.text_path, context)

        msg = EmailMultiAlternatives(subject, text, self.from_email, [email])

        # try to attach the html variant
        try:
            body = render_to_string(self.html_path, context)
            if pynliner:
                body = pynliner.fromString(body)
            msg.attach_alternative(body, "text/html")
        except TemplateDoesNotExist:
            logging.info("Email sent without HTML, since %s not found" % html_path)

        msg.send(fail_silently=self.fail_silently)

        # reset environment to original language
        if isinstance(recipient, User):
            activate(self.current_language)


def _send(recipient_pks, recipient_emails, template_path, context, from_email,
          fail_silently, extra_headers=None):
    recipients = list(get_user_model().objects.filter(pk__in=recipient_pks))
    recipients += recipient_emails

    current_language = get_language()
    current_site = Site.objects.get(id=settings.SITE_ID)

    default_context = context or {}
    default_context["current_site"] = current_site
    default_context["STATIC_URL"] = settings.STATIC_URL

    subject_path = "%s/short.txt" % template_path
    text_path = "%s/email.txt" % template_path
    html_path = "%s/email.html" % template_path

    for recipient in recipients:
        if use_threading:
            SendThread(recipient, current_language, current_site, default_context, subject_path,
                       text_path, html_path, from_email, fail_silently).start()
            return
        # if it is user, get the email and switch the language
        if isinstance(recipient, get_user_model()):
            email = recipient.email
            try:
                language = get_users_language(recipient)
            except LanguageStoreNotAvailable:
                language = None

            if language is not None:
                # activate the user's language
                activate(language)
        else:
            email = recipient

        # populate per-recipient context
        context = Context(default_context)
        context['recipient'] = recipient
        context['email'] = email

        # load email subject, strip and remove line breaks
        subject = render_to_string(subject_path, context).strip()
        subject = "".join(subject.splitlines())  # this must be a single line
        text = render_to_string(text_path, context)

        msg = EmailMultiAlternatives(subject, text, from_email, [email],
                                     headers=extra_headers)

        # try to attach the html variant
        try:
            body = render_to_string(html_path, context)
            if pynliner:
                body = pynliner.fromString(body)
            msg.attach_alternative(body, "text/html")
        except TemplateDoesNotExist:
            logging.info("Email sent without HTML, since %s not found" % html_path)

        msg.send(fail_silently=fail_silently)

        # reset environment to original language
        if isinstance(recipient, get_user_model()):
            activate(current_language)

        return msg
if use_celery:
    _send_task = task(_send)


def get_users_language(user):
    """
    Returns site-specific language for this user. Raises
    LanguageStoreNotAvailable if this site does not use translated
    notifications.
    """
    if getattr(settings, 'NOTIFICATION_LANGUAGE_MODULE', False):
        try:
            app_label, model_name = settings.NOTIFICATION_LANGUAGE_MODULE.split('.')
            model = models.get_model(app_label, model_name)
            language_model = model._default_manager.get(user__id__exact=user.id)
            if hasattr(language_model, 'language'):
                return language_model.language
        except (ImportError, ImproperlyConfigured, model.DoesNotExist):
            raise LanguageStoreNotAvailable
    raise LanguageStoreNotAvailable

########NEW FILE########
__FILENAME__ = views
import logging

from django.contrib.auth.models import User
from django.http import HttpResponseRedirect, Http404, HttpResponse
from django.shortcuts import render_to_response, get_object_or_404
from django.template import RequestContext
from django.conf import settings
from django.template.loader import get_template
from django.template.base import Template

from .utils import get_email_directories
from .parse_util import recursive_block_replace

logger = logging.getLogger('templated_emails')

def index(request, template_name="templated_emails/index.html"):
    if not request.user.is_superuser:
        raise Http404
    else:
        directory_tree = get_email_directories(settings.EMAIL_TEMPLATES_DIRECTORY)
        return render_to_response(template_name, {
            "directory_tree": directory_tree,
        }, context_instance=RequestContext(request))


def view(request, path, template_name="templated_emails/view.html"):
    if not request.user.is_superuser:
        raise Http404
    else:
        # get extends node
        # get all block nodes
        # do this recursive until no more extends
        # then place html in blocks
        rendered_subject = ""
        rendered_html = ""
        rendered_text = ""

        try:
            template = get_template("emails%s/email.html"%path)
            rendered_html = recursive_block_replace(template, {})
        except:
            logger.exception("Error rendering templated email email.html")

        try:
            template = get_template("emails%s/email.txt"%path)
            rendered_text = recursive_block_replace(template, {})
        except:
            logger.exception("Error rendering templated email email.txt")

        try:
            template = get_template("emails%s/short.txt"%path)
            rendered_subject = recursive_block_replace(template, {})
        except:
            logger.exception("Error rendering templated email short.txt")

        return render_to_response(template_name, {
            "rendered_subject": rendered_subject,
            "rendered_html": rendered_html,
            "rendered_text": rendered_text,
        }, context_instance=RequestContext(request))

########NEW FILE########
