# Alfred.framework for Objective-C
Alfred.framework is a lightweight Objective-C framework for developing workflow components for [Alfred v2][alfred]. Modeled in part on [alp][], Alfred.framework is designed to automate a number of repetitive and annoying workflow tasks with the goal of making it faster and easier to generate fewer lines of code. The library is still in its developmental infancy, but current features include:

* Painless generation of feedback XML.
* Fuzzy searching, modeled on [alp][].
* Methods for accessing cache folders, storage folders, and the local folder.
* An argument parser.
* Silent error logging.

You can [download the latest version here][latest]; for more information about this and prior releases, [see the changelog][cl]. You can also browse and download the source code [at Github](https://github.com/phyllisstein/Alfred.framework).


## Installation
Adding Alfred.framework to XCode is more of a chore than is ideal but less of a chore than you might fear. To get started, [download the latest version][latest] and extract the contents of the zip. Then, in XCode, click the plus sign in the lower-left-hand corner of the window, select 'Add Files to "MyAlfredWorkflow"...,' and navigate to the folder where you saved Alfred.framework. Ensure that "Copy items to the destination group's folder" and "MyAlfredWorkflow" (under "Add to targets") are checked, then select Alfred.framework and click "Add."

![](http://alfred.daniel.sh/framework/setup-1.png)

Now select the main project item from the pane to the left, then choose the target "MyAlfredWorkflow." Under "Build Phases," click the disclosure triangle next to "Link binary with libraries" and make sure it includes Alfred.framework. If not, click the plus sign, then "Add Other...," then navigate to the file on your hard drive and add it manually.

Now, in your main source file `main.m`, add a line lines below `#import <Foundation/Foundation.h>`:

```````````objectivec
//
//  main.m
//  MyAlfredWorkflow
//
//  Created by Daniel Shannon on 5/25/13.
//  Copyright (c) 2013 Daniel Shannon. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <Alfred/Alfred.h>

int main(int argc, const char * argv[])
{
```````````````````````````````````````````````````````````````````````````````````````````````

If you've done everything correctly so far, XCode should try to autocomplete `<Alfred/Alfred.h>` as you type, and your screen should look something like this:

![](http://alfred.daniel.sh/framework/setup-2.png)

Note that the organization of the files in the left pane doesn't make much of a difference, so long as you don't delete the framework.

Now, in order to use Alfred.framework, you simply must ensure that the framework bundle is copied to the same directory as your executable. Then import `<Alfred/Alfred.h>` and you're ready to go!


## Usage
Currently, Alfred.framework provides the following core features:

* Painless generation of feedback XML.
* Fuzzy searching, modeled on [alp][].
* Methods for accessing cache folders, storage folders, and the local folder.
* An argument parser.
* Silent error logging.

Each one is accessible through `<Alfred/Alfred.h>`. The two main classes currently in use are `AWWorkflow` and `AWFeedbackItem`. `AWWorkflow` is an interface to most of the methods above, whereas `AWFeedbackItem` is pretty much just what it says on the can.

### Feedback XML
To generate feedback XML in Alfred.framework, you must first create and configure one or more `AWFeedbackItem`s. There are a number of ways to do this. The first and most cumbersome involves using getter and setter methods to set up feedback items. For example, this would be perfectly valid:

```````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWFeedbackItem *i = [[AWFeedbackItem alloc] init];
i.title = @"Information";
i.subtitle = @"S'more information.";
i.valid = @YES;
i.arg = @"get info";
```````````````````````````````````````````````````````````````````````````````````````````````

...and so on. The following properties are presently used to pass data back to Alfred:

```````objectivec
@property NSString      *title;
@property NSString      *subtitle;
@property NSString      *uid;
@property NSNumber      *valid;
@property NSString      *autocomplete;
@property NSString      *icon;
@property NSNumber      *fileicon;
@property NSNumber      *filetype;
@property NSString      *arg;
@property NSString      *type;
```````````````````````````````````````````````````````````````````````````````````````````````

However, because setting each one would be tedious, `AWFeedbackItem` provides a class method, `+ itemWithObjectsAndKeys:(id)...`, and an instance method, `- initWithObjects:(NSArray *) forKeys:(NSArray *)`, to make it simpler. As their first arguments, both take a `BOOL` that determines whether the XML item is considered actionable by Alfred. The class method then allows you to specify a `nil`-terminated list of alternative objects and keys (property names) to set up the item. With the exception of the three `NSNumber` objects, which should be `@YES` or `@NO`, all keys and values _must_ be strings. For example:

````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWFeedbackItem *i = [AWFeedbackItem itemWithObjectsAndKeys:@"Entitlement", @"title", @"Subversion", @"subtitle", @"iconography.png", @"icon", @"argumentation", @"arg", @YES, @"valid", nil];
NSLog(@"xml=%@", [i xml]);
```````````````````````````````````````````````````````````````````````````````````````````````

...would log the following to the console:

`````````xml
AlfredWorkflowTest[31201:303] xml=<item valid="yes" arg="argumentation"><title>Entitlement</title><subtitle>Subversion</subtitle><icon>iconography.png</icon></item>
```````````````````````````````````````````````````````````````````````````````````````````````

You could do something similar with the customized constructor method. This method, rather than taking a list of `NSString` objects, takes two `NSArray` objects---one of keys, one of values---which must contain `NSString`s. Here's an example:

````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWFeedbackItem *j = [[AWFeedbackItem alloc] initWithObjects:@[@"Titillation", @"Submission & Subdual", @"automation", @NO] forKeys:@[@"title", @"subtitle", @"autocomplete", @"valid"];
NSLog(@"xml=%@", [j xml]);
```````````````````````````````````````````````````````````````````````````````````````````````

``````````````xml
AlfredWorkflowTest[31201:303] xml=<item valid="no" autocomplete="automation"><title>Titillation</title><subtitle>Submission &amp; Subdual</subtitle><icon>icon.png</icon></item>
```````````````````````````````````````````````````````````````````````````````````````````````

Alfred.framework automatically escapes XML strings passed to `AWFeedbackItem`. Additionally, the way that arguments are treated will vary depending on their content. From Alfred v2.0.4 on, arguments can be specified as either attributes of `<item></item>` _or_ separate XML keys. The framework supports this feature by designating any `arg` string containing newlines a tag, and any `arg` string without newlines an attribute. For example:

``````````objectivec
AWFeedbackItem *i = [AWFeedbackItem itemWithObjectsAndKeys:@NO, @"valid", @"Old and Busted", @"title", @"I'm a simple man", @"arg", nil];
AWFeedbackItem *j = [AWFeedbackItem itemWithObjectsAndKeys:@YES, @"valid", @"New Hotness", @"title", @"I\nthink\ncomplexly", @"arg", nil];

AWWorkflow *wf = [[AWWorkflow alloc] init];
[wf flush:YES feedbackItems:i, j, nil];
````````````````````````````````````````````````````````````````````````````````````````````````

`````````xml
<?xml version="1.0"?><items><item valid="no" arg="I&apos;m a simple man"><title>Old and Busted</title><subtitle></subtitle><icon>icon.png</icon></item><item valid="yes"><title>New Hotness</title><subtitle></subtitle><icon>icon.png</icon><arg>I
think
complexly</arg></item></items>
````````````````````````````````````````````````````````````````````````````````````````````````

Note that the feedback item's `- xml` method does not generate the complete XML string that Alfred needs to provide feedback. That functionality is provided through a method of `AWWorkflow`, and `- xml` is only used here for the purposes of demonstration.

To feed data back to Alfred, you must call `AWWorkflow`'s instance method `- flush:(BOOL) feedbackItems:(AWFeedbackItem *)...`. Like the feedback item's class method, this too takes a `nil`-terminated list of objects; in this case, however, each one should be an `AWFeedbackItem` instance. The first argument is a `BOOL`; if set to `YES`, it will flush the standard output buffer to Alfred and terminate your program. Otherwise, it will only spool the XML into the standard output. Call it like this:

```````````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWWorkflow *wf = [[AWWorkflow alloc] init];

AWFeedbackItem *i = [AWFeedbackItem itemWithObjectsAndKeys:@"Entitlement", @"title", @"Subversion", @"subtitle", @"iconography.png", @"icon", @"argumentation", @"arg", @YES, @"valid", nil];
AWFeedbackItem *j = [[AWFeedbackItem alloc] initWithObjects:@[@"Titillation", @"Submission & Subdual", @"automation", @YES] forKeys:@[@"title", @"subtitle", @"autocomplete", @"valid"];

[wf flush:YES feedbackItems:i, j, nil];
```````````````````````````````````````````````````````````````````````````````````````````````

This ends the program immediately, printing the following XML to the standard output:

````````````xml
<?xml version="1.0"?><items><item valid="yes" arg="argumentation"><title>Entitlement</title><subtitle>Subversion</subtitle><icon>iconography.png</icon></item><item valid="no" autocomplete="automation"><title>Titillation</title><subtitle>Submission &amp; Subdual</subtitle><icon>icon.png</icon></item></items>
```````````````````````````````````````````````````````````````````````````````````````````````

If you're generating feedback items on-the-fly, of course, you'll want to be able to send them all at once. Rather than passing them one by one to `- flush:feedbackItems:` and only flushing at the last object, you can also call `- flush:(BOOL) feedbackArray:(NSArray *)` with an `NSArary` containing `AWFeedbackItem`s. For example, you might want to rewrite the sample above with a condition:

```````````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWWorkflow *wf = [AWWorkflow workflow];     // Returns an initialized AWWorkflow
NSMutableArray *fbi = [NSMutableArray new];

if (myCondition == YES)
{
    AWFeedbackItem *i = [AWFeedbackItem itemWithObjectsAndKeys:@"Entitlement", @"title", @"Subversion", @"subtitle", @"iconography.png", @"icon", @"argumentation", @"arg", @YES, @"valid", nil];
    [fbi addObject:i];
}
AWFeedbackItem *j = [[AWFeedbackItem alloc] initWithObjects:@[@"Titillation", @"Submission & Subdual", @"automation", @YES] forKeys:@[@"title", @"subtitle", @"autocomplete", @"valid"];
[fbi addObject:j];

[wf flush:YES feedbackArray:fbi];
```````````````````````````````````````````````````````````````````````````````````````````````



### Fuzzy Searching
Alfred.framework includes a port of [alp][]'s fuzzy searching feature, which is considerably sped up in compiled code without losing any of its power. To use it, simply fill an `NSArray` with a number of objects. These objects can be of any type, so long as an `NSString` to be matched against can be extracted from them. The framework will return another `NSArray` with any matching elements, sorted by the quality of the match.

The method that handles this is also declared in `AWWorkflow`, as `- fuzzySearchFor:(NSString *) in:(NSArray *) withKeyBlock:(NSString *(^)(id))`. It takes a string with the search query, an array of objects, and a block function that will be applied to each element of the array to get a search string. The block should take a single object, though that object can contain many other objects, and return a string to be searched.

Let's take a look at some sample code, using data drawn from [alp][]'s sample case:

```````{.objectivec}
#import <Alfred/Alfred.h>

// [...]

AWWorkflow *wf = [AWWorkflow workflow];

NSArray *k = @[@"key", @"author", @"title"];
NSArray *v0 = @[@"ZB7K535R", @"Reskin 2003", @"Including Mechanisms in Our Models of Ascriptive Inequality: 2002 Presidential Address"];
NSArray *v1 = @[@"DBTD3HQS", @"Igor & Ronald 2008", @"Die Zunahme der Lohnungleichheit in der Bundesrepublik. Aktuelle Befunde für den Zeitraum von 1998 bis 2005"];
NSArray *v2 = @[@"MQ3BHTBJ", @"Marx 1978", @"Alienation and Social Class"];
NSArray *v3 = @[@"7G4BRU45", @"Marx 1978", @"The German Ideology"];
NSArray *v4 = @[@"9ANAZXQB", @"Llorente 2006", @"Analytical Marxism and the Division of Labor"];
NSArray *ofDicts = @[[NSDictionary dictionaryWithObjects:v0 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v1 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v2 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v3 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v4 forKeys:k]];

NSArray *res = [wf fuzzySearchFor:@"marx" in:ofDicts withKeyBlock: ^(id obj) {
    NSDictionary *d = (NSDictionary *)obj;
    NSString *s = [NSString stringWithFormat:@"%@ - %@",
                    [d objectForKey:@"author"],
                    [d objectForKey:@"title"]];
    return s;
}];
NSLog(@"res=%@", res);
```````````````````````````````````````````````````````````````````````````````````````````````

As you can see, it's okay that the strings we need to search are buried deep in the actual object so long as we know how to return a string from our key block; otherwise, the search function won't know what it should be applying its filters to. What's actually being searched in each case is the string `"{author} - {title}"`; what's returned, on the other hand, is the complete object that yielded each match:

    AlfredWorkflowTest[32039:303] res=(
        {
            author = "Marx 1978";
            key = MQ3BHTBJ;
            title = "Alienation and Social Class";
        },
        {
            author = "Marx 1978";
            key = 7G4BRU45;
            title = "The German Ideology";
        },
        {
            author = "Llorente 2006";
            key = 9ANAZXQB;
            title = "Analytical Marxism and the Division of Labor";
        }
    )

It should be considered purely coincidental that the order of the objects returned is identical to the order in which they were presented. The algorithm calculates quality of match based on the number of characters in sequence ("marx" is preferred to "moarx"---unbroken sequences are better) and the position of the sequence in the search string ("marx" is preferred to "smarx"---earlier is better).



### Argument Parsing
The `AWWorkflow` object provides a method for converting arguments to the workflow in the form of `--key=value` into an `NSDictionary` with usable objects. To invoke it, you must first create an array of dictionaries that define the expected arguments. Each dictionary requires three key--value pairs---`@"name"`, a string with the long name of the argument key, `@"flag"`, a single-letter string with the short name of the argument key, and `@"has_arg"`, an `NSNumber` that determines whether the argument key is an on/off flag (set to `@NO`), requires a value (set to `@YES`), or takes an optional value (set to anything else). Once you've determined your expected arguments, you can invoke `AWWorkflow`'s `- parseArguments:(const char **) withKeys:(NSArray *) count:(int)` method. This returns a dictionary object whose keys are the arguments' names and whose values were passed in to the program.

``````objectivec
#import <Foundation/Foundation.h>
#import <Alfred/Alfred.h>

int main(int argc, const char *argv[])
{
    @autoreleasepool {
        AWWorkflow *wf = [AWWorkflow workflow];
        NSArray *k = @[@{@"name": @"qux", @"has_arg": @YES, @"flag": @"q"},
                       @{@"name": @"baz", @"has_arg": @NO,  @"flag": @"b"},
                       @{@"name": @"cog", @"has_arg": @2,   @"flag": @"c"}];
        NSDictionary *args = [wf parseArguments:argv withKeys:k count:argc];
        NSLog(@"qux=%@, baz=%@, cog=%@", [args valueForKey:@"qux"], [args valueForKey:@"baz"], [args valueForKey:@"cog"]);
        // NSLog(@"query=%@", [args valueForKey:@"{query}"]);
    }
    return 0;
}
````````````````````````````````````````````````````````````````````````````````````````````````

You can compile this program, drop the framework into its folder (remember, it must be in the same directory as your executable), and run it from a Terminal window to check that it works:

````````bash
auntieclimactic:Debug danielsh$ ./ArgumentativeWorkflow --qux=foo --baz --cog
2013-05-26 08:20:22.847 DTWorkflow[48183:707] qux=foo, baz=1, cog=1
auntieclimactic:Debug danielsh$ ./ArgumentativeWorkflow --qux=foo --baz --cog=bar
2013-05-26 08:25:57.439 DTWorkflow[51394:707] qux=foo, baz=1, cog=bar
auntieclimactic:Debug danielsh$ ./DTWorkflow --qux=foo --cog=bar
2013-05-26 08:27:02.340 DTWorkflow[51421:707] qux=foo, baz=(null), cog=bar
````````````````````````````````````````````````````````````````````````````````````````````````

When implementing this in your workflow, remember that _arguments to long-style command parameters require an equals sign between the key and the value_.

What's more, anything that follows the arguments list will be recognized as potentially constituting an Alfred query, and placed in the returned dictionary under the reserved key `@"{query}"`. Remove the comment from the second `NSLog()` statement above, recompile, and try this:

```````bash
auntieclimactic:Debug danielsh$ ./ArgumentativeWorkflow --qux=fool --baz --cog=me once shame on you
2013-05-26 08:51:04.838 DTWorkflow[51785:707] qux=fool, baz=1, cog=me
2013-05-26 08:51:04.839 DTWorkflow[51785:707] query=once shame on you
````````````````````````````````````````````````````````````````````````````````````````````````





### Bundle Basics
Currently, only two methods are defined to interact with the Alfred bundle, both in `AWWorkflow`. The first of these is `- log:(NSString *)...`, which accepts a format string followed by a variable number of format arguments---just like `NSLog()` or `[NSString stringWithFormat:]`. However, rather than writing to the console, `- log:` saves text to a file called `framework.log` in the workflow's local folder. `- bundleID`, meanwhile, returns a string with your bundle ID, as extracted from the workflow's `info.plist` file.




### Filesystem Interaction
The framework also defines a number of methods for quickly accessing files in the local folder, the canonical cache folder, and the canonical storage folder. These, too, are provided through the workhorse `AWWorkflow` class:

* `- local`  
    Without an argument, `[wf local]` returns the path to the folder containing your executable.
* `- local:(NSString *)`  
    With an optional `NSString` argument, `[wf local:@"baz.png"]` returns the argument appended as a path component to the folder containing your executable.
* `- cache` and `- cache:(NSString *)`  
    Returns the path to your workflow's cache folder, optionally with an additional path component appended. If the cache folder does not already exist, the framework will create it; however, the file or folder referenced by `- cache:` _will not_ be created automatically.
* `- storage` and `- storage:(NSString *)`  
    Returns the path to your workflow's storage folder, optionally with an additional path component appended. If the storage folder does not already exist, the framework will create it; however, the file or folder referenced by `- storage:` _will not_ be created.




## Roadmap
In the not-too-distant future, more features from [alp][]---including settings, notifications, and Keychain access---will be ported to Alfred.framework. However, I'm always open to hearing interesting feature requests. Objective-C and Cocoa provide almost limitless possibilities for what can be done with this sort of thing, and I suspect that I'm not imaginative enough to see them all. Please don't hesitate to get in touch via [the Alfred forums](http://www.alfredforum.com/user/29-phyllisstein/), [Twitter](http://twitter.com/phyllisstein), or [e-mail](d@daniel.sh).



## License
Alfred.framework is licensed under a [Creative Commons Attribution-NonCommercial-ShareAlike 3.0](http://creativecommons.org/licenses/by-nc-sa/3.0/) license. This means that you may share and redistribute the package, but only for non-commercial purposes, only so long as you credit the original author---_moi_---and only if your derivative work is similarly licensed.

<center><a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.</center>




## [Download][latest]




[alfred]: http://alfredapp.com
[alp]: https://github.com/phyllisstein/alp
[latest]: http://alfred.daniel.sh/framework/Alfred-latest.zip
[cl]: http://alfred.daniel.sh/framework/changelog.html

# alp: A Python Module for Alfred Workflows
Formerly PyAl, alp has been trimmed and slimmed to make building [Alfred v2][] workflows even easier. Not much was lost in the transition---and indeed, some neat things were gained---and so making the transition from PyAl to alp should be relatively easy. All in all, the module is intended to result in fewer lines of repeated code and easy accessibility for newcomers to workflow construction in Alfred and with Python.

alp's primary features include:

* Functions for finding your bundle ID, cache and storage paths, and query arguments.
* Functions for reading and writing JSON and plist files.
* A function to perform fuzzy searching operations.
* A class to simplify generating [feedback XML](http://www.alfredforum.com/topic/5-generating-feedback-in-workflows/) for Alfred.
* A class to simplify saving and retrieving settings.
* A class to interface with the OS X Keychain.
* A class to send notifications to Mac OS X 10.8's Notification Center.
* A class to send notifications and information over e-mail.
* Several bundled modules for working with HTTP requests.

However, you can pick and choose from among these by deleting any of the files in the module (except for `core.py` and the folder `core_dependencies`); if something is missing, alp will silently ignore it.

To get started, simply download or clone this repository and copy the `alp` folder into your workflow directory, then `import alp`. A list of everything alp can do, with appropriate documentation, is below.

## Core Functions
These are intended to make some basic rote tasks easier and faster to code. alp defines the following functions:

* `alp.bundle()`  
    This function returns the bundle ID for your workflow by reading it from its `Info.plist` file.
* `alp.args()`  
    Returns a UTF-8 normalized list of the arguments passed to the script, which are normally separated by spaces. (Thanks to [nikipore](https://github.com/nikipore) for the idea and the tip about `unicodedata`.)
* `alp.decode(s)`  
    Returns a UTF-8 normalized string for `s`.
* `alp.local(join=None)`, `alp.cache(join=None)`, `alp.storage(join=None)`  
    These functions return the paths to, respectively, the workflow's local directory, the workflow's designated cache (volatile storage) directory, and the workflow's designated storage (nonvolatile storage) directory. The directories will be created if they do not exist. By specifying an argument for `join`, you can have a file or folder name appended to the path---however, _this file or folder will not be created_.
* `alp.readPlist(path)`, `alp.writePlist(path)`, `alp.jsonLoad(path, default=None)`, `alp.jsonDump(path)`  
    These functions will read from and write to the plist or JSON files located at `path`. If `path` is not an absolute path, they will treat it as a filename in the storage directory (so, for example, you could call `alp.jsonDump(yourFancyObject, "dump.json")` without any problems. `jsonLoad` has one additional argument, `default`, specifying the object to be dumped and returned if the JSON file did not already exist. For example, calling `alp.jsonLoad("foo.json", default=[])` would load `foo.json` with an empty list if the file was not found.
* `alp.find(query)`  
    Calls `mdfind` with the arguments given in `query`, splitting the results into a list and returning it. For more information, see [`mdfind (1)`](https://developer.apple.com/library/mac/#documentation/Darwin/Reference/ManPages/man1/mdfind.1.html).
* `alp.log(s)`  
    Writes `s` to a file called `debug.log` in the workflow's main folder.


## Feedback System
alp uses a robust and complete implementation of Alfred's feedback system, generating and outputting the required XML for the attributes you specify. This breaks down into a class called `Item` and a function called `feedback`.

* `alp.Item(**kwargs)`  
    The `Item` class is initialized with a list of keys and values, and returns one `Item` which can then be passed to the `feedback` function. The following keys are currently understood by alp and Alfred:

    + `title`: The title string to show in the feedback list.
    + `subtitle`: The subtitle string to show below the title.
    + `uid`: A unique identifier string for Alfred's sorting functions.
    + `valid`: Either `True`, `False`, or a string. Tells Alfred whether the item is actionable.
    + `autocomplete`: A string to autocomplete Alfred's query to when an invalid item is chosen.
    + `icon`: A path to an icon image, a path to a file, or a file type (default: `icon.png`).
    + `fileIcon`: If you wish to use a particular file's icon, set `icon` to its path and `fileIcon` to `True`.
    + `fileType`: If you wish to specify a type of file whose icon Alfred should use, set `icon` to the type and `fileType` to `True`.
    + `arg`: The argument to be passed as `{query}` if the item is valid and actioned. If it contains newlines, it will be passed as a separate XML key rather than an attribute of `<item></item>`.
    + `type`: Currently, can only be set to `file`, which tells Alfred to treat the result as a file.

    A nifty trick is to pass a dictionary with some or all of `alp.Item`'s keys and values into the initializer. So you could conceivably do this:

        >>> iDict = dict(title="A Title", subtitle="This is only a test.", uid="alp-test", valid=False)
        >>> i = alp.Item(**iDict)

* `Item.copy()`  
    Returns one copy of the item, which can then be modified separately and reused.
* `Item.get()`  
    Returns the current values for the item in the following format. Primarily used with the `feedback()` function below.

        {
            "data":
            {
                "content":
                {
                    "title": self.title,
                    "subtitle": self.subtitle,
                    "icon": self.icon,
                    "fileIcon": self.fileIcon,
                    "fileType": self.fileType
                },
                "attrib":
                {
                    "uid": self.uid,
                    "valid": self.valid
                }
            }
        }

    If `autocomplete` or `type` is set, that value will be added to the `"attrib"` dictionary, as will an `arg` that does not contain newlines.
* `alp.feedback(items)`  
    Takes either an individual item or a list of items for `items` and prints a UTF-8-encoded XML string for Alfred to interpret.


## Fuzzy Search
Github user [jlegewie](https://github.com/jlegewie) has contributed a stellar fuzzy-searching method to alp. Given a query, a list of strings, dictionaries, tuples, or other lists, and a key function, it returns a ranked list of matching objects. To use it, first get your data into an appropriate list, then call `alp.fuzzy_search()` with the following parameters: `alp.fuzzy_search(query, elements, key, rank, seq)`. [jlegewie](https://github.com/jlegewie) has provided the following example:

    elements = [{'key': u'ZB7K535R', 'author': u'Reskin 2003', 'title': u'Including Mechanisms in Our Models of Ascriptive Inequality: 2002 Presidential Address'}, {'key': u'DBTD3HQS', 'author': u'Igor & Ronald 2008', 'title': u'Die Zunahme der Lohnungleichheit in der Bundesrepublik. Aktuelle Befunde f\xfcr den Zeitraum von 1998 bis 2005'}, {'key': u'BKTCNEGP', 'author': u'Kirk & Sampson 2013', 'title': u'Juvenile Arrest and Collateral Educational Damage in the Transition to Adulthood'}, {'key': u'9AN4SPKT', 'author': u'Turner 2003', 'title': u'The Structure of Sociological Theory'}, {'key': u'9M92EV6S', 'author': u'Bruhns et al. 1999', 'title': u'Die heimliche Revolution'}, {'key': u'25QBTM5P', 'author': u'Durkheim 1997', 'title': u'The Division of Labor in Society'}, {'key': u'MQ3BHTBJ', 'author': u'Marx 1978', 'title': u'Alienation and Social Class'}, {'key': u'7G4BRU45', 'author': u'Marx 1978', 'title': u'The German Ideology: Part I'}, {'key': u'9ANAZXQB', 'author': u'Llorente 2006', 'title': u'Analytical Marxism and the Division of Labor'}]
    query = 'marx'
    results = fuzzy_search(query, elements, key=lambda x: '%s - %s' % (x['author'], x['title']))

As you can see, the `key` access function should extract a searchable string from your data set, and the `elements` argument should be a list that eventually contains strings. The neat thing about this being a _fuzzy_ search is that `mrx` would also match many of the Marx elements, and if a mistyped or fragmented query is closer to one good candidate (say "Max") than another (like "Marx"), results will be ranked accordingly.


## Notifications
The fact that Alfred's internal workflow workings only make it possible for a workflow to output one string can be frustrating. Enter alp's `Notification` class. It's used a little something like this:

    >>> import alp
    >>> n = alp.Notification()
    >>> n.notify("Title", "Subtitle", "Informative Text")

The title, subtitle, and informative text should be strings. This will pop up a notification that bears Python's logo but is otherwise indistinguishable from any of Alfred's notices. Currently, this is restricted to sending messages to the user---there's not yet a way to know whether the user clicks the notification, for example---but the problem is being worked on.


## HTTP Requests
The modules [Requests](http://docs.python-requests.org/en/latest/), [requests_cache](https://readthedocs.org/projects/requests-cache/), and [BeautifulSoup](http://www.crummy.com/software/BeautifulSoup/) are bundled with alp by default. (N.B.: Because they are relatively large, they can be removed from the module by deleting the folder `request`.) They vastly simplify making and interpreting HTTP requests. The alp `Request` class provides a quick-and-dirty interface to them, setting up a requests cache, making a request, and passing the returned data to BeautifulSoup for parsing.

* `alp.Request(url, payload=None, post=False, cache_for=None)`  
    The class is initialized with a URL to request, an optional key--value dictionary of arguments to pass to the URL, an optional demand that the request be POSTed, and an optional timeout---in seconds---for the cache. (By default, the cache lasts one day; pass a negative value to prevent it from expiring.) The object will then have its own `request` property, which is a Requests object and can be manipulated in any way that a standard Requests object can (see [the documentation](http://docs.python-requests.org/en/latest/) for more info).
* `Request.souper()`  
    This will return a BeautifulSoup object for the data pulled by your request, or else raise an exception if the request failed. BeautifulSoup makes parsing markup language much simpler; see [its documentation](http://www.crummy.com/software/BeautifulSoup/bs4/doc/) for more information.
* `Request.clear_cache()`  
    Clears the cache being used by `requests_cache` immediately.


## Settings Interface
The alp `Settings` object loads and saves settings in your workflow's designated storage path. On initialization, it looks for a settings file, creating it if it fails to find one and loading the predefined settings if it succeeds. It also defines the following methods:

* `Settings.set(**kwargs)`  
    Load the key--value pairs defined in `**kwargs` into memory and saves them to the settings file.
* `Settings.get(k, default=None)`  
    Searches the loaded settings for key `k`, optionally returning `default` if no setting is found.
* `Settings.delete(k)`  
    Unloads the setting for key `k` from memory and deletes it from the settings file.


## Keychain Interface
If your workflow needs to store a user's sensitive data, particularly a username--password pair, the safest way to do so is with the Mac OS X Keychain. The Keychain is normally an utter pain in the behind, but alp makes working with it a breeze. Simply initialize `alp.Keychain(service)` with a service name---for example, your workflow's bundle ID---and then use the following methods:

* `Keychain.storePassword(account, password)`  
    Saves the password securely under the given account name.
* `Keychain.retrievePassword(account)`  
    Searches the Keychain for an account matching the passed string, returning the password. Note that your script currently only has access to passwords defined by your script; you cannot start out searching for, say, "Twitter" and expect to come up with anything.
* `Keychain.modifyPassword(account, newPassword)`
    Changes the saved password for `account` to `newPassword`.
* `Keychain.deletePassword(account)`
    Removes `account`'s password from the Keychain.


## E-mail
By request, alp can also send simple plaintext messages over e-mail. Initialize the `alp.Mail()` object with the following parameters: `alp.Mail(host, port, SSL, user, pw, sender, to, mimetype, subject, body)`. `SSL` should be set to `True` or `False`. `mimetype` should be a string specifying the MIME subtype under "text/" and defaults to "plain" if `None` is passed. `to` can be either a single e-mail address or a list of e-mail addresses. Use `Mail.notify()` to send your message(s):

    >>> e = alp.Mail(host, port, SSL, user, pw, sender, to, mimetype, subject, body)
    >>> e.notify()

See the list of exceptions that can be raised [in the docs](http://docs.python.org/2/library/smtplib.html).


## Help and Support
The [Alfred v2 forums](http://www.alfredforum.com) are a good place to look for answers, but you can also reach this package's maintenance man, [Daniel](http://daniel.sh), at d atsign daniel dot sh or on Twitter at [@phyllisstein](http://twitter.com/phyllisstein/).


## License
alp and all of its components are free to use and distribute however you see fit. Go hog-wild. The author appreciates getting some credit for his work, and the authors of Requests, requests_cache, BeautifulSoup, [six](https://bitbucket.org/gutworth/six/), and [biplist](https://github.com/wooster/biplist/) probably do as well, so it'd be neat if you'd mention us all somewhere. Additionally, donations are gratefully accepted over at [my Alfred website](http://alfred.daniel.sh).



[Alfred v2]: http://www.alfredapp.com

# Alfred.framework for Objective-C
Alfred.framework is a lightweight Objective-C framework for developing workflow components for [Alfred v2][alfred]. Modeled in part on [alp][], Alfred.framework is designed to automate a number of repetitive and annoying workflow tasks with the goal of making it faster and easier to generate fewer lines of code. The library is still in its developmental infancy, but current features include:

* Painless generation of feedback XML.
* Fuzzy searching, modeled on [alp][].
* Methods for accessing cache folders, storage folders, and the local folder.
* An argument parser.
* Silent error logging.

You can [download the latest version here][latest]; for more information about this and prior releases, [see the changelog][cl]. You can also browse and download the source code [at Github](https://github.com/phyllisstein/Alfred.framework).


## Installation
Adding Alfred.framework to XCode is more of a chore than is ideal but less of a chore than you might fear. To get started, [download the latest version][latest] and extract the contents of the zip. Then, in XCode, click the plus sign in the lower-left-hand corner of the window, select 'Add Files to "MyAlfredWorkflow"...,' and navigate to the folder where you saved Alfred.framework. Ensure that "Copy items to the destination group's folder" and "MyAlfredWorkflow" (under "Add to targets") are checked, then select Alfred.framework and click "Add."

![](http://alfred.daniel.sh/framework/setup-1.png)

Now select the main project item from the pane to the left, then choose the target "MyAlfredWorkflow." Under "Build Phases," click the disclosure triangle next to "Link binary with libraries" and make sure it includes Alfred.framework. If not, click the plus sign, then "Add Other...," then navigate to the file on your hard drive and add it manually.

Now, in your main source file `main.m`, add a line lines below `#import <Foundation/Foundation.h>`:

```````````objectivec
//
//  main.m
//  MyAlfredWorkflow
//
//  Created by Daniel Shannon on 5/25/13.
//  Copyright (c) 2013 Daniel Shannon. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <Alfred/Alfred.h>

int main(int argc, const char * argv[])
{
```````````````````````````````````````````````````````````````````````````````````````````````

If you've done everything correctly so far, XCode should try to autocomplete `<Alfred/Alfred.h>` as you type, and your screen should look something like this:

![](http://alfred.daniel.sh/framework/setup-2.png)

Note that the organization of the files in the left pane doesn't make much of a difference, so long as you don't delete the framework.

Now, in order to use Alfred.framework, you simply must ensure that the framework bundle is copied to the same directory as your executable. Then import `<Alfred/Alfred.h>` and you're ready to go!


## Usage
Currently, Alfred.framework provides the following core features:

* Painless generation of feedback XML.
* Fuzzy searching, modeled on [alp][].
* Methods for accessing cache folders, storage folders, and the local folder.
* An argument parser.
* Silent error logging.

Each one is accessible through `<Alfred/Alfred.h>`. The two main classes currently in use are `AWWorkflow` and `AWFeedbackItem`. `AWWorkflow` is an interface to most of the methods above, whereas `AWFeedbackItem` is pretty much just what it says on the can.

### Feedback XML
To generate feedback XML in Alfred.framework, you must first create and configure one or more `AWFeedbackItem`s. There are a number of ways to do this. The first and most cumbersome involves using getter and setter methods to set up feedback items. For example, this would be perfectly valid:

```````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWFeedbackItem *i = [[AWFeedbackItem alloc] init];
i.title = @"Information";
i.subtitle = @"S'more information.";
i.valid = YES;
i.arg = @"get info";
```````````````````````````````````````````````````````````````````````````````````````````````

...and so on. The following properties are presently used to pass data back to Alfred:

```````objectivec
@property NSString      *title;
@property NSString      *subtitle;
@property NSString      *uid;
@property NSNumber      *valid;
@property NSString      *autocomplete;
@property NSString      *icon;
@property NSNumber      *fileicon;
@property NSNumber      *filetype;
@property NSString      *arg;
@property NSString      *type;
```````````````````````````````````````````````````````````````````````````````````````````````

However, because setting each one would be tedious, `AWFeedbackItem` provides a class method, `+ itemWithObjectsAndKeys:(id)...`, and an instance method, `- initWithObjects:(NSArray *) forKeys:(NSArray *)`, to make it simpler. As their first arguments, both take a `BOOL` that determines whether the XML item is considered actionable by Alfred. The class method then allows you to specify a `nil`-terminated list of alternative objects and keys (property names) to set up the item. With the exception of the three `NSNumber` objects, which should be `@YES` or `@NO`, all keys and values _must_ be strings. For example:

````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWFeedbackItem *i = [AWFeedbackItem itemWithObjectsAndKeys:@"Entitlement", @"title", @"Subversion", @"subtitle", @"iconography.png", @"icon", @"argumentation", @"arg", @YES, @"valid", nil];
NSLog(@"xml=%@", [i xml]);
```````````````````````````````````````````````````````````````````````````````````````````````

...would log the following to the console:

`````````xml
AlfredWorkflowTest[31201:303] xml=<item valid="yes" arg="argumentation"><title>Entitlement</title><subtitle>Subversion</subtitle><icon>iconography.png</icon></item>
```````````````````````````````````````````````````````````````````````````````````````````````

You could do something similar with the customized constructor method. This method, rather than taking a list of `NSString` objects, takes two `NSArray` objects---one of keys, one of values---which must contain `NSString`s. Here's an example:

````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWFeedbackItem *j = [[AWFeedbackItem alloc] initWithObjects:@[@"Titillation", @"Submission & Subdual", @"automation", @NO] forKeys:@[@"title", @"subtitle", @"autocomplete", @"valid"];
NSLog(@"xml=%@", [j xml]);
```````````````````````````````````````````````````````````````````````````````````````````````

``````````````xml
AlfredWorkflowTest[31201:303] xml=<item valid="no" autocomplete="automation"><title>Titillation</title><subtitle>Submission &amp; Subdual</subtitle><icon>icon.png</icon></item>
```````````````````````````````````````````````````````````````````````````````````````````````

Alfred.framework automatically escapes XML strings passed to `AWFeedbackItem`. Note that the feedback item's `- xml` method does not generate the complete XML string that Alfred needs to provide feedback. That functionality is provided through a method of `AWWorkflow`, and `- xml` is only used here for the purposes of demonstration.

To feed data back to Alfred, you must call `AWWorkflow`'s instance method `- flush:(BOOL) feedbackItems:(AWFeedbackItem *)...`. Like the feedback item's class method, this too takes a `nil`-terminated list of objects; in this case, however, each one should be an `AWFeedbackItem` instance. The first argument is a `BOOL`; if set to `YES`, it will flush the standard output buffer to Alfred and terminate your program. Otherwise, it will only spool the XML into the standard output. Call it like this:

```````````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWWorkflow *wf = [[AWWorkflow alloc] init];

AWFeedbackItem *i = [AWFeedbackItem validItem:YES withObjectsAndKeys:@"Entitlement", @"title", @"Subversion", @"subtitle", @"iconography.png", @"icon", @"argumentation", @"arg", nil];
AWFeedbackItem *j = [[AWFeedbackItem alloc] initAsValid:NO withObjects:@[@"Titillation", @"Submission & Subdual", @"automation"] forKeys:@[@"title", @"subtitle", @"autocomplete"];

[wf flush:YES feedbackItems:i, j, nil];
```````````````````````````````````````````````````````````````````````````````````````````````

This ends the program immediately, printing the following XML to the standard output:

````````````xml
<?xml version="1.0"?><items><item valid="yes" arg="argumentation"><title>Entitlement</title><subtitle>Subversion</subtitle><icon>iconography.png</icon></item><item valid="no" autocomplete="automation"><title>Titillation</title><subtitle>Submission &amp; Subdual</subtitle><icon>icon.png</icon></item></items>
```````````````````````````````````````````````````````````````````````````````````````````````

If you're generating feedback items on-the-fly, of course, you'll want to be able to send them all at once. Rather than passing them one by one to `- flush:feedbackItems:` and only flushing at the last object, you can also call `- flush:(BOOL) feedbackArray:(NSArray *)` with an `NSArary` containing `AWFeedbackItem`s. For example, you might want to rewrite the sample above with a condition:

```````````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWWorkflow *wf = [[AWWorkflow alloc] init];
NSMutableArray *fbi = [[NSMutableArray alloc] initWithCapacity:0];

if (myCondition == YES) {
    AWFeedbackItem *i = [AWFeedbackItem validItem:YES withObjectsAndKeys:@"Entitlement", @"title", @"Subversion", @"subtitle", @"iconography.png", @"icon", @"argumentation", @"arg", nil];
    [fbi addObject:i];
}
AWFeedbackItem *j = [[AWFeedbackItem alloc] initAsValid:NO withObjects:@[@"Titillation", @"Submission & Subdual", @"automation"] forKeys:@[@"title", @"subtitle", @"autocomplete"];
[fbi addObject:j];

[wf flush:YES feedbackArray:fbi];
```````````````````````````````````````````````````````````````````````````````````````````````



### Fuzzy Searching
Alfred.framework includes a port of [alp][]'s fuzzy searching feature, which is considerably sped up in compiled code without losing any of its power. To use it, simply fill an `NSArray` with a number of objects. These objects can be of any type, so long as an `NSString` to be matched against can be extracted from them. The framework will return another `NSArray` with any matching elements, sorted by the quality of the match.

The method that handles this is also declared in `AWWorkflow`, as `- fuzzySearchFor:(NSString *) in:(NSArray *) withKeyBlock:(NSString *(^)(id))`. It takes a string with the search query, an array of objects, and a block function that will be applied to each element of the array to get a search string. The block should take a single object, though that object can contain many other objects, and return a string to be searched.

Let's take a look at some sample code, using data drawn from [alp][]'s sample case:

```````{.objectivec}
#import <Alfred/Alfred.h>

// [...]

AWWorkflow *wf = [[AWWorkflow alloc] init];

NSArray *k = @[@"key", @"author", @"title"];
NSArray *v0 = @[@"ZB7K535R", @"Reskin 2003", @"Including Mechanisms in Our Models of Ascriptive Inequality: 2002 Presidential Address"];
NSArray *v1 = @[@"DBTD3HQS", @"Igor & Ronald 2008", @"Die Zunahme der Lohnungleichheit in der Bundesrepublik. Aktuelle Befunde für den Zeitraum von 1998 bis 2005"];
NSArray *v2 = @[@"MQ3BHTBJ", @"Marx 1978", @"Alienation and Social Class"];
NSArray *v3 = @[@"7G4BRU45", @"Marx 1978", @"The German Ideology"];
NSArray *v4 = @[@"9ANAZXQB", @"Llorente 2006", @"Analytical Marxism and the Division of Labor"];
NSArray *ofDicts = @[[NSDictionary dictionaryWithObjects:v0 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v1 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v2 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v3 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v4 forKeys:k]];

NSArray *res = [wf fuzzySearchFor:@"marx" in:ofDicts withKeyBlock: ^(id obj) {
    NSDictionary *d = (NSDictionary *)obj;
    NSString *s = [NSString stringWithFormat:@"%@ - %@",
                    [d objectForKey:@"author"],
                    [d objectForKey:@"title"]];
    return s;
}];
NSLog(@"res=%@", res);
```````````````````````````````````````````````````````````````````````````````````````````````

As you can see, it's okay that the strings we need to search are buried deep in the actual object so long as we know how to return a string from our key block; otherwise, the search function won't know what it should be applying its filters to. What's actually being searched in each case is the string `"{author} - {title}"`; what's returned, on the other hand, is the complete object that yielded each match:

    AlfredWorkflowTest[32039:303] res=(
        {
            author = "Marx 1978";
            key = MQ3BHTBJ;
            title = "Alienation and Social Class";
        },
        {
            author = "Marx 1978";
            key = 7G4BRU45;
            title = "The German Ideology";
        },
        {
            author = "Llorente 2006";
            key = 9ANAZXQB;
            title = "Analytical Marxism and the Division of Labor";
        }
    )

It should be considered purely coincidental that the order of the objects returned is identical to the order in which they were presented. The algorithm calculates quality of match based on the number of characters in sequence ("marx" is preferred to "moarx"---unbroken sequences are better) and the position of the sequence in the search string ("marx" is preferred to "smarx"---earlier is better).



### Argument Parsing
The `AWWorkflow` object provides a method for converting arguments to the workflow in the form of `--key=value` into an `NSDictionary` with usable objects. To invoke it, you must first create an array of dictionaries that define the expected arguments. Each dictionary requires three key--value pairs---`@"name"`, a string with the long name of the argument key, `@"flag"`, a single-letter string with the short name of the argument key, and `@"has_arg"`, an `NSNumber` that determines whether the argument key is an on/off flag (set to `@NO`), requires a value (set to `@YES`), or takes an optional value (set to anything else). Once you've determined your expected arguments, you can invoke `AWWorkflow`'s `- parseArguments:(const char **) withKeys:(NSArray *) count:(int)` method. This returns a dictionary object whose keys are the arguments' names and whose values were passed in to the program.

``````objectivec
#import <Foundation/Foundation.h>
#import <Alfred/Alfred.h>

int main(int argc, const char *argv[])
{
    @autoreleasepool {
        AWWorkflow *wf = [[AWWorkflow alloc] init];
        NSArray *k = @[@{@"name": @"qux", @"has_arg": @YES, @"flag": @"q"},
                       @{@"name": @"baz", @"has_arg": @NO,  @"flag": @"b"},
                       @{@"name": @"cog", @"has_arg": @2,   @"flag": @"c"}];
        NSDictionary *args = [wf parseArguments:argv withKeys:k count:argc];
        NSLog(@"qux=%@, baz=%@, cog=%@", [args valueForKey:@"qux"], [args valueForKey:@"baz"], [args valueForKey:@"cog"]);
        // NSLog(@"query=%@", [args valueForKey:@"{query}"]);
    }
    return 0;
}
````````````````````````````````````````````````````````````````````````````````````````````````

You can compile this program, drop the framework into its folder (remember, it must be in the same directory as your executable), and run it from a Terminal window to check that it works:

````````bash
auntieclimactic:Debug danielsh$ ./ArgumentativeWorkflow --qux=foo --baz --cog
2013-05-26 08:20:22.847 DTWorkflow[48183:707] qux=foo, baz=1, cog=1
auntieclimactic:Debug danielsh$ ./ArgumentativeWorkflow --qux=foo --baz --cog=bar
2013-05-26 08:25:57.439 DTWorkflow[51394:707] qux=foo, baz=1, cog=bar
auntieclimactic:Debug danielsh$ ./DTWorkflow --qux=foo --cog=bar
2013-05-26 08:27:02.340 DTWorkflow[51421:707] qux=foo, baz=(null), cog=bar
````````````````````````````````````````````````````````````````````````````````````````````````

When implementing this in your workflow, remember that _arguments to long-style command parameters require an equals sign between the key and the value_.

What's more, anything that follows the arguments list will be recognized as potentially constituting an Alfred query, and placed in the returned dictionary under the reserved key `@"{query}"`. Remove the comment from the second `NSLog()` statement above, recompile, and try this:

```````bash
auntieclimactic:Debug danielsh$ ./ArgumentativeWorkflow --qux=fool --baz --cog=me once shame on you
2013-05-26 08:51:04.838 DTWorkflow[51785:707] qux=fool, baz=1, cog=me
2013-05-26 08:51:04.839 DTWorkflow[51785:707] query=once shame on you
````````````````````````````````````````````````````````````````````````````````````````````````





### Bundle Basics
Currently, only two methods are defined to interact with the Alfred bundle, both in `AWWorkflow`. The first of these is `- log:(NSString *)...`, which accepts a format string followed by a variable number of format arguments---just like `NSLog()` or `[NSString stringWithFormat:]`. However, rather than writing to the console, `- log:` saves text to a file called `framework.log` in the workflow's local folder. `- bundleID`, meanwhile, returns a string with your bundle ID, as extracted from the workflow's `info.plist` file.




### Filesystem Interaction
The framework also defines a number of methods for quickly accessing files in the local folder, the canonical cache folder, and the canonical storage folder. These, too, are provided through the workhorse `AWWorkflow` class:

* `- local`  
    Without an argument, `[wf local]` returns the path to the folder containing your executable.
* `- local:(NSString *)`  
    With an optional `NSString` argument, `[wf local:@"baz.png"]` returns the argument appended as a path component to the folder containing your executable.
* `- cache` and `- cache:(NSString *)`  
    Returns the path to your workflow's cache folder, optionally with an additional path component appended. If the cache folder does not already exist, the framework will create it; however, the file or folder referenced by `- cache:` _will not_ be created automatically.
* `- storage` and `- storage:(NSString *)`  
    Returns the path to your workflow's storage folder, optionally with an additional path component appended. If the storage folder does not already exist, the framework will create it; however, the file or folder referenced by `- storage:` _will not_ be created.




## Roadmap
In the not-too-distant future, more features from [alp][]---including settings, notifications, and Keychain access---will be ported to Alfred.framework. However, I'm always open to hearing interesting feature requests. Objective-C and Cocoa provide almost limitless possibilities for what can be done with this sort of thing, and I suspect that I'm not imaginative enough to see them all. Please don't hesitate to get in touch via [the Alfred forums](http://www.alfredforum.com/user/29-phyllisstein/), [Twitter](http://twitter.com/phyllisstein), or [e-mail](d@daniel.sh).



## License
Alfred.framework is licensed under a [Creative Commons Attribution-NonCommercial-ShareAlike 3.0](http://creativecommons.org/licenses/by-nc-sa/3.0/) license. This means that you may share and redistribute the package, but only for non-commercial purposes, only so long as you credit the original author---_moi_---and only if your derivative work is similarly licensed.

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.




## [Download][latest]




[alfred]: http://alfredapp.com
[alp]: https://github.com/phyllisstein/alp
[latest]: http://alfred.daniel.sh/framework/Alfred-latest.zip
[cl]: http://alfred.daniel.sh/framework/changelog.html

# Alfred.framework for Objective-C
Alfred.framework is a lightweight Objective-C framework for developing workflow components for [Alfred v2][alfred]. Modeled in part on [alp][], Alfred.framework is designed to automate a number of repetitive and annoying workflow tasks with the goal of making it faster and easier to generate fewer lines of code. The library is still in its developmental infancy, but current features include:

* Painless generation of feedback XML.
* Fuzzy searching, modeled on [alp][].
* Methods for accessing cache folders, storage folders, and the local folder.
* An argument parser.
* Silent error logging.

You can [download the latest version here][latest]; for more information about this and prior releases, [see the changelog][cl]. You can also browse and download the source code [at Github](https://github.com/phyllisstein/Alfred.framework).


## Installation
Adding Alfred.framework to XCode is more of a chore than is ideal but less of a chore than you might fear. To get started, [download the latest version][latest] and extract the contents of the zip. Then, in XCode, click the plus sign in the lower-left-hand corner of the window, select 'Add Files to "MyAlfredWorkflow"...,' and navigate to the folder where you saved Alfred.framework. Ensure that "Copy items to the destination group's folder" and "MyAlfredWorkflow" (under "Add to targets") are checked, then select Alfred.framework and click "Add."

![](http://alfred.daniel.sh/framework/setup-1.png)

Now select the main project item from the pane to the left, then choose the target "MyAlfredWorkflow." Under "Build Phases," click the disclosure triangle next to "Link binary with libraries" and make sure it includes Alfred.framework. If not, click the plus sign, then "Add Other...," then navigate to the file on your hard drive and add it manually.

Now, in your main source file `main.m`, add a line lines below `#import <Foundation/Foundation.h>`:

```````````objectivec
//
//  main.m
//  MyAlfredWorkflow
//
//  Created by Daniel Shannon on 5/25/13.
//  Copyright (c) 2013 Daniel Shannon. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <Alfred/Alfred.h>

int main(int argc, const char * argv[])
{
```````````````````````````````````````````````````````````````````````````````````````````````

If you've done everything correctly so far, XCode should try to autocomplete `<Alfred/Alfred.h>` as you type, and your screen should look something like this:

![](http://alfred.daniel.sh/framework/setup-2.png)

Note that the organization of the files in the left pane doesn't make much of a difference, so long as you don't delete the framework.

Now, in order to use Alfred.framework, you simply must ensure that the framework bundle is copied to the same directory as your executable. Then import `<Alfred/Alfred.h>` and you're ready to go!


## Usage
Currently, Alfred.framework provides the following core features:

* Painless generation of feedback XML.
* Fuzzy searching, modeled on [alp][].
* Methods for accessing cache folders, storage folders, and the local folder.
* An argument parser.
* Silent error logging.

Each one is accessible through `<Alfred/Alfred.h>`. The two main classes currently in use are `AWWorkflow` and `AWFeedbackItem`. `AWWorkflow` is an interface to most of the methods above, whereas `AWFeedbackItem` is pretty much just what it says on the can.

### Feedback XML
To generate feedback XML in Alfred.framework, you must first create and configure one or more `AWFeedbackItem`s. There are a number of ways to do this. The first and most cumbersome involves using getter and setter methods to set up feedback items. For example, this would be perfectly valid:

```````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWFeedbackItem *i = [[AWFeedbackItem alloc] init];
i.title = @"Information";
i.subtitle = @"S'more information.";
i.valid = YES;
i.arg = @"get info";
```````````````````````````````````````````````````````````````````````````````````````````````

...and so on. The following properties are presently used to pass data back to Alfred:

```````objectivec
@property NSString      *title;
@property NSString      *subtitle;
@property NSString      *uid;
@property NSNumber      *valid;
@property NSString      *autocomplete;
@property NSString      *icon;
@property NSNumber      *fileicon;
@property NSNumber      *filetype;
@property NSString      *arg;
@property NSString      *type;
```````````````````````````````````````````````````````````````````````````````````````````````

However, because setting each one would be tedious, `AWFeedbackItem` provides a class method, `+ itemWithObjectsAndKeys:(id)...`, and an instance method, `- initWithObjects:(NSArray *) forKeys:(NSArray *)`, to make it simpler. As their first arguments, both take a `BOOL` that determines whether the XML item is considered actionable by Alfred. The class method then allows you to specify a `nil`-terminated list of alternative objects and keys (property names) to set up the item. With the exception of the three `NSNumber` objects, which should be `@YES` or `@NO`, all keys and values _must_ be strings. For example:

````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWFeedbackItem *i = [AWFeedbackItem itemWithObjectsAndKeys:@"Entitlement", @"title", @"Subversion", @"subtitle", @"iconography.png", @"icon", @"argumentation", @"arg", @YES, @"valid", nil];
NSLog(@"xml=%@", [i xml]);
```````````````````````````````````````````````````````````````````````````````````````````````

...would log the following to the console:

`````````xml
AlfredWorkflowTest[31201:303] xml=<item valid="yes" arg="argumentation"><title>Entitlement</title><subtitle>Subversion</subtitle><icon>iconography.png</icon></item>
```````````````````````````````````````````````````````````````````````````````````````````````

You could do something similar with the customized constructor method. This method, rather than taking a list of `NSString` objects, takes two `NSArray` objects---one of keys, one of values---which must contain `NSString`s. Here's an example:

````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWFeedbackItem *j = [[AWFeedbackItem alloc] initWithObjects:@[@"Titillation", @"Submission & Subdual", @"automation", @NO] forKeys:@[@"title", @"subtitle", @"autocomplete", @"valid"];
NSLog(@"xml=%@", [j xml]);
```````````````````````````````````````````````````````````````````````````````````````````````

``````````````xml
AlfredWorkflowTest[31201:303] xml=<item valid="no" autocomplete="automation"><title>Titillation</title><subtitle>Submission &amp; Subdual</subtitle><icon>icon.png</icon></item>
```````````````````````````````````````````````````````````````````````````````````````````````

Alfred.framework automatically escapes XML strings passed to `AWFeedbackItem`. Note that the feedback item's `- xml` method does not generate the complete XML string that Alfred needs to provide feedback. That functionality is provided through a method of `AWWorkflow`, and `- xml` is only used here for the purposes of demonstration.

To feed data back to Alfred, you must call `AWWorkflow`'s instance method `- flush:(BOOL) feedbackItems:(AWFeedbackItem *)...`. Like the feedback item's class method, this too takes a `nil`-terminated list of objects; in this case, however, each one should be an `AWFeedbackItem` instance. The first argument is a `BOOL`; if set to `YES`, it will flush the standard output buffer to Alfred and terminate your program. Otherwise, it will only spool the XML into the standard output. Call it like this:

```````````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWWorkflow *wf = [[AWWorkflow alloc] init];

AWFeedbackItem *i = [AWFeedbackItem validItem:YES withObjectsAndKeys:@"Entitlement", @"title", @"Subversion", @"subtitle", @"iconography.png", @"icon", @"argumentation", @"arg", nil];
AWFeedbackItem *j = [[AWFeedbackItem alloc] initAsValid:NO withObjects:@[@"Titillation", @"Submission & Subdual", @"automation"] forKeys:@[@"title", @"subtitle", @"autocomplete"];

[wf flush:YES feedbackItems:i, j, nil];
```````````````````````````````````````````````````````````````````````````````````````````````

This ends the program immediately, printing the following XML to the standard output:

````````````xml
<?xml version="1.0"?><items><item valid="yes" arg="argumentation"><title>Entitlement</title><subtitle>Subversion</subtitle><icon>iconography.png</icon></item><item valid="no" autocomplete="automation"><title>Titillation</title><subtitle>Submission &amp; Subdual</subtitle><icon>icon.png</icon></item></items>
```````````````````````````````````````````````````````````````````````````````````````````````

If you're generating feedback items on-the-fly, of course, you'll want to be able to send them all at once. Rather than passing them one by one to `- flush:feedbackItems:` and only flushing at the last object, you can also call `- flush:(BOOL) feedbackArray:(NSArray *)` with an `NSArary` containing `AWFeedbackItem`s. For example, you might want to rewrite the sample above with a condition:

```````````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWWorkflow *wf = [[AWWorkflow alloc] init];
NSMutableArray *fbi = [[NSMutableArray alloc] initWithCapacity:0];

if (myCondition == YES) {
    AWFeedbackItem *i = [AWFeedbackItem validItem:YES withObjectsAndKeys:@"Entitlement", @"title", @"Subversion", @"subtitle", @"iconography.png", @"icon", @"argumentation", @"arg", nil];
    [fbi addObject:i];
}
AWFeedbackItem *j = [[AWFeedbackItem alloc] initAsValid:NO withObjects:@[@"Titillation", @"Submission & Subdual", @"automation"] forKeys:@[@"title", @"subtitle", @"autocomplete"];
[fbi addObject:j];

[wf flush:YES feedbackArray:fbi];
```````````````````````````````````````````````````````````````````````````````````````````````



### Fuzzy Searching
Alfred.framework includes a port of [alp][]'s fuzzy searching feature, which is considerably sped up in compiled code without losing any of its power. To use it, simply fill an `NSArray` with a number of objects. These objects can be of any type, so long as an `NSString` to be matched against can be extracted from them. The framework will return another `NSArray` with any matching elements, sorted by the quality of the match.

The method that handles this is also declared in `AWWorkflow`, as `- fuzzySearchFor:(NSString *) in:(NSArray *) withKeyBlock:(NSString *(^)(id))`. It takes a string with the search query, an array of objects, and a block function that will be applied to each element of the array to get a search string. The block should take a single object, though that object can contain many other objects, and return a string to be searched.

Let's take a look at some sample code, using data drawn from [alp][]'s sample case:

```````{.objectivec}
#import <Alfred/Alfred.h>

// [...]

AWWorkflow *wf = [[AWWorkflow alloc] init];

NSArray *k = @[@"key", @"author", @"title"];
NSArray *v0 = @[@"ZB7K535R", @"Reskin 2003", @"Including Mechanisms in Our Models of Ascriptive Inequality: 2002 Presidential Address"];
NSArray *v1 = @[@"DBTD3HQS", @"Igor & Ronald 2008", @"Die Zunahme der Lohnungleichheit in der Bundesrepublik. Aktuelle Befunde für den Zeitraum von 1998 bis 2005"];
NSArray *v2 = @[@"MQ3BHTBJ", @"Marx 1978", @"Alienation and Social Class"];
NSArray *v3 = @[@"7G4BRU45", @"Marx 1978", @"The German Ideology"];
NSArray *v4 = @[@"9ANAZXQB", @"Llorente 2006", @"Analytical Marxism and the Division of Labor"];
NSArray *ofDicts = @[[NSDictionary dictionaryWithObjects:v0 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v1 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v2 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v3 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v4 forKeys:k]];

NSArray *res = [wf fuzzySearchFor:@"marx" in:ofDicts withKeyBlock: ^(id obj) {
    NSDictionary *d = (NSDictionary *)obj;
    NSString *s = [NSString stringWithFormat:@"%@ - %@",
                    [d objectForKey:@"author"],
                    [d objectForKey:@"title"]];
    return s;
}];
NSLog(@"res=%@", res);
```````````````````````````````````````````````````````````````````````````````````````````````

As you can see, it's okay that the strings we need to search are buried deep in the actual object so long as we know how to return a string from our key block; otherwise, the search function won't know what it should be applying its filters to. What's actually being searched in each case is the string `"{author} - {title}"`; what's returned, on the other hand, is the complete object that yielded each match:

    AlfredWorkflowTest[32039:303] res=(
        {
            author = "Marx 1978";
            key = MQ3BHTBJ;
            title = "Alienation and Social Class";
        },
        {
            author = "Marx 1978";
            key = 7G4BRU45;
            title = "The German Ideology";
        },
        {
            author = "Llorente 2006";
            key = 9ANAZXQB;
            title = "Analytical Marxism and the Division of Labor";
        }
    )

It should be considered purely coincidental that the order of the objects returned is identical to the order in which they were presented. The algorithm calculates quality of match based on the number of characters in sequence ("marx" is preferred to "moarx"---unbroken sequences are better) and the position of the sequence in the search string ("marx" is preferred to "smarx"---earlier is better).



### Argument Parsing
The `AWWorkflow` object provides a method for converting arguments to the workflow in the form of `--key=value` into an `NSDictionary` with usable objects. To invoke it, you must first create an array of dictionaries that define the expected arguments. Each dictionary requires three key--value pairs---`@"name"`, a string with the long name of the argument key, `@"flag"`, a single-letter string with the short name of the argument key, and `@"has_arg"`, an `NSNumber` that determines whether the argument key is an on/off flag (set to `@NO`), requires a value (set to `@YES`), or takes an optional value (set to anything else). Once you've determined your expected arguments, you can invoke `AWWorkflow`'s `- parseArguments:(const char **) withKeys:(NSArray *) count:(int)` method. This returns a dictionary object whose keys are the arguments' names and whose values were passed in to the program.

``````objectivec
#import <Foundation/Foundation.h>
#import <Alfred/Alfred.h>

int main(int argc, const char *argv[])
{
    @autoreleasepool {
        AWWorkflow *wf = [[AWWorkflow alloc] init];
        NSArray *k = @[@{@"name": @"qux", @"has_arg": @YES, @"flag": @"q"},
                       @{@"name": @"baz", @"has_arg": @NO,  @"flag": @"b"},
                       @{@"name": @"cog", @"has_arg": @2,   @"flag": @"c"}];
        NSDictionary *args = [wf parseArguments:argv withKeys:k count:argc];
        NSLog(@"qux=%@, baz=%@, cog=%@", [args valueForKey:@"qux"], [args valueForKey:@"baz"], [args valueForKey:@"cog"]);
        // NSLog(@"query=%@", [args valueForKey:@"{query}"]);
    }
    return 0;
}
````````````````````````````````````````````````````````````````````````````````````````````````

You can compile this program, drop the framework into its folder (remember, it must be in the same directory as your executable), and run it from a Terminal window to check that it works:

````````bash
auntieclimactic:Debug danielsh$ ./ArgumentativeWorkflow --qux=foo --baz --cog
2013-05-26 08:20:22.847 DTWorkflow[48183:707] qux=foo, baz=1, cog=1
auntieclimactic:Debug danielsh$ ./ArgumentativeWorkflow --qux=foo --baz --cog=bar
2013-05-26 08:25:57.439 DTWorkflow[51394:707] qux=foo, baz=1, cog=bar
auntieclimactic:Debug danielsh$ ./DTWorkflow --qux=foo --cog=bar
2013-05-26 08:27:02.340 DTWorkflow[51421:707] qux=foo, baz=(null), cog=bar
````````````````````````````````````````````````````````````````````````````````````````````````

When implementing this in your workflow, remember that _arguments to long-style command parameters require an equals sign between the key and the value_.

What's more, anything that follows the arguments list will be recognized as potentially constituting an Alfred query, and placed in the returned dictionary under the reserved key `@"{query}"`. Remove the comment from the second `NSLog()` statement above, recompile, and try this:

```````bash
auntieclimactic:Debug danielsh$ ./ArgumentativeWorkflow --qux=fool --baz --cog=me once shame on you
2013-05-26 08:51:04.838 DTWorkflow[51785:707] qux=fool, baz=1, cog=me
2013-05-26 08:51:04.839 DTWorkflow[51785:707] query=once shame on you
````````````````````````````````````````````````````````````````````````````````````````````````





### Bundle Basics
Currently, only two methods are defined to interact with the Alfred bundle, both in `AWWorkflow`. The first of these is `- log:(NSString *)...`, which accepts a format string followed by a variable number of format arguments---just like `NSLog()` or `[NSString stringWithFormat:]`. However, rather than writing to the console, `- log:` saves text to a file called `framework.log` in the workflow's local folder. `- bundleID`, meanwhile, returns a string with your bundle ID, as extracted from the workflow's `info.plist` file.




### Filesystem Interaction
The framework also defines a number of methods for quickly accessing files in the local folder, the canonical cache folder, and the canonical storage folder. These, too, are provided through the workhorse `AWWorkflow` class:

* `- local`  
    Without an argument, `[wf local]` returns the path to the folder containing your executable.
* `- local:(NSString *)`  
    With an optional `NSString` argument, `[wf local:@"baz.png"]` returns the argument appended as a path component to the folder containing your executable.
* `- cache` and `- cache:(NSString *)`  
    Returns the path to your workflow's cache folder, optionally with an additional path component appended. If the cache folder does not already exist, the framework will create it; however, the file or folder referenced by `- cache:` _will not_ be created automatically.
* `- storage` and `- storage:(NSString *)`  
    Returns the path to your workflow's storage folder, optionally with an additional path component appended. If the storage folder does not already exist, the framework will create it; however, the file or folder referenced by `- storage:` _will not_ be created.




## Roadmap
In the not-too-distant future, more features from [alp][]---including settings, notifications, and Keychain access---will be ported to Alfred.framework. However, I'm always open to hearing interesting feature requests. Objective-C and Cocoa provide almost limitless possibilities for what can be done with this sort of thing, and I suspect that I'm not imaginative enough to see them all. Please don't hesitate to get in touch via [the Alfred forums](http://www.alfredforum.com/user/29-phyllisstein/), [Twitter](http://twitter.com/phyllisstein), or [e-mail](d@daniel.sh).



## License
Alfred.framework is licensed under a [Creative Commons Attribution-NonCommercial-ShareAlike 3.0](http://creativecommons.org/licenses/by-nc-sa/3.0/) license. This means that you may share and redistribute the package, but only for non-commercial purposes, only so long as you credit the original author---_moi_---and only if your derivative work is similarly licensed.

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.




## [Download][latest]




[alfred]: http://alfredapp.com
[alp]: https://github.com/phyllisstein/alp
[latest]: http://alfred.daniel.sh/framework/Alfred-latest.zip
[cl]: http://alfred.daniel.sh/framework/changelog.html

# Alfred.framework for Objective-C
Alfred.framework is a lightweight Objective-C framework for developing workflow components for [Alfred v2][alfred]. Modeled in part on [alp][], Alfred.framework is designed to automate a number of repetitive and annoying workflow tasks with the goal of making it faster and easier to generate fewer lines of code. The library is still in its developmental infancy, but current features include:

* Painless generation of feedback XML.
* Fuzzy searching, modeled on [alp][].
* Methods for accessing cache folders, storage folders, and the local folder.
* An argument parser.
* Silent error logging.

You can [download the latest version here][latest]; for more information about this and prior releases, [see the changelog][cl]. You can also browse and download the source code [at Github](https://github.com/phyllisstein/Alfred.framework).


## Installation
Adding Alfred.framework to XCode is more of a chore than is ideal but less of a chore than you might fear. To get started, [download the latest version][latest] and extract the contents of the zip. Then, in XCode, click the plus sign in the lower-left-hand corner of the window, select 'Add Files to "MyAlfredWorkflow"...,' and navigate to the folder where you saved Alfred.framework. Ensure that "Copy items to the destination group's folder" and "MyAlfredWorkflow" (under "Add to targets") are checked, then select Alfred.framework and click "Add."

![](http://alfred.daniel.sh/framework/setup-1.png)

Now select the main project item from the pane to the left, then choose the target "MyAlfredWorkflow." Under "Build Phases," click the disclosure triangle next to "Link binary with libraries" and make sure it includes Alfred.framework. If not, click the plus sign, then "Add Other...," then navigate to the file on your hard drive and add it manually.

Now, in your main source file `main.m`, add a line lines below `#import <Foundation/Foundation.h>`:

```````````objectivec
//
//  main.m
//  MyAlfredWorkflow
//
//  Created by Daniel Shannon on 5/25/13.
//  Copyright (c) 2013 Daniel Shannon. All rights reserved.
//

#import <Foundation/Foundation.h>
#import <Alfred/Alfred.h>

int main(int argc, const char * argv[])
{
```````````````````````````````````````````````````````````````````````````````````````````````

If you've done everything correctly so far, XCode should try to autocomplete `<Alfred/Alfred.h>` as you type, and your screen should look something like this:

![](http://alfred.daniel.sh/framework/setup-2.png)

Note that the organization of the files in the left pane doesn't make much of a difference, so long as you don't delete the framework.

Now, in order to use Alfred.framework, you simply must ensure that the framework bundle is copied to the same directory as your executable. Then import `<Alfred/Alfred.h>` and you're ready to go!


## Usage
Currently, Alfred.framework provides the following core features:

* Painless generation of feedback XML.
* Fuzzy searching, modeled on [alp][].
* Methods for accessing cache folders, storage folders, and the local folder.
* An argument parser.
* Silent error logging.

Each one is accessible through `<Alfred/Alfred.h>`. The two main classes currently in use are `AWWorkflow` and `AWFeedbackItem`. `AWWorkflow` is an interface to most of the methods above, whereas `AWFeedbackItem` is pretty much just what it says on the can.

### Feedback XML
To generate feedback XML in Alfred.framework, you must first create and configure one or more `AWFeedbackItem`s. There are a number of ways to do this. The first and most cumbersome involves using getter and setter methods to set up feedback items. For example, this would be perfectly valid:

```````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWFeedbackItem *i = [[AWFeedbackItem alloc] init];
i.title = @"Information";
i.subtitle = @"S'more information.";
i.valid = YES;
i.arg = @"get info";
```````````````````````````````````````````````````````````````````````````````````````````````

...and so on. The following properties are presently used to pass data back to Alfred:

```````objectivec
@property NSString      *title;
@property NSString      *subtitle;
@property NSString      *uid;
@property NSNumber      *valid;
@property NSString      *autocomplete;
@property NSString      *icon;
@property NSNumber      *fileicon;
@property NSNumber      *filetype;
@property NSString      *arg;
@property NSString      *type;
```````````````````````````````````````````````````````````````````````````````````````````````

However, because setting each one would be tedious, `AWFeedbackItem` provides a class method, `+ itemWithObjectsAndKeys:(id)...`, and an instance method, `- initWithObjects:(NSArray *) forKeys:(NSArray *)`, to make it simpler. As their first arguments, both take a `BOOL` that determines whether the XML item is considered actionable by Alfred. The class method then allows you to specify a `nil`-terminated list of alternative objects and keys (property names) to set up the item. With the exception of the three `NSNumber` objects, which should be `@YES` or `@NO`, all keys and values _must_ be strings. For example:

````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWFeedbackItem *i = [AWFeedbackItem itemWithObjectsAndKeys:@"Entitlement", @"title", @"Subversion", @"subtitle", @"iconography.png", @"icon", @"argumentation", @"arg", @YES, @"valid", nil];
NSLog(@"xml=%@", [i xml]);
```````````````````````````````````````````````````````````````````````````````````````````````

...would log the following to the console:

`````````xml
AlfredWorkflowTest[31201:303] xml=<item valid="yes" arg="argumentation"><title>Entitlement</title><subtitle>Subversion</subtitle><icon>iconography.png</icon></item>
```````````````````````````````````````````````````````````````````````````````````````````````

You could do something similar with the customized constructor method. This method, rather than taking a list of `NSString` objects, takes two `NSArray` objects---one of keys, one of values---which must contain `NSString`s. Here's an example:

````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWFeedbackItem *j = [[AWFeedbackItem alloc] initWithObjects:@[@"Titillation", @"Submission & Subdual", @"automation", @NO] forKeys:@[@"title", @"subtitle", @"autocomplete", @"valid"];
NSLog(@"xml=%@", [j xml]);
```````````````````````````````````````````````````````````````````````````````````````````````

``````````````xml
AlfredWorkflowTest[31201:303] xml=<item valid="no" autocomplete="automation"><title>Titillation</title><subtitle>Submission &amp; Subdual</subtitle><icon>icon.png</icon></item>
```````````````````````````````````````````````````````````````````````````````````````````````

Alfred.framework automatically escapes XML strings passed to `AWFeedbackItem`. Note that the feedback item's `- xml` method does not generate the complete XML string that Alfred needs to provide feedback. That functionality is provided through a method of `AWWorkflow`, and `- xml` is only used here for the purposes of demonstration.

To feed data back to Alfred, you must call `AWWorkflow`'s instance method `- flush:(BOOL) feedbackItems:(AWFeedbackItem *)...`. Like the feedback item's class method, this too takes a `nil`-terminated list of objects; in this case, however, each one should be an `AWFeedbackItem` instance. The first argument is a `BOOL`; if set to `YES`, it will flush the standard output buffer to Alfred and terminate your program. Otherwise, it will only spool the XML into the standard output. Call it like this:

```````````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWWorkflow *wf = [[AWWorkflow alloc] init];

AWFeedbackItem *i = [AWFeedbackItem validItem:YES withObjectsAndKeys:@"Entitlement", @"title", @"Subversion", @"subtitle", @"iconography.png", @"icon", @"argumentation", @"arg", nil];
AWFeedbackItem *j = [[AWFeedbackItem alloc] initAsValid:NO withObjects:@[@"Titillation", @"Submission & Subdual", @"automation"] forKeys:@[@"title", @"subtitle", @"autocomplete"];

[wf flush:YES feedbackItems:i, j, nil];
```````````````````````````````````````````````````````````````````````````````````````````````

This ends the program immediately, printing the following XML to the standard output:

````````````xml
<?xml version="1.0"?><items><item valid="yes" arg="argumentation"><title>Entitlement</title><subtitle>Subversion</subtitle><icon>iconography.png</icon></item><item valid="no" autocomplete="automation"><title>Titillation</title><subtitle>Submission &amp; Subdual</subtitle><icon>icon.png</icon></item></items>
```````````````````````````````````````````````````````````````````````````````````````````````

If you're generating feedback items on-the-fly, of course, you'll want to be able to send them all at once. Rather than passing them one by one to `- flush:feedbackItems:` and only flushing at the last object, you can also call `- flush:(BOOL) feedbackArray:(NSArray *)` with an `NSArary` containing `AWFeedbackItem`s. For example, you might want to rewrite the sample above with a condition:

```````````````objectivec
#import <Alfred/Alfred.h>

// [...]

AWWorkflow *wf = [[AWWorkflow alloc] init];
NSMutableArray *fbi = [[NSMutableArray alloc] initWithCapacity:0];

if (myCondition == YES) {
    AWFeedbackItem *i = [AWFeedbackItem validItem:YES withObjectsAndKeys:@"Entitlement", @"title", @"Subversion", @"subtitle", @"iconography.png", @"icon", @"argumentation", @"arg", nil];
    [fbi addObject:i];
}
AWFeedbackItem *j = [[AWFeedbackItem alloc] initAsValid:NO withObjects:@[@"Titillation", @"Submission & Subdual", @"automation"] forKeys:@[@"title", @"subtitle", @"autocomplete"];
[fbi addObject:j];

[wf flush:YES feedbackArray:fbi];
```````````````````````````````````````````````````````````````````````````````````````````````



### Fuzzy Searching
Alfred.framework includes a port of [alp][]'s fuzzy searching feature, which is considerably sped up in compiled code without losing any of its power. To use it, simply fill an `NSArray` with a number of objects. These objects can be of any type, so long as an `NSString` to be matched against can be extracted from them. The framework will return another `NSArray` with any matching elements, sorted by the quality of the match.

The method that handles this is also declared in `AWWorkflow`, as `- fuzzySearchFor:(NSString *) in:(NSArray *) withKeyBlock:(NSString *(^)(id))`. It takes a string with the search query, an array of objects, and a block function that will be applied to each element of the array to get a search string. The block should take a single object, though that object can contain many other objects, and return a string to be searched.

Let's take a look at some sample code, using data drawn from [alp][]'s sample case:

```````{.objectivec}
#import <Alfred/Alfred.h>

// [...]

AWWorkflow *wf = [[AWWorkflow alloc] init];

NSArray *k = @[@"key", @"author", @"title"];
NSArray *v0 = @[@"ZB7K535R", @"Reskin 2003", @"Including Mechanisms in Our Models of Ascriptive Inequality: 2002 Presidential Address"];
NSArray *v1 = @[@"DBTD3HQS", @"Igor & Ronald 2008", @"Die Zunahme der Lohnungleichheit in der Bundesrepublik. Aktuelle Befunde für den Zeitraum von 1998 bis 2005"];
NSArray *v2 = @[@"MQ3BHTBJ", @"Marx 1978", @"Alienation and Social Class"];
NSArray *v3 = @[@"7G4BRU45", @"Marx 1978", @"The German Ideology"];
NSArray *v4 = @[@"9ANAZXQB", @"Llorente 2006", @"Analytical Marxism and the Division of Labor"];
NSArray *ofDicts = @[[NSDictionary dictionaryWithObjects:v0 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v1 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v2 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v3 forKeys:k],
                     [NSDictionary dictionaryWithObjects:v4 forKeys:k]];

NSArray *res = [wf fuzzySearchFor:@"marx" in:ofDicts withKeyBlock: ^(id obj) {
    NSDictionary *d = (NSDictionary *)obj;
    NSString *s = [NSString stringWithFormat:@"%@ - %@",
                    [d objectForKey:@"author"],
                    [d objectForKey:@"title"]];
    return s;
}];
NSLog(@"res=%@", res);
```````````````````````````````````````````````````````````````````````````````````````````````

As you can see, it's okay that the strings we need to search are buried deep in the actual object so long as we know how to return a string from our key block; otherwise, the search function won't know what it should be applying its filters to. What's actually being searched in each case is the string `"{author} - {title}"`; what's returned, on the other hand, is the complete object that yielded each match:

    AlfredWorkflowTest[32039:303] res=(
        {
            author = "Marx 1978";
            key = MQ3BHTBJ;
            title = "Alienation and Social Class";
        },
        {
            author = "Marx 1978";
            key = 7G4BRU45;
            title = "The German Ideology";
        },
        {
            author = "Llorente 2006";
            key = 9ANAZXQB;
            title = "Analytical Marxism and the Division of Labor";
        }
    )

It should be considered purely coincidental that the order of the objects returned is identical to the order in which they were presented. The algorithm calculates quality of match based on the number of characters in sequence ("marx" is preferred to "moarx"---unbroken sequences are better) and the position of the sequence in the search string ("marx" is preferred to "smarx"---earlier is better).



### Argument Parsing
The `AWWorkflow` object provides a method for converting arguments to the workflow in the form of `--key=value` into an `NSDictionary` with usable objects. To invoke it, you must first create an array of dictionaries that define the expected arguments. Each dictionary requires three key--value pairs---`@"name"`, a string with the long name of the argument key, `@"flag"`, a single-letter string with the short name of the argument key, and `@"has_arg"`, an `NSNumber` that determines whether the argument key is an on/off flag (set to `@NO`), requires a value (set to `@YES`), or takes an optional value (set to anything else). Once you've determined your expected arguments, you can invoke `AWWorkflow`'s `- parseArguments:(const char **) withKeys:(NSArray *) count:(int)` method. This returns a dictionary object whose keys are the arguments' names and whose values were passed in to the program.

``````objectivec
#import <Foundation/Foundation.h>
#import <Alfred/Alfred.h>

int main(int argc, const char *argv[])
{
    @autoreleasepool {
        AWWorkflow *wf = [[AWWorkflow alloc] init];
        NSArray *k = @[@{@"name": @"qux", @"has_arg": @YES, @"flag": @"q"},
                       @{@"name": @"baz", @"has_arg": @NO,  @"flag": @"b"},
                       @{@"name": @"cog", @"has_arg": @2,   @"flag": @"c"}];
        NSDictionary *args = [wf parseArguments:argv withKeys:k count:argc];
        NSLog(@"qux=%@, baz=%@, cog=%@", [args valueForKey:@"qux"], [args valueForKey:@"baz"], [args valueForKey:@"cog"]);
        // NSLog(@"query=%@", [args valueForKey:@"{query}"]);
    }
    return 0;
}
````````````````````````````````````````````````````````````````````````````````````````````````

You can compile this program, drop the framework into its folder (remember, it must be in the same directory as your executable), and run it from a Terminal window to check that it works:

````````bash
auntieclimactic:Debug danielsh$ ./ArgumentativeWorkflow --qux=foo --baz --cog
2013-05-26 08:20:22.847 DTWorkflow[48183:707] qux=foo, baz=1, cog=1
auntieclimactic:Debug danielsh$ ./ArgumentativeWorkflow --qux=foo --baz --cog=bar
2013-05-26 08:25:57.439 DTWorkflow[51394:707] qux=foo, baz=1, cog=bar
auntieclimactic:Debug danielsh$ ./DTWorkflow --qux=foo --cog=bar
2013-05-26 08:27:02.340 DTWorkflow[51421:707] qux=foo, baz=(null), cog=bar
````````````````````````````````````````````````````````````````````````````````````````````````

When implementing this in your workflow, remember that _arguments to long-style command parameters require an equals sign between the key and the value_.

What's more, anything that follows the arguments list will be recognized as potentially constituting an Alfred query, and placed in the returned dictionary under the reserved key `@"{query}"`. Remove the comment from the second `NSLog()` statement above, recompile, and try this:

```````bash
auntieclimactic:Debug danielsh$ ./ArgumentativeWorkflow --qux=fool --baz --cog=me once shame on you
2013-05-26 08:51:04.838 DTWorkflow[51785:707] qux=fool, baz=1, cog=me
2013-05-26 08:51:04.839 DTWorkflow[51785:707] query=once shame on you
````````````````````````````````````````````````````````````````````````````````````````````````





### Bundle Basics
Currently, only two methods are defined to interact with the Alfred bundle, both in `AWWorkflow`. The first of these is `- log:(NSString *)...`, which accepts a format string followed by a variable number of format arguments---just like `NSLog()` or `[NSString stringWithFormat:]`. However, rather than writing to the console, `- log:` saves text to a file called `framework.log` in the workflow's local folder. `- bundleID`, meanwhile, returns a string with your bundle ID, as extracted from the workflow's `info.plist` file.




### Filesystem Interaction
The framework also defines a number of methods for quickly accessing files in the local folder, the canonical cache folder, and the canonical storage folder. These, too, are provided through the workhorse `AWWorkflow` class:

* `- local`  
    Without an argument, `[wf local]` returns the path to the folder containing your executable.
* `- local:(NSString *)`  
    With an optional `NSString` argument, `[wf local:@"baz.png"]` returns the argument appended as a path component to the folder containing your executable.
* `- cache` and `- cache:(NSString *)`  
    Returns the path to your workflow's cache folder, optionally with an additional path component appended. If the cache folder does not already exist, the framework will create it; however, the file or folder referenced by `- cache:` _will not_ be created automatically.
* `- storage` and `- storage:(NSString *)`  
    Returns the path to your workflow's storage folder, optionally with an additional path component appended. If the storage folder does not already exist, the framework will create it; however, the file or folder referenced by `- storage:` _will not_ be created.




## Roadmap
In the not-too-distant future, more features from [alp][]---including settings, notifications, and Keychain access---will be ported to Alfred.framework. However, I'm always open to hearing interesting feature requests. Objective-C and Cocoa provide almost limitless possibilities for what can be done with this sort of thing, and I suspect that I'm not imaginative enough to see them all. Please don't hesitate to get in touch via [the Alfred forums](http://www.alfredforum.com/user/29-phyllisstein/), [Twitter](http://twitter.com/phyllisstein), or [e-mail](d@daniel.sh).



## License
Alfred.framework is licensed under a [Creative Commons Attribution-NonCommercial-ShareAlike 3.0](http://creativecommons.org/licenses/by-nc-sa/3.0/) license. This means that you may share and redistribute the package, but only for non-commercial purposes, only so long as you credit the original author---_moi_---and only if your derivative work is similarly licensed.

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>.




## [Download][latest]




[alfred]: http://alfredapp.com
[alp]: https://github.com/phyllisstein/alp
[latest]: http://alfred.daniel.sh/framework/Alfred-latest.zip
[cl]: http://alfred.daniel.sh/framework/changelog.html

# DEVONthink Note Workflow for Alfred v2
This workflow, which makes use of the [Alfred.framework][framework] project, adds a quick note to DEVONthink Pro. Enter `dtn` to dispaly a list of databases. Select one, then begin entering a query. While the query fuzzily matches any of your database's top-level groups, they'll be displayed and you can select one; once there are no more matches, the workflow kicks into note mode for the current database or group. Enter a note, either using a colon to separate the title and subtitle or letting the workflow choose a title and date stamp for you, then press `Return` to create it.

## Source Documentation
DEVONthink Note ably demonstrates several of the features of [Alfred.framework][framework]. In particular, it makes extensive use of the feedback and fuzzy-searching systems. Both use cases demonstrate how powerful these features can be without significantly adding to complexity. For example, coming up with a key block for a fuzzy search is a breeze, despite the size and complexity of our data set (the array containing a group's or database's children). Since we're just trying to get a searchable string, we can do this:

``````objectivec
AWWorkflow *aw = [[AWWorkflow alloc] init];
NSArray *res = [aw fuzzySearchFor:self.query in:children withKeyBlock:^NSString *(id o) {
    DEVONthinkRecord *obj = (DEVONthinkRecord *)o;
    return [obj name];
}];
return res;
```````````````````````````````````````````````````````````````````````````````````````````````

The returned results array will contain every child record that provided a matching response to `- name`.

The feedback behavior is probably even more transparent. We create a mutable array called `outObjects` early in the program (so it doesn't get stuck in a local namespace), then add an `AWFeedbackItem` to it whenever we need to. Then, just when we're ready to terminate the program, we call `AWWorkflow`'s `-flush:(BOOL) feedbackArray:(NSArray *)` with it.

```````objectivec
#import <Foundation/Foundation.h>
#import <Alfred/Alfred.h>
// [...]

int main(int argc, const char *argv[])
{
    NSMutableArray *outObjects = [NSMutableArray new];      // We declare it in our outermost level of nesting...
    // [...]
    
    if (argc == 1 || [argv1 isEqualToString:@"")
    {
        for(NSString *n in dbNames)
        {
            NSString *acp = [NSString stringWithFormat:@"%@→", n];
            NSString *st = [NSString stringWithFormat:@"Select a group in \"%@\"", n];
            AWFeedbackItem *i = [AWFeedbackItem itemWithObjectsAndKeys:@NO, @"valid", acp, @"autocomplete", n, @"title", st, @"subtitle", dbIcon, @"icon", nil];
            // ...so that this works, even from deep down here.

            [outObjects addObject:i];
        }
    }
````````````````````````````````````````````````````````````````````````````````````````````````

## License
Framework code by Daniel Shannon ([d@daniel.sh](d@daniel.sh)), 2013. This license may not be removed or altered. Alfred.framework is licensed under a [Creative Commons Attribution-NonCommercial-ShareAlike 3.0](http://creativecommons.org/licenses/by-nc-sa/3.0/) license. This means that you may share and redistribute the package, but only for non-commercial purposes, only so long as you credit the original author---_moi_---and only if your derivative work is similarly licensed.

To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ or send a letter to Creative Commons, 444 Castro Street, Suite 900, Mountain View, California, 94041, USA.

[framework]: https://github.com/phyllisstein/Alfred.framework "Github: Alfred.framework"

# Alfred Workflows
These workflows and workflow utilities are no longer maintained or updated. Under each folder, you'll find the source code for the workflow, without the icon or `Info.plist` files, and a zipped `.alfredworkflow` file that can be imported into Alfred.

Note that if you wish to import these workflows, it is recommended that you remove any lingering `update.json` files in the workflow's folder, as the server that they instruct Alleyoop to query is no longer active.


## Contributors

* Many thanks to [Alexander](https://github.com/alexex) for serious repairs to the "Open in Sublime" workflow.

