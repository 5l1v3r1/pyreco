__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# kaleo documentation build configuration file, created by
# sphinx-quickstart on Sat Aug 27 13:25:18 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = []

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-waitinglist'
copyright = u'2012, James Tauber and contributors'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0b1'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-waitinglistdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
    ('index', 'django-waitinglist.tex', u'django-waitinglist Documentation',
     u'Pinax', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-waitinglist', u'django-waitinglist Documentation',
     [u'Pinax'], 1)
]

########NEW FILE########
__FILENAME__ = runtests
import sys

from django.conf import settings

settings.configure(
    DEBUG=True,
    USE_TZ=True,
    DATABASES={
        "default": {
            "ENGINE": "django.db.backends.sqlite3",
        }
    },
    ROOT_URLCONF="waitinglist.urls",
    INSTALLED_APPS=[
        "django.contrib.auth",
        "django.contrib.contenttypes",
        "django.contrib.sites",
        "account",
        "waitinglist",
    ],
    SITE_ID=1
)

from django_nose import NoseTestSuiteRunner

test_runner = NoseTestSuiteRunner(verbosity=1)
failures = test_runner.run_tests(["waitinglist"])

if failures:
    sys.exit(failures)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from .models import (
    Cohort,
    SignupCodeCohort,
    Survey,
    SurveyAnswer,
    SurveyInstance,
    SurveyQuestion,
    SurveyQuestionChoice,
    UserCohort,
    WaitingListEntry
)


class WaitingListEntryAdmin(admin.ModelAdmin):

    list_display = ["email", "created"]
    search_fields = ["email"]


class SignupCodeCohortInline(admin.TabularInline):

    model = SignupCodeCohort


class UserCohortInline(admin.TabularInline):

    model = UserCohort


class SurveyInstanceAdmin(admin.ModelAdmin):

    model = SurveyInstance
    list_display = ["survey", "email", "created"]

    def survey(self, obj):
        return obj.survey.label

    def email(self, obj):
        return obj.entry.email

    def created(self, obj):
        return obj.entry.created


class SurveyAnswerAdmin(admin.ModelAdmin):

    model = SurveyAnswer
    list_display = ["survey", "email", "question_label", "value", "value_boolean", "created"]

    def survey(self, obj):
        return obj.instance.survey.label

    def email(self, obj):
        return obj.instance.entry.email

    def question_label(self, obj):
        return obj.question.question


class SurveyQuestionChoiceInline(admin.TabularInline):

    model = SurveyQuestionChoice


class SurveyQuestionAdmin(admin.ModelAdmin):

    model = SurveyQuestion
    list_display = ["survey", "question", "kind", "required"]
    inlines = [SurveyQuestionChoiceInline]

    def survey(self, obj):
        return obj.survey.label


admin.site.register(WaitingListEntry, WaitingListEntryAdmin)
admin.site.register(
    Cohort,
    inlines=[
        SignupCodeCohortInline,
        UserCohortInline,
    ]
)

admin.site.register(
    Survey,
    list_display=["label", "active"]
)
admin.site.register(SurveyAnswer, SurveyAnswerAdmin)
admin.site.register(SurveyInstance, SurveyInstanceAdmin)
admin.site.register(SurveyQuestion, SurveyQuestionAdmin)

########NEW FILE########
__FILENAME__ = forms
from django import forms

from .models import Cohort, SurveyAnswer, SurveyQuestion, WaitingListEntry
from .signals import answered_survey


class WaitingListEntryForm(forms.ModelForm):

    class Meta:
        model = WaitingListEntry

    def clean_email(self):
        value = self.cleaned_data["email"]
        try:
            entry = WaitingListEntry.objects.get(email=value)
        except WaitingListEntry.DoesNotExist:
            return value
        else:
            raise forms.ValidationError(
                "The email address %(email)s already registered on %(date)s." % {
                    "email": value,
                    "date": entry.created.strftime("%m/%d/%y"),
                }
            )

    def __init__(self, *args, **kwargs):
        super(WaitingListEntryForm, self).__init__(*args, **kwargs)
        self.fields["email"].widget.attrs["placeholder"] = "your@email.com"
        self.fields["email"].label = ""


class CohortCreate(forms.ModelForm):

    class Meta:
        model = Cohort
        exclude = ["created"]


class SurveyForm(forms.Form):

    def __init__(self, *args, **kwargs):
        self.survey = kwargs.pop("survey")
        super(SurveyForm, self).__init__(*args, **kwargs)
        for question in self.survey.questions.all():
            self.fields[question.name] = question.form_field()

    def save(self, instance):
        for question in self.survey.questions.all():
            answer = SurveyAnswer.objects.create(instance=instance, question=question)
            value = self.cleaned_data[question.name]
            if question.kind == SurveyQuestion.RADIO_CHOICES:
                answer.value = value.label
            elif question.kind == SurveyQuestion.CHECKBOX_FIELD:
                answer.value = ", ".join([x.label for x in value])
            elif question.kind == SurveyQuestion.BOOLEAN_FIELD:
                answer.value_boolean = value
            else:
                answer.value = value
            answer.save()
        answered_survey.send(sender=self, instance=instance)
        instance.entry.reset_trello_link()

########NEW FILE########
__FILENAME__ = export_to_trello
from django.conf import settings
from django.core.urlresolvers import reverse
from django.core.management.base import BaseCommand

from django.contrib.sites.models import Site

from ...models import WaitingListEntry, SurveyQuestion, SurveyAnswer

from ... import trello


class Command(BaseCommand):

    help = "Export waiting list entries to Trello for use as a simple CRM"

    def export_contacts(self):
        entries = WaitingListEntry.objects.filter(trello_card_id="")
        for entry in entries:
            # 0. Title of card is email address
            title = entry.email.encode("utf-8")
            answers = []
            try:
                qs = entry.surveyinstance.answers.all().order_by("question__pk")
                for answer in qs:
                    if answer.question.kind == SurveyQuestion.BOOLEAN_FIELD or len(answer.value) > 0:
                        answers.append(answer)
            except:
                answers = []

            description = ""
            if len(answers) > 0:
                list_id = self.api.answered_surveys_list_id
                # 1. Create Markdown for Description
                for answer in answers:
                    description += "#### {0}:\n".format(answer.question.question.encode("utf-8"))
                    if answer.question.kind == SurveyQuestion.BOOLEAN_FIELD:
                        description += "> {0}\n\n".format(answer.value_boolean)
                    else:
                        description += "> {0}\n\n".format(answer.value.encode("utf-8"))
            else:
                list_id = self.api.imported_contacts_list_id
            description += "\n\n-----\n\nID: {0}\n".format(str(entry.pk))
            description += "Admin Link: {0}://{1}{2}\n".format(self.protocol, self.site.domain, reverse("admin:waitinglist_waitinglistentry_change", args=[entry.pk]))
            description += "Created At: {0}\n".format(str(entry.created))

            # 2. Create the card
            card = self.api.create_card(title, description, list_id)
            # 3. Store the id
            entry.trello_card_id = card["id"]
            entry.save()
            print "Exported {0} onto Card {1}".format(entry.email.encode("utf-8"), entry.trello_card_id)

    def export_answers(self):
        questions = SurveyQuestion.objects.filter(trello_list_id="")
        for question in questions:
            question.trello_list_id = self.api.setup_board(question.question)
            question.save()
        answers = SurveyAnswer.objects.filter(trello_card_id="")
        for answer in answers:
            description = "Entry: {0}\n".format(self.api.card_short_url(answer.instance.entry.trello_card_id))
            if answer.question.kind == SurveyQuestion.BOOLEAN_FIELD:
                title = str(answer.value_boolean)
            else:
                title = answer.value.encode("utf-8")
            if title.strip() != "":
                card = self.api.create_card(title, description, answer.question.trello_list_id)
                answer.trello_card_id = card["id"]
                answer.save()
                print "Exported Answer {0} on Card {1}".format(answer.pk, answer.trello_card_id)

    def handle(self, *args, **options):
        self.site = Site.objects.get_current()
        self.protocol = getattr(settings, "DEFAULT_HTTP_PROTOCOL", "http")
        self.api = trello.Api()
        self.export_contacts()
        self.export_answers()

########NEW FILE########
__FILENAME__ = mail_out_survey_links
from django.conf import settings
from django.core.mail import EmailMessage
from django.core.management.base import BaseCommand
from django.template.loader import render_to_string

from django.contrib.sites.models import Site

from ...models import WaitingListEntry, Survey


class Command(BaseCommand):

    help = "Email links to survey instances for those that never saw a survey"

    def handle(self, *args, **options):
        survey = Survey.objects.get(active=True)
        entries = WaitingListEntry.objects.filter(surveyinstance__isnull=True)

        for entry in entries:
            instance = survey.instances.create(entry=entry)
            site = Site.objects.get_current()
            protocol = getattr(settings, "DEFAULT_HTTP_PROTOCOL", "http")
            ctx = {
                "instance": instance,
                "site": site,
                "protocol": protocol,
            }
            subject = render_to_string("waitinglist/survey_invite_subject.txt", ctx)
            subject = subject.strip()
            message = render_to_string("waitinglist/survey_invite_body.txt", ctx)
            EmailMessage(
                subject,
                message,
                to=[entry.email],
                from_email=settings.WAITINGLIST_SURVEY_INVITE_FROM_EMAIL
            ).send()

########NEW FILE########
__FILENAME__ = make_contact
from django.conf import settings
from django.core.mail import send_mail
from django.core.management.base import BaseCommand
from django.template.loader import render_to_string

from django.contrib.sites.models import Site

from ...models import WaitingListEntry

from ... import trello


class Command(BaseCommand):

    help = "Contact users in 'To Contact' list on Trello"

    def make_contact(self):
        cards = self.api.cards(self.api.to_contact_list_id)
        for card in cards:
            try:
                entry = WaitingListEntry.objects.filter(initial_contact_sent=False).get(trello_card_id=card["id"])
                subject = render_to_string("waitinglist/email/initial_contact_subject.txt", {"entry": entry})
                message = render_to_string("waitinglist/email/initial_contact.txt", {"entry": entry})
                send_mail(subject, message, settings.DEFAULT_FROM_EMAIL, [entry.email])
                self.api.move_card(card["id"], self.api.contacted_list_id)
                entry.initial_contact_sent = True
                entry.save()
                print "Sent to {0} ({1}) [Card #{2}]".format(card["name"], card["shortUrl"], card["idShort"])
            except WaitingListEntry.DoesNotExist:
                print "{0} ({1}) has already been sent [Card #{2}]".format(card["name"], card["shortUrl"], card["idShort"])

    def handle(self, *args, **options):
        self.site = Site.objects.get_current()
        self.protocol = getattr(settings, "DEFAULT_HTTP_PROTOCOL", "http")
        self.api = trello.Api()
        self.make_contact()

########NEW FILE########
__FILENAME__ = models
import collections
import hashlib

from django import forms
from django.conf import settings
from django.db import models
from django.db.models import Max
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.template.defaultfilters import slugify
from django.utils import timezone
from django.utils.translation import ugettext_lazy as _

from django.contrib.auth.models import User

from account.models import SignupCode, SignupCodeResult
from account.signals import user_signed_up

from . import trello


SURVEY_SECRET = getattr(settings, "WAITINGLIST_SURVEY_SECRET", settings.SECRET_KEY)


class WaitingListEntry(models.Model):

    email = models.EmailField(_("email address"), unique=True)
    created = models.DateTimeField(_("created"), default=timezone.now, editable=False)
    trello_card_id = models.CharField(max_length=100, blank=True)
    initial_contact_sent = models.BooleanField(default=False)

    def reset_trello_link(self):
        if self.trello_card_id:
            api = trello.Api()
            api.delete_card(self.trello_card_id)
            self.trello_card_id = ""
            self.save()

    class Meta:
        verbose_name = _("waiting list entry")
        verbose_name_plural = _("waiting list entries")

    def __unicode__(self):
        return self.email


@receiver(post_save, sender=WaitingListEntry)
def handle_waitinglistentry_save(sender, **kwargs):
    if kwargs.get("created"):
        try:
            survey = Survey.objects.get(active=True)
            SurveyInstance.objects.create(
                survey=survey,
                entry=kwargs.get("instance")
            )
        except Survey.DoesNotExist:
            pass


class Survey(models.Model):

    label = models.CharField(max_length=100, unique=True)
    active = models.BooleanField(default=True)

    def __unicode__(self):
        return self.label

    def save(self, *args, **kwargs):
        if self.active:
            Survey.objects.filter(active=True).update(active=False)
        return super(Survey, self).save(*args, **kwargs)


class SurveyInstance(models.Model):

    survey = models.ForeignKey(Survey, related_name="instances")
    entry = models.OneToOneField(WaitingListEntry)
    code = models.CharField(max_length=200, unique=True)

    def generate_hash(self):
        return hashlib.md5(self.entry.email + SURVEY_SECRET).hexdigest()

    def save(self, *args, **kwargs):
        self.code = self.generate_hash()
        return super(SurveyInstance, self).save(*args, **kwargs)


class SurveyQuestion(models.Model):

    TEXT_FIELD = 0
    TEXT_AREA = 1
    RADIO_CHOICES = 2
    CHECKBOX_FIELD = 3
    BOOLEAN_FIELD = 4

    FIELD_TYPE_CHOICES = [
        (TEXT_FIELD, "text field"),
        (TEXT_AREA, "textarea"),
        (RADIO_CHOICES, "radio choices"),
        (CHECKBOX_FIELD, "checkbox field (can select multiple answers"),
        (BOOLEAN_FIELD, "boolean field")
    ]

    survey = models.ForeignKey(Survey, related_name="questions")
    question = models.TextField()
    kind = models.IntegerField(choices=FIELD_TYPE_CHOICES)
    help_text = models.TextField(blank=True)
    ordinal = models.IntegerField(blank=True)
    required = models.BooleanField()
    trello_list_id = models.CharField(max_length=100, blank=True)

    class Meta:
        unique_together = [
            ("survey", "question")
        ]
        ordering = ["ordinal"]

    @property
    def name(self):
        return slugify(self.question)

    def form_field(self):
        kwargs = dict(
            label=self.question,
            help_text=self.help_text,
            required=self.required
        )
        field_class = forms.CharField

        if self.kind == SurveyQuestion.TEXT_AREA:
            kwargs.update({"widget": forms.Textarea()})
        elif self.kind == SurveyQuestion.RADIO_CHOICES:
            field_class = forms.ModelChoiceField
            kwargs.update({"widget": forms.RadioSelect(), "queryset": self.choices.all()})
        elif self.kind == SurveyQuestion.CHECKBOX_FIELD:
            field_class = forms.ModelMultipleChoiceField
            kwargs.update({"widget": forms.CheckboxSelectMultiple(), "queryset": self.choices.all()})
        elif self.kind == SurveyQuestion.BOOLEAN_FIELD:
            field_class = forms.BooleanField

        return field_class(**kwargs)

    def save(self, *args, **kwargs):
        if not self.pk:
            max_ordinal = self.survey.questions.aggregate(
                Max("ordinal")
            )["ordinal__max"] or 0
            self.ordinal = max_ordinal + 1
        return super(SurveyQuestion, self).save(*args, **kwargs)


class SurveyQuestionChoice(models.Model):
    question = models.ForeignKey(SurveyQuestion, related_name="choices")
    label = models.CharField(max_length=100)

    def __unicode__(self):
        return self.label


class SurveyAnswer(models.Model):

    instance = models.ForeignKey(SurveyInstance, related_name="answers")
    question = models.ForeignKey(SurveyQuestion, related_name="answers")
    value = models.TextField(blank=True)
    value_boolean = models.NullBooleanField(blank=True)
    created = models.DateTimeField(_("created"), default=timezone.now, editable=False)
    trello_card_id = models.CharField(max_length=100, blank=True)


Member = collections.namedtuple("Member", ["email", "signup_code", "user", "invited"])


class Cohort(models.Model):

    name = models.CharField(_("name"), max_length=35)
    created = models.DateTimeField(_("created"), default=timezone.now, editable=False)

    class Meta:
        permissions = (
            ("manage_cohorts", "Can manage cohorts"),
        )

    def members(self):
        members = []
        for scc in self.signupcodecohort_set.select_related():
            try:
                scr = SignupCodeResult.objects.get(signup_code=scc.signup_code_id)
            except SignupCodeResult.DoesNotExist:
                user = None
            else:
                user = scr.user
            members.append(
                Member(
                    scc.signup_code.email,
                    scc.signup_code,
                    user,
                    bool(scc.signup_code.sent)
                )
            )
        return members

    def member_counts(self):
        members = self.members()
        return {
            "total": len(members),
            "users": len([m for m in members if m.user is not None]),
            "pending": len([m.signup_code for m in members if not m.invited]),
        }

    def send_invitations(self):
        for sc in [m.signup_code for m in self.members() if not m.invited]:
            sc.send()

    def __unicode__(self):
        return self.name


class SignupCodeCohort(models.Model):
    """
    fetch cohort of a given signup code
        SignupCodeCohort.objects.select_related("cohort").get(signup_code__code="abc").cohort

    list of people waiting NOT on the site already or invited
        WaitingListEntry.objects.exclude(email__in=SignupCode.objects.values("email")).exclude(email__in=User.objects.values("email"))
    """
    signup_code = models.OneToOneField(SignupCode)
    cohort = models.ForeignKey(Cohort)


class UserCohort(models.Model):
    """
    Upon signup we create an instance of this model associating the new user and their cohort
    """
    user = models.OneToOneField(User)
    cohort = models.ForeignKey(Cohort)


@receiver(user_signed_up)
def handle_user_signup(sender, **kwargs):
    signup_code = kwargs["form"].cleaned_data["code"]
    # fetch the cohort for the signup code
    qs = SignupCodeCohort.objects.select_related("cohort")
    try:
        cohort = qs.get(signup_code__code=signup_code).cohort
        # create a UserCohort for user association to a cohort
        UserCohort.objects.create(user=kwargs["user"], cohort=cohort)
    except SignupCodeCohort.DoesNotExist:
        pass

########NEW FILE########
__FILENAME__ = signals
from django.dispatch import Signal


signed_up = Signal(providing_args=["entry"])
answered_survey = Signal(providing_args=["instance"])

########NEW FILE########
__FILENAME__ = stats
import datetime

from django.utils import timezone

from django.contrib.auth.models import User

from account.models import SignupCode

from waitinglist.models import WaitingListEntry


def stats():
    return {
        "waiting_list_entries": WaitingListEntry.objects.count(),
        "waitinglist_added_last_seven_days": WaitingListEntry.objects.filter(created__gt=timezone.now() - datetime.timedelta(days=7)).count(),
        "waitinglist_added_last_thirty_days": WaitingListEntry.objects.filter(created__gt=timezone.now() - datetime.timedelta(days=30)).count(),
        "waiting_list_entries_to_invite": WaitingListEntry.objects.exclude(email__in=SignupCode.objects.values("email")).exclude(email__in=User.objects.values("email")).count()
    }

########NEW FILE########
__FILENAME__ = waitinglist_tags
from django import template

from waitinglist.forms import WaitingListEntryForm


register = template.Library()


@register.assignment_tag
def waitinglist_entry_form():
    """
    Get a (new) form object to post a new comment.

    Syntax::

        {% waitinglist_entry_form as [varname] %}

    """
    return WaitingListEntryForm()

########NEW FILE########
__FILENAME__ = tests
from django.test import TestCase

from .forms import SurveyForm
from .models import (
    Survey,
    SurveyQuestion,
    WaitingListEntry
)


class SurveyTests(TestCase):

    def setUp(self):
        self.survey = Survey.objects.create(
            label="My Test Survey"
        )
        self.entry = WaitingListEntry.objects.create(email="pinax@awesome.com")
        self.ice_cream_question = self.survey.questions.create(
            question="What is your favorite ice cream flavor?",
            kind=SurveyQuestion.TEXT_FIELD,
            help_text="(e.g. Vanilla, Strawberry, Chocolate)",
            required=True
        )
        self.summer_question = self.survey.questions.create(
            question="What did you do last summer?",
            kind=SurveyQuestion.TEXT_AREA,
            required=False
        )
        self.season_question = self.survey.questions.create(
            question="What is your favorite season?",
            kind=SurveyQuestion.RADIO_CHOICES,
            required=True
        )
        self.spring = self.season_question.choices.create(
            label="Spring"
        )
        self.summer = self.season_question.choices.create(
            label="Summer"
        )
        self.fall = self.season_question.choices.create(
            label="Fall"
        )
        self.winter = self.season_question.choices.create(
            label="Winter"
        )
        self.city_question = self.survey.questions.create(
            question="Select all the cities you have visited",
            kind=SurveyQuestion.CHECKBOX_FIELD,
            required=True
        )
        self.boston = self.city_question.choices.create(
            label="Boston"
        )
        self.denver = self.city_question.choices.create(
            label="Denver"
        )
        self.nashville = self.city_question.choices.create(
            label="Nashville"
        )
        self.danville = self.city_question.choices.create(
            label="Danville"
        )
        self.golf_question = self.survey.questions.create(
            question="Do you like golf?",
            kind=SurveyQuestion.BOOLEAN_FIELD,
            required=True
        )

    def test_create_second_survey(self):
        Survey.objects.create(label="Another test survey")
        self.assertEquals(Survey.objects.count(), 2)
        self.assertEquals(Survey.objects.filter(active=False).count(), 1)
        self.assertEquals(Survey.objects.filter(active=True).count(), 1)

    def test_survey_form_creation(self):
        form = SurveyForm(survey=self.survey)
        self.assertTrue(len(form.fields), 5)

    def test_survey_form_invalid(self):
        form = SurveyForm(
            data={
                self.ice_cream_question.name: "Strawberry"
            },
            survey=self.survey
        )
        self.assertFalse(form.is_valid())

    def test_survey_form_valid(self):
        form = SurveyForm(
            data={
                self.ice_cream_question.name: "Strawberry",
                self.summer_question.name: "Swam in the lake",
                self.season_question.name: self.summer.pk,
                self.city_question.name: [self.nashville.pk],
                self.golf_question.name: True
            },
            survey=self.survey
        )
        self.assertTrue(form.is_valid())

    def test_survey_form_save(self):
        form = SurveyForm(
            data={
                self.ice_cream_question.name: "Strawberry",
                self.summer_question.name: "Swam in the lake",
                self.season_question.name: self.summer.pk,
                self.city_question.name: [self.nashville.pk, self.boston.pk],
                self.golf_question.name: True
            },
            survey=self.survey
        )
        self.assertTrue(form.is_valid())
        form.save(self.entry.surveyinstance)
        answers = self.entry.surveyinstance.answers.all()
        self.assertEquals(answers.count(), 5)
        self.assertEquals(answers.get(question=self.ice_cream_question).value, "Strawberry")
        self.assertEquals(answers.get(question=self.summer_question).value, "Swam in the lake")
        self.assertEquals(answers.get(question=self.season_question).value, self.summer.label)
        self.assertTrue(
            self.nashville.label in answers.get(question=self.city_question).value
        )
        self.assertTrue(
            self.boston.label in answers.get(question=self.city_question).value
        )
        self.assertTrue(answers.get(question=self.golf_question).value_boolean)

########NEW FILE########
__FILENAME__ = trello
from django.conf import settings

import requests


class Api(object):

    def __init__(self):
        self.base_url = "https://api.trello.com"
        self.token = getattr(settings, "WAITINGLIST_TRELLO_TOKEN", None)
        self.key = getattr(settings, "WAITINGLIST_TRELLO_KEY", None)
        self.org_slug = getattr(settings, "WAITINGLIST_TRELLO_ORG_SLUG", None)
        self.board_short_id = getattr(settings, "WAITINGLIST_TRELLO_BOARD_SHORT_ID", None)
        self.answered_surveys_list_name = getattr(settings, "WAITINGLIST_TRELLO_ANSWERED_SURVEY_LIST_NAME", "Answered Surveys")
        self.imported_contacts_list_name = getattr(settings, "WAITINGLIST_TRELLO_IMPORTED_CONTACTS_LIST_NAME", "Imported Contacts")
        self.imported_answers_list_name = getattr(settings, "WAITINGLIST_TRELLO_IMPORTED_ANSWERS_LIST_NAME", "Imported Answered")
        self.to_contact_list_name = getattr(settings, "WAITINGLIST_TRELLO_TO_CONTACT_LIST_NAME", "To Contact")
        self.contacted_list_name = getattr(settings, "WAITINGLIST_TRELLO_CONTACTED_LIST_NAME", "Contacted")
        self._answered_surveys_list_id = None
        self._imported_contacts_list_id = None
        self._to_contact_list_id = None
        self._contacted_list_id = None
        self._board_id = None
        self._org_id = None

    @property
    def org_id(self):
        if not self._org_id:
            url = "/1/organizations/{0}?token={1}&key={2}".format(self.org_slug, self.token, self.key)
            print url
            r = requests.get("{0}{1}".format(self.base_url, url))
            print r.status_code
            self._org_id = requests.get("{0}{1}".format(self.base_url, url)).json()["id"]
        return self._org_id

    @property
    def board_id(self):
        if not self._board_id:
            url = "/1/organizations/{0}/boards/?token={1}&key={2}".format(self.org_id, self.token, self.key)
            boards = requests.get("{0}{1}".format(self.base_url, url)).json()
            for board in boards:
                if board["shortLink"] == self.board_short_id:
                    self._board_id = board["id"]
                    break
        return self._board_id

    def lists(self, board_id):
        url = "/1/boards/{0}/lists?token={1}&key={2}".format(self.board_id, self.token, self.key)
        return requests.get("{0}{1}".format(self.base_url, url)).json()

    def create_list(self, name, board_id):
        url = "/1/lists?token={0}&key={1}".format(self.token, self.key)
        return requests.post("{0}{1}".format(self.base_url, url), data={
            "name": name,
            "idBoard": board_id
        }).json()

    def card_short_url(self, card_id):
        url = "/1/cards/{0}/shortUrl?token={1}&key={2}".format(card_id, self.token, self.key)
        return requests.get("{0}{1}".format(self.base_url, url)).json()["_value"]

    def _get_or_create_list(self, name):
        list_id = None
        for lst in self.lists(self.board_id):
            if lst["name"] == name:
                list_id = lst["id"]
        if list_id is None:
            list_id = self.create_list(name, self.board_id)["id"]
        return list_id

    @property
    def to_contact_list_id(self):
        if not self._to_contact_list_id:
            self._to_contact_list_id = self._get_or_create_list(self.to_contact_list_name)
        return self._to_contact_list_id

    @property
    def contacted_list_id(self):
        if not self._contacted_list_id:
            self._contacted_list_id = self._get_or_create_list(self.contacted_list_name)
        return self._contacted_list_id

    @property
    def answered_surveys_list_id(self):
        if not self._answered_surveys_list_id:
            self._answered_surveys_list_id = self._get_or_create_list(self.answered_surveys_list_name)
        return self._answered_surveys_list_id

    @property
    def imported_contacts_list_id(self):
        if not self._imported_contacts_list_id:
            self._imported_contacts_list_id = self._get_or_create_list(self.imported_contacts_list_name)
        return self._imported_contacts_list_id

    def cards(self, list_id):
        url = "/1/lists/{0}/cards?token={1}&key={2}".format(list_id, self.token, self.key)
        return requests.get("{0}{1}".format(self.base_url, url)).json()

    def move_card(self, card_id, list_id):
        url = "/1/card/{0}/idList?token={1}&key={2}".format(card_id, self.token, self.key)
        return requests.put("{0}{1}".format(self.base_url, url), data={"value": list_id})

    def create_card(self, title, description, list_id):
        url = "/1/cards?token={0}&key={1}".format(self.token, self.key)
        return requests.post("{0}{1}".format(self.base_url, url), data={"name": title, "desc": description, "idList": list_id}).json()

    def delete_card(self, card_id):
        url = "/1/cards/{2}?token={0}&key={1}".format(self.token, self.key, card_id)
        return requests.delete("{0}{1}".format(self.base_url, url))

    def setup_board(self, name):
        url = "/1/boards/?token={0}&key={1}".format(self.token, self.key)
        board_data = requests.post("{0}{1}".format(self.base_url, url), data={
            "name": name.encode("utf-8"),
            "prefs_permissionLevel": "org",
            "prefs_selfJoin": "true",
            "idOrganization": self.org_id
        }).json()
        return self.create_list(self.imported_answers_list_name, board_data["id"])["id"]

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from django.views.generic import TemplateView


urlpatterns = patterns(
    "",

    url(r"^list_signup/$", "waitinglist.views.list_signup", name="waitinglist_list_signup"),
    url(r"^ajax_list_signup/$", "waitinglist.views.ajax_list_signup", name="waitinglist_ajax_list_signup"),
    url(r"^survey/thanks/$", TemplateView.as_view(template_name="waitinglist/thanks.html"), name="waitinglist_thanks"),
    url(r"^survey/(?P<code>.*)/$", "waitinglist.views.survey", name="waitinglist_survey"),
    url(r"^success/$", TemplateView.as_view(template_name="waitinglist/success.html"), name="waitinglist_success"),
    url(r"^cohorts/$", "waitinglist.views.cohort_list", name="waitinglist_cohort_list"),
    url(r"^cohorts/create/$", "waitinglist.views.cohort_create", name="waitinglist_cohort_create"),
    url(r"^cohorts/cohort/(\d+)/$", "waitinglist.views.cohort_detail", name="waitinglist_cohort_detail"),
    url(r"^cohorts/cohort/(\d+)/add_member/$", "waitinglist.views.cohort_member_add", name="waitinglist_cohort_member_add"),
    url(r"^cohorts/cohort/(\d+)/send_invitations/$", "waitinglist.views.cohort_send_invitations", name="waitinglist_cohort_send_invitations"),
)

########NEW FILE########
__FILENAME__ = views
import json

from django.core.urlresolvers import reverse
from django.http import Http404, HttpResponse
from django.shortcuts import render, redirect, get_object_or_404
from django.template import RequestContext
from django.template.loader import render_to_string
from django.views.decorators.http import require_POST

from django.contrib.auth.models import User
from django.contrib.auth.decorators import permission_required

from account.models import SignupCode
from account.decorators import login_required

from .forms import WaitingListEntryForm, CohortCreate, SurveyForm
from .models import WaitingListEntry, Cohort, SignupCodeCohort, SurveyInstance
from .signals import signed_up


@require_POST
def ajax_list_signup(request):
    form = WaitingListEntryForm(request.POST)
    if form.is_valid():
        entry = form.save()
        signed_up.send(sender=ajax_list_signup, entry=entry)
        try:
            data = {
                "location": reverse("waitinglist_survey", args=[entry.surveyinstance.code])
            }
        except SurveyInstance.DoesNotExist:
            data = {
                "html": render_to_string("waitinglist/_success.html", {
                },  context_instance=RequestContext(request))
            }
    else:
        data = {
            "html": render_to_string("waitinglist/_list_signup.html", {
                "form": form,
            },  context_instance=RequestContext(request))
        }
    return HttpResponse(json.dumps(data), mimetype="application/json")


def list_signup(request, post_save_redirect=None):
    if request.method == "POST":
        form = WaitingListEntryForm(request.POST)
        if form.is_valid():
            entry = form.save()
            signed_up.send(sender=list_signup, entry=entry)
            try:
                post_save_redirect = reverse("waitinglist_survey", args=[entry.surveyinstance.code])
            except SurveyInstance.DoesNotExist:
                pass
            if post_save_redirect is None:
                post_save_redirect = reverse("waitinglist_success")
            if not post_save_redirect.startswith("/"):
                post_save_redirect = reverse(post_save_redirect)
            return redirect(post_save_redirect)
    else:
        form = WaitingListEntryForm()
    ctx = {
        "form": form,
    }
    return render(request, "waitinglist/list_signup.html", ctx)


def survey(request, code):
    instance = get_object_or_404(SurveyInstance, code=code)
    if request.method == "POST":
        form = SurveyForm(request.POST, survey=instance.survey)
        if form.is_valid():
            form.save(instance)
            return redirect("waitinglist_thanks")
    else:
        form = SurveyForm(survey=instance.survey)
    return render(request, "waitinglist/survey.html", {"form": form})


@login_required
@permission_required("waitinglist.manage_cohorts")
def cohort_list(request):

    ctx = {
        "cohorts": Cohort.objects.order_by("-created")
    }
    return render(request, "cohorts/cohort_list.html", ctx)


@login_required
@permission_required("waitinglist.manage_cohorts")
def cohort_create(request):

    if request.method == "POST":
        form = CohortCreate(request.POST)

        if form.is_valid():
            cohort = form.save()
            return redirect("waitinglist_cohort_detail", cohort.id)
    else:
        form = CohortCreate()

    ctx = {
        "form": form,
    }
    return render(request, "cohorts/cohort_create.html", ctx)


@login_required
@permission_required("waitinglist.manage_cohorts")
def cohort_detail(request, pk):

    cohort = get_object_or_404(Cohort, pk=pk)

    # people who are NOT invited or on the site already
    waiting_list = WaitingListEntry.objects.exclude(
        email__in=SignupCode.objects.values("email")
    ).exclude(
        email__in=User.objects.values("email")
    )

    ctx = {
        "cohort": cohort,
        "waiting_list": waiting_list,
    }
    return render(request, "cohorts/cohort_detail.html", ctx)


@login_required
@permission_required("waitinglist.manage_cohorts")
def cohort_member_add(request, pk):

    cohort = Cohort.objects.get(pk=pk)

    if "invite_next" in request.POST:
        try:
            N = int(request.POST["invite_next"])
        except ValueError:
            return redirect("waitinglist_cohort_detail", cohort.id)
        # people who are NOT invited or on the site already
        waiting_list = WaitingListEntry.objects.exclude(
            email__in=SignupCode.objects.values("email")
        ).exclude(
            email__in=User.objects.values("email")
        )
        emails = waiting_list.values_list("email", flat=True)[:N]
    else:
        email = request.POST["email"].strip()
        if email:
            emails = [email]
        else:
            emails = []

    for email in emails:
        if not SignupCode.objects.filter(email=email).exists():
            signup_code = SignupCode.create(email=email, max_uses=1, expiry=730)
            signup_code.save()
            SignupCodeCohort.objects.create(signup_code=signup_code, cohort=cohort)

    return redirect("waitinglist_cohort_detail", cohort.id)


@login_required
@permission_required("waitinglist.manage_cohorts")
def cohort_send_invitations(request, pk):

    cohort = Cohort.objects.get(pk=pk)
    cohort.send_invitations()

    return redirect("waitinglist_cohort_detail", cohort.id)

########NEW FILE########
