__FILENAME__ = initialize
#!/usr/bin/env python

import sys

sys.stderr.write(
    """Since Mathics 0.5, the functionality of initialize.py has been moved
into setup.py. Please run:

  {python} setup.py initialize

to initialize the database.
""".format(python=sys.executable or 'python'))
sys.exit(1)

########NEW FILE########
__FILENAME__ = benchmark
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

# Default number of times to repeat each benchmark. None -> Automatic
TESTS_PER_BENCHMARK = None

# Mathics expressions to benchmark
BENCHMARKS = {
    'Arithmetic': ['1 + 2', '5 * 3'],
    'Plot': [
        'Plot[0, {x, -3, 3}]',
        'Plot[x^2 + x + 1, {x, -3, 3}]',
        'Plot[Sin[Cos[x^2]], {x, -3, 3}]',
        'Plot[Sin[100 x], {x, -3, 3}]'],
    'Plot3D': [
        'Plot3D[0, {x, -1, 1}, {y, -1, 1}]',
        'Plot3D[x + y^2, {x, -3, 3}, {y, -2, 2}]',
        'Plot3D[Sin[x + y^2], {x, -3, 3}, {y, -3, 3}]',
        'Plot3D[Sin[100 x + 100 y ^ 2], {x, 0, 1}, {y, 0, 1}]'],
    'DensityPlot': [
        'DensityPlot[x + y^2, {x, -3, 3}, {y, -2, 2}]'],
    'Trig': [
        'Sin[RandomReal[]]', 'ArcTan[RandomReal[]]'],
    'Random': [
        'RandomInteger[{-100, 100}, 100]',
        'RandomInteger[10, {10, 10}]',
        'RandomInteger[{0,1}, {5, 5, 5}]',
        'RandomReal[1, 100]', 'RandomReal[{-1, 1}, 100]',
        'RandomComplex[2 + I, 50]',
        'RandomComplex[{-1 - I, 1 + I}, {10, 10}]'],
    'Expand': [
        'Expand[(a1+a2)^200]', 'Expand[(a1+a2+a3)^25]',
        'Expand[(a1+a2+a3+a4+a5+a6+a7)^3]'],
    'Matrix': [
        'RandomInteger[{0,1}, {10,10}] . RandomInteger[{0,1}, {10,10}]',
        'RandomInteger[{0,10}, {10,10}] + RandomInteger[{0,10}, {10,10}]'],
}

PARSING_BENCHMARKS = [
    "+".join(map(str, range(1, 1000))),
    ";".join(map(str, range(1, 1000))),
    "/".join(map(str, range(1, 1000))),
    "^".join(map(str, range(1, 1000))),
    "! " * 1000 + 'expr',
    "!" * 1000 + 'expr',
    'expr' + "& " * 1000,
    "Sin[" * 1000 + '0.5' + "]" * 1000,
]

import sys
import time
from argparse import ArgumentParser

import mathics
from mathics.core.parser import parse
from mathics.core.definitions import Definitions
from mathics.core.evaluation import Evaluation

definitions = Definitions(add_builtin=True)
evaluation = None


def format_time_units(seconds):
    if seconds < 1e-6:
        return "{0:4.3g} ns".format(seconds * 1e9)
    elif seconds < 1e-3:
        return "{0:4.3g} us".format(seconds * 1e6)
    elif seconds < 1:
        return "{0:4.3g} ms".format(seconds * 1e3)
    else:
        return "{0:4.3g} s ".format(seconds)


def timeit(func, repeats=None):
    if repeats is None:
        global TESTS_PER_BENCHMARK
        repeats = TESTS_PER_BENCHMARK

    times = []
    if repeats is not None:
        # Fixed number of repeats
        for i in xrange(repeats):
            times.append(time.clock())
            func()
    else:
        # Automatic number of repeats
        repeats = 10000
        for i in xrange(repeats):
            times.append(time.clock())
            func()
            if any(i == j for j in (5, 10, 100, 1000, 5000)):
                if times[-1] > times[0] + 1:
                    repeats = i
                    break

    times.append(time.clock())

    average_time = format_time_units((times[-1] - times[0]) / repeats)
    best_time = format_time_units(
        min([times[i + 1] - times[i] for i in range(repeats)]))
    print "    {0:5n} loops, avg: {1} per loop, best: {2} per loop".format(
        repeats, average_time, best_time)


def truncate_line(string):
    if len(string) > 70:
        return string[:70] + "..."
    return string


def benchmark_parse(expression_string):
    print "  '{0}'".format(truncate_line(expression_string))
    timeit(lambda: parse(expression_string))


def benchmark_format(expression_string):
    print "  '{0}'".format(expression_string)
    expr = parse(expression_string)
    timeit(lambda: expr.default_format(evaluation, "FullForm"))


def benchmark_expression(expression_string):
    print "  '{0}'".format(expression_string)
    expr = parse(expression_string)
    timeit(lambda: expr.evaluate(evaluation))


def benchmark_section(section_name):
    print section_name
    for benchmark in BENCHMARKS.get(section_name):
        benchmark_expression(benchmark)
    print ""


def benchmark_all():
    print "EVALUATION BENCHMARKS:"
    for section_name in sorted(BENCHMARKS.keys()):
        benchmark_section(section_name)
    print "PARSING BENCHMARKS:"
    for expression_string in PARSING_BENCHMARKS:
        benchmark_parse(expression_string)


def main():
    global evaluation, TESTS_PER_BENCHMARK
    parser = ArgumentParser(
        description="Mathics benchmark suite.", add_help=False)

    parser.add_argument(
        '--help', '-h', help='show this help message and exit', action='help')

    parser.add_argument(
        '--version', '-v', action='version',
        version='%(prog)s ' + mathics.__version__)

    parser.add_argument(
        '--section', '-s', dest="section", metavar="SECTION",
        help="only test SECTION")

    parser.add_argument(
        '--expression', '-e', dest="expression", metavar="EXPRESSION",
        help="benchmark a valid Mathics expression")

    parser.add_argument(
        '--number', '-n', dest="repeat", metavar="REPEAT",
        help="loop REPEAT number of times")

    args = parser.parse_args()

    try:
        evaluation = Evaluation("", definitions, catch_interrupt=False)
    except Exception, exc:
        print "Exception {0}".format(exc)
        info = sys.exc_info()
        sys.excepthook(*info)
        sys.exit(-1)

    if args.repeat is not None:
        TESTS_PER_BENCHMARK = int(args.repeat)

    if args.expression:
        benchmark_expression(args.expression)
    elif args.section:
        benchmark_section(args.section)
    else:
        benchmark_all()

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = algebra
# -*- coding: utf8 -*-

from mathics.builtin.base import Builtin
from mathics.core.expression import Expression, Integer
from mathics.core.convert import from_sympy

import sympy
import sympy.mpmath as mpmath


def sympy_factor(expr_sympy):
    try:
        result = sympy.together(expr_sympy)
        numer, denom = result.as_numer_denom()
        if denom == 1:
            result = sympy.factor(expr_sympy)
        else:
            result = sympy.factor(numer) / sympy.factor(denom)
    except sympy.PolynomialError:
        return expr_sympy
    return result


def cancel(expr):
    if expr.has_form('Plus', None):
        return Expression('Plus', *[cancel(leaf) for leaf in expr.leaves])
    else:
        try:
            result = expr.to_sympy()
            # result = sympy.powsimp(result, deep=True)
            result = sympy.cancel(result)

            # cancel factors out rationals, so we factor them again
            result = sympy_factor(result)

            return from_sympy(result)
        except sympy.PolynomialError:
            # e.g. for non-commutative expressions
            return expr


class Cancel(Builtin):
    """
    <dl>
    <dt>'Cancel[$expr$]'
        <dd>cancels out common factors in numerators and denominators.
    </dl>

    >> Cancel[x / x ^ 2]
     = 1 / x
    'Cancel' threads over sums:
    >> Cancel[x / x ^ 2 + y / y ^ 2]
     = 1 / x + 1 / y

    >> Cancel[f[x] / x + x * f[x] / x ^ 2]
     = 2 f[x] / x
    """

    def apply(self, expr, evaluation):
        'Cancel[expr_]'

        return cancel(expr)


class Simplify(Builtin):
    """
    <dl>
    <dt>'Simplify[$expr$]'
        <dd>simplifies $expr$.
    </dl>

    >> Simplify[2*Sin[x]^2 + 2*Cos[x]^2]
     = 2
    >> Simplify[x]
     = x
    >> Simplify[f[x]]
     = f[x]
    """

    rules = {
        'Simplify[list_List]': 'Simplify /@ list',
        'Simplify[rule_Rule]': 'Simplify /@ rule',
        'Simplify[eq_Equal]': 'Simplify /@ eq',
    }

    def apply(self, expr, evaluation):
        'Simplify[expr_]'

        expr_sympy = expr.to_sympy()
        result = expr_sympy
        try:
            result = sympy.simplify(result)
        except TypeError:
            # XXX What's going on here?
            pass
        result = sympy.trigsimp(result)
        result = sympy.together(result)
        result = sympy.cancel(result)
        result = from_sympy(result)
        return result


class Together(Builtin):
    """
    <dl>
    <dt>'Together[$expr$]'
        <dd>writes sums of fractions in $expr$ together.
    </dl>

    >> Together[a / c + b / c]
     = (a + b) / c
    'Together' operates on lists:
    >> Together[{x / (y+1) + x / (y+1)^2}]
     = {x (2 + y) / (1 + y) ^ 2}
    But it does not touch other functions:
    >> Together[f[a / c + b / c]]
     = f[a / c + b / c]

    #> f[x]/x+f[x]/x^2//Together
     = (1 + x) f[x] / x ^ 2
    """

    attributes = ['Listable']

    def apply(self, expr, evaluation):
        'Together[expr_]'

        expr_sympy = expr.to_sympy()
        result = sympy.together(expr_sympy)
        result = from_sympy(result)
        result = cancel(result)
        return result


class Factor(Builtin):
    """
    <dl>
    <dt>'Factor[$expr$]'
        <dd>factors the polynomial expression $expr$.
    </dl>

    >> Factor[x ^ 2 + 2 x + 1]
     = (1 + x) ^ 2

    >> Factor[1 / (x^2+2x+1) + 1 / (x^4+2x^2+1)]
     = (2 + 2 x + 3 x ^ 2 + x ^ 4) / ((1 + x) ^ 2 (1 + x ^ 2) ^ 2)
    """

    def apply(self, expr, evaluation):
        'Factor[expr_]'

        expr_sympy = expr.to_sympy()
        try:
            result = sympy.together(expr_sympy)
            numer, denom = result.as_numer_denom()
            if denom == 1:
                result = sympy.factor(expr_sympy)
            else:
                result = sympy.factor(numer) / sympy.factor(denom)
        except sympy.PolynomialError:
            return expr
        return from_sympy(result)


class Apart(Builtin):
    """
    <dl>
    <dt>'Apart[$expr$]'
        <dd>writes $expr$ as sum of individual fractions.
    <dt>'Apart[$expr$, $var$]'
        <dd>treats $var$ as main variable.
    </dl>

    >> Apart[1 / (x^2 + 5x + 6)]
     = 1 / (2 + x) - 1 / (3 + x)

    When several variables are involved, the results can be different
    depending on the main variable:
    >> Apart[1 / (x^2 - y^2), x]
     = -1 / (2 y (x + y)) + 1 / (2 y (x - y))
    >> Apart[1 / (x^2 - y^2), y]
     = 1 / (2 x (x + y)) + 1 / (2 x (x - y))

    'Apart' is 'Listable':
    >> Apart[{1 / (x^2 + 5x + 6)}]
     = {1 / (2 + x) - 1 / (3 + x)}

    But it does not touch other expressions:
    >> Sin[1 / (x ^ 2 - y ^ 2)] // Apart
     = Sin[1 / (x ^ 2 - y ^ 2)]

    #> Attributes[f] = {HoldAll}; Apart[f[x + x]]
     = f[x + x]

    #> Attributes[f] = {}; Apart[f[x + x]]
     = f[2 x]
    """

    attributes = ['Listable']
    rules = {
        'Apart[expr_]': (
            'Block[{vars = Cases[Level[expr, {-1}], _Symbol]},'
            '  If[Length[vars] > 0, Apart[expr, vars[[1]]], expr]]'),
    }

    def apply(self, expr, var, evaluation):
        'Apart[expr_, var_Symbol]'

        expr_sympy = expr.to_sympy()
        var_sympy = var.to_sympy()
        try:
            result = sympy.apart(expr_sympy, var_sympy)
            result = from_sympy(result)
            return result
        except sympy.PolynomialError:
            # raised e.g. for apart(sin(1/(x**2-y**2)))
            return expr


class Expand(Builtin):
    """
    <dl>
    <dt>'Expand[$expr$]'
        <dd>expands out positive integer powers and products of sums in $expr$.
    </dl>
    >> Expand[(x + y) ^ 3]
     = x ^ 3 + 3 x ^ 2 y + 3 x y ^ 2 + y ^ 3
    >> Expand[(a + b) (a + c + d)]
     = a ^ 2 + a b + a c + a d + b c + b d
    >> Expand[(a + b) (a + c + d) (e + f) + e a a]
     = 2 a ^ 2 e + a ^ 2 f + a b e + a b f + a c e + a c f + a d e + a d f + b c e + b c f + b d e + b d f
    >> Expand[(a + b) ^ 2 * (c + d)]
     = a ^ 2 c + a ^ 2 d + 2 a b c + 2 a b d + b ^ 2 c + b ^ 2 d
    >> Expand[(x + y) ^ 2 + x y]
     = x ^ 2 + 3 x y + y ^ 2
    >> Expand[((a + b) (c + d)) ^ 2 + b (1 + a)]
     = a ^ 2 c ^ 2 + 2 a ^ 2 c d + a ^ 2 d ^ 2 + b + a b + 2 a b c ^ 2 + 4 a b c d + 2 a b d ^ 2 + b ^ 2 c ^ 2 + 2 b ^ 2 c d + b ^ 2 d ^ 2

    'Expand' expands items in lists and rules:
    >> Expand[{4 (x + y), 2 (x + y) -> 4 (x + y)}]
     = {4 x + 4 y, 2 x + 2 y -> 4 x + 4 y}

    'Expand' does not change any other expression.
    >> Expand[Sin[x (1 + y)]]
     = Sin[x (1 + y)]

    #> a(b(c+d)+e) // Expand
     = a b c + a b d + a e

    #> (y^2)^(1/2)/(2x+2y)//Expand
     = Sqrt[y ^ 2] / (2 x + 2 y)

    ## This caused a program crash!
    #> 2(3+2x)^2/(5+x^2+3x)^3 // Expand
     = 24 x / (5 + 3 x + x ^ 2) ^ 3 + 8 x ^ 2 / (5 + 3 x + x ^ 2) ^ 3 + 18 / (5 + 3 x + x ^ 2) ^ 3
    """

    def apply(self, expr, evaluation):
        'Expand[expr_]'

        def expand(expr):
            head_name = expr.get_head_name()
            if head_name in ('List', 'Rule'):
                return Expression(
                    head_name, *[expand(leaf) for leaf in expr.leaves])
            leaves = expr.get_leaves()
            if expr.has_form('Times', 2, None):
                " Group negative powers into one negative power "
                neg_powers = []
                other_leaves = []
                for leaf in leaves:
                    if (leaf.has_form('Power', 2) and   # nopep8
                        leaf.leaves[1].get_int_value() is not None and
                        leaf.leaves[1].get_int_value() < 0):
                        neg_powers.append(leaf)
                    else:
                        other_leaves.append(leaf)
                if len(neg_powers) > 1:
                    leaves = other_leaves + [
                        Expression('Power', Expression('Times', *[
                            Expression(
                                'Power', leaf.leaves[0],
                                Integer(sympy.Integer(-leaf.leaves[1].value)))
                            for leaf in neg_powers]), Integer(-1))]
            if head_name in ('Plus', 'Times', 'Power'):
                leaves = [expand(leaf) for leaf in leaves]
            if expr.has_form('Times', 2, None):
                result = [[]]
                has_plus = False
                for leaf in leaves:
                    if leaf.has_form('Plus', 1):
                        leaf = leaf.leaves[0]
                    if leaf.has_form('Plus', 2, None):
                        new_result = []
                        for summand in leaf.leaves:
                            if summand.has_form('Times', None):
                                add = summand.leaves
                            else:
                                add = [summand]
                            new_result.extend(item + add for item in result)
                        result = new_result
                        has_plus = True
                    else:
                        if leaf.has_form('Times', None):
                            add = leaf.leaves
                        else:
                            add = [leaf]
                        result = [item + add for item in result]
                if has_plus:
                    return Expression(
                        'Plus', *(expand(Expression('Times', *item))
                        for item in result))

                else:
                    return Expression('Plus', *(
                        Expression('Times', *item) for item in result))

            elif expr.has_form('Power', 2):
                n = leaves[1].get_int_value()
                sum = leaves[0]
                if sum.has_form('Plus', None) and n is not None and n > 0:
                    result = []
                    items = sum.leaves

                    def iterate(rest, n_rest):
                        if rest and n_rest > 0:
                            for k in range(n_rest + 1):
                                for coeff, next in iterate(rest[1:],
                                                           n_rest - k):
                                    if k == 0:
                                        this_factor = []
                                    else:
                                        this_factor = [Expression(
                                            'Power', rest[0], Integer(k))]
                                    yield (int(
                                        mpmath.binomial(n_rest, k) * coeff),
                                        this_factor + next)
                        elif n_rest == 0:
                            yield (sympy.Integer(1), [])

                    def times(coeff, factors):
                        if coeff == 1:
                            return Expression('Times', *factors)
                        else:
                            return Expression(
                                'Times', Integer(coeff), *factors)

                    return Expression('Plus', *[
                        times(coeff, factors) for coeff,
                        factors in iterate(items, n)])
                else:
                    return Expression(
                        expr.head, *[expand(leaf) for leaf in expr.leaves])
            elif expr.has_form('Plus', 2, None):
                return Expression('Plus', *leaves)
            else:
                return expr

        result = expand(expr)
        return result


class PowerExpand(Builtin):
    """
    <dl>
    <dt>'PowerExpand[$expr$]'
        <dd>expands out powers of the form '(x^y)^z' and '(x*y)^z' in $expr$.
    </dl>

    >> PowerExpand[(a ^ b) ^ c]
     = a ^ (b c)
    >> PowerExpand[(a * b) ^ c]
     = a ^ c b ^ c

    'PowerExpand' is not correct without certain assumptions:
    >> PowerExpand[(x ^ 2) ^ (1/2)]
     = x
    """

    rules = {
        'PowerExpand[(x_ ^ y_) ^ z_]': 'x ^ (y * z)',
        'PowerExpand[(x_ * y_) ^ z_]': 'x ^ z * y ^ z',
        'PowerExpand[Log[x_ ^ y_]]': 'y * Log[x]',
        'PowerExpand[x_Plus]': 'PowerExpand /@ x',
        'PowerExpand[x_Times]': 'PowerExpand /@ x',
        'PowerExpand[x_Power]': 'PowerExpand /@ x',
        'PowerExpand[x_List]': 'PowerExpand /@ x',
        'PowerExpand[x_Rule]': 'PowerExpand /@ x',
        'PowerExpand[other_]': 'other',
    }


class Numerator(Builtin):
    """
    <dl>
    <dt>'Numerator[$expr$]'
        <dd>gives the numerator in $expr$.
    </dl>

    >> Numerator[a / b]
     = a
    >> Numerator[2 / 3]
     = 2
    >> Numerator[a + b]
     = a + b
    """

    def apply(self, expr, evaluation):
        'Numerator[expr_]'

        sympy_expr = expr.to_sympy()
        numer, denom = sympy_expr.as_numer_denom()
        return from_sympy(numer)


class Denominator(Builtin):
    """
    <dl>
    <dt>'Denominator[$expr$]'
        <dd>gives the denominator in $expr$.
    </dl>

    >> Denominator[a / b]
     = b
    >> Denominator[2 / 3]
     = 3
    >> Denominator[a + b]
     = 1
    """

    def apply(self, expr, evaluation):
        'Denominator[expr_]'

        sympy_expr = expr.to_sympy()
        numer, denom = sympy_expr.as_numer_denom()
        return from_sympy(denom)


class Variables(Builtin):
    # This builtin is incomplete. See the failing test case below.
    """
    <dl>
    <dt>'Variables[$expr$]'
        <dd>gives a list of the variables that appear in the
        polynomial $expr$.
    </dl>

    >> Variables[a x^2 + b x + c]
     = {a, b, c, x}
    >> Variables[{a + b x, c y^2 + x/2}]
     = {a, b, c, x, y}
    >> Variables[x + Sin[y]]
     = {x, Sin[y]}
    """

    """
    ## failing test case from MMA docs
    #> Variables[E^x]
     = {}
    """

    def apply(self, expr, evaluation):
        'Variables[expr_]'

        variables = set()

        def find_vars(e):
            if e.to_sympy().is_constant():
                return
            elif e.is_symbol():
                variables.add(e)
            elif (e.has_form('Plus', None) or
                  e.has_form('Times', None)):
                for l in e.leaves:
                    find_vars(l)
            elif e.has_form('Power', 2):
                (a, b) = e.leaves  # a^b
                if not(a.to_sympy().is_constant()) and b.to_sympy().is_rational:
                    find_vars(a)
            elif not(e.is_atom()):
                variables.add(e)

        exprs = expr.leaves if expr.has_form('List', None) else [expr]
        for e in exprs:
            find_vars(from_sympy(e.to_sympy().expand()))

        variables = Expression('List', *variables)
        variables.sort()        # MMA doesn't do this
        return variables

########NEW FILE########
__FILENAME__ = arithmetic
# -*- coding: utf8 -*-

"""
Arithmetic functions

Basic arithmetic functions, including complex number arithmetic.
"""

from __future__ import with_statement

import sympy
import sympy.mpmath as mpmath

from mathics.builtin.base import (
    Builtin, Predefined, BinaryOperator, PrefixOperator, PostfixOperator, Test,
    SympyFunction, SympyConstant)

from mathics.core.expression import (Expression, Number, Integer, Rational,
                                     Real, Symbol, Complex, String)
from mathics.core.numbers import (
    add, min_prec, dps, sympy2mpmath, mpmath2sympy, SpecialValueError)

from mathics.builtin.lists import _IterationFunction
from mathics.core.convert import from_sympy


class _MPMathFunction(SympyFunction):

    attributes = ('Listable', 'NumericFunction')

    mpmath_name = None

    nargs = 1

    def eval(self, *args):
        if self.mpmath_name is None:
            return None

        mpmath_function = getattr(mpmath, self.mpmath_name)
        return mpmath_function(*args)

    def apply(self, z, evaluation):
        '%(name)s[z__]'

        args = z.get_sequence()

        if len(args) != self.nargs:
            return

        # if no arguments are inexact attempt to use sympy
        if all(not x.is_inexact() for x in args):
            result = Expression(self.get_name(), *args).to_sympy()
            result = self.prepare_mathics(result)
            result = from_sympy(result)
            # evaluate leaves to convert e.g. Plus[2, I] -> Complex[2, 1]
            result = result.evaluate_leaves(evaluation)
        else:
            prec = min_prec(*args)
            with mpmath.workprec(prec):
                mpmath_args = [sympy2mpmath(x.to_sympy()) for x in args]
                if None in mpmath_args:
                    return
                try:
                    result = self.eval(*mpmath_args)
                    result = from_sympy(mpmath2sympy(result, prec))
                except ValueError, exc:
                    text = str(exc)
                    if text == 'gamma function pole':
                        return Symbol('ComplexInfinity')
                    else:
                        raise
                except ZeroDivisionError:
                    return
                except SpecialValueError, exc:
                    return Symbol(exc.name)

        return result


class Plus(BinaryOperator, SympyFunction):
    """
    <dl>
    <dt>'Plus[$a$, $b$, ...]'</dt>
    <dt>$a$ + $b$ + ...</dt>
        <dd>represents the sum of the terms $a$, $b$, ...
    </dl>

    >> 1 + 2
     = 3

    'Plus' performs basic simplification of terms:

    >> a + b + a
     = 2 a + b
    >> a + a + 3 * a
     = 5 a
    >> a + b + 4.5 + a + b + a + 2 + 1.5 b
     = 6.5 + 3. a + 3.5 b

    Apply 'Plus' on a list to sum up its elements:
    >> Plus @@ {2, 4, 6}
     = 12
    The sum of the first 1000 integers:
    >> Plus @@ Range[1000]
     = 500500

    'Plus' has default value 0:
    >> DefaultValues[Plus]
     = {HoldPattern[Default[Plus]] :> 0}
    >> a /. n_. + x_ :> {n, x}
     = {0, a}

    The sum of 2 red circles and 3 red circles is...
    >> 2 Graphics[{Red,Disk[]}] + 3 Graphics[{Red,Disk[]}]
     = 5 -Graphics-

    #> -2a - 2b
     = -2 a - 2 b
    #> -4+2x+2*Sqrt[3]
     = -4 + 2 Sqrt[3] + 2 x
    #> 2a-3b-c
     = 2 a - 3 b - c
    #> 2a+5d-3b-2c-e
     = 2 a - 3 b - 2 c + 5 d - e

    #> 1 - I * Sqrt[3]
     = 1 - I Sqrt[3]

    #> Head[3 + 2 I]
     = Complex
    """

    operator = '+'
    precedence = 310
    attributes = ('Flat', 'Listable', 'NumericFunction',
                  'OneIdentity', 'Orderless', 'Protected')

    default_formats = False

    defaults = {
        None: '0',
    }

    sympy_name = 'Add'

    def format_plus(self, items, evaluation):
        'Plus[items__]'

        def negate(item):
            if item.has_form('Times', 1, None):
                if isinstance(item.leaves[0], Number):
                    neg = Number.from_mp(-item.leaves[0].to_sympy())
                    if neg.same(Integer(1)):
                        if len(item.leaves) == 1:
                            return neg
                        else:
                            return Expression('Times', *item.leaves[1:])
                    else:
                        return Expression('Times', neg, *item.leaves[1:])
                else:
                    return Expression('Times', -1, *item.leaves)
            elif isinstance(item, (Integer, Rational, Real, Complex)):
                return Number.from_mp(-item.to_sympy())
            else:
                return Expression('Times', -1, item)

        def is_negative(value):
            if isinstance(value, Complex):
                real, imag = value.to_sympy().as_real_imag()
                if real <= 0 and imag <= 0:
                    return True
            elif isinstance(value, Number) and value.to_sympy() < 0:
                return True
            return False

        items = items.get_sequence()
        values = [Expression('HoldForm', item) for item in items[:1]]
        ops = []
        for item in items[1:]:
            if (item.has_form('Times', 1, None) and is_negative(item.leaves[0])) or is_negative(item):
                item = negate(item)
                op = "-"
            else:
                op = "+"
            values.append(Expression('HoldForm', item))
            ops.append(String(op))
        return Expression('Infix', Expression('List', *values),
                          Expression('List', *ops), 310, Symbol('Left'))

    def apply(self, items, evaluation):
        'Plus[items___]'

        items = items.numerify(evaluation).get_sequence()
        leaves = []
        last_item = last_count = None

        prec = min_prec(*items)
        is_real = all([not isinstance(i, Complex) for i in items])

        if prec is None:
            number = (sympy.Integer(0), sympy.Integer(0))
        else:
            number = (
                sympy.Float('0.0', dps(prec)),
                sympy.Float('0.0', dps(prec)))

        def append_last():
            if last_item is not None:
                if last_count == 1:
                    leaves.append(last_item)
                else:
                    if last_item.has_form('Times', None):
                        last_item.leaves.insert(0, Number.from_mp(last_count))
                        leaves.append(last_item)
                    else:
                        leaves.append(Expression(
                            'Times', Number.from_mp(last_count), last_item))

        for item in items:
            if isinstance(item, Number):
                # TODO: Optimise this for the case of adding many real numbers
                if isinstance(item, Complex):
                    sym_real, sym_imag = item.real.to_sympy(
                    ), item.imag.to_sympy()
                else:
                    sym_real, sym_imag = item.to_sympy(), sympy.Integer(0)

                if prec is not None:
                    sym_real = sym_real.n(dps(prec))
                    sym_imag = sym_imag.n(dps(prec))

                number = (number[0] + sym_real, number[1] + sym_imag)
            else:
                count = rest = None
                if item.has_form('Times', None):
                    for leaf in item.leaves:
                        if isinstance(leaf, Number):
                            count = leaf.to_sympy()
                            rest = item.leaves[:]
                            rest.remove(leaf)
                            if len(rest) == 1:
                                rest = rest[0]
                            else:
                                rest.sort()
                                rest = Expression('Times', *rest)
                            break
                if count is None:
                    count = sympy.Integer(1)
                    rest = item
                if last_item is not None and last_item == rest:
                    last_count = add(last_count, count)
                else:
                    append_last()
                    last_item = rest
                    last_count = count
        append_last()
        if prec is not None or number != (0, 0):
            if number[1].is_zero and is_real:
                leaves.insert(0, Number.from_mp(number[0], prec))
            elif number[1].is_zero and number[1].is_Integer and prec is None:
                leaves.insert(0, Number.from_mp(number[0], prec))
            else:
                leaves.insert(0, Complex(number[0], number[1], prec))
        if not leaves:
            return Integer(0)
        elif len(leaves) == 1:
            return leaves[0]
        else:
            leaves.sort()
            return Expression('Plus', *leaves)


class Subtract(BinaryOperator):
    """
    <dl>
    <dt>'Subtract[$a$, $b$]'</dt>
    <dt>$a$ - $b$</dt>
        <dd>represents the subtraction of $b$ from $a$.</dd>
    </dl>

    >> 5 - 3
     = 2
    >> a - b // FullForm
     = Plus[a, Times[-1, b]]
    >> a - b - c
     = a - b - c
    >> a - (b - c)
     = a - b + c
    """

    operator = '-'
    precedence_parse = 311
    precedence = 310
    attributes = ('Listable', 'NumericFunction')
    grouping = 'Left'

    rules = {
        'Subtract[x_, y_]': 'Plus[x, Times[-1, y]]',
    }


class Minus(PrefixOperator):
    """
    <dl>
    <dt>'Minus[$expr$]'
        <dd> is the negation of $expr$.
    </dl>

    >> -a //FullForm
     = Times[-1, a]

    'Minus' automatically distributes:
    >> -(x - 2/3)
     = 2 / 3 - x

    'Minus' threads over lists:
    >> -Range[10]
    = {-1, -2, -3, -4, -5, -6, -7, -8, -9, -10}
    """

    operator = '-'
    precedence = 480
    attributes = ('Listable', 'NumericFunction')

    rules = {
        'Minus[x_]': 'Times[-1, x]',
    }

    formats = {
        'Minus[x_]': 'Prefix[{HoldForm[x]}, "-", 480]',
        # don't put e.g. -2/3 in parentheses
        'Minus[expr_Divide]': 'Prefix[{HoldForm[expr]}, "-", 399]',
        'Minus[Infix[expr_, op_, 400, grouping_]]': (
            'Prefix[{Infix[expr, op, 400, grouping]}, "-", 399]'),
    }

    def apply_int(self, x, evaluation):
        'Minus[x_Integer]'

        return Integer(-x.to_sympy())

    def post_parse(self, expression):
        if (expression.get_head().get_name() == 'Minus'    # noqa
            and len(expression.leaves) == 1
            and isinstance(expression.leaves[0], Number)):
            return Number.from_mp(-expression.leaves[0].to_sympy())
        else:
            return super(Minus, self).post_parse(expression)


class PrePlus(PrefixOperator):
    """
    Hack to help the parser distinguish between binary and unary Plus.

    >> +a //FullForm
     = a

    #> +(x - 2/3 + y)
     = -2 / 3 + x + y

    #> +Infinity
     = Infinity
    """

    operator = '+'
    precedence = 480
    attributes = ('Listable', 'NumericFunction')

    def apply_int(self, x, evaluation):
        'PrePlus[x_]'
        return x

    def post_parse(self, expression):
        return expression.leaves[0]


def create_infix(items, operator, prec, grouping):
    if len(items) == 1:
        return items[0]
    else:
        return Expression('Infix', Expression('List', *items),
                          String(operator), prec, Symbol(grouping))


class Times(BinaryOperator, SympyFunction):
    """
    <dl>
    <dt>'Times[$a$, $b$, ...]'</dt>
    <dt>'$a$ * $b$ * ...'</dt>
    <dt>'$a$ $b$ ...'</dt>
        <dd>represents the product of the terms $a$, $b$, ...
    </dl>
    >> 10 * 2
     = 20
    >> 10 2
     = 20
    >> a * a
     = a ^ 2
    >> x ^ 10 * x ^ -2
     = x ^ 8
    >> {1, 2, 3} * 4
     = {4, 8, 12}
    >> Times @@ {1, 2, 3, 4}
     = 24
    >> IntegerLength[Times@@Range[5000]]
     = 16326

    'Times' has default value 1:
    >> DefaultValues[Times]
     = {HoldPattern[Default[Times]] :> 1}
    >> a /. n_. * x_ :> {n, x}
     = {1, a}

    #> -a*b // FullForm
     = Times[-1, a, b]
    #> -(x - 2/3)
     = 2 / 3 - x
    #> -x*2
     = -2 x
    #> -(h/2) // FullForm
     = Times[Rational[-1, 2], h]

    #> x / x
     = 1
    #> 2x^2 / x^2
     = 2

    #> 3. Pi
     = 9.42477796076937972

    #> Head[3 * I]
     = Complex

    #> Head[Times[I, 1/2]]
     = Complex

    #> Head[Pi * I]
     = Times

    #> 3 * a //InputForm
     = 3*a
    #> 3 * a //OutputForm
     = 3 a
    """

    operator = '*'
    operator_display = ' '
    precedence = 400
    attributes = ('Flat', 'Listable', 'NumericFunction',
                  'OneIdentity', 'Orderless', 'Protected')

    defaults = {
        None: '1',
    }

    default_formats = False

    sympy_name = 'Mul'

    rules = {
    }

    formats = {
    }

    def format_times(self, items, evaluation, op=u'\u2062'):
        'Times[items__]'

        def inverse(item):
            if item.has_form('Power', 2) and isinstance(    # noqa
                item.leaves[1], (Integer, Rational, Real)):
                neg = Number.from_mp(-item.leaves[1].to_sympy())
                if neg.same(Integer(1)):
                    return item.leaves[0]
                else:
                    return Expression('Power', item.leaves[0], neg)
            else:
                return item

        items = items.get_sequence()
        positive = []
        negative = []
        for item in items:
            if (item.has_form('Power', 2)   # noqa
                and isinstance(item.leaves[1], (Integer, Rational, Real))
                and item.leaves[1].to_sympy() < 0):
                negative.append(inverse(item))
            elif isinstance(item, Rational):
                numerator = item.numerator()
                if not numerator.same(Integer(1)):
                    positive.append(numerator)
                negative.append(item.denominator())
            else:
                positive.append(item)
        if (positive and isinstance(positive[0], (Integer, Real))   # noqa
            and positive[0].to_sympy() < 0):
            positive[0] = Number.from_mp(-positive[0].to_sympy())
            if positive[0].same(Integer(1)):
                del positive[0]
            minus = True
        else:
            minus = False
        positive = [Expression('HoldForm', item) for item in positive]
        negative = [Expression('HoldForm', item) for item in negative]
        if positive:
            positive = create_infix(positive, op, 400, 'None')
        else:
            positive = Integer(1)
        if negative:
            negative = create_infix(negative, op, 400, 'None')
            result = Expression('Divide', Expression(
                'HoldForm', positive), Expression('HoldForm', negative))
        else:
            result = positive
        if minus:
            result = Expression(
                'Minus', result)  # Expression('PrecedenceForm', result, 481))
        result = Expression('HoldForm', result)
        return result

    def format_inputform(self, items, evaluation):
        'InputForm: Times[items__]'
        return self.format_times(items, evaluation, op='*')

    def format_outputform(self, items, evaluation):
        'OutputForm: Times[items__]'
        return self.format_times(items, evaluation, op=' ')

    def apply(self, items, evaluation):
        'Times[items___]'

        # TODO: Clean this up and optimise it

        items = items.numerify(evaluation).get_sequence()
        number = (sympy.Integer(1), sympy.Integer(0))
        leaves = []

        prec = min_prec(*items)
        is_real = all([not isinstance(i, Complex) for i in items])

        for item in items:
            if isinstance(item, Number):
                if isinstance(item, Complex):
                    sym_real, sym_imag = item.real.to_sympy(
                    ), item.imag.to_sympy()
                else:
                    sym_real, sym_imag = item.to_sympy(), sympy.Integer(0)

                if prec is not None:
                    sym_real = sym_real.n(dps(prec))
                    sym_imag = sym_imag.n(dps(prec))

                if sym_real.is_zero and sym_imag.is_zero and prec is None:
                    return Integer('0')
                number = (
                    number[0] * sym_real - number[1] * sym_imag,
                    number[0] * sym_imag + number[1] * sym_real)
            elif leaves and item == leaves[-1]:
                leaves[-1] = Expression('Power', leaves[-1], Integer(2))
            elif (leaves and item.has_form('Power', 2)
                  and leaves[-1].has_form('Power', 2)
                  and item.leaves[0].same(leaves[-1].leaves[0])):
                leaves[-1].leaves[1] = Expression(
                    'Plus', item.leaves[1], leaves[-1].leaves[1])
            elif (leaves and item.has_form('Power', 2)
                  and item.leaves[0].same(leaves[-1])):
                leaves[-1] = Expression(
                    'Power', leaves[-1],
                    Expression('Plus', item.leaves[1], Integer(1)))
            elif (leaves and leaves[-1].has_form('Power', 2)
                  and leaves[-1].leaves[0].same(item)):
                leaves[-1] = Expression('Power', item, Expression(
                    'Plus', Integer(1), leaves[-1].leaves[1]))
            else:
                leaves.append(item)
        if number == (1, 0):
            number = None
        elif number == (-1, 0) and leaves and leaves[0].has_form('Plus', None):
            leaves[0].leaves = [Expression('Times', Integer(
                -1), leaf) for leaf in leaves[0].leaves]
            number = None

        if number is not None:
            if number[1].is_zero and is_real:
                leaves.insert(0, Number.from_mp(number[0], prec))
            elif number[1].is_zero and number[1].is_Integer and prec is None:
                leaves.insert(0, Number.from_mp(number[0], prec))
            else:
                leaves.insert(0, Complex(from_sympy(
                    number[0]), from_sympy(number[1]), prec))

        if not leaves:
            return Integer(1)
        elif len(leaves) == 1:
            return leaves[0]
        else:
            return Expression('Times', *leaves)


class Divide(BinaryOperator):
    """
    <dl>
    <dt>'Divide[$a$, $b$]'</dt>
    <dt>'$a$ / $b$'</dt>
        <dd>represents the division of $a$ by $b$.
    </dl>
    >> 30 / 5
     = 6
    >> 1 / 8
     = 1 / 8
    >> Pi / 4
     = Pi / 4

    Use 'N' or a decimal point to force numeric evaluation:
    >> Pi / 4.0
     = 0.78539816339744831
    >> 1 / 8
     = 1 / 8
    >> N[%]
     = 0.125

    Nested divisions:
    >> a / b / c
     = a / (b c)
    >> a / (b / c)
     = a c / b
    >> a / b / (c / (d / e))
     = a d / (b c e)
    >> a / (b ^ 2 * c ^ 3 / e)
     = a e / (b ^ 2 c ^ 3)

    #> 1 / 4.0
     = 0.25
    #> 10 / 3 // FullForm
     = Rational[10, 3]
    #> a / b // FullForm
     = Times[a, Power[b, -1]]

    """

    operator = '/'
    precedence = 470
    attributes = ('Listable', 'NumericFunction')
    grouping = 'Left'

    default_formats = False

    rules = {
        'Divide[x_, y_]': 'Times[x, Power[y, -1]]',
        'MakeBoxes[Divide[x_, y_], f:StandardForm|TraditionalForm]': (
            'FractionBox[MakeBoxes[x, f], MakeBoxes[y, f]]'),
    }

    formats = {
        (('InputForm', 'OutputForm'), 'Divide[x_, y_]'): (
            'Infix[{HoldForm[x], HoldForm[y]}, "/", 400, Left]'),
    }

    def post_parse(self, expression):
        if len(expression.leaves) == 2:
            if (isinstance(expression.leaves[0], Integer) and   # noqa
                isinstance(expression.leaves[1], Integer) and
                expression.leaves[1].to_sympy() != 0):

                return Number.from_mp(Rational(
                    expression.leaves[0].to_sympy(),
                    expression.leaves[1].to_sympy()).to_sympy())
            else:
                if (isinstance(expression.leaves[0], Integer) and   # noqa
                    expression.leaves[0].to_sympy() == 1):

                    return Expression('Power',
                                      expression.leaves[1].post_parse(),
                                      Integer(-1))
                else:
                    return Expression(
                        'Times', expression.leaves[0].post_parse(),
                        Expression('Power', expression.leaves[1].post_parse(),
                                   Integer(-1)))
        else:
            return super(Divide, self).post_parse(expression)


class Power(BinaryOperator, SympyFunction):
    """
    <dl>
    <dt>'Power[$a$, $b$]'</dt>
    <dt>'$a$ ^ $b$'</dt>
        <dd>represents $a$ raised to the power of $b$.
    </dl>

    >> 4 ^ (1/2)
     = 2
    >> 4 ^ (1/3)
     = 2 ^ (2 / 3)
    >> 3^123
     = 48519278097689642681155855396759336072749841943521979872827

    >> (y ^ 2) ^ (1/2)
     = Sqrt[y ^ 2]
    >> (y ^ 2) ^ 3
     = y ^ 6

    >> Plot[Evaluate[Table[x^y, {y, 1, 5}]], {x, -1.5, 1.5}, AspectRatio -> 1]
     = -Graphics-

    Use a decimal point to force numeric evaluation:
    >> 4.0 ^ (1/3)
     = 1.58740105196819947

    'Power' has default value 1 for its second argument:
    >> DefaultValues[Power]
     = {HoldPattern[Default[Power, 2]] :> 1}
    >> a /. x_ ^ n_. :> {x, n}
     = {a, 1}

    'Power' can be used with complex numbers:
    >> (1.5 + 1.0 I) ^ 3.5
     = -3.68294005782191823 + 6.9513926640285049 I
    >> (1.5 + 1.0 I) ^ (3.5 + 1.5 I)
     = -3.19181629045628082 + 0.645658509416156807 I

    #> 1/0
     : Infinite expression (division by zero) encountered.
     = ComplexInfinity
    #> Sqrt[-3+2. I]
     = 0.550250522700337511 + 1.81735402102397062 I
    #> Sqrt[-3+2 I]
     = Sqrt[-3 + 2 I]
    #> (3/2+1/2I)^2
     = 2 + 3 I / 2
    #> I ^ I
     = I ^ I

    #> 2 ^ 2.0
     = 4.

    #> Pi ^ 4.
     = 97.4090910340024374
    """

    operator = '^'
    precedence = 590
    attributes = ('Listable', 'NumericFunction', 'OneIdentity')
    grouping = 'Right'

    default_formats = False

    sympy_name = 'Pow'

    messages = {
        'infy': "Infinite expression (division by zero) encountered.",
    }

    defaults = {
        2: '1',
    }

    formats = {
        Expression('Power', Expression('Pattern', Symbol('x'),
                   Expression('Blank')), Rational(1, 2)): 'HoldForm[Sqrt[x]]',
        (('InputForm', 'OutputForm'), 'x_ ^ y_'): (
            'Infix[{HoldForm[x], HoldForm[y]}, "^", 590, Right]'),
        ('', 'x_ ^ y_'): (
            'PrecedenceForm[Superscript[OuterPrecedenceForm[HoldForm[x], 590],'
            '  HoldForm[y]], 590]'),

        ('', 'x_ ^ y_?Negative'): (
            'HoldForm[Divide[1, #]]&[If[y==-1, HoldForm[x], HoldForm[x]^-y]]'),
    }

    rules = {
    }

    def apply(self, items, evaluation):
        'Power[items__]'

        items_sequence = items.get_sequence()

        if len(items_sequence) == 2:
            x, y = items_sequence
        else:
            return Expression('Power', *items_sequence)

        if y.get_int_value() == 1:
            return x
        elif x.get_int_value() == 1:
            return x
        elif y.get_int_value() == 0:
            if x.get_int_value() == 0:
                evaluation.message('Power', 'indet', Expression('Power', x, y))
                return Symbol('Indeterminate')
            else:
                return Integer(1)

        elif x.has_form('Power', 2) and isinstance(y, Integer):
            return Expression('Power', x.leaves[0],
                              Expression('Times', x.leaves[1], y))
        elif x.has_form('Times', None) and isinstance(y, Integer):
            return Expression('Times', *[
                Expression('Power', leaf, y) for leaf in x.leaves])

        elif (isinstance(x, Number) and isinstance(y, Number)
              and not (x.is_inexact() or y.is_inexact())):

            sym_x, sym_y = x.to_sympy(), y.to_sympy()

            try:
                if sym_y >= 0:
                    result = sym_x ** sym_y
                else:
                    if sym_x == 0:
                        evaluation.message('Power', 'infy')
                        return Symbol('ComplexInfinity')
                    result = sympy.Integer(1) / (sym_x ** (-sym_y))
                if isinstance(result, sympy.Pow):
                    result = result.simplify()
                    args = [from_sympy(expr) for expr in result.as_base_exp()]
                    result = Expression('Power', *args)
                    result = result.evaluate_leaves(evaluation)
                    return result

                return from_sympy(result)
            except ValueError:
                return Expression('Power', x, y)
            except ZeroDivisionError:
                evaluation.message('Power', 'infy')
                return Symbol('ComplexInfinity')

        elif (isinstance(x, Number) and isinstance(y, Number)
              and (x.is_inexact() or y.is_inexact())):
            try:
                prec = min(max(x.get_precision(), 64), max(
                    y.get_precision(), 64))
                with mpmath.workprec(prec):
                    mp_x = sympy2mpmath(x.to_sympy())
                    mp_y = sympy2mpmath(y.to_sympy())
                    result = mp_x ** mp_y
                    if isinstance(result, mpmath.mpf):
                        return Real(str(result), prec)
                    elif isinstance(result, mpmath.mpc):
                        return Complex(str(result.real),
                                       str(result.imag), prec)
            except ZeroDivisionError:
                evaluation.message('Power', 'infy')
                return Symbol('ComplexInfinity')
        else:
            numerified_items = items.numerify(evaluation)
            return Expression('Power', *numerified_items.get_sequence())


class Sqrt(SympyFunction):
    """
    <dl>
    <dt>'Sqrt[$expr$]'
        <dd>returns the square root of $expr$.
    </dl>

    >> Sqrt[4]
     = 2
    >> Sqrt[5]
     = Sqrt[5]
    >> Sqrt[5] // N
     = 2.2360679774997897
    >> Sqrt[a]^2
     = a

    Complex numbers:
    >> Sqrt[-4]
     = 2 I
    >> I == Sqrt[-1]
     = True

    >> Plot[Sqrt[a^2], {a, -2, 2}]
     = -Graphics-
    """

    attributes = ('Listable', 'NumericFunction')

    rules = {
        'Sqrt[x_]': 'x ^ (1/2)',

        'MakeBoxes[Sqrt[x_], f:StandardForm|TraditionalForm]': (
            'SqrtBox[MakeBoxes[x, f]]'),
    }


class Infinity(SympyConstant):
    """
    <dl>
    <dt>'Infinity'
        <dd>represents an infinite real quantity.
    </dl>

    >> 1 / Infinity
     = 0
    >> Infinity + 100
     = Infinity

    Use 'Infinity' in sum and limit calculations:
    >> Sum[1/x^2, {x, 1, Infinity}]
     = Pi ^ 2 / 6

    #> FullForm[Infinity]
     = DirectedInfinity[1]
    #> (2 + 3.5*I) / Infinity
     = 0. + 0. I
    #> Infinity + Infinity
     = Infinity
    #> Infinity / Infinity
     : Indeterminate expression 0 Infinity encountered.
     = Indeterminate
    """

    sympy_name = 'oo'

    rules = {
        'Infinity': 'DirectedInfinity[1]',

        'MakeBoxes[Infinity, f:StandardForm|TraditionalForm]': (
            '"\\[Infinity]"'),
    }


class ComplexInfinity(SympyConstant):
    """
    <dl>
    <dt>'ComplexInfinity'
        <dd>represents an infinite complex quantity of undetermined direction.
    </dl>

    >> 1 / ComplexInfinity
     = 0
    >> ComplexInfinity + ComplexInfinity
     = ComplexInfinity
    >> ComplexInfinity * Infinity
     = ComplexInfinity
    >> FullForm[ComplexInfinity]
     = DirectedInfinity[]
    """

    sympy_name = 'ComplexInfinity'

    rules = {
        'ComplexInfinity': 'DirectedInfinity[]',
    }


class DirectedInfinity(SympyFunction):
    """
    <dl>
    <dt>'DirectedInfinity[$z$]'</dt>
        <dd>represents an infinite multiple of the complex number $z$.
    <dt>'DirectedInfinity[]'</dt>
        <dd>is the same as 'ComplexInfinity'.</dd>
    </dl>

    >> DirectedInfinity[1]
     = Infinity
    >> DirectedInfinity[]
     = ComplexInfinity
    >> DirectedInfinity[1 + I]
     = (1 / 2 + I / 2) Sqrt[2] Infinity

    >> 1 / DirectedInfinity[1 + I]
     = 0
    >> DirectedInfinity[1] + DirectedInfinity[-1]
     : Indeterminate expression -Infinity + Infinity encountered.
     = Indeterminate

    #> DirectedInfinity[1+I]+DirectedInfinity[2+I]
     = (2 / 5 + I / 5) Sqrt[5] Infinity + (1 / 2 + I / 2) Sqrt[2] Infinity

    #> DirectedInfinity[Sqrt[3]]
     = Infinity
    """

    rules = {
        'DirectedInfinity[args___] ^ -1': '0',
        '0 * DirectedInfinity[args___]': 'Message[Infinity::indet, Unevaluated[0 DirectedInfinity[args]]]; Indeterminate',
        'DirectedInfinity[a_?NumericQ] /; N[Abs[a]] != 1': 'DirectedInfinity[a / Abs[a]]',
        'DirectedInfinity[a_] * DirectedInfinity[b_]': 'DirectedInfinity[a*b]',
        'DirectedInfinity[] * DirectedInfinity[args___]': 'DirectedInfinity[]',
        'DirectedInfinity[0]': 'DirectedInfinity[]',
        'z_?NumberQ * DirectedInfinity[]': 'DirectedInfinity[]',
        'z_?NumberQ * DirectedInfinity[a_]': 'DirectedInfinity[z * a]',
        'DirectedInfinity[a_] + DirectedInfinity[b_] /; b == -a': (
            'Message[Infinity::indet,'
            '  Unevaluated[DirectedInfinity[a] + DirectedInfinity[b]]];'
            'Indeterminate'),
        'DirectedInfinity[args___] + _?NumberQ': 'DirectedInfinity[args]',
    }

    formats = {
        'DirectedInfinity[1]': 'HoldForm[Infinity]',
        'DirectedInfinity[-1]': 'HoldForm[-Infinity]',
        'DirectedInfinity[]': 'HoldForm[ComplexInfinity]',
        'DirectedInfinity[z_?NumericQ]': 'HoldForm[z Infinity]',
    }

    def to_sympy(self, expr, **kwargs):
        if len(expr.leaves) == 1:
            dir = expr.leaves[0].get_int_value()
            if dir == 1:
                return sympy.oo
            elif dir == -1:
                return -sympy.oo


class Re(SympyFunction):
    """
    <dl>
    <dt>'Re[$z$]'
        <dd>returns the real component of the complex number $z$.
    </dl>

    >> Re[3+4I]
     = 3

    >> Plot[{Cos[a], Re[E^(I a)]}, {a, 0, 2 Pi}]
     = -Graphics-
    """

    attributes = ('Listable', 'NumericFunction')

    def apply_complex(self, number, evaluation):
        'Re[number_Complex]'

        real, imag = number.to_sympy().as_real_imag()
        return Number.from_mp(real)

    def apply_number(self, number, evaluation):
        'Re[number_?NumberQ]'

        return number


class Im(SympyFunction):
    """
    <dl>
    <dt>'Im[$z$]'
        <dd>returns the imaginary component of the complex number $z$.
    </dl>

    >> Im[3+4I]
     = 4

    >> Plot[{Sin[a], Im[E^(I a)]}, {a, 0, 2 Pi}]
     = -Graphics-
    """

    attributes = ('Listable', 'NumericFunction')

    def apply_complex(self, number, evaluation):
        'Im[number_Complex]'

        real, imag = number.to_sympy().as_real_imag()
        return Number.from_mp(imag)

    def apply_number(self, number, evaluation):
        'Im[number_?NumberQ]'

        return Integer(0)


class Abs(_MPMathFunction):
    """
    <dl>
    <dt>'Abs[$x$]'
        <dd>returns the absolute value of $x$.
    </dl>
    >> Abs[-3]
     = 3

    'Abs' returns the magnitude of complex numbers:
    >> Abs[3 + I]
     = Sqrt[10]
    >> Abs[3.0 + I]
     = 3.16227766016837933
    >> Plot[Abs[x], {x, -4, 4}]
     = -Graphics-

    #> Abs[I]
     = 1
    #> Abs[a - b]
     = Abs[a - b]

    #> Abs[Sqrt[3]]
     = Sqrt[3]
    """

    sympy_name = 'Abs'
    mpmath_name = 'fabs'  # mpmath actually uses python abs(x) / x.__abs__()


class I(Predefined):
    """
    <dl>
    <dt>'I'
        <dd>represents the imaginary number 'Sqrt[-1]'.
    </dl>

    >> I^2
     = -1
    >> (3+I)*(3-I)
     = 10
    """

    def evaluate(self, evaluation):
        return Complex(sympy.Integer(0), sympy.Integer(1))


class NumberQ(Test):
    """
    <dl>
    <dt>'NumberQ[$expr$]'
        <dd>returns 'True' if $expr$ is an explicit number, and 'False' otherwise.
    </dl>

    >> NumberQ[3+I]
     = True
    >> NumberQ[5!]
     = True
    >> NumberQ[Pi]
     = False
    """

    def test(self, expr):
        return isinstance(expr, Number)


class RealNumberQ(Test):
    """
    <dl>
    <dt>'RealNumberQ[$expr$]'
        <dd>returns 'True' if $expr$ is an explicit number with no imaginary component.
    </dl>

    >> RealNumberQ[10]
     = True
    >> RealNumberQ[4.0]
     = True
    >> RealNumberQ[1+I]
     = False
    >> RealNumberQ[0 * I]
     = True
    >> RealNumberQ[0.0 * I]
     = False
    """

    def test(self, expr):
        return isinstance(expr, (Integer, Rational, Real))


class ExactNumberQ(Test):
    """
    <dl>
    <dt>'ExactNumberQ[$expr$]'
        <dd>returns 'True' if $expr$ is an exact number, and 'False' otherwise.
    </dl>

    >> ExactNumberQ[10]
     = True
    >> ExactNumberQ[4.0]
     = False
    >> ExactNumberQ[n]
     = False

    'ExactNumberQ' can be applied to complex numbers:
    >> ExactNumberQ[1 + I]
     = True
    >> ExactNumberQ[1 + 1. I]
     = False
    """

    def test(self, expr):
        return isinstance(expr, Number) and not expr.is_inexact()


class InexactNumberQ(Test):
    """
    <dl>
    <dt>'InexactNumberQ[$expr$]'
        <dd>returns 'True' if $expr$ is not an exact number, and 'False' otherwise.
    </dl>

    >> InexactNumberQ[a]
     = False
    >> InexactNumberQ[3.0]
     = True
    >> InexactNumberQ[2/3]
     = False

    'InexactNumberQ' can be applied to complex numbers:
    >> InexactNumberQ[4.0+I]
     = True
    """

    def test(self, expr):
        return isinstance(expr, Number) and expr.is_inexact()


class IntegerQ(Test):
    """
    <dl>
    <dt>'IntegerQ[$expr$]'
        <dd>returns 'True' if $expr$ is an integer, and 'False' otherwise.
    </dl>

    >> IntegerQ[3]
     = True
    >> IntegerQ[Pi]
     = False
    """

    def test(self, expr):
        return isinstance(expr, Integer)


class Integer_(Builtin):
    """
    <dl>
    <dt>'Integer'
        <dd>is the head of integers.
    </dl>

    >> Head[5]
     = Integer

    ## Test large Integer comparison bug
    #> {a, b} = {2^10000, 2^10000 + 1}; {a == b, a < b, a <= b}
     = {False, True, True}
    """

    name = 'Integer'


class Real_(Builtin):
    u"""
    <dl>
    <dt>'Real'
        <dd>is the head of real (inexact) numbers.
    </dl>

    >> x = 3. ^ -20;
    >> InputForm[x]
     = 2.86797199079244131*^-10
    >> Head[x]
     = Real

    ## Formatting tests
    #> 1. * 10^6
     = 1.*^6
    #> 1. * 10^5
     = 100000.
    #> -1. * 10^6
     = -1.*^6
    #> -1. * 10^5
     = -100000.
    #> 1. * 10^-6
     = 1.*^-6
    #> 1. * 10^-5
     = 0.00001
    #> -1. * 10^-6
     = -1.*^-6
    #> -1. * 10^-5
     = -0.00001

    ## Mathematica treats zero strangely
    #> 0.0000000000000
     = 0.
    #> 0.0000000000000000000000000000
     = 0.*^-28

    ## Parse *^ Notation
    #> 1.5*^24
     = 1.5*^24
    #> 1.5*^+24
     = 1.5*^24
    #> 1.5*^-24
     = 1.5*^-24

    ## Don't accept *^ with spaces
    #> 1.5 *^10
     : Parse error at or near token ^.
    #> 1.5*^ 10
     : Parse error at or near token ^.
    """

    name = 'Real'


class Rational_(Builtin):
    """
    <dl>
    <dt>'Rational'</dt>
        <dd>is the head of rational numbers.</dd>
    <dt>'Rational[$a$, $b$]'</dt>
        <dd>constructs the rational number a / b.</dd>
    </dl>

    >> Head[1/2]
     = Rational

    >> Rational[1, 2]
     = 1 / 2

    #> -2/3
     = -2 / 3
    """

    name = 'Rational'

    def apply(self, n, m, evaluation):
        'Rational[n_Integer, m_Integer]'

        if m.to_sympy() == 1:
            return Integer(n.to_sympy())
        else:
            return Rational(n.to_sympy(), m.to_sympy())


class Complex_(Builtin):
    """
    <dl>
    <dt>'Complex'
        <dd>is the head of complex numbers.
    <dt>'Complex[$a$, $b$]'
        <dd>constructs the complex number '$a$ + I $b$'.
    </dl>

    >> Head[2 + 3*I]
     = Complex
    >> Complex[1, 2/3]
     = 1 + 2 I / 3
    >> Abs[Complex[3, 4]]
     = 5

    #> OutputForm[Complex[2.0 ^ 40, 3]]
     = 1.099511627776*^12 + 3. I
    #> InputForm[Complex[2.0 ^ 40, 3]]
     = 1.099511627776*^12 + 3.*I

    #> -2 / 3 - I
     = -2 / 3 - I

    #> Complex[10, 0]
     = 10

    #> 0. + I
     = 0. + 1. I

    #> 1 + 0 I
     = 1
    #> Head[%]
     = Integer

    #> Complex[0.0, 0.0]
     = 0. + 0. I
    #> 0. I
     = 0. + 0. I
    #> 0. + 0. I
     = 0. + 0. I

    #> 1. + 0. I
     = 1. + 0. I
    #> 0. + 1. I
     = 0. + 1. I

    ## Check Nesting Complex
    #> Complex[1, Complex[0, 1]]
     = 0
    #> Complex[1, Complex[1, 0]]
     = 1 + I
    #> Complex[1, Complex[1, 1]]
     = I
    """

    name = 'Complex'

    def apply(self, r, i, evaluation):
        'Complex[r_?NumberQ, i_?NumberQ]'

        if isinstance(r, Complex) or isinstance(i, Complex):
            sym_form = r.to_sympy() + sympy.I * i.to_sympy()
            sym_r, sym_i = sym_form.simplify().as_real_imag()
        else:
            sym_r, sym_i = r.to_sympy(), i.to_sympy()

        if isinstance(sym_i, sympy.Integer) and sym_i == 0:
            return Number.from_mp(sym_r)
        else:
            return Complex(sym_r, sym_i)


class Factorial(PostfixOperator, _MPMathFunction):
    """
    <dl>
    <dt>'Factorial[$n$]'</dt>
    <dt>'$n$!'</dt>
        <dd>computes the factorial of $n$.
    </dl>

    >> 20!
     = 2432902008176640000

    'Factorial' handles numeric (real and complex) values using the gamma function:
    >> 10.5!
     = 1.18994230839622485*^7
    >> (-3.0+1.5*I)!
     = 0.0427943437183768611 - 0.00461565252860394996 I

    However, the value at poles is 'ComplexInfinity':
    >> (-1.)!
     = ComplexInfinity

    'Factorial' has the same operator ('!') as 'Not', but with higher precedence:
    >> !a! //FullForm
     = Not[Factorial[a]]

    #> 0!
     = 1
    """

    operator = '!'
    precedence = 610

    def apply_int(self, n, evaluation):
        'Factorial[n_Integer]'

        n = n.to_sympy()
        if n < 0:
            return Symbol('ComplexInfinity')
        else:
            return Integer(sympy.factorial(n))

    def eval(self, z):
        return mpmath.factorial(z)


class Gamma(SympyFunction):
    """
    <dl>
    <dt>'Gamma[$z$]'
        <dd>is the Gamma function on the complex number $z$.
    </dl>

    >> Gamma[8]
     = 5040
    >> Gamma[1. + I]
     = 0.498015668118356043 - 0.154949828301810685 I

    Both 'Gamma' and 'Factorial' functions are continuous:
    >> Plot[{Gamma[x], x!}, {x, 0, 4}]
     = -Graphics-
    """

    # TODO implement the incomplete Gamma functions

    rules = {
        'Gamma[x_]': '(x - 1)!',
    }


class Pochhammer(SympyFunction):
    """
    <dl>
    <dt>'Pochhammer[$a$, $n$]'
        <dd>is the Pochhammer symbol (a)_n.
    </dl>

    >> Pochhammer[4, 8]
     = 6652800
    """

    sympy_name = 'RisingFactorial'

    rules = {
        'Pochhammer[a_, n_]': 'Gamma[a + n] / Gamma[a]',
    }


class HarmonicNumber(_MPMathFunction):
    """
    <dl>
    <dt>'HarmonicNumber[n]'
      <dd>returns the $n$th harmonic number.
    </dl>

    >> Table[HarmonicNumber[n], {n, 8}]
     = {1, 3 / 2, 11 / 6, 25 / 12, 137 / 60, 49 / 20, 363 / 140, 761 / 280}

    >> HarmonicNumber[3.8]
     =  2.0380634056306492

    #> HarmonicNumber[-1.5]
     = 0.613705638880109381
    """

    rules = {
        'HarmonicNumber[-1]': 'ComplexInfinity',
    }

    sympy_name = 'harmonic'
    mpmath_name = 'harmonic'


class Sum(_IterationFunction, SympyFunction):
    """
    <dl>
    <dt>'Sum[$expr$, {$i$, $imin$, $imax$}]'
        <dd>evaluates the discrete sum of $expr$ with $i$ ranging from $imin$ to $imax$.
    <dt>'Sum[$expr$, {$i$, $imax$}]'
        <dd>same as 'Sum[$expr$, {$i$, 1, $imax$}]'.
    <dt>'Sum[$expr$, {$i$, $imin$, $imax$, $di$}]'
        <dd>$i$ ranges from $imin$ to $imax$ in steps of $di$.
    <dt>'Sum[$expr$, {$i$, $imin$, $imax$}, {$j$, $jmin$, $jmax$}, ...]'
        <dd>evaluates $expr$ as a multiple sum, with {$i$, ...}, {$j$, ...}, ... being in outermost-to-innermost order.
    </dl>
    >> Sum[k, {k, 1, 10}]
     = 55

    Double sum:
    >> Sum[i * j, {i, 1, 10}, {j, 1, 10}]
     = 3025

    Symbolic sums are evaluated:
    >> Sum[k, {k, 1, n}]
     = n (1 + n) / 2
    >> Sum[k, {k, n, 2 n}]
     = 3 n (1 + n) / 2
    >> Sum[k, {k, I, I + 1}]
     = 1 + 2 I
    >> Sum[1 / k ^ 2, {k, 1, n}]
     = HarmonicNumber[n, 2]

    Verify algebraic identities:
    >> Sum[x ^ 2, {x, 1, y}] - y * (y + 1) * (2 * y + 1) / 6
     = 0

    >> (-1 + a^n) Sum[a^(k n), {k, 0, m-1}] // Simplify
     = Piecewise[{{m, a ^ n == 1}, {(1 - (a ^ n) ^ m) / (1 - a ^ n), True}}] (-1 + a ^ n)

    Infinite sums:
    >> Sum[1 / 2 ^ i, {i, 1, Infinity}]
     = 1
    >> Sum[1 / k ^ 2, {k, 1, Infinity}]
     = Pi ^ 2 / 6

    #> a=Sum[x^k*Sum[y^l,{l,0,4}],{k,0,4}]]
     : Parse error at or near token ].
    """

    # Do not throw warning message for symbolic iteration bounds
    throw_iterb = False

    sympy_name = 'Sum'

    rules = _IterationFunction.rules.copy()
    rules.update({
        'MakeBoxes[Sum[f_, {i_, a_, b_, 1}],'
        '  form:StandardForm|TraditionalForm]': (
            r'RowBox[{SubsuperscriptBox["\[Sum]",'
            r'  RowBox[{MakeBoxes[i, form], "=", MakeBoxes[a, form]}],'
            r'  MakeBoxes[b, form]], MakeBoxes[f, form]}]'),
    })

    def get_result(self, items):
        return Expression('Plus', *items)

    def to_sympy(self, expr, **kwargs):
        if expr.has_form('Sum', 2) and expr.leaves[1].has_form('List', 3):
            index = expr.leaves[1]
            result = sympy.summation(expr.leaves[0].to_sympy(), (
                index.leaves[0].to_sympy(), index.leaves[1].to_sympy(),
                index.leaves[2].to_sympy()))
            return result


class Product(_IterationFunction, SympyFunction):
    """
    <dl>
    <dt>'Product[$expr$, {$i$, $imin$, $imax$}]'
        <dd>evaluates the discrete product of $expr$ with $i$ ranging from $imin$ to $imax$.
    <dt>'Product[$expr$, {$i$, $imax$}]'
        <dd>same as 'Product[$expr$, {$i$, 1, $imax$}]'.
    <dt>'Product[$expr$, {$i$, $imin$, $imax$, $di$}]'
        <dd>$i$ ranges from $imin$ to $imax$ in steps of $di$.
    <dt>'Product[$expr$, {$i$, $imin$, $imax$}, {$j$, $jmin$, $jmax$}, ...]'
        <dd>evaluates $expr$ as a multiple product, with {$i$, ...}, {$j$, ...}, ... being in outermost-to-innermost order.
    </dl>

    >> Product[k, {k, 1, 10}]
     = 3628800
    >> 10!
     = 3628800
    >> Product[x^k, {k, 2, 20, 2}]
     = x ^ 110
    >> Product[2 ^ i, {i, 1, n}]
     = 2 ^ (n / 2 + n ^ 2 / 2)

    Symbolic products involving the factorial are evaluated:
    >> Product[k, {k, 3, n}]
     = n! / 2

    Evaluate the $n$th primorial:
    >> primorial[0] = 1;
    >> primorial[n_Integer] := Product[Prime[k], {k, 1, n}];
    >> primorial[12]
     = 7420738134810

    ## Used to be a bug in sympy, but now it is solved exactly!
    #> Product[1 + 1 / i ^ 2, {i, Infinity}]
     = 1 / ((-I)! I!)
    """

    throw_iterb = False

    sympy_name = 'Product'

    rules = _IterationFunction.rules.copy()
    rules.update({
        'MakeBoxes[Product[f_, {i_, a_, b_, 1}],'
        '  form:StandardForm|TraditionalForm]': (
            r'RowBox[{SubsuperscriptBox["\[Product]",'
            r'  RowBox[{MakeBoxes[i, form], "=", MakeBoxes[a, form]}],'
            r'  MakeBoxes[b, form]], MakeBoxes[f, form]}]'),
    })

    def get_result(self, items):
        return Expression('Times', *items)

    def to_sympy(self, expr, **kwargs):
        if expr.has_form('Product', 2) and expr.leaves[1].has_form('List', 3):
            index = expr.leaves[1]
            try:
                return sympy.product(expr.leaves[0].to_sympy(), (
                    index.leaves[0].to_sympy(), index.leaves[1].to_sympy(),
                    index.leaves[2].to_sympy()))
            except ZeroDivisionError:
                pass


# TODO: Proper symbolic computation
class Piecewise(SympyFunction):
    """
    <dl>
    <dt>'Picewise[{{expr1, cond1}, ...}]'
      <dd>represents a piecewise function.
    <dt>'Picewise[{{expr1, cond1}, ...}, expr]'
      <dd>represents a piecewise function with default 'expr'.
    </dl>

    Heaviside function
    >> Piecewise[{{0, x <= 0}}, 1]
     = Piecewise[{{0, x <= 0}}, 1]
    """

    # TODO
    """
    #> D[%, x]
    """

    sympy_name = 'Piecewise'

    def prepare_sympy(self, leaves):
        if len(leaves) == 1:
            return leaves[0]
        if len(leaves) == 2:
            return leaves[0].leaves + [
                Expression('List', leaves[1], Symbol('True'))]

    def from_sympy(self, args):
        # Hack to get around weird sympy.Piecewise 'otherwise' behaviour
        if str(args[-1].leaves[1]).startswith('_True__Dummy_'):
            args[-1].leaves[1] = Symbol('True')
        return [args]

########NEW FILE########
__FILENAME__ = assignment
# -*- coding: utf8 -*-

from mathics.builtin.base import (
    Builtin, BinaryOperator, PostfixOperator, PrefixOperator)
from mathics.core.expression import Expression, Symbol
from mathics.core.rules import Rule
from mathics.builtin.lists import walk_parts
from mathics.builtin.evaluation import set_recursionlimit

from mathics import settings


def get_symbol_list(list, error_callback):
    if list.has_form('List', None):
        list = list.leaves
    else:
        list = [list]
    values = []
    for item in list:
        name = item.get_name()
        if name:
            values.append(name)
        else:
            error_callback(item)
            return None
    return values


class _SetOperator(object):
    def assign_elementary(self, lhs, rhs, evaluation, tags=None, upset=False):
        name = lhs.get_head_name()

        if name in ('OwnValues', 'DownValues', 'SubValues', 'UpValues',
                    'NValues', 'Options', 'DefaultValues', 'Attributes',
                    'Messages'):
            if len(lhs.leaves) != 1:
                evaluation.message_args(name, len(lhs.leaves), 1)
                return False
            tag = lhs.leaves[0].get_name()
            if not tag:
                evaluation.message(name, 'sym', lhs.leaves[0], 1)
                return False
            if tags is not None and tags != [tag]:
                evaluation.message(name, 'tag', name, tag)
                return False

            if (name != 'Attributes' and 'Protected'    # noqa
                in evaluation.definitions.get_attributes(tag)):
                evaluation.message(name, 'wrsym', tag)
                return False
            if name == 'Options':
                option_values = rhs.get_option_values(evaluation)
                if option_values is None:
                    evaluation.message(name, 'options', rhs)
                    return False
                evaluation.definitions.set_options(tag, option_values)
            elif name == 'Attributes':
                attributes = get_symbol_list(
                    rhs, lambda item: evaluation.message(name, 'sym', item, 1))
                if attributes is None:
                    return False
                if 'Locked' in evaluation.definitions.get_attributes(tag):
                    evaluation.message(name, 'locked', tag)
                    return False
                evaluation.definitions.set_attributes(tag, attributes)
            else:
                rules = rhs.get_rules_list()
                if rules is None:
                    evaluation.message(name, 'vrule', lhs, rhs)
                    return False
                evaluation.definitions.set_values(tag, name, rules)
            return True

        form = ''
        nprec = None
        default = False
        message = False

        allow_custom_tag = False

        focus = lhs

        if name == 'N':
            if len(lhs.leaves) not in (1, 2):
                evaluation.message_args('N', len(lhs.leaves), 1, 2)
                return False
            if len(lhs.leaves) == 1:
                nprec = Symbol('MachinePrecision')
            else:
                nprec = lhs.leaves[1]
            focus = lhs.leaves[0]
            lhs = Expression('N', focus, nprec)
        elif name == 'MessageName':
            if len(lhs.leaves) != 2:
                evaluation.message_args('MessageName', len(lhs.leaves), 2)
                return False
            focus = lhs.leaves[0]
            message = True
        elif name == 'Default':
            if len(lhs.leaves) not in (1, 2, 3):
                evaluation.message_args('Default', len(lhs.leaves), 1, 2, 3)
                return False
            focus = lhs.leaves[0]
            default = True
        elif name == 'Format':
            if len(lhs.leaves) not in (1, 2):
                evaluation.message_args('Format', len(lhs.leaves), 1, 2)
                return False
            if len(lhs.leaves) == 2:
                form = lhs.leaves[1].get_name()
                if not form:
                    evaluation.message('Format', 'fttp', lhs.leaves[1])
                    return False
            else:
                form = ('StandardForm', 'TraditionalForm', 'OutputForm',
                        'TeXForm', 'MathMLForm',
                        )
            lhs = focus = lhs.leaves[0]
        else:
            allow_custom_tag = True

        focus = focus.evaluate_leaves(evaluation)

        if tags is None and not upset:
            name = focus.get_lookup_name()
            if not name:
                evaluation.message(self.get_name(), 'setraw', focus)
                return False
            tags = [name]
        elif upset:
            if allow_custom_tag:
                tags = []
                if focus.is_atom():
                    evaluation.message(self.get_name(), 'normal')
                    return False
                for leaf in focus.leaves:
                    name = leaf.get_lookup_name()
                    tags.append(name)
            else:
                tags = [focus.get_lookup_name()]
        else:
            allowed_names = [focus.get_lookup_name()]
            if allow_custom_tag:
                for leaf in focus.get_leaves():
                    allowed_names.append(leaf.get_lookup_name())
            for name in tags:
                if name not in allowed_names:
                    evaluation.message(self.get_name(), 'tagnfd', name)
                    return False

        ignore_protection = False
        rhs_int_value = rhs.get_int_value()
        lhs_name = lhs.get_name()
        if lhs_name == '$RecursionLimit':
            # if (not rhs_int_value or rhs_int_value < 20) and not
            # rhs.get_name() == 'Infinity':
            if (not rhs_int_value or rhs_int_value < 20  # noqa
                or rhs_int_value > settings.MAX_RECURSION_DEPTH):

                evaluation.message('$RecursionLimit', 'limset', rhs)
                return False
            try:
                set_recursionlimit(rhs_int_value)
            except OverflowError:
                # TODO: Message
                return False
            ignore_protection = True
        elif lhs_name == '$ModuleNumber':
            if not rhs_int_value or rhs_int_value <= 0:
                evaluation.message('$ModuleNumber', 'set', rhs)
                return False
            ignore_protection = True
        elif lhs_name in ('$Line', '$HistoryLength'):
            if rhs_int_value is None or rhs_int_value < 0:
                evaluation.message(lhs_name, 'intnn', rhs)
                return False
            ignore_protection = True
        elif lhs_name == '$RandomState':
            # TODO: allow setting of legal random states!
            # (but consider pickle's insecurity!)
            evaluation.message('$RandomState', 'rndst', rhs)
            return False

        rhs_name = rhs.get_head_name()
        if rhs_name == 'Condition':
            if len(rhs.leaves) != 2:
                evaluation.message_args('Condition', len(rhs.leaves), 2)
                return False
            else:
                lhs = Expression('Condition', lhs, rhs.leaves[1])
                rhs = rhs.leaves[0]

        rule = Rule(lhs, rhs)
        count = 0
        defs = evaluation.definitions
        for tag in tags:
            if (not ignore_protection and 'Protected'   # noqa
                in evaluation.definitions.get_attributes(tag)):
                if lhs.get_name() == tag:
                    evaluation.message(self.get_name(), 'wrsym', tag)
                else:
                    evaluation.message(self.get_name(), 'write', tag, lhs)
                continue
            count += 1
            if form:
                defs.add_format(tag, rule, form)
            elif nprec:
                defs.add_nvalue(tag, rule)
            elif default:
                defs.add_default(tag, rule)
            elif message:
                defs.add_message(tag, rule)
            else:
                if upset:
                    defs.add_rule(tag, rule, position='up')
                else:
                    defs.add_rule(tag, rule)
        if count == 0:
            return False

        return True

    def assign(self, lhs, rhs, evaluation):
        if lhs.get_head_name() == 'List':
            if (not (rhs.get_head_name() == 'List')     # noqa
                or len(lhs.leaves) != len(rhs.leaves)):

                evaluation.message(self.get_name(), 'shape', lhs, rhs)
                return False
            else:
                result = True
                for left, right in zip(lhs.leaves, rhs.leaves):
                    if not self.assign(left, right, evaluation):
                        result = False
                return result
        elif lhs.get_head_name() == 'Part':
            if len(lhs.leaves) < 1:
                evaluation.message(self.get_name(), 'setp', lhs)
                return False
            symbol = lhs.leaves[0]
            name = symbol.get_name()
            if not name:
                evaluation.message(self.get_name(), 'setps', symbol)
                return False
            if 'Protected' in evaluation.definitions.get_attributes(name):
                evaluation.message(self.get_name(), 'wrsym', name)
                return False
            rule = evaluation.definitions.get_ownvalue(name)
            if rule is None:
                evaluation.message(self.get_name(), 'noval', symbol)
                return False
            indices = lhs.leaves[1:]
            result = walk_parts([rule.replace], indices, evaluation, rhs)
            if result:
                evaluation.definitions.set_ownvalue(name, result)
            else:
                return False
        else:
            return self.assign_elementary(lhs, rhs, evaluation)


class Set(BinaryOperator, _SetOperator):
    """
    >> a = 3
     = 3
    >> a
     = 3
    >> f[x_] = x^2
     = x ^ 2
    >> f[10]
     = 100

    You can set multiple values at once using lists:
    >> {a, b, c} = {10, 2, 3}
     = {10, 2, 3}
    >> {a, b, {c, {d}}} = {1, 2, {{c1, c2}, {a}}}
     = {1, 2, {{c1, c2}, {10}}}
    >> d
     = 10

    'Set' evaluates its right-hand side immediately and assigns it to the left-hand side:
    >> a
     = 1
    >> x = a
     = 1
    >> a = 2
     = 2
    >> x
     = 1

    'Set' always returns the right-hand side, which you can again use in an assignment:
    >> a = b = c = 2;
    >> a == b == c == 2
     = True

    'Set' supports assignments to parts:
    >> A = {{1, 2}, {3, 4}};
    >> A[[1, 2]] = 5
     = 5
    >> A
     = {{1, 5}, {3, 4}}
    >> A[[;;, 2]] = {6, 7}
     = {6, 7}
    >> A
     = {{1, 6}, {3, 7}}
    Set a submatrix:
    >> B = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    >> B[[1;;2, 2;;-1]] = {{t, u}, {y, z}};
    >> B
     = {{1, t, u}, {4, y, z}, {7, 8, 9}}
    """

    operator = '='
    precedence = 40
    grouping = 'Right'
    attributes = ('HoldFirst', 'SequenceHold')

    messages = {
        'setraw': "Cannot assign to raw object `1`.",
        'shape': "Lists `1` and `2` are not the same shape.",
    }

    def apply(self, lhs, rhs, evaluation):
        'lhs_ = rhs_'

        self.assign(lhs, rhs, evaluation)
        return rhs


class SetDelayed(Set):
    """
    'SetDelayed' has attribute 'HoldAll', thus it does not evaluate the right-hand side immediately,
    but evaluates it when needed.
    >> Attributes[SetDelayed]
     = {HoldAll, Protected, SequenceHold}
    >> a = 1
     = 1
    >> x := a
    >> a = 2
     = 2
    >> x
     = 2

    'Condition' can be used to make a conditioned assignment:
    >> f[x_] := p[x] /; x>0
    >> f[3]
     = p[3]
    >> f[-3]
     = f[-3]
    """

    operator = ':='
    attributes = ('HoldAll', 'SequenceHold')

    def apply(self, lhs, rhs, evaluation):
        'lhs_ := rhs_'

        if self.assign(lhs, rhs, evaluation):
            return Symbol('Null')
        else:
            return Symbol('$Failed')


class UpSet(BinaryOperator, _SetOperator):
    """
    >> a[b] ^= 3;
    >> DownValues[a]
     = {}
    >> UpValues[b]
     = {HoldPattern[a[b]] :> 3}

    >> a ^= 3
     : Nonatomic expression expected.
     = 3

    You can use 'UpSet' to specify special values like format values.
    However, these values will not be saved in 'UpValues':
    >> Format[r] ^= "custom";
    >> r
     = custom
    >> UpValues[r]
     = {}

    #> f[g, a + b, h] ^= 2
     : Tag Plus in f[g, a + b, h] is Protected.
     = 2
    #> UpValues[h]
     = {HoldPattern[f[g, a + b, h]] :> 2}
    """

    operator = '^='
    precedence = 40
    attributes = ('HoldFirst', 'SequenceHold')
    grouping = 'Right'

    def apply(self, lhs, rhs, evaluation):
        'lhs_ ^= rhs_'

        self.assign_elementary(lhs, rhs, evaluation, upset=True)
        return rhs


class UpSetDelayed(UpSet):
    """
    >> a[b] ^:= x
    >> x = 2;
    >> a[b]
     = 2
    >> UpValues[b]
     = {HoldPattern[a[b]] :> x}

    #> f[g, a + b, h] ^:= 2
     : Tag Plus in f[g, a + b, h] is Protected.
    #> f[a+b] ^:= 2
     : Tag Plus in f[a + b] is Protected.
     = $Failed
    """

    operator = '^:='
    attributes = ('HoldAll', 'SequenceHold')

    def apply(self, lhs, rhs, evaluation):
        'lhs_ ^:= rhs_'

        if self.assign_elementary(lhs, rhs, evaluation, upset=True):
            return Symbol('Null')
        else:
            return Symbol('$Failed')


class TagSet(Builtin, _SetOperator):
    """
    <dl>
    <dt>'TagSet[$f$, $lhs$, $rhs$]' or 'f /: lhs = rhs'</dt>
        <dd>sets $lhs$ to be $rhs$ and assigns the corresonding rule to the symbol $f$.
    </dl>

    >> x /: f[x] = 2
     = 2
    >> f[x]
     = 2
    >> DownValues[f]
     = {}
    >> UpValues[x]
     = {HoldPattern[f[x]] :> 2}

    The symbol $f$ must appear as the ultimate head of $lhs$ or as the head of a leaf in $lhs$:
    >> x /: f[g[x]] = 3;
     : Tag x not found or too deep for an assigned rule.
    >> g /: f[g[x]] = 3;
    >> f[g[x]]
     = 3
    """

    attributes = ('HoldAll', 'SequenceHold')

    messages = {
        'tagnfd': "Tag `1` not found or too deep for an assigned rule.",
    }

    def apply(self, f, lhs, rhs, evaluation):
        'f_ /: lhs_ = rhs_'

        name = f.get_name()
        if not name:
            evaluation.message(self.get_name(), 'sym', f, 1)
            return

        rhs = rhs.evaluate(evaluation)
        self.assign_elementary(lhs, rhs, evaluation, tags=[name])
        return rhs


class TagSetDelayed(TagSet):
    """
    <dl>
    <dt>'TagSetDelayed[$f$, $lhs$, $rhs$]' or 'f /: lhs := rhs'
        <dd>is the delayed version of 'TagSet'.
    </dl>
    """

    attributes = ('HoldAll', 'SequenceHold')

    def apply(self, f, lhs, rhs, evaluation):
        'f_ /: lhs_ := rhs_'

        name = f.get_name()
        if not name:
            evaluation.message(self.get_name(), 'sym', f, 1)
            return

        rhs = rhs.evaluate(evaluation)
        if self.assign_elementary(lhs, rhs, evaluation, tags=[name]):
            return Symbol('Null')
        else:
            return Symbol('$Failed')


class Definition(Builtin):
    """
    <dl>
    <dt>'Definition[$symbol$]'
        <dd>prints as the user-defined values and rules associated with $symbol$.
    </dl>

    'Definition' does not print information for 'ReadProtected' symbols.
    'Definition' uses 'InputForm' to format values.

    >> a = 2;
    >> Definition[a]
     = a = 2

    >> f[x_] := x ^ 2
    >> g[f] ^:= 2
    >> Definition[f]
     = f[x_] = x ^ 2
     .
     . g[f] ^= 2

    Definition of a rather evolved (though meaningless) symbol:
    >> Attributes[r] := {Orderless}
    >> Format[r[args___]] := Infix[{args}, "~"]
    >> N[r] := 3.5
    >> Default[r, 1] := 2
    >> r::msg := "My message"
    >> Options[r] := {Opt -> 3}
    >> r[arg_., OptionsPattern[r]] := {arg, OptionValue[Opt]}

    Some usage:
    >> r[z, x, y]
     = x ~ y ~ z
    >> N[r]
     = 3.5
    >> r[]
     = {2, 3}
    >> r[5, Opt->7]
     = {5, 7}

    Its definition:
    >> Definition[r]
     = Attributes[r] = {Orderless}
     .
     . arg_. ~ OptionsPattern[r] = {arg, OptionValue[Opt]}
     .
     . N[r, MachinePrecision] = 3.5
     .
     . Format[args___, MathMLForm] = Infix[{args}, "~"]
     .
     . Format[args___, OutputForm] = Infix[{args}, "~"]
     .
     . Format[args___, StandardForm] = Infix[{args}, "~"]
     .
     . Format[args___, TeXForm] = Infix[{args}, "~"]
     .
     . Format[args___, TraditionalForm] = Infix[{args}, "~"]
     .
     . Default[r, 1] = 2
     .
     . Options[r] = {Opt -> 3}

    For 'ReadProtected' symbols, 'Definition' just prints attributes, default values and options:
    >> SetAttributes[r, ReadProtected]
    >> Definition[r]
     = Attributes[r] = {Orderless, ReadProtected}
     .
     . Default[r, 1] = 2
     .
     . Options[r] = {Opt -> 3}
    This is the same for built-in symbols:
    >> Definition[Plus]
     = Attributes[Plus] = {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}
     .
     . Default[Plus] = 0
    >> Definition[Level]
     = Attributes[Level] = {Protected}
     .
     . Options[Level] = {Heads -> False}

    'ReadProtected' can be removed, unless the symbol is locked:
    >> ClearAttributes[r, ReadProtected]
    'Clear' clears values:
    >> Clear[r]
    >> Definition[r]
     = Attributes[r] = {Orderless}
     .
     . Default[r, 1] = 2
     .
     . Options[r] = {Opt -> 3}
    'ClearAll' clears everything:
    >> ClearAll[r]
    >> Definition[r]
     = Null

    If a symbol is not defined at all, 'Null' is printed:
    >> Definition[x]
     = Null
    """

    attributes = ('HoldAll',)

    def format_definition(self, symbol, evaluation, grid=True):
        'StandardForm,TraditionalForm,OutputForm: Definition[symbol_]'

        lines = []

        def print_rule(rule, up=False, lhs=lambda l: l, rhs=lambda r: r):
            evaluation.check_stopped()
            if isinstance(rule, Rule):
                r = rhs(rule.replace.replace_vars({'Definition': Expression(
                    'HoldForm', Symbol('Definition'))}))
                lines.append(Expression('HoldForm', Expression(
                    up and 'UpSet' or 'Set', lhs(rule.pattern.expr), r)))

        name = symbol.get_name()
        if not name:
            evaluation.message('Definition', 'sym', symbol, 1)
            return
        attributes = evaluation.definitions.get_attributes(name)
        definition = evaluation.definitions.get_user_definition(
            name, create=False)
        all = evaluation.definitions.get_definition(name)
        if attributes:
            attributes = list(attributes)
            attributes.sort()
            lines.append(Expression(
                'HoldForm', Expression(
                    'Set', Expression('Attributes', symbol), Expression(
                        'List',
                        *(Symbol(attribute) for attribute in attributes)))))

        if definition is not None and not 'ReadProtected' in attributes:
            for rule in definition.ownvalues:
                print_rule(rule)
            for rule in definition.downvalues:
                print_rule(rule)
            for rule in definition.subvalues:
                print_rule(rule)
            for rule in definition.upvalues:
                print_rule(rule, up=True)
            for rule in definition.nvalues:
                print_rule(rule)
            formats = definition.formatvalues.items()
            formats.sort()
            for format, rules in formats:
                for rule in rules:
                    def lhs(expr):
                        return Expression('Format', expr, Symbol(format))

                    def rhs(expr):
                        if expr.has_form('Infix', None):
                            expr = Expression(Expression(
                                'HoldForm', expr.head), *expr.leaves)
                        return Expression('InputForm', expr)
                    print_rule(rule, lhs=lhs, rhs=rhs)
        for rule in all.defaultvalues:
            print_rule(rule)
        if all.options:
            options = all.options.items()
            options.sort()
            lines.append(
                Expression('HoldForm', Expression(
                    'Set', Expression('Options', symbol),
                    Expression('List', *(
                        Expression('Rule', Symbol(name), value)
                        for name, value in options)))))
        if grid:
            if lines:
                return Expression(
                    'Grid', Expression(
                        'List', *(Expression('List', line) for line in lines)),
                    Expression(
                        'Rule', Symbol('ColumnAlignments'), Symbol('Left')))
            else:
                return Symbol('Null')
        else:
            for line in lines:
                evaluation.print_out(Expression('InputForm', line))
            return Symbol('Null')

    def format_definition_input(self, symbol, evaluation):
        'InputForm: Definition[symbol_]'

        return self.format_definition(symbol, evaluation, grid=False)


class Clear(Builtin):
    """
    <dl>
    <dt>'Clear[$symb1$, $symb2$, ...]'
        <dd>clears all values of the given symbols.
        The arguments can also be given as strings containing symbol names.
    </dl>

    >> x = 2;
    >> Clear[x]
    >> x
     = x

    'ClearAll' may not be called for 'Protected' symbols.
    >> Clear[Sin]
     : Symbol Sin is Protected.
    The values and rules associated with built-in symbols will not get lost when applying 'Clear'
    (after unprotecting them):
    >> Unprotect[Sin]
    >> Clear[Sin]
    >> Sin[Pi]
     = 0

    'Clear' does not remove attributes, messages, options, and default values associated
    with the symbols. Use 'ClearAll' to do so.
    >> Attributes[r] = {Flat, Orderless};
    >> Clear["r"]
    >> Attributes[r]
     = {Flat, Orderless}
    """

    attributes = ('HoldAll',)

    messages = {
        'ssym': "`1` is not a symbol or a string.",
    }

    allow_locked = True

    def do_clear(self, definition):
        definition.ownvalues = []
        definition.downvalues = []
        definition.subvalues = []
        definition.upvalues = []
        definition.formatvalues = {}
        definition.nvalues = []

    def apply(self, symbols, evaluation):
        '%(name)s[symbols___]'

        for symbol in symbols.get_sequence():
            name = symbol.get_name()
            if not name:
                name = symbol.get_string_value()
            if not name:
                evaluation.message('Clear', 'ssym', symbol)
                continue
            attributes = evaluation.definitions.get_attributes(name)
            if 'Protected' in attributes:
                evaluation.message('Clear', 'wrsym', name)
                continue
            if not self.allow_locked and 'Locked' in attributes:
                evaluation.message('Clear', 'locked', name)
                continue
            definition = evaluation.definitions.get_user_definition(name)
            self.do_clear(definition)

        return Symbol('Null')


class ClearAll(Clear):
    """
    <dl>
    <dt>'ClearAll[$symb1$, $symb2$, ...]'
        <dd>clears all values, attributes, messages and options associated with the given symbols.
        The arguments can also be given as strings containing symbol names.
    </dl>

    >> x = 2;
    >> ClearAll[x]
    >> x
     = x
    >> Attributes[r] = {Flat, Orderless};
    >> ClearAll[r]
    >> Attributes[r]
     = {}

    'ClearAll' may not be called for 'Protected' or 'Locked' symbols.
    >> Attributes[lock] = {Locked};
    >> ClearAll[lock]
     : Symbol lock is locked.
    """

    allow_locked = False

    def do_clear(self, definition):
        super(ClearAll, self).do_clear(definition)
        definition.attributes = set()
        definition.messages = []
        definition.options = []
        definition.defaultvalues = []


class Unset(PostfixOperator):
    """
    >> a = 2
     = 2
    >> a =.
    >> a
     = a
    Unsetting an already unset or never defined variable will not cause anything:
    >> a =.
    >> b =.

    'Unset' can unset particular function values. It will print a message
    if no corresponding rule is found.
    >> f[x_] =.
     : Assignment on f for f[x_] not found.
     = $Failed
    >> f[x_] := x ^ 2
    >> f[3]
     = 9
    >> f[x_] =.
    >> f[3]
     = f[3]

    You can also unset 'OwnValues', 'DownValues', 'SubValues', and 'UpValues' directly.
    This is equivalent to setting them to '{}'.
    >> f[x_] = x; f[0] = 1;
    >> DownValues[f] =.
    >> f[2]
     = f[2]

    'Unset' threads over lists:
    >> a = b = 3;
    >> {a, {b}} =.
     = {Null, {Null}}

    #> x = 2;
    #> OwnValues[x] =.
    #> x
     = x
    #> f[a][b] = 3;
    #> SubValues[f] =.
    #> f[a][b]
     = f[a][b]
    #> PrimeQ[p] ^= True
     = True
    #> PrimeQ[p]
     = True
    #> UpValues[p] =.
    #> PrimeQ[p]
     = False

    #> a + b ^= 5;
    #> a =.
    #> a + b
     = 5
    #> {UpValues[a], UpValues[b]} =.
     = {Null, Null}
    #> a + b
     = a + b

    #> Unset[Messages[1]]
     : First argument in Messages[1] is not a symbol or a string naming a symbol.
     = $Failed
    """

    operator = '=.'
    precedence = 670
    attributes = ('HoldFirst', 'Listable', 'ReadProtected')

    messages = {
        'norep': "Assignment on `2` for `1` not found.",
        'usraw': "Cannot unset raw object `1`.",
    }

    def apply(self, expr, evaluation):
        'Unset[expr_]'

        name = expr.get_head_name()
        if name in ('OwnValues', 'DownValues', 'SubValues', 'UpValues',
                    'NValues', 'Options', 'Messages'):
            if len(expr.leaves) != 1:
                evaluation.message_args(name, len(expr.leaves), 1)
                return Symbol('$Failed')
            symbol = expr.leaves[0].get_name()
            if not symbol:
                evaluation.message(name, 'fnsym', expr)
                return Symbol('$Failed')
            if name == 'Options':
                empty = {}
            else:
                empty = []
            evaluation.definitions.set_values(symbol, name, empty)
            return Symbol('Null')
        name = expr.get_lookup_name()
        if not name:
            evaluation.message('Unset', 'usraw', expr)
            return Symbol('$Failed')
        if not evaluation.definitions.unset(name, expr):
            if not expr.is_atom():
                evaluation.message('Unset', 'norep', expr, name)
                return Symbol('$Failed')
        return Symbol('Null')


class Quit(Builtin):
    """
    'Quit' removes all user-defined definitions.

    >> a = 3
     = 3
    >> Quit[]
    >> a
     = a

    'Quit' even removes the definitions of protected and locked symbols:
    >> x = 5;
    >> Attributes[x] = {Locked, Protected};
    >> Quit[]
    >> x
     = x
    """

    def apply(self, evaluation):
        'Quit[]'

        evaluation.definitions.set_user_definitions({})
        return Symbol('Null')


def get_symbol_values(symbol, func_name, position, evaluation):
    name = symbol.get_name()
    if not name:
        evaluation.message(func_name, 'sym', symbol, 1)
        return
    if position in ('default',):
        definition = evaluation.definitions.get_definition(name)
    else:
        definition = evaluation.definitions.get_user_definition(name)
    result = Expression('List')
    for rule in definition.get_values_list(position):
        if isinstance(rule, Rule):
            pattern = rule.pattern
            if pattern.has_form('HoldPattern', 1):
                pattern = pattern.expr
            else:
                pattern = Expression('HoldPattern', pattern.expr)
            result.leaves.append(Expression(
                'RuleDelayed', pattern, rule.replace))
    return result


class DownValues(Builtin):
    """
    'DownValues[$symbol$]' gives the list of downvalues associated with $symbol$.

    'DownValues' uses 'HoldPattern' and 'RuleDelayed' to protect the downvalues from being
    evaluated. Moreover, it has attribute 'HoldAll' to get the specified symbol instead of its value.

    >> f[x_] := x ^ 2
    >> DownValues[f]
     = {HoldPattern[f[x_]] :> x ^ 2}

    Mathics will sort the rules you assign to a symbol according to their specifity. If it cannot decide
    which rule is more special, the newer one will get higher precedence.
    >> f[x_Integer] := 2
    >> f[x_Real] := 3
    >> DownValues[f]
     = {HoldPattern[f[x_Real]] :> 3, HoldPattern[f[x_Integer]] :> 2, HoldPattern[f[x_]] :> x ^ 2}
    >> f[3]
     = 2
    >> f[3.]
     = 3
    >> f[a]
     = a ^ 2
    The default order of patterns can be computed using 'Sort' with 'PatternsOrderedQ':
    >> Sort[{x_, x_Integer}, PatternsOrderedQ]
     = {x_Integer, x_}
    By assigning values to 'DownValues', you can override the default ordering:
    >> DownValues[g] := {g[x_] :> x ^ 2, g[x_Integer] :> x}
    >> g[2]
     = 4

    Fibonacci numbers:
    >> DownValues[fib] := {fib[0] -> 0, fib[1] -> 1, fib[n_] :> fib[n - 1] + fib[n - 2]}
    >> fib[5]
     = 5
    """

    attributes = ('HoldAll',)

    def apply(self, symbol, evaluation):
        'DownValues[symbol_]'

        return get_symbol_values(symbol, 'DownValues', 'down', evaluation)


class OwnValues(Builtin):
    """
    >> x = 3;
    >> x = 2;
    >> OwnValues[x]
     = {HoldPattern[x] :> 2}
    >> x := y
    >> OwnValues[x]
     = {HoldPattern[x] :> y}
    >> y = 5;
    >> OwnValues[x]
     = {HoldPattern[x] :> y}
    >> Hold[x] /. OwnValues[x]
     = Hold[y]
    >> Hold[x] /. OwnValues[x] // ReleaseHold
     = 5
    """

    attributes = ('HoldAll',)

    def apply(self, symbol, evaluation):
        'OwnValues[symbol_]'

        return get_symbol_values(symbol, 'OwnValues', 'own', evaluation)


class SubValues(Builtin):
    """
    >> f[1][x_] := x
    >> f[2][x_] := x ^ 2
    >> SubValues[f]
     = {HoldPattern[f[2][x_]] :> x ^ 2, HoldPattern[f[1][x_]] :> x}
    >> Definition[f]
     = f[2][x_] = x ^ 2
     .
     . f[1][x_] = x
    """

    attributes = ('HoldAll',)

    def apply(self, symbol, evaluation):
        'SubValues[symbol_]'

        return get_symbol_values(symbol, 'SubValues', 'sub', evaluation)


class UpValues(Builtin):
    """
    >> a + b ^= 2
     = 2
    >> UpValues[a]
     = {HoldPattern[a + b] :> 2}
    >> UpValues[b]
     = {HoldPattern[a + b] :> 2}

    You can assign values to 'UpValues':
    >> UpValues[pi] := {Sin[pi] :> 0}
    >> Sin[pi]
     = 0
    """

    attributes = ('HoldAll',)

    def apply(self, symbol, evaluation):
        'UpValues[symbol_]'

        return get_symbol_values(symbol, 'UpValues', 'up', evaluation)


class NValues(Builtin):
    """
    >> NValues[a]
     = {}
    >> N[a] = 3;
    >> NValues[a]
     = {HoldPattern[N[a, MachinePrecision]] :> 3}

    You can assign values to 'NValues':
    >> NValues[b] := {N[b, MachinePrecision] :> 2}
    >> N[b]
     = 2.
    Be sure to use 'SetDelayed', otherwise the left-hand side of the transformation rule will be evaluated immediately,
    causing the head of 'N' to get lost. Furthermore, you have to include the precision in the rules; 'MachinePrecision'
    will not be inserted automatically:
    >> NValues[c] := {N[c] :> 3}
    >> N[c]
     = c

    Mathics will gracefully assign any list of rules to 'NValues'; however, inappropriate rules will never be used:
    >> NValues[d] = {foo -> bar};
    >> NValues[d]
     = {HoldPattern[foo] :> bar}
    >> N[d]
     = d
    """

    attributes = ('HoldAll',)

    def apply(self, symbol, evaluation):
        'NValues[symbol_]'

        return get_symbol_values(symbol, 'NValues', 'n', evaluation)


class Messages(Builtin):
    """
    >> a::b = "foo"
     = foo
    >> Messages[a]
     = {HoldPattern[a::b] :> foo}
    >> Messages[a] = {a::c :> "bar"};
    >> a::c // InputForm
     = "bar"
    >> Message[a::c]
     : bar
    """

    attributes = ('HoldAll',)

    def apply(self, symbol, evaluation):
        'Messages[symbol_]'

        return get_symbol_values(symbol, 'Messages', 'messages', evaluation)


class DefaultValues(Builtin):
    """
    >> Default[f, 1] = 4
     = 4
    >> DefaultValues[f]
     = {HoldPattern[Default[f, 1]] :> 4}

    You can assign values to 'DefaultValues':
    >> DefaultValues[g] = {Default[g] -> 3};
    >> Default[g, 1]
     = 3
    >> g[x_.] := {x}
    >> g[a]
     = {a}
    >> g[]
     = {3}
    """

    attributes = ('HoldAll',)

    def apply(self, symbol, evaluation):
        'DefaultValues[symbol_]'

        return get_symbol_values(
            symbol, 'DefaultValues', 'default', evaluation)


class AddTo(BinaryOperator):
    """
    '$x$ += $dx$' is equivalent to '$x$ = $x$ + $dx$'.
    >> a = 10;
    >> a += 2
     = 12
    >> a
     = 12
    """

    operator = '+='
    precedence = 100
    attributes = ('HoldFirst',)
    grouping = 'Right'

    rules = {
        'x_ += dx_': 'x = x + dx',
    }


class SubtractFrom(BinaryOperator):
    """
    '$x$ -= $dx$' is equivalent to '$x$ = $x$ - $dx$'.
    >> a = 10;
    >> a -= 2
     = 8
    >> a
     = 8
    """

    operator = '-='
    precedence = 100
    attributes = ('HoldFirst',)
    grouping = 'Right'

    rules = {
        'x_ -= dx_': 'x = x - dx',
    }


class TimesBy(BinaryOperator):
    """
    '$x$ *= $dx$' is equivalent to '$x$ = $x$ * $dx$'.
    >> a = 10;
    >> a *= 2
     = 20
    >> a
     = 20
    """

    operator = '*='
    precedence = 100
    attributes = ('HoldFirst',)
    grouping = 'Right'

    rules = {
        'x_ *= dx_': 'x = x * dx',
    }


class DivideBy(BinaryOperator):
    """
    '$x$ /= $dx$' is equivalent to '$x$ = $x$ / $dx$'.
    >> a = 10;
    >> a /= 2
     = 5
    >> a
     = 5
    """

    operator = '/='
    precedence = 100
    attributes = ('HoldFirst',)
    grouping = 'Right'

    rules = {
        'x_ /= dx_': 'x = x / dx',
    }


class Increment(PostfixOperator):
    """
    >> a = 2;
    >> a++
     = 2
    >> a
     = 3
    Grouping of 'Increment', 'PreIncrement' and 'Plus':
    >> ++++a+++++2//Hold//FullForm
     = Hold[Plus[PreIncrement[PreIncrement[Increment[Increment[a]]]], 2]]
    """

    operator = '++'
    precedence = 660
    attributes = ('HoldFirst', 'ReadProtected')

    rules = {
        'x_++': 'Module[{t=x}, x = x + 1; t]',
    }


class PreIncrement(PrefixOperator):
    """
    <dl>
    <dt>'PreIncrement[$x$]' or '++$x$'
        <dd>is equivalent to '$x$ = $x$ + 1'.
    </dl>
    >> a = 2;
    >> ++a
     = 3
    >> a
     = 3
    """

    operator = '++'
    precedence = 660
    attributes = ('HoldFirst', 'ReadProtected')

    rules = {
        '++x_': 'x = x + 1',
    }


class Decrement(PostfixOperator):
    """
    >> a = 5;
    >> a--
     = 5
    >> a
     = 4
    """

    operator = '--'
    precedence = 660
    attributes = ('HoldFirst', 'ReadProtected')

    rules = {
        'x_--': 'Module[{t=x}, x = x - 1; t]',
    }


class PreDecrement(PrefixOperator):
    """
    >> a = 2;
    >> --a
     = 1
    >> a
     = 1
    """

    operator = '--'
    precedence = 660
    attributes = ('HoldFirst', 'ReadProtected')

    rules = {
        '--x_': 'x = x - 1',
    }

########NEW FILE########
__FILENAME__ = attributes
# -*- coding: utf8 -*-

r"""
Attributes

There are several builtin-attributes which have a predefined meaning in \Mathics.
However, you can set any symbol as an attribute, in contrast to \Mathematica.
"""

from mathics.builtin.base import Predefined, Builtin
from mathics.core.expression import Symbol, Expression
from mathics.builtin.assignment import get_symbol_list


class Attributes(Builtin):
    u"""
    >> Attributes[Plus]
     = {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}
    'Attributes' always considers the head of an expression:
    >> Attributes[a + b + c]
     = {Flat, Listable, NumericFunction, OneIdentity, Orderless, Protected}

    You can assign values to 'Attributes' to set attributes:
    >> Attributes[f] = {Flat, Orderless}
     = {Flat, Orderless}
    >> f[b, f[a, c]]
     = f[a, b, c]
    Attributes must be symbols:
    >> Attributes[f] := {a + b}
     : Argument a + b at position 1 is expected to be a symbol.
     = $Failed
    Use 'Symbol' to convert strings to symbols:
    >> Attributes[f] = Symbol["Listable"]
     = Listable
    >> Attributes[f]
     = {Listable}
    """

    attributes = ('HoldAll', 'Listable')

    def apply(self, expr, evaluation):
        'Attributes[expr_]'

        name = expr.get_lookup_name()
        attributes = list(evaluation.definitions.get_attributes(name))
        attributes.sort()
        attr = [Symbol(attribute) for attribute in attributes]
        return Expression('List', *attr)


class SetAttributes(Builtin):
    """
    >> SetAttributes[f, Flat]
    >> Attributes[f]
     = {Flat}
    >> SetAttributes[{f, g}, {Flat, Orderless}]
    >> Attributes[g]
     = {Flat, Orderless}
    """

    attributes = ('HoldFirst',)

    def apply(self, symbols, attributes, evaluation):
        'SetAttributes[symbols_, attributes_]'

        symbols = get_symbol_list(symbols, lambda item: evaluation.message(
            'SetAttributes', 'sym', item, 1))
        if symbols is None:
            return
        values = get_symbol_list(attributes, lambda item: evaluation.message(
            'SetAttributes', 'sym', item, 2))
        if values is None:
            return
        for symbol in symbols:
            if 'Locked' in evaluation.definitions.get_attributes(symbol):
                evaluation.message('SetAttributes', 'locked', symbol)
            else:
                for value in values:
                    evaluation.definitions.set_attribute(symbol, value)
        return Symbol('Null')


class ClearAttributes(Builtin):
    """
    >> SetAttributes[f, Flat]
    >> Attributes[f]
     = {Flat}
    >> ClearAttributes[f, Flat]
    >> Attributes[f]
     = {}
    Attributes that are not even set are simply ignored:
    >> ClearAttributes[{f}, {Flat}]
    >> Attributes[f]
     = {}
    """

    attributes = ('HoldFirst',)

    def apply(self, symbols, attributes, evaluation):
        'ClearAttributes[symbols_, attributes_]'

        symbols = get_symbol_list(symbols, lambda item: evaluation.message(
            'ClearAttributes', 'sym', item, 1))
        if symbols is None:
            return
        values = get_symbol_list(attributes, lambda item: evaluation.message(
            'ClearAttributes', 'sym', item, 2))
        if values is None:
            return
        for symbol in symbols:
            if 'Locked' in evaluation.definitions.get_attributes(symbol):
                evaluation.message('ClearAttributes', 'locked', symbol)
            else:
                for value in values:
                    evaluation.definitions.clear_attribute(symbol, value)
        return Symbol('Null')


class Protect(Builtin):
    """
    >> A = {1, 2, 3};
    >> Protect[A]
    >> A[[2]] = 4;
     : Symbol A is Protected.
    >> A
     = {1, 2, 3}
    """

    attributes = ('HoldAll',)

    rules = {
        'Protect[symbols__]': 'SetAttributes[{symbols}, Protected]',
    }


class Unprotect(Builtin):

    attributes = ('HoldAll',)

    rules = {
        'Unprotect[symbols__]': 'ClearAttributes[{symbols}, Protected]',
    }


class Protected(Predefined):
    """
    Values of 'Protected' symbols cannot be modified:
    >> Attributes[p] = {Protected};
    >> p = 2;
     : Symbol p is Protected.
    >> f[p] ^= 3;
     : Tag p in f[p] is Protected.
    >> Format[p] = "text";
     : Symbol p is Protected.

    However, attributes might still be set:
    >> SetAttributes[p, Flat]
    >> Attributes[p]
     = {Flat, Protected}
    Thus, you can easily remove the attribute 'Protected':
    >> Attributes[p] = {};
    >> p = 2
     = 2
    You can also use 'Protect' or 'Unprotect', resp.
    >> Protect[p]
    >> Attributes[p]
     = {Protected}
    >> Unprotect[p]

    If a symbol is 'Protected' and 'Locked', it can never be changed again:
    >> SetAttributes[p, {Protected, Locked}]
    >> p = 2
     : Symbol p is Protected.
     = 2
    >> Unprotect[p]
     : Symbol p is locked.
    """


class Locked(Predefined):
    """
    The attributes of 'Locked' symbols cannot be modified:
    >> Attributes[lock] = {Flat, Locked};
    >> SetAttributes[lock, {}]
     : Symbol lock is locked.
    >> ClearAttributes[lock, Flat]
     : Symbol lock is locked.
    >> Attributes[lock] = {}
     : Symbol lock is locked.
     = {}
    >> Attributes[lock]
     = {Flat, Locked}

    However, their values might be modified (as long as they are not 'Protected' too):
    >> lock = 3
     = 3
    """


class Flat(Predefined):
    """
    >> SetAttributes[f, Flat]
    >> f[a, b, c] /. f[a, b] -> d
     = f[d, c]

    #> SetAttributes[{u, v}, Flat]
    #> u[x_] := {x}
    #> u[]
     = u[]
    #> u[a]
     = {a}
    #> u[a, b]
     : Recursion depth of 200 exceeded.
     = $Aborted
    #> u[a, b, c]
     : Recursion depth of 200 exceeded.
     = $Aborted
    #> v[x_] := x
    #> v[]
     = v[]
    #> v[a]
     = a
    #> v[a, b] (* in Mathematica: Iteration limit of 4096 exceeded. *)
     = v[a, b]
    #> v[a, b, c] (* in Mathematica: Iteration limit of 4096 exceeded. *)
     : Recursion depth of 200 exceeded.
     = $Aborted
    """


class Orderless(Predefined):
    """
    >> SetAttributes[f, Orderless]
    >> f[c, a, b, a + b, 3, 1.0]
     = f[1., 3, a, b, c, a + b]
    >> SetAttributes[f, Flat]
    >> f[a, b, c] /. f[a, b] -> d
     = f[c, d]
    """


class OneIdentity(Predefined):
    """
    'OneIdentity' affects pattern matching:
    >> SetAttributes[f, OneIdentity]
    >> a /. f[args___] -> {args}
     = {a}
    It does not affect evaluation:
    >> f[a]
     = f[a]
    """


class SequenceHold(Predefined):
    """
    Normally, 'Sequence' will be spliced into a function:
    >> f[Sequence[a, b]]
     = f[a, b]
    It does not for 'SequenceHold' functions:
    >> SetAttributes[f, SequenceHold]
    >> f[Sequence[a, b]]
     = f[Sequence[a, b]]

    E.g., 'Set' has attribute 'SequenceHold' to allow assignment of sequences to variables:
    >> s = Sequence[a, b];
    >> s
     = Sequence[a, b]
    >> Plus[s]
     = a + b
    """


class HoldFirst(Predefined):
    pass


class HoldRest(Predefined):
    pass


class HoldAll(Predefined):
    pass


class HoldAllComplete(Predefined):
    """
    'HoldAllComplete' even prevents upvalues from being used, and includes 'SequenceHold'.
    >> SetAttributes[f, HoldAllComplete]
    >> f[a] ^= 3;
    >> f[a]
     = f[a]
    >> f[Sequence[a, b]]
     = f[Sequence[a, b]]
    """


class NHoldAll(Predefined):
    """
    >> N[f[2, 3]]
     = f[2., 3.]
    >> SetAttributes[f, NHoldAll]
    >> N[f[2, 3]]
     = f[2, 3]
    """


class NHoldFirst(Predefined):
    pass


class NHoldRest(Predefined):
    pass


class Listable(Predefined):
    """
    >> SetAttributes[f, Listable]
    >> f[{1, 2, 3}, {4, 5, 6}]
     = {f[1, 4], f[2, 5], f[3, 6]}
    >> f[{1, 2, 3}, 4]
     = {f[1, 4], f[2, 4], f[3, 4]}
    >> {{1, 2}, {3, 4}} + {5, 6}
     = {{6, 7}, {9, 10}}
    """

########NEW FILE########
__FILENAME__ = base
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import re
import sympy

from mathics.core.definitions import Definition
from mathics.core.rules import Rule, BuiltinRule, Pattern
from mathics.core.expression import (BaseExpression, Expression, Symbol,
                                     String, Integer)


class Builtin(object):
    name = None
    abstract = False
    attributes = ()
    rules = {}
    formats = {}
    messages = {}
    options = {}
    defaults = {}

    def __new__(cls, *args, **kwargs):
        if kwargs.get('expression', None) is not False:
            return Expression(cls.get_name(), *args)
        else:
            instance = super(Builtin, cls).__new__(cls)
            if not instance.formats:
                # Reset formats so that not every instance shares the same
                # empty dict {}
                instance.formats = {}
            return instance

    def __init__(self, *args, **kwargs):
        super(Builtin, self).__init__()

    def contribute(self, definitions):
        from mathics.core.parser import parse

        name = self.get_name()
        rules = []
        for pattern, function in self.get_functions():
            rules.append(BuiltinRule(pattern, function, system=True))
        for pattern, replace in self.rules.items():
            if not isinstance(pattern, BaseExpression):
                pattern = pattern % {'name': name}
                pattern = parse(pattern)
            replace = replace % {'name': name}
            rules.append(Rule(pattern, parse(replace), system=True))

        box_rules = []
        if name != 'MakeBoxes':
            new_rules = []
            for rule in rules:
                if rule.pattern.get_head_name() == 'MakeBoxes':
                    box_rules.append(rule)
                else:
                    new_rules.append(rule)
            rules = new_rules

        formatvalues = {'': []}
        for pattern, function in self.get_functions('format_'):
            if isinstance(pattern, tuple):
                forms, pattern = pattern
            else:
                forms = ['']
            for form in forms:
                if form not in formatvalues:
                    formatvalues[form] = []
                formatvalues[form].append(BuiltinRule(
                    pattern, function, system=True))
        for pattern, replace in self.formats.items():
            if isinstance(pattern, tuple):
                forms, pattern = pattern
                if not isinstance(forms, tuple):
                    forms = [forms]
            else:
                forms, pattern = [''], pattern
            for form in forms:
                if not form in formatvalues:
                    formatvalues[form] = []
                if not isinstance(pattern, BaseExpression):
                    pattern = parse(pattern)
                formatvalues[form].append(Rule(
                    pattern, parse(replace), system=True))
        for form, formatrules in formatvalues.items():
            formatrules.sort()

        messages = [Rule(Expression('MessageName', Symbol(name), String(msg)),
                         String(value), system=True)
                    for msg, value in self.messages.items()]

        if name == 'MakeBoxes':
            attributes = []
        else:
            attributes = ['Protected']
        attributes += list(self.attributes)
        options = {}
        for option, value in self.options.iteritems():
            options[option] = parse(value)
        defaults = []
        for spec, value in self.defaults.iteritems():
            value = parse(value)
            pattern = None
            if spec is None:
                pattern = Expression('Default', Symbol(name))
            elif isinstance(spec, int):
                pattern = Expression('Default', Symbol(name), Integer(spec))
            if pattern is not None:
                defaults.append(Rule(pattern, value, system=True))
        definition = Definition(
            name=name, rules=rules, formatvalues=formatvalues,
            messages=messages, attributes=attributes, options=options,
            defaultvalues=defaults)
        definitions.builtin[name] = definition

        makeboxes_def = definitions.builtin['MakeBoxes']
        for rule in box_rules:
            makeboxes_def.add_rule(rule)

    @classmethod
    def get_name(cls):
        if cls.name is None:
            return cls.__name__
        else:
            return cls.name

    def get_operator(self):
        return None

    def get_operator_display(self):
        return None

    def get_functions(self, prefix='apply'):
        from mathics.core.parser import parse

        for name in dir(self):
            if name.startswith(prefix):
                function = getattr(self, name)
                pattern = function.__doc__
                if pattern is None:  # Fixes PyPy bug
                    continue
                else:
                    m = re.match(r'([\w,]+)\:\s*(.*)', pattern)
                if m is not None:
                    attrs = m.group(1).split(',')
                    pattern = m.group(2)
                else:
                    attrs = []
                pattern = pattern % {'name': self.get_name()}
                pattern = parse(pattern)
                if attrs:
                    yield (attrs, pattern), function
                else:
                    yield (pattern, function)

    def get_option(self, options, name, evaluation, pop=False):
        value = options.pop(name, None) if pop else options.get(name)
        if value is not None:
            return value.evaluate(evaluation)
        else:
            return None


class InstancableBuiltin(Builtin):
    def __new__(cls, *args, **kwargs):
        new_kwargs = kwargs.copy()
        new_kwargs['expression'] = False
        instance = super(InstancableBuiltin, cls).__new__(
            cls, *args, **new_kwargs)
        if not instance.formats:
            # Reset formats so that not every instance shares the same empty
            # dict {}
            instance.formats = {}
        if kwargs.get('expression', None) is not False:
            try:
                instance.init(*args, **kwargs)
            except TypeError:
                # TypeError occurs when unpickling instance, e.g. PatterObject,
                # because parameter expr is not given. This should no be a
                # problem, as pickled objects need their init-method not
                # being called.
                pass
        return instance

    def init(self, *args, **kwargs):
        pass


class Operator(Builtin):
    operator = None
    precedence = None
    precedence_parse = None
    needs_verbatim = False

    default_formats = True

    def get_operator(self):
        return self.operator

    def get_operator_display(self):
        if hasattr(self, 'operator_display'):
            return self.operator_display
        else:
            return self.operator

    def is_binary(self):
        return False

    def is_prefix(self):
        return False

    def is_postfix(self):
        return False

    def post_parse(self, expression):
        return Expression(expression.head.post_parse(), *[
            leaf.post_parse() for leaf in expression.leaves])


class Predefined(Builtin):
    def get_functions(self, prefix='apply'):
        functions = list(super(Predefined, self).get_functions(prefix))
        if prefix == 'apply' and hasattr(self, 'evaluate'):
            functions.append((Symbol(self.get_name()), self.evaluate))
        return functions


class UnaryOperator(Operator):
    def __init__(self, format_function, *args, **kwargs):
        super(UnaryOperator, self).__init__(*args, **kwargs)
        name = self.get_name()
        if self.needs_verbatim:
            name = 'Verbatim[%s]' % name
        if self.default_formats:
            op_pattern = '%s[item_]' % name
            if not op_pattern in self.formats:
                operator = self.get_operator_display()
                if operator is not None:
                    form = '%s[{HoldForm[item]},"%s",%d]' % (
                        format_function, operator, self.precedence)
                    self.formats[op_pattern] = form


class PrefixOperator(UnaryOperator):
    def __init__(self, *args, **kwargs):
        super(PrefixOperator, self).__init__('Prefix', *args, **kwargs)

    def parse(self, args):
        from mathics.core.parser import MathicsParser, Token

        rest = args[0].parse_tokens
        if rest:
            parser = MathicsParser()
            items = list(rest + [Token('(')] + [args[1]] +
                         args[2].parse_tokens + [Token(')')])
            result = parser.parse(items)
            return result
        else:
            return Expression(self.get_name(), args[2], parse_operator=self)

    def is_prefix(self):
        return True


class PostfixOperator(UnaryOperator):
    def __init__(self, *args, **kwargs):
        super(PostfixOperator, self).__init__('Postfix', *args, **kwargs)

    def parse(self, args):
        from mathics.core.parser import MathicsParser, Token

        rest = args[2].parse_tokens
        if rest:
            parser = MathicsParser()    # construct our own parser!
            items = [Token('(')] + args[0].parse_tokens + [
                args[1]] + [Token(')')] + rest
            result = parser.parse(items)
            return result
        else:
            return Expression(self.get_name(), args[0], parse_operator=self)

    def is_postfix(self):
        return True


class BinaryOperator(Operator):
    grouping = 'None'  # NonAssociative, None, Left, Right

    def __init__(self, *args, **kwargs):
        super(BinaryOperator, self).__init__(*args, **kwargs)
        name = self.get_name()
        # Prevent pattern matching symbols from gaining meaning here using
        # Verbatim
        name = 'Verbatim[%s]' % name
        if self.grouping in ('None', 'NonAssociative'):
            op_pattern = '%s[items__]' % name
            replace_items = 'items'
        else:
            op_pattern = '%s[x_, y_]' % name
            replace_items = 'x, y'

        if self.default_formats:
            operator = self.get_operator_display()
            formatted = 'MakeBoxes[Infix[{%s},"%s",%d,%s], form]' % (
                replace_items, operator, self.precedence, self.grouping)
            formatted_output = 'MakeBoxes[Infix[{%s}," %s ",%d,%s], form]' % (
                replace_items, operator, self.precedence, self.grouping)
            default_rules = {
                'MakeBoxes[{0}, form:StandardForm|TraditionalForm]'.format(
                    op_pattern): formatted,
                'MakeBoxes[{0}, form:InputForm|OutputForm]'.format(
                    op_pattern): formatted_output,
            }
            default_rules.update(self.rules)
            self.rules = default_rules

    def parse(self, args):
        left = args[0]
        right = args[2]
        name = self.get_name()
        grouping = self.grouping
        if grouping != 'NonAssociative':
            def collect_leaves(expr):
                if expr.parenthesized or expr.get_head_name() != name:
                    return [expr]
                else:
                    result = []
                    for leaf in expr.leaves:
                        result.extend(collect_leaves(leaf))
                    return result
            leaves = collect_leaves(left) + collect_leaves(right)
            if grouping == 'None':
                return Expression(name, parse_operator=self, *leaves)
            elif grouping == 'Right':
                result = Expression(name, parse_operator=self, *leaves[-2:])
                for leaf in reversed(leaves[:-2]):
                    result = Expression(
                        name, leaf, result, parse_operator=self)
                return result
            elif grouping == 'Left':
                result = Expression(name, parse_operator=self, *leaves[:2])
                for leaf in leaves[2:]:
                    result = Expression(
                        name, result, leaf, parse_operator=self)
                return result
        else:
            return Expression(self.get_name(), left, right,
                              parse_operator=self)

    def is_binary(self):
        return True


class Test(Builtin):
    def apply(self, expr, evaluation):
        '%(name)s[expr_]'

        if self.test(expr):
            return Symbol('True')
        else:
            return Symbol('False')


class SympyObject(Builtin):
    sympy_name = None

    def __init__(self, *args, **kwargs):
        super(SympyObject, self).__init__(*args, **kwargs)
        if self.sympy_name is None:
            self.sympy_name = self.get_name().lower()

    def is_constant(self):
        return False


class SympyFunction(SympyObject):
    def prepare_sympy(self, leaves):
        return leaves

    def to_sympy(self, expr, **kwargs):
        try:
            if self.sympy_name:
                leaves = self.prepare_sympy(expr.leaves)
                return getattr(sympy, self.sympy_name)(*(
                    leaf.to_sympy(**kwargs) for leaf in leaves))
        except TypeError:
            pass

    def from_sympy(self, leaves):
        return leaves

    def prepare_mathics(self, sympy_expr):
        return sympy_expr


class SympyConstant(SympyObject, Predefined):
    attributes = ('Constant', 'ReadProtected')

    def is_constant(self):
        # free Symbol will be converted to corresponding SymPy symbol
        return True

    def to_sympy(self, expr, **kwargs):
        # there is no "native" SymPy expression for e.g. E[x]
        return None


class InvalidLevelspecError(Exception):
    pass


class PartError(Exception):
    pass


class PartDepthError(PartError):
    pass


class PartRangeError(PartError):
    pass


class BoxConstructError(Exception):
    pass


class BoxConstruct(Builtin):
    def get_option_values(self, leaves, evaluation=None, **options):
        default = evaluation.definitions.get_options(self.get_name()).copy()
        options = Expression('List', *leaves).get_option_values(evaluation)
        default.update(options)
        return default

    def boxes_to_text(self, leaves, **options):
        raise BoxConstructError

    def boxes_to_xml(self, leaves, **options):
        raise BoxConstructError

    def boxes_to_tex(self, leaves, **options):
        raise BoxConstructError


class PatternError(Exception):
    def __init__(self, name, tag, *args):
        super(PatternError).__init__()


class PatternArgumentError(PatternError):
    def __init__(self, name, count, expected):
        super(PatternArgumentError, self).__init__(None, None)


class PatternObject(InstancableBuiltin, Pattern):
    needs_verbatim = True

    arg_counts = []

    def init(self, expr):
        super(PatternObject, self).init(expr)
        if self.arg_counts is not None:
            if len(expr.leaves) not in self.arg_counts:
                self.error_args(len(expr.leaves), *self.arg_counts)
        self.expr = expr
        self.head = Pattern.create(expr.head)
        self.leaves = [Pattern.create(leaf) for leaf in expr.leaves]

    def error(self, tag, *args):
        raise PatternError(self.get_name(), tag, *args)

    def error_args(self, count, *expected):
        raise PatternArgumentError(self.get_name(), count, *expected)

    def get_lookup_name(self):
        return self.get_name()

    def get_head_name(self):
        return self.get_name()

    def get_sort_key(self, pattern_sort=False):
        return self.expr.get_sort_key(pattern_sort=pattern_sort)

    def get_match_count(self, vars={}):
        return (1, 1)

    def get_match_candidates(self, leaves, expression, attributes, evaluation,
                             vars={}):
        return leaves

    def get_attributes(self, definitions):
        return self.head.get_attributes(definitions)

########NEW FILE########
__FILENAME__ = calculus
# -*- coding: utf8 -*-

"""
Calculus functions
"""

from mathics.builtin.base import Builtin, PostfixOperator, SympyFunction
from mathics.core.expression import Expression, Integer, Number
from mathics.core.convert import (
    sympy_symbol_prefix, SympyExpression, from_sympy)
from mathics.core.rules import Pattern
from mathics.builtin.scoping import dynamic_scoping

import sympy


class D(SympyFunction):
    u"""
    <dl>
    <dt>'D[$f$, $x$]'
        <dd>gives the partial derivative of $f$ with respect to $x$.
    <dt>'D[$f$, $x$, $y$, ...]'
        <dd>differentiates successively with respect to $x$, $y$, etc.
    <dt>'D[$f$, {$x$, $n$}]'
        <dd>gives the multiple derivative of order $n$.
    <dt>'D[$f$, {{$x1$, $x2$, ...}}]'
        <dd>gives the vector derivative of $f$ with respect to $x1$, $x2$, etc.
    </dl>

    >> D[x^3 + x^2, x]
     = 2 x + 3 x ^ 2
    >> D[y, x]
     = 0
    >> D[x, x]
     = 1
    >> D[x + y, x]
     = 1
    >> D[Sin[Cos[x]], x]
     = -Cos[Cos[x]] Sin[x]

    >> D[Sin[x], {x, 2}]
     = -Sin[x]

    Unknown functions are derived using 'Derivative':
    >> D[f[x], x]
     = f'[x]
    >> D[f[x, x], x]
     = Derivative[0, 1][f][x, x] + Derivative[1, 0][f][x, x]
    >> D[f[x, x], x] // InputForm
     = Derivative[0, 1][f][x, x] + Derivative[1, 0][f][x, x]

    Chain rule:
    >> D[f[2x+1, 2y, x+y], x]
     = 2 Derivative[1, 0, 0][f][1 + 2 x, 2 y, x + y] + Derivative[0, 0, 1][f][1 + 2 x, 2 y, x + y]
    >> D[f[x^2, x, 2y], {x,2}, y] // Expand
     = 8 x Derivative[1, 1, 1][f][x ^ 2, x, 2 y] + 8 x ^ 2 Derivative[2, 0, 1][f][x ^ 2, x, 2 y] + 2 Derivative[0, 2, 1][f][x ^ 2, x, 2 y] + 4 Derivative[1, 0, 1][f][x ^ 2, x, 2 y]

    Compute the gradient vector of a function:
    >> D[x ^ 3 * Cos[y], {{x, y}}]
     = {3 x ^ 2 Cos[y], -x ^ 3 Sin[y]}
    Hesse matrix:
    >> D[Sin[x] * Cos[y], {{x,y}, 2}]
     = {{-Cos[y] Sin[x], -Cos[x] Sin[y]}, {-Cos[x] Sin[y], -Cos[y] Sin[x]}}

    #> D[2/3 Cos[x] - 1/3 x Cos[x] Sin[x] ^ 2,x]//Expand
     = -2 x Cos[x] ^ 2 Sin[x] / 3 + x Sin[x] ^ 3 / 3 - 2 Sin[x] / 3 - Cos[x] Sin[x] ^ 2 / 3

    #> D[f[#1], {#1,2}]
     = f''[#1]
    #> D[(#1&)[t],{t,4}]
     = 0

    #> Attributes[f] ={HoldAll}; Apart[f''[x + x]]
     = f''[2 x]

    #> Attributes[f] = {}; Apart[f''[x + x]]
     = f''[2 x]
    """

    # TODO
    """
    >> D[2x, 2x]
     = 0
    """

    sympy_name = 'Derivative'

    messages = {
        'dvar': (
            "Multiple derivative specifier `1` does not have the form "
            "{variable, n}, where n is a non-negative machine integer."),
    }

    rules = {
        'D[f_ + g_, x_?NotListQ]': 'D[f, x] + D[g, x]',
        'D[f_ * g_, x_?NotListQ]': 'D[f, x] * g + f * D[g, x]',
        'D[f_ ^ r_, x_?NotListQ] /; FreeQ[r, x]': 'r * f ^ (r-1) * D[f, x]',
        'D[E ^ f_, x_?NotListQ]': 'E ^ f * D[f, x]',
        'D[f_ ^ g_, x_?NotListQ]': 'D[E ^ (Log[f] * g), x]',

        'D[f_, x_?NotListQ] /; FreeQ[f, x]': '0',
        #'D[f_[g_], x_?NotListQ]': (
        #  'Module[{t}, D[f[t], t] /. t -> g] * D[g, x]',
        #'D[f_[g_], x_?NotListQ]': 'D[f[g], g] * D[g, x]',

        'D[f_[left___, x_, right___], x_?NotListQ] /; FreeQ[{left, right}, x]':
        'Derivative[Sequence @@ UnitVector['
        '  Length[{left, x, right}], Length[{left, x}]]][f][left, x, right]',
        #'D[f_[args___], x_?NotListQ]':
        #'Plus @@ MapIndexed[(D[f[Sequence@@ReplacePart[{args}, #2->t]], t] '
        #'/. t->#) * D[#, x]&, {args}]',

        'D[{items___}, x_?NotListQ]': 'D[#, x]& /@ {items}',
        'D[f_, {list_List}]': 'D[f, #]& /@ list',
        'D[f_, {list_List, n_Integer?Positive}]': (
            'D[f, Sequence @@ ConstantArray[{list}, n]]'),
        'D[f_, x_, rest__]': 'D[D[f, x], rest]',

        'D[expr_, {x_, n_Integer?NonNegative}]': (
            'Module[{t}, Nest[Function[{t}, D[t, x]], expr, n]]'),
    }

    def apply(self, f, x, evaluation):
        'D[f_, x_?NotListQ]'

        if f == x:
            return Integer(1)
        elif not f.is_atom() and len(f.leaves) == 1 and f.leaves[0] == x:
            return Expression(
                Expression(Expression('Derivative', Integer(1)), f.head), x)
        elif not f.is_atom() and len(f.leaves) == 1:
            g = f.leaves[0]
            return Expression(
                'Times', Expression('D', Expression(f.head, g), g),
                Expression('D', g, x))
        elif not f.is_atom() and len(f.leaves) > 1:
            def summand(leaf, index):
                if leaf.same(x):
                    result = Expression(Expression(
                        Expression(
                            'Derivative',
                            *([Integer(0)] * (index) + [Integer(1)] +
                              [Integer(0)] * (len(f.leaves) - index - 1))),
                        f.head), *f.leaves)
                else:
                    result = Expression('D', f, leaf)
                return Expression('Times', result, Expression('D', leaf, x))
            x_pattern = Pattern.create(x)
            result = Expression(
                'Plus', *[
                    summand(leaf, index) for index, leaf in enumerate(f.leaves)
                    if not leaf.is_free(x_pattern, evaluation)])
            if len(result.leaves) == 1:
                return result.leaves[0]
            else:
                return result

    def apply_wrong(self, expr, x, other, evaluation):
        'D[expr_, {x_, other___}]'

        arg = Expression('List', x, *other.get_sequence())
        evaluation.message('D', 'dvar', arg)
        return Expression('D', expr, arg)


class Derivative(PostfixOperator, SympyFunction):
    u"""
    <dl>
    <dt>'Derivative[$n$][$f$]'
        <dd>represents the $n$th derivative of the function $f$.
    <dt>'Derivative[$n1$, $n2$, ...][$f$]'
        <dd>represents a multivariate derivative.
    </dl>

    >> Derivative[1][Sin]
     = Cos[#1]&
    >> Derivative[3][Sin]
     = -Cos[#1]&
    >> Derivative[2][# ^ 3&]
     = 6 #1&

    'Derivative' can be entered using '\\'':
    >> Sin'[x]
     = Cos[x]
    >> (# ^ 4&)''
     = 12 #1 ^ 2&
    >> f'[x] // InputForm
     = Derivative[1][f][x]

    >> Derivative[1][#2 Sin[#1]+Cos[#2]&]
     = Cos[#1] #2&
    >> Derivative[1,2][#2^3 Sin[#1]+Cos[#2]&]
     = 6 Cos[#1] #2&
    Deriving with respect to an unknown parameter yields 0:
    >> Derivative[1,2,1][#2^3 Sin[#1]+Cos[#2]&]
     = 0&
    The 0th derivative of any expression is the expression itself:
    >> Derivative[0,0,0][a+b+c]
     = a + b + c

    You can calculate the derivative of custom functions:
    >> f[x_] := x ^ 2
    >> f'[x]
     = 2 x

    Unknown derivatives:
    >> Derivative[2, 1][h]
     = Derivative[2, 1][h]
    >> Derivative[2, 0, 1, 0][h[g]]
     = Derivative[2, 0, 1, 0][h[g]]

    ## Parser Tests
    #> Hold[f''] // FullForm
     = Hold[Derivative[2][f]]
    #> Hold[f ' '] // FullForm
     = Hold[Derivative[2][f]]
    #> Hold[f '' ''] // FullForm
     = Hold[Derivative[4][f]]
    #> Hold[Derivative[x][4] '] // FullForm
     = Hold[Derivative[1][Derivative[x][4]]]
    """

    operator = "'"
    precedence = 670
    attributes = ('NHoldAll',)

    rules = {
        'MakeBoxes[Derivative[n__Integer][f_], '
        '  form:StandardForm|TraditionalForm]': (
            r'SuperscriptBox[MakeBoxes[f, form], If[{n} === {2}, '
            r'  "\[Prime]\[Prime]", If[{n} === {1}, "\[Prime]", '
            r'    RowBox[{"(", Sequence @@ Riffle[{n}, ","], ")"}]]]]'),
        'MakeBoxes[Derivative[n:1|2][f_], form:OutputForm]':
        """RowBox[{MakeBoxes[f, form], If[n==1, "'", "''"]}]""",

        'Derivative[0...][f_]': 'f',
        'Derivative[n__Integer][Derivative[m__Integer][f_]] /; Length[{m}] '
        '== Length[{n}]': 'Derivative[Sequence @@ ({n} + {m})][f]',
        """Derivative[n__Integer][f_Symbol] /; Module[{t=Sequence@@Slot/@Range[Length[{n}]], result, nothing, ft=f[t]},
            If[Head[ft] === f
            && FreeQ[Join[UpValues[f], DownValues[f], SubValues[f]], Derivative|D]
            && Context[f] != "System`",
                False,
                (* else *)
                ft = f[t];
                Block[{f},
                    Unprotect[f];
                    (*Derivative[1][f] ^= nothing;*)
                    Derivative[n][f] ^= nothing;
                    Derivative[n][nothing] ^= nothing;
                    result = D[ft, Sequence@@Table[{Slot[i], {n}[[i]]}, {i, Length[{n}]}]];
                ];
                FreeQ[result, nothing]
            ]
            ]""":
        """Module[{t=Sequence@@Slot/@Range[Length[{n}]], result, nothing, ft},
                ft = f[t];
                Block[{f},
                    Unprotect[f];
                    Derivative[n][f] ^= nothing;
                    Derivative[n][nothing] ^= nothing;
                    result = D[ft, Sequence@@Table[{Slot[i], {n}[[i]]}, {i, Length[{n}]}]];
                ];
                Function @@ {result}
            ]""",
        'Derivative[n__Integer][f_Function]':
        """Evaluate[D[
            Quiet[f[Sequence @@ Table[Slot[i], {i, 1, Length[{n}]}]],
                Function::slotn],
            Sequence @@ Table[{Slot[i], {n}[[i]]}, {i, 1, Length[{n}]}]]]&""",
    }

    default_formats = False

    def __init__(self, *args, **kwargs):
        super(Derivative, self).__init__(*args, **kwargs)

    def post_parse(self, expression):
        count = 0
        inner = expression
        while inner.has_form('Derivative', 1):
            inner = inner.leaves[0]
            count += 1
        return Expression(Expression('Derivative', Integer(count)), inner)

    def to_sympy(self, expr, **kwargs):
        inner = expr
        exprs = [inner]
        try:
            while True:
                inner = inner.head
                exprs.append(inner)
        except AttributeError:
            pass

        if len(exprs) != 4 or not all(len(expr.leaves) >= 1
                                      for exp in exprs[:3]):
            return

        sym_x = exprs[0].leaves[0].to_sympy()
        func = exprs[1].leaves[0]
        sym_func = sympy.Function(str(
            sympy_symbol_prefix + func.__str__()))(sym_x)

        count = exprs[2].leaves[0].to_python()
        for i in range(count):
            try:
                sym_func = sympy.Derivative(sym_func)
            except ValueError:
                return None

        return sym_func


class Integrate(SympyFunction):
    r"""
    <dl>
    <dt>'Integrate[$f$, $x$]'
        <dd>integrates $f$ with respect to $x$. The result does not contain the additive integration constant.
    <dt>'Integrate[$f$, {$x$, $a$, $b$}]'
        <dd>computes the definite integral of $f$ with respect to $x$ from $a$ to $b$.
    </dl>

    Integrate a polynomial:
    >> Integrate[6 x ^ 2 + 3 x ^ 2 - 4 x + 10, x]
     = 10 x - 2 x ^ 2 + 3 x ^ 3

    Integrate trigonometric functions:
    >> Integrate[Sin[x] ^ 5, x]
     = -Cos[x] - Cos[x] ^ 5 / 5 + 2 Cos[x] ^ 3 / 3

    Definite integrals:
    >> Integrate[x ^ 2 + x, {x, 1, 3}]
     = 38 / 3
    >> Integrate[Sin[x], {x, 0, Pi/2}]
     = 1

    Some other integrals:
    >> Integrate[1 / (1 - 4 x + x^2), x]
     = -Sqrt[3] Log[-2 + Sqrt[3] + x] / 6 + Sqrt[3] Log[-2 - Sqrt[3] + x] / 6
    >> Integrate[4 Sin[x] Cos[x], x]
     = 2 Sin[x] ^ 2

    ## This should better return -Infinity:
    #> Integrate[-Infinity, {x, 0, Infinity}]
     = Indeterminate


    Integration in TeX:
    >> Integrate[f[x], {x, a, b}] // TeXForm
     = \int_a^bf\left[x\right] \, dx

    #> DownValues[Integrate]
     = {}
    #> Definition[Integrate]
     = Attributes[Integrate] = {Protected, ReadProtected}
    #> Integrate[Hold[x + x], {x, a, b}]
     = Integrate[Hold[x + x], {x, a, b}]
    #> Integrate[sin[x], x]
     = Integrate[sin[x], x]

    #> Integrate[x ^ 3.5 + x, x]
     = x ^ 2 / 2 + 0.222222222222222222 x ^ 4.5

    #> Integrate[Abs[Sin[phi]],{phi,0,2Pi}]//N
     = 4.

    #> Integrate[1/(x^5+1), x]
     = RootSum[625 #1 ^ 4 + 125 #1 ^ 3 + 25 #1 ^ 2 + 5 #1 + 1&, Log[x + 5 #1] #1&] + Log[1 + x] / 5

    #> Integrate[ArcTan(x), x]
     = ArcTan x ^ 2 / 2
    #> Integrate[E[x], x]
     = Integrate[E[x], x]

    #> Integrate[Exp[-(x/2)^2],{x,-Infinity,+Infinity}]
     = 2 Sqrt[Pi]

    #> Integrate[Exp[-1/(x^2)], x]
     = Sqrt[Pi] Erf[1 / x] + x E ^ (-1 / x ^ 2)

    >> Integrate[ArcSin[x / 3], x]
     = x ArcSin[x / 3] + Sqrt[9 - x ^ 2]

    >> Integrate[f'[x], {x, a, b}]
     = -f[a] + f[b]
    """

    # TODO
    """
    >> Integrate[Sqrt[Tan[x]], x]
     = 1/4 Log[1 + Tan[x] - Sqrt[2] Sqrt[Tan[x]]] Sqrt[2] + 1/2 ArcTan[-1/2 (Sqrt[2] - 2 Sqrt[Tan[x]]) Sqrt[2]] Sqrt[2] + 1/2 ArcTan[1/2 (Sqrt[2] + 2 Sqrt[Tan[x]]) Sqrt[2]] Sqrt[2] - 1/4 Log[1 + Tan[x] + Sqrt[2] Sqrt[Tan[x]]] Sqrt[2]
    #> Integrate[x/Exp[x^2/t], {x, 0, Infinity}]
     = ConditionalExpression[-, Re[t] > 0]
    >> Integrate[f'[x], {x, a, b}]
     = f[b] - f[a]
    """

    attributes = ('ReadProtected',)

    sympy_name = 'Integral'

    messages = {
        'idiv': "Integral of `1` does not converge on `2`.",
        'ilim': "Invalid integration variable or limit(s).",

        'iconstraints': "Additional constraints needed: `1`",
    }

    rules = {
        'Integrate[list_List, x_]': 'Integrate[#, x]& /@ list',

        'MakeBoxes[Integrate[f_, x_], form:StandardForm|TraditionalForm]':
        r'''RowBox[{"\[Integral]", MakeBoxes[f, form], "\[InvisibleTimes]",
                RowBox[{"\[DifferentialD]", MakeBoxes[x, form]}]}]''',
        'MakeBoxes[Integrate[f_, {x_, a_, b_}], '
        'form:StandardForm|TraditionalForm]':
        r'''RowBox[{SubsuperscriptBox["\[Integral]", MakeBoxes[a, form],
                MakeBoxes[b, form]], MakeBoxes[f, form], "\[InvisibleTimes]",
                RowBox[{"\[DifferentialD]", MakeBoxes[x, form]}]}]''',
    }

    def prepare_sympy(self, leaves):
        if len(leaves) == 2:
            x = leaves[1]
            if x.has_form('List', 3):
                return [leaves[0]] + x.leaves
        return leaves

    def from_sympy(self, leaves):
        args = []
        for leaf in leaves[1:]:
            if leaf.has_form('List', 1):
                # {x} -> x
                args.append(leaf.leaves[0])
            else:
                args.append(leaf)
        return [leaves[0]] + args

    def apply(self, f, xs, evaluation):
        'Integrate[f_, xs__]'

        f_sympy = f.to_sympy()
        if isinstance(f_sympy, SympyExpression):
            return
        xs = xs.get_sequence()
        vars = []
        prec = None
        for x in xs:
            if x.has_form('List', 3):
                x, a, b = x.leaves
                prec_a = a.get_precision()
                prec_b = b.get_precision()
                if prec_a is not None and prec_b is not None:
                    prec_new = min(prec_a, prec_b)
                    if prec is None or prec_new < prec:
                        prec = prec_new
                a = a.to_sympy()
                b = b.to_sympy()
            else:
                a = b = None
                a_mathics, b_mathics = a, b
            if not x.get_name():
                evaluation.message('Integrate', 'ilim')
                return
            x = x.to_sympy()
            if a is None or b is None:
                vars.append(x)
            else:
                vars.append((x, a, b))
        try:
            result = sympy.integrate(f_sympy, *vars)
        except sympy.PolynomialError:
            return
        except ValueError:
            # e.g. ValueError: can't raise polynomial to a negative power
            return
        except NotImplementedError:
            # e.g. NotImplementedError: Result depends on the sign of
            # -sign(_Mathics_User_j)*sign(_Mathics_User_w)
            return

        if prec is not None:
            result = sympy.N(result)
        result = from_sympy(result)
        return result


class Solve(Builtin):
    """
    <dl>
    <dt>'Solve[$equation$, $vars$]'
        <dd>attempts to solve $equation$ for the variables $vars$.
    <dt>'Solve[$equation$, $vars$, $domain$]'
        <dd>restricts variables to $domain$, which can be 'Complexes' or 'Reals'.
    </dl>

    >> Solve[x ^ 2 - 3 x == 4, x]
     = {{x -> -1}, {x -> 4}}
    >> Solve[4 y - 8 == 0, y]
     = {{y -> 2}}

    Apply the solution:
    >> sol = Solve[2 x^2 - 10 x - 12 == 0, x]
     = {{x -> -1}, {x -> 6}}
    >> x /. sol
     = {-1, 6}

    Contradiction:
    >> Solve[x + 1 == x, x]
     = {}
    Tautology:
    >> Solve[x ^ 2 == x ^ 2, x]
     = {{}}

    Rational equations:
    >> Solve[x / (x ^ 2 + 1) == 1, x]
     = {{x -> 1 / 2 - I / 2 Sqrt[3]}, {x -> 1 / 2 + I / 2 Sqrt[3]}}
    >> Solve[(x^2 + 3 x + 2)/(4 x - 2) == 0, x]
     = {{x -> -2}, {x -> -1}}

    Transcendental equations:
    >> Solve[Cos[x] == 0, x]
     = {{x -> Pi / 2}, {x -> 3 Pi / 2}}

    Solve can only solve equations with respect to symbols or functions:
    >> Solve[f[x + y] == 3, f[x + y]]
     = {{f[x + y] -> 3}}
    >> Solve[a + b == 2, a + b]
     : a + b is not a valid variable.
     = Solve[a + b == 2, a + b]
    This happens when solving with respect to an assigned symbol:
    >> x = 3;
    >> Solve[x == 2, x]
     : 3 is not a valid variable.
     = Solve[False, 3]
    >> Clear[x]
    >> Solve[a < b, a]
     : a < b is not a well-formed equation.
     = Solve[a < b, a]

    Solve a system of equations:
    >> eqs = {3 x ^ 2 - 3 y == 0, 3 y ^ 2 - 3 x == 0};
    >> sol = Solve[eqs, {x, y}]
     = {{x -> 0, y -> 0}, {x -> 1, y -> 1}, {x -> (-1 / 2 - I / 2 Sqrt[3]) ^ 2, y -> -1 / 2 - I / 2 Sqrt[3]}, {x -> (-1 / 2 + I / 2 Sqrt[3]) ^ 2, y -> -1 / 2 + I / 2 Sqrt[3]}}
    >> eqs /. sol // Simplify
     = {{True, True}, {True, True}, {True, True}, {True, True}}

    An underdetermined system:
    >> Solve[x^2 == 1 && z^2 == -1, {x, y, z}]
     : Equations may not give solutions for all "solve" variables.
     = {{x -> -1, z -> -I}, {x -> -1, z -> I}, {x -> 1, z -> -I}, {x -> 1, z -> I}}

    Domain specification:
    >> Solve[x^2 == -1, x, Reals]
     = {}
    >> Solve[x^2 == 1, x, Reals]
     = {{x -> -1}, {x -> 1}}
    >> Solve[x^2 == -1, x, Complexes]
     = {{x -> -I}, {x -> I}}

    #> Solve[x^2 +1 == 0, x] // FullForm
     = List[List[Rule[x, Complex[0, -1]]], List[Rule[x, Complex[0, 1]]]]

    #> Solve[x^5==x,x]
     = {{x -> -1}, {x -> 0}, {x -> 1}, {x -> -I}, {x -> I}}

    #> Solve[g[x] == 0, x]
     = Solve[g[x] == 0, x]
    ## (should use inverse functions, actually!)
    #> Solve[g[x] + h[x] == 0, x]
     = Solve[g[x] + h[x] == 0, x]

    #> Solve[Sin(x) == 1, x]
     = {{x -> 1 / Sin}}

    #> Solve[E == 1, E]
     : E is not a valid variable.
     = Solve[False, E]
    #> Solve[False, Pi]
     : Pi is not a valid variable.
     = Solve[False, Pi]

    ## Issue63
    #> Solve[{(7+x)*ma == 167, (5+x)*mb == 167, (7+5)*(ma+mb) == 334}, {ma, mb, x}]
     = {{ma -> 1169 / 12 - 167 Sqrt[37] / 12, mb -> -835 / 12 + 167 Sqrt[37] / 12, x -> Sqrt[37]}, {ma -> 1169 / 12 + 167 Sqrt[37] / 12, mb -> -835 / 12 - 167 Sqrt[37] / 12, x -> -Sqrt[37]}}
    #> Solve[{(7+x)*ma == 167, (5+x)*mb == 167, (7+5)*(ma+mb) == 334}, {x, ma, mb}]
     = {{x -> -Sqrt[37], ma -> 1169 / 12 + 167 Sqrt[37] / 12, mb -> -835 / 12 - 167 Sqrt[37] / 12}, {x -> Sqrt[37], ma -> 1169 / 12 - 167 Sqrt[37] / 12, mb -> -835 / 12 + 167 Sqrt[37] / 12}}
    """

    messages = {
        'eqf': "`1` is not a well-formed equation.",
        'svars': 'Equations may not give solutions for all "solve" variables.',
    }

    rules = {
        'Solve[eqs_, vars_, Complexes]': 'Solve[eqs, vars]',
        'Solve[eqs_, vars_, Reals]': (
            'Cases[Solve[eqs, vars], {Rule[x,y_?RealNumberQ]}]'),
    }

    def apply(self, eqs, vars, evaluation):
        'Solve[eqs_, vars_]'

        vars_original = vars
        head_name = vars.get_head_name()
        if head_name == 'List':
            vars = vars.leaves
        else:
            vars = [vars]
        for var in vars:
            if ((var.is_atom() and not var.is_symbol()) or  # noqa
                head_name in ('Plus', 'Times', 'Power') or
                'Constant' in var.get_attributes(evaluation.definitions)):

                evaluation.message('Solve', 'ivar', vars_original)
                return
        eqs_original = eqs
        if eqs.get_head_name() in ('List', 'And'):
            eqs = eqs.leaves
        else:
            eqs = [eqs]
        sympy_eqs = []
        sympy_denoms = []
        for eq in eqs:
            symbol_name = eq.get_name()
            if symbol_name == 'True':
                pass
            elif symbol_name == 'False':
                return Expression('List')
            elif not eq.has_form('Equal', 2):
                return evaluation.message('Solve', 'eqf', eqs_original)
            else:
                left, right = eq.leaves
                left = left.to_sympy()
                right = right.to_sympy()
                eq = left - right
                eq = sympy.together(eq)
                eq = sympy.cancel(eq)
                sympy_eqs.append(eq)
                numer, denom = eq.as_numer_denom()
                sympy_denoms.append(denom)

        vars_sympy = [var.to_sympy() for var in vars]

        # delete unused variables to avoid SymPy's
        # PolynomialError: Not a zero-dimensional system
        # in e.g. Solve[x^2==1&&z^2==-1,{x,y,z}]
        all_vars = vars[:]
        all_vars_sympy = vars_sympy[:]
        vars = []
        vars_sympy = []
        for var, var_sympy in zip(all_vars, all_vars_sympy):
            pattern = Pattern.create(var)
            if not eqs_original.is_free(pattern, evaluation):
                vars.append(var)
                vars_sympy.append(var_sympy)

        def transform_dict(sols):
            if not sols:
                yield sols
            for var, sol in sols.iteritems():
                rest = sols.copy()
                del rest[var]
                rest = transform_dict(rest)
                if not isinstance(sol, (tuple, list)):
                    sol = [sol]
                if not sol:
                    for r in rest:
                        yield r
                else:
                    for r in rest:
                        for item in sol:
                            new_sols = r.copy()
                            new_sols[var] = item
                            yield new_sols
                break

        def transform_solution(sol):
            if not isinstance(sol, dict):
                if not isinstance(sol, (list, tuple)):
                    sol = [sol]
                sol = dict(zip(vars_sympy, sol))
            return transform_dict(sol)

        if not sympy_eqs:
            sympy_eqs = True
        elif len(sympy_eqs) == 1:
            sympy_eqs = sympy_eqs[0]

        try:
            if isinstance(sympy_eqs, bool):
                result = sympy_eqs
            else:
                result = sympy.solve(sympy_eqs, vars_sympy)
            if not isinstance(result, list):
                result = [result]
            if result == [True]:
                return Expression('List', Expression('List'))
            if result == [None]:
                return Expression('List')
            results = []
            for sol in result:
                results.extend(transform_solution(sol))
            result = results
            if any(sol and any(var not in sol for var in all_vars_sympy)
                   for sol in result):
                evaluation.message('Solve', 'svars')

            # Filter out results for which denominator is 0
            result = [sol for sol in result if all(sympy.simplify(
                denom.subs(sol)) != 0 for denom in sympy_denoms)]
                # (SymPy should actually do that itself, but it doesn't!)
            return Expression('List', *(Expression(
                'List',
                *(Expression('Rule', var, from_sympy(sol[var_sympy]))
                  for var, var_sympy in zip(vars, vars_sympy)
                  if var_sympy in sol)
            ) for sol in result))
        except sympy.PolynomialError:
            # raised for e.g. Solve[x^2==1&&z^2==-1,{x,y,z}] when not deleting
            # unused variables beforehand
            pass
        except NotImplementedError:
            pass
        except TypeError, exc:
            if str(exc).startswith("expected Symbol, Function or Derivative"):
                evaluation.message('Solve', 'ivar', vars_original)


class Limit(Builtin):
    """
    <dl>
    <dt>'Limit[$expr$, $x$->$x0$]'
        <dd>gives the limit of $expr$ as $x$ approaches $x0$.
    <dt>'Limit[$expr$, $x$->$x0$, Direction->1]'
        <dd>approaches $x0$ from smaller values.
    <dt>'Limit[$expr$, $x$->$x0$, Direction->-1]'
        <dd>approaches $x0$ from larger values.
    </dl>

    >> Limit[x, x->2]
     = 2
    >> Limit[Sin[x] / x, x->0]
     = 1
    >> Limit[1/x, x->0, Direction->-1]
     = Infinity
    >> Limit[1/x, x->0, Direction->1]
     = -Infinity

    #> Limit[(1 + cos[x]) / x, x -> 0]
     = Limit[(1 + cos[x]) / x, x -> 0]
    """

    attributes = ('Listable',)

    options = {
        'Direction': '1',
    }

    messages = {
        'ldir': "Value of Direction -> `1` should be -1 or 1.",
    }

    def apply(self, expr, x, x0, evaluation, options={}):
        'Limit[expr_, x_->x0_, OptionsPattern[Limit]]'

        expr = expr.to_sympy()
        x = x.to_sympy()
        x0 = x0.to_sympy()

        direction = self.get_option(options, 'Direction', evaluation)
        value = direction.get_int_value()
        if value not in (-1, 1):
            evaluation.message('Limit', 'ldir', direction)
        if value > 0:
            dir_sympy = '-'
        else:
            dir_sympy = '+'

        try:
            result = sympy.limit(expr, x, x0, dir_sympy)
            return from_sympy(result)
        except sympy.PoleError:
            pass
        except RuntimeError:
            # Bug in Sympy: RuntimeError: maximum recursion depth exceeded
            # while calling a Python object
            pass
        except NotImplementedError:
            pass


class FindRoot(Builtin):
    r"""
    <dl>
    <dt>'FindRoot[$f$, {$x$, $x0$}]'
        <dd>searches for a numerical root of $f$, starting from '$x$=$x0$'.
    <dt>'FindRoot[$lhs$ == $rhs$, {$x$, $x0$}]'
        <dd>tries to solve the equation '$lhs$ == $rhs$'.
    </dl>

    'FindRoot' uses Newton\'s method, so the function of interest should have a first derivative.

    >> FindRoot[Cos[x], {x, 1}]
     = {x -> 1.57079632679489662}
    >> FindRoot[Sin[x] + Exp[x],{x, 0}]
     = {x -> -0.588532743981861077}

    >> FindRoot[Sin[x] + Exp[x] == Pi,{x, 0}]
     = {x -> 0.866815239911458064}

    'FindRoot' has attribute 'HoldAll' and effectively uses 'Block' to localize $x$.
    However, in the result $x$ will eventually still be replaced by its value.
    >> x = 3;
    >> FindRoot[Tan[x] + Sin[x] == Pi, {x, 1}]
     = {3 -> 1.14911295431426855}
    >> Clear[x]

    'FindRoot' stops after 100 iterations:
    >> FindRoot[x^2 + x + 1, {x, 1}]
     : The maximum number of iterations was exceeded. The result might be inaccurate.
     = {x -> -1.}

    Find complex roots:
    >> FindRoot[x ^ 2 + x + 1, {x, -I}]
     = {x -> -0.5 - 0.866025403784438647 I}

    The function has to return numerical values:
    >> FindRoot[f[x] == 0, {x, 0}]
     : The function value is not a number at x = 0..
     = FindRoot[f[x] - 0, {x, 0}]

    The derivative must not be 0:
    >> FindRoot[Sin[x] == x, {x, 0}]
     : Encountered a singular derivative at the point x = 0..
     = FindRoot[Sin[x] - x, {x, 0}]

    #> FindRoot[2.5==x,{x,0}]
     = {x -> 2.5}
    """

    attributes = ('HoldAll',)

    messages = {
        'snum': "Value `1` is not a number.",
        'nnum': "The function value is not a number at `1` = `2`.",
        'dsing': "Encountered a singular derivative at the point `1` = `2`.",
        'maxiter': ("The maximum number of iterations was exceeded. "
                    "The result might be inaccurate."),
    }

    rules = {
        'FindRoot[lhs_ == rhs_, {x_, xs_}]': 'FindRoot[lhs - rhs, {x, xs}]',
    }

    def apply(self, f, x, x0, evaluation):
        'FindRoot[f_, {x_, x0_}]'

        x0 = Expression('N', x0).evaluate(evaluation)
        if not isinstance(x0, Number):
            evaluation.message('FindRoot', 'snum', x0)
            return
        x_name = x.get_name()
        if not x_name:
            evaluation.message('FindRoot', 'sym', x, 2)
            return
        count = 0

        def diff(evaluation):
            return Expression('D', f, x).evaluate(evaluation)

        d = dynamic_scoping(diff, {x_name: None}, evaluation)

        def sub(evaluation):
            d_value = d.evaluate(evaluation)
            if d_value == Integer(0):
                return None
            return Expression('Times', f, Expression(
                'Power', d_value, Integer(-1))).evaluate(evaluation)

        while count < 100:
            minus = dynamic_scoping(sub, {x_name: x0}, evaluation)
            if minus is None:
                evaluation.message('FindRoot', 'dsing', x_name, x0)
                return
            x1 = Expression('Plus', x0, Expression(
                'Times', Integer(-1), minus)).evaluate(evaluation)
            if not isinstance(x1, Number):
                evaluation.message('FindRoot', 'nnum', x_name, x0)
                return
            if x1 == x0:
                break
            x0 = Expression('N', x1).evaluate(
                evaluation)       # N required due to bug in sympy arithmetic
            count += 1
        else:
            evaluation.message('FindRoot', 'maxiter')

        return Expression('List', Expression('Rule', x, x0))

########NEW FILE########
__FILENAME__ = combinatorial
# -*- coding: utf8 -*-

from __future__ import with_statement

import sympy

from mathics.builtin.base import Builtin
from mathics.core.expression import Expression, Integer
from mathics.builtin.arithmetic import _MPMathFunction


class Fibonacci(Builtin):
    """
    <dl>
    <dt>'Fibonacci[$n$]'
        <dd>computes the $n$th Fibonacci number.
    </dl>

    >> Fibonacci[0]
     = 0
    >> Fibonacci[1]
     = 1
    >> Fibonacci[10]
     = 55
    >> Fibonacci[200]
     = 280571172992510140037611932413038677189525
    """

    attributes = ('Listable', 'NumericFunction', 'ReadProtected')

    def apply(self, n, evaluation):
        'Fibonacci[n_Integer]'

        return Integer(sympy.fibonacci(n.to_sympy()))


class Binomial(_MPMathFunction):
    """
    <dl>
    <dt>'Binomial[$n$, $k$]'
        <dd>gives the binomial coefficient $n$ choose $k$.
    </dl>

    >> Binomial[5, 3]
     = 10

    'Binomial' supports inexact numbers:
    >> Binomial[10.5,3.2]
     = 165.286109367256421

    Some special cases:
    >> Binomial[10, -2]
     = 0
    >> Binomial[-10.5, -3.5]
     = 0.
    >> Binomial[-10, -3.5]
     = ComplexInfinity
    """

    attributes = ('Listable', 'NumericFunction')

    nargs = 2
    sympy_name = 'binomial'
    mpmath_name = 'binomial'


class Multinomial(Builtin):
    """
    <dl>
    <dt>'Multinomial[$n1$, $n2$, ...]'
        <dd>gives the multinomial coefficient '($n1$+$n2$+...)!/($n1$!$n2$!...)'.
    </dl>

    >> Multinomial[2, 3, 4, 5]
     = 2522520
    >> Multinomial[]
     = 1
    Multinomial is expressed in terms of 'Binomial':
    >> Multinomial[a, b, c]
     = Binomial[a + b, b] Binomial[a + b + c, c]
    'Multinomial[$n$-$k$, $k$]' is equivalent to 'Binomial[$n$, $k$]'.
    >> Multinomial[2, 3]
     = 10
    """

    attributes = ('Listable', 'NumericFunction', 'Orderless')

    def apply(self, values, evaluation):
        'Multinomial[values___]'

        values = values.get_sequence()
        result = Expression('Times')
        total = []
        for value in values:
            total.append(value)
            result.leaves.append(Expression(
                'Binomial', Expression('Plus', *total), value))
        return result

########NEW FILE########
__FILENAME__ = comparison
# -*- coding: utf8 -*-

import sympy

from mathics.builtin.base import Builtin, BinaryOperator, Test, SympyFunction
from mathics.core.expression import (Expression, Number, Integer, Rational,
                                     Real, Symbol, String)
from mathics.core.numbers import get_type, dps


class SameQ(BinaryOperator):
    """
    >> a===a
     = True
    >> 1===1
     = True
    >> 1===1.
     = False
    """

    operator = '==='
    precedence = 290

    def apply(self, lhs, rhs, evaluation):
        'lhs_ === rhs_'

        if lhs.same(rhs):
            return Symbol('True')
        else:
            return Symbol('False')


class UnsameQ(BinaryOperator):
    """
    >> a=!=a
     = False
    >> 1=!=1.
     = True
    """

    operator = '=!='
    precedence = 290

    def apply(self, lhs, rhs, evaluation):
        'lhs_ =!= rhs_'

        if lhs.same(rhs):
            return Symbol('False')
        else:
            return Symbol('True')

operators = {
    'Less': (-1,),
    'LessEqual': (-1, 0),
    'Equal': (0,),
    'GreaterEqual': (0, 1),
    'Greater': (1,),
    'Unequal': (-1, 1),
}


class _InequalityOperator(BinaryOperator):
    precedence = 290
    grouping = 'NonAssociative'

    def parse(self, args):
        names = operators.keys()

        def inequality_leaves(expression):
            if expression.parenthesized:
                return [expression]
            name = expression.get_head().get_name()
            leaves = expression.get_leaves()
            if name == 'Inequality':
                return leaves
            elif name in names:
                result = []
                for leaf in leaves[:-1]:
                    result.extend([leaf, Symbol(name)])
                result.extend(leaves[-1:])
                return result
            else:
                return [expression]

        left = args[0]
        right = args[2]
        name = self.get_name()

        left_leaves = inequality_leaves(left)
        right_leaves = inequality_leaves(right)
        leaves = left_leaves + [Symbol(name)] + right_leaves
        ops = set(leaves[1::2])
        if len(ops) == 1:
            return Expression(ops.pop(), *leaves[0::2])
        else:
            return Expression('Inequality', *leaves)

    def apply(self, items, evaluation):
        '%(name)s[items__]'

        items_sequence = items.get_sequence()
        all_numeric = all(item.is_numeric() and item.get_precision() is None
                          for item in items_sequence)

        # All expressions are numeric but exact and they are not all numbers,
        if all_numeric and any(not isinstance(item, Number)
                               for item in items_sequence):
            # so apply N and compare them.
            items = items_sequence
            n_items = []
            for item in items:
                if not isinstance(item, Number):
                    # TODO: use $MaxExtraPrecision insterad of hard-coded 50
                    n_expr = Expression('N', item, Integer(50))
                    item = n_expr.evaluate(evaluation)
                n_items.append(item)
            items = n_items
        else:
            items = items.numerify(evaluation).get_sequence()
        wanted = operators[self.get_name()]
        prev = None
        for item in items:
            if (item.get_real_value() is None   # noqa
                and not item.has_form('DirectedInfinity', None)):
                return
            if prev is not None and do_cmp(prev, item) not in wanted:
                return Symbol('False')
            prev = item
        return Symbol('True')


class Inequality(Builtin):
    """
    'Inequality' is the head of expressions involving different inequality operators (at least temporarily).
    Thus, it is possible to write chains of inequalities.
    >> a < b <= c
     = a < b && b <= c
    >> Inequality[a, Greater, b, LessEqual, c]
     = a > b && b <= c
    >> 1 < 2 <= 3
     = True
    >> 1 < 2 > 0
     = True
    >> 1 < 2 < -1
     = False
    """

    messages = {
        'ineq': ("Inequality called with `` arguments; the number of "
                 "arguments is expected to be an odd number >= 3."),
    }

    def apply(self, items, evaluation):
        'Inequality[items___]'

        items = items.numerify(evaluation).get_sequence()
        count = len(items)
        if count == 1:
            return Symbol('True')
        elif count % 2 == 0:
            evaluation.message('Inequality', 'ineq', count)
        elif count == 3:
            name = items[1].get_name()
            if name in operators.keys():
                return Expression(name, items[0], items[2])
        else:
            groups = [Expression('Inequality', *items[index - 1:index + 2])
                      for index in range(1, count - 1, 2)]
            return Expression('And', *groups)


def numerify(vars, evaluation):
    return Expression('List', *vars).numerify(evaluation).leaves


def do_cmp(x1, x2):
    real1, real2 = x1.get_real_value(), x2.get_real_value()
    inf1 = inf2 = None
    if x1.has_form('DirectedInfinity', 1):
        inf1 = x1.leaves[0].get_int_value()
    if x2.has_form('DirectedInfinity', 1):
        inf2 = x2.leaves[0].get_int_value()

    if real1 is not None and get_type(real1) != 'f':
        real1 = sympy.Float(real1)
    if real2 is not None and get_type(real2) != 'f':
        real2 = sympy.Float(real2)
    # Bus error when not converting to mpf

    if real1 is not None and real2 is not None:
        return cmp(x1, x2)
    elif inf1 is not None and inf2 is not None:
        return cmp(inf1, inf2)
    elif inf1 is not None and real2 is not None:
        return inf1
    elif real1 is not None and inf2 is not None:
        return -inf2
    else:
        return None


def do_compare(l1, l2):
    if l1.same(l2):
        return True
    elif isinstance(l1, String) and isinstance(l2, String):
        return False
    elif l1.to_sympy().is_number and l2.to_sympy().is_number:
        # assert min_prec(l1, l2) is None
        prec = 64  # TODO: Use $MaxExtraPrecision
        if l1.to_sympy().n(dps(prec)) == l2.to_sympy().n(dps(prec)):
            return True
        return False
    elif l1.has_form('List', None) and l2.has_form('List', None):
        if len(l1.leaves) != len(l2.leaves):
            return False
        for item1, item2 in zip(l1.leaves, l2.leaves):
            result = do_compare(item1, item2)
            if not result:
                return result
        return True
    else:
        return None


class Equal(_InequalityOperator, SympyFunction):
    """
    >> a==a
     = True
    >> a==b
     = a == b
    >> 1==1.
     = True

    Lists are compared based on their elements:
    >> {{1}, {2}} == {{1}, {2}}
     = True
    >> {1, 2} == {1, 2, 3}
     = False

    Real values are considered equal if they only differ in their last digits:
    >> 0.739085133215160642 == 0.739085133215160641
     = True
    >> 0.73908513321516064200000000 == 0.73908513321516064100000000
     = False

    >> 0.1 ^ 10000 == 0.1 ^ 10000 + 0.1 ^ 10016
     = False
    >> 0.1 ^ 10000 == 0.1 ^ 10000 + 0.1 ^ 10017
     = True

    ## TODO: Needs ^^ opperator

    ## Real numbers are considered equal if they only differ in their last seven binary digits
    ## #> 2^^1.000000000000000000000000000000000000000000000000000000000000 ==  2^^1.000000000000000000000000000000000000000000000000000001111111
    ##  = True
    ## 2^^1.000000000000000000000000000000000000000000000000000000000000 ==  2^^1.000000000000000000000000000000000000000000000000000010000000
    ##  = False

    Comparisons are done using the lower precision:
    >> N[E, 100] == N[E, 150]
     = True

    Symbolic constants are compared numerically:
    >> E > 1
     = True
    >> Pi == 3.14
     = False

    #> Pi ^ E == E ^ Pi
     = False

    #> N[E, 3] == N[E]
     = True

    #> {1, 2, 3} < {1, 2, 3}
     = {1, 2, 3} < {1, 2, 3}

    #> E == N[E]
     = True
    """
    operator = '=='
    grouping = 'None'

    sympy_name = 'Eq'

    def apply_other(self, x, y, evaluation):
        'Equal[x_?(!RealNumberQ[#]&), y_?(!RealNumberQ[#]&)]'

        x, y = numerify([x, y], evaluation)
        result = do_compare(x, y)
        if result is not None:
            if result:
                return Symbol('True')
            else:
                return Symbol('False')


class Unequal(_InequalityOperator, SympyFunction):
    """
    >> 1 != 1.
     = False

    Lists are compared based on their elements:
    >> {1} != {2}
     = True
    >> {1, 2} != {1, 2}
     = False
    >> {a} != {a}
     = False
    >> "a" != "b"
     = True
    >> "a" != "a"
     = False

    #> Pi != N[Pi]
     = False

    #> a_ != b_
     = a_ != b_
    """

    operator = '!='

    sympy_name = 'Ne'

    def apply_other(self, x, y, evaluation):
        'Unequal[x_?(!RealNumberQ[#]&), y_?(!RealNumberQ[#]&)]'

        x, y = numerify([x, y], evaluation)
        result = do_compare(x, y)
        if result is not None:
            if result:
                return Symbol('False')
            else:
                return Symbol('True')


class Less(_InequalityOperator, SympyFunction):
    operator = '<'
    sympy_name = 'StrictLessThan'


class LessEqual(_InequalityOperator, SympyFunction):
    operator = '<='
    sympy_name = 'LessThan'


class Greater(_InequalityOperator, SympyFunction):
    """
    >> a > b > c //FullForm
     = Greater[a, b, c]
    >> Greater[3, 2, 1]
     = True
    """

    operator = '>'
    sympy_name = 'StrictGreaterThan'


class GreaterEqual(_InequalityOperator, SympyFunction):
    operator = '>='
    sympy_name = 'GreaterThan'


class Positive(Test):
    def test(self, expr):
        return isinstance(expr, (Integer, Rational, Real)) and expr.value > 0


class Negative(Test):
    """
    >> Negative[-3]
     = True
    >> Negative[10/7]
     = False
    >> Negative[1+2I]
     = False
    >> Negative[a+b]
     = False
    """

    def test(self, expr):
        return isinstance(expr, (Integer, Rational, Real)) and expr.value < 0


class NonNegative(Test):
    def test(self, expr):
        return isinstance(expr, (Integer, Rational, Real)) and expr.value >= 0


class NonPositive(Test):
    def test(self, expr):
        return isinstance(expr, (Integer, Rational, Real)) and expr.value <= 0


def expr_max(items):
    result = Expression('DirectedInfinity', -1)
    for item in items:
        c = do_cmp(item, result)
        if c > 0:
            result = item
    return result


def expr_min(items):
    result = Expression('DirectedInfinity', 1)
    for item in items:
        c = do_cmp(item, result)
        if c < 0:
            result = item
    return result


class Max(Builtin):
    """
    >> Max[4, -8, 1]
     = 4
    >> Max[{1,2},3,{-3,3.5,-Infinity},{{1/2}}]
     = 3.5

    #> Max[]
     = -Infinity
    """

    attributes = ('Flat', 'NumericFunction', 'OneIdentity', 'Orderless')

    def apply(self, items, evaluation):
        'Max[items___]'

        items = items.flatten(Symbol('List')).get_sequence()
        result = Expression('DirectedInfinity', -1)
        for item in items:
            if item.has_form('List', None):
                leaves = item.leaves
            else:
                leaves = [item]
            for leaf in leaves:
                c = do_cmp(leaf, result)
                if c > 0:
                    result = leaf
        return result


class Min(Builtin):
    """
    >> Min[4, -8, 1]
     = -8
    >> Min[{1,2},3,{-3,3.5,-Infinity},{{1/2}}]
     = -Infinity

    #> Min[]
     = Infinity
    """

    attributes = ('Flat', 'NumericFunction', 'OneIdentity', 'Orderless')

    def apply(self, items, evaluation):
        'Min[items___]'

        items = items.flatten(Symbol('List')).get_sequence()
        result = Expression('DirectedInfinity', 1)
        for item in items:
            if item.has_form('List', None):
                leaves = item.leaves
            else:
                leaves = [item]
            for leaf in leaves:
                c = do_cmp(leaf, result)
                if c < 0:
                    result = leaf
        return result

########NEW FILE########
__FILENAME__ = control
# -*- coding: utf8 -*-

"""
Control statements
"""

from mathics.builtin.base import Builtin, BinaryOperator
from mathics.core.expression import Expression, Symbol, from_python
from mathics.core.evaluation import (
    AbortInterrupt, BreakInterrupt, ContinueInterrupt)

from mathics.builtin.lists import _IterationFunction
from mathics.builtin.patterns import match


class CompoundExpression(BinaryOperator):
    """
    <dl>
    <dt>'CompoundExpression[$e1$, $e2$, ...]' or '$e1$; $e2$; ...'
        <dd>evaluates its arguments in turn, returning the last result.
    </dl>
    >> a; b; c; d
     = d
    If the last argument is omitted, 'Null' is taken:
    >> a;

    ## Parser Tests
    #> FullForm[Hold[a ;]]
     = Hold[CompoundExpression[a, Null]]
    #> FullForm[Hold[a ; b]]
     = Hold[CompoundExpression[a, b]]
    #> FullForm[Hold[a ; b ;]]
     = Hold[CompoundExpression[a, b, Null]]
    #> FullForm[Hold[a ; b ; c]]
     = Hold[CompoundExpression[a, b, c]]
    #> FullForm[Hold[a ; ; c]]
     = Hold[CompoundExpression[a, Null, c]]
    #> FullForm[Hold[a ; ;]]
     = Hold[CompoundExpression[a, Null, Null]]
    #> FullForm[Hold[; a]]
     : Parse error at or near token ;.
    #> FullForm[Hold[; a ;]]
     : Parse error at or near token ;.
    """

    operator = ';'
    precedence = 10
    attributes = ('HoldAll', 'ReadProtected')

    def apply(self, expr, evaluation):
        'CompoundExpression[expr___]'

        items = expr.get_sequence()
        result = Symbol('Null')
        for expr in items:
            result = expr.evaluate(evaluation)
        return result


class If(Builtin):
    """
    <dl>
    <dt>'If[$cond$, $pos$, $neg$]'
        <dd>returns $pos$ if $cond$ evaluates to 'True', and $neg$ if it evaluates to 'False'.
    <dt>'If[$cond$, $pos$, $neg$, $other$]'
        <dd>returns $other$ if $cond$ evaluates to neither 'True' nor 'False'.
    <dt>'If[$cond$, $pos$]'
        <dd>returns 'Null' if $cond$ evaluates to 'False'.
    </dl>
    >> If[1<2, a, b]
     = a
    If the second branch is not specified, 'Null' is taken:
    >> If[1<2, a]
     = a
    >> If[False, a] //FullForm
     = Null

    You might use comments (inside '(*' and '*)') to make the branches of 'If' more readable:
    >> If[a, (*then*) b, (*else*) c];
    """

    attributes = ('HoldRest',)

    def apply_2(self, condition, t, evaluation):
        'If[condition_, t_]'

        name = condition.get_name()
        if name == 'True':
            return t.evaluate(evaluation)
        elif name == 'False':
            return Symbol('Null')

    def apply_3(self, condition, t, f, evaluation):
        'If[condition_, t_, f_]'

        name = condition.get_name()
        if name == 'True':
            return t.evaluate(evaluation)
        elif name == 'False':
            return f.evaluate(evaluation)

    def apply_4(self, condition, t, f, u, evaluation):
        'If[condition_, t_, f_, u_]'

        name = condition.get_name()
        if name == 'True':
            return t.evaluate(evaluation)
        elif name == 'False':
            return f.evaluate(evaluation)
        else:
            return u.evaluate(evaluation)


class Switch(Builtin):
    """
    <dl>
    <dt>'Switch[$expr$, $pattern1$, $value1$, $pattern2$, $value2$, ...]'
        <dd>yields the first $value$ for which $expr matches the corresponding $pattern$.
    </dl>

    >> Switch[2, 1, x, 2, y, 3, z]
     = y
    >> Switch[5, 1, x, 2, y]
     = Switch[5, 1, x, 2, y]
    >> Switch[5, 1, x, 2, y, _, z]
     = z
    >> Switch[2, 1]
     : Switch called with 2 arguments. Switch must be called with an odd number of arguments.
     = Switch[2, 1]

    #> a; Switch[b, b]
     : Switch called with 2 arguments. Switch must be called with an odd number of arguments.
     = Switch[b, b]
    """

    attributes = ('HoldRest',)

    messages = {
        'argct': ("Switch called with `2` arguments. "
                  "Switch must be called with an odd number of arguments."),
    }

    def apply(self, expr, rules, evaluation):
        'Switch[expr_, rules___]'

        rules = rules.get_sequence()
        if len(rules) % 2 != 0:
            evaluation.message('Switch', 'argct', 'Switch', len(rules) + 1)
            return
        for pattern, value in zip(rules[::2], rules[1::2]):
            if match(expr, pattern, evaluation):
                return value.evaluate(evaluation)
        # return unevaluated Switch when no pattern matches


class Which(Builtin):
    """
    <dl>
    <dt>'Which[$cond1$, $expr1$, $cond2$, $expr2$, ...]'
        <dd>yields $expr1$ if $cond1$ evaluates to 'True', $expr2$ if $cond2$ evaluates to 'True', etc.
    </dl>
    >> n = 5;
    >> Which[n == 3, x, n == 5, y]
     = y
    >> f[x_] := Which[x < 0, -x, x == 0, 0, x > 0, x]
    >> f[-3]
     = 3
    If no test yields 'True', 'Which' returns 'Null':
    >> Which[False, a]

    'Which' must be called with an even number of arguments:
    >> Which[a, b, c]
     : Which called with 3 arguments.
     = Which[a, b, c]
    """

    attributes = ('HoldAll',)

    def apply(self, items, evaluation):
        'Which[items___]'

        items = items.get_sequence()
        if len(items) == 1:
            evaluation.message('Which', 'argctu', 'Which')
            return
        elif len(items) % 2 == 1:
            evaluation.message('Which', 'argct', 'Which', len(items))
            return
        for test, item in zip(items[::2], items[1::2]):
            if test.evaluate(evaluation).is_true():
                return item.evaluate(evaluation)
        return Symbol('Null')


class Do(_IterationFunction):
    """
    <dl>
    <dt>'Do[$expr$, {$max$}]'
        <dd>evaluates $expr$ $max$ times.
    <dt>'Do[$expr$, {$i$, $max$}]'
        <dd>evaluates $expr$ $max$ times, substituting $i$ in $expr$ with values from 1 to $max$.
    <dt>'Do[$expr$, {$i$, $min$, $max$}]'
        <dd>starts with '$i$ = $max$'.
    <dt>'Do[$expr$, {$i$, $min$, $max$, $step$}]'
        <dd>uses a step size of $step$.
    <dt>'Do[$expr$, {$i$, {$i1$, $i2$, ...}}]'
        <dd>uses values $i1$, $i2$, ... for $i$.
    <dt>'Do[$expr$, {$i$, $imin$, $imax$}, {$j$, $jmin$, $jmax$}, ...]'
        <dd>evaluates $expr$ for each $j$ from $jmin$ to $jmax$, for each $i$ from $imin$ to $imax$, etc.
    </dl>
    >> Do[Print[i], {i, 2, 4}]
     | 2
     | 3
     | 4
    >> Do[Print[{i, j}], {i,1,2}, {j,3,5}]
     | {1, 3}
     | {1, 4}
     | {1, 5}
     | {2, 3}
     | {2, 4}
     | {2, 5}
    You can use 'Break[]' and 'Continue[]' inside 'Do':
    >> Do[If[i > 10, Break[], If[Mod[i, 2] == 0, Continue[]]; Print[i]], {i, 5, 20}]
     | 5
     | 7
     | 9

    #> Do[Print["hi"],{1+1}]
     | hi
     | hi
    """

    allow_loopcontrol = True

    def get_result(self, items):
        return Symbol('Null')


class For(Builtin):
    """
    <dl>
    <dt>'For[$start$, $test$, $incr$, $body$]'
        <dd>evaluates $start$, and then iteratively $body$ and $incr$ as long as $test$ evaluates to 'True'.
    <dt>'For[$start$, $test$, $incr$]'
        <dd>evaluates only $incr$ and no $body$.
    <dt>'For[$start$, $test$]'
        <dd>runs the loop without any body.
    </dl>
    Compute the factorial of 10 using 'For':
    >> n := 1
    >> For[i=1, i<=10, i=i+1, n = n * i]
    >> n
     = 3628800
    >> n == 10!
     = True
    """

    attributes = ('HoldRest',)
    rules = {
        'For[start_, test_, incr_]': 'For[start, test, incr, Null]',
    }

    def apply(self, start, test, incr, body, evaluation):
        'For[start_, test_, incr_, body_]'
        while test.evaluate(evaluation).is_true():
            evaluation.check_stopped()
            try:
                try:
                    body.evaluate(evaluation)
                except ContinueInterrupt:
                    pass
                try:
                    incr.evaluate(evaluation)
                except ContinueInterrupt:
                    # Critical, most likely leads to an infinite loop
                    pass
            except BreakInterrupt:
                break
        return Symbol('Null')


class While(Builtin):
    """
    <dl>
    <dt>'While[$test$, $body$]'
        <dd>evaluates $body$ as long as $test$ evaluates to 'True'.
    <dt>'While[$test$]'
        <dd>runs the loop without any body.
    </dl>
    Compute the GCD of two numbers:
    >> {a, b} = {27, 6};
    >> While[b != 0, {a, b} = {b, Mod[a, b]}];
    >> a
     = 3
    """

    attributes = ('HoldAll',)
    rules = {
        'While[test_]': 'While[test, Null]',
    }

    def apply(self, test, body, evaluation):
        'While[test_, body_]'

        while test.evaluate(evaluation).is_true():
            try:
                evaluation.check_stopped()
                body.evaluate(evaluation)
            except ContinueInterrupt:
                pass
            except BreakInterrupt:
                break
        return Symbol('Null')


class Nest(Builtin):
    """
    <dl>
    <dt>'Nest[$f$, $expr$, $n$]'
        <dd>starting with $expr$, iteratively applies $f$ $n$ times and returns the final result.
    </dl>

    >> Nest[f, x, 3]
     = f[f[f[x]]]
    >> Nest[(1+#) ^ 2 &, x, 2]
     = (1 + (1 + x) ^ 2) ^ 2
    """

    def apply(self, f, expr, n, evaluation):
        'Nest[f_, expr_, n_Integer]'

        n = n.get_int_value()
        if n is None or n < 0:
            return
        result = expr
        for k in range(n):
            result = Expression(f, result).evaluate(evaluation)
        return result


class NestList(Builtin):
    """
    <dl>
    <dt>'NestList[$f$, $expr$, $n$]'
        <dd>starting with $expr$, iteratively applies $f$ $n$ times and returns a list of all intermediate results.
    </dl>

    >> NestList[f, x, 3]
     = {x, f[x], f[f[x]], f[f[f[x]]]}
    >> NestList[2 # &, 1, 8]
     = {1, 2, 4, 8, 16, 32, 64, 128, 256}

    ## TODO: improve this example when RandomChoice, PointSize, Axes->False are implemented
    Chaos game rendition of the Sierpinski triangle:
    >> vertices = {{0,0}, {1,0}, {.5, .5 Sqrt[3]}};
    >> points = NestList[.5(vertices[[ RandomInteger[{1,3}] ]] + #) &, {0.,0.}, 2000];
    >> Graphics[Point[points], ImageSize->Small]
     = -Graphics-
    """

    def apply(self, f, expr, n, evaluation):
        'NestList[f_, expr_, n_Integer]'

        n = n.get_int_value()
        if n is None or n < 0:
            return

        interm = expr
        result = [interm]

        for k in range(n):
            interm = Expression(f, interm).evaluate(evaluation)
            result.append(interm)

        return from_python(result)


class NestWhile(Builtin):
    """
    <dl>
    <dt>'NestWhile[$f$, $expr$, $test$]'
        <dd>applies a function $f$ repeatedly on an expression $expr$, until
        applying $test$ on the result no longer yields 'True'.
    <dt>'NestWhile[$f$, $expr$, $test$, $m$]'
        <dd>supplies the last $m$ results to $test$ (default value: 1).
    <dt>'NestWhile[$f$, $expr$, $test$, All]'
        <dd>supplies all results gained so far to $test$.
    </dl>

    Divide by 2 until the result is no longer an integer:
    >> NestWhile[#/2&, 10000, IntegerQ]
     = 625 / 2
    """

    rules = {
        'NestWhile[f_, expr_, test_]': 'NestWhile[f, expr, test, 1]',
    }

    def apply(self, f, expr, test, m, evaluation):
        'NestWhile[f_, expr_, test_, Pattern[m,_Integer|All]]'

        results = [expr]
        while True:
            if m.get_name() == 'All':
                test_leaves = results
            else:
                test_leaves = results[-m.value:]
            test_expr = Expression(test, *test_leaves)
            test_result = test_expr.evaluate(evaluation)
            if test_result.is_true():
                next = Expression(f, results[-1])
                results.append(next.evaluate(evaluation))
            else:
                break
        return results[-1]


class FixedPoint(Builtin):
    """
    <dl>
    <dt>'FixedPoint[$f$, $expr$]'
        <dd>starting with $expr$, iteratively applies $f$ until the result no longer changes.
    <dt>'FixedPoint[$f$, $expr$, $n$]'
        <dd>performs at most $n$ iterations.
    </dl>

    >> FixedPoint[Cos, 1.0]
     = 0.739085133215160639

    >> FixedPoint[#+1 &, 1, 20]
     = 21

    #> FixedPoint[f, x, 0]
     = x
    #> FixedPoint[f, x, -1]
     : Non-negative integer expected.
     = FixedPoint[f, x, -1]
    #> FixedPoint[Cos, 1.0, Infinity]
     = 0.739085133215160639
    """

    def apply(self, f, expr, n, evaluation):
        'FixedPoint[f_, expr_, n_:DirectedInfinity[1]]'

        if n == Expression('DirectedInfinity', 1):
            count = None
        else:
            count = n.get_int_value()
            if count is None or count < 0:
                evaluation.message('FixedPoint', 'intnn')
                return
        result = expr
        index = 0
        while count is None or index < count:
            evaluation.check_stopped()
            new_result = Expression(f, result).evaluate(evaluation)
            # print '%d: %s' % (index, new_result)
            if new_result == result:
                result = new_result
                break
            result = new_result
            index += 1

        return result


class FixedPointList(Builtin):
    """
    <dl>
    <dt>'FixedPointList[$f$, $expr$]'
        <dd>starting with $expr$, iteratively applies $f$ until the result no longer changes, and returns a list of all intermediate results.
    <dt>'FixedPointList[$f$, $expr$, $n$]'
        <dd>performs at most $n$ iterations.
    </dl>

    >> FixedPointList[Cos, 1.0, 4]
     = {1., 0.540302305868139717, 0.857553215846393416, 0.65428979049777915, 0.793480358742565592}

    Observe the convergence of Newton's method for approximating square roots:
    >> newton[n_] := FixedPointList[.5(# + n/#) &, 1.];
    >> newton[9]
     = {1., 5., 3.4, 3.02352941176470588, 3.00009155413138018, 3.00000000139698386, 3., 3.}

    Plot the "hailstone" sequence of a number:
    >> collatz[1] := 1;
    >> collatz[x_ ? EvenQ] := x / 2;
    >> collatz[x_] := 3 x + 1;
    >> list = FixedPointList[collatz, 14]
     = {14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1, 1}
    >> ListLinePlot[list]
     = -Graphics-

    #> FixedPointList[f, x, 0]
     = {x}
    #> FixedPointList[f, x, -1]
     : Non-negative integer expected.
     = FixedPointList[f, x, -1]
    #> Last[FixedPointList[Cos, 1.0, Infinity]]
     = 0.739085133215160639
    """

    def apply(self, f, expr, n, evaluation):
        'FixedPointList[f_, expr_, n_:DirectedInfinity[1]]'

        if n == Expression('DirectedInfinity', 1):
            count = None
        else:
            count = n.get_int_value()
            if count is None or count < 0:
                evaluation.message('FixedPoint', 'intnn')
                return

        interm = expr
        result = [interm]

        index = 0
        while count is None or index < count:
            evaluation.check_stopped()

            new_result = Expression(f, interm).evaluate(evaluation)
            result.append(new_result)
            if new_result == interm:
                break

            interm = new_result
            index += 1

        return from_python(result)


class Abort(Builtin):
    """
    <dl>
    <dt>'Abort[]'
        <dd>aborts an evaluation completely and returns '$Aborted'.
    </dl>
    >> Print["a"]; Abort[]; Print["b"]
     | a
     = $Aborted
    """

    def apply(self, evaluation):
        'Abort[]'

        raise AbortInterrupt

# class Return(Builtin):
#    pass


class Break(Builtin):
    """
    <dl>
    <dt>'Break[]'
        <dd>exits a 'For', 'While', or 'Do' loop.
    </dl>
    >> n = 0;
    >> While[True, If[n>10, Break[]]; n=n+1]
    >> n
     = 11
    """

    messages = {
        'nofwd': "No enclosing For, While, or Do found for Break[].",
    }

    def apply(self, evaluation):
        'Break[]'

        raise BreakInterrupt


class Continue(Builtin):
    """
    <dl>
    <dt>'Continue[]'
        <dd>continues with the next iteration in a 'For', 'While', or 'Do' loop.
    </dl>
    >> For[i=1, i<=8, i=i+1, If[Mod[i,2] == 0, Continue[]]; Print[i]]
     | 1
     | 3
     | 5
     | 7
    """

    messages = {
        'nofwd': "No enclosing For, While, or Do found for Continue[].",
    }

    def apply(self, evaluation):
        'Continue[]'

        raise ContinueInterrupt

########NEW FILE########
__FILENAME__ = datentime
# -*- coding: utf8 -*-

"""
Date and Time
"""

import time
from datetime import datetime, timedelta
import dateutil.parser

from mathics.core.expression import (Expression, Real, Symbol, String,
                                     from_python)

from mathics.builtin.base import Builtin, Predefined
from mathics.settings import TIME_12HOUR

START_TIME = time.time()

TIME_INCREMENTS = {
    'Year': (1, 0, 0, 0, 0, 0),
    'Quarter': (0, 3, 0, 0, 0, 0),
    'Month': (0, 1, 0, 0, 0, 0),
    'Week': (0, 0, 7, 0, 0, 0),
    'Day': (0, 0, 1, 0, 0, 0),
    'Hour': (0, 0, 0, 1, 0, 0),
    'Minute': (0, 0, 0, 0, 1, 0),
    'Second': (0, 0, 0, 0, 0, 1),
}

# FIXME: Some of the formats are not supported by strftime/strptime
# (commented out)
DATE_STRING_FORMATS = {
    "Date": "%c",
    "DateShort": "%a %d %b %Y",
    "Time": "%X",
    "DateTime": "%c %X",
    "DateTimeShort": "%a %d %b %Y %X",
    "Year": "%Y",
    "YearShort": "%y",
    #"QuarterName": "Quarter N",
    #"QuarterNameShort": "QN",
    #"Quarter": "",
    "MonthName": "%B",
    "MonthNameShort": "%b",
    #"MonthNameInitial": "%b",
    "Month": "%m",
    "MonthShort": "%m",
    "DayName": "%A",
    "DayNameShort": "%a",
    #"DayNameInitial": "%a",
    "Day": "%d",
    "DayShort": "%d",
    "Hour": "%I" if TIME_12HOUR else "%H",
    "Hour12": "%I",
    "Hour24": "%H",
    "HourShort": "%H",
    "Hour12Short": "%I",
    "Hour24Short": "%H",
    "AMPM": "%p",
    #"AMPMLowerCase": "%p",
    "Minute": "%M",
    "MinuteShort": "%M",
    "Second": "%S",
    "SecondShort": "%S",
    "SecondExact": "%S.%f",
    #"Millisecond": "%f",
    #"MillisecondShort": "",
}

EPOCH_START = datetime(1900, 1, 1)

if not hasattr(timedelta, 'total_seconds'):
    def total_seconds(td):
        return float(td.microseconds +
                     (td.seconds + td.days * 24 * 3600) * 10 ** 6) / 10 ** 6
else:
    total_seconds = timedelta.total_seconds


class Timing(Builtin):
    """
    <dl>
    <dt>'Timing[$expr$]'
      <dd>measures the processor time taken to evaluate $expr$.
      It returns a list containing the measured time in seconds and the result of the evaluation.
    </dl>

    >> Timing[50!]
     = {..., 30414093201713378043612608166064768844377641568960512000000000000}
    >> Attributes[Timing]
     = {HoldAll, Protected}
    """

    attributes = ('HoldAll',)

    def apply(self, expr, evaluation):
        'Timing[expr_]'

        start = time.clock()
        result = expr.evaluate(evaluation)
        stop = time.clock()
        return Expression('List', Real(stop - start), result)


class AbsoluteTiming(Builtin):
    """
    <dl>
    <dt>'AbsoluteTiming[$expr$]'
      <dd>measures the actual time it takes to evaluate $expr$.
      It returns a list containing the measured time in seconds and the result of the evaluation.
    </dl>

    >> AbsoluteTiming[50!]
     = {..., 30414093201713378043612608166064768844377641568960512000000000000}
    >> Attributes[AbsoluteTiming]
     = {HoldAll, Protected}
    """

    attributes = ('HoldAll',)

    def apply(self, expr, evaluation):
        'AbsoluteTiming[expr_]'

        start = time.time()
        result = expr.evaluate(evaluation)
        stop = time.time()
        return Expression('List', Real(stop - start), result)


class DateStringFormat(Predefined):
    """
    <dl>
    <dt>'$DateStringFormat'
      <dd>gives the format used for dates generated by DateString.
    </dl>

    >> $DateStringFormat
     = {DateTimeShort}
    """

    name = '$DateStringFormat'

    value = u'DateTimeShort'

    # TODO: Methods to change this

    def evaluate(self, evaluation):
        return Expression('List', String(self.value))


class _DateFormat(Builtin):
    def to_datelist(self, epochtime, evaluation):
        """ Converts date-time 'epochtime' to datelist """
        etime = epochtime.to_python()

        form_name = self.get_name()

        if isinstance(etime, float) or isinstance(etime, (int, long)):
            date = EPOCH_START + timedelta(seconds=etime)
            datelist = [date.year, date.month, date.day, date.hour,
                        date.minute, date.second + 1e-06 * date.microsecond]
            return datelist

        if isinstance(etime, basestring):
            date = dateutil.parser.parse(etime.strip('"'))
            datelist = [date.year, date.month, date.day, date.hour,
                        date.minute, date.second + 1e-06 * date.microsecond]
            return datelist

        if not isinstance(etime, list):
            evaluation.message(form_name, 'arg', etime)
            return

        if 1 <= len(etime) <= 6 and all(    # noqa
            (isinstance(val, float) and i > 1) or
            isinstance(val, (int, long)) for i, val in enumerate(etime)):

            default_date = [1900, 1, 1, 0, 0, 0.]
            datelist = etime + default_date[len(etime):]
            prec_part, imprec_part = datelist[:2], datelist[2:]

            try:
                dtime = datetime(prec_part[0], prec_part[1], 1)
            except ValueError:
                # FIXME datetime is fairly easy to overlfow. 1 <= month <= 12
                # and some bounds on year too.
                evaluation.message(form_name, 'arg', epochtime)
                return

            tdelta = timedelta(days=imprec_part[0] - 1, hours=imprec_part[1],
                               minutes=imprec_part[2], seconds=imprec_part[3])
            dtime += tdelta
            datelist = [dtime.year, dtime.month, dtime.day, dtime.hour,
                        dtime.minute, dtime.second + 1e-06 * dtime.microsecond]
            return datelist

        if len(etime) == 2:
            if (isinstance(etime[0], basestring) and    # noqa
                isinstance(etime[1], list) and
                all(isinstance(s, basestring) for s in etime[1])):
                is_spec = [str(s).strip(
                    '"') in DATE_STRING_FORMATS.keys() for s in etime[1]]
                etime[1] = map(lambda s: str(s).strip('"'), etime[1])

                if sum(is_spec) == len(is_spec):
                    forms = []
                    fields = [DATE_STRING_FORMATS[s] for s in etime[1]]
                    for sep in ['', ' ', '/', '-', '.', ',', ':']:
                        forms.append(sep.join(fields))
                else:
                    forms = ['']
                    for i, s in enumerate(etime[1]):
                        if is_spec[i]:
                            forms[0] += DATE_STRING_FORMATS[s]
                        else:
                            # TODO: Escape % signs?
                            forms[0] += s

                date = _Date()
                date.date = None
                for form in forms:
                    try:
                        date.date = datetime.strptime(
                            str(etime[0]).strip('"'), form)
                        break
                    except ValueError:
                        pass

                if date.date is None:
                    evaluation.message(form_name, 'str', etime[0], etime[1])
                    return
                datelist = date.to_list()

                # If year is ambiguious, assume the current year
                if 'Year' not in etime[1] and 'YearShort' not in etime[1]:
                    datelist[0] = datetime.today().year

                return datelist

            else:
                evaluation.message(form_name, 'str', etime[0], etime[1])
                return

        evaluation.message(form_name, 'arg', epochtime)
        return


class DateList(_DateFormat):
    """
    <dl>
    <dt>'DateList[]'
      <dd>returns the current local time in the form {$year$, $month$, $day$, $hour$, $minute$, $second$}.
    <dt>'DateList[$time$]'
      <dd>returns a formatted date for the number of seconds $time$ since epoch Jan 1 1900.
    <dt>'DateList[{$y$, $m$, $d$, $h$, $m$, $s$}]'
      <dd>converts an incomplete date list to the standard representation.
    <dt>'DateString[$string$]'
      <dd>returns the formatted date list of a date string specification.
    <dt>'DateString[$string$, {$e1$, $e2$, ...}]'
      <dd>returns the formatted date list of a $string$ obtained from elements $ei$.
    </dl>

    >> DateList[0]
     = {1900, 1, 1, 0, 0, 0.}

    >> DateList[3155673600]
     = {2000, 1, 1, 0, 0, 0.}

    >> DateList[{2003, 5, 0.5, 0.1, 0.767}]
     = {2003, 4, 30, 12, 6, 46.02}

    >> DateList[{2012, 1, 300., 10}]
     = {2012, 10, 26, 10, 0, 0.}

    >> DateList["31/10/1991"]
     = {1991, 10, 31, 0, 0, 0.}

    >> DateList[{"31/10/91", {"Day", "Month", "YearShort"}}]
     = {1991, 10, 31, 0, 0, 0.}

    >> DateList[{"31 10/91", {"Day", " ", "Month", "/", "YearShort"}}]
     = {1991, 10, 31, 0, 0, 0.}

    ## strptime should ignore leading 0s
    #> DateList[{"6/6/91", {"Day", "Month", "YearShort"}}]
     = {1991, 6, 6, 0, 0, 0.}
    #> DateList[{"6/06/91", {"Day", "Month", "YearShort"}}]
     = {1991, 6, 6, 0, 0, 0.}
    #> DateList[{"06/06/91", {"Day", "Month", "YearShort"}}]
     = {1991, 6, 6, 0, 0, 0.}
    #> DateList[{"06/6/91", {"Day", "Month", "YearShort"}}]
     = {1991, 6, 6, 0, 0, 0.}

    If not specified, the current year assumed
    >> DateList[{"5/18", {"Month", "Day"}}]
     = {..., 5, 18, 0, 0, 0.}
    #> DateList[{"5/18", {"Month", "Day"}}][[1]] == DateList[][[1]]
     = True
    """
    # TODO: Somehow check that the current year is correct

    rules = {
        'DateList[]': 'DateList[AbsoluteTime[]]',
    }

    messages = {
        'arg': 'Argument `1` cannot be intepreted as a date or time input.',
        'str': 'String `1` cannot be interpreted as a date in format `2`.',
    }

    def apply(self, epochtime, evaluation):
        '%(name)s[epochtime_]'
        datelist = self.to_datelist(epochtime, evaluation)

        if datelist is None:
            return

        return Expression('List', *datelist)


class DateString(_DateFormat):
    """
    <dl>
    <dt>'DateString[]'
      <dd>returns the current local time and date as a string.
    <dt>'DateString[$elem$]'
      <dd>returns the time formatted according to $elems$.
    <dt>'DateString[{$e1$, $e2$, ...}]'
      <dd>concatinates the time formatted according to elements $ei$.
    <dt>'DateString[$time$]'
      <dd>returns the date string of an AbsoluteTime.
    <dt>'DateString[{$y$, $m$, $d$, $h$, $m$, $s$}]'
      <dd>returns the date string of a date list specification.
    <dt>'DateString[$string$]'
      <dd>returns the formatted date string of a date string specification.
    <dt>'DateString[$spec$, $elems$]'
      <dd>formats the time in turns of $elems$. Both $spec$ and $elems$ can take any of the above formats.
    </dl>

    The current date and time:
    >> DateString[];

    >> DateString[{1991, 10, 31, 0, 0}, {"Day", " ", "MonthName", " ", "Year"}]
     = 31 October 1991

    >> DateString[{2007, 4, 15, 0}]
     = Sun 15 Apr 2007 00:00:00

    >> DateString[{1979, 3, 14}, {"DayName", "  ", "Month", "-", "YearShort"}]
     = Wednesday  03-79

    Non-integer values are accepted too:
    >> DateString[{1991, 6, 6.5}]
     = Thu 6 Jun 1991 12:00:00

    ## Check Leading 0
    #> DateString[{1979, 3, 14}, {"DayName", "  ", "MonthShort", "-", "YearShort"}]
     =  Wednesday  3-79

    #> DateString[{1979, 3, 4}]
     = Sun 4 Mar 1979 00:00:00

    #> DateString[{"DayName", "  ", "Month", "/", "YearShort"}]
     = ...

    #> DateString["2000-12-1", "Year"]
     = 2000

    ## Assumed separators
    #> DateString[{"06/06/1991", {"Month", "Day", "Year"}}]
     = Thu 6 Jun 1991 00:00:00

    ## Specified separators
    #> DateString[{"06/06/1991", {"Month", "/", "Day", "/", "Year"}}]
     = Thu 6 Jun 1991 00:00:00

    #> DateString[{"5/19"}]
     = 5/19
    """

    rules = {
        'DateString[]': 'DateString[DateList[], $DateStringFormat]',
        'DateString[epochtime_?(VectorQ[#1, NumericQ]&)]': (
            'DateString[epochtime, $DateStringFormat]'),
        'DateString[epochtime_?NumericQ]': (
            'DateString[epochtime, $DateStringFormat]'),
        'DateString[format_?(VectorQ[#1, StringQ]&)]': (
            'DateString[DateList[], format]'),
        'DateString[epochtime_]': 'DateString[epochtime, $DateStringFormat]',
    }

    messages = {
        'arg': 'Argument `1` cannot be intepreted as a date or time input.',
        'fmt': '`1` is not a valid date format.',
    }

    attributes = ('ReadProtected',)

    def apply(self, epochtime, form, evaluation):
        'DateString[epochtime_, form_]'
        datelist = self.to_datelist(epochtime, evaluation)

        if datelist is None:
            return

        date = _Date(datelist=datelist)

        pyform = form.to_python()
        if not isinstance(pyform, list):
            pyform = [pyform]

        pyform = map(lambda x: x.strip('"'), pyform)

        if not all(isinstance(f, unicode) or isinstance(f, str)
                   for f in pyform):
            evaluation.message('DateString', 'fmt', form)
            return

        datestrs = []
        for p in pyform:
            if str(p) in DATE_STRING_FORMATS.keys():
                # FIXME: Years 1900 before raise an error
                tmp = date.date.strftime(DATE_STRING_FORMATS[p])
                if str(p).endswith("Short") and str(p) != "YearShort":
                    if str(p) == "DateTimeShort":
                        tmp = tmp.split(' ')
                        tmp = ' '.join(map(lambda s: s.lstrip(
                            '0'), tmp[:-1]) + [tmp[-1]])
                    else:
                        tmp = ' '.join(map(lambda s: s.lstrip(
                            '0'), tmp.split(' ')))
            else:
                tmp = str(p)

            datestrs.append(tmp)

        return from_python(''.join(datestrs))


class AbsoluteTime(_DateFormat):
    """
    <dl>
    <dt>'AbsoluteTime[]'
      <dd>gives the local time in seconds since epoch Jan 1 1900.
    <dt>'AbsoluteTime[$string$]'
      <dd>gives the absolute time specification for a given date string.
    <dt>'AbsoluteTime[{$y$, $m$, $d$, $h$, $m$, $s$}]'
      <dd>gives the absolute time specification for a given date list.
    <dt>'AbsoluteTime[{"string",{$e1$, $e2$, ...}}]'
      <dd>gives the absolute time specification for a given date list with specified elements $ei$.
    </dl>

    >> AbsoluteTime[]
     = ...

    >> AbsoluteTime[{2000}]
     = 3155673600

    >> AbsoluteTime[{"01/02/03", {"Day", "Month", "YearShort"}}]
     = 3253046400

    >> AbsoluteTime["6 June 1991"]
     = 2885155200

    >> AbsoluteTime[{"6-6-91", {"Day", "Month", "YearShort"}}]
     = 2885155200

    ## Mathematica Bug - Mathics gets it right
    #> AbsoluteTime[1000]
     = 1000
    """

    messages = {
        'arg': 'Argument `1` cannot be intepreted as a date or time input.',
        'fmt': '`1` is not a valid date format.',
    }

    def apply_now(self, evaluation):
        'AbsoluteTime[]'

        return from_python(total_seconds(datetime.now() - EPOCH_START))

    def apply_spec(self, epochtime, evaluation):
        'AbsoluteTime[epochtime_]'

        datelist = self.to_datelist(epochtime, evaluation)

        if datelist is None:
            return

        date = _Date(datelist=datelist)
        tdelta = date.date - EPOCH_START
        if tdelta.microseconds == 0:
            return from_python(int(total_seconds(tdelta)))
        return from_python(total_seconds(tdelta))


class TimeZone(Predefined):
    """
    <dl>
    <dt>'$TimeZone'
      <dd> gives the current time zone.
    </dl>

    >> $TimeZone
     = ...
    """

    name = '$TimeZone'

    def evaluate(self, evaluation):
        return Real(-time.timezone / 3600.)


class TimeUsed(Builtin):
    """
    <dl>
    <dt>'TimeUsed[]'
      <dd>returns the total cpu time used for this session.
    </dl>

    >> TimeUsed[]
     = ...
    """

    def apply(self, evaluation):
        'TimeUsed[]'
        return Real(time.clock())  # TODO: Check this for windows


class SessionTime(Builtin):
    """
    <dl>
    <dt>'SessionTime[]'
      <dd>returns the total time since this session started.
    </dl>

    >> SessionTime[]
     = ...
    """
    def apply(self, evaluation):
        'SessionTime[]'
        return Real(time.time() - START_TIME)


class Pause(Builtin):
    """
    <dl>
    <dt>'Pause[n]'
      <dd>pauses for $n$ seconds.
    </dl>

    >> Pause[0.5]
    """

    messages = {
        'numnm': ('Non-negative machine-sized number expected at '
                  'position 1 in `1`.'),
    }

    def apply(self, n, evaluation):
        'Pause[n_]'
        sleeptime = n.to_python()
        if not isinstance(sleeptime, (int, float)) or sleeptime < 0:
            evaluation.message('Pause', 'numnm', Expression('Pause', n))
            return

        time.sleep(sleeptime)
        return Symbol('Null')


class _Date():
    def __init__(self, datelist=[], absolute=None, datestr=None):
        datelist += [1900, 1, 1, 0, 0, 0.][len(datelist):]
        self.date = datetime(
            datelist[0], datelist[1], datelist[2], datelist[3], datelist[4],
            int(datelist[5]), int(1e6 * (datelist[5] % 1.)))
        if absolute is not None:
            self.date += timedelta(seconds=absolute)
        if datestr is not None:
            if absolute is not None:
                raise ValueError
            self.date = dateutil.parser.parse(datestr)

    def addself(self, timevec):
        years = self.date.year + timevec[0] + int(
            (self.date.month + timevec[1]) / 12)
        months = (self.date.month + timevec[1]) % 12
        if months == 0:
            months += 12
            years -= 1
        self.date = datetime(years, months, self.date.day, self.date.hour,
                             self.date.minute, self.date.second)
        tdelta = timedelta(days=timevec[2], hours=timevec[3],
                           minutes=timevec[4], seconds=timevec[5])
        self.date += tdelta

    def to_list(self):
        return [self.date.year, self.date.month, self.date.day,
                self.date.hour, self.date.minute,
                self.date.second + 1e-6 * self.date.microsecond]


class DatePlus(Builtin):
    """
    <dl>
    <dt>'DatePlus[date, n]'
      <dd>finds the date $n$ days after $date$.
    <dt>'DatePlus[date, {n, "unit"}]'
      <dd>finds the date $n$ units after $date$.
    <dt>'DatePlus[date, {{n1, "unit1"}, {n2, unit2}, ...}]'
      <dd>finds the date which is $n_i$ specified units after $date$.
    <dt>'DatePlus[n]'
      <dd>finds the date $n$ days after the current date.
    <dt>'DatePlus[offset]'
      <dd>finds the date which is offset from the current date.
    </dl>

    Add 73 days to Feb 5, 2010:
    >> DatePlus[{2010, 2, 5}, 73]
     = {2010, 4, 19}

    Add 8 weeks and 1 day to March 16, 1999:
    >> DatePlus[{2010, 2, 5}, {{8, "Week"}, {1, "Day"}}]
     = {2010, 4, 3}
    """

    rules = {
        'DatePlus[n_]': 'DatePlus[Take[DateList[], 3], n]'
    }

    messages = {
        'date': 'Argument `1` cannot be interpreted as a date.',
        'inc': ('Argument `1` is not a time increment or a list '
                'of time increments.'),
    }

    attributes = ('ReadProtected',)

    def apply(self, date, off, evaluation):
        'DatePlus[date_, off_]'

        # Process date
        pydate = date.to_python()
        if isinstance(pydate, list):
            date_prec = len(pydate)
            idate = _Date(datelist=pydate)
        elif isinstance(pydate, float) or isinstance(pydate, int):
            date_prec = 'absolute'
            idate = _Date(absolute=pydate)
        elif isinstance(pydate, basestring):
            date_prec = 'string'
            idate = _Date(datestr=pydate.strip('"'))
        else:
            evaluation.message('DatePlus', 'date', date)
            return

        # Process offset
        pyoff = off.to_python()
        if isinstance(pyoff, float) or isinstance(pyoff, int):
            pyoff = [[pyoff, u'"Day"']]
        elif (isinstance(pyoff, list) and len(pyoff) == 2 and
              isinstance(pyoff[1], unicode)):
            pyoff = [pyoff]

        # Strip " marks
        pyoff = map(lambda x: [x[0], x[1].strip('"')], pyoff)

        if isinstance(pyoff, list) and all(     # noqa
            len(o) == 2 and o[1] in TIME_INCREMENTS.keys() and
            isinstance(o[0], (float, int)) for o in pyoff):

            for o in pyoff:
                idate.addself([o[0] * TIME_INCREMENTS[
                              o[1]][i] for i in range(6)])
        else:
            evaluation.message('DatePlus', 'inc', off)
            return

        if isinstance(date_prec, int):
            result = Expression('List', *idate.to_list()[:date_prec])
        elif date_prec == 'absolute':
            result = Expression('AbsoluteTime', idate.to_list())
        elif date_prec == 'string':
            result = Expression('DateString', Expression(
                'List', *idate.to_list()))

        return result


class DateDifference(Builtin):
    """
    <dl>
    <dt>'DateDifference[$date1$, $date2$]
      <dd>difference between dates in days.
    <dt>'DateDifference[$date1$, $date2$, $unit$]
      <dd>difference between dates in specified $unit$.
    <dt>'DateDifference[$date1$, $date2$, {$unit1$, $unit2$, ...}]
      <dd>difference between dates as a list in the specified units.
    </dl>

    >> DateDifference[{2042, 1, 4}, {2057, 1, 1}]
     = 5476

    >> DateDifference[{1936, 8, 14}, {2000, 12, 1}, "Year"]
     = {64.3424657534, Year}

    >> DateDifference[{2010, 6, 1}, {2015, 1, 1}, "Hour"]
     = {40200, Hour}

    >> DateDifference[{2003, 8, 11}, {2003, 10, 19}, {"Week", "Day"}]
     = {{9, Week}, {6, Day}}
    """

    # FIXME: Since timedelta doesnt use large time units (years, months etc)
    # this method can be innacuarate. The example below gives fractional Days
    # (20.1666666667 not 20).

    """
    >> DateDifference[{2000, 6, 15}, {2001, 9, 4}, {"Month", "Day"}]
     = {{14, "Month"}, {20, "Day"}}
    """

    rules = {
        'DateDifference[date1_, date2_]': 'DateDifference[date1, date2, "Day"]'
    }

    messages = {
        'date': 'Argument `1` cannot be interpreted as a date.',
        'inc': ('Argument `1` is not a time increment or '
                'a list of time increments.'),
    }

    attributes = ('ReadProtected',)

    def apply(self, date1, date2, units, evaluation):
        'DateDifference[date1_, date2_, units_]'

        # Process dates
        pydate1, pydate2 = date1.to_python(), date2.to_python()

        if isinstance(pydate1, list):               # Date List
            idate = _Date(datelist=pydate1)
        elif isinstance(pydate1, (float, int)):     # Absolute Time
            idate = _Date(absolute=pydate1)
        elif isinstance(pydate1, basestring):       # Date string
            idate = _Date(datestr=pydate2.strip('"'))
        else:
            evaluation.message('DateDifference', 'date', date1)
            return

        if isinstance(pydate2, list):           # Date List
            fdate = _Date(datelist=pydate2)
        elif isinstance(pydate2, (int, float)):  # Absolute Time
            fdate = _Date(absolute=pydate2)
        elif isinstance(pydate1, basestring):   # Date string
            fdate = _Date(datestr=pydate2.strip('"'))
        else:
            evaluation.message('DateDifference', 'date', date2)
            return

        try:
            tdelta = fdate.date - idate.date
        except OverflowError:
            evaluation.message('General', 'ovf')
            return

        # Process Units
        pyunits = units.to_python()
        if isinstance(pyunits, basestring):
            pyunits = [unicode(pyunits.strip('"'))]
        elif (isinstance(pyunits, list) and
              all(isinstance(p, basestring) for p in pyunits)):
            pyunits = map(lambda p: p.strip('"'), pyunits)

        if not all(p in TIME_INCREMENTS.keys() for p in pyunits):
            evaluation.message('DateDifference', 'inc', units)

        def intdiv(a, b, flag=True):
            'exact integer division where possible'
            if flag:
                if a % b == 0:
                    return a / b
                else:
                    return a / float(b)
            else:
                return a / b

        if not isinstance(pyunits, list):
            pyunits = [pyunits]

        # Why doesn't this work?
        # pyunits = pyunits.sort(key=TIME_INCREMENTS.get, reverse=True)

        pyunits = [(a, TIME_INCREMENTS.get(a)) for a in pyunits]
        pyunits.sort(key=lambda a: a[1], reverse=True)
        pyunits = [a[0] for a in pyunits]

        seconds = int(total_seconds(tdelta))

        result = []
        flag = False
        for i, unit in enumerate(pyunits):
            if i + 1 == len(pyunits):
                flag = True

            if unit == 'Year':
                result.append([intdiv(
                    seconds, 365 * 24 * 60 * 60, flag), "Year"])
                seconds = seconds % (365 * 24 * 60 * 60)
            if unit == 'Quarter':
                result.append([intdiv(
                    seconds, 365 * 6 * 60 * 60, flag), "Quarter"])
                seconds = seconds % (365 * 6 * 60 * 60)
            if unit == 'Month':
                result.append([intdiv(
                    seconds, 365 * 2 * 60 * 60, flag), "Month"])
                seconds = seconds % (365 * 2 * 60 * 60)
            if unit == 'Week':
                result.append([intdiv(
                    seconds, 7 * 24 * 60 * 60, flag), "Week"])
                seconds = seconds % (7 * 24 * 60 * 60)
            if unit == 'Day':
                result.append([intdiv(seconds, 24 * 60 * 60, flag), "Day"])
                seconds = seconds % (24 * 60 * 60)
            if unit == 'Hour':
                result.append([intdiv(seconds, 60 * 60, flag), "Hour"])
                seconds = seconds % (60 * 60)
            if unit == 'Minute':
                result.append([intdiv(seconds, 60, flag), "Minute"])
                seconds = seconds % 60
            if unit == 'Second':
                result.append([intdiv(seconds + total_seconds(
                    tdelta) % 1, 1, flag), "Second"])

        if len(result) == 1:
            if pyunits[0] == "Day":
                return from_python(result[0][0])
            return from_python(result[0])
        return from_python(result)

########NEW FILE########
__FILENAME__ = diffeqns
# -*- coding: utf8 -*-

"""
Differential equation solver functions
"""

import sympy
from mathics.builtin.base import Builtin
from mathics.core.expression import Expression
from mathics.core.convert import sympy_symbol_prefix, from_sympy


class DSolve(Builtin):
    """
    <dl>
    <dt>'DSolve[$eq$, $y[x]$, $x$]'
        <dd>solves a differential equation for the function $y[x]$.
    </dl>

    >> DSolve[y''[x] == 0, y[x], x]
     = {{y[x] -> x C[2] + C[1]}}

    >> DSolve[y''[x] == y[x], y[x], x]
     = {{y[x] -> C[1] E ^ (-x) + C[2] E ^ x}}

    >> DSolve[y''[x] == y[x], y, x]
     = {{y -> (Function[{x}, C[1] Exp[-x] + C[2] Exp[x]])}}

    #> Attributes[f] = {HoldAll};
    #> DSolve[f[x + x] == Sin[f'[x]], f, x]
     : To avoid possible ambiguity, the arguments of the dependent variable in -Sin[f'[x]] + f[x + x] should literally match the independent variables.
     = DSolve[f[x + x] == Sin[f'[x]], f, x]

    #> Attributes[f] = {};
    #> DSolve[f[x + x] == Sin[f'[x]], f, x]
     : To avoid possible ambiguity, the arguments of the dependent variable in -Sin[f'[x]] + f[2 x] should literally match the independent variables.
     = DSolve[f[2 x] == Sin[f'[x]], f, x]

    #> DSolve[f'[x] == f[x], f, x] // FullForm
     = List[List[Rule[f, Function[List[x], Times[C[1], Exp[x]]]]]]

    #> DSolve[f'[x] == f[x], f, x] /. {C[1] -> 1}
     = {{f -> (Function[{x}, 1 Exp[x]])}}

    #> DSolve[f'[x] == f[x], f, x] /. {C -> D}
     = {{f -> (Function[{x}, D[1] Exp[x]])}}

    #> DSolve[f'[x] == f[x], f, x] /. {C[1] -> C[0]}
     = {{f -> (Function[{x}, C[0] Exp[x]])}}
    """

    # TODO: GeneratedParameters option

    messages = {
        'deqn': ('Equation or list of equations expected instead of '
                 '`1` in the first argument `1`.'),
        'deqx': ('Supplied equations are not differential equations '
                 'of the given functions.'),
        'dsfun': '`1` cannot be used as a function.',
        'dsvar': '`1` cannot be used as a variable.',
        'litarg': ('To avoid possible ambiguity, the arguments of the '
                   'dependent variable in `1` should literally match the '
                   'independent variables.'),
        # FIXME: Remove these if sympy changes:
        'symsys': "SymPy can't solve systems of DEs.",
        'symimp': "SymPy can't solve this form of DE.",
        'symmua': "SymPy can't handle functions of multiple variables.",
    }

    def apply(self, eqn, y, x, evaluation):
        'DSolve[eqn_, y_, x_]'

        if eqn.has_form('List', eqn):
            # TODO: Try and solve BVPs using Solve or something analagous OR
            # add this functonality to sympy.
            evaluation.message('DSolve', 'symsys')
            return

        if eqn.get_head_name() != 'Equal':
            evaluation.message('DSolve', 'deqn', eqn)
            return

        if ((x.is_atom() and not x.is_symbol()) or      # nopep8
            x.get_head_name() in ('Plus', 'Times', 'Power') or
            'Constant' in x.get_attributes(evaluation.definitions)):
            evaluation.message('DSolve', 'dsvar')
            return

        # Fixes pathalogical DSolve[y''[x] == y[x], y, x]
        try:
            y.leaves
            function_form = None
            func = y
        except AttributeError:
            func = Expression(y, x)
            function_form = Expression('List', x)

        if func.is_atom():
            evaluation.message('DSolve', 'dsfun', y)
            return

        if len(func.leaves) != 1:
            evaluation.message('DSolve', 'symmua')
            return

        if x not in func.leaves:
            evaluation.message('DSolve', 'deqx')
            return

        left, right = eqn.leaves
        eqn = Expression('Plus', left, Expression(
            'Times', -1, right)).evaluate(evaluation)

        sym_eq = eqn.to_sympy(converted_functions=set([func.get_head_name()]))
        sym_x = sympy.symbols(str(sympy_symbol_prefix + x.name))
        sym_func = sympy.Function(str(
            sympy_symbol_prefix + func.get_head_name()))(sym_x)

        try:
            sym_result = sympy.dsolve(sym_eq, sym_func)
            if not isinstance(sym_result, list):
                sym_result = [sym_result]
        except ValueError:
            evaluation.message('DSolve', 'symimp')
            return
        except NotImplementedError:
            evaluation.message('DSolve', 'symimp')
            return
        except AttributeError:
            evaluation.message('DSolve', 'litarg', eqn)
            return
        except KeyError:
            evaluation.message('DSolve', 'litarg', eqn)
            return

        if function_form is None:
            return Expression('List', *[
                Expression(
                    'List', Expression('Rule', *from_sympy(soln).leaves))
                for soln in sym_result])
        else:
            return Expression('List', *[
                Expression('List', Expression('Rule', y, Expression(
                    'Function', function_form, *from_sympy(soln).leaves[1:])))
                for soln in sym_result])

# TODO: NDSolve

########NEW FILE########
__FILENAME__ = evaluation
# -*- coding: utf8 -*-

import sys

from mathics.builtin.base import Predefined, Builtin
from mathics.core.expression import Integer

from mathics import settings


def set_recursionlimit(n):
    "Sets the required python recursion limit given $RecursionLimit value"
    def conversion(m):
        return 200 + 5 * m
    sys.setrecursionlimit(conversion(n))
    if sys.getrecursionlimit() != conversion(n):
        raise OverflowError


class RecursionLimit(Predefined):
    """
    >> a = a + a
     : Recursion depth of 200 exceeded.
     = $Aborted
    >> $RecursionLimit
     = 200

    >> $RecursionLimit = x;
     : Cannot set $RecursionLimit to x; value must be an integer between 20 and 512.

    >> $RecursionLimit = 512
     = 512
    >> a = a + a
     : Recursion depth of 512 exceeded.
     = $Aborted

    #> $RecursionLimit = 20
     = 20
    #> a = a + a
     : Recursion depth of 20 exceeded.
     = $Aborted

    #> $RecursionLimit = 200
     = 200

    """

    name = '$RecursionLimit'
    value = 200

    set_recursionlimit(value)

    rules = {
        '$RecursionLimit': str(value),
    }

    messages = {
        'reclim': "Recursion depth of `1` exceeded.",
        'limset': (
            "Cannot set $RecursionLimit to `1`; "
            "value must be an integer between 20 and %d.") % (
                settings.MAX_RECURSION_DEPTH),
    }

    rules = {
        '$RecursionLimit': str(value),
    }

    def evaluate(self, evaluation):
        return Integer(self.value)


class Hold(Builtin):
    """
    >> Attributes[Hold]
     = {HoldAll, Protected}
    """

    attributes = ('HoldAll',)


class HoldComplete(Builtin):
    """
    >> Attributes[HoldComplete]
     = {HoldAllComplete, Protected}
    """

    attributes = ('HoldAllComplete',)


class HoldForm(Builtin):
    """
    'HoldForm[$expr$]' maintains $expr$ in an unevaluated form, but prints as $expr$.

    >> HoldForm[1 + 2 + 3]
     = 1 + 2 + 3

    'HoldForm' has attribute 'HoldAll':
    >> Attributes[HoldForm]
     = {HoldAll, Protected}
    """

    attributes = ('HoldAll',)

    rules = {
        'MakeBoxes[HoldForm[expr_], f_]': 'MakeBoxes[expr, f]',
    }


class Evaluate(Builtin):
    """
    >> SetAttributes[f, HoldAll]
    >> f[1 + 2]
     = f[1 + 2]
    >> f[Evaluate[1 + 2]]
     = f[3]

    >> Hold[Evaluate[1 + 2]]
     = Hold[3]
    >> HoldComplete[Evaluate[1 + 2]]
     = HoldComplete[Evaluate[1 + 2]]
    >> Evaluate[Sequence[1, 2]]
     = Sequence[1, 2]
    """

    rules = {
        'Evaluate[Unevaluated[x_]]': 'Unevaluated[x]',
        'Evaluate[x___]': 'x',
    }


class Unevaluated(Builtin):
    """
    >> Length[Unevaluated[1+2+3+4]]
     = 4
    'Unevaluated' has attribute 'HoldAllComplete':
    >> Attributes[Unevaluated]
     = {HoldAllComplete, Protected}

    'Unevaluated' is maintained for arguments to non-executed functions:
    >> f[Unevaluated[x]]
     = f[Unevaluated[x]]
    Likewise, its kept in flattened arguments and sequences:
    >> Attributes[f] = {Flat};
    >> f[a, Unevaluated[f[b, c]]]
     = f[a, Unevaluated[b], Unevaluated[c]]
    >> g[a, Sequence[Unevaluated[b], Unevaluated[c]]]
     = g[a, Unevaluated[b], Unevaluated[c]]
    However, unevaluated sequences are kept:
    >> g[Unevaluated[Sequence[a, b, c]]]
     = g[Unevaluated[Sequence[a, b, c]]]

    #> Attributes[h] = Flat;
    #> h[items___] := Plus[items]
    #> h[1, Unevaluated[Sequence[Unevaluated[2], 3]], Sequence[4, Unevaluated[5]]]
     = 15
    """

    attributes = ('HoldAllComplete',)


class ReleaseHold(Builtin):
    """
    <dl>
    <dt>'ReleaseHold[$expr$]'
    <dd>removes any 'Hold', 'HoldForm', 'HoldPattern' or 'HoldComplete' head from $expr$.
    </dl>
    >> x = 3;
    >> Hold[x]
     = Hold[x]
    >> ReleaseHold[Hold[x]]
     = 3
    >> ReleaseHold[y]
     = y
    """

    rules = {
        'ReleaseHold[(Hold|HoldForm|HoldPattern|HoldComplete)[expr_]]': 'expr',
        'ReleaseHold[other_]': 'other',
    }


class Sequence(Builtin):
    """
    <dl>
    <dt>'Sequence[$x1$, $x2$, ...]'
        <dd>represents a sequence of arguments to a function.
    </dl>

    'Sequence' is automatically spliced in, except when a function has attribute 'SequenceHold'
    (like assignment functions).
    >> f[x, Sequence[a, b], y]
     = f[x, a, b, y]
    >> Attributes[Set]
     = {HoldFirst, Protected, SequenceHold}
    >> a = Sequence[b, c];
    >> a
     = Sequence[b, c]

    Apply 'Sequence' to a list to splice in arguments:
    >> list = {1, 2, 3};
    >> f[Sequence @@ list]
     = f[1, 2, 3]

    Inside 'Hold' or a function with a held argument, 'Sequence' is
    spliced in at the first level of the argument:
    >> Hold[a, Sequence[b, c], d]
     = Hold[a, b, c, d]
    If 'Sequence' appears at a deeper level, it is left unevaluated:
    >> Hold[{a, Sequence[b, c], d}]
     = Hold[{a, Sequence[b, c], d}]
    """


class Line(Builtin):
    """
    >> $Line
     = 1
    >> $Line
     = 2
    >> $Line = 12;
    >> 2 * 5
     = 10
    >> Out[13]
     = 10
    >> $Line = -1;
     : Non-negative integer expected.
    """

    name = '$Line'


class HistoryLength(Builtin):
    """
    >> $HistoryLength
     = 100
    >> $HistoryLength = 1;
    >> 42
     = 42
    >> %
     = 42
    >> %%
     = %3
    >> $HistoryLength = 0;
    >> 42
     = 42
    >> %
     = %7
    """

    name = '$HistoryLength'

    rules = {
        '$HistoryLength': '100',
    }


class In(Builtin):
    """
    >> x = 1
     = 1
    >> x = x + 1
     = 2
    >> Do[In[2], {3}]
    >> x
     = 5
    >> In[-1]
     = 5
    >> Definition[In]
     = Attributes[In] = {Protected}
     .
     . In[6] = Definition[In]
     .
     . In[5] = In[-1]
     .
     . In[4] = x
     .
     . In[3] = Do[In[2], {3}]
     .
     . In[2] = x = x + 1
     .
     . In[1] = x = 1
    """

    rules = {
        'In[k_Integer?Negative]': 'In[$Line + k]',
    }


class Out(Builtin):
    """
    <dl>
    <dt>'Out[$k$]' or '%$k$'
        <dd>gives the result of the $k$th input line.
    <dt>'%', '%%', etc.
        <dd>gives the result of the previous input line, of the line before the previous input line, etc.
    </dl>

    >> 42
     = 42
    >> %
     = 42
    >> 43;
    >> %
    >> 44
     = 44
    >> %1
     = 42
    >> %%
     = 44
    >> Hold[Out[-1]]
     = Hold[%]
    >> Hold[%4]
     = Hold[%4]
    >> Out[0]
     = Out[0]

    #> 10
     = 10
    #> Out[-1] + 1
     = 11
    #> Out[] + 1
     = 12
    """

    rules = {
        'Out[k_Integer?Negative]': 'Out[$Line + k]',
        'Out[]': 'Out[$Line - 1]',
        'MakeBoxes[Out[k_Integer?((-10 <= # < 0)&)],'
        '    f:StandardForm|TraditionalForm|InputForm|OutputForm]':
        r'StringJoin[ConstantArray["%%", -k]]',
        'MakeBoxes[Out[k_Integer?Positive],'
        '    f:StandardForm|TraditionalForm|InputForm|OutputForm]':
        r'"%%" <> ToString[k]',
    }

########NEW FILE########
__FILENAME__ = exptrig
# -*- coding: utf8 -*-

"""
Exponential, trigonometric and hyperbolic functions

Mathics basically supports all important trigonometric and hyperbolic functions.
Numerical values and derivatives can be computed; however, most special exact values and simplification
rules are not implemented yet.
"""

from __future__ import with_statement

import sympy
import sympy.mpmath as mpmath

from mathics.builtin.base import Builtin, SympyConstant
from mathics.core.expression import Real, Expression, Integer
from mathics.core.numbers import dps

from mathics.builtin.numeric import get_precision
from mathics.builtin.arithmetic import _MPMathFunction


class Pi(SympyConstant):
    u"""
    <dl>
    <dt>'Pi'
        <dd>is the constant \u03c0.
    </dl>

    >> N[Pi]
     = 3.14159265358979324
    >> N[Pi, 50]
     = 3.1415926535897932384626433832795028841971693993751

    >> Attributes[Pi]
     = {Constant, Protected, ReadProtected}
    """

    sympy_name = 'pi'

    def apply_N(self, precision, evaluation):
        'N[Pi, precision_]'
        precision = get_precision(precision, evaluation)
        if precision is not None:
            return Real(sympy.pi.n(dps(precision)), p=precision)


class E(SympyConstant):
    """
    <dl>
    <dt>'E'
        <dd>is the constant e.
    </dl>

    >> N[E]
     = 2.71828182845904524
    >> N[E, 50]
     = 2.7182818284590452353602874713526624977572470937

    >> Attributes[E]
     = {Constant, Protected, ReadProtected}

    #> 5. E
     = 13.5914091422952262
    """

    sympy_name = 'E'

    def apply_N(self, precision, evaluation):
        'N[E, precision_]'
        precision = get_precision(precision, evaluation)
        if precision is not None:
            return Real(sympy.E.n(dps(precision)), p=precision)


class GoldenRatio(SympyConstant):
    """
    <dl>
    <dt>'GoldenRatio'
        <dd>is the golden ratio.
    </dl>

    >> N[GoldenRatio]
     = 1.61803398874989485
    """

    sympy_name = 'GoldenRatio'

    rules = {
        'N[GoldenRatio, prec_]': 'N[(1+Sqrt[5])/2, prec]',
    }


class Exp(_MPMathFunction):
    """
    <dl>
    <dt>'Exp[$z$]'
        <dd>returns the exponential function of $z$.
    </dl>

    >> Exp[1]
     = E
    >> Exp[10.0]
     = 22026.4657948067169
    >> Exp[x] //FullForm
     = Power[E, x]

    >> Plot[Exp[x], {x, 0, 3}]
     = -Graphics-
    """

    rules = {
        'Exp[x_]': 'E ^ x',
        'Derivative[1][Exp]': 'Exp',
    }


class Log(_MPMathFunction):
    """
    <dl>
    <dt>'Log[$z$]'
        <dd>returns the natural logarithm of $z$.
    </dl>

    >> Log[{0, 1, E, E * E, E ^ 3, E ^ x}]
     = {-Infinity, 0, 1, 2, 3, Log[E ^ x]}
    >> Log[0.]
     = Indeterminate
    >> Plot[Log[x], {x, 0, 5}]
     = -Graphics-

    #> Log[1000] / Log[10] // Simplify
     = 3

    #> Log[1.4]
     = 0.336472236621212931

    #> Log[1.4]
     = 0.336472236621212931

    #> Log[-1.4]
     = 0.336472236621212931 + 3.14159265358979324 I
    """

    nargs = 2
    mpmath_name = 'log'
    sympy_name = 'log'

    rules = {
        'Log[0.]': 'Indeterminate',
        'Log[0]': 'DirectedInfinity[-1]',
        'Log[1]': '0',
        'Log[E]': '1',
        'Log[E^x_Integer]': 'x',
        'Derivative[1][Log]': '1/#&',
        'Log[x_?InexactNumberQ]': 'Log[E, x]',
    }

    def prepare_sympy(self, leaves):
        if len(leaves) == 2:
            leaves = [leaves[1], leaves[0]]
        return leaves

    def eval(self, *args):
        return mpmath.log(args[1], args[0])


class Log2(Builtin):
    """
    <dl>
    <dt>'Log2[$z$]'
        <dd>returns the base-2 logarithm of $z$.
    </dl>

    >> Log2[4 ^ 8]
     = 16
    >> Log2[5.6]
     = 2.48542682717024176
    >> Log2[E ^ 2]
     = 2 / Log[2]
    """

    rules = {
        'Log2[x_]': 'Log[2, x]',
    }


class Log10(Builtin):
    """
    <dl>
    <dt>'Log10[$z$]'
        <dd>returns the base-10 logarithm of $z$.
    </dl>

    >> Log10[1000]
     = 3
    >> Log10[{2., 5.}]
     = {0.301029995663981195, 0.698970004336018805}
    >> Log10[E ^ 3]
     = 3 / Log[10]
    """

    rules = {
        'Log10[x_]': 'Log[10, x]',
    }


class Sin(_MPMathFunction):
    """
    <dl>
    <dt>'Sin[$z$]'
        <dd>returns the sine of $z$.
    </dl>

    >> Sin[0]
     = 0
    >> Sin[0.5]
     = 0.479425538604203
    >> Sin[3 Pi]
     = 0
    >> Sin[1.0 + I]
     = 1.29845758141597729 + 0.634963914784736108 I

    >> Plot[Sin[x], {x, -Pi, Pi}]
     = -Graphics-
    """

    mpmath_name = 'sin'

    rules = {
        'Sin[Pi]': '0',
        'Sin[n_Integer*Pi]': '0',
        'Sin[(1/2) * Pi]': '1',
        'Sin[0]': '0',
        'Derivative[1][Sin]': 'Cos[#]&',
    }


class Cos(_MPMathFunction):
    """
    <dl>
    <dt>'Cos[$z$]'
        <dd>returns the cosine of $z$.
    </dl>

    >> Cos[3 Pi]
     = -1
    """

    mpmath_name = 'cos'

    rules = {
        'Cos[Pi]': '-1',
        'Cos[n_Integer * Pi]': '(-1)^n',
        'Cos[(1/2) * Pi]': '0',
        'Cos[0]': '1',
        'Derivative[1][Cos]': '-Sin[#]&',
    }


class Tan(_MPMathFunction):
    """
    <dl>
    <dt>'Tan[$z$]'
        <dd>returns the tangent of $z$.
    </dl>

    >> Tan[0]
     = 0
    >> Tan[Pi / 2]
     = ComplexInfinity
    """

    mpmath_name = 'tan'

    rules = {
        'Tan[(1/2) * Pi]': 'ComplexInfinity',
        'Tan[0]': '0',
        'Derivative[1][Tan]': 'Sec[#]^2&',
    }


class Sec(_MPMathFunction):
    """
    <dl>
    <dt>'Sec[$z$]'
        <dd>returns the secant of $z$.
    </dl>

    >> Sec[0]
     = 1
    >> Sec[1] (* Sec[1] in Mathematica *)
     = 1 / Cos[1]
    >> Sec[1.]
     = 1.85081571768092562
    """

    mpmath_name = 'sec'

    rules = {
        'Derivative[1][Sec]': 'Sec[#] Tan[#]&',
        'Sec[0]': '1',
    }

    def to_sympy(self, expr, **kwargs):
        if len(expr.leaves) == 1:
            return Expression('Power', Expression('Cos', expr.leaves[0]),
                              Integer(-1)).to_sympy()


class Csc(_MPMathFunction):
    """
    <dl>
    <dt>'Csc[$z$]'
        <dd>returns the cosecant of $z$.
    </dl>

    >> Csc[0]
     = ComplexInfinity
    >> Csc[1] (* Csc[1] in Mathematica *)
     = 1 / Sin[1]
    >> Csc[1.]
     = 1.18839510577812122
    """

    mpmath_name = 'csc'

    rules = {
        'Derivative[1][Csc]': '-Cot[#] Csc[#]&',
        'Csc[0]': 'ComplexInfinity',
    }

    def to_sympy(self, expr, **kwargs):
        if len(expr.leaves) == 1:
            return Expression('Power', Expression('Sin', expr.leaves[0]),
                              Integer(-1)).to_sympy()


class Cot(_MPMathFunction):
    """
    <dl>
    <dt>'Cot[$z$]'
        <dd>returns the cotangent of $z$.
    </dl>

    >> Cot[0]
     = ComplexInfinity
    >> Cot[1.]
     = 0.642092615934330703
    """

    mpmath_name = 'cot'

    rules = {
        'Derivative[1][Cot]': '-Csc[#]^2&',
        'Cot[0]': 'ComplexInfinity',
    }


class ArcSin(_MPMathFunction):
    """
    <dl>
    <dt>'ArcSin[$z$]'
        <dd>returns the inverse sine of $z$.
    </dl>

    >> ArcSin[0]
     = 0
    >> ArcSin[1]
     = Pi / 2
    """

    sympy_name = 'asin'
    mpmath_name = 'asin'

    rules = {
        'Derivative[1][ArcSin]': '1/Sqrt[1-#^2]&',
        'ArcSin[0]': '0',
        'ArcSin[1]': 'Pi / 2',
    }


class ArcCos(_MPMathFunction):
    """
    <dl>
    <dt>'ArcCos[$z$]'
        <dd>returns the inverse cosine of $z$.
    </dl>

    >> ArcCos[1]
     = 0
    >> ArcCos[0]
     = Pi / 2
    >> Integrate[ArcCos[x], {x, -1, 1}]
     = Pi
    """

    sympy_name = 'acos'
    mpmath_name = 'acos'

    rules = {
        'Derivative[1][ArcCos]': '-1/Sqrt[1-#^2]&',
        'ArcCos[0]': 'Pi / 2',
        'ArcCos[1]': '0',
    }


class ArcTan(_MPMathFunction):
    """
    <dl>
    <dt>'ArcTan[$z$]'
        <dd>returns the inverse tangent of $z$.
    </dl>

    >> ArcTan[1]
     = Pi / 4
    >> ArcTan[1.0]
     = 0.78539816339744831
    >> ArcTan[-1.0]
     = -0.78539816339744831

    >> ArcTan[1, 1]
     = Pi / 4
    #> ArcTan[-1, 1]
     = 3 Pi / 4
    #> ArcTan[1, -1]
     = -Pi / 4
    #> ArcTan[-1, -1]
     = -3 Pi / 4

    #> ArcTan[1, 0]
     = 0
    #> ArcTan[-1, 0]
     = Pi
    #> ArcTan[0, 1]
     = Pi / 2
    #> ArcTan[0, -1]
     = -Pi / 2
    """

    sympy_name = 'atan'
    mpmath_name = 'atan'

    rules = {
        'ArcTan[1]': 'Pi/4',
        'ArcTan[0]': '0',
        'Derivative[1][ArcTan]': '1/(1+#^2)&',
        'ArcTan[x_?RealNumberQ, y_?RealNumberQ]':
        '''If[x == 0, If[y == 0, 0, If[y > 0, Pi/2, -Pi/2]], If[x > 0,
            ArcTan[y/x], If[y >= 0, ArcTan[y/x] + Pi, ArcTan[y/x] - Pi]]]''',
    }


class ArcSec(_MPMathFunction):
    """
    <dl>
    <dt>'ArcSec[$z$]'
        <dd>returns the inverse secant of $z$.
    </dl>

    >> ArcSec[1]
     = 0
    >> ArcSec[-1]
     = Pi
    """

    sympy_name = ''
    mpmath_name = 'asec'

    rules = {
        'Derivative[1][ArcSec]': '1 / (Sqrt[1 - 1/#^2] * #^2)&',
        'ArcSec[0]': 'ComplexInfinity',
        'ArcSec[1]': '0',
    }

    def to_sympy(self, expr, **kwargs):
        if len(expr.leaves) == 1:
            return Expression('ArcCos', Expression('Power', expr.leaves[0],
                              Integer(-1))).to_sympy()


class ArcCsc(_MPMathFunction):
    """
    <dl>
    <dt>'ArcCsc[$z$]'
        <dd>returns the inverse cosecant of $z$.
    </dl>

    >> ArcCsc[1]
     = Pi / 2
    >> ArcCsc[-1]
     = -Pi / 2
    """

    sympy_name = ''
    mpmath_name = 'acsc'

    rules = {
        'Derivative[1][ArcCsc]': '-1 / (Sqrt[1 - 1/#^2] * #^2)&',
        'ArcCsc[0]': 'ComplexInfinity',
        'ArcCsc[1]': 'Pi / 2',
    }

    def to_sympy(self, expr, **kwargs):
        if len(expr.leaves) == 1:
            return Expression('ArcSin', Expression('Power', expr.leaves[0],
                              Integer(-1))).to_sympy()


class ArcCot(_MPMathFunction):
    """
    <dl>
    <dt>'ArcCot[$z$]'
        <dd>returns the inverse cotangent of $z$.
    </dl>

    >> ArcCot[0]
     = Pi / 2
    >> ArcCot[1]
     = Pi / 4
    """

    sympy_name = 'acot'
    mpmath_name = 'acot'

    rules = {
        'Derivative[1][ArcCot]': '-1/(1+#^2)&',
        'ArcCot[0]': 'Pi / 2',
        'ArcCot[1]': 'Pi / 4',
    }


class Sinh(_MPMathFunction):
    """
    <dl>
    <dt>'Sinh[$z$]'
        <dd>returns the hyperbolic sine of $z$.
    </dl>

    >> Sinh[0]
     = 0
    """

    mpmath_name = 'sinh'

    rules = {
        'Derivative[1][Sinh]': 'Cosh[#]&',
    }


class Cosh(_MPMathFunction):
    """
    <dl>
    <dt>'Cosh[$z$]'
        <dd>returns the hyperbolic cosine of $z$.
    </dl>

    >> Cosh[0]
     = 1
    """

    mpmath_name = 'cosh'

    rules = {
        'Derivative[1][Cosh]': 'Sinh[#]&',
    }


class Tanh(_MPMathFunction):
    """
    <dl>
    <dt>'Tanh[$z$]'
        <dd>returns the hyperbolic tangent of $z$.
    </dl>

    >> Tanh[0]
     = 0
    """

    mpmath_name = 'tanh'

    rules = {
        'Derivative[1][Tanh]': 'Sech[#1]^2&',
    }


class Sech(_MPMathFunction):
    """
    <dl>
    <dt>'Sech[$z$]'
        <dd>returns the hyperbolic secant of $z$.
    </dl>

    >> Sech[0]
     = 1
    """

    sympy_name = ''
    mpmath_name = 'sech'

    rules = {
        'Derivative[1][Sech]': '-Sech[#1] Tanh[#1]&',
    }

    def to_sympy(self, expr, **kwargs):
        if len(expr.leaves) == 1:
            return Expression('Power', Expression('Cosh', expr.leaves[0]),
                              Integer(-1)).to_sympy()


class Csch(_MPMathFunction):
    """
    <dl>
    <dt>'Csch[$z$]'
        <dd>returns the hyperbolic cosecant of $z$.
    </dl>

    >> Csch[0]
     = ComplexInfinity
    """

    sympy_name = ''
    mpmath_name = 'csch'

    rules = {
        'Csch[0]': 'ComplexInfinity',
        'Csch[0.]': 'ComplexInfinity',
        'Derivative[1][Csch]': '-Coth[#1] Csch[#1]&',
    }

    def to_sympy(self, expr, **kwargs):
        if len(expr.leaves) == 1:
            return Expression('Power', Expression('Sinh', expr.leaves[0]),
                              Integer(-1)).to_sympy()


class Coth(_MPMathFunction):
    """
    <dl>
    <dt>'Coth[$z$]'
        <dd>returns the hyperbolic cotangent of $z$.
    </dl>

    >> Coth[0]
     = ComplexInfinity
    """

    mpmath_name = 'coth'

    rules = {
        'Coth[0]': 'ComplexInfinity',
        'Coth[0.]': 'ComplexInfinity',
        'Derivative[1][Coth]': '-Csch[#1]^2&',
    }


class ArcSinh(_MPMathFunction):
    """
    <dl>
    <dt>'ArcSinh[$z$]'
        <dd>returns the inverse hyperbolic sine of $z$.
    </dl>

    >> ArcSinh[0]
     = 0
    >> ArcSinh[0.]
     = 0.
    >> ArcSinh[1.0]
     = 0.881373587019543025
    """

    sympy_name = 'asinh'
    mpmath_name = 'asinh'

    rules = {
        'Derivative[1][ArcSinh]': '1/Sqrt[1+#^2]&',
    }


class ArcCosh(_MPMathFunction):
    """
    <dl>
    <dt>'ArcCosh[$z$]'
        <dd>returns the inverse hyperbolic cosine of $z$.
    </dl>

    >> ArcCosh[0]
     = I / 2 Pi
    >> ArcCosh[0.]
     = 0. + 1.57079632679489662 I
    >> ArcCosh[0.00000000000000000000000000000000000000]
     = 0. + 1.5707963267948966191479842624545426588 I

    #> ArcCosh[1.4]
     = 0.867014726490565104
    """

    sympy_name = 'acosh'
    mpmath_name = 'acosh'

    rules = {
        'ArcCosh[z:0.0]': 'N[I / 2 Pi, Precision[1+z]]',
        'Derivative[1][ArcCosh]': '1/(Sqrt[#-1]*Sqrt[#+1])&',
    }


class ArcTanh(_MPMathFunction):
    """
    <dl>
    <dt>'ArcTanh[$z$]'
        <dd>returns the inverse hyperbolic tangent of $z$.
    </dl>

    >> ArcTanh[0]
     = 0
    >> ArcTanh[1]
     = Infinity
    >> ArcTanh[0]
     = 0
    >> ArcTanh[.5 + 2 I]
     = 0.0964156202029961672 + 1.12655644083482235 I
    >> ArcTanh[2 + I]
     = ArcTanh[2 + I]
    """

    sympy_name = 'atanh'
    mpmath_name = 'atanh'

    rules = {
        'Derivative[1][ArcTanh]': '1/(1-#^2)&',
    }


class ArcSech(_MPMathFunction):
    """
    <dl>
    <dt>'ArcSech[$z$]'
        <dd>returns the inverse hyperbolic secant of $z$.
    </dl>

    >> ArcSech[0]
     = Infinity
    >> ArcSech[1]
     = 0
    >> ArcSech[0.5]
     = 1.31695789692481671
    """

    sympy_name = ''
    mpmath_name = 'asech'

    rules = {
        'ArcSech[0]': 'Infinity',
        'ArcSech[0.]': 'Indeterminate',
        'Derivative[1][ArcSech]': '-1 / (# * Sqrt[(1-#)/(1+#)] (1+#)) &',
    }

    def to_sympy(self, expr, **kwargs):
        if len(expr.leaves) == 1:
            return Expression('ArcCosh', Expression('Power', expr.leaves[0],
                              Integer(-1))).to_sympy()


class ArcCsch(_MPMathFunction):
    """
    <dl>
    <dt>'ArcCsch[$z$]'
        <dd>returns the inverse hyperbolic cosecant of $z$.
    </dl>

    >> ArcCsch[0]
     = ComplexInfinity
    >> ArcCsch[1.0]
     = 0.881373587019543025
    """

    sympy_name = ''
    mpmath_name = 'acsch'

    rules = {
        'ArcCsch[0]': 'ComplexInfinity',
        'ArcCsch[0.]': 'ComplexInfinity',
        'Derivative[1][ArcCsch]': '-1 / (Sqrt[1+1/#^2] * #^2) &',
    }

    def to_sympy(self, expr, **kwargs):
        if len(expr.leaves) == 1:
            return Expression('ArcSinh', Expression('Power', expr.leaves[0],
                              Integer(-1))).to_sympy()


class ArcCoth(_MPMathFunction):
    """
    <dl>
    <dt>'ArcCoth[$z$]'
        <dd>returns the inverse hyperbolic cotangent of $z$.
    </dl>

    >> ArcCoth[0]
     = I / 2 Pi
    >> ArcCoth[1]
     = Infinity
    >> ArcCoth[0.0]
     = 0. + 1.57079632679489662 I
    >> ArcCoth[0.5]
     = 0.549306144334054846 - 1.57079632679489662 I
    """

    sympy_name = 'acoth'
    mpmath_name = 'acoth'

    rules = {
        'ArcCoth[z:0.0]': 'N[I / 2 Pi, Precision[1+z]]',
        'Derivative[1][ArcCoth]': '1/(1-#^2)&',
    }

########NEW FILE########
__FILENAME__ = files
# -*- coding: utf8 -*-

"""
File Operations
"""

from __future__ import with_statement
import os
import io
import shutil
import hashlib
import zlib
import base64
import tempfile
import time
import struct
import sympy
import math

from mathics.core.expression import (Expression, Real, Complex, String, Symbol,
                                     from_python, Integer, BoxError)
from mathics.builtin.base import (Builtin, Predefined, BinaryOperator,
                                  PrefixOperator)
from mathics.settings import ROOT_DIR

INITIAL_DIR = os.getcwd()
HOME_DIR = os.path.expanduser('~')
SYS_ROOT_DIR = '/' if os.name == 'posix' else '\\'
TMP_DIR = tempfile.gettempdir()
DIRECTORY_STACK = [INITIAL_DIR]
INPUT_VAR = ""
INPUTFILE_VAR = ""
PATH_VAR = [HOME_DIR, os.path.join(ROOT_DIR, 'data'),
            os.path.join(ROOT_DIR, 'packages')]


def path_search(filename):
    # For names of the form "name`", search for name.mx and name.m
    if filename[-1] == '`':
        filename = filename[:-1].replace('`', os.path.sep)
        for ext in ['.mx', '.m']:
            result = path_search(filename + ext)
            if result is not None:
                filename = None
                break

    if filename is not None:
        result = None
        for p in PATH_VAR + ['']:
            path = os.path.join(p, filename)
            if os.path.exists(path):
                result = path
                break

    # If FindFile resolves to a dir, search within for Kernel/init.m and init.m
    if result is not None and os.path.isdir(result):
        for ext in [os.path.join('Kernel', 'init.m'), 'init.m']:
            tmp = os.path.join(result, ext)
            if os.path.isfile(tmp):
                return tmp
    return result


def count():
    n = 0
    while True:
        yield n
        n += 1

NSTREAMS = count()      # use next(NSTREAMS)
STREAMS = []


def _channel_to_stream(channel, mode='r'):
    if isinstance(channel, String):
        name = channel.get_string_value()
        opener = mathics_open(name, mode)
        opener.__enter__()
        n = opener.n
        if mode in ['r', 'rb']:
            head = 'InputStream'
        elif mode in ['w', 'a', 'wb', 'ab']:
            head = 'OutputStream'
        else:
            raise ValueError("Unknown format {0}".format(mode))
        return Expression(head, channel, Integer(n))
    elif channel.has_form('InputStream', 2):
        return channel
    elif channel.has_form('OutputStream', 2):
        return channel
    else:
        return None


def _lookup_stream(n=None):
    if n is None:
        return None
    elif n is not None:
        try:
            return STREAMS[n]
        except IndexError:
            return None


class mathics_open:
    def __init__(self, name, mode='r'):
        self.name = name
        self.mode = mode

        if mode not in ['r', 'w', 'a', 'rb', 'wb', 'ab']:
            raise ValueError("Can't handle mode {0}".format(mode))

    def __enter__(self):
        # find path
        path = path_search(self.name)
        if path is None and self.mode in ['w', 'a', 'wb', 'ab']:
            path = self.name
        if path is None:
            raise IOError

        # determine encoding
        encoding = 'utf-8' if 'b' not in self.mode else None

        # open the stream
        stream = io.open(path, self.mode, encoding=encoding)

        # build the Expression
        n = next(NSTREAMS)
        if self.mode in ['r', 'rb']:
            self.expr = Expression(
                'InputStream', String(path), Integer(n))
        elif self.mode in ['w', 'a', 'wb', 'ab']:
            self.expr = Expression(
                'OutputStream', String(path), Integer(n))
        else:
            raise IOError

        STREAMS.append(stream)

        self.n = n

        return stream

    def __exit__(self, type, value, traceback):
        strm = STREAMS[self.n]
        if strm is not None:
            strm.close()
            STREAMS[self.n] = None


class InitialDirectory(Predefined):
    """
    <dl>
    <dt>'$InitialDirectory'
      <dd>returns the directory from which \Mathics was started.
    </dl>

    >> $InitialDirectory
     = ...
    """

    name = '$InitialDirectory'

    def evaluate(self, evaluation):
        global INITIAL_DIR
        return String(INITIAL_DIR)


class InstallationDirectory(Predefined):
    """
    <dl>
    <dt>'$InstallationDirectory'
      <dd>returns the directory in which \Mathics was installed.
    </dl>

    >> $InstallationDirectory
     = ...
    """

    name = '$InstallationDirectory'

    def evaluate(self, evaluation):
        global ROOT_DIR
        return String(ROOT_DIR)


class HomeDirectory(Predefined):
    """
    <dl>
    <dt>'$HomeDirectory'
      <dd>returns the users HOME directory.
    </dl>

    >> $HomeDirectory
     = ...
    """

    name = '$HomeDirectory'

    attributes = ('Protected')

    def evaluate(self, evaluation):
        global HOME_DIR
        return String(HOME_DIR)


class RootDirectory(Predefined):
    """
    <dl>
    <dt>'$RootDirectory'
      <dd>returns the system root directory.
    </dl>

    >> $RootDirectory
     = ...
    """

    name = '$RootDirectory'

    attributes = ('Protected')

    def evaluate(self, evaluation):
        global SYS_ROOT_DIR
        return String(SYS_ROOT_DIR)


class TemporaryDirectory(Predefined):
    """
    <dl>
    <dt>'$TemporaryDirectory'
      <dd>returns the directory used for temporary files.
    </dl>

    >> $TemporaryDirectory
     = ...
    """

    name = '$TemporaryDirectory'

    def evaluate(self, evaluation):
        return String(TMP_DIR)


class Input(Predefined):
    """
    <dl>
    <dt>'$Input'
      <dd>is the name of the stream from which input is currently being read.
    </dl>

    >> $Input
     = 
    """

    attributes = ('Protected', 'ReadProtected')
    name = '$Input'

    def evaluate(self, evaluation):
        global INPUT_VAR
        return String(INPUT_VAR)


class InputFileName(Predefined):
    """
    <dl>
    <dt>'$InputFileName'
      <dd>is the name of the file from which input is currently being read.
    </dl>

    While in interactive mode, '$InputFileName' is "".
    >> $InputFileName
     = 
    """

    name = '$InputFileName'

    def evaluate(self, evaluation):
        global INPUTFILE_VAR
        return String(INPUTFILE_VAR)


class PathnameSeparator(Predefined):
    """
    <dl>
    <dt>'$PathnameSeparator'
      <dd>returns a string for the seperator in paths.
    </dl>

    >> $PathnameSeparator
     = ...
    """

    name = '$PathnameSeparator'

    def evaluate(self, evaluation):
        return String(os.sep)


class Path(Predefined):
    """
    <dl>
    <dt>'$Path'
      <dd>returns the list of directories to search when looking for a file.
    </dl>

    >> $Path
     = ...
    """

    attributes = ('Protected')
    name = '$Path'

    def evaluate(self, evaluation):
        return Expression('List', *[String(p) for p in PATH_VAR])


class OperatingSystem(Predefined):
    """
    <dl>
    <dt>'$OperatingSystem'
      <dd>gives the type of operating system running Mathics.
    </dl>

    >> $OperatingSystem
     = ...
    """

    attributes = ('Locked', 'Protected')
    name = '$OperatingSystem'

    def evaluate(self, evaluation):
        if os.name == 'posix':
            return String('Unix')
        elif os.name == 'nt':
            return String('Windows')
        elif os.name == 'os2':
            return String('MacOSX')
        else:
            return String('Unknown')


class Read(Builtin):
    """
    <dl>
    <dt>'Read[stream]'
      <dd>reads the input stream and returns one expression.
    <dt>'Read[stream, type]'
      <dd>reads the input stream and returns an object of the given type.
    </dl>

    ## Malformed InputString
    #> Read[InputStream[String], {Word, Number}]
     = Read[InputStream[String], {Word, Number}]

    ## Correctly formed InputString but not open
    #> Read[InputStream[String, -1], {Word, Number}]
     : InputStream[String, -1] is not open.
     = Read[InputStream[String, -1], {Word, Number}]

    ## String
    >> str = StringToStream["abc123"];
    >> Read[str, String]
     = abc123
    #> Read[str, String]
     = EndOfFile
    #> Close[str];

    ## Word
    >> str = StringToStream["abc 123"];
    >> Read[str, Word]
     = abc
    >> Read[str, Word]
     = 123
    #> Read[str, Word]
     = EndOfFile
    #> Close[str];
    #> str = StringToStream[""];
    #> Read[str, Word]
     = EndOfFile
    #> Read[str, Word]
     = EndOfFile
    #> Close[str];

    ## Number
    >> str = StringToStream["123, 4"];
    >> Read[str, Number]
     = 123
    >> Read[str, Number]
     = 4
    #> Read[str, Number]
     = EndOfFile
    #> Close[str];
    #> str = StringToStream["123xyz 321"];
    #> Read[str, Number]
     = 123
    #> Quiet[Read[str, Number]]
     = $Failed

    ## Real
    #> str = StringToStream["123, 4abc"];
    #> Read[str, Real]
     = 123.
    #> Read[str, Real]
     = 4.
    #> Quiet[Read[str, Number]]
     = $Failed

    #> Close[str];
    #> str = StringToStream["1.523E-19"]; Read[str, Real]
     = 1.523*^-19
    #> Close[str];
    #> str = StringToStream["-1.523e19"]; Read[str, Real]
     = -1.523*^19
    #> Close[str];
    #> str = StringToStream["3*^10"]; Read[str, Real]
     = 3.*^10
    #> Close[str];
    #> str = StringToStream["3.*^10"]; Read[str, Real]
     = 3.*^10
    #> Close[str];

    ## Expression
    #> str = StringToStream["x + y Sin[z]"]; Read[str, Expression]
     = x + y Sin[z]
    #> Close[str];
    ## #> str = Quiet[StringToStream["Sin[1 123"]; Read[str, Expression]]
    ##  = $Failed

    ## Multiple types
    >> str = StringToStream["123 abc"];
    >> Read[str, {Number, Word}]
     = {123, abc}
    #> Read[str, {Number, Word}]
     = EndOfFile
    #> Close[str];

    #> str = StringToStream["123 abc"];
    #> Quiet[Read[str, {Word, Number}]]
     = $Failed
    #> Close[str];

    #> str = StringToStream["123 123"];  Read[str, {Real, Number}]
     = {123., 123}
    #> Close[str];

    #> Quiet[Read[str, {Real}]]
     = Read[InputStream[String, ...], {Real}]
    """

    messages = {
        'openx': '`1` is not open.',
        'readf': '`1` is not a valid format specification.',
        'readn': 'Invalid real number found when reading from `1`.',
        'readt': 'Invalid input found when reading `1` from `2`.',
        'intnm': ('Non-negative machine-sized integer expected at '
                  'position 3 in `1`.'),
    }

    rules = {
        'Read[stream_]': 'Read[stream, Expression]',
    }

    options = {
        'NullRecords': 'False',
        'NullWords': 'False',
        'RecordSeparators': '{"\r\n", "\n", "\r"}',
        'TokenWords': '{}',
        'WordSeparators': '{" ", "\t"}',
    }

    attributes = ('Protected')

    def check_options(self, options):
        ## Options:
        # TODO: Proper error messages

        result = {}
        keys = options.keys()

        # AnchoredSearch
        if 'AnchoredSearch' in keys:
            anchored_search = options['AnchoredSearch'].to_python()
            assert anchored_search in [True, False]
            result['AnchoredSearch'] = anchored_search

        # IgnoreCase
        if 'IgnoreCase' in keys:
            ignore_case = options['IgnoreCase'].to_python()
            assert ignore_case in [True, False]
            result['IgnoreCase'] = ignore_case

        # WordSearch
        if 'WordSearch' in keys:
            word_search = options['WordSearch'].to_python()
            assert word_search in [True, False]
            result['WordSearch'] = word_search

        # RecordSeparators
        if 'RecordSeparators' in keys:
            record_separators = options['RecordSeparators'].to_python()
            assert isinstance(record_separators, list)
            assert all(isinstance(s, basestring) and s[
                       0] == s[-1] == '"' for s in record_separators)
            record_separators = [s[1:-1] for s in record_separators]
            result['RecordSeparators'] = record_separators

        # WordSeparators
        if 'WordSeparators' in keys:
            word_separators = options['WordSeparators'].to_python()
            assert isinstance(word_separators, list)
            assert all(isinstance(s, basestring) and s[
                       0] == s[-1] == '"' for s in word_separators)
            word_separators = [s[1:-1] for s in word_separators]
            result['WordSeparators'] = word_separators

        # NullRecords
        if 'NullRecords' in keys:
            null_records = options['NullRecords'].to_python()
            assert null_records in [True, False]
            result['NullRecords'] = null_records

        # NullWords
        if 'NullWords' in keys:
            null_words = options['NullWords'].to_python()
            assert null_words in [True, False]
            result['NullWords'] = null_words

        # TokenWords
        if 'TokenWords' in keys:
            token_words = options['TokenWords'].to_python()
            assert token_words == []
            result['TokenWords'] = token_words

        return result

    def apply(self, channel, types, evaluation, options):
        'Read[channel_, types_, OptionsPattern[Read]]'

        if channel.has_form('OutputStream', 2):
            evaluation.message('General', 'openw', channel)
            return

        strm = _channel_to_stream(channel, 'r')

        if strm is None:
            return

        [name, n] = strm.get_leaves()

        stream = _lookup_stream(n.get_int_value())

        if stream is None or stream.closed:
            evaluation.message('Read', 'openx', strm)
            return

        types = types.to_python()
        if not isinstance(types, list):
            types = [types]

        READ_TYPES = ['Byte', 'Character', 'Expression',
                      'Number', 'Real', 'Record', 'String', 'Word']

        for typ in types:
            if not (isinstance(typ, basestring) and typ in READ_TYPES):
                evaluation.message('Read', 'readf', from_python(typ))
                return Symbol('$Failed')

        ## Options:
        # TODO: Implement extra options
        py_options = self.check_options(options)
        # null_records = py_options['NullRecords']
        # null_words = py_options['NullWords']
        record_separators = py_options['RecordSeparators']
        # token_words = py_options['TokenWords']
        word_separators = py_options['WordSeparators']

        name = name.to_python()

        result = []

        def reader(stream, word_separators, accepted=None):
            while True:
                word = ''
                while True:
                    tmp = stream.read(1)

                    if tmp == '':
                        if word == '':
                            raise EOFError
                        yield word

                    if tmp in word_separators:
                        if word == '':
                            break
                        if stream.seekable():
                            # stream.seek(-1, 1) #Python3
                            stream.seek(stream.tell() - 1)
                        yield word

                    if accepted is not None and tmp not in accepted:
                        yield word

                    word += tmp

        read_word = reader(stream, word_separators)
        read_record = reader(stream, record_separators)
        read_number = reader(stream, word_separators + record_separators,
                             ['+', '-', '.'] + [str(i) for i in range(10)])
        read_real = reader(
            stream, word_separators + record_separators,
            ['+', '-', '.', 'e', 'E', '^', '*'] + [str(i) for i in range(10)])
        for typ in types:
            try:
                if typ == 'Byte':
                    tmp = stream.read(1)
                    if tmp == '':
                        raise EOFError
                    result.append(ord(tmp))
                elif typ == 'Character':
                    tmp = stream.read(1)
                    if tmp == '':
                        raise EOFError
                    result.append(tmp)
                elif typ == 'Expression':
                    tmp = read_record.next()
                    try:
                        try:
                            expr = parse(tmp)
                        except NameError:
                            from mathics.core.parser import parse, ParseError
                            expr = parse(tmp)
                    except ParseError:
                        expr = None
                    if expr is None:
                        evaluation.message('Read', 'readt', tmp, Expression(
                            'InputSteam', name, n))
                        return Symbol('$Failed')
                    result.append(tmp)
                elif typ == 'Number':
                    tmp = read_number.next()
                    try:
                        tmp = int(tmp)
                    except ValueError:
                        try:
                            tmp = float(tmp)
                        except ValueError:
                            evaluation.message('Read', 'readn', Expression(
                                'InputSteam', name, n))
                            return Symbol('$Failed')
                    result.append(tmp)

                elif typ == 'Real':
                    tmp = read_real.next()
                    tmp = tmp.replace('*^', 'E')
                    try:
                        tmp = float(tmp)
                    except ValueError:
                        evaluation.message('Read', 'readn', Expression(
                            'InputSteam', name, n))
                        return Symbol('$Failed')
                    result.append(tmp)
                elif typ == 'Record':
                    result.append(read_record.next())
                elif typ == 'String':
                    tmp = stream.readline()
                    if len(tmp) == 0:
                        raise EOFError
                    result.append(tmp.rstrip('\n'))
                elif typ == 'Word':
                    result.append(read_word.next())

            except EOFError:
                return Symbol('EndOfFile')

        if len(result) == 1:
            return from_python(*result)

        return from_python(result)

    def apply_nostream(self, arg1, arg2, evaluation):
        'Read[arg1_, arg2_]'
        evaluation.message('General', 'stream', arg1)
        return


class Write(Builtin):
    """
    <dl>
    <dt>'Write[$channel$, $expr1$, $expr2$, ...]'
      <dd>writes the expressions to the output channel followed by a newline.
    </dl>

    >> str = OpenWrite[]
     = ...
    >> Write[str, 10 x + 15 y ^ 2]
    >> Write[str, 3 Sin[z]]
    >> Close[str]
     = ...
    >> str = OpenRead[%];
    >> ReadList[str]
     = {10 x + 15 y ^ 2, 3 Sin[z]}
    #> Close[str];
    """

    attributes = ('Protected')

    def apply(self, channel, expr, evaluation):
        'Write[channel_, expr___]'

        strm = _channel_to_stream(channel)

        if strm is None:
            return

        n = strm.leaves[1].get_int_value()
        stream = _lookup_stream(n)

        if stream is None or stream.closed:
            evaluation.message('General', 'openx', name)
            return

        expr = expr.get_sequence()
        expr = Expression('Row', Expression('List', *expr))

        evaluation.format = 'text'
        text = evaluation.format_output(from_python(expr))
        stream.write(unicode(text) + u'\n')
        return Symbol('Null')


class _BinaryFormat(object):
    """
    Container for BinaryRead readers and BinaryWrite writers
    """

    @staticmethod
    def _IEEE_real(real):
        if math.isnan(real):
            return Symbol('Indeterminate')
        elif math.isinf(real):
            return Expression('DirectedInfinity', Integer((-1) ** (real < 0)))
        else:
            return Real(real)

    @staticmethod
    def _IEEE_cmplx(real, imag):
        if math.isnan(real) or math.isnan(imag):
            return Symbol('Indeterminate')
        elif math.isinf(real) or math.isinf(imag):
            if math.isinf(real) and math.isinf(imag):
                return Symbol('Indeterminate')
            return Expression('DirectedInfinity', Expression(
                'Complex', 
                (-1) ** (real < 0) if math.isinf(real) else 0,
                (-1) ** (imag < 0) if math.isinf(imag) else 0))
        else:
            return Complex(real, imag)

    @classmethod
    def get_readers(cls):
        readers = {}
        for funcname in dir(cls):
            if funcname.startswith('_') and funcname.endswith('_reader'):
                readers[funcname[1:-7]] = getattr(cls, funcname)
        return readers

    @classmethod
    def get_writers(cls):
        writers = {}
        for funcname in dir(cls):
            if funcname.startswith('_') and funcname.endswith('_writer'):
                writers[funcname[1:-7]] = getattr(cls, funcname)
        return writers

    # Reader Functions

    @staticmethod
    def _Byte_reader(s):
        "8-bit unsigned integer"
        return Integer(*struct.unpack('B', s.read(1)))

    @staticmethod
    def _Character8_reader(s): 
        "8-bit character"
        return String(*struct.unpack('c', s.read(1)))

    @staticmethod
    def _Character16_reader(s):
        "16-bit character"
        return String(unichr(*struct.unpack('H', s.read(2))))

    @staticmethod
    def _Complex64_reader(s):
        "IEEE single-precision complex number"
        return _BinaryFormat._IEEE_cmplx(*struct.unpack('ff', s.read(8)))

    @staticmethod
    def _Complex128_reader(s): 
        "IEEE double-precision complex number"
        return _BinaryFormat._IEEE_cmplx(*struct.unpack('dd', s.read(16)))

    @staticmethod
    def _Complex256_reader(s):
        "IEEE quad-precision complex number"
        return Complex(_Real128_reader(s), _Real128_reader(s))

    @staticmethod
    def _Integer8_reader(s):
        "8-bit signed integer"
        return Integer(*struct.unpack('b', s.read(1)))

    @staticmethod
    def _Integer16_reader(s):
        "16-bit signed integer"
        return Integer(*struct.unpack('h', s.read(2)))

    @staticmethod
    def _Integer24_reader(s):
        "24-bit signed integer"
        b = s.read(3)
        return Integer(*struct.unpack(
            'i', b + ('\0' if b[-1] < '\x80' else '\xff')))

    @staticmethod
    def _Integer32_reader(s):
        "32-bit signed integer"
        return Integer(*struct.unpack('i', s.read(4)))

    @staticmethod
    def _Integer64_reader(s):
        "64-bit signed integer"
        return Integer(*struct.unpack('q', s.read(8)))

    @staticmethod
    def _Integer128_reader(s):
        "128-bit signed integer"
        a, b = struct.unpack('Qq', s.read(16))
        return Integer((b << 64) + a)

    @staticmethod
    def _Real32_reader(s): 
        "IEEE single-precision real number"
        return _BinaryFormat._IEEE_real(*struct.unpack('f', s.read(4)))

    @staticmethod
    def _Real64_reader(s):
        "IEEE double-precision real number"
        return _BinaryFormat._IEEE_real(*struct.unpack('d', s.read(8)))

    @staticmethod
    def _Real128_reader(s):
        "IEEE quad-precision real number"
        # Workaround quad missing from struct
        # correctness is not guaranteed
        b = s.read(16)
        sig, sexp = b[:14], b[14:]

        # Sign / Exponent
        sexp, = struct.unpack('H', sexp)
        signbit = sexp / 0x8000
        expbits = sexp % 0x8000

        # Signifand
        fracbits = int(sig[::-1].encode('hex'), 16)

        if expbits == 0x0000 and fracbits == 0:
            return Real('0.' + '0' * 4965)
        elif expbits == 0x7FFF:
            if fracbits == 0:
                return Expression('DirectedInfinity', Integer((-1) ** signbit))
            else:
                return Symbol('Indeterminate')

        core = sympy.mpmath.fdiv(fracbits, 2 ** 112, prec=128)
        if expbits == 0x000:
            assert fracbits != 0
            exp = -16382
            core = sympy.mpmath.fmul((-1) ** signbit, core, prec=128)
        else:
            assert 0x0001 <= expbits <= 0x7FFE
            exp = expbits - 16383
            core = sympy.mpmath.fmul(
                (-1) ** signbit,
                sympy.mpmath.fadd(1, core, prec=128), prec=128)

        if exp >= 0:
            result = sympy.mpmath.fmul(core, 2 ** exp, prec=128)
        else:
            result = sympy.mpmath.fdiv(core, 2 ** -exp, prec=128)

        return Real(sympy.mpmath.nstr(result, n=38), p=112)

    @staticmethod
    def _TerminatedString_reader(s):
        "null-terminated string of 8-bit characters"
        b = s.read(1)
        string = ''
        while b != '\x00':
            if b == '':
                raise struct.error
            string += b
            b = s.read(1)
        return String(string)

    @staticmethod
    def _UnsignedInteger8_reader(s):
        "8-bit unsigned integer"
        return Integer(*struct.unpack('B', s.read(1)))

    @staticmethod
    def _UnsignedInteger16_reader(s):
        "16-bit unsigned integer"
        return Integer(*struct.unpack('H', s.read(2)))

    @staticmethod
    def _UnsignedInteger24_reader(s):
        "24-bit unsigned integer"
        return Integer(*struct.unpack('I', s.read(3) + '\0'))

    @staticmethod
    def _UnsignedInteger32_reader(s):
        "32-bit unsigned integer"
        return Integer(*struct.unpack('I', s.read(4)))

    @staticmethod
    def _UnsignedInteger64_reader(s):
        "64-bit unsigned integer"
        return Integer(*struct.unpack('Q', s.read(8)))

    @staticmethod
    def _UnsignedInteger128_reader(s):
        "128-bit unsigned integer"
        a, b = struct.unpack('QQ', s.read(16))
        return Integer((b << 64) + a)

    # Writer Functions

    @staticmethod
    def _Byte_writer(s, x):
        "8-bit unsigned integer"
        s.write(struct.pack('B', x))

    @staticmethod
    def _Character8_writer(s, x): 
        "8-bit character"
        s.write(struct.pack('c', x.encode('utf-8')))

    # TODO
    # @staticmethod
    # def _Character16_writer(s, x):
    #     "16-bit character"
    #     pass

    @staticmethod
    def _Complex64_writer(s, x):
        "IEEE single-precision complex number"
        s.write(struct.pack('ff', x.real, x.imag))
        # return _BinaryFormat._IEEE_cmplx(*struct.unpack('ff', s.read(8)))

    @staticmethod
    def _Complex128_writer(s, x): 
        "IEEE double-precision complex number"
        s.write(struct.pack('dd', x.real, x.imag))

    # TODO
    # @staticmethod
    # def _Complex256_writer(s, x):
    #     "IEEE quad-precision complex number"
    #     pass

    @staticmethod
    def _Integer8_writer(s, x):
        "8-bit signed integer"
        s.write(struct.pack('b', x))

    @staticmethod
    def _Integer16_writer(s, x):
        "16-bit signed integer"
        s.write(struct.pack('h', x))

    @staticmethod
    def _Integer24_writer(s, x):
        "24-bit signed integer"
        s.write(struct.pack("i", x << 8)[1:])

    @staticmethod
    def _Integer32_writer(s, x):
        "32-bit signed integer"
        s.write(struct.pack('i', x))

    @staticmethod
    def _Integer64_writer(s, x):
        "64-bit signed integer"
        s.write(struct.pack('q', x))

    @staticmethod
    def _Integer128_writer(s, x):
        "128-bit signed integer"
        a, b = x & 0xFFFFFFFFFFFFFFFF, x >> 64
        s.write(struct.pack('Qq', a, b))

    @staticmethod
    def _Real32_writer(s, x): 
        "IEEE single-precision real number"
        s.write(struct.pack('f', x))

    @staticmethod
    def _Real64_writer(s, x):
        "IEEE double-precision real number"
        s.write(struct.pack('d', x))

    # TODO
    # @staticmethod
    # def _Real128_writer(s, x):
    #     "IEEE quad-precision real number"
    #     pass

    @staticmethod
    def _TerminatedString_writer(s, x):
        "null-terminated string of 8-bit characters"
        s.write(x.encode('utf-8'))

    @staticmethod
    def _UnsignedInteger8_writer(s, x):
        "8-bit unsigned integer"
        s.write(struct.pack('B', x))

    @staticmethod
    def _UnsignedInteger16_writer(s, x):
        "16-bit unsigned integer"
        s.write(struct.pack('H', x))

    @staticmethod
    def _UnsignedInteger24_writer(s, x):
        "24-bit unsigned integer"
        s.write(struct.pack("I", x << 8)[1:])

    @staticmethod
    def _UnsignedInteger32_writer(s, x):
        "32-bit unsigned integer"
        s.write(struct.pack('I', x))

    @staticmethod
    def _UnsignedInteger64_writer(s, x):
        "64-bit unsigned integer"
        s.write(struct.pack('Q', x))

    @staticmethod
    def _UnsignedInteger128_writer(s, x):
        "128-bit unsigned integer"
        a, b = x & 0xFFFFFFFFFFFFFFFF, x >> 64
        s.write(struct.pack('QQ', a, b))


class BinaryWrite(Builtin):
    """
    <dl>
    <dt>'BinaryWrite[$channel$, $b$]'
      <dd>writes a single byte given as an integer from 0 to 255.
    <dt>'BinaryWrite[$channel$, {b1, b2, ...}]'
      <dd>writes a sequence of byte.
    <dt>'BinaryWrite[$channel$, "string"]'
      <dd>writes the raw characters in a string.
    <dt>'BinaryWrite[$channel$, $x$, $type$]'
      <dd>writes $x$ as the specified type.
    <dt>'BinaryWrite[$channel$, {$x1$, $x2$, ...}, $type$]'
      <dd>writes a sequence of objects as the specified type.
    <dt>'BinaryWrite[$channel$, {$x1$, $x2$, ...}, {$type1$, $type2$, ...}]'
      <dd>writes a sequence of objects using a sequence of specified types.
    </dl>

    >> strm = OpenWrite[BinaryFormat -> True]
     = OutputStream[...]
    >> BinaryWrite[strm, {39, 4, 122}]
     = OutputStream[...]
    >> Close[strm]
     = ...
    >> strm = OpenRead[%, BinaryFormat -> True]
     = InputStream[...]
    >> BinaryRead[strm]
     = 39
    >> BinaryRead[strm, "Byte"]
     = 4
    >> BinaryRead[strm, "Character8"]
     = z
    >> Close[strm];

    Write a String
    >> strm = OpenWrite[BinaryFormat -> True]
     = OutputStream[...]
    >> BinaryWrite[strm, "abc123"]
     = OutputStream[...]
    >> Close[%]
     = ...

    Read as Bytes
    >> strm = OpenRead[%, BinaryFormat -> True]
     = InputStream[...]
    >> BinaryRead[strm, {"Character8", "Character8", "Character8", "Character8", "Character8", "Character8", "Character8"}]
     = {a, b, c, 1, 2, 3, EndOfFile}
    >> Close[strm]
     = ...

    Read as Characters
    >> strm = OpenRead[%, BinaryFormat -> True]
     = InputStream[...]
    >> BinaryRead[strm, {"Byte", "Byte", "Byte", "Byte", "Byte", "Byte", "Byte"}]
     = {97, 98, 99, 49, 50, 51, EndOfFile}
    >> Close[strm]
     = ...

    Write Type
    >> strm = OpenWrite[BinaryFormat -> True]
     = OutputStream[...]
    >> BinaryWrite[strm, 97, "Byte"]
     = OutputStream[...]
    >> BinaryWrite[strm, {97, 98, 99}, {"Byte", "Byte", "Byte"}]
     = OutputStream[...]
    >> Close[%]
     = ...

    ## Write then Read as Bytes
    #> WRb[bytes_, form_] := Module[{str, res={}, byte}, str = OpenWrite[BinaryFormat -> True]; BinaryWrite[str, bytes, form]; str = OpenRead[Close[str], BinaryFormat -> True]; While[Not[SameQ[byte = BinaryRead[str], EndOfFile]], res = Join[res, {byte}];]; Close[str]; res]

    ## Byte
    #> WRb[{149, 2, 177, 132}, {"Byte", "Byte", "Byte", "Byte"}]
     = {149, 2, 177, 132}
    #> WRb[{149, 2, 177, 132}, {"Byte", "Byte", "Byte", "Byte"}]
     = {149, 2, 177, 132}
    #> (# == WRb[#, Table["Byte", {50}]]) & [RandomInteger[{0, 255}, 50]]
     = True

    ## Character8
    #> WRb[{"a", "b", "c"}, {"Character8", "Character8", "Character8"}]
     = {97, 98, 99}
    #> WRb[{34, 60, 39}, {"Character8", "Character8", "Character8"}]
     = {51, 52, 54, 48, 51, 57}
    #> WRb[{"ab", "c", "d"}, {"Character8", "Character8", "Character8", "Character8"}]
     = {97, 98, 99, 100}

    ## Character16
    ## TODO

    ## Complex64
    #> WRb[-6.36877988924*^28 + 3.434203392*^9 I, "Complex64"]
     = {80, 201, 77, 239, 201, 177, 76, 79}
    #> WRb[-6.98948862335*^24 + 1.52209021297*^23 I, "Complex64"]
     = {158, 2, 185, 232, 18, 237, 0, 102}
    #> WRb[-1.41079828148*^-19 - 0.013060791418 I, "Complex64"]
     = {195, 142, 38, 160, 238, 252, 85, 188}
    #> WRb[{5, -2054}, "Complex64"]
     = {0, 0, 160, 64, 0, 0, 0, 0, 0, 96, 0, 197, 0, 0, 0, 0}
    #> WRb[Infinity, "Complex64"]
     = {0, 0, 128, 127, 0, 0, 0, 0}
    #> WRb[-Infinity, "Complex64"]
     = {0, 0, 128, 255, 0, 0, 0, 0}
    #> WRb[DirectedInfinity[1 + I], "Complex64"]
     = {0, 0, 128, 127, 0, 0, 128, 127}
    #> WRb[DirectedInfinity[I], "Complex64"]
     = {0, 0, 0, 0, 0, 0, 128, 127}
    ## FIXME (different convention to MMA)
    #> WRb[Indeterminate, "Complex64"]
     = {0, 0, 192, 127, 0, 0, 192, 127}

    ## Complex128
    #> WRb[1.19839770357*^-235 - 2.64656391494*^-54 I,"Complex128"]
     = {102, 217, 1, 163, 234, 98, 40, 15, 243, 104, 116, 15, 48, 57, 208, 180}
    #> WRb[3.22170267142*^134 - 8.98364297498*^198 I,"Complex128"]
     = {219, 161, 12, 126, 47, 94, 220, 91, 189, 66, 29, 68, 147, 11, 62, 233}
    #> WRb[-Infinity, "Complex128"]
     = {0, 0, 0, 0, 0, 0, 240, 255, 0, 0, 0, 0, 0, 0, 0, 0}
    #> WRb[DirectedInfinity[1 - I], "Complex128"]
     = {0, 0, 0, 0, 0, 0, 240, 127, 0, 0, 0, 0, 0, 0, 240, 255}
    #> WRb[DirectedInfinity[I], "Complex128"]
     = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 240, 127}
    ## FIXME (different convention to MMA)
    #> WRb[Indeterminate, "Complex128"]
     = {0, 0, 0, 0, 0, 0, 248, 127, 0, 0, 0, 0, 0, 0, 248, 127}

    ## Complex256
    ## TODO

    ## Integer8
    #> WRb[{5, 2, 11, -4}, {"Integer8", "Integer8", "Integer8", "Integer8"}]
     = {5, 2, 11, 252}
    #> WRb[{127, -128, 0}, {"Integer8", "Integer8", "Integer8"}]
     = {127, 128, 0}

    ## Integer16
    #> WRb[{661, -31567, 6256}, {"Integer16", "Integer16", "Integer16"}]
     = {149, 2, 177, 132, 112, 24}
    #> WRb[{0, 255, -1, 32640, -32640}, Table["Integer16", {5}]]
     = {0, 0, 255, 0, 255, 255, 128, 127, 128, 128}

    ## Integer24
    #> WRb[{-6247016, -6631492}, {"Integer24", "Integer24"}]
     = {152, 173, 160, 188, 207, 154}
    #> WRb[{-1593967, 1989169}, {"Integer24", "Integer24"}]
     = {145, 173, 231, 49, 90, 30}

    ## Integer32
    #> WRb[{-636001327, -236143729}, {"Integer32", "Integer32"}]
     = {209, 99, 23, 218, 143, 187, 236, 241}
    #> WRb[{2024611599, -1139645195}, {"Integer32", "Integer32"}]
     = {15, 31, 173, 120, 245, 100, 18, 188}

    ## Integer64
    #> WRb[{1176115612243989203}, "Integer64"]
     = {211, 18, 152, 2, 235, 102, 82, 16}
    #> WRb[{-8526737900550694619}, "Integer64"]
     = {37, 217, 208, 88, 14, 241, 170, 137}

    ## Integer128
    #> WRb[139827542997232652313568968616424513676, "Integer128"]
     = {140, 32, 24, 199, 10, 169, 248, 117, 123, 184, 75, 76, 34, 206, 49, 105}
    #> WRb[103439096823027953602112616165136677221, "Integer128"]
     = {101, 57, 184, 108, 43, 214, 186, 120, 153, 51, 132, 225, 56, 165, 209, 77}
    #> WRb[-49058912464625098822365387707690163087, "Integer128"]
     = {113, 100, 125, 144, 211, 83, 140, 24, 206, 11, 198, 118, 222, 152, 23, 219}

    ## Real32
    #> WRb[{8.398086656*^9, 1.63880017687*^16}, {"Real32", "Real32"}]
     = {81, 72, 250, 79, 52, 227, 104, 90}
    #> WRb[{5.6052915284*^32, 9.631141*^6}, {"Real32", "Real32"}]
     = {251, 22, 221, 117, 165, 245, 18, 75}
    #> WRb[Infinity, "Real32"]
     = {0, 0, 128, 127}
    #> WRb[-Infinity, "Real32"]
     = {0, 0, 128, 255}
    ## FIXME (different convention to MMA)
    #> WRb[Indeterminate, "Real32"]
     = {0, 0, 192, 127}

    ## Real64
    #> WRb[-5.14646619426*^227, "Real64"]
     = {91, 233, 20, 87, 129, 185, 53, 239}
    #> WRb[-9.69531698809*^20, "Real64"]
     = {187, 67, 162, 67, 122, 71, 74, 196}
    #> WRb[9.67355569764*^159, "Real64"]
     = {132, 48, 80, 125, 157, 4, 38, 97}
    #> WRb[Infinity, "Real64"]
     = {0, 0, 0, 0, 0, 0, 240, 127}
    #> WRb[-Infinity, "Real64"]
     = {0, 0, 0, 0, 0, 0, 240, 255}
    ## FIXME (different convention to MMA)
    #> WRb[Indeterminate, "Real64"]
     = {0, 0, 0, 0, 0, 0, 248, 127}

    ## Real128
    ## TODO

    ## TerminatedString
    #> WRb["abc", "TerminatedString"]
     = {97, 98, 99, 0}
    #> WRb[{"123", "456"}, {"TerminatedString", "TerminatedString", "TerminatedString"}]
     = {49, 50, 51, 0, 52, 53, 54, 0}
    #> WRb["", "TerminatedString"]
    = {0}

    ## UnsignedInteger8
    #> WRb[{96, 94, 141, 162, 141}, Table["UnsignedInteger8", {5}]]
     = {96, 94, 141, 162, 141}
    #> (#==WRb[#,Table["UnsignedInteger8",{50}]])&[RandomInteger[{0, 255}, 50]]
     = True

    ## UnsignedInteger16
    #> WRb[{18230, 47466, 9875, 59141}, Table["UnsignedInteger16", {4}]]
     = {54, 71, 106, 185, 147, 38, 5, 231}
    #> WRb[{0, 32896, 65535}, Table["UnsignedInteger16", {3}]]
     = {0, 0, 128, 128, 255, 255}

    ## UnsignedInteger24
    #> WRb[{14820174, 15488225}, Table["UnsignedInteger24", {2}]]
     = {78, 35, 226, 225, 84, 236}
    #> WRb[{5374629, 3889391}, Table["UnsignedInteger24", {2}]]
     = {165, 2, 82, 239, 88, 59}

    ## UnsignedInteger32
    #> WRb[{1885507541, 4157323149}, Table["UnsignedInteger32", {2}]]
     = {213, 143, 98, 112, 141, 183, 203, 247}
    #> WRb[{384206740, 1676316040}, Table["UnsignedInteger32", {2}]]
     = {148, 135, 230, 22, 136, 141, 234, 99}

    ## UnsignedInteger64
    #> WRb[7079445437368829279, "UnsignedInteger64"]
     = {95, 5, 33, 229, 29, 62, 63, 98}
    #> WRb[5381171935514265990, "UnsignedInteger64"]
     = {134, 9, 161, 91, 93, 195, 173, 74}

    ## UnsignedInteger128
    #> WRb[293382001665435747348222619884289871468, "UnsignedInteger128"]
     = {108, 78, 217, 150, 88, 126, 152, 101, 231, 134, 176, 140, 118, 81, 183, 220}
    #> WRb[253033302833692126095975097811212718901, "UnsignedInteger128"]
     = {53, 83, 116, 79, 81, 100, 60, 126, 202, 52, 241, 48, 5, 113, 92, 190}
    """

    writers = _BinaryFormat.get_writers()

    def apply_notype(self, name, n, b, evaluation):
        'BinaryWrite[OutputStream[name_, n_], b_]'
        return self.apply(name, n, b, None, evaluation)

    def apply(self, name, n, b, typ, evaluation):
        'BinaryWrite[OutputStream[name_, n_], b_, typ_]'

        channel = Expression('OutputStream', name, n)

        # Check channel
        stream = _lookup_stream(n.get_int_value())

        if stream is None or stream.closed:
            evaluation.message('General', 'openx', name)
            return

        if stream.mode not in ['wb', 'ab']:
            evaluation.message('BinaryWrite', 'openr', channel)
            return

        # Check Empty Type
        if typ is None:
            expr = Expression('BinaryWrite', channel, b)
            typ = Expression('List')
        else:
            expr = Expression('BinaryWrite', channel, b, typ)

        # Check b
        if b.has_form('List', None):
            pyb = b.leaves
        else:
            pyb = [b]

        # Check Type
        if typ.has_form('List', None):
            types = typ.get_leaves()
        else:
            types = [typ]

        if len(types) == 0:     # Default type is "Bytes"
            types = [String("Byte")]

        types = [t.get_string_value() for t in types]
        if not all(t in self.writers for t in types):
            evaluation.message('BinaryRead', 'format', typ)
            return

        # Write to stream
        result = []
        i = 0
        while i < len(pyb):
            x = pyb[i]
            # Types are "repeated as many times as necessary"
            t = types[i % len(types)]

            if t in ('Real128', 'Complex256'):
                evaluation.message('BinaryRead', 'warnquad', t)

            # Coerce x
            if t == 'TerminatedString':
                x = x.get_string_value() + '\x00'
            elif t.startswith('Real'):
                if isinstance(x, Real):
                    x = x.to_python()
                elif x.has_form('DirectedInfinity', 1):
                    if x.leaves[0].get_int_value() == 1:
                        x = float('+inf')
                    elif x.leaves[0].get_int_value() == -1:
                        x = float('-inf')
                    else:
                        x = None
                elif isinstance(x, Symbol) and x.get_name() == 'Indeterminate':
                    x = float('nan')
                else:
                    x = None
                assert x is None or isinstance(x, float)
            elif t.startswith('Complex'):
                if isinstance(x, (Complex, Real, Integer)):
                    x = x.to_python()
                elif x.has_form('DirectedInfinity', 1):
                    x = x.leaves[0].to_python(n_evaluation=evaluation)

                    # x*float('+inf') creates nan if x.real or x.imag are zero
                    x = complex(x.real * float('+inf') if x.real != 0 else 0,
                                x.imag * float('+inf') if x.imag != 0 else 0)
                elif isinstance(x, Symbol) and x.get_name() == 'Indeterminate':
                    x = complex(float('nan'), float('nan'))
                else:
                    x = None
            elif t.startswith('Character'):
                if isinstance(x, Integer):
                    x = [String(char) for char in str(x.get_int_value())]
                    pyb = pyb[:i] + x + pyb[i + 1:]
                    x = pyb[i]
                if isinstance(x, String) and len(x.get_string_value()) > 1:
                    x = [String(char) for char in x.get_string_value()] 
                    pyb = pyb[:i] + x + pyb[i + 1:]
                    x = pyb[i]
                x = x.get_string_value()
            elif t == 'Byte' and isinstance(x, String):
                if len(x.get_string_value()) > 1:
                    x = [String(char) for char in x.get_string_value()] 
                    pyb = pyb[:i] + x + pyb[i + 1:]
                    x = pyb[i]
                x = ord(x.get_string_value())
            else:
                x = x.get_int_value()

            if x is None:
                return evaluation.message('BinaryWrite', 'nocoerce', b)

            try:
                self.writers[t](stream, x)
            except struct.error:
                return evaluation.message('BinaryWrite', "nocoerce", b)
            i += 1

        stream.flush()
        return channel 


class BinaryRead(Builtin):
    """
    <dl>
    <dt>'BinaryRead[$stream$]'
      <dd>reads one byte from the stream as an integer from 0 to 255.
    <dt>'BinaryRead[$stream$, $type$]'
      <dd>reads one object of specified type from the stream.
    <dt>'BinaryRead[$stream$, {$type1$, $type2$, ...}]'
      <dd>reads a sequence of objects of specified types.
    </dl>

    >> strm = OpenWrite[BinaryFormat -> True]
     = OutputStream[...]
    >> BinaryWrite[strm, {97, 98, 99}]
     = OutputStream[...]
    >> Close[strm]
     = ...
    >> strm = OpenRead[%, BinaryFormat -> True]
     = InputStream[...]
    >> BinaryRead[strm, {"Character8", "Character8", "Character8"}]
     = {a, b, c}
    >> Close[strm];

    ## Write as Bytes then Read
    #> WbR[bytes_, form_] := Module[{str, res}, str = OpenWrite[BinaryFormat -> True]; BinaryWrite[str, bytes]; str = OpenRead[Close[str], BinaryFormat -> True]; res = BinaryRead[str, form]; Close[str]; res]

    ## Byte
    #> WbR[{149, 2, 177, 132}, {"Byte", "Byte", "Byte", "Byte"}]
     = {149, 2, 177, 132}
    #> (# == WbR[#, Table["Byte", {50}]]) & [RandomInteger[{0, 255}, 50]]
     = True

    ## Character8
    #> WbR[{97, 98, 99}, {"Character8", "Character8", "Character8"}]
     = {a, b, c}
    #> WbR[{34, 60, 39}, {"Character8", "Character8", "Character8"}]
     = {", <, '}

    ## Character16
    #> WbR[{97, 0, 98, 0, 99, 0}, {"Character16", "Character16", "Character16"}]
     = {a, b, c}
    #> ToCharacterCode[WbR[{50, 154, 182, 236}, {"Character16", "Character16"}]]
     = {{39474}, {60598}}
    ## #> WbR[ {91, 146, 206, 54}, {"Character16", "Character16"}]
    ##  = {\:925b, \:36ce}

    ## Complex64
    #> WbR[{80, 201, 77, 239, 201, 177, 76, 79}, "Complex64"]
     = -6.36877988924*^28 + 3.434203392*^9 I
    #> WbR[{158, 2, 185, 232, 18, 237, 0, 102}, "Complex64"]
     = -6.98948862335*^24 + 1.52209021297*^23 I
    #> WbR[{195, 142, 38, 160, 238, 252, 85, 188}, "Complex64"]
     = -1.41079828148*^-19 - 0.013060791418 I

    ## Complex128
    #> WbR[{15,114,1,163,234,98,40,15,214,127,116,15,48,57,208,180},"Complex128"]
     = 1.19839770357*^-235 - 2.64656391494*^-54 I
    #> WbR[{148,119,12,126,47,94,220,91,42,69,29,68,147, 11,62,233},"Complex128"]
     = 3.22170267142*^134 - 8.98364297498*^198 I
    #> WbR[{15,42,80,125,157,4,38,97, 0,0,0,0,0,0,240,255}, "Complex128"]
      = -I Infinity
    #> WbR[{15,42,80,125,157,4,38,97, 0,0,0,0,0,0,240,127}, "Complex128"]
      = I Infinity
    #> WbR[{15,42,80,125,157,4,38,97, 1,0,0,0,0,0,240,255}, "Complex128"]
     = Indeterminate
    #> WbR[{0,0,0,0,0,0,240,127, 15,42,80,125,157,4,38,97}, "Complex128"]
     = Infinity
    #> WbR[{0,0,0,0,0,0,240,255, 15,42,80,125,157,4,38,97}, "Complex128"]
     = -Infinity
    #> WbR[{1,0,0,0,0,0,240,255, 15,42,80,125,157,4,38,97}, "Complex128"]
     = Indeterminate
    #> WbR[{0,0,0,0,0,0,240,127, 0,0,0,0,0,0,240,127}, "Complex128"]
     = Indeterminate
    #> WbR[{0,0,0,0,0,0,240,127, 0,0,0,0,0,0,240,255}, "Complex128"]
     = Indeterminate

    ## Complex256
    ## TODO

    ## Integer8
    #> WbR[{149, 2, 177, 132}, {"Integer8", "Integer8", "Integer8", "Integer8"}]
     = {-107, 2, -79, -124}
    #> WbR[{127, 128, 0, 255}, {"Integer8", "Integer8", "Integer8", "Integer8"}]
     = {127, -128, 0, -1}

    ## Integer16
    #> WbR[{149, 2, 177, 132, 112, 24}, {"Integer16", "Integer16", "Integer16"}]
     = {661, -31567, 6256}
    #> WbR[{0, 0, 255, 0, 255, 255, 128, 127, 128, 128}, Table["Integer16", {5}]]
     = {0, 255, -1, 32640, -32640}

    ## Integer24
    #> WbR[{152, 173, 160, 188, 207, 154}, {"Integer24", "Integer24"}]
     = {-6247016, -6631492}
    #> WbR[{145, 173, 231, 49, 90, 30}, {"Integer24", "Integer24"}]
     = {-1593967, 1989169}

    ## Integer32
    #> WbR[{209, 99, 23, 218, 143, 187, 236, 241}, {"Integer32", "Integer32"}]
     = {-636001327, -236143729}
    #> WbR[{15, 31, 173, 120, 245, 100, 18, 188}, {"Integer32", "Integer32"}]
     = {2024611599, -1139645195}

    ## Integer64
    #> WbR[{211, 18, 152, 2, 235, 102, 82, 16}, "Integer64"]
     = 1176115612243989203
    #> WbR[{37, 217, 208, 88, 14, 241, 170, 137}, "Integer64"]
     = -8526737900550694619

    ## Integer128
    #> WbR[{140,32,24,199,10,169,248,117,123,184,75,76,34,206,49,105}, "Integer128"]
     = 139827542997232652313568968616424513676
    #> WbR[{101,57,184,108,43,214,186,120,153,51,132,225,56,165,209,77}, "Integer128"]
     = 103439096823027953602112616165136677221
    #> WbR[{113,100,125,144,211,83,140,24,206,11,198,118,222,152,23,219}, "Integer128"]
     = -49058912464625098822365387707690163087

    ## Real32
    #> WbR[{81, 72, 250, 79, 52, 227, 104, 90}, {"Real32", "Real32"}]
     = {8.398086656*^9, 1.63880017687*^16}
    #> WbR[{251, 22, 221, 117, 165, 245, 18, 75}, {"Real32", "Real32"}]
     = {5.6052915284*^32, 9.631141*^6}
    #> WbR[{0, 0, 128, 127}, "Real32"]
     = Infinity
    #> WbR[{0, 0, 128, 255}, "Real32"]
     = -Infinity
    #> WbR[{1, 0, 128, 255}, "Real32"]
     = Indeterminate
    #> WbR[{1, 0, 128, 127}, "Real32"]
     = Indeterminate

    ## Real64
    #> WbR[{45, 243, 20, 87, 129, 185, 53, 239}, "Real64"]
     = -5.14646619426*^227
    #> WbR[{192, 60, 162, 67, 122, 71, 74, 196}, "Real64"]
     = -9.69531698809*^20
    #> WbR[{15, 42, 80, 125, 157, 4, 38, 97}, "Real64"]
     = 9.67355569764*^159
    #> WbR[{0, 0, 0, 0, 0, 0, 240, 127}, "Real64"]
     = Infinity
    #> WbR[{0, 0, 0, 0, 0, 0, 240, 255}, "Real64"]
     = -Infinity
    #> WbR[{1, 0, 0, 0, 0, 0, 240, 127}, "Real64"]
     = Indeterminate
    #> WbR[{1, 0, 0, 0, 0, 0, 240, 255}, "Real64"]
     = Indeterminate

    ## Real128
    ## 0x0000
    #> WbR[{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0}, "Real128"]
     : Results for the format Real128 may not be correct.
     = 0.*^-4965
    #> WbR[{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,128}, "Real128"]
     : Results for the format Real128 may not be correct.
     = 0.*^-4965
    ## 0x0001 - 0x7FFE
    #> WbR[{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,255,63}, "Real128"]
     : Results for the format Real128 may not be correct.
     = 1.
    #> WbR[{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,255,191}, "Real128"]
     : Results for the format Real128 may not be correct.
     = -1.
    #> WbR[{135, 62, 233, 137, 22, 208, 233, 210, 133, 82, 251, 92, 220, 216, 255, 63}, "Real128"]
     : Results for the format Real128 may not be correct.
     = 1.84711247573661489653389674493896
    #> WbR[{135, 62, 233, 137, 22, 208, 233, 210, 133, 82, 251, 92, 220, 216, 207, 72}, "Real128"]
     : Results for the format Real128 may not be correct.
     = 2.45563355727491021879689747166252*^679
    #> WbR[{74, 95, 30, 234, 116, 130, 1, 84, 20, 133, 245, 221, 113, 110, 219, 212}, "Real128"]
     : Results for the format Real128 may not be correct.
     = -4.52840681592341879518366539335138*^1607
    ## 0x7FFF
    #> WbR[{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,255,127}, "Real128"]
     : Results for the format Real128 may not be correct.
     = Infinity
    #> WbR[{0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,255,255}, "Real128"]
     : Results for the format Real128 may not be correct.
     = -Infinity
    #> WbR[{1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,255,127}, "Real128"]
     : Results for the format Real128 may not be correct.
     = Indeterminate
    #> WbR[{1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,255,255}, "Real128"]
     : Results for the format Real128 may not be correct.
     = Indeterminate

    ## TerminatedString
    #> WbR[{97, 98, 99, 0}, "TerminatedString"]
     = abc
    #> WbR[{49, 50, 51, 0, 52, 53, 54, 0, 55, 56, 57}, Table["TerminatedString", {3}]]
     = {123, 456, EndOfFile}
    #> WbR[{0}, "TerminatedString"] // InputForm
     = ""

    ## UnsignedInteger8
    #> WbR[{96, 94, 141, 162, 141}, Table["UnsignedInteger8", {5}]]
     = {96, 94, 141, 162, 141}
    #> (#==WbR[#,Table["UnsignedInteger8",{50}]])&[RandomInteger[{0, 255}, 50]]
     = True

    ## UnsignedInteger16
    #> WbR[{54, 71, 106, 185, 147, 38, 5, 231}, Table["UnsignedInteger16", {4}]]
     = {18230, 47466, 9875, 59141}
    #> WbR[{0, 0, 128, 128, 255, 255}, Table["UnsignedInteger16", {3}]]
     = {0, 32896, 65535}

    ## UnsignedInteger24
    #> WbR[{78, 35, 226, 225, 84, 236}, Table["UnsignedInteger24", {2}]]
     = {14820174, 15488225}
    #> WbR[{165, 2, 82, 239, 88, 59}, Table["UnsignedInteger24", {2}]]
     = {5374629, 3889391}

    ## UnsignedInteger32
    #> WbR[{213,143,98,112,141,183,203,247}, Table["UnsignedInteger32", {2}]]
     = {1885507541, 4157323149}
    #> WbR[{148,135,230,22,136,141,234,99}, Table["UnsignedInteger32", {2}]]
     = {384206740, 1676316040}

    ## UnsignedInteger64
    #> WbR[{95, 5, 33, 229, 29, 62, 63, 98}, "UnsignedInteger64"]
     = 7079445437368829279
    #> WbR[{134, 9, 161, 91, 93, 195, 173, 74}, "UnsignedInteger64"]
     = 5381171935514265990

    ## UnsignedInteger128
    #> WbR[{108,78,217,150,88,126,152,101,231,134,176,140,118,81,183,220}, "UnsignedInteger128"]
     = 293382001665435747348222619884289871468
    #> WbR[{53,83,116,79,81,100,60,126,202,52,241,48,5,113,92,190}, "UnsignedInteger128"]
     = 253033302833692126095975097811212718901

    ## EndOfFile
    #> WbR[{148}, {"Integer32", "Integer32","Integer32"}]
     = {EndOfFile, EndOfFile, EndOfFile}
    """

    readers = _BinaryFormat.get_readers()

    messages = {
        'format': '`1` is not a recognized binary format.',
        'openw': '`1` is open for output.',
        'bfmt': 'The stream `1` has been opened with BinaryFormat -> False and cannot be used with binary data.',
        'warnquad': 'Results for the format `1` may not be correct.',   # FIXME
    }

    def apply_empty(self, name, n, evaluation):
        'BinaryRead[InputStream[name_, n_]]'
        return self.apply(name, n, None, evaluation)

    def apply(self, name, n, typ, evaluation):
        'BinaryRead[InputStream[name_, n_], typ_]'

        channel = Expression('InputStream', name, n)

        # Check channel
        stream = _lookup_stream(n.get_int_value())

        if stream is None or stream.closed:
            evaluation.message('General', 'openx', name)
            return

        if stream.mode not in ['rb']:
            evaluation.message('BinaryRead', 'bfmt', channel)
            return

        # Check typ
        if typ is None:
            expr = Expression('BinaryRead', channel)
            typ = String('Byte')
        else:
            expr = Expression('BinaryRead', channel, typ)

        if typ.has_form('List', None):
            types = typ.get_leaves()
        else:
            types = [typ]

        types = [t.get_string_value() for t in types]
        if not all(t in self.readers for t in types):
            evaluation.message('BinaryRead', 'format', typ)
            return

        # Read from stream
        result = []
        for t in types:
            if t in ('Real128', 'Complex256'):
                evaluation.message('BinaryRead', 'warnquad', t)
            try:
                result.append(self.readers[t](stream))
            except struct.error:
                result.append(Symbol('EndOfFile'))

        if typ.has_form('List', None):
            return Expression('List', *result)
        else:
            if len(result) == 1:
                return result[0]


class WriteString(Builtin):
    """
    <dl>
    <dt>'WriteString[$stream$, $str1, $str2$, ... ]'
      <dd>writes the strings to the output stream.
    </dl>

    >> str = OpenWrite[];
    >> WriteString[str, "This is a test 1"]
    >> WriteString[str, "This is also a test 2"]
    >> Close[str]
     = ...
    >> FilePrint[%]
     | This is a test 1This is also a test 2

    >> str = OpenWrite[];
    >> WriteString[str, "This is a test 1", "This is also a test 2"]
    >> Close[str]
     = ...
    >> FilePrint[%]
     | This is a test 1This is also a test 2

    #> str = OpenWrite[];
    #> WriteString[str, 100, 1 + x + y, Sin[x  + y]]
    #> Close[str]
     = ...
    #> FilePrint[%]
     | 1001 + x + ySin[x + y]

    #> str = OpenWrite[];
    #> WriteString[str]
    #> Close[str]
     = ...
    #> FilePrint[%]

    #> WriteString[%%, abc]
    #> Streams[%%%][[1]]
     = ...
    #> Close[%]
     = ...
    #> FilePrint[%]
     | abc

    #> WriteString[OpenWrite["/dev/zero"], "abc"]   (* Null *)
    """

    messages = {
        'strml': ('`1` is not a string, stream, '
                  'or list of strings and streams.'),
    }

    attributes = ('Protected')

    def apply(self, channel, expr, evaluation):
        'WriteString[channel_, expr___]'
        strm = _channel_to_stream(channel, 'w')

        if strm is None:
            return

        stream = _lookup_stream(strm.leaves[1].get_int_value())

        if stream is None or stream.closed:
            return None

        exprs = []
        for expri in expr.get_sequence():
            result = expri.format(evaluation, "OutputForm")
            try:
                result = result.boxes_to_text(evaluation=evaluation)
            except BoxError:
                return evaluation.message(
                    'General', 'notboxes', String('%s' % result))
            exprs.append(result)

        stream.write(u''.join(exprs))
        stream.flush()
        return Symbol('Null')


class _OpenAction(Builtin):

    attributes = ('Protected')

    # BinaryFormat: 'False',
    # CharacterEncoding :> Automatic, 
    # DOSTextFormat :> True,
    # FormatType -> InputForm, 
    # NumberMarks :> $NumberMarks,
    # PageHeight -> 22, PageWidth -> 78, 
    # TotalHeight -> Infinity,
    # TotalWidth -> Infinity

    options = {
        'BinaryFormat': 'False',
    }

    messages = {
        'argx': 'OpenRead called with 0 arguments; 1 argument is expected.',
        'fstr': ('File specification `1` is not a string of '
                 'one or more characters.'),
    }

    def apply_empty(self, evaluation, options):
        '%(name)s[OptionsPattern[]]'

        if isinstance(self, (OpenWrite, OpenAppend)):
            tmpf = tempfile.NamedTemporaryFile(dir=TMP_DIR)
            path = String(tmpf.name)
            tmpf.close()
            return self.apply_path(path, evaluation, options)
        else:
            evaluation.message('OpenRead', 'argx')
            return

    def apply_path(self, path, evaluation, options):
        '%(name)s[path_?NotOptionQ, OptionsPattern[]]'

        ## Options
        # BinaryFormat
        mode = self.mode
        if options['BinaryFormat'].is_true():
            if not self.mode.endswith('b'):
                mode += 'b'

        if not (isinstance(path, String) and len(path.to_python()) > 2):
            evaluation.message(self.__class__.__name__, 'fstr', path)
            return

        path_string = path.get_string_value()

        tmp = path_search(path_string)
        if tmp is None:
            if mode in ['r', 'rb']:
                evaluation.message('General', 'noopen', path)
                return
        else:
            path_string = tmp

        try:
            opener = mathics_open(path_string, mode=mode)
            stream = opener.__enter__()
            n = opener.n
        except IOError:
            evaluation.message('General', 'noopen', path)
            return

        return Expression(self.stream_type, path, Integer(n))


class OpenRead(_OpenAction):
    """
    <dl>
    <dt>'OpenRead["file"]'
      <dd>opens a file and returns an InputStream.
    </dl>

    >> OpenRead["ExampleData/EinsteinSzilLetter.txt"]
     = InputStream[...]
    #> Close[%];

    #> OpenRead[]
     : OpenRead called with 0 arguments; 1 argument is expected.
     = OpenRead[]

    #> OpenRead[y]
     : File specification y is not a string of one or more characters.
     = OpenRead[y]

    #> OpenRead[""]
     : File specification  is not a string of one or more characters.
     = OpenRead[]

    #> OpenRead["MathicsNonExampleFile"]
     : Cannot open MathicsNonExampleFile.
     = OpenRead[MathicsNonExampleFile]

    #> OpenRead["ExampleData/EinsteinSzilLetter.txt", BinaryFormat -> True]
     = InputStream[...]
    #> Close[%];
    """

    mode = 'r'
    stream_type = 'InputStream'


class OpenWrite(_OpenAction):
    """
    <dl>
    <dt>'OpenWrite["file"]'
      <dd>opens a file and returns an OutputStream.
    </dl>

    >> OpenWrite[]
     = OutputStream[...]
    #> Close[%];

    #> OpenWrite[BinaryFormat -> True]
     = OutputStream[...]
    #> Close[%];
    """

    mode = 'w'
    stream_type = 'OutputStream'


class OpenAppend(_OpenAction):
    """
    <dl>
    <dt>'OpenAppend["file"]'
      <dd>opens a file and returns an OutputStream to which writes are appended.
    </dl>

    >> OpenAppend[]
     = OutputStream[...]
    #> Close[%];

    #> OpenAppend["MathicsNonExampleFile"]
     = OutputStream[MathicsNonExampleFile, ...]

    #> DeleteFile["MathicsNonExampleFile"]
    """

    mode = 'a'
    stream_type = 'OutputStream'


class Get(PrefixOperator):
    r"""
    <dl>
    <dt>'<<name'
      <dd>reads a file and evaluates each expression, returning only the last one.
    </dl>

    >> Put[x + y, "example_file"]
    >> <<"example_file"
     = x + y

    >> Put[x + y, 2x^2 + 4z!, Cos[x] + I Sin[x], "example_file"]
    >> <<"example_file"
     = Cos[x] + I Sin[x]
    #> DeleteFile["example_file"]

    >> 40! >> "fourtyfactorial"
    >> FilePrint["fourtyfactorial"]
     | 815915283247897734345611269596115894272000000000
    >> <<"fourtyfactorial"
     = 815915283247897734345611269596115894272000000000
    #> DeleteFile["fourtyfactorial"]

    ## TODO: Requires EndPackage implemented
    ## 'Get' can also load packages:
    ## >> << "VectorAnalysis`"

    #> Get["SomeTypoPackage`"]
     : Cannot open SomeTypoPackage`.
     = $Failed

    ## Parser Tests
    #> Hold[<< ~/some_example/dir/] // FullForm
     = Hold[Get["~/some_example/dir/"]]
    #> Hold[<<`/.\-_:$*~?] // FullForm
     = Hold[Get["`/.\\-_:$*~?"]]
    """

    operator = '<<'
    precedence = 720
    attributes = ('Protected')

    def apply(self, path, evaluation):
        'Get[path_String]'
        pypath = path.get_string_value()
        try:
            with mathics_open(pypath, 'r') as f:
                result = f.readlines()
        except IOError:
            evaluation.message('General', 'noopen', path)
            return Symbol('$Failed')

        try:
            parse
            ParseError
        except NameError:
            from mathics.core.parser import parse

        from mathics.main import wait_for_line

        total_input = ""
        syntax_error_count = 0
        expr = Symbol('Null')

        for lineno, tmp in enumerate(result):
            total_input += ' ' + tmp
            if wait_for_line(total_input):
                continue
            try:
                expr = parse(total_input)
            except:  # FIXME: something weird is going on here
                syntax_error_count += 1
                if syntax_error_count <= 4:
                    print "Syntax Error (line {0} of {1})".format(
                        lineno + 1, pypath)
                if syntax_error_count == 4:
                    print "Supressing further syntax errors in {0}".format(
                        pypath)
            else:
                if expr is not None:
                    expr = expr.evaluate(evaluation)
                total_input = ""

        if total_input != "":
            # TODO:
            # evaluation.message('Syntax', 'sntue', 'line {0} of
            # {1}'.format(lineno, pypath))
            print 'Unexpected end of file (probably unfinished expression)'
            print '    (line {0} of "{1}").'.format(lineno, pypath)
            return Symbol('Null')

        return expr

    def apply_default(self, filename, evaluation):
        'Get[filename_]'
        expr = Expression('Get', filename)
        evaluation.message('General', 'stream', filename)
        return expr


class Put(BinaryOperator):
    """
    <dl>
    <dt>'$expr$ >> $filename$'
      <dd>write $expr$ to a file.
    <dt>'Put[$expr1$, $expr2$, ..., $"filename"$]'
      <dd>write a sequence of expressions to a file.
    </dl>

    >> 40! >> "fourtyfactorial"
    >> FilePrint["fourtyfactorial"]
     | 815915283247897734345611269596115894272000000000
    #> 40! >> fourtyfactorial
    #> FilePrint["fourtyfactorial"]
     | 815915283247897734345611269596115894272000000000

    #> Put[40!, fourtyfactorial]
     : fourtyfactorial is not string, InputStream[], or OutputStream[]
     = 815915283247897734345611269596115894272000000000 >> fourtyfactorial
    ## FIXME: final line should be
    ## = Put[815915283247897734345611269596115894272000000000, fourtyfactorial]
    #> DeleteFile["fourtyfactorial"]

    >> Put[50!, "fiftyfactorial"]
    >> FilePrint["fiftyfactorial"]
     | 30414093201713378043612608166064768844377641568960512000000000000
    #> DeleteFile["fiftyfactorial"]

    >> Put[10!, 20!, 30!, "factorials"]
    >> FilePrint["factorials"]
     | 3628800
     | 2432902008176640000
     | 265252859812191058636308480000000

    #> DeleteFile["factorials"]
     =

    #> Put[x + y, 2x^2 + 4z!, Cos[x] + I Sin[x], "example_file"]
    #> FilePrint["example_file"]
     | x + y
     | 2*x^2 + 4*z!
     | Cos[x] + I*Sin[x]
    #> DeleteFile["example_file"]
    """

    operator = '>>'
    precedence = 30

    def apply(self, exprs, filename, evaluation):
        'Put[exprs___, filename_String]'
        instream = Expression('OpenWrite', filename).evaluate(evaluation)
        name, n = instream.leaves
        result = self.apply_input(exprs, name, n, evaluation)
        Expression('Close', instream).evaluate(evaluation)
        return result

    def apply_input(self, exprs, name, n, evaluation):
        'Put[exprs___, OutputStream[name_, n_]]'
        stream = _lookup_stream(n.get_int_value())

        if stream is None or stream.closed:
            evaluation.message('Put', 'openx', Expression(
                'OutputSteam', name, n))
            return

        text = [evaluation.format_output(Expression(
            'InputForm', expr)) for expr in exprs.get_sequence()]
        text = u'\n'.join(text) + u'\n'
        text.encode('ascii')

        stream.write(text)

        return Symbol('Null')

    def apply_default(self, exprs, filename, evaluation):
        'Put[exprs___, filename_]'
        expr = Expression('Put', exprs, filename)
        evaluation.message('General', 'stream', filename)
        return expr

    def parse(self, args):
        if isinstance(args[2], Symbol):
            ptokens = args[2].parse_tokens
            args[2] = String(args[2])
            args[2].parse_tokens = ptokens

        return super(Put, self).parse(args)


class PutAppend(BinaryOperator):
    """
    <dl>
    <dt>'$expr$ >>> $filename$'
      <dd>append $expr$ to a file.
    <dt>'PutAppend[$expr1$, $expr2$, ..., $"filename"$]'
      <dd>write a sequence of expressions to a file.
    </dl>

    >> Put[50!, "factorials"]
    >> FilePrint["factorials"]
     | 30414093201713378043612608166064768844377641568960512000000000000

    >> PutAppend[10!, 20!, 30!, "factorials"]
    >> FilePrint["factorials"]
     | 30414093201713378043612608166064768844377641568960512000000000000
     | 3628800
     | 2432902008176640000
     | 265252859812191058636308480000000

    >> 60! >>> "factorials"
    >> FilePrint["factorials"]
     | 30414093201713378043612608166064768844377641568960512000000000000
     | 3628800
     | 2432902008176640000
     | 265252859812191058636308480000000
     | 8320987112741390144276341183223364380754172606361245952449277696409600000000000000

    >> "string" >>> factorials
    >> FilePrint["factorials"]
     | 30414093201713378043612608166064768844377641568960512000000000000
     | 3628800
     | 2432902008176640000
     | 265252859812191058636308480000000
     | 8320987112741390144276341183223364380754172606361245952449277696409600000000000000
     | "string"
    #> DeleteFile["factorials"];
    """

    operator = '>>>'
    precedence = 30
    attributes = ('Protected')

    def apply(self, exprs, filename, evaluation):
        'PutAppend[exprs___, filename_String]'
        instream = Expression('OpenAppend', filename).evaluate(evaluation)
        name, n = instream.leaves
        result = self.apply_input(exprs, name, n, evaluation)
        Expression('Close', instream).evaluate(evaluation)
        return result

    def apply_input(self, exprs, name, n, evaluation):
        'PutAppend[exprs___, OutputStream[name_, n_]]'
        stream = _lookup_stream(n.get_int_value())

        if stream is None or stream.closed:
            evaluation.message('Put', 'openx', Expression(
                'OutputSteam', name, n))
            return

        text = [unicode(e.do_format(
            evaluation, 'OutputForm').__str__()) for e in exprs.get_sequence()]
        text = u'\n'.join(text) + u'\n'
        text.encode('ascii')

        stream.write(text)

        return Symbol('Null')

    def apply_default(self, exprs, filename, evaluation):
        'PutAppend[exprs___, filename_]'
        expr = Expression('PutAppend', exprs, filename)
        evaluation.message('General', 'stream', filename)
        return expr

    def parse(self, args):
        if isinstance(args[2], Symbol):
            ptokens = args[2].parse_tokens
            args[2] = String(args[2])
            args[2].parse_tokens = ptokens

        return super(PutAppend, self).parse(args)


class FindFile(Builtin):
    """
    <dl>
    <dt>'FindFile[$name$]'
      <dd>searches '$Path' for the given filename.
    </dl>

    >> FindFile["ExampleData/sunflowers.jpg"]
     = ...

    >> FindFile["VectorAnalysis`"]
     = ...

    >> FindFile["VectorAnalysis`VectorAnalysis`"]
     = ...

    #> FindFile["SomeTypoPackage`"]
     = $Failed
    """

    attributes = ('Protected')

    messages = {
        'string': 'String expected at position 1 in `1`.',
    }

    def apply(self, name, evaluation):
        'FindFile[name_]'

        py_name = name.to_python()

        if not (isinstance(py_name, basestring) and
                py_name[0] == py_name[-1] == '"'):
            evaluation.message(
                'FindFile', 'string', Expression('FindFile', name))
            return
        py_name = py_name[1:-1]

        result = path_search(py_name)

        if result is None:
            return Symbol('$Failed')

        return String(os.path.abspath(result))


class FileNameSplit(Builtin):
    """
    <dl>
    <dt>'FileNameSplit["$filenams$"]'
      <dd>splits a $filename$ into a list of parts.
    </dl>

    >> FileNameSplit["example/path/file.txt"]
     = {example, path, file.txt}

    #> FileNameSplit["example/path", OperatingSystem -> x]
     : The value of option OperatingSystem -> x must be one of "MacOSX", "Windows", or "Unix".
     = {example, path}
    """

    attributes = ('Protected')

    options = {
        'OperatingSystem': '$OperatingSystem',
    }

    messages = {
        'ostype': ('The value of option OperatingSystem -> `1` '
                   'must be one of "MacOSX", "Windows", or "Unix".'),
    }

    def apply(self, filename, evaluation, options):
        'FileNameSplit[filename_String, OptionsPattern[FileNameSplit]]'

        path = filename.to_python()[1:-1]

        operating_system = options[
            'OperatingSystem'].evaluate(evaluation).to_python()

        if operating_system not in ['"MacOSX"', '"Windows"', '"Unix"']:
            evaluation.message('FileNameSplit', 'ostype', options[
                               'OperatingSystem'])
            if os.name == 'posix':
                operating_system = 'Unix'
            elif os.name == 'nt':
                operating_system = 'Windows'
            elif os.name == 'os2':
                operating_system = 'MacOSX'
            else:
                return

        # TODO Implement OperatingSystem Option

        result = []
        while path not in ['', SYS_ROOT_DIR]:
            path, ext = os.path.split(path)
            if ext != '':
                result.insert(0, ext)

        return from_python(result)


class FileNameJoin(Builtin):
    """
    <dl>
    <dt>'FileNameJoin[{"$dir_1$", "$dir_2$", ...}]'
      <dd>joins the $dir_i$ togeather into one path.
    </dl>

    >> FileNameJoin[{"dir1", "dir2", "dir3"}]
     = ...

    >> FileNameJoin[{"dir1", "dir2", "dir3"}, OperatingSystem -> "Unix"]
     = dir1/dir2/dir3

    ## TODO
    ## #> FileNameJoin[{"dir1", "dir2", "dir3"}, OperatingSystem -> "Windows"]
    ##  = dir1\dir2\dir3
    """

    attributes = ('Protected')

    options = {
        'OperatingSystem': '$OperatingSystem',
    }

    messages = {
        'ostype': ('The value of option OperatingSystem -> `1` '
                   'must be one of "MacOSX", "Windows", or "Unix".'),
    }

    def apply(self, pathlist, evaluation, options):
        'FileNameJoin[pathlist_?ListQ, OptionsPattern[FileNameJoin]]'

        py_pathlist = pathlist.to_python()
        if not all(isinstance(p, basestring) and p[0] == p[-1] == '"'
                   for p in py_pathlist):
            return
        py_pathlist = [p[1:-1] for p in py_pathlist]

        operating_system = options[
            'OperatingSystem'].evaluate(evaluation).to_python()

        if operating_system not in ['"MacOSX"', '"Windows"', '"Unix"']:
            evaluation.message('FileNameSplit', 'ostype', options[
                               'OperatingSystem'])
            if os.name == 'posix':
                operating_system = 'Unix'
            elif os.name == 'nt':
                operating_system = 'Windows'
            elif os.name == 'os2':
                operating_system = 'MacOSX'
            else:
                return

        # TODO Implement OperatingSystem Option

        result = os.path.join(*py_pathlist)

        return from_python(result)


class FileExtension(Builtin):
    """
    <dl>
    <dt>'FileExtension["$file$"]'
      <dd>gives the extension for the specified file name.
    </dl>

    >> FileExtension["file.txt"]
     = txt

    >> FileExtension["file.tar.gz"]
     = gz

    #> FileExtension["file."]
     = 
    #> FileExtension["file"]
     = 
    """

    attributes = ('Protected')

    options = {
        'OperatingSystem': '$OperatingSystem',
    }

    def apply(self, filename, evaluation, options):
        'FileExtension[filename_String, OptionsPattern[FileExtension]]'
        path = filename.to_python()[1:-1]
        filename_base, filename_ext = os.path.splitext(path)
        filename_ext = filename_ext.lstrip('.')
        return from_python(filename_ext)


class FileBaseName(Builtin):
    """
    <dl>
    <dt>'FileBaseName["$file$"]'
      <dd>gives the base name for the specified file name.
    </dl>

    >> FileBaseName["file.txt"]
     = file

    >> FileBaseName["file.tar.gz"]
     = file.tar

    #> FileBaseName["file."]
     = file

    #> FileBaseName["file"]
     = file
    """

    attributes = ('Protected')

    options = {
        'OperatingSystem': '$OperatingSystem',
    }

    def apply(self, filename, evaluation, options):
        'FileBaseName[filename_String, OptionsPattern[FileBaseName]]'
        path = filename.to_python()[1:-1]

        filename_base, filename_ext = os.path.splitext(path)
        return from_python(filename_base)


class DirectoryName(Builtin):
    """
    <dl>
    <dt>'DirectoryName["$name$"]'
      <dd>extracts the directory name from a filename.
    </dl>

    >> DirectoryName["a/b/c"]
     = a/b

    >> DirectoryName["a/b/c", 2]
     = a

    #> DirectoryName["a/b/c", 3] // InputForm
     = ""
    #> DirectoryName[""] // InputForm
     = ""

    #> DirectoryName["a/b/c", x]
     : Positive machine-sized integer expected at position 2 in DirectoryName[a/b/c, x].
     = DirectoryName[a/b/c, x]

    #> DirectoryName["a/b/c", -1]
     : Positive machine-sized integer expected at position 2 in DirectoryName[a/b/c, -1].
     = DirectoryName[a/b/c, -1]

    #> DirectoryName[x]
     : String expected at position 1 in DirectoryName[x].
     = DirectoryName[x]
    """

    attributes = ('Protected')

    options = {
        'OperatingSystem': '$OperatingSystem',
    }

    messages = {
        'string': 'String expected at position 1 in `1`.',
        'intpm': ('Positive machine-sized integer expected at '
                  'position 2 in `1`.'),
    }

    def apply(self, name, n, evaluation, options):
        'DirectoryName[name_, n_, OptionsPattern[DirectoryName]]'

        if n is None:
            expr = Expression('DirectoryName', name)
            py_n = 1
        else:
            expr = Expression('DirectoryName', name, n)
            py_n = n.to_python()

        if not (isinstance(py_n, (int, long)) and py_n > 0):
            evaluation.message('DirectoryName', 'intpm', expr)
            return

        py_name = name.to_python()
        if not (isinstance(py_name, basestring) and
                py_name[0] == py_name[-1] == '"'):
            evaluation.message('DirectoryName', 'string', expr)
            return
        py_name = py_name[1:-1]

        result = py_name
        for i in range(py_n):
            (result, tmp) = os.path.split(result)

        return String(result)

    def apply1(self, name, evaluation, options):
        'DirectoryName[name_, OptionsPattern[DirectoryName]]'
        return self.apply(name, None, evaluation, options)


class FileNameDepth(Builtin):
    """
    <dl>
    <dt>'FileNameDepth["$name$"]'
      <dd>gives the number of path parts in the given filename.
    </dl>

    >> FileNameDepth["a/b/c"]
     = 3

    >> FileNameDepth["a/b/c/"]
     = 3

    #> FileNameDepth[x]
     = FileNameDepth[x]

    #> FileNameDepth[$RootDirectory]
     = 0
    """

    attributes = ('Protected')

    options = {
        'OperatingSystem': '$OperatingSystem',
    }

    rules = {
        'FileNameDepth[name_String]': 'Length[FileNameSplit[name]]',
    }


class AbsoluteFileName(Builtin):
    """
    <dl>
    <dt>'AbsoluteFileName["$name$"]'
      <dd>returns the absolute version of the given filename.
    </dl>

    >> AbsoluteFileName["ExampleData/sunflowers.jpg"]
     = ...

    #> AbsoluteFileName["Some/NonExistant/Path.ext"]
     : File not found during AbsoluteFileName[Some/NonExistant/Path.ext].
     = $Failed
    """

    attributes = ('Protected')

    messages = {
        'fstr': (
            'File specification x is not a string of one or more characters.'),
        'nffil': 'File not found during `1`.',
    }

    def apply(self, name, evaluation):
        'AbsoluteFileName[name_]'

        py_name = name.to_python()

        if not (isinstance(py_name, basestring) and
                py_name[0] == py_name[-1] == '"'):
            evaluation.message('AbsoluteFileName', 'fstr', name)
            return
        py_name = py_name[1:-1]

        result = path_search(py_name)

        if result is None:
            evaluation.message('AbsoluteFileName', 'nffil',
                               Expression('AbsoluteFileName', name))
            return Symbol('$Failed')

        return String(os.path.abspath(result))


class ExpandFileName(Builtin):
    """
    <dl>
    <dt>'ExpandFileName["$name$"]'
      <dd>expands $name$ to an absolute filename for your system.
    </dl>

    >> ExpandFileName["ExampleData/sunflowers.jpg"]
     = ...
    """

    attributes = ('Protected')

    messages = {
        'string': 'String expected at position 1 in `1`.',
    }

    def apply(self, name, evaluation):
        'ExpandFileName[name_]'

        py_name = name.to_python()

        if not (isinstance(py_name, basestring) and
                py_name[0] == py_name[-1] == '"'):
            evaluation.message('ExpandFileName', 'string',
                               Expression('ExpandFileName', name))
            return
        py_name = py_name[1:-1]

        return String(os.path.abspath(py_name))


class ReadList(Read):
    """
    <dl>
    <dt>'ReadList["$file$"]'
      <dd>Reads all the expressions until the end of file.
    <dt>'ReadList["$file$", $type$]'
      <dd>Reads objects of a specified type until the end of file.
    <dt>'ReadList["$file$", {$type1$, $type2$, ...}]'
      <dd>Reads a sequence of specified types until the end of file.
    </dl>

    >> ReadList[StringToStream["a 1 b 2"], {Word, Number}]
     = {{a, 1}, {b, 2}}

    >> str = StringToStream["abc123"];
    >> ReadList[str]
     = {abc123}
    >> InputForm[%]
     = {"abc123"}

    #> ReadList[str, "Invalid"]
     : "Invalid" is not a valid format specification.
     = ReadList[..., Invalid]
    #> Close[str];


    #> ReadList[StringToStream["a 1 b 2"], {Word, Number}, 1]
     = {{a, 1}}
    """

    # TODO
    """
    #> ReadList[StringToStream["a 1 b 2"], {Word, Number}, -1]
     : Non-negative machine-sized integer expected at position 3 in ReadList[InputStream[String, ...], {Word, Number}, -1].
     = ReadList[InputStream[String, ...], {Word, Number}, -1]
    """

    # TODO: Expression type
    """
    #> ReadList[StringToStream["123 45 x y"], Expression]
     = {5535 x y}
    """

    # TODO: Accept newlines in input
    """
    >> ReadList[StringToStream["123\nabc"]]
     = {123, abc}
    >> InputForm[%]
     = {123, abc}
    """

    rules = {
        'ReadList[stream_]': 'ReadList[stream, Expression]',
    }

    attributes = ('Protected')

    options = {
        'NullRecords': 'False',
        'NullWords': 'False',
        'RecordSeparators': '{"\r\n", "\n", "\r"}',
        'TokenWords': '{}',
        'WordSeparators': '{" ", "\t"}',
    }

    def apply(self, channel, types, evaluation, options):
        'ReadList[channel_, types_, OptionsPattern[ReadList]]'

        # Options
        # TODO: Implement extra options
        # py_options = self.check_options(options)
        # null_records = py_options['NullRecords']
        # null_words = py_options['NullWords']
        # record_separators = py_options['RecordSeparators']
        # token_words = py_options['TokenWords']
        # word_separators = py_options['WordSeparators']

        result = []
        while True:
            tmp = super(ReadList, self).apply(
                channel, types, evaluation, options)

            if tmp == Symbol('$Failed'):
                return

            if tmp.to_python() == 'EndOfFile':
                break
            result.append(tmp)
        return from_python(result)

    def apply_m(self, channel, types, m, evaluation, options):
        'ReadList[channel_, types_, m_, OptionsPattern[ReadList]]'

        # Options
        # TODO: Implement extra options
        # py_options = self.check_options(options)
        # null_records = py_options['NullRecords']
        # null_words = py_options['NullWords']
        # record_separators = py_options['RecordSeparators']
        # token_words = py_options['TokenWords']
        # word_separators = py_options['WordSeparators']

        py_m = m.get_int_value()
        if py_m < 0:
            evaluation.message(
                'ReadList', 'intnm', Expression('ReadList', channel, types, m))
            return

        result = []
        for i in range(py_m):
            tmp = super(ReadList, self).apply(
                channel, types, evaluation, options)

            if tmp == Symbol('$Failed'):
                return

            if tmp.to_python() == 'EndOfFile':
                break
            result.append(tmp)
        return from_python(result)


class FilePrint(Builtin):
    """
    <dl>
    <dt>'FilePrint[$file$]'
      <dd>prints the raw contents of $file$.
    </dl>

    #> exp = Sin[1];
    #> FilePrint[exp]
     : File specification Sin[1] is not a string of one or more characters.
     = FilePrint[Sin[1]]

    ## Return $Failed on special files
    #> FilePrint["/dev/zero"]
     = $Failed
    #> FilePrint["/dev/random"]
     = $Failed
    #> FilePrint["/dev/null"]
     = $Failed

    #> FilePrint["somenonexistantpath_h47sdmk^&h4"]
     : Cannot open somenonexistantpath_h47sdmk^&h4.
     = FilePrint[somenonexistantpath_h47sdmk^&h4]

    #> FilePrint[""]
     : File specification  is not a string of one or more characters.
     = FilePrint[]
    """

    messages = {
        'fstr': ('File specification `1` is not a string of '
                 'one or more characters.'),
    }

    options = {
        'CharacterEncoding': '$CharacterEncoding',
        'RecordSeparators': '{"\r\n", "\n", "\r"}',
        'WordSeparators': '{" ", "\t"}',
    }

    attributes = ('Protected')

    def apply(self, path, evaluation, options):
        'FilePrint[path_ OptionsPattern[FilePrint]]'
        pypath = path.to_python()
        if not (isinstance(pypath, basestring) and
                pypath[0] == pypath[-1] == '"' and len(pypath) > 2):
            evaluation.message('FilePrint', 'fstr', path)
            return
        pypath = path_search(pypath[1:-1])

        # Options
        record_separators = options['RecordSeparators'].to_python()
        assert isinstance(record_separators, list)
        assert all(isinstance(s, basestring) and s[
                   0] == s[-1] == '"' for s in record_separators)
        record_separators = [s[1:-1] for s in record_separators]

        if pypath is None:
            evaluation.message('General', 'noopen', path)
            return

        if not os.path.isfile(pypath):
            return Symbol("$Failed")

        try:
            with mathics_open(pypath, 'r') as f:
                result = f.read()
        except IOError:
            evaluation.message('General', 'noopen', path)
            return

        result = [result]
        for sep in record_separators:
            result = [item for res in result for item in res.split(sep)]

        if result[-1] == '':
            result = result[:-1]

        for res in result:
            evaluation.print_out(from_python(res))

        return Symbol('Null')


class Close(Builtin):
    """
    <dl>
    <dt>'Close[$stream$]'
      <dd>closes an input or output stream.
    </dl>

    >> Close[StringToStream["123abc"]]
     = String

    >> Close[OpenWrite[]]
     = ...

    #> Streams[] == (Close[OpenWrite[]]; Streams[])
     = True

    #> Close["abc"]
     : abc is not open.
     = Close[abc]

    #> strm = OpenWrite[];
    #> Close[strm];
    #> Quiet[Close[strm]]
     = Close[OutputStream[...]]
    """

    attributes = ('Protected')

    def apply(self, channel, evaluation):
        'Close[channel_]'

        if (channel.has_form('InputStream', 2) or       # noqa
            channel.has_form('OutputStream', 2)):
            [name, n] = channel.get_leaves()
            stream = _lookup_stream(n.get_int_value())
        else:
            stream = None

        if stream is None or stream.closed:
            evaluation.message('General', 'openx', channel)
            return

        stream.close()
        return name


class StreamPosition(Builtin):
    """
    <dl>
    <dt>'StreamPosition[$stream$]'
      <dd>returns the current position in a stream as an integer.
    </dl>

    >> str = StringToStream["Mathics is cool!"]
     = ...

    >> Read[str, Word]
     = Mathics

    >> StreamPosition[str]
     = 7
    """

    attributes = ('Protected')

    def apply_input(self, name, n, evaluation):
        'StreamPosition[InputStream[name_, n_]]'
        stream = _lookup_stream(n.get_int_value())

        if stream is None or stream.closed:
            evaluation.message('General', 'openx', name)
            return

        return from_python(stream.tell())

    def apply_output(self, name, n, evaluation):
        'StreamPosition[OutputStream[name_, n_]]'
        stream = _lookup_stream(n.get_int_value())

        if stream is None or stream.closed:
            evaluation.message('General', 'openx', name)
            return

        return from_python(stream.tell())

    def apply_default(self, stream, evaluation):
        'StreamPosition[stream_]'
        evaluation.message('General', 'stream', stream)
        return


class SetStreamPosition(Builtin):
    """
    <dl>
    <dt>'SetStreamPosition[$stream$, $n$]'
      <dd>sets the current position in a stream.
    </dl>

    >> str = StringToStream["Mathics is cool!"]
     = ...

    >> SetStreamPosition[str, 8]
     = 8

    >> Read[str, Word]
     = is

    #> SetStreamPosition[str, -5]
     : Python2 cannot handle negative seeks.
     = 10

    >> SetStreamPosition[str, Infinity]
     = 16
    """

    # TODO: Seeks beyond stream should return stmrng message
    """
    #> SetStreamPosition[str, 40]
     = ERROR_MESSAGE_HERE
    """

    messages = {
        'int': 'Integer expected at position 2 in `1`.',
        'stmrng': (
            'Cannot set the current point in stream `1` to position `2`. The '
            'requested position exceeds the number of characters in the file'),
        'python2': 'Python2 cannot handle negative seeks.',  # FIXME: Python3?
    }

    attributes = ('Protected')

    def apply_input(self, name, n, m, evaluation):
        'SetStreamPosition[InputStream[name_, n_], m_]'
        stream = _lookup_stream(n.get_int_value())

        if stream is None or stream.closed:
            evaluation.message('General', 'openx', name)
            return

        if not stream.seekable:
            raise NotImplementedError

        seekpos = m.to_python()
        if not (isinstance(seekpos, int) or seekpos == float('inf')):
            evaluation.message('SetStreamPosition', 'stmrng',
                               Expression('InputStream', name, n), m)
            return

        try:
            if seekpos == float('inf'):
                stream.seek(0, 2)
            else:
                if seekpos < 0:
                    stream.seek(seekpos, 2)
                else:
                    stream.seek(seekpos)
        except IOError:
            evaluation.message('SetStreamPosition', 'python2')

        return from_python(stream.tell())

    def apply_output(self, name, n, m, evaluation):
        'SetStreamPosition[OutputStream[name_, n_], m_]'
        return self.apply_input(name, n, m, evaluation)

    def apply_default(self, stream, evaluation):
        'SetStreamPosition[stream_]'
        evaluation.message('General', 'stream', stream)
        return


class Skip(Read):
    """
    <dl>
    <dt>'Skip[$stream$, $type$]'
      <dd>skips ahead in an input steream by one object of the specified $type$.
    <dt>'Skip[$stream$, $type$, $n$]'
      <dd>skips ahead in an input steream by $n$ objects of the specified $type$.
    </dl>

    >> str = StringToStream["a b c d"];
    >> Read[str, Word]
     = a
    >> Skip[str, Word]
    >> Read[str, Word]
     = c
    #> Close[str];

    >> str = StringToStream["a b c d"];
    >> Read[str, Word]
     = a
    >> Skip[str, Word, 2]
    >> Read[str, Word]
     = d
    #> Skip[str, Word]
     = EndOfFile
    #> Close[str];
    """

    rules = {
        'Skip[InputStream[name_, n_], types_]':
        'Skip[InputStream[name, n], types, 1]',
    }

    messages = {
        'intm':
        'Non-negative machine-sized integer expected at position 3 in `1`',
    }

    options = {
        'AnchoredSearch': 'False',
        'IgnoreCase': 'False',
        'WordSearch': 'False',
        'RecordSeparators': '{"\r\n", "\n", "\r"}',
        'WordSeparators': '{" ", "\t"}',
    }

    attributes = ('Protected')

    def apply(self, name, n, types, m, evaluation, options):
        'Skip[InputStream[name_, n_], types_, m_, OptionsPattern[Skip]]'

        channel = Expression('InputStream', name, n)

        # Options
        # TODO Implement extra options
        # py_options = self.check_options(options)
        # null_records = py_options['NullRecords']
        # null_words = py_options['NullWords']
        # record_separators = py_options['RecordSeparators']
        # token_words = py_options['TokenWords']
        # word_separators = py_options['WordSeparators']

        py_m = m.to_python()
        if not (isinstance(py_m, int) and py_m > 0):
            evaluation.message('Skip', 'intm', Expression(
                'Skip', Expression('InputStream', name, n), types, m))
            return
        for i in range(py_m):
            result = super(Skip, self).apply(
                channel, types, evaluation, options)
            if result.to_python() == 'EndOfFile':
                return Symbol('EndOfFile')
        return Symbol('Null')


class Find(Read):
    """
    <dl>
    <dt>'Find[$stream$, $text$]'
      <dd>find the first line in $stream$ that contains $text$.
    </dl>

    >> str = OpenRead["ExampleData/EinsteinSzilLetter.txt"];
    >> Find[str, "uranium"]
     = in manuscript, leads me to expect that the element uranium may be turned into
    >> Find[str, "uranium"]
     = become possible to set up a nuclear chain reaction in a large mass of uranium,
    >> Close[str]
     = ...

    >> str = OpenRead["ExampleData/EinsteinSzilLetter.txt"];
    >> Find[str, {"energy", "power"} ]
     = a new and important source of energy in the immediate future. Certain aspects
    >> Find[str, {"energy", "power"} ]
     = by which vast amounts of power and large quantities of new radium-like
    >> Close[str]
     = ...
    """

    attributes = ('Protected')

    options = {
        'AnchoredSearch': 'False',
        'IgnoreCase': 'False',
        'WordSearch': 'False',
        'RecordSeparators': '{"\r\n", "\n", "\r"}',
        'WordSeparators': '{" ", "\t"}',
    }

    def apply(self, name, n, text, evaluation, options):
        'Find[InputStream[name_, n_], text_, OptionsPattern[Find]]'

        # Options
        # TODO Implement extra options
        # py_options = self.check_options(options)
        # anchored_search = py_options['AnchoredSearch']
        # ignore_case = py_options['IgnoreCase']
        # word_search = py_options['WordSearch']
        # record_separators = py_options['RecordSeparators']
        # word_separators = py_options['WordSeparators']

        py_text = text.to_python()

        channel = Expression('InputStream', name, n)

        if not isinstance(py_text, list):
            py_text = [py_text]

        if not all(isinstance(t, basestring) and
                   t[0] == t[-1] == '"' for t in py_text):
            evaluation.message(
                'Find', 'unknown', Expression('Find', channel, text))
            return

        py_text = [t[1:-1] for t in py_text]

        while True:
            tmp = super(Find, self).apply(
                channel, Symbol('Record'), evaluation, options)
            py_tmp = tmp.to_python()[1:-1]

            if py_tmp == 'EndOfFile':
                evaluation.message(
                    'Find', 'notfound', Expression('Find', channel, text))
                return Symbol("$Failed")

            for t in py_text:
                if py_tmp.find(t) != -1:
                    return from_python(py_tmp)


class FindList(Builtin):
    """
    <dl>
    <dt>'FindList[$file$, $text$]'
      <dd>returns a list of all lines in $file$ that contain $text$.
    <dt>'FindList[$file$, {$text1$, $text2$, ...}]'
      <dd>returns a list of all lines in $file$ that contain any of the specified string.
    <dt>'FindList[{$file1$, $file2$, ...}, ...]'
      <dd>returns a list of all lines in any of the $filei$ that contain the specified strings.
    </dl>

    >> str = FindList["ExampleData/EinsteinSzilLetter.txt", "uranium"];
    #> Length[str]
     = 7

    >> FindList["ExampleData/EinsteinSzilLetter.txt", "uranium", 1]
     = {in manuscript, leads me to expect that the element uranium may be turned into}

    #> FindList["ExampleData/EinsteinSzilLetter.txt", "project"]
     = {}

    #> FindList["ExampleData/EinsteinSzilLetter.txt", "uranium", 0]
     = $Failed
    """

    messages = {
        'strs':
        'String or non-empty list of strings expected at position `1` in `2`.',
        'intnm':
        'Non-negative machine-sized integer expected at position `1` in `2`.',
    }

    attributes = ('Protected')

    options = {
        'AnchoredSearch': 'False',
        'IgnoreCase': 'False',
        'RecordSeparators': '{"\r\n", "\n", "\r"}',
        'WordSearch': 'False',
        'WordSeparators': '{" ", "\t"}',
    }

    # TODO: Extra options AnchoredSearch, IgnoreCase RecordSeparators,
    # WordSearch, WordSeparators this is probably best done with a regex

    def apply_without_n(self, filename, text, evaluation, options):
        'FindList[filename_, text_, OptionsPattern[FindList]]'
        return self.apply(filename, text, None, evaluation, options)

    def apply(self, filename, text, n, evaluation, options):
        'FindList[filename_, text_, n_, OptionsPattern[FindList]]'
        py_text = text.to_python()
        py_name = filename.to_python()
        if n is None:
            py_n = None
            expr = Expression('FindList', filename, text)
        else:
            py_n = n.to_python()
            expr = Expression('FindList', filename, text, n)

        if not isinstance(py_text, list):
            py_text = [py_text]

        if not isinstance(py_name, list):
            py_name = [py_name]

        if not all(isinstance(t, basestring) and
                   t[0] == t[-1] == '"' for t in py_name):
            evaluation.message('FindList', 'strs', '1', expr)
            return Symbol('$Failed')

        if not all(isinstance(t, basestring) and
                   t[0] == t[-1] == '"' for t in py_text):
            evaluation.message('FindList', 'strs', '2', expr)
            return Symbol('$Failed')

        if not ((isinstance(py_n, int) and py_n >= 0) or py_n is None):
            evaluation.message('FindList', 'intnm', '3', expr)
            return Symbol('$Failed')

        if py_n == 0:
            return Symbol('$Failed')

        py_text = [t[1:-1] for t in py_text]
        py_name = [t[1:-1] for t in py_name]

        results = []
        for path in py_name:
            try:
                with mathics_open(path, 'r') as f:
                    lines = f.readlines()
            except IOError:
                evaluation.message('General', 'noopen', path)
                return

            result = []
            for line in lines:
                for t in py_text:
                    if line.find(t) != -1:
                        result.append(line[:-1])
            results.append(result)

        results = [r for result in results for r in result]

        if isinstance(py_n, int):
            results = results[:min(py_n, len(results))]

        return from_python(results)


class InputStream(Builtin):
    """
    <dl>
    <dt>'InputStream[$name$, $n$]'
      <dd>represents an input stream.
    </dl>

    >> str = StringToStream["Mathics is cool!"]
     = ...
    >> Close[str]
     = String
    """

    attributes = ('Protected')

    def apply(self, name, n, evaluation):
        'InputStream[name_, n_]'
        return


class OutputStream(Builtin):
    """
    <dl>
    <dt>'OutputStream[$name$, $n$]'
      <dd>represents an output stream.
    </dl>

    >> OpenWrite[]
     = ...
    >> Close[%]
     = ...
    """

    attributes = ('Protected')

    def apply(self, name, n, evaluation):
        'OutputStream[name_, n_]'
        return


class StringToStream(Builtin):
    """
    <dl>
    <dt>'StringToStream[$string$]'
      <dd>converts a $string$ to an open input stream.
    </dl>

    >> strm = StringToStream["abc 123"]
     = InputStream[String, ...]

    #> Read[strm, Word]
     = abc

    #> Read[strm, Number]
     = 123

    #> Close[strm]
     = String
    """

    attributes = ('Protected')

    def apply(self, string, evaluation):
        'StringToStream[string_]'
        pystring = string.to_python()[1:-1]
        stream = io.StringIO(unicode(pystring))

        name = Symbol('String')
        n = next(NSTREAMS)

        result = Expression('InputStream', name, Integer(n))

        STREAMS.append(stream)
        return result


class Streams(Builtin):
    """
    <dl>
    <dt>'Streams[]'
      <dd>returns a list of all open streams.
    </dl>

    >> Streams[]
     = ...

    #> OpenWrite[]
     = ...
    #> Streams[%[[1]]]
     = {OutputStream[...]}

    #> Streams["some_nonexistant_name"]
     = {}
    """

    attributes = ('Protected')

    def apply(self, evaluation):
        'Streams[]'
        return self.apply_name(None, evaluation)

    def apply_name(self, name, evaluation):
        'Streams[name_String]'
        result = []
        for n in xrange(len(STREAMS)):
            stream = _lookup_stream(n)
            if stream is None or stream.closed:
                continue
            if isinstance(stream, io.StringIO):
                head = 'InputStream'
                _name = Symbol('String')
            else:
                mode = stream.mode
                if mode in ['r', 'rb']:
                    head = 'InputStream'
                elif mode in ['w', 'a', 'wb', 'ab']:
                    head = 'OutputStream'
                else:
                    raise ValueError("Unknown mode {0}".format(mode))
                _name = String(stream.name)
            expr = Expression(head, _name, Integer(n))
            if name is None or _name == name:
                result.append(expr)
        return Expression('List', *result)


class Compress(Builtin):
    """
    <dl>
    <dt>'Compress[$expr$]'
      <dd>gives a compressed string representation of $expr$.
    </dl>

    >> Compress[N[Pi, 10]]
     = eJwz1jM0MTS1NDIzNQEADRsCNw== 
    """

    attributes = ('Protected')

    options = {
        'Method': '{}',
    }

    def apply(self, expr, evaluation, options):
        'Compress[expr_, OptionsPattern[Compress]]'
        string = expr.format(evaluation, 'FullForm')
        string = string.boxes_to_text(
            evaluation=evaluation, show_string_characters=True)
        string = string.encode('utf-8')

        # TODO Implement other Methods
        result = zlib.compress(string)
        result = base64.encodestring(result)

        return String(result)


class Uncompress(Builtin):
    """
    <dl>
    <dt>'Uncompress["$string$"]'
      <dd>recovers an expression from a string generated by 'Compress'.
    </dl>

    >> Compress["Mathics is cool"]
     = eJxT8k0sychMLlbILFZIzs/PUQIANFwF1w==
    >> Uncompress[%]
     = Mathics is cool

    >> a = x ^ 2 + y Sin[x] + 10 Log[15];
    >> b = Compress[a];
    >> Uncompress[b]
     = x ^ 2 + y Sin[x] + 10 Log[15]
    """

    attributes = ('Protected')

    def apply(self, string, evaluation):
        'Uncompress[string_String]'
        string = string.get_string_value()
        string = base64.decodestring(string)
        tmp = zlib.decompress(string)
        tmp = tmp.decode('utf-8')

        try:
            expr = parse(tmp)
        except NameError:
            from mathics.core.parser import parse
            expr = parse(tmp)

        return expr


class FileByteCount(Builtin):
    """
    <dl>
    <dt>'FileByteCount[$file$]'
      <dd>returns the number of bytes in $file$.
    </dl>

    >> FileByteCount["ExampleData/sunflowers.jpg"]
     = 142286
    """

    messages = {
        'fstr':
        'File specification `1` is not a string of one or more characters.',
    }

    def apply(self, filename, evaluation):
        'FileByteCount[filename_]'
        py_filename = filename.to_python()
        if not (isinstance(py_filename, basestring) and
                py_filename[0] == py_filename[-1] == '"'):
            evaluation.message('FileByteCount', 'fstr', filename)
            return
        py_filename = py_filename[1:-1]

        try:
            with mathics_open(py_filename, 'rb') as f:
                count = 0
                tmp = f.read(1)
                while tmp != '':
                    count += 1
                    tmp = f.read(1)

        except IOError:
            evaluation.message('General', 'noopen', filename)
            return

        return from_python(count)


class FileHash(Builtin):
    """
    <dl>
    <dt>'FileHash[$file$]'
      <dd>returns an integer hash for the given $file$.
    <dt>'FileHash[$file$, $type$]'
      <dd>returns an integer hash of the specified $type$ for the given $file$.</dd>
      <dd>The types supported are "MD5", "Adler32", "CRC32", "SHA", "SHA224", "SHA256", "SHA384", and "SHA512".</dd>
    </dl>

    >> FileHash["ExampleData/sunflowers.jpg"]
     = 109937059621979839952736809235486742106

    >> FileHash["ExampleData/sunflowers.jpg", "MD5"]
     = 109937059621979839952736809235486742106

    >> FileHash["ExampleData/sunflowers.jpg", "Adler32"]
     = 1607049478

    >> FileHash["ExampleData/sunflowers.jpg", "SHA256"]
     = 111619807552579450300684600241129773909359865098672286468229443390003894913065

    #> FileHash["ExampleData/sunflowers.jpg", "CRC32"]
     = 933095683
    #> FileHash["ExampleData/sunflowers.jpg", "SHA"]
     = 851696818771101405642332645949480848295550938123
    #> FileHash["ExampleData/sunflowers.jpg", "SHA224"]
     = 8723805623766373862936267623913366865806344065103917676078120867011
    #> FileHash["ExampleData/sunflowers.jpg", "SHA384"]
     = 28288410602533803613059815846847184383722061845493818218404754864571944356226472174056863474016709057507799332611860
    #> FileHash["ExampleData/sunflowers.jpg", "SHA512"]
     = 10111462070211820348006107532340854103555369343736736045463376555356986226454343186097958657445421102793096729074874292511750542388324853755795387877480102

    #> FileHash["ExampleData/sunflowers.jpg", xyzsymbol]
     = FileHash[ExampleData/sunflowers.jpg, xyzsymbol]
    #> FileHash["ExampleData/sunflowers.jpg", "xyzstr"]
     = FileHash[ExampleData/sunflowers.jpg, xyzstr]
    #> FileHash[xyzsymbol]
     = FileHash[xyzsymbol]
    """

    rules = {
        'FileHash[filename_String]': 'FileHash[filename, "MD5"]',
    }

    attributes = ('Protected', 'ReadProtected')

    def apply(self, filename, hashtype, evaluation):
        'FileHash[filename_String, hashtype_String]'
        py_hashtype = hashtype.to_python()
        py_filename = filename.to_python()

        # TODO: MD2?
        supported_hashes = {
            'Adler32': zlib.adler32,
            'CRC32': zlib.crc32,
            'MD5': lambda s: int(hashlib.md5(s).hexdigest(), 16),
            'SHA': lambda s: int(hashlib.sha1(s).hexdigest(), 16),
            'SHA224': lambda s: int(hashlib.sha224(s).hexdigest(), 16),
            'SHA256': lambda s: int(hashlib.sha256(s).hexdigest(), 16),
            'SHA384': lambda s: int(hashlib.sha384(s).hexdigest(), 16),
            'SHA512': lambda s: int(hashlib.sha512(s).hexdigest(), 16),
        }

        py_hashtype = py_hashtype[1:-1]
        py_filename = py_filename[1:-1]

        hash_func = supported_hashes.get(py_hashtype)
        if hash_func is None:
            return

        try:
            with mathics_open(py_filename, 'rb') as f:
                dump = f.read()
        except IOError:
            evaluation.message('General', 'noopen', filename)
            return

        return from_python(hash_func(dump))


class FileDate(Builtin):
    """
    <dl>
    <dt>'FileDate[$file$, $types$]'
      <dd>returns the time and date at which the file was last modified.
    </dl>

    >> FileDate["ExampleData/sunflowers.jpg"]
     = ...

    >> FileDate["ExampleData/sunflowers.jpg", "Access"]
     = ...

    >> FileDate["ExampleData/sunflowers.jpg", "Creation"]
     = ...

    >> FileDate["ExampleData/sunflowers.jpg", "Change"]
     = ...

    >> FileDate["ExampleData/sunflowers.jpg", "Modification"]
     = ...

    >>  FileDate["ExampleData/sunflowers.jpg", "Rules"]
     = ...

    #>  FileDate["MathicsNonExistantExample"]
     : File not found during FileDate[MathicsNonExistantExample].
     = FileDate[MathicsNonExistantExample]
    #>  FileDate["MathicsNonExistantExample", "Modification"]
     : File not found during FileDate[MathicsNonExistantExample, Modification].
     = FileDate[MathicsNonExistantExample, Modification]

    #> FileDate["ExampleData/sunflowers.jpg", "Fail"]
     : Date type Fail should be "Access", "Modification", "Creation" (Windows only), "Change" (Macintosh and Unix only), or "Rules".
     = FileDate[ExampleData/sunflowers.jpg, Fail]
    """

    messages = {
        'nffil': 'File not found during `1`.',
        'datetype': ('Date type Fail should be "Access", "Modification", '
                     '"Creation" (Windows only), '
                     '"Change" (Macintosh and Unix only), or "Rules".'),
    }

    rules = {
        'FileDate[filepath_String, "Rules"]':
        '''{"Access" -> FileDate[filepath, "Access"],
            "Creation" -> FileDate[filepath, "Creation"],
            "Change" -> FileDate[filepath, "Change"],
            "Modification" -> FileDate[filepath, "Modification"]}''',
    }

    attributes = ('Protected')

    def apply(self, path, timetype, evaluation):
        'FileDate[path_, timetype_]'
        py_path = path_search(path.to_python()[1:-1])

        if py_path is None:
            if timetype is None:
                evaluation.message(
                    'FileDate', 'nffil', Expression('FileDate', path))
            else:
                evaluation.message('FileDate', 'nffil', Expression(
                    'FileDate', path, timetype))
            return

        if timetype is None:
            time_type = 'Modification'
        else:
            time_type = timetype.to_python()[1:-1]

        if time_type == 'Access':
            result = os.path.getatime(py_path)
        elif time_type == 'Creation':
            if os.name == 'posix':
                return Expression('Missing', 'NotApplicable')
            result = os.path.getctime(py_path)
        elif time_type == 'Change':
            if os.name != 'posix':
                return Expression('Missing', 'NotApplicable')
            result = os.path.getctime(py_path)
        elif time_type == 'Modification':
            result = os.path.getmtime(py_path)
        else:
            evaluation.message('FileDate', 'datetype')
            return

        # Offset for system epoch
        epochtime = Expression('AbsoluteTime', time.strftime(
            "%Y-%m-%d %H:%M",
            time.gmtime(0))).to_python(n_evaluation=evaluation)
        result += epochtime

        return Expression('DateList', from_python(result))

    def apply_default(self, path, evaluation):
        'FileDate[path_]'
        return self.apply(path, None, evaluation)


class SetFileDate(Builtin):
    """
    <dl>
    <dt>'SetFileDate["$file$"]'
      <dd>set the file access and modification dates of $file$ to the current date.
    <dt>'SetFileDate["$file$", $date$]'
      <dd>set the file access and modification dates of $file$ to the specified date list.
    <dt>'SetFileDate["$file$", $date$, "$type$"]'
      <dd>set the file date of $file$ to the specified date list.
      The "$type$" can be one of "$Access$", "$Creation$", "$Modification$", or 'All'.
    </dl>

    Create a temporary file (for example purposes)
    >> tmpfilename = $TemporaryDirectory <> "/tmp0";
    >> Close[OpenWrite[tmpfilename]];

    >> SetFileDate[tmpfilename, {2000, 1, 1, 0, 0, 0.}, "Access"];

    >> FileDate[tmpfilename, "Access"]
     = {2000, 1, 1, 0, 0, 0.}

    #> SetFileDate[tmpfilename, {2001, 1, 1, 0, 0, 0.}];
    #> FileDate[tmpfilename, "Access"]
     = {2001, 1, 1, 0, 0, 0.}

    #> SetFileDate[tmpfilename]
    #> FileDate[tmpfilename, "Access"]
     = {...}

    #> DeleteFile[tmpfilename]

    #> SetFileDate["MathicsNonExample"]
     : File not found during SetFileDate[MathicsNonExample].
     = $Failed
    """

    messages = {
        'fstr': ('File specification `1` is not a string of one or '
                 'more characters.'),
        'nffil': 'File not found during `1`.',
        'fdate': ('Date specification should be either the number of seconds '
                  'since January 1, 1900 or a {y, m, d, h, m, s} list.'),
        'datetype': ('Date type a should be "Access", "Modification", '
                     '"Creation" (Windows only), or All.'),
        'nocreationunix': ('The Creation date of a file cannot be set on '
                           'Macintosh or Unix.'),
    }

    attributes = ('Protected')

    def apply(self, filename, datelist, attribute, evaluation):
        'SetFileDate[filename_, datelist_, attribute_]'

        py_filename = filename.to_python()

        if datelist is None:
            py_datelist = Expression(
                'DateList').evaluate(evaluation).to_python()
            expr = Expression('SetFileDate', filename)
        else:
            py_datelist = datelist.to_python()

        if attribute is None:
            py_attr = 'All'
            if datelist is not None:
                expr = Expression('SetFileDate', filename, datelist)
        else:
            py_attr = attribute.to_python()
            expr = Expression('SetFileDate', filename, datelist, attribute)

        # Check filename
        if not (isinstance(py_filename, basestring) and
                py_filename[0] == py_filename[-1] == '"'):
            evaluation.message('SetFileDate', 'fstr', filename)
            return
        py_filename = path_search(py_filename[1:-1])

        if py_filename is None:
            evaluation.message('SetFileDate', 'nffil', expr)
            return Symbol('$Failed')

        # Check datelist
        if not (isinstance(py_datelist, list) and len(py_datelist) == 6 and
                all(isinstance(d, int) for d in py_datelist[:-1]) and
                isinstance(py_datelist[-1], float)):
            evaluation.message('SetFileDate', 'fdate', expr)

        # Check attribute
        if py_attr not in ['"Access"', '"Creation"', '"Modification"', 'All']:
            evaluation.message('SetFileDate', 'datetype')
            return

        epochtime = Expression('AbsoluteTime', time.strftime(
            "%Y-%m-%d %H:%M", time.gmtime(0))).evaluate(evaluation).to_python()

        stattime = Expression('AbsoluteTime', from_python(py_datelist))
        stattime = stattime.to_python(n_evaluation=evaluation)

        stattime -= epochtime

        try:
            os.stat(py_filename)
            if py_attr == '"Access"':
                os.utime(py_filename, (
                    stattime, os.path.getatime(py_filename)))
            if py_attr == '"Creation"':
                if os.name == 'posix':
                    evaluation.message('SetFileDate', 'nocreationunix')
                    return Symbol('$Failed')
                else:
                    # TODO: Note: This is windows only
                    return Symbol('$Failed')
            if py_attr == '"Modification"':
                os.utime(py_filename, (os.path.getatime(
                    py_filename), stattime))
            if py_attr == 'All':
                os.utime(py_filename, (stattime, stattime))
        except OSError as e:
            print e
            # evaluation.message(...)
            return Symbol('$Failed')

        return Symbol('Null')

    def apply_1arg(self, filename, evaluation):
        'SetFileDate[filename_]'
        return self.apply(filename, None, None, evaluation)

    def apply_2arg(self, filename, datelist, evaluation):
        'SetFileDate[filename_, datelist_]'
        return self.apply(filename, datelist, None, evaluation)


class CopyFile(Builtin):
    """
    <dl>
    <dt>'CopyFile["$file1$", "$file2$"]'
      <dd>copies $file1$ to $file2$.
    </dl>

    >> CopyFile["ExampleData/sunflowers.jpg", "MathicsSunflowers.jpg"]
     = MathicsSunflowers.jpg
    >> DeleteFile["MathicsSunflowers.jpg"]
    """

    messages = {
        'filex': 'Cannot overwrite existing file `1`.',
        'fstr': ('File specification `1` is not a string of '
                 'one or more characters.'),
        'nffil': 'File not found during `1`.',
    }

    attributes = ('Protected')

    def apply(self, source, dest, evaluation):
        'CopyFile[source_, dest_]'

        py_source = source.to_python()
        py_dest = dest.to_python()

        # Check filenames
        if not (isinstance(py_source, basestring) and
                py_source[0] == py_source[-1] == '"'):
            evaluation.message('CopyFile', 'fstr', source)
            return
        if not (isinstance(py_dest, basestring) and
                py_dest[0] == py_dest[-1] == '"'):
            evaluation.message('CopyFile', 'fstr', dest)
            return

        py_source = py_source[1:-1]
        py_dest = py_dest[1:-1]

        py_source = path_search(py_source)

        if py_source is None:
            evaluation.message('CopyFile', 'filex', source)
            return Symbol('$Failed')

        if os.path.exists(py_dest):
            evaluation.message('CopyFile', 'filex', dest)
            return Symbol('$Failed')

        try:
            shutil.copy(py_source, py_dest)
        except IOError:
            evaluation.message('CopyFile', 'nffil', Expression(
                'CopyFile', source, dest))
            return Symbol('$Failed')

        return dest


class RenameFile(Builtin):
    """
    <dl>
    <dt>'RenameFile["$file1$", "$file2$"]'
      <dd>renames $file1$ to $file2$.
    </dl>

    >> CopyFile["ExampleData/sunflowers.jpg", "MathicsSunflowers.jpg"]
     = MathicsSunflowers.jpg
    >> RenameFile["MathicsSunflowers.jpg", "MathicsSunnyFlowers.jpg"]
     = MathicsSunnyFlowers.jpg
    >> DeleteFile["MathicsSunnyFlowers.jpg"]
    """

    messages = {
        'filex': 'Cannot overwrite existing file `1`.',
        'fstr': ('File specification `1` is not a string of '
                 'one or more characters.'),
        'nffil': 'File not found during `1`.',
    }

    attributes = ('Protected')

    def apply(self, source, dest, evaluation):
        'RenameFile[source_, dest_]'

        py_source = source.to_python()
        py_dest = dest.to_python()

        # Check filenames
        if not (isinstance(py_source, basestring) and
                py_source[0] == py_source[-1] == '"'):
            evaluation.message('RenameFile', 'fstr', source)
            return
        if not (isinstance(py_dest, basestring) and
                py_dest[0] == py_dest[-1] == '"'):
            evaluation.message('RenameFile', 'fstr', dest)
            return

        py_source = py_source[1:-1]
        py_dest = py_dest[1:-1]

        py_source = path_search(py_source)

        if py_source is None:
            evaluation.message('RenameFile', 'filex', source)
            return Symbol('$Failed')

        if os.path.exists(py_dest):
            evaluation.message('RenameFile', 'filex', dest)
            return Symbol('$Failed')

        try:
            shutil.move(py_source, py_dest)
        except IOError:
            evaluation.message('RenameFile', 'nffil', dest)
            return Symbol('$Failed')

        return dest


class DeleteFile(Builtin):
    """
    <dl>
    <dt>'Delete["$file$"]'
      <dd>deletes $file$.
    <dt>'Delete[{"$file1$", "$file2$", ...}]'
      <dd>deletes a list of files.
    </dl>

    >> CopyFile["ExampleData/sunflowers.jpg", "MathicsSunflowers.jpg"];
    >> DeleteFile["MathicsSunflowers.jpg"]

    >> CopyFile["ExampleData/sunflowers.jpg", "MathicsSunflowers1.jpg"];
    >> CopyFile["ExampleData/sunflowers.jpg", "MathicsSunflowers2.jpg"];
    >> DeleteFile[{"MathicsSunflowers1.jpg", "MathicsSunflowers2.jpg"}]
    """

    messages = {
        'filex': 'Cannot overwrite existing file `1`.',
        'strs': ('String or non-empty list of strings expected at '
                 'position `1` in `2`.'),
        'nffil': 'File not found during `1`.',
    }

    attributes = ('Protected')

    def apply(self, filename, evaluation):
        'DeleteFile[filename_]'

        py_path = filename.to_python()
        if not isinstance(py_path, list):
            py_path = [py_path]

        py_paths = []
        for path in py_path:
            # Check filenames
            if not (isinstance(path, basestring) and
                    path[0] == path[-1] == '"'):
                evaluation.message('DeleteFile', 'strs', filename,
                                   Expression('DeleteFile', filename))
                return

            path = path[1:-1]
            path = path_search(path)

            if path is None:
                evaluation.message('DeleteFile', 'nffil', Expression(
                    'DeleteFile', filename))
                return Symbol('$Failed')
            py_paths.append(path)

        for path in py_paths:
            try:
                os.remove(path)
            except OSError:
                return Symbol('$Failed')

        return Symbol('Null')


class DirectoryStack(Builtin):
    """
    <dl>
    <dt>'DirectoryStack[]'
      <dd>returns the directory stack.
    </dl>

    >> DirectoryStack[]
    = ...
    """

    attributes = ('Protected')

    def apply(self, evaluation):
        'DirectoryStack[]'
        global DIRECTORY_STACK
        return from_python(DIRECTORY_STACK)


class Directory(Builtin):
    """
    <dl>
    <dt>'Directory[]'
      <dd>returns the current working directory.
    </dl>

    >> Directory[]
    = ...
    """

    attributes = ('Protected')

    def apply(self, evaluation):
        'Directory[]'
        result = os.getcwd()
        return String(result)


class ParentDirectory(Builtin):
    """
    <dl>
    <dt>'ParentDirectory[]'
      <dd>returns the parent of the current working directory.
    <dt>'ParentDirectory["$dir$"]'
      <dd>returns the parent $dir$.
    </dl>

    >> ParentDirectory[]
     = ...
    """

    rules = {
        'ParentDirectory[]': 'ParentDirectory[Directory[]]',
    }

    messages = {
        'fstr': ('File specification `1` is not a string of '
                 'one or more characters.'),
    }

    attributes = ('Protected')

    def apply(self, path, evaluation):
        'ParentDirectory[path_]'

        if not isinstance(path, String):
            evaluation.message('ParentDirectory', 'fstr', path)
            return

        pypath = path.to_python()[1:-1]

        result = os.path.abspath(os.path.join(pypath, os.path.pardir))
        return String(result)


class SetDirectory(Builtin):
    """
    <dl>
    <dt>'SetDirectory[$dir$]'
      <dd>sets the current working directory to $dir$.
    </dl>

    >> SetDirectory[]
    = ...

    #> SetDirectory["MathicsNonExample"]
     : Cannot set current directory to MathicsNonExample.
     = $Failed
    """

    rules = {
        'SetDirectory[]': 'SetDirectory[$HomeDirectory]',
    }

    messages = {
        'fstr': ('File specification `1` is not a string of '
                 'one or more characters.'),
        'cdir': 'Cannot set current directory to `1`.',
    }

    attributes = ('Protected')

    def apply(self, path, evaluation):
        'SetDirectory[path_]'

        if not isinstance(path, String):
            evaluation.message('SetDirectory', 'fstr', path)
            return

        py_path = path.__str__()[1:-1]
        py_path = path_search(py_path)

        if py_path is None:
            evaluation.message('SetDirectory', 'cdir', path)
            return Symbol('$Failed')

        os.chdir(py_path)
        DIRECTORY_STACK.append(os.getcwd())
        return String(os.getcwd())


class ResetDirectory(Builtin):
    """
    <dl>
    <dt>'ResetDirectory[]'
      <dd>pops a directory from the directory stack and returns it.
    </dl>

    >> ResetDirectory[]
    = ...
    """

    messages = {
        'dtop': 'Directory stack is empty.',
    }

    attributes = ('Protected')

    def apply(self, evaluation):
        'ResetDirectory[]'
        global DIRECTORY_STACK

        try:
            tmp = DIRECTORY_STACK.pop()
        except IndexError:
            tmp = os.getcwd()
            evaluation.message('ResetDirectory', 'dtop')
        else:
            os.chdir(tmp)
        return String(tmp)


class CreateDirectory(Builtin):
    """
    <dl>
    <dt>'CreateDirectory["$dir$"]'
      <dd>creates a directory called $dir$.
    <dt>'CreateDirectory[]'
      <dd>creates a temporary directory.
    </dl>

    >> dir = CreateDirectory[]
     = ...
    #> DirectoryQ[dir]
     = True
    #> DeleteDirectory[dir]
    """

    attributes = ('Listable', 'Protected')

    options = {
        'CreateIntermediateDirectories': 'True',
    }

    messages = {
        'fstr': ('File specification `1` is not a string of '
                 'one or more characters.'),
        'nffil': "File not found during `1`.",
        'filex': "`1` already exists.",
    }

    def apply(self, dirname, evaluation, options):
        'CreateDirectory[dirname_, OptionsPattern[CreateDirectory]]'

        expr = Expression('CreateDirectory', dirname)
        py_dirname = dirname.to_python()

        if not (isinstance(py_dirname, basestring) and
                py_dirname[0] == py_dirname[-1] == '"'):
            evaluation.message('CreateDirectory', 'fstr', dirname)
            return

        py_dirname = py_dirname[1:-1]

        if os.path.isdir(py_dirname):
            evaluation.message(
                'CreateDirectory', 'filex', os.path.abspath(py_dirname))
            return

        os.mkdir(py_dirname)

        if not os.path.isdir(py_dirname):
            evaluation.message('CreateDirectory', 'nffil', expr)
            return

        return String(os.path.abspath(py_dirname))

    def apply_empty(self, evaluation, options):
        'CreateDirectory[OptionsPattern[CreateDirectory]]'
        dirname = tempfile.mkdtemp(prefix='m', dir=TMP_DIR)
        return String(dirname)


class DeleteDirectory(Builtin):
    """
    <dl>
    <dt>'DeleteDirectory["$dir$"]'
      <dd>deletes a directory called $dir$.
    </dl>

    >> dir = CreateDirectory[]
     = ...
    >> DeleteDirectory[dir]
    >> DirectoryQ[dir]
     = False
    #> Quiet[DeleteDirectory[dir]]
     = $Failed
    """

    attributes = ('Protected')

    options = {
        'DeleteContents': 'False',
    }

    messages = {
        'strs': ('String or non-empty list of strings expected at '
                 'position 1 in `1`.'),
        'nodir': 'Directory `1` not found.',
        'dirne': 'Directory `1` not empty.',
        'optx': 'Unknown option `1` in `2`',
        'idcts': 'DeleteContents expects either True or False.',   # MMA Bug
    }

    def apply(self, dirname, evaluation, options):
        'DeleteDirectory[dirname_, OptionsPattern[DeleteDirectory]]'

        expr = Expression('DeleteDirectory', dirname)
        py_dirname = dirname.to_python()

        delete_contents = options['DeleteContents'].to_python()
        if not delete_contents in [True, False]:
            evaluation.message('DeleteDirectory', 'idcts')
            return

        if not (isinstance(py_dirname, basestring) and
                py_dirname[0] == py_dirname[-1] == '"'):
            evaluation.message('DeleteDirectory', 'strs', expr)
            return

        py_dirname = py_dirname[1:-1]

        if not os.path.isdir(py_dirname):
            evaluation.message('DeleteDirectory', 'nodir', dirname)
            return Symbol('$Failed')

        if delete_contents:
            shutil.rmtree(py_dirname)
        else:
            if os.listdir(py_dirname) != []:
                evaluation.message('DeleteDirectory', 'dirne', dirname)
                return Symbol('$Failed')
            os.rmdir(py_dirname)

        return Symbol('Null')


class CopyDirectory(Builtin):
    """
    <dl>
    <dt>'CopyDirectory["$dir1$", "$dir2$"]'
      <dd>copies directory $dir1$ to $dir2$.
    </dl>
    """

    attributes = ('Protected')

    messages = {
        'argr': 'called with `1` argument; 2 arguments are expected.',
        'fstr': ('File specification `1` is not a string of '
                 'one or more characters.'),
        'filex': 'Cannot overwrite existing file `1`.',
        'nodir': 'Directory `1` not found.',
    }

    def apply(self, dirs, evaluation):
        'CopyDirectory[dirs__]'

        seq = dirs.get_sequence()
        if len(seq) != 2:
            evaluation.message('CopyDirectory', 'argr', len(seq))
            return
        (dir1, dir2) = (s.to_python() for s in seq)

        if not (isinstance(dir1, basestring) and dir1[0] == dir1[-1] == '"'):
            evaluation.message('CopyDirectory', 'fstr', seq[0])
            return
        dir1 = dir1[1:-1]

        if not (isinstance(dir2, basestring) and dir2[0] == dir2[-1] == '"'):
            evaluation.message('CopyDirectory', 'fstr', seq[1])
            return
        dir2 = dir2[1:-1]

        if not os.path.isdir(dir1):
            evaluation.message('CopyDirectory', 'nodir', seq[0])
            return Symbol('$Failed')
        if os.path.isdir(dir2):
            evaluation.message('CopyDirectory', 'filex', seq[1])
            return Symbol('$Failed')

        shutil.copytree(dir1, dir2)

        return String(os.path.abspath(dir2))


class RenameDirectory(Builtin):
    """
    <dl>
    <dt>'RenameyDirectory["$dir1$", "$dir2$"]'
      <dd>renames directory $dir1$ to $dir2$.
    </dl>
    """

    attributes = ('Protected')

    messages = {
        'argr': 'called with `1` argument; 2 arguments are expected.',
        'fstr': ('File specification `1` is not a string of '
                 'one or more characters.'),
        'filex': 'Cannot overwrite existing file `1`.',
        'nodir': 'Directory `1` not found.',
    }

    def apply(self, dirs, evaluation):
        'RenameDirectory[dirs__]'

        seq = dirs.get_sequence()
        if len(seq) != 2:
            evaluation.message('RenameDirectory', 'argr', len(seq))
            return
        (dir1, dir2) = (s.to_python() for s in seq)

        if not (isinstance(dir1, basestring) and dir1[0] == dir1[-1] == '"'):
            evaluation.message('RenameDirectory', 'fstr', seq[0])
            return
        dir1 = dir1[1:-1]

        if not (isinstance(dir2, basestring) and dir2[0] == dir2[-1] == '"'):
            evaluation.message('RenameDirectory', 'fstr', seq[1])
            return
        dir2 = dir2[1:-1]

        if not os.path.isdir(dir1):
            evaluation.message('RenameDirectory', 'nodir', seq[0])
            return Symbol('$Failed')
        if os.path.isdir(dir2):
            evaluation.message('RenameDirectory', 'filex', seq[1])
            return Symbol('$Failed')

        shutil.move(dir1, dir2)

        return String(os.path.abspath(dir2))


class FileType(Builtin):
    """
    <dl>
    <dt>'FileType["$file$"]'
      <dd>returns the type of a file, from 'File', 'Directory' or 'None'.
    </dl>

    >> FileType["ExampleData/sunflowers.jpg"]
     = File
    >> FileType["ExampleData"]
     = Directory
    >> FileType["ExampleData/nonexistant"]
     = None

    #> FileType[x]
     : File specification x is not a string of one or more characters.
     = FileType[x]
    """

    messages = {
        'fstr': ('File specification `1` is not a string of '
                 'one or more characters.'),
    }

    attributes = ('Protected')

    def apply(self, filename, evaluation):
        'FileType[filename_]'
        if not isinstance(filename, String):
            evaluation.message('FileType', 'fstr', filename)
            return
        path = filename.to_python()[1:-1]

        path = path_search(path)

        if path is None:
            return Symbol('None')

        if os.path.isfile(path):
            return Symbol('File')
        else:
            return Symbol('Directory')


class FileExistsQ(Builtin):
    """
    <dl>
    <dt>'FileExistsQ["$file$"]'
      <dd>returns 'True' if $file$ exists and 'False' otherwise.
    </dl>

    >> FileExistsQ["ExampleData/sunflowers.jpg"]
     = True
    >> FileExistsQ["ExampleData/sunflowers.png"]
     = False
    """

    messages = {
        'fstr': ('File specification `1` is not a string of '
                 'one or more characters.'),
    }

    attributes = ('Protected')

    def apply(self, filename, evaluation):
        'FileExistsQ[filename_]'
        path = filename.to_python()
        if not (isinstance(path, basestring) and path[0] == path[-1] == '"'):
            evaluation.message('FileExistsQ', 'fstr', filename)
            return
        path = path[1:-1]

        path = path_search(path)

        if path is None:
            return Symbol('False')
        return Symbol('True')


class DirectoryQ(Builtin):
    """
    <dl>
    <dt>'DirectoryQ["$name$"]'
      <dd>returns 'True' if the directory called $name$ exists and 'False' otherwise.
    </dl>

    >> DirectoryQ["ExampleData/"]
     = True
    >> DirectoryQ["ExampleData/MythicalSubdir/"]
     = False

    #> DirectoryQ["ExampleData"]
     = True

    #> DirectoryQ["ExampleData/MythicalSubdir/NestedDir/"]
     = False
    """

    messages = {
        'fstr': ('File specification `1` is not a string of '
                 'one or more characters.'),
    }

    attributes = ('Protected')

    def apply(self, pathname, evaluation):
        'DirectoryQ[pathname_]'
        path = pathname.to_python()

        if not (isinstance(path, basestring) and path[0] == path[-1] == '"'):
            evaluation.message('DirectoryQ', 'fstr', pathname)
            return
        path = path[1:-1]

        path = path_search(path)

        if path is not None and os.path.isdir(path):
            return Symbol('True')
        return Symbol('False')


class Needs(Builtin):
    """
    <dl>'Needs["context`"]'
      <dd>loads the specified context if not already in '$Packages'.
    </dl>

    >> Needs["VectorAnalysis`"]
    #> Needs["VectorAnalysis`"]

    #> Needs["SomeFakePackageOrTypo`"]
     : Cannot open SomeFakePackageOrTypo`.
     : Context SomeFakePackageOrTypo` was not created when Needs was evaluated.
     = $Failed

    #> Needs["VectorAnalysis"]
     : Invalid context specified at position 1 in Needs[VectorAnalysis]. A context must consist of valid symbol names separated by and ending with `.
     = Needs[VectorAnalysis]

    ## --- VectorAnalysis ---

    #> Needs["VectorAnalysis`"]

    #> DotProduct[{1,2,3}, {4,5,6}]
     = 32
    #> DotProduct[{-1.4, 0.6, 0.2}, {0.1, 0.6, 1.7}]
     = 0.56

    #> CrossProduct[{1,2,3}, {4,5,6}]
     = {-3, 6, -3}
    #> CrossProduct[{-1.4, 0.6, 0.2}, {0.1, 0.6, 1.7}]
     = {0.9, 2.4, -0.9}

    #> ScalarTripleProduct[{-2,3,1},{0,4,0},{-1,3,3}]
     = -20
    #> ScalarTripleProduct[{-1.4,0.6,0.2}, {0.1,0.6,1.7}, {0.7,-1.5,-0.2}]
     = -2.79

    #> CoordinatesToCartesian[{2, Pi, 3}, Spherical]
     = {0, 0, -2}
    #> CoordinatesFromCartesian[%, Spherical]
     = {2, Pi, 0}
    #> CoordinatesToCartesian[{2, Pi, 3}, Cylindrical]
     = {-2, 0, 3}
    #> CoordinatesFromCartesian[%, Cylindrical]
     = {2, Pi, 3}
    ## Needs Sin/Cos exact value (PR #100) for these tests to pass
    ## #> CoordinatesToCartesian[{2, Pi / 4, Pi / 3}, Spherical]
    ##  = {Sqrt[2] / 2, Sqrt[6] / 2, Sqrt[2]}
    ## #> CoordinatesFromCartesian[%, Spherical]
    ##  = {2, Pi / 4, Pi / 3}
    ## #> CoordinatesToCartesian[{2, Pi / 4, -1}, Cylindrical]
    ##  = {Sqrt[2], Sqrt[2], -1}
    ## #> CoordinatesFromCartesian[%, Cylindrical]
    ##  = {2, Pi / 4, -1}
    #> CoordinatesToCartesian[{0.27, 0.51, 0.92}, Cylindrical]
     = {0.235641017064352841, 0.131807856658385023, 0.92}
    #> CoordinatesToCartesian[{0.27, 0.51, 0.92}, Spherical]
     = {0.0798518563676219116, 0.10486654429093224, 0.235641017064352841}

    #> Coordinates[]
     = {Xx, Yy, Zz}
    #> Coordinates[Spherical]
     = {Rr, Ttheta, Pphi}
    #> SetCoordinates[Cylindrical]
     = Cylindrical[Rr, Ttheta, Zz]
    #> Coordinates[]
     = {Rr, Ttheta, Zz}
    #> CoordinateSystem
     = Cylindrical
    #> Parameters[]
     = {}
    #> CoordinateRanges[]
    ## = {0 <= Rr < Infinity, -Pi < Ttheta <= Pi, -Infinity < Zz < Infinity}
     = {0 <= Rr && Rr < Infinity, -Pi < Ttheta && Ttheta <= Pi, -Infinity < Zz < Infinity}
    #> CoordinateRanges[Cartesian]
     = {-Infinity < Xx < Infinity, -Infinity < Yy < Infinity, -Infinity < Zz < Infinity}
    #> ScaleFactors[Cartesian]
     = {1, 1, 1}
    #> ScaleFactors[Spherical]
     = {1, Rr, Rr Sin[Ttheta]}
    #> ScaleFactors[Cylindrical]
     = {1, Rr, 1}
    #> ScaleFactors[{2, 1, 3}, Cylindrical]
     = {1, 2, 1}
    #> JacobianDeterminant[Cartesian]
     = 1
    #> JacobianDeterminant[Spherical]
     = Rr ^ 2 Sin[Ttheta]
    #> JacobianDeterminant[Cylindrical]
     = Rr
    #> JacobianDeterminant[{2, 1, 3}, Cylindrical]
     = 2
    #> JacobianMatrix[Cartesian]
     = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}
    #> JacobianMatrix[Spherical]
     = {{Cos[Pphi] Sin[Ttheta], Rr Cos[Pphi] Cos[Ttheta], -Rr Sin[Pphi] Sin[Ttheta]}, {Sin[Pphi] Sin[Ttheta], Rr Cos[Ttheta] Sin[Pphi], Rr Cos[Pphi] Sin[Ttheta]}, {Cos[Ttheta], -Rr Sin[Ttheta], 0}}
    #> JacobianMatrix[Cylindrical]
     = {{Cos[Ttheta], -Rr Sin[Ttheta], 0}, {Sin[Ttheta], Rr Cos[Ttheta], 0}, {0, 0, 1}}
    """

    messages = {
        'ctx': ('Invalid context specified at position `2` in `1`. '
                'A context must consist of valid symbol names separated by '
                'and ending with `3`.'),
        'nocont': 'Context `1` was not created when Needs was evaluated.',
    }

    def apply(self, context, evaluation):
        'Needs[context_String]'

        if context.get_string_value()[-1] != '`':
            evaluation.message('Needs', 'ctx', Expression(
                'Needs', context), 1, '`')
            return

        # TODO
        # if Expression('MemberQ', context, Symbol('$Packages')).is_true():
        #    # Already loaded
        #    return Symbol('Null')

        result = Expression('Get', context).evaluate(evaluation)

        if result == Symbol('$Failed'):
            evaluation.message('Needs', 'nocont', context)
            return Symbol('$Failed')

        return Symbol('Null')

########NEW FILE########
__FILENAME__ = functional
# -*- coding: utf8 -*-

"""
Functional programming
"""

from mathics.builtin.base import Builtin, PostfixOperator
from mathics.core.expression import Expression


class Function(PostfixOperator):
    """
    <dl>
    <dt>'Function[$body$]' or '$body$ &'
        <dd>represents a pure function with parameters '#1', '#2', etc.
    <dt>'Function[{$x1$, $x2$, ...}, $body$]'
        <dd>represents a pure function with parameters $x1$, $x2$, etc.
    </dl>

    >> f := # ^ 2 &
    >> f[3]
     = 9
    >> #^3& /@ {1, 2, 3}
     = {1, 8, 27}
    >> #1+#2&[4, 5]
     = 9

    You can use 'Function' with named parameters:
    >> Function[{x, y}, x * y][2, 3]
     = 6

    Parameters are renamed, when necessary, to avoid confusion:
    >> Function[{x}, Function[{y}, f[x, y]]][y]
     = Function[{y$}, f[y, y$]]
    >> Function[{y}, f[x, y]] /. x->y
     = Function[{y}, f[y, y]]
    >> Function[y, Function[x, y^x]][x][y]
     = x ^ y
    >> Function[x, Function[y, x^y]][x][y]
     = x ^ y

    Slots in inner functions are not affected by outer function application:
    >> g[#] & [h[#]] & [5]
     = g[h[5]]

    #> g[x_,y_] := x+y
    #> g[Sequence@@Slot/@Range[2]]&[1,2]
     = #1 + #2
    #> Evaluate[g[Sequence@@Slot/@Range[2]]]&[1,2]
     = 3
    """

    operator = '&'
    precedence = 90
    attributes = ('HoldAll',)

    messages = {
        'slot': "`1` should contain a positive integer.",
        'slotn': "Slot number `1` cannot be filled.",
        'fpct': "Too many parameters to be filled.",
    }

    def apply_slots(self, body, args, evaluation):
        'Function[body_][args___]'

        args = args.get_sequence()
        args.insert(0, Expression('Function', body))
        return body.replace_slots(args, evaluation)

    def apply_named(self, vars, body, args, evaluation):
        'Function[vars_, body_][args___]'

        if vars.has_form('List', None):
            vars = vars.leaves
        else:
            vars = [vars]

        args = args.get_sequence()
        if len(vars) > len(args):
            evaluation.message('Function', 'fpct', )
        else:
            vars = dict(zip((
                var.get_name() for var in vars), args[:len(vars)]))
            return body.replace_vars(vars)


class Slot(Builtin):
    """
    <dl>
    <dt>'#$n$'
        <dd>represents the $n$th argument to a pure function.
    <dt>'#'
        <dd>is short-hand for '#1'
    <dt>'#0'
        <dd>represents the pure function itself.
    </dl>

    >> #
     = #1

    Unused arguments are simply ignored:
    >> {#1, #2, #3}&[1, 2, 3, 4, 5]
     = {1, 2, 3}

    Recursive pure functions can be written using '#0':
    >> If[#1<=1, 1, #1 #0[#1-1]]& [10]
     = 3628800

    #> # // InputForm
     = #1

    #> #0 // InputForm
     = #0
    """

    attributes = ('NHoldAll',)

    rules = {
        'Slot[]': 'Slot[1]',
        'MakeBoxes[Slot[n_Integer?NonNegative],'
        '  f:StandardForm|TraditionalForm|InputForm|OutputForm]': (
            '"#" <> ToString[n]'),
    }


class SlotSequence(Builtin):
    """
    <dl>
    <dt>'##'
        <dd>is the sequence of arguments supplied to a pure function.
    <dt>'##$n$'
        <dd>starts with the $n$th argument.
    </dl>

    >> Plus[##]& [1, 2, 3]
     = 6
    >> Plus[##2]& [1, 2, 3]
     = 5

    >> FullForm[##]
     = SlotSequence[1]

    #> ## // InputForm
     = ##1
    """

    attributes = ('NHoldAll',)

    rules = {
        'SlotSequence[]': 'SlotSequence[1]',
        'MakeBoxes[SlotSequence[n_Integer?Positive],'
        'f:StandardForm|TraditionalForm|InputForm|OutputForm]': (
            '"##" <> ToString[n]'),
    }


class Composition(Builtin):
    """
    <dl>
    <dt>'Composition[$f$, $g$]'
        <dd>returns the composition of two functions $f$ and $g$.
    </dl>

    >> Composition[f, g][x]
     = f[g[x]]
    >> Composition[f, g, h][x, y, z]
     = f[g[h[x, y, z]]]
    >> Composition[]
     = Identity
    >> Composition[][x]
     = x
    >> Attributes[Composition]
     = {Flat, OneIdentity, Protected}
    >> Composition[f, Composition[g, h]]
     = Composition[f, g, h]
    """

    attributes = ('Flat', 'OneIdentity')

    rules = {
        'Composition[]': 'Identity',
    }

    def apply(self, functions, args, evaluation):
        'Composition[functions__][args___]'

        functions = functions.get_sequence()
        args = args.get_sequence()
        result = Expression(functions[-1], *args)
        for f in reversed(functions[:-1]):
            result = Expression(f, result)
        return result


class Identity(Builtin):
    """
    >> Identity[x]
     = x
    >> Identity[x, y]
     = Identity[x, y]
    """

    rules = {
        'Identity[x_]': 'x',
    }

########NEW FILE########
__FILENAME__ = graphics
# -*- coding: utf8 -*-

"""
Graphics
"""

from math import floor, ceil, log10

import json

from mathics.builtin.base import (
    Builtin, InstancableBuiltin, BoxConstruct, BoxConstructError)
from mathics.builtin.options import options_to_rules
from mathics.core.expression import (
    Expression, Integer, Real, NumberError, Symbol)


class CoordinatesError(BoxConstructError):
    pass


class ColorError(BoxConstructError):
    pass

element_heads = ('Rectangle', 'Disk', 'Line', 'Point',
                 'Circle', 'Polygon', 'Inset', 'Text', 'Sphere')
color_heads = ('RGBColor', 'CMYKColor', 'Hue', 'GrayLevel')
thickness_heads = ('Thickness', 'AbsoluteThickness', 'Thick', 'Thin')

GRAPHICS_SYMBOLS = set(['List', 'Rule', 'VertexColors'] + list(element_heads) +
                       [element + 'Box' for element in element_heads] +
                       list(color_heads) + list(thickness_heads))


def get_class(name):
    from mathics.builtin.graphics3d import GLOBALS3D

    c = GLOBALS.get(name)
    if c is None:
        return GLOBALS3D.get(name)
    else:
        return c

    # globals() does not work with Cython, otherwise one could use something
    # like return globals().get(name)


def coords(value):
    if value.has_form('List', 2):
        x, y = value.leaves[0].to_number(), value.leaves[1].to_number()
        if x is None or y is None:
            raise CoordinatesError
        return (x, y)
    raise CoordinatesError


class Coords(object):
    def __init__(self, graphics, expr=None, pos=None, d=None):
        self.graphics = graphics
        self.p = pos
        self.d = d
        if expr is not None:
            if expr.has_form('Offset', 1, 2):
                self.d = coords(expr.leaves[0])
                if len(expr.leaves) > 1:
                    self.p = coords(expr.leaves[1])
                else:
                    self.p = None
            else:
                self.p = coords(expr)

    def pos(self):
        p = self.graphics.translate(self.p)
        p = (cut(p[0]), cut(p[1]))
        if self.d is not None:
            d = self.graphics.translate_absolute(self.d)
            return (p[0] + d[0], p[1] + d[1])
        return p

    def add(self, x, y):
        p = (self.p[0] + x, self.p[1] + y)
        return Coords(self.graphics, pos=p, d=self.d)


def cut(value):
    "Cut values in graphics primitives (not displayed otherwise in SVG)"
    border = 10 ** 8
    if value < -border:
        value = -border
    elif value > border:
        value = border
    return value


def create_css(edge_color=None, face_color=None, stroke_width=None,
               font_color=None):
    css = []
    if edge_color is not None:
        color, opacity = edge_color.to_css()
        css.append('stroke: %s' % color)
        css.append('stroke-opacity: %s' % opacity)
    else:
        css.append('stroke: none')
    if stroke_width is not None:
        css.append('stroke-width: %fpx' % stroke_width)
    if face_color is not None:
        color, opacity = face_color.to_css()
        css.append('fill: %s' % color)
        css.append('fill-opacity: %s' % opacity)
    else:
        css.append('fill: none')
    if font_color is not None:
        color, opacity = font_color.to_css()
        css.append('color: %s' % color)
    return '; '.join(css)


def asy_number(value):
    return '%s' % value


def create_pens(edge_color=None, face_color=None, stroke_width=None,
                is_face_element=False):
    result = []
    if face_color is not None:
        brush, opacity = face_color.to_asy()
        if opacity != 1:
            brush += '+opacity(%s)' % asy_number(opacity)
        result.append(brush)
    elif is_face_element:
        result.append('nullpen')
    if edge_color is not None:
        pen, opacity = edge_color.to_asy()
        if opacity != 1:
            pen += '+opacity(%s)' % asy_number(opacity)
        if stroke_width is not None:
            pen += '+linewidth(%s)' % asy_number(stroke_width)
        result.append(pen)
    elif is_face_element:
        result.append('nullpen')
    return ', '.join(result)


class Graphics(Builtin):
    r"""
    <dl>
    <dt>'Graphics[$primitives$, $options$]'
        <dd>represents a graphic.
    </dl>

    >> Graphics[{Blue, Line[{{0,0}, {1,1}}]}]
     = -Graphics-

    'Graphics' supports 'PlotRange':
    >> Graphics[{Rectangle[{1, 1}]}, Axes -> True, PlotRange -> {{-2, 1.5}, {-1, 1.5}}]
     = -Graphics-

    'Graphics' produces 'GraphicsBox' boxes:
    >> Graphics[Rectangle[]] // ToBoxes // Head
     = GraphicsBox

    In 'TeXForm', 'Graphics' produces Asymptote figures:
    >> Graphics[Circle[]] // TeXForm
     = 
     . \begin{asy}
     . size(5.85559796438cm, 5cm);
     . draw(ellipse((175.0,175.0),175.0,175.0), rgb(0, 0, 0)+linewidth(0.666666666667));
     . clip(box((-0.333333333333,0.333333333333), (350.333333333,349.666666667)));
     . \end{asy}

    Invalid graphics directives yield invalid box structures:
    >> Graphics[Circle[{a, b}]]
     : GraphicsBox[CircleBox[List[a, b]], Rule[AspectRatio, Automatic], Rule[Axes, False], Rule[AxesStyle, List[]], Rule[ImageSize, Automatic], Rule[LabelStyle, List[]], Rule[PlotRange, Automatic], Rule[PlotRangePadding, Automatic], Rule[TicksStyle, List[]]] is not a valid box structure.
    """

    options = {
        'Axes': 'False',
        'TicksStyle': '{}',
        'AxesStyle': '{}',
        'LabelStyle': '{}',
        'AspectRatio': 'Automatic',
        'PlotRange': 'Automatic',
        'PlotRangePadding': 'Automatic',
        'ImageSize': 'Automatic',
    }

    box_suffix = 'Box'

    def apply_makeboxes(self, content, evaluation, options):
        '''MakeBoxes[%(name)s[content_, OptionsPattern[%(name)s]],
                StandardForm|TraditionalForm|OutputForm]'''

        def convert(content):
            if content.has_form('List', None):
                return Expression('List',
                                  *[convert(item) for item in content.leaves])
            head = content.get_head_name()
            if head in element_heads:
                if head == 'Text':
                    head = 'Inset'
                atoms = content.get_atoms(include_heads=False)
                if any(not isinstance(atom, (Integer, Real)) and
                       not atom.get_name() in GRAPHICS_SYMBOLS
                       for atom in atoms):
                    if head == 'Inset':
                        n_leaves = [content.leaves[0]] + [
                            Expression('N', leaf).evaluate(evaluation)
                            for leaf in content.leaves[1:]]
                    else:
                        n_leaves = (Expression('N', leaf).evaluate(
                            evaluation) for leaf in content.leaves)
                else:
                    n_leaves = content.leaves
                return Expression(head + self.box_suffix, *n_leaves)
            return content

        for option in options:
            options[option] = Expression(
                'N', options[option]).evaluate(evaluation)
        box_name = 'Graphics' + self.box_suffix
        return Expression(box_name, convert(content),
                          *options_to_rules(options))


class _GraphicsElement(InstancableBuiltin):
    def init(self, graphics, item=None, style=None):
        if item is not None and not item.has_form(self.get_name(), None):
            raise BoxConstructError
        self.graphics = graphics
        self.style = style
        self.is_completely_visible = False  # True for axis elements


class _Color(_GraphicsElement):
    components_sizes = []
    default_components = []

    def init(self, item=None, components=None):
        super(_Color, self).init(None, item)
        if item is not None:
            if len(item.leaves) == 1 and item.leaves[0].has_form('List', None):
                leaves = item.leaves[0].leaves
            else:
                leaves = item.leaves
            if len(leaves) in self.components_sizes:
                try:
                    components = [value.to_number(
                        min=0, max=1) for value in leaves]
                except NumberError:
                    raise ColorError
                if len(components) < len(self.default_components):
                    components.extend(self.default_components[
                                      len(components):])
                self.components = components
            else:
                raise ColorError
        elif components is not None:
            self.components = components

    @staticmethod
    def create(expr):
        head = expr.get_head_name()
        cls = get_class(head)
        if cls is None:
            raise ColorError
        return cls(expr)

    def to_css(self):
        rgba = self.to_rgba()
        return (r'rgb(%f%%, %f%%, %f%%)' % (
            rgba[0] * 100, rgba[1] * 100, rgba[2] * 100), rgba[3])

    def to_asy(self):
        rgba = self.to_rgba()
        return (r'rgb(%s, %s, %s)' % (
            asy_number(rgba[0]), asy_number(rgba[1]), asy_number(rgba[2])),
            rgba[3])

    def to_js(self):
        return self.to_rgba()

    def to_expr(self):
        return Expression(self.get_name(), *self.components)


class RGBColor(_Color):
    components_sizes = [3, 4]
    default_components = [0, 0, 0, 1]

    def to_rgba(self):
        return self.components


class CMYKColor(_Color):
    components_sizes = [3, 4, 5]
    default_components = [0, 0, 0, 0, 1]

    def to_rgba(self):
        k = self.components[3]
        k_ = 1 - k
        c = self.components
        cmy = [c[0] * k_ + k, c[1] * k_ + k, c[2] * k_ + k]
        rgb = (1 - cmy[0], 1 - cmy[1], 1 - cmy[2])
        return rgb + (c[4],)


class Hue(_Color):
    """
    >> Graphics[Table[{EdgeForm[Gray], Hue[h, s], Disk[{12h, 8s}]}, {h, 0, 1, 1/6}, {s, 0, 1, 1/4}]]
     = -Graphics-

    >> Graphics[Table[{EdgeForm[{GrayLevel[0, 0.5]}], Hue[(-11+q+10r)/72, 1, 1, 0.6], Disk[(8-r) {Cos[2Pi q/12], Sin[2Pi q/12]}, (8-r)/3]}, {r, 6}, {q, 12}]]
     = -Graphics-
    """

    components_sizes = [1, 2, 3, 4]
    default_components = [0, 1, 1, 1]

    def to_rgba(self):
        h, s, v = self.components[:3]
        i = floor(6 * h)
        f = 6 * h - i
        i = i % 6
        p = v * (1 - s)
        q = v * (1 - f * s)
        t = v * (1 - (1 - f) * s)

        rgb = {
            0: (v, t, p),
            1: (q, v, p),
            2: (p, v, t),
            3: (p, q, v),
            4: (t, p, v),
            5: (v, p, q),
        }[i]
        return rgb + (self.components[3],)

    def hsl_to_rgba(self):
        h, s, l = self.components[:3]
        if l < 0.5:
            q = l * (1 + s)
        else:
            q = l + s - l * s
        p = 2 * l - q

        rgb = (h + 1 / 3, h, h - 1 / 3)

        def map(value):
            if value < 0:
                value += 1
            if value > 1:
                value -= 1
            return value

        def trans(t):
            if t < 1 / 6:
                return p + ((q - p) * 6 * t)
            elif t < 1 / 2:
                return q
            elif t < 2 / 3:
                return p + ((q - p) * 6 * (2 / 3 - t))
            else:
                return p

        result = tuple([trans(map(t)) for t in rgb]) + (self.components[3],)
        print result
        return result


class GrayLevel(_Color):
    components_sizes = [1, 2]
    default_components = [0, 1]

    def to_rgba(self):
        g = self.components[0]
        return (g, g, g, self.components[1])


class _Thickness(_GraphicsElement):
    def init(self, graphics, item=None, value=None):
        super(_Thickness, self).init(graphics, item)
        if item is not None:
            self.value = item.leaves[0].to_number()
        elif value is not None:
            self.value = value
        else:
            raise BoxConstructError
        if self.value < 0:
            raise BoxConstructError


class AbsoluteThickness(_Thickness):
    def get_thickness(self):
        return self.graphics.translate_absolute((self.value, 0))[0]


class Thickness(_Thickness):
    def get_thickness(self):
        return self.graphics.translate_relative(self.value)


class Thin(Builtin):
    rules = {
        'Thin': 'AbsoluteThickness[0.5]',
    }


class Thick(Builtin):
    rules = {
        'Thick': 'AbsoluteThickness[2]',
    }


class Offset(Builtin):
    pass


class Rectangle(Builtin):
    """
    <dl>
    <dt>'Rectangle[{$xmin$, $ymin$}]'
        <dd>represents a unit square with bottom-left corner at {$xmin$, $ymin$}.
    <dt>'Rectangle[{$xmin$, $ymin$}, {$xmax$, $ymax$}]
        <dd>is a rectange extending from {$xmin$, $ymin$} to {$xmax$, $ymax$}.
    </dl>

    >> Graphics[Rectangle[]]
     = -Graphics-

    >> Graphics[{Blue, Rectangle[{0.5, 0}], Orange, Rectangle[{0, 0.5}]}]
     = -Graphics-
    """

    rules = {
        'Rectangle[]': 'Rectangle[{0, 0}]',
    }


class Disk(Builtin):
    """
    <dl>
    <dt>'Disk[{$cx$, $cy$}, $r$]'
        <dd>fills a circle with center '($cx$, $cy$)' and radius $r$.
    <dt>'Disk[{$cx$, $cy$}, {$rx$, $ry$}]'
        <dd>fills an ellipse.
    <dt>'Disk[{$cx$, $cy$}]'
        <dd>chooses radius 1.
    <dt>'Disk[]'
        <dd>chooses center '(0, 0)' and radius 1.
    </dl>

    >> Graphics[{Blue, Disk[{0, 0}, {2, 1}]}]
     = -Graphics-
    The outer border can be drawn using 'EdgeForm':
    >> Graphics[{EdgeForm[Black], Red, Disk[]}]
     = -Graphics-
    """

    rules = {
        'Disk[]': 'Disk[{0, 0}]',
    }


class Circle(Builtin):
    """
    <dl>
    <dt>'Circle[{$cx$, $cy$}, $r$]'
        <dd>draws a circle with center '($cx$, $cy$)' and radius $r$.
    <dt>'Circle[{$cx$, $cy$}, {$rx$, $ry$}]'
        <dd>draws an ellipse.
    <dt>'Circle[{$cx$, $cy$}]'
        <dd>chooses radius 1.
    <dt>'Circle[]'
        <dd>chooses center '(0, 0)' and radius 1.
    </dl>

    >> Graphics[{Red, Circle[{0, 0}, {2, 1}]}]
     = -Graphics-
    """

    rules = {
        'Circle[]': 'Circle[{0, 0}]',
    }


class Inset(Builtin):
    pass


class Text(Inset):
    """
    #> Graphics[{Text[x, {0,0}]}]
     = -Graphics-
    """


class RectangleBox(_GraphicsElement):
    def init(self, graphics, style, item):
        super(RectangleBox, self).init(graphics, item, style)
        if len(item.leaves) not in (1, 2):
            raise BoxConstructError
        self.edge_color, self.face_color = style.get_style(
            _Color, face_element=True)
        self.p1 = Coords(graphics, item.leaves[0])
        if len(item.leaves) == 1:
            self.p2 = self.p1.add(1, 1)
        elif len(item.leaves) == 2:
            self.p2 = Coords(graphics, item.leaves[1])

    def extent(self):
        l = self.style.get_line_width(face_element=True) / 2
        result = []
        for p in [self.p1, self.p2]:
            x, y = p.pos()
            result.extend([(x - l, y - l), (
                x - l, y + l), (x + l, y - l), (x + l, y + l)])
        return result

    def to_svg(self):
        l = self.style.get_line_width(face_element=True)
        x1, y1 = self.p1.pos()
        x2, y2 = self.p2.pos()
        xmin = min(x1, x2)
        ymin = min(y1, y2)
        w = max(x1, x2) - xmin
        h = max(y1, y2) - ymin
        style = create_css(self.edge_color, self.face_color, l)
        return '<rect x="%f" y="%f" width="%f" height="%f" style="%s" />' % (
            xmin, ymin, w, h, style)

    def to_asy(self):
        l = self.style.get_line_width(face_element=True)
        x1, y1 = self.p1.pos()
        x2, y2 = self.p2.pos()
        pens = create_pens(
            self.edge_color, self.face_color, l, is_face_element=True)
        x1, x2, y1, y2 = asy_number(x1), asy_number(
            x2), asy_number(y1), asy_number(y2)
        return 'filldraw((%s,%s)--(%s,%s)--(%s,%s)--(%s,%s)--cycle, %s);' % (
            x1, y1, x2, y1, x2, y2, x1, y2, pens)


class _RoundBox(_GraphicsElement):
    face_element = None

    def init(self, graphics, style, item):
        super(_RoundBox, self).init(graphics, item, style)
        if len(item.leaves) not in (1, 2):
            raise BoxConstructError
        self.edge_color, self.face_color = style.get_style(
            _Color, face_element=self.face_element)
        self.c = Coords(graphics, item.leaves[0])
        if len(item.leaves) == 1:
            rx = ry = 1
        elif len(item.leaves) == 2:
            r = item.leaves[1]
            if r.has_form('List', 2):
                rx = r.leaves[0].to_number()
                ry = r.leaves[1].to_number()
            else:
                rx = ry = r.to_number()
        self.r = self.c.add(rx, ry)

    def extent(self):
        l = self.style.get_line_width(face_element=self.face_element) / 2
        x, y = self.c.pos()
        rx, ry = self.r.pos()
        rx -= x
        ry = y - ry
        rx += l
        ry += l
        return [(x - rx, y - ry), (x - rx, y + ry),
                (x + rx, y - ry), (x + rx, y + ry)]

    def to_svg(self):
        x, y = self.c.pos()
        rx, ry = self.r.pos()
        rx -= x
        ry = y - ry
        l = self.style.get_line_width(face_element=self.face_element)
        style = create_css(self.edge_color, self.face_color, stroke_width=l)
        return '<ellipse cx="%f" cy="%f" rx="%f" ry="%f" style="%s" />' % (
            x, y, rx, ry, style)

    def to_asy(self):
        x, y = self.c.pos()
        rx, ry = self.r.pos()
        rx -= x
        ry -= y
        l = self.style.get_line_width(face_element=self.face_element)
        pen = create_pens(edge_color=self.edge_color,
                          face_color=self.face_color, stroke_width=l,
                          is_face_element=self.face_element)
        cmd = 'filldraw' if self.face_element else 'draw'
        return '%s(ellipse((%s,%s),%s,%s), %s);' % (
            cmd, asy_number(x), asy_number(y), asy_number(rx), asy_number(ry),
            pen)


class DiskBox(_RoundBox):
    face_element = True


class CircleBox(_RoundBox):
    face_element = False


class _Polyline(_GraphicsElement):
    def do_init(self, graphics, points):
        if not points.has_form('List', None):
            raise BoxConstructError
        if (points.leaves and points.leaves[0].has_form('List', None) and
            all(leaf.has_form('List', None)
                for leaf in points.leaves[0].leaves)):
            leaves = points.leaves
            self.multi_parts = True
        else:
            leaves = [Expression('List', *points.leaves)]
            self.multi_parts = False
        lines = []
        for leaf in leaves:
            if leaf.has_form('List', None):
                lines.append(leaf.leaves)
            else:
                raise BoxConstructError
        self.lines = [[graphics.coords(
            graphics, point) for point in line] for line in lines]

    def extent(self):
        l = self.style.get_line_width(face_element=False)
        result = []
        for line in self.lines:
            for c in line:
                x, y = c.pos()
                result.extend([(x - l, y - l), (
                    x - l, y + l), (x + l, y - l), (x + l, y + l)])
        return result


class Point(Builtin):
    """
    <dl>
    <dt>'Line[{$point_1$, $point_2$ ...}]'
        <dd>represents the point primitive.
    <dt>'Line[{{$p_11$, $p_12$, ...}, {$p_21$, $p_22$, ...}, ...}]'
        <dd>represents a number of point primitives.
    </dl>

    >> Graphics[Point[{0,0}]]
    = -Graphics-

    >> Graphics[Point[Table[{Sin[t], Cos[t]}, {t, 0, 2. Pi, Pi / 15.}]]]
    = -Graphics-

    >> Graphics3D[Point[Table[{Sin[t], Cos[t], 0}, {t, 0, 2. Pi, Pi / 15.}]]]
    = -Graphics3D-
    """
    pass


class PointBox(_Polyline):
    def init(self, graphics, style, item=None):
        super(PointBox, self).init(graphics, item, style)
        self.edge_color, self.face_color = style.get_style(
            _Color, face_element=True)
        if item is not None:
            if len(item.leaves) != 1:
                raise BoxConstructError
            points = item.leaves[0]
            if points.has_form('List', None) and len(points.leaves) != 0:
                if all(not leaf.has_form('List', None)
                       for leaf in points.leaves):
                    points = Expression('List', points)
            self.do_init(graphics, points)
        else:
            raise BoxConstructError

    def to_svg(self):
        l = self.style.get_line_width(face_element=False)
        style = create_css(edge_color=self.edge_color,
                           stroke_width=l, face_color=self.face_color)
        svg = ''
        for line in self.lines:
            for coords in line:
                svg += '<circle cx="%f" cy="%f" r="1" style="%s" />' % (
                    coords.pos()[0], coords.pos()[1], style)
        return svg

    def to_asy(self):
        pen = create_pens(face_color=self.face_color, is_face_element=False)

        asy = ''
        for line in self.lines:
            for coords in line:
                asy += 'dot(%s, %s);' % (coords.pos(), pen)

        return asy


class Line(Builtin):
    """
    <dl>
    <dt>'Line[{$point_1$, $point_2$ ...}]'
        <dd>represents the line primitive.
    <dt>'Line[{{$p_11$, $p_12$, ...}, {$p_21$, $p_22$, ...}, ...}]'
        <dd>represents a number of line primitives.
    </dl>

    >> Graphics[Line[{{0,1},{0,0},{1,0},{1,1}}]]
    = -Graphics-

    >> Graphics3D[Line[{{0,0,0},{0,1,1},{1,0,0}}]]
    = -Graphics3D-
    """
    pass


class LineBox(_Polyline):
    def init(self, graphics, style, item=None, lines=None):
        super(LineBox, self).init(graphics, item, style)
        self.edge_color, _ = style.get_style(_Color, face_element=False)
        if item is not None:
            if len(item.leaves) != 1:
                raise BoxConstructError
            points = item.leaves[0]
            self.do_init(graphics, points)
        elif lines is not None:
            self.lines = lines
        else:
            raise BoxConstructError

    def to_svg(self):
        l = self.style.get_line_width(face_element=False)
        style = create_css(edge_color=self.edge_color, stroke_width=l)
        svg = ''
        for line in self.lines:
            svg += '<polyline points="%s" style="%s" />' % (
                ' '.join(['%f,%f' % coords.pos() for coords in line]), style)
        return svg

    def to_asy(self):
        l = self.style.get_line_width(face_element=False)
        pen = create_pens(edge_color=self.edge_color, stroke_width=l)
        asy = ''
        for line in self.lines:
            path = '--'.join(['(%s,%s)' % coords.pos() for coords in line])
            asy += 'draw(%s, %s);' % (path, pen)
        return asy


class Polygon(Builtin):
    """
    <dl>
    <dt>'Polygon[{$point_1$, $point_2$ ...}]'
        <dd>represents the filled polygon primitive.
    <dt>'Polygon[{{$p_11$, $p_12$, ...}, {$p_21$, $p_22$, ...}, ...}]'
        <dd>represents a number of filled polygon primitives.
    </dl>

    >> Graphics[Polygon[{{1,0},{0,0},{0,1}}]]
    = -Graphics-

    >> Graphics3D[Polygon[{{0,0,0},{0,1,1},{1,0,0}}]]
    = -Graphics3D-
    """
    pass


class PolygonBox(_Polyline):
    def init(self, graphics, style, item=None):
        super(PolygonBox, self).init(graphics, item, style)
        self.edge_color, self.face_color = style.get_style(
            _Color, face_element=True)
        if item is not None:
            if len(item.leaves) not in (1, 2):
                raise BoxConstructError
            points = item.leaves[0]
            self.do_init(graphics, points)
            self.vertex_colors = None
            for leaf in item.leaves[1:]:
                if not leaf.has_form('Rule', 2):
                    raise BoxConstructError
                name = leaf.leaves[0].get_name()
                self.process_option(name, leaf.leaves[1])
        else:
            raise BoxConstructError

    def process_option(self, name, value):
        if name == 'VertexColors':
            if not value.has_form('List', None):
                raise BoxConstructError
            black = RGBColor(components=[0, 0, 0, 1])
            self.vertex_colors = [[black] * len(line) for line in self.lines]
            colors = value.leaves
            if not self.multi_parts:
                colors = [Expression('List', *colors)]
            for line_index, line in enumerate(self.lines):
                if line_index >= len(colors):
                    break
                line_colors = colors[line_index]
                if not line_colors.has_form('List', None):
                    continue
                for index, color in enumerate(line_colors.leaves):
                    if index >= len(self.vertex_colors[line_index]):
                        break
                    try:
                        self.vertex_colors[line_index][
                            index] = _Color.create(color)
                    except ColorError:
                        continue
        else:
            raise BoxConstructError

    def to_svg(self):
        l = self.style.get_line_width(face_element=True)
        if self.vertex_colors is None:
            face_color = self.face_color
        else:
            face_color = None
        style = create_css(
            edge_color=self.edge_color, face_color=face_color, stroke_width=l)
        svg = ''
        if self.vertex_colors is not None:
            mesh = []
            for index, line in enumerate(self.lines):
                data = [[coords.pos(), color.to_js()] for coords, color in zip(
                    line, self.vertex_colors[index])]
                mesh.append(data)
            svg += '<meshgradient data="%s" />' % json.dumps(mesh)
        for line in self.lines:
            svg += '<polygon points="%s" style="%s" />' % (
                ' '.join('%f,%f' % coords.pos() for coords in line), style)
        return svg

    def to_asy(self):
        l = self.style.get_line_width(face_element=True)
        if self.vertex_colors is None:
            face_color = self.face_color
        else:
            face_color = None
        pens = create_pens(edge_color=self.edge_color, face_color=face_color,
                           stroke_width=l, is_face_element=True)
        asy = ''
        if self.vertex_colors is not None:
            paths = []
            colors = []
            edges = []
            for index, line in enumerate(self.lines):
                paths.append('--'.join([
                    '(%s,%s)' % coords.pos() for coords in line]) + '--cycle')

                # ignore opacity
                colors.append(','.join([
                    color.to_asy()[0] for color in self.vertex_colors[index]]))

                edges.append(','.join(['0'] + ['1'] * (
                    len(self.vertex_colors[index]) - 1)))

            asy += 'gouraudshade(%s, new pen[] {%s}, new int[] {%s});' % (
                '^^'.join(paths), ','.join(colors), ','.join(edges))
        if pens and pens != 'nullpen':
            for line in self.lines:
                path = '--'.join(
                    ['(%s,%s)' % coords.pos() for coords in line]) + '--cycle'
                asy += 'filldraw(%s, %s);' % (path, pens)
        return asy


class InsetBox(_GraphicsElement):
    def init(self, graphics, style, item=None, content=None, pos=None,
             opos=(0, 0)):
        super(InsetBox, self).init(graphics, item, style)
        self.color, _ = style.get_style(_Color, face_element=False)
        if item is not None:
            if len(item.leaves) not in (1, 2, 3):
                raise BoxConstructError
            content = item.leaves[0]
            self.content = content.format(
                graphics.evaluation, 'TraditionalForm')
            if len(item.leaves) > 1:
                self.pos = Coords(graphics, item.leaves[1])
            else:
                self.pos = Coords(graphics, pos=(0, 0))
            if len(item.leaves) > 2:
                self.opos = coords(item.leaves[2])
            else:
                self.opos = (0, 0)
        else:
            self.content = content
            self.pos = pos
            self.opos = opos
        self.content_text = self.content.boxes_to_text(
            evaluation=self.graphics.evaluation)

    def extent(self):
        p = self.pos.pos()
        h = 25
        w = len(self.content_text) * \
            7  # rough approximation by numbers of characters
        opos = self.opos
        x = p[0] - w / 2.0 - opos[0] * w / 2.0
        y = p[1] - h / 2.0 + opos[1] * h / 2.0
        return [(x, y), (x + w, y + h)]

    def to_svg(self):
        x, y = self.pos.pos()
        content = self.content.boxes_to_xml(
            evaluation=self.graphics.evaluation)
        style = create_css(font_color=self.color)
        svg = (
            '<foreignObject x="%f" y="%f" ox="%f" oy="%f" style="%s">'
            '<math>%s</math></foreignObject>') % (
                x, y, self.opos[0], self.opos[1], style, content)
        return svg

    def to_asy(self):
        x, y = self.pos.pos()
        content = self.content.boxes_to_tex(
            evaluation=self.graphics.evaluation)
        pen = create_pens(edge_color=self.color)
        asy = 'label("$%s$", (%s,%s), (%s,%s), %s);' % (
            content, x, y, -self.opos[0], -self.opos[1], pen)
        return asy


def total_extent(extents):
    xmin = xmax = ymin = ymax = None
    for extent in extents:
        for x, y in extent:
            if xmin is None or x < xmin:
                xmin = x
            if xmax is None or x > xmax:
                xmax = x
            if ymin is None or y < ymin:
                ymin = y
            if ymax is None or y > ymax:
                ymax = y
    return xmin, xmax, ymin, ymax


class EdgeForm(Builtin):
    pass


class FaceForm(Builtin):
    pass


class Style(object):
    def __init__(self, graphics, edge=False, face=False):
        self.styles = []
        self.graphics = graphics
        self.edge = edge
        self.face = face
        self.klass = graphics.get_style_class()

    def append(self, item, allow_forms=True):
        head = item.get_head_name()
        if head in color_heads:
            style = get_class(head)(item)
        elif head in thickness_heads:
            style = get_class(head)(self.graphics, item)
        elif head in ('EdgeForm', 'FaceForm'):
            style = self.klass(self.graphics, edge=head == 'EdgeForm',
                               face=head == 'FaceForm')
            if len(item.leaves) > 1:
                raise BoxConstructError
            if item.leaves:
                if item.leaves[0].has_form('List', None):
                    for dir in item.leaves[0].leaves:
                        style.append(dir, allow_forms=False)
                else:
                    style.append(item.leaves[0], allow_forms=False)
        else:
            raise BoxConstructError
        self.styles.append(style)

    def extend(self, style, pre=True):
        if pre:
            self.styles = style.styles + self.styles
        else:
            self.styles.extend(style.styles)

    def clone(self):
        result = self.klass(self.graphics, edge=self.edge, face=self.face)
        result.styles = self.styles[:]
        return result

    def get_default_face_color(self):
        return RGBColor(components=(0, 0, 0, 1))

    def get_default_edge_color(self):
        return RGBColor(components=(0, 0, 0, 1))

    def get_style(self, style_class, face_element=None, default_to_faces=True,
                  consider_forms=True):
        if face_element is not None:
            default_to_faces = consider_forms = face_element
        edge_style = face_style = None
        if style_class == _Color:
            if default_to_faces:
                face_style = self.get_default_face_color()
            else:
                edge_style = self.get_default_edge_color()
        elif style_class == _Thickness:
            if not default_to_faces:
                edge_style = AbsoluteThickness(self.graphics, value=0.5)
        for item in self.styles:
            if isinstance(item, style_class):
                if default_to_faces:
                    face_style = item
                else:
                    edge_style = item
            elif isinstance(item, Style):
                if consider_forms:
                    if item.edge:
                        edge_style, _ = item.get_style(
                            style_class, default_to_faces=False,
                            consider_forms=False)
                    elif item.face:
                        _, face_style = item.get_style(
                            style_class, default_to_faces=True,
                            consider_forms=False)

        return edge_style, face_style

    def get_line_width(self, face_element=True):
        if self.graphics.pixel_width is None:
            return 0
        edge_style, _ = self.get_style(
            _Thickness, default_to_faces=face_element,
            consider_forms=face_element)
        if edge_style is None:
            return 0
        return edge_style.get_thickness()


class _GraphicsElements(object):
    def __init__(self, content, evaluation):
        self.evaluation = evaluation
        self.elements = []

        def convert(content, style):
            if content.has_form('List', None):
                items = content.leaves
            else:
                items = [content]
            style = style.clone()
            for item in items:
                if item.get_name() == 'Null':
                    continue
                head = item.get_head_name()
                if (head in color_heads or head in thickness_heads or   # noqa
                    head in ('EdgeForm', 'FaceForm')):
                    style.append(item)
                elif head[-3:] == 'Box':  # and head[:-3] in element_heads:
                    element_class = get_class(head)
                    if element_class is not None:
                        element = get_class(head)(self, style, item)
                        self.elements.append(element)
                    else:
                        raise BoxConstructError
                elif head == 'List':
                    convert(item, style)
                else:
                    raise BoxConstructError

        convert(content, self.get_style_class()(self))

    def create_style(self, expr):
        style = self.get_style_class()(self)

        def convert(expr):
            if expr.has_form(('List', 'Directive'), None):
                for item in expr.leaves:
                    convert(item)
            else:
                style.append(expr)

        convert(expr)
        return style

    def get_style_class(self):
        return Style


class GraphicsElements(_GraphicsElements):
    coords = Coords

    def __init__(self, content, evaluation, neg_y=False):
        super(GraphicsElements, self).__init__(content, evaluation)
        self.neg_y = neg_y
        self.xmin = self.ymin = self.pixel_width = None
        self.pixel_height = self.extent_width = self.extent_height = None

    def translate(self, coords):
        if self.pixel_width is not None:
            w = self.extent_width if self.extent_width > 0 else 1
            h = self.extent_height if self.extent_height > 0 else 1
            result = [(coords[0] - self.xmin) * self.pixel_width / w,
                      (coords[1] - self.ymin) * self.pixel_height / h]
            if self.neg_y:
                result[1] = self.pixel_height - result[1]
            return tuple(result)
        else:
            return (coords[0], coords[1])

    def translate_absolute(self, d):
        if self.pixel_width is None:
            return (0, 0)
        else:
            l = 96.0 / 72
            return (d[0] * l, (-1 if self.neg_y else 1) * d[1] * l)

    def translate_relative(self, x):
        if self.pixel_width is None:
            return 0
        else:
            return x * self.pixel_width

    def extent(self, completely_visible_only=False):
        if completely_visible_only:
            ext = total_extent([element.extent() for element in self.elements
                                if element.is_completely_visible])
        else:
            ext = total_extent([element.extent() for element in self.elements])
        xmin, xmax, ymin, ymax = ext
        if xmin == xmax:
            xmin = 0
            xmax *= 2
        if ymin == ymax:
            ymin = 0
            ymax *= 2
        return xmin, xmax, ymin, ymax

    def to_svg(self):
        return '\n'.join(element.to_svg() for element in self.elements)

    def to_asy(self):
        return '\n'.join(element.to_asy() for element in self.elements)

    def set_size(self, xmin, ymin, extent_width, extent_height, pixel_width,
                 pixel_height):

        self.xmin, self.ymin = xmin, ymin
        self.extent_width, self.extent_height = extent_width, extent_height
        self.pixel_width, self.pixel_height = pixel_width, pixel_height


class GraphicsBox(BoxConstruct):
    options = Graphics.options

    attributes = ('HoldAll', 'ReadProtected')

    def boxes_to_text(self, leaves, **options):
        self._prepare_elements(leaves, options)  # to test for Box errors
        return '-Graphics-'

    def _get_image_size(self, options, graphics_options, max_width):
        inside_row = options.pop('inside_row', False)
        inside_list = options.pop('inside_list', False)
        image_size_multipliers = options.pop('image_size_multipliers', None)

        aspect_ratio = graphics_options['AspectRatio']

        if image_size_multipliers is None:
            image_size_multipliers = (0.5, 0.25)

        if aspect_ratio == Symbol('Automatic'):
            aspect = None
        else:
            try:
                aspect = aspect_ratio.to_number()
            except NumberError:
                # TODO: Custom message - MMA uses a tooltip over red graphics
                aspect = None

        image_size = graphics_options['ImageSize']
        image_size = image_size.get_name()
        base_width, base_height = {
            'Automatic': (400, 350),
            'Tiny': (100, 100),
            'Small': (200, 200),
            'Medium': (400, 350),
            'Large': (600, 500),
        }.get(image_size, (None, None))
        if base_width is None:
            raise BoxConstructError
        if max_width is not None and base_width > max_width:
            base_width = max_width

        if inside_row:
            multi = image_size_multipliers[1]
        elif inside_list:
            multi = image_size_multipliers[0]
        else:
            multi = 1

        return base_width, base_height, multi, aspect

    def _prepare_elements(self, leaves, options, neg_y=False, max_width=None):
        if not leaves:
            raise BoxConstructError

        graphics_options = self.get_option_values(leaves[1:], **options)

        base_width, base_height, size_multiplier, size_aspect = \
            self._get_image_size(options, graphics_options, max_width)

        plot_range = graphics_options['PlotRange'].to_python()
        if plot_range == 'Automatic':
            plot_range = ['Automatic', 'Automatic']
        if not isinstance(plot_range, list) or len(plot_range) != 2:
            raise BoxConstructError

        try:
            elements = GraphicsElements(leaves[
                                        0], options['evaluation'], neg_y)
        except NumberError:
            raise BoxConstructError

        def calc_dimensions(final_pass=True):
            """
            calc_dimensions gets called twice: In the first run
            (final_pass = False, called inside _prepare_elements), the extent
            of all user-defined graphics is determined.
            Axes are created accordingly.
            In the second run (final_pass = True, called from outside),
            the dimensions of these axes are taken into account as well.
            This is also important to size absolutely sized objects correctly
            (e.g. values using AbsoluteThickness).
            """

            if 'Automatic' in plot_range:
                xmin, xmax, ymin, ymax = elements.extent()
            else:
                xmin = xmax = ymin = ymax = None
            if final_pass and plot_range != ['Automatic', 'Automatic']:
                # Take into account the dimensiosn of axes and axes labels
                # (they should be displayed completely even when a specific
                # PlotRange is given).
                exmin, exmax, eymin, eymax = elements.extent(
                    completely_visible_only=True)
            else:
                exmin = exmax = eymin = eymax = None

            def get_range(min, max):
                if max < min:
                    min, max = max, min
                elif min == max:
                    if min < 0:
                        min, max = 2 * min, 0
                    elif min > 0:
                        min, max = 0, 2 * min
                    else:
                        min, max = -1, 1
                return min, max

            try:
                if plot_range[0] == 'Automatic':
                    if xmin is None and xmax is None:
                        xmin = 0
                        xmax = 1
                    elif xmin == xmax:
                        xmin -= 1
                        xmax += 1
                elif (isinstance(plot_range[0], list) and
                      len(plot_range[0]) == 2):
                    xmin, xmax = map(float, plot_range[0])
                    xmin, xmax = get_range(xmin, xmax)
                    xmin = elements.translate((xmin, 0))[0]
                    xmax = elements.translate((xmax, 0))[0]
                    if exmin is not None and exmin < xmin:
                        xmin = exmin
                    if exmax is not None and exmax > xmax:
                        xmax = exmax
                else:
                    raise BoxConstructError

                if plot_range[1] == 'Automatic':
                    if ymin is None and ymax is None:
                        ymin = 0
                        ymax = 1
                    elif ymin == ymax:
                        ymin -= 1
                        ymax += 1
                elif (isinstance(plot_range[1], list) and
                      len(plot_range[1]) == 2):
                    ymin, ymax = map(float, plot_range[1])
                    ymin, ymax = get_range(ymin, ymax)
                    ymin = elements.translate((0, ymin))[1]
                    ymax = elements.translate((0, ymax))[1]
                    if eymin is not None and eymin < ymin:
                        ymin = eymin
                    if eymax is not None and eymax > ymax:
                        ymax = eymax
                else:
                    raise BoxConstructError
            except (ValueError, TypeError):
                raise BoxConstructError

            w = xmax - xmin
            h = ymax - ymin

            if size_aspect is None:
                aspect = h / w
            else:
                aspect = size_aspect

            height = base_height
            width = height / aspect
            if width > base_width:
                width = base_width
                height = width * aspect
            height = height

            width *= size_multiplier
            height *= size_multiplier

            return xmin, xmax, ymin, ymax, w, h, width, height

        xmin, xmax, ymin, ymax, w, h, width, height = calc_dimensions(
            final_pass=False)

        elements.set_size(xmin, ymin, w, h, width, height)

        xmin -= w * 0.02
        xmax += w * 0.02
        ymin -= h * 0.02
        ymax += h * 0.02

        self.create_axes(elements, graphics_options, xmin, xmax, ymin, ymax)

        return elements, calc_dimensions

    def boxes_to_tex(self, leaves, **options):
        elements, calc_dimensions = self._prepare_elements(
            leaves, options, max_width=450)

        asy_completely_visible = '\n'.join(
            element.to_asy() for element in elements.elements
            if element.is_completely_visible)

        asy_regular = '\n'.join(
            element.to_asy() for element in elements.elements
            if not element.is_completely_visible)

        xmin, xmax, ymin, ymax, w, h, width, height = calc_dimensions()

        tex = r"""
\begin{asy}
size(%scm, %scm);
%s
clip(box((%s,%s), (%s,%s)));
%s
\end{asy}
""" % (asy_number(width / 60), asy_number(height / 60),
       asy_regular,
       asy_number(xmin), asy_number(ymin), asy_number(xmax), asy_number(ymax),
       asy_completely_visible)

        return tex

    def boxes_to_xml(self, leaves, **options):
        elements, calc_dimensions = self._prepare_elements(
            leaves, options, neg_y=True)

        svg = elements.to_svg()

        xmin, xmax, ymin, ymax, w, h, width, height = calc_dimensions()

        xmin -= 1
        ymin -= 1
        w += 2
        h += 2

        xml = (
            '<svg xmlns:svg="http://www.w3.org/2000/svg" '
            'xmlns="http://www.w3.org/2000/svg"\nversion="1.0" width="%f" '
            'height="%f" viewBox="%f %f %f %f">%s</svg>') % (
                width, height, xmin, ymin, w, h, svg)

        xml = """<mtable><mtr><mtd>%s</mtd></mtr></mtable>""" % xml
        return xml

    def axis_ticks(self, xmin, xmax):
        def round_to_zero(value):
            if value == 0:
                return 0
            elif value < 0:
                return ceil(value)
            else:
                return floor(value)

        def round_step(value):
            if not value:
                return 1, 1
            sub_steps = 5
            try:
                shift = 10.0 ** floor(log10(value))
            except ValueError:
                print value
                return 1, 1
            value = value / shift
            if value < 1.5:
                value = 1
            elif value < 3:
                value = 2
                sub_steps = 4
            elif value < 8:
                value = 5
            else:
                value = 10
            return value * shift, sub_steps

        step_x, sub_x = round_step((xmax - xmin) / 5.0)
        step_x_small = 1.0 * step_x / sub_x
        steps_x = int(floor((xmax - xmin) / step_x))
        steps_x_small = int(floor((xmax - xmin) / step_x_small))

        start_k_x = int(ceil(xmin / step_x))
        start_k_x_small = int(ceil(xmin / step_x_small))

        #start_x = step_x * round_to_zero((xmax - xmin) / step_x)
        #start_x_small = step_x_small * \
        #    round_to_zero((xmax - xmin) / step_x_small)

        zero_tolerance = 0.01
        if xmax > min:
            if xmin > 0 and xmin / (xmax - xmin) < zero_tolerance:
                xmin = 0
            if xmax < 0 and xmax / (xmax - xmin) < zero_tolerance:
                xmax = 0
        if xmin <= 0 <= xmax:
            origin_k_x = 0
        else:
            origin_k_x = start_k_x
        origin_x = origin_k_x * step_x

        ticks = []
        ticks_small = []
        for k in range(start_k_x, start_k_x + steps_x + 1):
            if k != origin_k_x:
                x = k * step_x
                if x > xmax:
                    break
                ticks.append(x)
        for k in range(start_k_x_small, start_k_x_small + steps_x_small + 1):
            if k % sub_x != 0:
                x = k * step_x_small
                if x > xmax:
                    break
                ticks_small.append(x)

        return ticks, ticks_small, origin_x

    def create_axes(self, elements, graphics_options, xmin, xmax, ymin, ymax):
        axes = graphics_options.get('Axes')
        if axes.is_true():
            axes = (True, True)
        elif axes.has_form('List', 2):
            axes = (axes.leaves[0].is_true(), axes.leaves[1].is_true())
        else:
            axes = (False, False)
        ticks_style = graphics_options.get('TicksStyle')
        axes_style = graphics_options.get('AxesStyle')
        label_style = graphics_options.get('LabelStyle')
        if ticks_style.has_form('List', 2):
            ticks_style = ticks_style.leaves
        else:
            ticks_style = [ticks_style] * 2
        if axes_style.has_form('List', 2):
            axes_style = axes_style.leaves
        else:
            axes_style = [axes_style] * 2

        ticks_style = [elements.create_style(s) for s in ticks_style]
        axes_style = [elements.create_style(s) for s in axes_style]
        label_style = elements.create_style(label_style)
        ticks_style[0].extend(axes_style[0])
        ticks_style[1].extend(axes_style[1])

        def add_element(element):
            element.is_completely_visible = True
            elements.elements.append(element)

        ticks_x, ticks_x_small, origin_x = self.axis_ticks(xmin, xmax)
        ticks_y, ticks_y_small, origin_y = self.axis_ticks(ymin, ymax)

        axes_extra = 6
        tick_small_size = 3
        tick_large_size = 5
        tick_label_d = 2

        for index, (
            min, max, p_self0, p_other0, p_origin,
            ticks, ticks_small) in enumerate([
                (xmin, xmax, lambda y: (0, y), lambda x: (x, 0),
                 lambda x: (x, origin_y), ticks_x, ticks_x_small),
                (ymin, ymax, lambda x: (x, 0), lambda y: (0, y),
                 lambda y: (origin_x, y), ticks_y, ticks_y_small)]):
            if axes[index]:
                add_element(LineBox(
                    elements, axes_style[index],
                    lines=[[Coords(elements, pos=p_origin(min),
                                   d=p_other0(-axes_extra)),
                            Coords(elements, pos=p_origin(max),
                                   d=p_other0(axes_extra))]]))
                ticks_lines = []
                tick_label_style = ticks_style[index].clone()
                tick_label_style.extend(label_style)
                for x in ticks:
                    ticks_lines.append([Coords(elements, pos=p_origin(x)),
                                        Coords(elements, pos=p_origin(x),
                                               d=p_self0(tick_large_size))])
                    add_element(InsetBox(
                        elements, tick_label_style, content=Real(x),
                        pos=Coords(elements, pos=p_origin(x),
                                   d=p_self0(-tick_label_d)), opos=p_self0(1)))
                for x in ticks_small:
                    pos = p_origin(x)
                    ticks_lines.append([Coords(elements, pos=pos),
                                        Coords(elements, pos=pos,
                                               d=p_self0(tick_small_size))])
                add_element(LineBox(elements, axes_style[0],
                                    lines=ticks_lines))

        """if axes[1]:
            add_element(LineBox(elements, axes_style[1], lines=[[Coords(elements, pos=(origin_x,ymin), d=(0,-axes_extra)),
                Coords(elements, pos=(origin_x,ymax), d=(0,axes_extra))]]))
            ticks = []
            tick_label_style = ticks_style[1].clone()
            tick_label_style.extend(label_style)
            for k in range(start_k_y, start_k_y+steps_y+1):
                if k != origin_k_y:
                    y = k * step_y
                    if y > ymax:
                        break
                    pos = (origin_x,y)
                    ticks.append([Coords(elements, pos=pos),
                        Coords(elements, pos=pos, d=(tick_large_size,0))])
                    add_element(InsetBox(elements, tick_label_style, content=Real(y), pos=Coords(elements, pos=pos,
                        d=(-tick_label_d,0)), opos=(1,0)))
            for k in range(start_k_y_small, start_k_y_small+steps_y_small+1):
                if k % sub_y != 0:
                    y = k * step_y_small
                    if y > ymax:
                        break
                    pos = (origin_x,y)
                    ticks.append([Coords(elements, pos=pos),
                        Coords(elements, pos=pos, d=(tick_small_size,0))])
            add_element(LineBox(elements, axes_style[1], lines=ticks))"""


class Directive(Builtin):
    attributes = ('ReadProtected',)


class Blend(Builtin):
    """
    >> Blend[{Red, Blue}]
     = RGBColor[0.5, 0., 0.5, 1.]
    >> Blend[{Red, Blue}, 0.3]
     = RGBColor[0.7, 0., 0.3, 1.]
    >> Blend[{Red, Blue, Green}, 0.75]
     = RGBColor[0., 0.5, 0.5, 1.]

    >> Graphics[Table[{Blend[{Red, Green, Blue}, x], Rectangle[{10 x, 0}]}, {x, 0, 1, 1/10}]]
     = -Graphics-

    >> Graphics[Table[{Blend[{RGBColor[1, 0.5, 0, 0.5], RGBColor[0, 0, 1, 0.5]}, x], Disk[{5x, 0}]}, {x, 0, 1, 1/10}]]
     = -Graphics-

    #> Blend[{Red, Green, Blue}, {1, 0.5}]
     : {1, 0.5} should be a real number or a list of non-negative numbers, which has the same length as {RGBColor[1, 0, 0], RGBColor[0, 1, 0], RGBColor[0, 0, 1]}.
     = Blend[{RGBColor[1, 0, 0], RGBColor[0, 1, 0], RGBColor[0, 0, 1]}, {1, 0.5}]
    """

    messages = {
        'arg': ("`1` is not a valid list of color or gray-level directives, "
                "or pairs of a real number and a directive."),
        'argl': ("`1` should be a real number or a list of non-negative "
                 "numbers, which has the same length as `2`."),
    }

    rules = {
        'Blend[colors_]': 'Blend[colors, ConstantArray[1, Length[colors]]]',
    }

    def do_blend(self, colors, values):
        type = None
        homogenous = True
        for color in colors:
            if type is None:
                type = color.__class__
            else:
                if color.__class__ != type:
                    homogenous = False
                    break
        if not homogenous:
            colors = [RGBColor(components=color.to_rgba()) for color in colors]
            type = RGBColor
        total = sum(values)
        result = None
        for color, value in zip(colors, values):
            frac = value / total
            part = [component * frac for component in color.components]
            if result is None:
                result = part
            else:
                result = [r + p for r, p in zip(result, part)]
        return type(components=result)

    def apply(self, colors, u, evaluation):
        'Blend[{colors___}, u_]'

        colors_orig = colors
        try:
            colors = [_Color.create(color) for color in colors.get_sequence()]
            if not colors:
                raise ColorError
        except ColorError:
            evaluation.message('Blend', 'arg', Expression('List', colors_orig))
            return
        try:
            if u.has_form('List', None):
                values = [value.to_number() for value in u.leaves]
                if len(u.leaves) != len(colors):
                    raise NumberError(None)  # pseudo NumberError caught below
                use_list = True
            else:
                values = u.to_number(min=0, max=1)
                use_list = False
        except NumberError:
            evaluation.message('Blend', 'argl', u, Expression(
                'List', colors_orig))
            return

        if use_list:
            return self.do_blend(colors, values).to_expr()
        else:
            x = values
            pos = int(floor(x * (len(colors) - 1)))
            x = (x - pos * 1.0 / (len(colors) - 1)) * (len(colors) - 1)
            if pos == len(colors) - 1:
                return colors[-1].to_expr()
            else:
                return self.do_blend(
                    colors[pos:(pos + 2)], [1 - x, x]).to_expr()


class Lighter(Builtin):
    """
    <dl>
    <dt>'Lighter[$c$, $f$]'
        <dd>is equivalent to 'Blend[{$c$, White}, $f$]'.
    <dt>'Lighter[$c$]'
        <dd>is equivalent to 'Lighter[$c$, 1/3]'.
    </dl>

    >> Lighter[Orange, 1/4]
     = RGBColor[1., 0.625, 0.25, 1.]
    >> Graphics[{Lighter[Orange, 1/4], Disk[]}]
     = -Graphics-
    >> Graphics[Table[{Lighter[Orange, x], Disk[{12x, 0}]}, {x, 0, 1, 1/6}]]
     = -Graphics-
    """

    rules = {
        'Lighter[c_, f_]': 'Blend[{c, White}, f]',
        'Lighter[c_]': 'Lighter[c, 1/3]',
    }


class Darker(Builtin):
    """
    <dl>
    <dt>'Darker[$c$, $f$]'
        <dd>is equivalent to 'Blend[{$c$, Black}, $f$]'.
    <dt>'Darker[$c$]'
        <dd>is equivalent to 'Darker[$c$, 1/3]'.
    </dl>

    >> Graphics[Table[{Darker[Yellow, x], Disk[{12x, 0}]}, {x, 0, 1, 1/6}]]
     = -Graphics-
    """

    rules = {
        'Darker[c_, f_]': 'Blend[{c, Black}, f]',
        'Darker[c_]': 'Darker[c, 1/3]',
    }


class _ColorObject(Builtin):
    text_name = None

    def __init__(self, *args, **kwargs):
        super(_ColorObject, self).__init__(*args, **kwargs)

        if self.text_name is None:
            text_name = self.get_name().lower()
        else:
            text_name = self.text_name
        doc = """
            <dl>
            <dt>'%(name)s'
            <dd>represents the color %(text_name)s in graphics.
            </dl>

            >> Graphics[{%(name)s, Disk[]}, ImageSize->Small]
             = -Graphics-
        """ % {'name': self.get_name(), 'text_name': text_name}
        if self.__doc__ is None:
            self.__doc__ = doc
        else:
            self.__doc__ = doc + self.__doc__


class Black(_ColorObject):
    """
    >> Black
     = GrayLevel[0]
    """

    rules = {
        'Black': 'GrayLevel[0]',
    }


class White(_ColorObject):
    """
    >> White
     = GrayLevel[1]
    """

    rules = {
        'White': 'GrayLevel[1]',
    }


class Gray(_ColorObject):
    """
    >> Gray
     = GrayLevel[0.5]
    """

    rules = {
        'Gray': 'GrayLevel[0.5]',
    }


class Red(_ColorObject):
    """
    >> Red
     = RGBColor[1, 0, 0]
    """

    rules = {
        'Red': 'RGBColor[1, 0, 0]',
    }


class Green(_ColorObject):
    """
    >> Green
     = RGBColor[0, 1, 0]
    """

    rules = {
        'Green': 'RGBColor[0, 1, 0]',
    }


class Blue(_ColorObject):
    """
    >> Blue
     = RGBColor[0, 0, 1]
    """

    rules = {
        'Blue': 'RGBColor[0, 0, 1]',
    }


class Cyan(_ColorObject):
    """
    >> Cyan
     = RGBColor[0, 1, 1]
    """

    rules = {
        'Cyan': 'RGBColor[0, 1, 1]',
    }


class Magenta(_ColorObject):
    """
    >> Magenta
     = RGBColor[1, 0, 1]
    """

    rules = {
        'Magenta': 'RGBColor[1, 0, 1]',
    }


class Yellow(_ColorObject):
    """
    >> Yellow
     = RGBColor[1, 1, 0]
    """

    rules = {
        'Yellow': 'RGBColor[1, 1, 0]',
    }


class Purple(_ColorObject):
    rules = {
        'Purple': 'RGBColor[0.5, 0, 0.5]',
    }


class LightRed(_ColorObject):
    text_name = 'light red'

    rules = {
        'LightRed': 'Lighter[Red, 0.85]',
    }


class Orange(_ColorObject):
    rules = {
        'Orange': 'RGBColor[1, 0.5, 0]',
    }

GLOBALS = {
    'Rectangle': Rectangle,
    'Disk': Disk,
    'Circle': Circle,
    'Polygon': Polygon,
    'Inset': Inset,
    'Text': Text,
    'RectangleBox': RectangleBox,
    'DiskBox': DiskBox,
    'LineBox': LineBox,
    'CircleBox': CircleBox,
    'PolygonBox': PolygonBox,
    'PointBox': PointBox,
    'InsetBox': InsetBox,

    'RGBColor': RGBColor,
    'CMYKColor': CMYKColor,
    'Hue': Hue,
    'GrayLevel': GrayLevel,

    'Thickness': Thickness,
    'AbsoluteThickness': AbsoluteThickness,
    'Thick': Thick,
    'Thin': Thin,
}

########NEW FILE########
__FILENAME__ = graphics3d
# -*- coding: utf8 -*-

"""
Graphics (3D)
"""

import numbers
from mathics.core.expression import Expression, NumberError, from_python
from mathics.builtin.base import BoxConstructError, Builtin, InstancableBuiltin
from graphics import (Graphics, GraphicsBox, PolygonBox, create_pens, _Color,
                      LineBox, PointBox, Style, RGBColor, get_class,
                      asy_number, CoordinatesError, _GraphicsElements)

import json

from django.utils.html import escape as escape_html


def coords3D(value):
    if value.has_form('List', 3):
        return (value.leaves[0].to_number(),
                value.leaves[1].to_number(),
                value.leaves[2].to_number())
    raise CoordinatesError


class Coords3D(object):
    def __init__(self, graphics, expr=None, pos=None, d=None):
        self.graphics = graphics
        self.p = pos
        self.d = d
        if expr is not None:
            if expr.has_form('Offset', 1, 2):
                self.d = coords3D(expr.leaves[0])
                if len(expr.leaves) > 1:
                    self.p = coords3D(expr.leaves[1])
                else:
                    self.p = None
            else:
                self.p = coords3D(expr)

    def pos(self):
        return self.p, self.d

    def add(self, x, y, z):
        p = (self.p[0] + x, self.p[1] + y, self.p[2] + z)
        return Coords3D(self.graphics, pos=p, d=self.d)

    def scale(self, a):
        self.p = (self.p[0] * a[0], self.p[1] * a[1], self.p[2] * a[2])


class Style3D(Style):
    def get_default_face_color(self):
        return RGBColor(components=(1, 1, 1, 1))


class Graphics3D(Graphics):
    r"""
    <dl>
    <dt>'Graphics3D[$primitives$, $options$]'
        <dd>represents a three-dimensional graphic.
    </dl>

    >> Graphics3D[Polygon[{{0,0,0}, {0,1,1}, {1,0,0}}]]
     = -Graphics3D-

    In 'TeXForm', 'Graphics3D' creates Asymptote figures:
    >> Graphics3D[Sphere[]] // TeXForm
     = 
     . \begin{asy}
     . import three;
     . import solids;
     . size(6cm, 6cm);
     . currentprojection=perspective(2.6,-4.8,4.0);
     . currentlight=light(rgb(0.5,0.5,1), specular=red, (2,0,2), (2,2,2), (0,2,2));
     . draw(surface(sphere((0, 0, 0), 1)), rgb(1,1,1));
     . draw(((-1.0,-1.0,-1.0)--(1.0,-1.0,-1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-1.0,1.0,-1.0)--(1.0,1.0,-1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-1.0,-1.0,1.0)--(1.0,-1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-1.0,1.0,1.0)--(1.0,1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-1.0,-1.0,-1.0)--(-1.0,1.0,-1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((1.0,-1.0,-1.0)--(1.0,1.0,-1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-1.0,-1.0,1.0)--(-1.0,1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((1.0,-1.0,1.0)--(1.0,1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-1.0,-1.0,-1.0)--(-1.0,-1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((1.0,-1.0,-1.0)--(1.0,-1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-1.0,1.0,-1.0)--(-1.0,1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((1.0,1.0,-1.0)--(1.0,1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . \end{asy}

    #> Graphics3D[Point[Table[{Sin[t], Cos[t], 0}, {t, 0, 2. Pi, Pi / 15.}]]] // TeXForm
     = 
     . \begin{asy}
     . import three;
     . import solids;
     . size(6cm, 6cm);
     . currentprojection=perspective(2.6,-4.8,4.0);
     . currentlight=light(rgb(0.5,0.5,1), specular=red, (2,0,2), (2,2,2), (0,2,2));
     . path3 g=(0.0,1.0,0.0)--(0.207911690818,0.978147600734,0.0)--(0.406736643076,0.913545457643,0.0)--(0.587785252292,0.809016994375,0.0)--(0.743144825477,0.669130606359,0.0)--(0.866025403784,0.5,0.0)--(0.951056516295,0.309016994375,0.0)--(0.994521895368,0.104528463268,0.0)--(0.994521895368,-0.104528463268,0.0)--(0.951056516295,-0.309016994375,0.0)--(0.866025403784,-0.5,0.0)--(0.743144825477,-0.669130606359,0.0)--(0.587785252292,-0.809016994375,0.0)--(0.406736643076,-0.913545457643,0.0)--(0.207911690818,-0.978147600734,0.0)--(-1.56804861761e-18,-1.0,0.0)--(-0.207911690818,-0.978147600734,0.0)--(-0.406736643076,-0.913545457643,0.0)--(-0.587785252292,-0.809016994375,0.0)--(-0.743144825477,-0.669130606359,0.0)--(-0.866025403784,-0.5,0.0)--(-0.951056516295,-0.309016994375,0.0)--(-0.994521895368,-0.104528463268,0.0)--(-0.994521895368,0.104528463268,0.0)--(-0.951056516295,0.309016994375,0.0)--(-0.866025403784,0.5,0.0)--(-0.743144825477,0.669130606359,0.0)--(-0.587785252292,0.809016994375,0.0)--(-0.406736643076,0.913545457643,0.0)--(-0.207911690818,0.978147600734,0.0)--(1.26770763531e-17,1.0,0.0)--cycle;dot(g, rgb(0, 0, 0));
     . draw(((-0.994521895368,-1.0,-1.0)--(0.994521895368,-1.0,-1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-0.994521895368,1.0,-1.0)--(0.994521895368,1.0,-1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-0.994521895368,-1.0,1.0)--(0.994521895368,-1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-0.994521895368,1.0,1.0)--(0.994521895368,1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-0.994521895368,-1.0,-1.0)--(-0.994521895368,1.0,-1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((0.994521895368,-1.0,-1.0)--(0.994521895368,1.0,-1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-0.994521895368,-1.0,1.0)--(-0.994521895368,1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((0.994521895368,-1.0,1.0)--(0.994521895368,1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-0.994521895368,-1.0,-1.0)--(-0.994521895368,-1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((0.994521895368,-1.0,-1.0)--(0.994521895368,-1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((-0.994521895368,1.0,-1.0)--(-0.994521895368,1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . draw(((0.994521895368,1.0,-1.0)--(0.994521895368,1.0,1.0)), rgb(0.4, 0.4, 0.4)+linewidth(1));
     . \end{asy}
    """

    options = Graphics.options.copy()
    options.update({
        'BoxRatios': 'Automatic',
        'Lighting': 'Automatic',
        'ViewPoint': '{1.3,-2.4,2}',
    })

    box_suffix = '3DBox'

    rules = {
        'MakeBoxes[Graphics3D[content_, OptionsPattern[Graphics3D]], '
        '        OutputForm]': '"-Graphics3D-"',
    }

    messages = {
        'invlight': "`1` is not a valid list of light sources.",
    }


class Graphics3DBox(GraphicsBox):
    def boxes_to_text(self, leaves, **options):
        return '-Graphics3D-'

    def _prepare_elements(self, leaves, options, max_width=None):
        if not leaves:
            raise BoxConstructError

        graphics_options = self.get_option_values(leaves[1:], **options)

        evaluation = options['evaluation']

        base_width, base_height, size_multiplier, size_aspect = \
            self._get_image_size(options, graphics_options, max_width)

        # TODO: Handle ImageScaled[], and Scaled[]
        lighting_option = graphics_options['Lighting']
        lighting = lighting_option.to_python()
        self.lighting = []

        if lighting == 'Automatic':
            self.lighting = [
                {"type": "Ambient", "color": [0.3, 0.2, 0.4]},
                {"type": "Directional", "color": [0.8, 0., 0.],
                 "position": [2, 0, 2]},
                {"type": "Directional", "color": [0., 0.8, 0.],
                 "position": [2, 2, 2]},
                {"type": "Directional", "color": [0., 0., 0.8],
                 "position": [0, 2, 2]}
            ]
        elif lighting == 'Neutral':
            self.lighting = [
                {"type": "Ambient", "color": [0.3, 0.3, 0.3]},
                {"type": "Directional", "color": [0.3, 0.3, 0.3],
                 "position": [2, 0, 2]},
                {"type": "Directional", "color": [0.3, 0.3, 0.3],
                 "position": [2, 2, 2]},
                {"type": "Directional", "color": [0.3, 0.3, 0.3],
                 "position": [0, 2, 2]}
            ]
        elif lighting == 'None':
            pass

        elif (isinstance(lighting, list) and
              all(isinstance(light, list) for light in lighting)):
            for light in lighting:
                if light[0] in ['"Ambient"', '"Directional"', '"Point"',
                                '"Spot"']:
                    try:
                        head = light[1].get_head_name()
                    except AttributeError:
                        break
                    color = get_class(head)(light[1])
                    if light[0] == '"Ambient"':
                        self.lighting.append({
                            "type": "Ambient",
                            "color": color.to_rgba(), 
                        })
                    elif light[0] == '"Directional"':
                        position = [0, 0, 0]
                        if isinstance(light[2], list):
                            if len(light[2]) == 3:
                                position = light[2]
                            if len(light[2]) == 2 and all(  # noqa
                                isinstance(p, list) and len(p) == 3
                                for p in light[2]):
                                position = [light[2][0][i] - light[2][1][i]
                                            for i in range(3)]
                        self.lighting.append({
                            "type": "Directional",
                            "color": color.to_rgba(),
                            "position": position
                        })
                    elif light[0] == '"Point"':
                        position = [0, 0, 0]
                        if isinstance(light[2], list) and len(light[2]) == 3:
                            position = light[2]
                        self.lighting.append({
                            "type": "Point",
                            "color": color.to_rgba(),
                            "position": position
                        })
                    elif light[0] == '"Spot"':
                        position = [0, 0, 1]
                        target = [0, 0, 0]
                        if isinstance(light[2], list):
                            if len(light[2]) == 2:
                                if (isinstance(light[2][0], list) and   # noqa
                                    len(light[2][0]) == 3):
                                    position = light[2][0]
                                if (isinstance(light[2][1], list) and   # noqa
                                    len(light[2][1]) == 3):
                                    target = light[2][1]
                            if len(light[2]) == 3:
                                position = light[2]
                        angle = light[3]
                        self.lighting.append({
                            "type": "Spot",
                            "color": color.to_rgba(),
                            "position": position,
                            "target": target,
                            "angle": angle
                        })

        else:
            evaluation.message("Graphics3D", 'invlight', lighting_option)

        # ViewPoint Option
        viewpoint_option = graphics_options['ViewPoint']
        viewpoint = viewpoint_option.to_python(n_evaluation=evaluation)

        if isinstance(viewpoint, list) and len(viewpoint) == 3:
            if all(isinstance(x, numbers.Real) for x in viewpoint):
                # TODO Infinite coordinates e.g. {0, 0, Infinity}
                pass
        else:
            try:
                viewpoint = {
                    'Above': [0, 0, 2],
                    'Below': [0, 0, -2],
                    'Front': [0, -2, 0],
                    'Back': [0, 2, 0],
                    'Left': [-2, 0, 0],
                    'Right': [2, 0, 0]
                }[viewpoint]
            except KeyError:
                # evaluation.message()
                # TODO
                viewpoint = [1.3, -2.4, 2]

        assert(isinstance(viewpoint, list) and len(viewpoint) == 3 and all(
            isinstance(x, numbers.Real) for x in viewpoint))
        self.viewpoint = viewpoint

        # TODO Aspect Ratio
        # aspect_ratio = graphics_options['AspectRatio'].to_python()

        boxratios = graphics_options['BoxRatios'].to_python()
        if boxratios == 'Automatic':
            boxratios = ['Automatic', 'Automatic', 'Automatic']
        else:
            boxratios = boxratios
        if not isinstance(boxratios, list) or len(boxratios) != 3:
            raise BoxConstructError

        plot_range = graphics_options['PlotRange'].to_python()
        if plot_range == 'Automatic':
            plot_range = ['Automatic', 'Automatic', 'Automatic']
        if not isinstance(plot_range, list) or len(plot_range) != 3:
            raise BoxConstructError

        try:
            elements = Graphics3DElements(leaves[0], evaluation)
        except NumberError:
            raise BoxConstructError

        def calc_dimensions(final_pass=True):
            if 'Automatic' in plot_range:
                xmin, xmax, ymin, ymax, zmin, zmax = elements.extent()
            else:
                xmin = xmax = ymin = ymax = zmin = zmax = None

            try:
                if plot_range[0] == 'Automatic':
                    if xmin is None and xmax is None:
                        xmin = 0
                        xmax = 1
                    elif xmin == xmax:
                        xmin -= 1
                        xmax += 1
                elif (isinstance(plot_range[0], list) and
                      len(plot_range[0]) == 2):
                    xmin, xmax = map(float, plot_range[0])
                    xmin = elements.translate((xmin, 0, 0))[0]
                    xmax = elements.translate((xmax, 0, 0))[0]
                else:
                    raise BoxConstructError

                if plot_range[1] == 'Automatic':
                    if ymin is None and ymax is None:
                        ymin = 0
                        ymax = 1
                    elif ymin == ymax:
                        ymin -= 1
                        ymax += 1
                elif (isinstance(plot_range[1], list) and
                      len(plot_range[1]) == 2):
                    ymin, ymax = map(float, plot_range[1])
                    ymin = elements.translate((0, ymin, 0))[1]
                    ymax = elements.translate((0, ymax, 0))[1]
                else:
                    raise BoxConstructError

                if plot_range[2] == 'Automatic':
                    if zmin is None and zmax is None:
                        zmin = 0
                        zmax = 1
                    elif zmin == zmax:
                        zmin -= 1
                        zmax += 1
                elif (isinstance(plot_range[1], list) and
                      len(plot_range[1]) == 2):
                    zmin, zmax = map(float, plot_range[2])
                    zmin = elements.translate((0, 0, zmin))[2]
                    zmax = elements.translate((0, 0, zmax))[2]
                else:
                    raise BoxConstructError
            except (ValueError, TypeError):
                raise BoxConstructError

            boxscale = [1., 1., 1.]
            if boxratios[0] != 'Automatic':
                boxscale[0] = boxratios[0] / (xmax - xmin)
            if boxratios[1] != 'Automatic':
                boxscale[1] = boxratios[1] / (ymax - ymin)
            if boxratios[2] != 'Automatic':
                boxscale[2] = boxratios[2] / (zmax - zmin)

            if final_pass:
                xmin *= boxscale[0]
                xmax *= boxscale[0]
                ymin *= boxscale[1]
                ymax *= boxscale[1]
                zmin *= boxscale[2]
                zmax *= boxscale[2]

                # Rescale lighting
                for i, light in enumerate(self.lighting):
                    if self.lighting[i]["type"] != "Ambient":
                        self.lighting[i]["position"] = (
                            [light["position"][j] * boxscale[j]
                             for j in range(3)])
                    if self.lighting[i]["type"] == "Spot":
                        self.lighting[i]["target"] = (
                            [light["target"][j] * boxscale[j]
                             for j in range(3)])

                # Rescale viewpoint
                self.viewpoint = [
                    vp * max([xmax - xmin, ymax - ymin, zmax - zmin])
                    for vp in self.viewpoint]

            return xmin, xmax, ymin, ymax, zmin, zmax, boxscale

        xmin, xmax, ymin, ymax, zmin, zmax, boxscale = \
            calc_dimensions(final_pass=False)

        axes, ticks = self.create_axes(
            elements, graphics_options,
            xmin, xmax, ymin, ymax, zmin, zmax, boxscale)

        return elements, axes, ticks, calc_dimensions, boxscale

    def boxes_to_tex(self, leaves, **options):
        elements, axes, ticks, calc_dimensions, boxscale = \
            self._prepare_elements(leaves, options, max_width=450)

        elements._apply_boxscaling(boxscale)

        asy = elements.to_asy()

        xmin, xmax, ymin, ymax, zmin, zmax, boxscale = calc_dimensions()

        # TODO: Intelligently place the axes on the longest non-middle edge.
        # See algorithm used by web graphics in mathics/web/media/graphics.js
        # for details of this. (Projection to sceen etc).

        # Choose axes placement (boundbox edge vertices)
        axes_indices = []
        if axes[0]:
            axes_indices.append(0)
        if axes[1]:
            axes_indices.append(6)
        if axes[2]:
            axes_indices.append(8)

        # Draw boundbox and axes
        boundbox_asy = ''
        boundbox_lines = self.get_boundbox_lines(
            xmin, xmax, ymin, ymax, zmin, zmax)

        for i, line in enumerate(boundbox_lines):
            if i in axes_indices:
                pen = create_pens(edge_color=RGBColor(
                    components=(0, 0, 0, 1)), stroke_width=1.5)
            else:
                pen = create_pens(edge_color=RGBColor(
                    components=(0.4, 0.4, 0.4, 1)), stroke_width=1)

            path = '--'.join(['(%s,%s,%s)' % coords for coords in line])
            boundbox_asy += 'draw((%s), %s);\n' % (path, pen)

        # TODO: Intelligently draw the axis ticks such that they are always
        # directed inward and choose the coordinate direction which makes the
        # ticks the longest. Again, details in mathics/web/media/graphics.js

        # Draw axes ticks
        ticklength = 0.05 * max([xmax - xmin, ymax - ymin, zmax - zmin])
        pen = create_pens(edge_color=RGBColor(
            components=(0, 0, 0, 1)), stroke_width=1.2)
        for xi in axes_indices:
            if xi < 4:          # x axis
                for i, tick in enumerate(ticks[0][0]):
                    line = [
                        (tick, boundbox_lines[xi][0][1],
                         boundbox_lines[xi][0][2]),
                        (tick, boundbox_lines[xi][0][1],
                         boundbox_lines[xi][0][2] + ticklength)]

                    path = '--'.join(
                        ['({0},{1},{2})'.format(*coords) for coords in line])

                    boundbox_asy += 'draw(({0}), {1});\n'.format(path, pen)
                    boundbox_asy += 'label("{0}",{1},{2});\n'.format(
                        ticks[0][2][i], (tick, boundbox_lines[xi][0][1],
                                         boundbox_lines[xi][0][2]),
                        'S')

                for small_tick in ticks[0][1]:
                    line = [
                        (small_tick, boundbox_lines[xi][0][1],
                         boundbox_lines[xi][0][2]),
                        (small_tick, boundbox_lines[xi][0][1],
                         boundbox_lines[xi][0][2] + 0.5 * ticklength)]

                    path = '--'.join(
                        ['({0},{1},{2})'.format(*coords) for coords in line])

                    boundbox_asy += 'draw(({0}), {1});\n'.format(path, pen)

            if 4 <= xi < 8:     # y axis
                for i, tick in enumerate(ticks[1][0]):
                    line = [
                        (boundbox_lines[xi][0][0], tick,
                         boundbox_lines[xi][0][2]),
                        (boundbox_lines[xi][0][0], tick,
                         boundbox_lines[xi][0][2] - ticklength)]
                    path = '--'.join(
                        ['({0},{1},{2})'.format(*coords) for coords in line])

                    boundbox_asy += 'draw(({0}), {1});\n'.format(path, pen)

                    boundbox_asy += 'label("{0}",{1},{2});\n'.format(
                        ticks[1][2][i], (boundbox_lines[xi][0][0], tick,
                                         boundbox_lines[xi][0][2]),
                        'NW')

                for small_tick in ticks[1][1]:
                    line = [
                        (boundbox_lines[xi][0][0], small_tick,
                         boundbox_lines[xi][0][2]),
                        (boundbox_lines[xi][0][0], small_tick,
                         boundbox_lines[xi][0][2] - 0.5 * ticklength)]
                    path = '--'.join(
                        ['({0},{1},{2})'.format(*coords) for coords in line])
                    boundbox_asy += 'draw(({0}), {1});\n'.format(path, pen)
            if 8 <= xi:         # z axis
                for i, tick in enumerate(ticks[2][0]):
                    line = [
                        (boundbox_lines[xi][0][0], boundbox_lines[xi][0][1],
                         tick),
                        (boundbox_lines[xi][0][0],
                         boundbox_lines[xi][0][1] + ticklength, tick)]
                    path = '--'.join(
                        ['({0},{1},{2})'.format(*coords) for coords in line])
                    boundbox_asy += 'draw(({0}), {1});\n'.format(path, pen)
                    boundbox_asy += 'label("{0}",{1},{2});\n'.format(
                        ticks[2][2][i],
                        (boundbox_lines[xi][0][0], boundbox_lines[xi][0][1],
                         tick),
                        'W')
                for small_tick in ticks[2][1]:
                    line = [
                        (boundbox_lines[xi][0][0],
                         boundbox_lines[xi][0][1],
                         small_tick),
                        (boundbox_lines[xi][0][0],
                         boundbox_lines[xi][0][1] + 0.5 * ticklength,
                         small_tick)
                    ]
                    path = '--'.join(
                        ['({0},{1},{2})'.format(*coords) for coords in line])
                    boundbox_asy += 'draw(({0}), {1});\n'.format(path, pen)

        (height, width) = (400, 400)  # TODO: Proper size
        tex = r"""
\begin{{asy}}
import three;
import solids;
size({0}cm, {1}cm);
currentprojection=perspective({2[0]},{2[1]},{2[2]});
currentlight=light(rgb(0.5,0.5,1), specular=red, (2,0,2), (2,2,2), (0,2,2));
{3}
{4}
\end{{asy}}
""".format(asy_number(width / 60), asy_number(height / 60), self.viewpoint,
           asy, boundbox_asy)
        return tex

    def boxes_to_xml(self, leaves, **options):
        elements, axes, ticks, calc_dimensions, boxscale = \
            self._prepare_elements(leaves, options)

        elements._apply_boxscaling(boxscale)

        json_repr = elements.to_json()

        xmin, xmax, ymin, ymax, zmin, zmax, boxscale = calc_dimensions()

        # TODO: Cubeoid (like this)
        # json_repr = [{'faceColor': (1, 1, 1, 1), 'position': [(0,0,0), None],
        # 'size':[(1,1,1), None], 'type': 'cube'}]

        json_repr = json.dumps({
            'elements': json_repr,
            'axes': {
                'hasaxes': axes,
                'ticks': ticks,
            },
            'extent': {
                'xmin': xmin,
                'xmax': xmax,
                'ymin': ymin,
                'ymax': ymax,
                'zmin': zmin,
                'zmax': zmax,
            },
            'lighting': self.lighting,
            'viewpoint': self.viewpoint,
        })

        # return "<mn>3</mn>"

        # xml = ('<graphics3d xmin="%f" xmax="%f" ymin="%f" ymax="%f" '
        #        'zmin="%f" zmax="%f" data="%s" />') % (
        #           xmin, xmax, ymin, ymax, zmin, zmax, json_repr)
        xml = '<graphics3d data="{0}" />'.format(escape_html(json_repr))
        xml = '<mtable><mtr><mtd>{0}</mtd></mtr></mtable>'.format(xml)
        return xml

    def create_axes(self, elements, graphics_options,
                    xmin, xmax, ymin, ymax, zmin, zmax, boxscale):
        axes = graphics_options.get('Axes')
        if axes.is_true():
            axes = (True, True, True)
        elif axes.has_form('List', 3):
            axes = (leaf.is_true() for leaf in axes.leaves)
        else:
            axes = (False, False, False)
        ticks_style = graphics_options.get('TicksStyle')
        axes_style = graphics_options.get('AxesStyle')
        label_style = graphics_options.get('LabelStyle')
        if ticks_style.has_form('List', 3):
            ticks_style = ticks_style.leaves
        else:
            ticks_style = [ticks_style] * 3
        if axes_style.has_form('List', 3):
            axes_style = axes_style.leaves
        else:
            axes_style = [axes_style] * 3

        ticks_style = [elements.create_style(s) for s in ticks_style]
        axes_style = [elements.create_style(s) for s in axes_style]
        label_style = elements.create_style(label_style)
        ticks_style[0].extend(axes_style[0])
        ticks_style[1].extend(axes_style[1])

        ticks = [self.axis_ticks(xmin, xmax),
                 self.axis_ticks(ymin, ymax),
                 self.axis_ticks(zmin, zmax)]

        # Add zero if required, since axis_ticks does not
        if xmin <= 0 <= xmax:
            ticks[0][0].append(0.0)
            ticks[0][0].sort()
        if ymin <= 0 <= ymax:
            ticks[1][0].append(0.0)
            ticks[1][0].sort()
        if zmin <= 0 <= zmax:
            ticks[2][0].append(0.0)
            ticks[2][0].sort()

        # Convert ticks to nice strings e.g 0.100000000000002 -> '0.1' and
        # scale ticks appropriately
        ticks = [[map(lambda x: boxscale[i] * x, t[0]),
                  map(lambda x: boxscale[i] * x, t[1]),
                  map(str, t[0])] for i, t in enumerate(ticks)]

        return axes, ticks

    def get_boundbox_lines(self, xmin, xmax, ymin, ymax, zmin, zmax):
        return [
            [(xmin, ymin, zmin), (xmax, ymin, zmin)],
            [(xmin, ymax, zmin), (xmax, ymax, zmin)],
            [(xmin, ymin, zmax), (xmax, ymin, zmax)],
            [(xmin, ymax, zmax), (xmax, ymax, zmax)],
            [(xmin, ymin, zmin), (xmin, ymax, zmin)],
            [(xmax, ymin, zmin), (xmax, ymax, zmin)],
            [(xmin, ymin, zmax), (xmin, ymax, zmax)],
            [(xmax, ymin, zmax), (xmax, ymax, zmax)],
            [(xmin, ymin, zmin), (xmin, ymin, zmax)],
            [(xmax, ymin, zmin), (xmax, ymin, zmax)],
            [(xmin, ymax, zmin), (xmin, ymax, zmax)],
            [(xmax, ymax, zmin), (xmax, ymax, zmax)]]


def total_extent_3d(extents):
    xmin = xmax = ymin = ymax = zmin = zmax = None
    for extent in extents:
        for x, y, z in extent:
            if xmin is None or x < xmin:
                xmin = x
            if xmax is None or x > xmax:
                xmax = x
            if ymin is None or y < ymin:
                ymin = y
            if ymax is None or y > ymax:
                ymax = y
            if zmin is None or z < zmin:
                zmin = z
            if zmax is None or z > zmax:
                zmax = z
    return xmin, xmax, ymin, ymax, zmin, zmax


class Graphics3DElements(_GraphicsElements):
    coords = Coords3D

    def __init__(self, content, evaluation, neg_y=False):
        super(Graphics3DElements, self).__init__(content, evaluation)
        self.neg_y = neg_y
        self.xmin = self.ymin = self.pixel_width = self.pixel_height = \
            self.extent_width = self.extent_height = None

    def extent(self, completely_visible_only=False):
        return total_extent_3d([element.extent() for element in self.elements])

    def to_svg(self):
        return '\n'.join(element.to_svg() for element in self.elements)

    def to_asy(self):
        return '\n'.join([element.to_asy() for element in self.elements])

    def _apply_boxscaling(self, boxscale):
        for element in self.elements:
            element._apply_boxscaling(boxscale)

    def to_json(self):
        result = []
        for element in self.elements:
            result.extend(element.to_json())
        return result

    def get_style_class(self):
        return Style3D


class Point3DBox(PointBox):
    def init(self, *args, **kwargs):
        super(Point3DBox, self).init(*args, **kwargs)

    def process_option(self, name, value):
        super(Point3DBox, self).process_option(name, value)

    def to_json(self):
        # TODO: account for point size
        data = []

        # Tempoary bug fix: default Point color should be black not white
        face_color = self.face_color
        if list(face_color.to_rgba()[:3]) == [1, 1, 1]:
            face_color = RGBColor(
                components=(0, 0, 0, face_color.to_rgba()[3]))

        for line in self.lines:
            data.append({
                'type': 'point',
                'coords': [coords.pos() for coords in line],
                'color': face_color.to_rgba(),
            })
        return data

    def to_asy(self):
        face_color = self.face_color

        # Tempoary bug fix: default Point color should be black not white
        if list(face_color.to_rgba()[:3]) == [1, 1, 1]:
            face_color = RGBColor(
                components=(0, 0, 0, face_color.to_rgba()[3]))

        pen = create_pens(face_color=face_color, is_face_element=False)

        return ''.join('path3 g={0}--cycle;dot(g, {1});'.format(
            '--'.join('({0},{1},{2})'.format(*coords.pos()[0])
                      for coords in line), pen) for line in self.lines)

    def extent(self):
        result = []
        for line in self.lines:
            for c in line:
                p, d = c.pos()
                result.append(p)
        return result

    def _apply_boxscaling(self, boxscale):
        for line in self.lines:
            for coords in line:
                coords.scale(boxscale)


class Line3DBox(LineBox):
    def init(self, *args, **kwargs):
        super(Line3DBox, self).init(*args, **kwargs)

    def process_option(self, name, value):
        super(Line3DBox, self).process_option(name, value)

    def to_json(self):
        # TODO: account for line widths and style
        data = []
        for line in self.lines:
            data.append({
                'type': 'line',
                'coords': [coords.pos() for coords in line],
                'color': self.edge_color.to_rgba(),
            })
        return data

    def to_asy(self):
        # l = self.style.get_line_width(face_element=False)
        pen = create_pens(edge_color=self.edge_color, stroke_width=1)

        return ''.join('draw({0}, {1});'.format(
            '--'.join('({0},{1},{2})'.format(*coords.pos()[0])
                      for coords in line), pen) for line in self.lines)

    def extent(self):
        result = []
        for line in self.lines:
            for c in line:
                p, d = c.pos()
                result.append(p)
        return result

    def _apply_boxscaling(self, boxscale):
        for line in self.lines:
            for coords in line:
                coords.scale(boxscale)


class Polygon3DBox(PolygonBox):
    def init(self, *args, **kwargs):
        self.vertex_normals = None
        super(Polygon3DBox, self).init(*args, **kwargs)

    def process_option(self, name, value):
        if name == 'VertexNormals':
            # TODO: process VertexNormals and use them in rendering
            pass
        else:
            super(Polygon3DBox, self).process_option(name, value)

    def to_json(self):
        # TODO: account for line widths and style
        if self.vertex_colors is None:
            face_color = self.face_color
        else:
            face_color = None

        if face_color is not None:
            face_color = face_color.to_js()

        data = []
        for line in self.lines:
            data.append({
                'type': 'polygon',
                'coords': [coords.pos() for coords in line],
                'faceColor': face_color,
            })
        return data

    def to_asy(self):
        l = self.style.get_line_width(face_element=True)
        if self.vertex_colors is None:
            face_color = self.face_color
        else:
            face_color = None
        pen = create_pens(edge_color=self.edge_color, face_color=face_color,
                          stroke_width=l, is_face_element=True)

        asy = ''
        for line in self.lines:
            asy += 'path3 g=' + '--'.join(['(%s,%s,%s)' % coords.pos()[0]
                                           for coords in line]) + '--cycle;'
            asy += 'draw(surface(g), %s);' % (pen)
        return asy

    def extent(self):
        result = []
        for line in self.lines:
            for c in line:
                p, d = c.pos()
                result.append(p)
        return result

    def _apply_boxscaling(self, boxscale):
        for line in self.lines:
            for coords in line:
                coords.scale(boxscale)


class Sphere(Builtin):
    """
    <dl>
    <dt>'Sphere[{$x$, $y$, $z$}]'
        <dd>is a sphere of radius $1$ centerd at the point {$x$, $y$, $z$}.
    <dt>'Sphere[{$x$, $y$, $z$}, $r$]'
        <dd>is a sphere of radius $r$ centered at the point $x$, $y$, $z$.
    <dt>'Sphere[{{$x1$, $y1$, $z1$}, {$x2$, $y2$, $z2$}, ... }, $r$]'
        <dd>is a collection spheres of radius $r$ centered at the points {$x1$, $y2$, $z2$}, {$x2$, $y2$, $z2$}, ...
    </dl>

    >> Graphics3D[Sphere[{0, 0, 0}, 1]]
     = -Graphics3D-

    >> Graphics3D[{Yellow, Sphere[{{-1, 0, 0}, {1, 0, 0}, {0, 0, Sqrt[3.]}}, 1]}]
     = -Graphics3D-
    """

    rules = {
        'Sphere[]': 'Sphere[{0, 0, 0}, 1]',
        'Sphere[positions_]': 'Sphere[positions, 1]'
    }


class Cuboid(Builtin):
    """
    <dl>
    <dt>'Cuboid[{$xmin$, $ymin$, $zmin$}]'
        <dd>is a unit cube.
    <dt>'Cuboid[{$xmin$, $ymin$, $zmin$}, {$xmax$, $ymax$, $zmax$}]'
        <dd>represents a cuboid extending from {$xmin$, $ymin$, $zmin$} to {$xmax$, $ymax$, $zmax$}.
    </dl>

    >> Graphics3D[Cuboid[{0, 0, 1}]]
     = -Graphics3D-

    >> Graphics3D[{Red, Cuboid[{0, 0, 0}, {1, 1, 0.5}], Blue, Cuboid[{0.25, 0.25, 0.5}, {0.75, 0.75, 1}]}]
     = -Graphics3D-
    """

    rules = {
        'Cuboid[]': 'Cuboid[{0,0,0}]',
    }

    def apply_full(self, xmin, ymin, zmin, xmax, ymax, zmax, evaluation):
        'Cuboid[{xmin_, ymin_, zmin_}, {xmax_, ymax_, zmax_}]'

        try:
            xmin, ymin, zmin = [value.to_number(n_evaluation=evaluation)
                                for value in (xmin, ymin, zmin)]
            xmax, ymax, zmax = [value.to_number(n_evaluation=evaluation)
                                for value in (xmax, ymax, zmax)]
        except NumberError:
            # TODO
            return

        if (xmax <= xmin) or (ymax <= ymin) or (zmax <= zmin):
            # TODO
            return

        polygons = [
            # X
            Expression('List',
                       Expression('List', xmin, ymin, zmin),
                       Expression('List', xmin, ymax, zmin),
                       Expression('List', xmin, ymax, zmax)),
            Expression('List',
                       Expression('List', xmin, ymin, zmin),
                       Expression('List', xmin, ymin, zmax),
                       Expression('List', xmin, ymax, zmax)),
            Expression('List',
                       Expression('List', xmax, ymin, zmin),
                       Expression('List', xmax, ymax, zmin),
                       Expression('List', xmax, ymax, zmax)),
            Expression('List',
                       Expression('List', xmax, ymin, zmin),
                       Expression('List', xmax, ymin, zmax),
                       Expression('List', xmax, ymax, zmax)),
            # Y
            Expression('List',
                       Expression('List', xmin, ymin, zmin),
                       Expression('List', xmax, ymin, zmin),
                       Expression('List', xmax, ymin, zmax)),
            Expression('List',
                       Expression('List', xmin, ymin, zmin),
                       Expression('List', xmin, ymin, zmax),
                       Expression('List', xmax, ymin, zmax)),
            Expression('List',
                       Expression('List', xmin, ymax, zmin),
                       Expression('List', xmax, ymax, zmin),
                       Expression('List', xmax, ymax, zmax)),
            Expression('List',
                       Expression('List', xmin, ymax, zmin),
                       Expression('List', xmin, ymax, zmax),
                       Expression('List', xmax, ymax, zmax)),
            # Z
            Expression('List',
                       Expression('List', xmin, ymin, zmin),
                       Expression('List', xmin, ymax, zmin),
                       Expression('List', xmax, ymax, zmin)),
            Expression('List',
                       Expression('List', xmin, ymin, zmin),
                       Expression('List', xmax, ymin, zmin),
                       Expression('List', xmax, ymax, zmin)),
            Expression('List',
                       Expression('List', xmin, ymin, zmax),
                       Expression('List', xmin, ymax, zmax),
                       Expression('List', xmax, ymax, zmax)),
            Expression('List',
                       Expression('List', xmin, ymin, zmax),
                       Expression('List', xmax, ymin, zmax),
                       Expression('List', xmax, ymax, zmax)),
        ]

        return Expression('Polygon', Expression('List', *polygons))

    def apply_min(self, xmin, ymin, zmin, evaluation):
        'Cuboid[{xmin_, ymin_, zmin_}]'
        try:
            xmin, ymin, zmin = [value.to_number(
                n_evaluation=evaluation) for value in (xmin, ymin, zmin)]
        except NumberError:
            # TODO
            return
        (xmax, ymax, zmax) = (from_python(value + 1)
                              for value in (xmin, ymin, zmin))
        (xmin, ymin, zmin) = (from_python(value)
                              for value in (xmin, ymin, zmin))

        return self.apply_full(xmin, ymin, zmin, xmax, ymax, zmax, evaluation)


class _Graphics3DElement(InstancableBuiltin):
    def init(self, graphics, item=None, style=None):
        if item is not None and not item.has_form(self.get_name(), None):
            raise BoxConstructError
        self.graphics = graphics
        self.style = style
        self.is_completely_visible = False  # True for axis elements


class Sphere3DBox(_Graphics3DElement):
    def init(self, graphics, style, item):
        super(Sphere3DBox, self).init(graphics, item, style)
        self.edge_color, self.face_color = style.get_style(
            _Color, face_element=True)
        if len(item.leaves) != 2:
            raise BoxConstructError

        points = item.leaves[0].to_python()
        if not all(isinstance(point, list) for point in points):
            points = [points]
        if not all(len(point) == 3 and all(isinstance(p, numbers.Real)
                   for p in point) for point in points):
            raise BoxConstructError

        self.points = [Coords3D(graphics, pos=point) for point in points]
        self.radius = item.leaves[1].to_python()

    def to_asy(self):
        #l = self.style.get_line_width(face_element=True)

        if self.face_color is None:
            face_color = (1, 1, 1)
        else:
            face_color = self.face_color.to_js()

        return ''.join(
            'draw(surface(sphere({0}, {1})), rgb({2},{3},{4}));'.format(
                tuple(coord.pos()[0],), self.radius, *face_color[:3])
            for coord in self.points)

    def to_json(self):
        face_color = self.face_color
        if face_color is not None:
            face_color = face_color.to_js()
        return [{
            'type': 'sphere',
            'coords': [coords.pos() for coords in self.points],
            'radius': self.radius,
            'faceColor': face_color,
        }]

    def extent(self):
        result = []
        result.extend([
            coords.add(self.radius, self.radius, self.radius).pos()[0]
            for coords in self.points])
        result.extend([
            coords.add(-self.radius, -self.radius, -self.radius).pos()[0]
            for coords in self.points])
        return result

    def _apply_boxscaling(self, boxscale):
        # TODO
        pass

GLOBALS3D = {
    'Polygon3DBox': Polygon3DBox,
    'Line3DBox': Line3DBox,
    'Point3DBox': Point3DBox,
    'Sphere3DBox': Sphere3DBox,
}

########NEW FILE########
__FILENAME__ = importexport
# -*- coding: utf8 -*-

"""
Importing and Exporting
"""

from mathics.core.expression import Expression, from_python
from mathics.builtin.base import Builtin, Predefined, Symbol, String

from pymimesniffer import magic
import mimetypes


mimetypes.add_type('application/vnd.wolfram.mathematica.package', '.m')

# Seems that JSON is not registered on the mathics.net server, so we do it manually here.
# Keep in mind that mimetypes has system-dependent aspects (it inspects "/etc/mime.types" and other files).
mimetypes.add_type('application/json', '.json')

IMPORTERS = {}
EXPORTERS = {}


class ImportFormats(Predefined):
    """
    <dl>
    <dt>'$ImportFormats'
        <dd>returns a list of file formats supported by Import.
    </dl>

    >> $ImportFormats
     = {CSV, JSON, Text}
    """

    name = '$ImportFormats'

    def evaluate(self, evaluation):
        return from_python(sorted(IMPORTERS.keys()))


class ExportFormats(Predefined):
    """
    <dl>
    <dt>'$ExportFormats'
        <dd>returns a list of file formats supported by Export.
    </dl>

    >> $ExportFormats
     = {CSV, Text}
    """

    name = '$ExportFormats'

    def evaluate(self, evaluation):
        return from_python(sorted(EXPORTERS.keys()))


# FIXME This should be private, ImportExport`RegisterImport
class RegisterImport(Builtin):
    """
    <dl>
    <dt>'RegisterImport["$format$", $defaultFunction$]'
      <dd>register '$defaultFunction$' as the default function used when importing from a file of type '"$format$"'.
    <dt>'RegisterImport["$format$", {"$elem1$" :> $conditionalFunction1$, "$elem2$" :> $conditionalFunction2$, ..., $defaultFunction$}]'
      <dd>registers multiple elements ($elem1$, ...) and their corresponding converter functions ($conditionalFunction1$, ...) in addition to the $defaultFunction$.
    <dt>'RegisterImport["$format$", {"$conditionalFunctions$, $defaultFunction$, "$elem3$" :> $postFunction3$, "$elem4$" :> $postFunction4$, ...}]'
      <dd>also registers additional elements ($elem3$, ...) whose converters ($postFunction3$, ...) act on output from the low-level funcions.
    </dl>

    First, define the default function used to import the data.
    >> ExampleFormat1Import[filename_String] := Module[{stream, head, data}, stream = OpenRead[filename]; head = ReadList[stream, String, 2]; data = Partition[ReadList[stream, Number], 2]; Close[stream]; {"Header" -> head, "Data" -> data}]

    'RegisterImport' is then used to register the above function to a new data format.
    >> RegisterImport["ExampleFormat1", ExampleFormat1Import]

    >> FilePrint["ExampleData/ExampleData.txt"]
     | Example File Format
     | Created by Angus
     | 0.629452	0.586355
     | 0.711009	0.687453
     | 0.246540	0.433973
     | 0.926871	0.887255
     | 0.825141	0.940900
     | 0.847035	0.127464
     | 0.054348	0.296494
     | 0.838545	0.247025
     | 0.838697	0.436220
     | 0.309496	0.833591

    >> Import["ExampleData/ExampleData.txt", {"ExampleFormat1", "Elements"}]
     = {Data, Header}

    >> Import["ExampleData/ExampleData.txt", {"ExampleFormat1", "Header"}]
     = {Example File Format, Created by Angus}

    Conditional Importer:
    >> ExampleFormat2DefaultImport[filename_String] := Module[{stream, head}, stream = OpenRead[filename]; head = ReadList[stream, String, 2]; Close[stream]; {"Header" -> head}]

    >> ExampleFormat2DataImport[filename_String] := Module[{stream, data}, stream = OpenRead[filename]; Skip[stream, String, 2]; data = Partition[ReadList[stream, Number], 2]; Close[stream]; {"Data" -> data}]

    >> RegisterImport["ExampleFormat2", {"Data" :> ExampleFormat2DataImport, ExampleFormat2DefaultImport}]

    >> Import["ExampleData/ExampleData.txt", {"ExampleFormat2", "Elements"}]
     = {Data, Header}

    >> Import["ExampleData/ExampleData.txt", {"ExampleFormat2", "Header"}]
     = {Example File Format, Created by Angus}

    >> Import["ExampleData/ExampleData.txt", {"ExampleFormat2", "Data"}] // Grid
     = 0.629452   0.586355
     .
     . 0.711009   0.687453
     .
     . 0.24654    0.433973
     .
     . 0.926871   0.887255
     .
     . 0.825141   0.9409
     .
     . 0.847035   0.127464
     .
     . 0.054348   0.296494
     .
     . 0.838545   0.247025
     .
     . 0.838697   0.43622
     .
     . 0.309496   0.833591

    """

    attributes = ('Protected', 'ReadProtected')

    # XXX OptionsIssue
    options = {
        'Path': 'Automatic',
        'FunctionChannels': '{"FileNames"}',
        'Sources': 'None',
        'DefaultElement': 'Automatic',
        'AvailableElements': 'None',
        'Options': '{}',
        'OriginalChannel': 'False',
        'BinaryFormat': 'False',
        'Encoding': 'False',
        'Extensions': '{}',
        'AlphaChannel': 'False',
    }

    rules = {
        'RegisterImport[formatname_String, function_]':
        'RegisterImport[formatname, function, {}]',
    }

    def apply(self, formatname, function, posts, evaluation, options):
        '''RegisterImport[formatname_String, function_, posts_,
               OptionsPattern[RegisterImport]]'''

        if function.has_form('List', None):
            leaves = function.get_leaves()
        else:
            leaves = [function]

        if not (len(leaves) >= 1 and isinstance(leaves[-1], Symbol) and
                all(x.has_form('RuleDelayed', None) for x in leaves[:-1])):
            # TODO: Message
            return Symbol('$Failed')

        # Does not work in python <= 2.6
        # conditionals = {elem.get_string_value(): expr for [elem, expr] in
        # [x.get_leaves() for x in leaves[:-1]]}
        conditionals = dict(
            (elem.get_string_value(), expr)
            for (elem, expr) in (x.get_leaves() for x in leaves[:-1]))
        default = leaves[-1]
        posts = {}

        IMPORTERS[formatname.get_string_value()] = (
            conditionals, default, posts, options)

        return Symbol('Null')


# FIXME This should be private, ImportExport`RegisterExport
class RegisterExport(Builtin):
    """
    <dl>
    <dt>'RegisterExport["$format$", $func$]'
      <dd>register '$func$' as the default function used when exporting from a file of type '"$format$"'.
    </dl>

    Simple text exporter
    >> ExampleExporter1[filename_, data_, opts___] := Module[{strm = OpenWrite[filename], char = data}, WriteString[strm, char]; Close[strm]]

    >> RegisterExport["ExampleFormat1", ExampleExporter1]

    >> Export["sample.txt", "Encode this string!", "ExampleFormat1"];

    >> FilePrint["sample.txt"]
     | Encode this string!

    #> DeleteFile["sample.txt"]

    Very basic encrypted text exporter
    >> ExampleExporter2[filename_, data_, opts___] := Module[{strm = OpenWrite[filename], char}, (* TODO: Check data *) char = FromCharacterCode[Mod[ToCharacterCode[data] - 84, 26] + 97]; WriteString[strm, char]; Close[strm]]

    >> RegisterExport["ExampleFormat2", ExampleExporter2]

    >> Export["sample.txt", "encodethisstring", "ExampleFormat2"];

    >> FilePrint["sample.txt"]
     | rapbqrguvffgevat

    #> DeleteFile["sample.txt"]
    """

    options = {
        'Path': 'Automatic',
        'FunctionChannels': '{"FileNames"}',
        'Sources': 'None',
        'DefaultElement': 'None',
        'AvailableElements': 'None',
        'Options': '{}',
        'OriginalChannel': 'False',
        'BinaryFormat': 'False',
        'Encoding': 'False',
        'Extensions': '{}',
        'AlphaChannel': 'False',
    }

    def apply(self, formatname, function, evaluation, options):
        'RegisterExport[formatname_String, function_, OptionsPattern[RegisterExport]]'
        EXPORTERS[formatname.get_string_value()] = function

        return Symbol('Null')


class Import(Builtin):
    """
    <dl>
    <dt>'Import["$file$"]'
      <dd>imports data from a file.
    <dt>'Import["$file$", $elements$]'
      <dd>imports the specified elements from a file.
    <dt>'Import["http://$url$", ...]' and 'Import["ftp://$url$", ...]'
      <dd>imports from a URL.
    </dl>

    #> Import["ExampleData/ExampleData.tx"]
     : File not found during Import.
     = $Failed
    #> Import[x]
     : First argument x is not a valid file, directory, or URL specification.
     = $Failed

    ## CSV
    #> Import["ExampleData/numberdata.csv", "Elements"]
     = {Data, Grid}
    #> Import["ExampleData/numberdata.csv", "Data"]
    = {{0.88, 0.60, 0.94}, {0.76, 0.19, 0.51}, {0.97, 0.04, 0.26}, {0.33, 0.74, 0.79}, {0.42, 0.64, 0.56}}
    #> Import["ExampleData/numberdata.csv"]
    = {{0.88, 0.60, 0.94}, {0.76, 0.19, 0.51}, {0.97, 0.04, 0.26}, {0.33, 0.74, 0.79}, {0.42, 0.64, 0.56}}

    ## Text
    >> Import["ExampleData/ExampleData.txt", "Elements"]
     = {Data, Lines, Plaintext, String, Words}
    >> Import["ExampleData/ExampleData.txt", "Lines"]
     = ...

    ## JSON
    >> Import["ExampleData/colors.json"]
     = {colorsArray -> {{colorName -> black, rgbValue -> (0, 0, 0), hexValue -> #000000}, {colorName -> red, rgbValue -> (255, 0, 0), hexValue -> #FF0000}, {colorName -> green, rgbValue -> (0, 255, 0), hexValue -> #00FF00}, {colorName -> blue, rgbValue -> (0, 0, 255), hexValue -> #0000FF}, {colorName -> yellow, rgbValue -> (255, 255, 0), hexValue -> #FFFF00}, {colorName -> cyan, rgbValue -> (0, 255, 255), hexValue -> #00FFFF}, {colorName -> magenta, rgbValue -> (255, 0, 255), hexValue -> #FF00FF}, {colorName -> white, rgbValue -> (255, 255, 255), hexValue -> #FFFFFF}}}
    """

    # TODO: Images tests
    """
    >> Import["ExampleData/sunflowers.jpg"]
     = -Image-
    """

    messages = {
        'nffil': 'File not found during Import.',
        'chtype': ('First argument `1` is not a valid file, directory, '
                   'or URL specification.'),
        'noelem': (
            'The Import element `1` is not present when importing as `2`.'),
        'fmtnosup': '`1` is not a supported Import format.',
    }

    rules = {
        'Import[filename_]': 'Import[filename, {}]',
    }

    def apply(self, filename, elements, evaluation):
        'Import[filename_, elements_]'

        # Check filename
        path = filename.to_python()
        if not (isinstance(path, basestring) and path[0] == path[-1] == '"'):
            evaluation.message('Import', 'chtype', filename)
            return Symbol('$Failed')

        findfile = Expression('FindFile', filename).evaluate(evaluation)
        if findfile == Symbol('$Failed'):
            evaluation.message('Import', 'nffil')
            return findfile

        # Check elements
        if elements.has_form('List', None):
            elements = elements.get_leaves()
        else:
            elements = [elements]

        for el in elements:
            if not isinstance(el, String):
                evaluation.message('Import', 'noelem', el)
                return Symbol('$Failed')

        elements = [el.get_string_value() for el in elements]

        # Determine file type
        for el in elements:
            if el in IMPORTERS.keys():
                filetype = el
                elements.remove(el)
                break
        else:
            filetype = Expression('FileFormat', findfile).evaluate(
                evaluation=evaluation).get_string_value()

        if filetype not in IMPORTERS.keys():
            evaluation.message('Import', 'fmtnosup', filetype)
            return Symbol('$Failed')

        # Load the importer
        (conditionals, default_function, posts,
         importer_options) = IMPORTERS[filetype]

        # XXX OptionsIssue
        # function_channels = importer_options.get(String("FunctionChannels"))
        function_channels = importer_options.get(Symbol("FunctionChannels"))

        # XXX OptionsIssue
        # default_element = importer_options.get(String("DefaultElement"))
        default_element = importer_options.get(Symbol("DefaultElement"))

        def get_results(tmp_function):
            if function_channels == Expression('List', String('FileNames')):
                tmp = Expression(tmp_function, findfile).evaluate(evaluation)
            elif function_channels == Expression('List', String('Streams')):
                stream = Expression('OpenRead', findfile).evaluate(evaluation)
                if stream.get_head_name() != 'InputStream':
                    evaluation.message('Import', 'nffil')
                    return None
                tmp = Expression(tmp_function, stream).evaluate(evaluation)
                Expression('Close', stream).evaluate(evaluation)
            else:
                # TODO print appropriate error message
                raise NotImplementedError
            tmp = tmp.get_leaves()
            if not all(expr.has_form('Rule', None) for expr in tmp):
                return None

            # return {a.get_string_value() : b for (a,b) in map(lambda x:
            # x.get_leaves(), tmp)}
            return dict((a.get_string_value(), b)
                        for (a, b) in map(lambda x: x.get_leaves(), tmp))

        # Perform the import
        defaults = None

        if elements == []:
            defaults = get_results(default_function)
            if defaults is None:
                return Symbol('$Failed')
            if default_element == Symbol("Automatic"):
                return Expression('List', *(
                    Expression('Rule', String(key), defaults[key])
                    for key in defaults.keys()))
            else:
                result = defaults.get(default_element.get_string_value())
                if result is None:
                    evaluation.message('Import', 'noelem', default_element,
                                       from_python(filetype))
                    return Symbol('$Failed')
                return result
        else:
            assert len(elements) == 1
            el = elements[0]
            if el == "Elements":
                defaults = get_results(default_function)
                if defaults is None:
                    return Symbol('$Failed')
                # Use set() to remove duplicates
                return from_python(sorted(set(
                    conditionals.keys() + defaults.keys() + posts.keys())))
            else:
                if el in conditionals.keys():
                    result = get_results(conditionals[el])
                    if result is None:
                        return Symbol('$Failed')
                    if len(result.keys()) == 1 and result.keys()[0] == el:
                        return result.values()[0]
                elif el in posts.keys():
                    # TODO: allow use of conditionals
                    result = get_results(posts[el])
                    if result is None:
                        return Symbol('$Failed')
                else:
                    if defaults is None:
                        defaults = get_results(default_function)
                        if defaults is None:
                            return Symbol('$Failed')
                    if el in defaults.keys():
                        return defaults[el]
                    else:
                        evaluation.message('Import', 'noelem', from_python(el),
                                           from_python(filetype))
                        return Symbol('$Failed')


class Export(Builtin):
    """
    <dl>
    <dt>'Export["$file$.$ext$", $expr$]'
      <dd>exports $expr$ to a file, using the extension $ext$ to determine the format.
    <dt>'Export["$file$", $expr$, "$format$"]'
      <dd>exports $expr$ to a file in the specified format.
    <dt>'Export["$file$", $exprs$, $elems$]'
      <dd>exports $exprs$ to a file as elements specified by $elems$.
    </dl>

    ## Invalid Filename
    #> Export["abc.", 1+2]
     : Cannot infer format of file abc..
     = $Failed
    #> Export[".ext", 1+2]
     : Cannot infer format of file .ext.
     = $Failed
    #> Export[x, 1+2]
     : First argument x is not a valid file specification.
     = $Failed

    ## Explicit Format
    #> Export["abc.txt", 1+x, "JPF"]
     : {JPF} is not a valid set of export elements for the Text format.
     = $Failed
    #> Export["abc.txt", 1+x, {"JPF"}]
     : {JPF} is not a valid set of export elements for the Text format.
     = $Failed

    ## Empty elems
    #> Export["123.txt", 1+x, {}]
     = 123.txt
    #> Export["123.jcp", 1+x, {}]
     : Cannot infer format of file 123.jcp.
     = $Failed

    ## Compression
    ## #> Export["abc.txt", 1+x, "ZIP"]    (* MMA Bug - Export::type *)
    ##  : {ZIP} is not a valid set of export elements for the Text format.
    ##  = $Failed
    ## #> Export["abc.txt", 1+x, "BZIP"]   (* MMA Bug - General::stop *)
    ##  : {BZIP} is not a valid set of export elements for the Text format.
    ##  = $Failed
    ## #> Export["abc.txt", 1+x, {"BZIP", "ZIP", "Text"}]
    ##  = abc.txt
    ## #> Export["abc.txt", 1+x, {"GZIP", "Text"}]
    ##  = abc.txt
    ## #> Export["abc.txt", 1+x, {"BZIP2", "Text"}]
    ##  = abc.txt

    ## FORMATS

    ## Text
    #> Export["abc.txt", 1 + x + y]
     = abc.txt
    #> FilePrint[%]
     | 1 + x + y
    #> DeleteFile[%%]

    ## CSV
    #> Export["abc.csv", {{1, 2, 3}, {4, 5, 6}}]
     = abc.csv
    #> FilePrint[%]
     | 1,2,3
     | 4,5,6
    #> DeleteFile[%%]
    """

    messages = {
        'chtype': "First argument `1` is not a valid file specification.",
        'infer': "Cannot infer format of file `1`.",
        'noelem': "`1` is not a valid set of export elements for the `2` format.",
    }

    _extdict = {
        'jpg': 'JPEG',
        'txt': 'Text',
        'csv': 'CSV',
    }

    rules = {
        'Export[filename_, expr_, elems_?NotListQ]': (
            'Export[filename, expr, {elems}]'),
    }

    def apply_noelems(self, filename, expr, evaluation):
        "Export[filename_, expr_]"

        # Check filename
        if not self._check_filename(filename, evaluation):
            return Symbol('$Failed')

        # Determine Format
        form = self._infer_form(filename, evaluation)

        if form is None:
            evaluation.message('Export', 'infer', filename)
            return Symbol('$Failed')
        else:
            return self.apply(filename, expr, String(form), evaluation)

    def apply(self, filename, expr, elems, evaluation):
        "Export[filename_, expr_, elems_List]"

        # Check filename
        if not self._check_filename(filename, evaluation):
            return Symbol('$Failed')

        ## Process elems {comp* format?, elem1*}
        leaves = elems.get_leaves()

        format_spec, elems_spec = [], []
        found_form = False
        for leaf in leaves[::-1]:
            leaf_str = leaf.get_string_value()

            if not found_form and leaf_str in EXPORTERS:
                found_form = True

            if found_form:
                format_spec.append(leaf_str)
            else:
                elems_spec.append(leaf)

        # Infer format if not present
        if not found_form:
            assert format_spec == []
            format_spec = self._infer_form(filename, evaluation)
            if format_spec is None:
                evaluation.message('Export', 'infer', filename)
                return Symbol('$Failed')
            format_spec = [format_spec]
        else:
            assert format_spec != []

        # First item in format_spec is the explicit format.
        # The other elements (if present) are compression formats

        if elems_spec != []:        # FIXME: support elems
            evaluation.message(
                'Export', 'noelem', elems, String(format_spec[0]))
            return Symbol('$Failed')

        # Load the exporter
        exporter_symbol = EXPORTERS[format_spec[0]]

        exporter_function = Expression(exporter_symbol, filename, expr)

        if exporter_function.evaluate(evaluation) == Symbol('Null'):
            return filename
        return Symbol('$Failed')

    def _check_filename(self, filename, evaluation):
        path = filename.to_python()
        if isinstance(path, basestring) and path[0] == path[-1] == '"':
            return True
        evaluation.message('Export', 'chtype', filename)
        return False

    def _infer_form(self, filename, evaluation):
        ext = Expression('FileExtension', filename).evaluate(evaluation)
        ext = ext.get_string_value()
        return self._extdict.get(ext)


class FileFormat(Builtin):
    """
    <dl>
    <dt>'FileFormat["$name$"]'
      <dd>attempts to determine what format 'Import' should use to import specified file.
    </dl>

    >> FileFormat["ExampleData/sunflowers.jpg"]
     = JPEG

    ## UTF-8 Unicode text
    >> FileFormat["ExampleData/EinsteinSzilLetter.txt"]
     = Text

    >> FileFormat["ExampleData/lena.tif"]
     = TIFF

    ## ASCII text
    #> FileFormat["ExampleData/BloodToilTearsSweat.txt"]
     = Text
    #> FileFormat["ExampleData/MadTeaParty.gif"]
     = GIF
    #> FileFormat["ExampleData/moon.tif"]
     = TIFF

    #> FileFormat["ExampleData/numberdata.csv"]
     = CSV

    #> FileFormat["ExampleData/EinsteinSzilLetter.txt"]
     = Text

    #> FileFormat["ExampleData/BloodToilTearsSweat.txt"]
     = Text

    #> FileFormat["ExampleData/benzene.xyz"]
     = XYZ

    #> FileFormat["ExampleData/colors.json"]
     = JSON

    #> FileFormat["ExampleData/some-typo.extension"]
     : File not found during FileFormat[ExampleData/some-typo.extension].
     = $Failed

    #> FileFormat["ExampleData/Testosterone.svg"]
     = SVG
    """

    # TODO: JSON example file
    """
    #> FileFormat["ExampleData/example.json"]
     = JSON
    """

    messages = {
        'nffil': 'File not found during `1`.',
    }

    detector = None

    def apply(self, filename, evaluation):
        'FileFormat[filename_String]'

        findfile = Expression('FindFile', filename).evaluate(evaluation)
        if findfile == Symbol('$Failed'):
            evaluation.message(
                'FileFormat', 'nffil', Expression('FileFormat', filename))
            return findfile

        path = findfile.get_string_value()

        if not FileFormat.detector:
            loader = magic.MagicLoader()
            loader.load()
            FileFormat.detector = magic.MagicDetector(loader.mimetypes)

        mime = set(FileFormat.detector.match(path))

        # If match fails match on extension only
        if mime == set([]):
            mime, encoding = mimetypes.guess_type(path)
            if mime is None:
                mime = set([])
            else:
                mime = set([mime])

        # TODO: Add more file formats

        typedict = {
            'application/dicom': 'DICOM',
            'application/dbase': 'DBF',
            'application/dbf': 'DBF',
            'application/eps': 'EPS',
            'application/fits': 'FITS',
            'application/json': 'JSON',
            'application/mathematica': 'NB',
            'application/mdb': 'MDB',
            'application/mbox': 'MBOX',
            'application/msaccess': 'MDB',
            'application/octet-stream': 'OBJ',
            'application/pdf': 'PDF',
            'application/pcx': 'PCX',
            'application/postscript': 'EPS',
            'application/rss+xml': 'RSS',
            'application/rtf': 'RTF',
            'application/sla': 'STL',
            'application/tga': 'TGA',
            'application/vnd.google-earth.kml+xml': 'KML',
            'application/vnd.ms-excel': 'XLS',
            'application/vnd.ms-pki.stl': 'STL',
            'application/vnd.oasis.opendocument.spreadsheet': 'ODS',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': 'XLSX',    # nopep8
            'application/vnd.sun.xml.calc': 'SXC',
            'application/vnd.msaccess': 'MDB',
            'application/vnd.wolfram.cdf': 'CDF',
            'application/vnd.wolfram.cdf.text': 'CDF',
            'application/vnd.wolfram.mathematica.package': 'Package',
            'application/xhtml+xml': 'XHTML',
            'application/xml': 'XML',
            'application/x-3ds': '3DS',
            'application/x-cdf': 'NASACDF',
            'application/x-eps': 'EPS',
            'application/x-flac': 'FLAC',
            'application/x-font-bdf': 'BDF',
            'application/x-hdf': 'HDF',
            'application/x-msaccess': 'MDB',
            'application/x-netcdf': 'NetCDF',
            'application/x-shockwave-flash': 'SWF',
            'application/x-tex': 'TeX',  # Also TeX
            'audio/aiff': 'AIFF',
            'audio/basic': 'AU',        # Also SND
            'audio/midi': 'MIDI',
            'audio/x-aifc': 'AIFF',
            'audio/x-aiff': 'AIFF',
            'audio/x-flac': 'FLAC',
            'audio/x-wav': 'WAV',
            'chemical/seq-na-genbank': 'GenBank',
            'chemical/seq-aa-fasta': 'FASTA',
            'chemical/seq-na-fasta': 'FASTA',
            'chemical/seq-na-fastq': 'FASTQ',
            'chemical/seq-na-sff': 'SFF',
            'chemical/x-cif': 'CIF',
            'chemical/x-daylight-smiles': 'SMILES',
            'chemical/x-hin': 'HIN',
            'chemical/x-jcamp-dx': 'JCAMP-DX',
            'chemical/x-mdl-molfile': 'MOL',
            'chemical/x-mdl-sdf': 'SDF',
            'chemical/x-mdl-sdfile': 'SDF',
            'chemical/x-mdl-tgf': 'TGF',
            'chemical/x-mmcif': 'CIF',
            'chemical/x-mol2': 'MOL2',
            'chemical/x-mopac-input': 'Table',
            'chemical/x-pdb': 'PDB',
            'chemical/x-xyz': 'XYZ',
            'image/bmp': 'BMP',
            'image/eps': 'EPS',
            'image/fits': 'FITS',
            'image/gif': 'GIF',
            'image/jp2': 'JPEG2000',
            'image/jpeg': 'JPEG',
            'image/pbm': 'PNM',
            'image/pcx': 'PCX',
            'image/pict': 'PICT',
            'image/png': 'PNG',
            'image/svg+xml': 'SVG',
            'image/tga': 'TGA',
            'image/tiff': 'TIFF',
            'image/vnd.dxf': 'DXF',
            'image/vnd.microsoft.icon': 'ICO',
            'image/x-3ds': '3DS',
            'image/x-dxf': 'DXF',
            'image/x-exr': 'OpenEXR',
            'image/x-icon': 'ICO',
            'image/x-ms-bmp': 'BMP',
            'image/x-pcx': 'PCX',
            'image/x-portable-anymap': 'PNM',
            'image/x-portable-bitmap': 'PBM',
            'image/x-portable-graymap': 'PGM',
            'image/x-portable-pixmap': 'PPM',
            'image/x-xbitmap': 'XBM',
            'model/x3d+xml': 'X3D',
            'model/vrml': 'VRML',
            'model/x-lwo': 'LWO',
            'model/x-pov': 'POV',
            'text/calendar': 'ICS',
            'text/comma-separated-values': 'CSV',
            'text/csv': 'CSV',
            'text/html': 'HTML',
            'text/mathml': 'MathML',
            'text/plain': 'Text',
            'text/rtf': 'RTF',
            'text/scriptlet': 'SCT',
            'text/tab-separated-values': 'TSV',
            'text/texmacs': 'Text',
            'text/vnd.graphviz': 'DOT',
            'text/x-csrc': 'C',
            'text/x-tex': 'TeX',
            'text/x-vcalendar': 'VCS',
            'text/x-vcard': 'VCF',
            'video/avi': 'AVI',
            'video/quicktime': 'QuickTime',
            'video/x-flv': 'FLV',
            # None: 'Binary',
        }

        result = []
        for key in typedict.keys():
            if key in mime:
                result.append(typedict[key])

        if len(result) == 0:
            result = 'Binary'
        elif len(result) == 1:
            result = result[0]
        else:
            return None

        return from_python(result)

########NEW FILE########
__FILENAME__ = inout
# -*- coding: utf8 -*-

"""
Input and Output
"""

import re

from mathics.builtin.base import (
    Builtin, BinaryOperator, BoxConstruct, BoxConstructError, Operator)
from mathics.builtin.tensors import get_dimensions
from mathics.builtin.comparison import expr_min
from mathics.builtin.lists import list_boxes
from mathics.builtin.options import options_to_rules
from mathics.core.expression import (
    Expression, String, Symbol, Integer, Rational, Real, Complex, BoxError)

MULTI_NEWLINE_RE = re.compile(r"\n{2,}")


class Format(Builtin):
    """
    Assign values to 'Format' to control how particular expressions should be formatted when printed
    to the user.
    >> Format[f[x___]] := Infix[{x}, "~"]
    >> f[1, 2, 3]
     = 1 ~ 2 ~ 3
    >> f[1]
     = 1

    Raw objects cannot be formatted:
    >> Format[3] = "three";
     : Cannot assign to raw object 3.

    Format types must be symbols:
    >> Format[r, a + b] = "r";
     : Format type a + b is not a symbol.

    Formats must be attached to the head of an expression:
    >> f /: Format[g[f]] = "my f";
     : Tag f not found or too deep for an assigned rule.
    """

    messages = {
        'fttp': "Format type `1` is not a symbol.",
    }


def parenthesize(precedence, leaf, leaf_boxes, when_equal):
    from mathics.builtin import builtins_precedence

    while leaf.has_form('HoldForm', 1):
        leaf = leaf.leaves[0]
    if leaf.has_form(('Infix', 'Prefix', 'Postfix'), 3, None):
        leaf_prec = leaf.leaves[2].get_int_value()
    elif leaf.has_form('PrecedenceForm', 2):
        leaf_prec = leaf.leaves[1].get_int_value()
    else:
        leaf_prec = builtins_precedence.get(leaf.get_head_name())
    if precedence is not None and leaf_prec is not None:
        if precedence > leaf_prec or (precedence == leaf_prec and when_equal):
            return Expression(
                'RowBox',
                Expression('List', String("("), leaf_boxes, String(")")))
    return leaf_boxes


def make_boxes_infix(leaves, ops, precedence, grouping, form):

    result = []
    for index, leaf in enumerate(leaves):
        if index > 0:
            result.append(ops[index - 1])
        parenthesized = False
        if grouping == 'NonAssociative':
            parenthesized = True
        elif grouping == 'Left' and index > 0:
            parenthesized = True
        elif grouping == 'Right' and index == 0:
            parenthesized = True

        leaf_boxes = MakeBoxes(leaf, form)
        leaf = parenthesize(precedence, leaf, leaf_boxes, parenthesized)
        result.append(leaf)
    return Expression('RowBox', Expression('List', *result))


class MakeBoxes(Builtin):
    """

    String representation of boxes
    >> \(x \^ 2\)
     = SuperscriptBox[x, 2]

    >> \(x \_ 2\)
     = SubscriptBox[x, 2]

    >> \( a \+ b \% c\)
     = UnderoverscriptBox[a, b, c]

    >> \( a \& b \% c\)
     = UnderoverscriptBox[a, c, b]

    #> \( \@ 5 \)
     = SqrtBox[5]

    >> \(x \& y \)
     = OverscriptBox[x, y]

    >> \(x \+ y \)
     = UnderscriptBox[x, y]

    #> \( x \^ 2 \_ 4 \)
     = SuperscriptBox[x, SubscriptBox[2, 4]]

    ## Tests for issue 151 (infix operators in heads)
    #> (a + b)[x]
     = (a + b)[x]
    #> (a b)[x]
     = (a b)[x]
    #> (a <> b)[x]
     : String expected.
     = (a <> b)[x]
    """

    # TODO: Convert operators to appropriate representations e.g. 'Plus' to '+'
    """
    >> \(a + b\)
     = RowBox[{a, +, b}]

    >> \(TraditionalForm \` a + b\)
     = FormBox[RowBox[{a, +, b}], TraditionalForm]

    >> \(x \/ \(y + z\)\)
     =  FractionBox[x, RowBox[{y, +, z}]]
    """

    # TODO: Constructing boxes from Real
    """
    ## Test Real MakeBoxes
    #> MakeBoxes[1.4]
     = 1.4`
    #> MakeBoxes[1.4`]
     = 1.4`
    #> MakeBoxes[1.5`20]
     = 1.5`20.
    #> MakeBoxes[1.4`20]
     = 1.4`20.
    #> MakeBoxes[1.5``20]
     = 1.5`20.1760912591
    #> MakeBoxes[-1.4]
     = RowBox[{-, 1.4`}]
    #> MakeBoxes[34.*^3]
     = 34000.`

    #> MakeBoxes[0`]
     = 0.`
    #> MakeBoxes[0`3]
     = 0
    #> MakeBoxes[0``30]
     = 0.``30.
    #> MakeBoxes[0.`]
     = 0.`
    #> MakeBoxes[0.`3]
     = 0.`
    #> MakeBoxes[0.``30]
     = 0.``30.

    #> MakeBoxes[14]
     = 14
    #> MakeBoxes[-14]
     = RowBox[{-, 14}]
    """

    # TODO: Correct precedence
    """
    >> \(x \/ y + z\)
     = RowBox[{FractionBox[x, y], +, z}]
    >> \(x \/ (y + z)\)
     = FractionBox[x, RowBox[{(, RowBox[{y, +, z}], )}]]

    #> \( \@ a + b \)
     = RowBox[{SqrtBox[a], +, b}]
    """

    # FIXME: Don't insert spaces with brackets
    """
    #> \(c (1 + x)\)
     = RowBox[{c, RowBox[{(, RowBox[{1, +, x}], )}]}]
    """

    # TODO: Required MakeExpression
    """
    #> \!\(x \^ 2\)
     = x ^ 2
    #> FullForm[%]
     = Power[x, 2]
    """

    # TODO: Fix Infix operators
    """
    >> MakeBoxes[1 + 1]
     = RowBox[{1, +, 1}]
    """

    # TODO: Parsing of special characters (like commas)
    """
    >> \( a, b \)
     = RowBox[{a, ,, b}]
    """

    attributes = ('HoldAllComplete',)

    rules = {
        'MakeBoxes[Infix[head_[leaves___]], '
        '    f:StandardForm|TraditionalForm|OutputForm|InputForm]': (
            'MakeBoxes[Infix[head[leaves], StringForm["~`1`~", head]], f]'),
        'MakeBoxes[expr_]': 'MakeBoxes[expr, StandardForm]',
        'MakeBoxes[(form:StandardForm|TraditionalForm|OutputForm|TeXForm|'
        'MathMLForm)[expr_], StandardForm|TraditionalForm]': (
            'MakeBoxes[expr, form]'),
        'MakeBoxes[(form:OutputForm|MathMLForm|TeXForm)[expr_], OutputForm]':
        'MakeBoxes[expr, form]',
        'MakeBoxes[StandardForm[expr_], OutputForm]':
        'MakeBoxes[expr, OutputForm]',
        'MakeBoxes[FullForm[expr_], StandardForm|TraditionalForm|OutputForm]':
        'StyleBox[MakeBoxes[expr, FullForm], ShowStringCharacters->True]',
        'MakeBoxes[InputForm[expr_], StandardForm|TraditionalForm|OutputForm]':
        'StyleBox[MakeBoxes[expr, InputForm], ShowStringCharacters->True]',
        'MakeBoxes[PrecedenceForm[expr_, prec_], f_]': 'MakeBoxes[expr, f]',
        'MakeBoxes[Style[expr_, OptionsPattern[Style]], f_]': (
            'StyleBox[MakeBoxes[expr, f], '
            'ImageSizeMultipliers -> OptionValue[ImageSizeMultipliers]]'),
    }

    def apply_general(self, expr, f, evaluation):
        '''MakeBoxes[expr_,
            f:TraditionalForm|StandardForm|OutputForm|InputForm|FullForm]'''

        if expr.is_atom():
            x = expr
            if isinstance(x, Symbol):
                return String(x.name)
            elif isinstance(x, String):
                return String('"' + unicode(x.value) + '"')
            elif isinstance(x, (Integer, Real)):
                return x.make_boxes(f.get_name())
            elif isinstance(x, (Rational, Complex)):
                return x.format(evaluation, f.get_name())
        else:
            head = expr.head
            leaves = expr.leaves

            f_name = f.get_name()
            if f_name == 'TraditionalForm':
                left, right = '(', ')'
            else:
                left, right = '[', ']'

            # Parenthesize infix operators at the head of expressions,
            # like (a + b)[x], but not f[a] in f[a][b].
            #
            head_boxes = parenthesize(670,
                                      head, MakeBoxes(head, f), False)
            result = [head_boxes, String(left)]

            if len(leaves) > 1:
                row = []
                if f_name in ('InputForm', 'OutputForm', 'FullForm'):
                    sep = ', '
                else:
                    sep = ','
                for index, leaf in enumerate(leaves):
                    if index > 0:
                        row.append(String(sep))
                    row.append(MakeBoxes(leaf, f))
                result.append(RowBox(Expression('List', *row)))
            elif len(leaves) == 1:
                result.append(MakeBoxes(leaves[0], f))
            result.append(String(right))
            return RowBox(Expression('List', *result))

    def _apply_atom(self, x, f, evaluation):
        '''MakeBoxes[x_?AtomQ,
            f:TraditionalForm|StandardForm|OutputForm|InputForm|FullForm]'''

        if isinstance(x, Symbol):
            return String(x.name)
        elif isinstance(x, String):
            return String('"' + x.value + '"')
        elif isinstance(x, (Integer, Real)):
            return x.make_boxes(f.get_name())
        elif isinstance(x, (Rational, Complex)):
            return x.format(evaluation, f.get_name())

    def apply_outerprecedenceform(self, expr, prec, f, evaluation):
        '''MakeBoxes[OuterPrecedenceForm[expr_, prec_],
            f:StandardForm|TraditionalForm|OutputForm|InputForm]'''

        precedence = prec.get_int_value()
        boxes = MakeBoxes(expr)
        return parenthesize(precedence, expr, boxes, True)

    def apply_postprefix(self, p, expr, h, prec, f, evaluation):
        '''MakeBoxes[(p:Prefix|Postfix)[expr_, h_, prec_:None],
            f:StandardForm|TraditionalForm|OutputForm|InputForm]'''

        if not isinstance(h, String):
            h = MakeBoxes(h, f)

        precedence = prec.get_int_value()

        leaves = expr.get_leaves()
        if len(leaves) == 1:
            leaf = leaves[0]
            leaf_boxes = MakeBoxes(leaf, f)
            leaf = parenthesize(precedence, leaf, leaf_boxes, True)
            if p.get_name() == 'Postfix':
                args = (leaf, h)
            else:
                args = (h, leaf)

            return Expression('RowBox', Expression('List', *args))
        else:
            return MakeBoxes(expr, f)

    def apply_infix(self, expr, h, prec, grouping, f, evaluation):
        '''MakeBoxes[Infix[expr_, h_, prec_:None, grouping_:None],
            f:StandardForm|TraditionalForm|OutputForm|InputForm]'''

        def get_op(op):
            if not isinstance(op, String):
                op = MakeBoxes(op, f)
            else:
                op_value = op.get_string_value()
                if f.get_name() == 'InputForm' and op_value in ['*', '^']:
                    pass
                elif (f.get_name() in ('InputForm', 'OutputForm') and
                      not op_value.startswith(' ') and
                      not op_value.endswith(' ')):
                    op = String(' ' + op_value + ' ')
            return op

        precedence = prec.get_int_value()
        grouping = grouping.get_name()

        leaves = expr.get_leaves()
        if len(leaves) > 1:
            if h.has_form('List', len(leaves) - 1):
                ops = [get_op(op) for op in h.leaves]
            else:
                ops = [get_op(h)] * (len(leaves) - 1)
            return make_boxes_infix(leaves, ops, precedence, grouping, f)
        elif len(leaves) == 1:
            return MakeBoxes(leaves[0], f)
        else:
            return MakeBoxes(expr, f)


class ToBoxes(Builtin):
    """
    >> ToBoxes[a + b]
     = RowBox[{a, +, b}]
    >> ToBoxes[a ^ b] // FullForm
     = SuperscriptBox["a", "b"]
    """

    def apply(self, expr, form, evaluation):
        'ToBoxes[expr_, form_:StandardForm]'

        form_name = form.get_name()
        if form_name is None:
            evaluation.message('ToBoxes', 'boxfmt', form)
        boxes = expr.format(evaluation, form_name)
        return boxes


class RowBox(Builtin):
    pass


class Row(Builtin):
    def apply_makeboxes(self, items, sep, f, evaluation):
        '''MakeBoxes[Row[{items___}, sep_:""],
            f:StandardForm|TraditionalForm|OutputForm]'''

        items = items.get_sequence()
        if not isinstance(sep, String):
            sep = MakeBoxes(sep, f)
        if len(items) == 1:
            return MakeBoxes(items[0], f)
        else:
            result = []
            for index, item in enumerate(items):
                if index > 0 and not sep.same(String('')):
                    result.append(sep)
                result.append(MakeBoxes(item, f))
            return RowBox(Expression('List', *result))


def is_constant(list):
    if list:
        return all(item == list[0] for item in list[1:])
    return True


class GridBox(BoxConstruct):
    """
    #> Grid[{{a,bc},{d,e}}, ColumnAlignments:>Symbol["Rig"<>"ht"]]
     = a   bc
     .
     . d   e
    """

    options = {
        'ColumnAlignments': 'Center',
    }

    def get_array(self, leaves, evaluation):
        options = self.get_option_values(leaves[1:], evaluation)
        if not leaves:
            raise BoxConstructError
        expr = leaves[0]
        if not expr.has_form('List', None):
            if not all(leaf.has_form('List', None) for leaf in expr.leaves):
                raise BoxConstructError
        items = [leaf.leaves for leaf in expr.leaves]
        if not is_constant([len(row) for row in items]):
            raise BoxConstructError
        return items, options

    def boxes_to_tex(self, leaves, **box_options):
        evaluation = box_options.get('evaluation')
        items, options = self.get_array(leaves, evaluation)
        new_box_options = box_options.copy()
        new_box_options['inside_list'] = True
        column_alignments = options['ColumnAlignments'].get_name()
        if column_alignments in ('Center', 'Left', 'Right'):
            column_alignments = column_alignments[0].lower()
        else:
            raise BoxConstructError
        column_count = 0
        for row in items:
            column_count = max(column_count, len(row))
        result = r'\begin{array}{%s} ' % (column_alignments * column_count)
        for index, row in enumerate(items):
            result += ' & '.join(item.boxes_to_tex(**new_box_options)
                                 for item in row)
            if index != len(items) - 1:
                result += '\\\\ '
        result += r'\end{array}'
        return result

    def boxes_to_xml(self, leaves, **box_options):
        evaluation = box_options.get('evaluation')
        items, options = self.get_array(leaves, evaluation)
        attrs = {}
        column_alignments = options['ColumnAlignments'].get_name()
        if column_alignments in ('Center', 'Left', 'Right'):
            attrs['columnalign'] = column_alignments.lower()
        else:
            raise BoxConstructError
        attrs = ' '.join('{0}="{1}"'.format(name, value)
                         for name, value in attrs.iteritems())
        result = '<mtable {0}>\n'.format(attrs)
        new_box_options = box_options.copy()
        new_box_options['inside_list'] = True
        for row in items:
            result += '<mtr>'
            for item in row:
                result += u'<mtd {0}>{1}</mtd>'.format(
                    attrs, item.boxes_to_xml(**new_box_options))
            result += '</mtr>\n'
        result += '</mtable>'
        return result

    def boxes_to_text(self, leaves, **box_options):
        evaluation = box_options.get('evaluation')
        items, options = self.get_array(leaves, evaluation)
        result = ''
        if not items:
            return ''
        widths = [0] * len(items[0])
        cells = [[item.boxes_to_text(**box_options).splitlines()
                  for item in row] for row in items]
        for row in cells:
            for index, cell in enumerate(row):
                if index >= len(widths):
                    raise BoxConstructError
                for line in cell:
                    widths[index] = max(widths[index], len(line))
        for row_index, row in enumerate(cells):
            if row_index > 0:
                result += '\n'
            k = 0
            while True:
                line_exists = False
                line = ''
                for cell_index, cell in enumerate(row):
                    if len(cell) > k:
                        line_exists = True
                        text = cell[k]
                    else:
                        text = ''
                    line += text
                    if cell_index < len(row) - 1:
                        line += ' ' * (widths[cell_index] - len(text))
                        # if cell_index < len(row) - 1:
                        line += '   '
                if line_exists:
                    result += line + '\n'
                else:
                    break
                k += 1
        return result


class Grid(Builtin):
    """
    >> Grid[{{a, b}, {c, d}}]
     = a   b
     .
     . c   d
    """

    options = GridBox.options

    def apply_makeboxes(self, array, f, evaluation, options):
        '''MakeBoxes[Grid[array_?MatrixQ, OptionsPattern[Grid]],
            f:StandardForm|TraditionalForm|OutputForm]'''

        return Expression(
            'GridBox',
            Expression('List', *(
                Expression('List', *(
                    Expression('MakeBoxes', item, f) for item in row.leaves))
                for row in array.leaves)),
            *options_to_rules(options))


class TableForm(Builtin):
    """
    >> TableForm[Array[a, {3,2}],TableDepth->1]
     = {a[1, 1], a[1, 2]}
     .
     . {a[2, 1], a[2, 2]}
     .
     . {a[3, 1], a[3, 2]}

    A table of Graphics:
    >> Table[Style[Graphics[{EdgeForm[{Black}], RGBColor[r,g,b], Rectangle[]}], ImageSizeMultipliers->{0.2, 1}], {r,0,1,1/2}, {g,0,1,1/2}, {b,0,1,1/2}] // TableForm
     = -Graphics-   -Graphics-   -Graphics-
     .
     . -Graphics-   -Graphics-   -Graphics-
     .
     . -Graphics-   -Graphics-   -Graphics-
     .
     . -Graphics-   -Graphics-   -Graphics-
     .
     . -Graphics-   -Graphics-   -Graphics-
     .
     . -Graphics-   -Graphics-   -Graphics-
     .
     . -Graphics-   -Graphics-   -Graphics-
     .
     . -Graphics-   -Graphics-   -Graphics-
     .
     . -Graphics-   -Graphics-   -Graphics-
    """

    options = {
        'TableDepth': 'Infinity',
    }

    def apply_makeboxes(self, table, f, evaluation, options):
        '''MakeBoxes[%(name)s[table_, OptionsPattern[%(name)s]],
            f:StandardForm|TraditionalForm|OutputForm]'''

        dims = len(get_dimensions(table, head=Symbol('List')))
        depth = self.get_option(options, 'TableDepth', evaluation).unformatted
        depth = expr_min((Integer(dims), depth))
        depth = depth.get_int_value()
        if depth is None:
            evaluation.message(self.get_name(), 'int')
            return

        if depth <= 0:
            return Expression('MakeBoxes', table, f)
        elif depth == 1:
            return Expression(
                'GridBox', Expression('List', *(
                    Expression('List', Expression('MakeBoxes', item, f))
                    for item in table.leaves)))
        else:
            new_depth = Expression('Rule', Symbol('TableDepth'), depth - 2)

            def transform_item(item):
                if depth > 2:
                    return Expression(self.get_name(), item, new_depth)
                else:
                    return item

            return Expression(
                'GridBox', Expression('List', *(
                    Expression('List', *(
                        Expression('MakeBoxes', transform_item(item), f)
                        for item in row.leaves)) for row in table.leaves)))


class MatrixForm(TableForm):
    """
    >> Array[a,{4,3}]//MatrixForm
     = a[1, 1]   a[1, 2]   a[1, 3]
     .
     . a[2, 1]   a[2, 2]   a[2, 3]
     .
     . a[3, 1]   a[3, 2]   a[3, 3]
     .
     . a[4, 1]   a[4, 2]   a[4, 3]

    ## Issue #182
    #> {{2*a, 0},{0,0}}//MatrixForm
     = 2 a   0
     .
     . 0     0
    """

    def apply_makeboxes_matrix(self, table, f, evaluation, options):
        '''MakeBoxes[%(name)s[table_, OptionsPattern[%(name)s]],
            f:StandardForm|TraditionalForm]'''

        result = super(MatrixForm, self).apply_makeboxes(
            table, f, evaluation, options)
        if result.get_head_name() == 'GridBox':
            return Expression('RowBox', Expression(
                'List', String("("), result, String(")")))
        return result


class Superscript(Builtin):
    """
    >> Superscript[x,3] // TeXForm
     = x^3
    """

    rules = {
        'MakeBoxes[Superscript[x_, y_], f:StandardForm|TraditionalForm]': (
            'SuperscriptBox[MakeBoxes[x, f], MakeBoxes[y, f]]'),
    }


class Subscript(Builtin):
    """
    >> Subscript[x,1,2,3] // TeXForm
     = x_{1,2,3}
    """

    def apply_makeboxes(self, x, y, f, evaluation):
        'MakeBoxes[Subscript[x_, y__], f:StandardForm|TraditionalForm]'

        y = y.get_sequence()
        return Expression(
            'SubscriptBox', Expression('MakeBoxes', x, f), *list_boxes(y, f))


class Subsuperscript(Builtin):
    """
    >> Subsuperscript[a, b, c] // TeXForm
     = a_b^c
    """

    rules = {
        'MakeBoxes[Subsuperscript[x_, y_, z_], '
        'f:StandardForm|TraditionalForm]': (
            'SubsuperscriptBox[MakeBoxes[x, f], MakeBoxes[y, f], '
            'MakeBoxes[z, f]]'),
    }


class Postfix(BinaryOperator):
    """
    >> b // a
     = a[b]
    >> c // b // a
     = a[b[c]]

    The postfix operator '//' is parsed to an expression before evaluation:
    >> Hold[x // a // b // c // d // e // f]
     = Hold[f[e[d[c[b[a[x]]]]]]]
    """

    operator = '//'
    operator_display = None
    precedence = 70
    grouping = 'Left'

    def post_parse(self, expression):
        return Expression(expression.leaves[1].post_parse(),
                          expression.leaves[0].post_parse())


class Prefix(BinaryOperator):
    """
    >> a @ b
     = a[b]
    >> a @ b @ c
     = a[b[c]]
    >> Format[p[x_]] := Prefix[{x}, "*"]
    >> p[3]
     = *3
    >> Format[q[x_]] := Prefix[{x}, "~", 350]
    >> q[a+b]
     = ~(a + b)
    >> q[a*b]
     = ~a b
    >> q[a]+b
     = b + ~a

    The prefix operator '@' is parsed to an expression before evaluation:
    >> Hold[a @ b @ c @ d @ e @ f @ x]
     = Hold[a[b[c[d[e[f[x]]]]]]]
    """

    operator = '@'
    operator_display = None
    precedence = 640
    grouping = 'Right'

    def post_parse(self, expression):
        return Expression(expression.leaves[0].post_parse(),
                          expression.leaves[1].post_parse())


class Infix(Builtin):
    """
    >> Format[g[x_, y_]] := Infix[{x, y}, "#", 350, Left]
    >> g[a, g[b, c]]
     = a # (b # c)
    >> g[g[a, b], c]
     = a # b # c
    >> g[a + b, c]
     = (a + b) # c
    >> g[a * b, c]
     = a b # c
    >> g[a, b] + c
     = c + a # b
    >> g[a, b] * c
     = c (a # b)

    >> Infix[{a, b, c}, {"+", "-"}]
     = a + b - c

    #> Format[r[items___]] := Infix[If[Length[{items}] > 1, {items}, {ab}], "~"]
    #> r[1, 2, 3]
     = 1 ~ 2 ~ 3
    #> r[1]
     = ab
    """


class StringForm(Builtin):
    """
    >> StringForm["`1` bla `2` blub `` bla `2`", a, b, c]
     = a bla b blub c bla b
    """

    format_re = re.compile(r'(\`(\d*)\`)')

    def apply_makeboxes(self, s, args, f, evaluation):
        '''MakeBoxes[StringForm[s_String, args___],
            f:StandardForm|TraditionalForm|OutputForm]'''

        s = s.value
        args = args.get_sequence()
        result = []
        pos = 0
        last_index = 0
        for match in self.format_re.finditer(s):
            start, end = match.span(1)
            if match.group(2):
                index = int(match.group(2))
            else:
                index = last_index + 1
            if index > last_index:
                last_index = index
            if start > pos:
                result.append(String(s[pos:start]))
            pos = end
            if 1 <= index <= len(args):
                arg = args[index - 1]
                result.append(MakeBoxes(arg, f))
        if pos < len(s):
            result.append(String(s[pos:]))
        return RowBox(Expression('List', *result))


class Message(Builtin):
    """
    >> a::b = "Hello world!"
     = Hello world!
    >> Message[a::b]
     : Hello world!
    >> a::c := "Hello `1`, Mr 00`2`!"
    >> Message[a::c, "you", 3 + 4]
     : Hello you, Mr 007!
    """

    attributes = ('HoldFirst',)

    def apply(self, symbol, tag, params, evaluation):
        'Message[MessageName[symbol_Symbol, tag_String], params___]'

        params = params.get_sequence()
        evaluation.message(symbol.name, tag.value, *params)
        return Symbol('Null')


class Quiet(Builtin):
    """
    <dl>
    <dt>'Quiet[$expr$, {$s1::t1$, ...}]'
        <dd>evaluates $expr$, without messages '{$s1::t1$, ...}' being displayed.
    <dt>'Quiet[$expr$, All]'
        <dd>evaluates $expr$, without any messages being displayed.
    <dt>'Quiet[$expr$, None]'
        <dd>evaluates $expr$, without all messages being displayed.
    <dt>'Quiet[$expr$, $off$, $on$]'
        <dd>evaluates $expr$, with messages $off$ being suppressed, but messages $on$ being displayed.
    </dl>

    >> a::b = "Hello";
    >> Quiet[x+x, {a::b}]
     = 2 x
    >> Quiet[Message[a::b]; x+x, {a::b}]
     = 2 x

    >> Message[a::b]; y=Quiet[Message[a::b]; x+x, {a::b}]; Message[a::b]; y
     : Hello
     : Hello
     = 2 x

    >> Quiet[expr, All, All]
     : Arguments 2 and 3 of Quiet[expr, All, All] should not both be All.
     = Quiet[expr, All, All]
    >> Quiet[x + x, {a::b}, {a::b}]
     : In Quiet[x + x, {a::b}, {a::b}] the message name(s) {a::b} appear in both the list of messages to switch off and the list of messages to switch on.
     = Quiet[x + x, {a::b}, {a::b}]
    """

    attributes = ('HoldAll',)

    messages = {
        'anmlist': ("Argument `1` of `2` should be All, None, a message name, "
                    "or a list of message names."),
        'allall': "Arguments 2 and 3 of `1` should not both be All.",
        'conflict': (
            "In `1` the message name(s) `2` appear in both the list of "
            "messages to switch off and the list of messages to switch on."),
    }

    rules = {
        'Quiet[expr_]': 'Quiet[expr, All]',
        'Quiet[expr_, moff_]': 'Quiet[expr, moff, None]',
    }

    def apply(self, expr, moff, mon, evaluation):
        'Quiet[expr_, moff_, mon_]'

        def get_msg_list(expr):
            if expr.has_form('MessageName', 2):
                expr = Expression('List', expr)
            if expr.get_name() == 'All':
                all = True
                messages = []
            elif expr.get_name() == 'None':
                all = False
                messages = []
            elif expr.has_form('List', None):
                all = False
                messages = []
                for item in expr.leaves:
                    if item.has_form('MessageName', 2):
                        symbol = item.leaves[0].get_name()
                        tag = item.leaves[1].get_string_value()
                        if symbol and tag:
                            messages.append((symbol, tag))
                        else:
                            raise ValueError
                    else:
                        raise ValueError
            else:
                raise ValueError
            return all, messages

        old_quiet_all, old_quiet_messages = \
            evaluation.quiet_all, evaluation.quiet_messages.copy()
        try:
            quiet_expr = Expression('Quiet', expr, moff, mon)
            try:
                off_all, off_messages = get_msg_list(moff)
            except ValueError:
                evaluation.message('Quiet', 'anmlist', 2, quiet_expr)
                return
            try:
                on_all, on_messages = get_msg_list(mon)
            except ValueError:
                evaluation.message('Quiet', 'anmlist', 2, quiet_expr)
                return
            if off_all and on_all:
                evaluation.message('Quiet', 'allall', quiet_expr)
                return
            evaluation.quiet_all = off_all
            conflict = []
            for off in off_messages:
                if off in on_messages:
                    conflict.append(off)
                    break
            if conflict:
                evaluation.message(
                    'Quiet', 'conflict', quiet_expr, Expression('List', *(
                        Expression('MessageName', Symbol(symbol), String(tag))
                        for symbol, tag in conflict)))
                return
            for off in off_messages:
                evaluation.quiet_messages.add(off)
            for on in on_messages:
                evaluation.quiet_messages.discard(on)
            if on_all:
                evaluation.quiet_messages = set()

            return expr.evaluate(evaluation)
        finally:
            evaluation.quiet_all, evaluation.quiet_messages =\
                old_quiet_all, old_quiet_messages


class MessageName(BinaryOperator):
    """
    'MessageName' is the head of message IDs of the form 'symbol::tag'.
    >> FullForm[a::b]
     = MessageName[a, "b"]

    The second parameter 'tag' is interpreted as a string.
    >> FullForm[a::"b"]
     = MessageName[a, "b"]
    """

    messages = {
        'messg': "Message cannot be set to `1`. It must be set to a string.",
    }

    operator = '::'
    precedence = 750
    attributes = ('HoldFirst',)

    default_formats = False

    formats = {
    }

    rules = {
        'MakeBoxes[MessageName[symbol_Symbol, tag_String], '
        'f:StandardForm|TraditionalForm|OutputForm]': (
            'RowBox[{MakeBoxes[symbol, f], "::", MakeBoxes[tag, f]}]'),
        'MakeBoxes[MessageName[symbol_Symbol, tag_String], InputForm]': (
            'RowBox[{MakeBoxes[symbol, InputForm], "::", tag}]'),
    }

    def apply(self, symbol, tag, evaluation):
        'MessageName[symbol_Symbol, tag_String]'

        pattern = Expression('MessageName', symbol, tag)
        return evaluation.definitions.get_value(
            symbol.get_name(), 'Messages', pattern, evaluation)

    def post_parse(self, expr):
        if len(expr.leaves) == 2 and expr.leaves[1].is_symbol():
            msg = expr.leaves[1].get_name()
            return Expression('MessageName', expr.leaves[0], String(msg))
        else:
            return expr


class General(Builtin):
    """
    'General' is a symbol to which all general-purpose messages are assigned.
    >> General::argr
     = `1` called with 1 argument; `2` arguments are expected.
    >> Message[Rule::argr, Rule, 2]
     : Rule called with 1 argument; 2 arguments are expected.
    """

    messages = {
        'argb': ("`1` called with `2` arguments; "
                 "between `3` and `4` arguments are expected."),
        'argct': "`1` called with `2` arguments.",
        'argctu': "`1` called with 1 argument.",
        'argr': "`1` called with 1 argument; `2` arguments are expected.",
        'argrx': "`1` called with `2` arguments; `3` arguments are expected.",
        'argx': "`1` called with `2` arguments; 1 argument is expected.",
        'argt': ("`1` called with `2` arguments; "
                 "`3` or `4` arguments are expected."),
        'argtu': (
            "`1` called with 1 argument; `2` or `3` arguments are expected."),
        'boxfmt': "`1` is not a box formatting type.",
        'color': "`1` is not a valid color or gray-level specification.",
        'divz': "The argument `1` should be nonzero.",
        'exact': "Argument `1` is not an exact number.",
        'fnsym': ("First argument in `1` is not a symbol "
                  "or a string naming a symbol."),
        'heads': "Heads `1` and `2` are expected to be the same.",
        'ilsnn': ("Single or list of non-negative integers expected at "
                  "position `1`."),
        'indet': "Indeterminate expression `1` encountered.",
        'innf': "Non-negative integer or Infinity expected at position `1`.",
        'int': "Integer expected.",
        'intp': "Positive integer expected.",
        'intnn': "Non-negative integer expected.",
        'iterb': "Iterator does not have appropriate bounds.",
        'ivar': "`1` is not a valid variable.",
        'level': ("Level specification `1` is not of the form n, "
                  "{n}, or {m, n}."),
        'locked': "Symbol `1` is locked.",
        'matsq': "Argument `1` is not a non-empty square matrix.",
        'noopen': "Cannot open `1`.",
        'nord': "Invalid comparison with `1` attempted.",
        'normal': "Nonatomic expression expected.",
        'noval': (
            "Symbol `1` in part assignment does not have an immediate value."),
        'openx': "`1` is not open.",
        'optb': "Optional object `1` in `2` is not a single blank.",
        'ovfl': "Overflow occured in computation.",
        'partd': "Part specification is longer than depth of object.",
        'partw': "Part `1` of `2` does not exist.",
        'plld': "Endpoints in `1` must be distinct machine-size real numbers.",
        'plln': "Limiting value `1` in `2` is not a machine-size real number.",
        'pspec': ("Part specification `1` is neither an integer nor "
                  "a list of integer."),
        'seqs': "Sequence specification expected, but got `1`.",
        'setp': "Part assignment to `1` could not be made",
        'setps': "`1` in the part assignment is not a symbol.",
        'span': "`1` is not a valid Span specification.",
        'stream': "`1` is not string, InputStream[], or OutputStream[]",
        'string': "String expected.",
        'sym': "Argument `1` at position `2` is expected to be a symbol.",
        'tag': "Rule for `1` can only be attached to `2`.",
        'vrule': ("Cannot set `1` to `2`, "
                  "which is not a valid list of replacement rules."),
        'write': "Tag `1` in `2` is Protected.",
        'wrsym': "Symbol `1` is Protected.",

        # Self-defined messages
        #'rep': "`1` is not a valid replacement rule.",
        'options': "`1` is not a valid list of option rules.",
        'timeout': "Timeout reached.",
        'syntax': "`1`",
        'invalidargs': "Invalid arguments.",

        'notboxes': "`1` is not a valid box structure.",
    }


class Print(Builtin):
    """
    >> Print["Hello world!"]
     | Hello world!
    >> Print["The answer is ", 7 * 6, "."]
     | The answer is 42.
    """

    def apply(self, expr, evaluation):
        'Print[expr__]'

        expr = expr.get_sequence()
        expr = Expression('Row', Expression('List', *expr))
        evaluation.print_out(expr)
        return Symbol('Null')


class FullForm(Builtin):
    """
    >> FullForm[a + b * c]
     = Plus[a, Times[b, c]]
    >> FullForm[2/3]
     = Rational[2, 3]
    >> FullForm["A string"]
     = "A string"
    """


class StandardForm(Builtin):
    u"""
    >> StandardForm[a + b * c]
     = a + b c
    >> StandardForm["A string"]
     = A string
    'StandardForm' is used by default:
    >> "A string"
     = A string
    >> f'[x]
     = f'[x]
    """


class InputForm(Builtin):
    """
    >> InputForm[a + b * c]
     = a + b*c
    >> InputForm["A string"]
     = "A string"
    >> InputForm[f'[x]]
     = Derivative[1][f][x]
    >> InputForm[Derivative[1, 0][f][x]]
     = Derivative[1, 0][f][x]
    #> InputForm[2 x ^ 2 + 4z!]
     = 2*x^2 + 4*z!
    """


class OutputForm(Builtin):
    """
    >> OutputForm[f'[x]]
     = f'[x]
    >> OutputForm[Derivative[1, 0][f][x]]
     = Derivative[1, 0][f][x]
    >> OutputForm["A string"]
     = A string
    >> OutputForm[Graphics[Rectangle[]]]
     = -Graphics-
    """


class MathMLForm(Builtin):
    u"""
    >> MathMLForm[HoldForm[Sqrt[a^3]]]
     = <math><msqrt><msup><mi>a</mi> <mn>3</mn></msup></msqrt></math>

    ## Test cases for Unicode
    #> MathMLForm[\\[Mu]]
     = <math><mi>\u03bc</mi></math>

    #> MathMLForm[Graphics[Text["\u03bc"]]]
     = <math><mtable><mtr><mtd><svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg"
     .  version="1.0" width="..." height="..." viewBox="..."><foreignObject x="..." y="..." ox="0.000000" oy="0.000000" style="stroke: none; fill: none; color: rgb(0.000000%, 0.000000%, 0.000000%)"><math><mtext>\u03bc</mtext></math></foreignObject></svg></mtd></mtr></mtable></math>

    ## The <mo> should contain U+2062 INVISIBLE TIMES
    #> MathMLForm[MatrixForm[{{2*a, 0},{0,0}}]]
     = <math><mrow><mo>(</mo> <mtable columnalign="center">
     . <mtr><mtd columnalign="center"><mrow><mn>2</mn> <mo form="prefix" lspace="0" rspace="0.2em">\u2062</mo> <mi>a</mi></mrow></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr>
     . <mtr><mtd columnalign="center"><mn>0</mn></mtd><mtd columnalign="center"><mn>0</mn></mtd></mtr>
     . </mtable> <mo>)</mo></mrow></math>
    """

    def apply_mathml(self, expr, evaluation):
        'MakeBoxes[expr_, MathMLForm]'

        boxes = MakeBoxes(expr).evaluate(evaluation)
        try:
            xml = boxes.boxes_to_xml(evaluation=evaluation)
        except BoxError:
            evaluation.message('General', 'notboxes', String('%s' % boxes))
            xml = ''
        # mathml = '<math><mstyle displaystyle="true">%s</mstyle></math>' % xml
        # #convert_box(boxes)
        mathml = '<math>%s</math>' % xml  # convert_box(boxes)
        return Expression('RowBox', Expression('List', String(mathml)))


class TeXForm(Builtin):
    r"""
    >> TeXForm[HoldForm[Sqrt[a^3]]]
     = \sqrt{a^3}

    #> {"hi","you"} //InputForm //TeXForm
     = \left\{\text{"hi"}, \text{"you"}\right\}
    """

    def apply_tex(self, expr, evaluation):
        'MakeBoxes[expr_, TeXForm]'

        boxes = MakeBoxes(expr).evaluate(evaluation)
        try:
            tex = boxes.boxes_to_tex(evaluation=evaluation)

            # Replace multiple newlines by a single one e.g. between asy-blocks
            tex = MULTI_NEWLINE_RE.sub('\n', tex)

            tex = tex.replace(u' \uF74c', u' \, d')  # tmp hack for Integrate
        except BoxError:
            evaluation.message('General', 'notboxes', String('%s' % boxes))
            tex = ''
        return Expression('RowBox', Expression('List', String(tex)))


class Style(Builtin):
    options = {
        'ImageSizeMultipliers': 'Automatic',
    }

    rules = {
        'MakeBoxes[Style[expr_, OptionsPattern[Style]], f_]': (
            'StyleBox[MakeBoxes[expr, f], '
            'ImageSizeMultipliers -> OptionValue[ImageSizeMultipliers]]'),
    }


class Precedence(Builtin):
    """
    <dl>
    <dt>'Precedence[$op$]'
        <dd>returns the precedence of the built-in operator $op$.
    </dl>

    >> Precedence[Plus]
     = 310.
    >> Precedence[Plus] < Precedence[Times]
     = True

    Unknown symbols have precedence 670:
    >> Precedence[f]
     = 670.
    Other expressions have precedence 1000:
    >> Precedence[a + b]
     = 1000.
    """

    def apply(self, expr, evaluation):
        'Precedence[expr_]'

        from mathics.builtin import builtins

        name = expr.get_name()
        precedence = 1000
        if name:
            builtin = builtins.get(name)
            if builtin is not None and isinstance(builtin, Operator):
                precedence = builtin.precedence
            else:
                precedence = 670
        return Real(precedence)

########NEW FILE########
__FILENAME__ = integer
# -*- coding: utf8 -*-

"""
Integer functions
"""

import sympy

from mathics.builtin.base import Builtin
from mathics.core.expression import Integer


class Floor(Builtin):
    """
    <dl>
    <dt>'Floor[$x$]'
        <dd>gives the smallest integer less than or equal to $x$.
    <dt>'Floor[$x$, $a$]'
        <dd>gives the smallest multiple of $a$ less than or equal to $x$.
    </dl>

    >> Floor[10.4]
     = 10
    >> Floor[10/3]
     = 3
    >> Floor[10]
     = 10
    >> Floor[21, 2]
     = 20
    >> Floor[2.6, 0.5]
     = 2.5
    >> Floor[-10.4]
     = -11

    For negative $a$, the smallest multiple of $a$ greater than or equal to $x$
    is returned.
    >> Floor[10.4, -1]
     = 11
    >> Floor[-10.4, -1]
     = -10
    """

    rules = {
        'Floor[x_, a_]': 'Floor[x / a] * a',
        'Floor[z_Complex]': 'Complex[Floor[Re[z]], Floor[Im[z]]]',
    }

    def apply_real(self, x, evaluation):
        'Floor[x_?RealNumberQ]'

        x = x.value
        if x < 0:
            floor = - sympy.Integer(abs(x))
            if x != floor:
                floor -= 1
        else:
            floor = sympy.Integer(x)
        return Integer(floor)


class IntegerLength(Builtin):
    """
    >> IntegerLength[123456]
     = 6
    >> IntegerLength[10^10000]
     = 10001
    >> IntegerLength[-10^1000]
     = 1001
    'IntegerLength' with base 2:
    >> IntegerLength[8, 2]
     = 4
    Check that 'IntegerLength' is correct for the first 100 powers of 10:
    >> IntegerLength /@ (10 ^ Range[100]) == Range[2, 101]
     = True
    The base must be greater than 1:
    >> IntegerLength[3, -2]
     : Base -2 is not an integer greater than 1.
     = IntegerLength[3, -2]
    """

    rules = {
        'IntegerLength[n_]': 'IntegerLength[n, 10]',
    }

    messages = {
        'base': "Base `1` is not an integer greater than 1.",
    }

    def apply(self, n, b, evaluation):
        'IntegerLength[n_, b_]'

        # Use interval arithmetic to account for "right" rounding

        n, b = n.get_int_value(), b.get_int_value()
        if n is None or b is None:
            evaluation.message('IntegerLength', 'int')
            return
        if b <= 1:
            evaluation.message('IntegerLength', 'base', b)
            return

        result = sympy.Integer(sympy.log(abs(n), b)) + 1
        return Integer(result)

########NEW FILE########
__FILENAME__ = linalg
# -*- coding: utf8 -*-

"""
Linear algebra
"""

import sympy

from mathics.builtin.base import Builtin
from mathics.core.convert import from_sympy
from mathics.core.expression import Expression, Integer


def matrix_data(m):
    if not m.has_form('List', None):
        return None
    if not all(leaf.has_form('List', None) for leaf in m.leaves):
        return None
    return [[item.to_sympy() for item in row.leaves] for row in m.leaves]


def to_sympy_matrix(data, **kwargs):
    if not isinstance(data, list):
        data = matrix_data(data)
    try:
        return sympy.Matrix(data)
    except (TypeError, AssertionError, ValueError):
        return None


class Det(Builtin):
    u"""
    <dl>
    <dt>'Det[$m$]'
        <dd>computes the determinant of the matrix $m$.
    </dl>

    >> Det[{{1, 1, 0}, {1, 0, 1}, {0, 1, 1}}]
     = -2

    Symbolic determinant:
    >> Det[{{a, b, c}, {d, e, f}, {g, h, i}}]
     = a e i - a f h - b d i + b f g + c d h - c e g
    """

    def apply(self, m, evaluation):
        'Det[m_]'

        matrix = to_sympy_matrix(m)
        if matrix is None or matrix.cols != matrix.rows or matrix.cols == 0:
            return evaluation.message('Det', 'matsq', m)
        det = matrix.det()
        return from_sympy(det)


class Inverse(Builtin):
    """
    <dl>
    <dt>'Inverse[$m$]'
        <dd>computes the inverse of the matrix $m$.
    </dl>

    >> Inverse[{{1, 2, 0}, {2, 3, 0}, {3, 4, 1}}]
     = {{-3, 2, 0}, {2, -1, 0}, {1, -2, 1}}
    >> Inverse[{{1, 0}, {0, 0}}]
     : The matrix {{1, 0}, {0, 0}} is singular.
     = Inverse[{{1, 0}, {0, 0}}]

    >> Inverse[{{1, 0, 0}, {0, Sqrt[3]/2, 1/2}, {0,-1 / 2, Sqrt[3]/2}}]
    = {{1, 0, 0}, {0, Sqrt[3] / 2, -1 / 2}, {0, 1 / 2, Sqrt[3] / 2}}
    """

    messages = {
        'sing': "The matrix `1` is singular.",
    }

    def apply(self, m, evaluation):
        'Inverse[m_]'

        matrix = to_sympy_matrix(m)
        if matrix is None or matrix.cols != matrix.rows or matrix.cols == 0:
            return evaluation.message('Inverse', 'matsq', m)
        if matrix.det() == 0:
            return evaluation.message('Inverse', 'sing', m)
        inv = matrix.inv()
        return from_sympy(inv)


class LinearSolve(Builtin):
    """
    <dl>
    <dt>'LinearSolve[$matrix$, $right$]'
        <dd>solves the linear equation system '$matrix$ . x = $right$' and returns one corresponding solution 'x'.
    </dl>

    >> LinearSolve[{{1, 1, 0}, {1, 0, 1}, {0, 1, 1}}, {1, 2, 3}]
     = {0, 1, 2}
    Test the solution:
    >> {{1, 1, 0}, {1, 0, 1}, {0, 1, 1}} . {0, 1, 2}
     = {1, 2, 3}
    If there are several solutions, one arbitrary solution is returned:
    >> LinearSolve[{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, {1, 1, 1}]
     = {-1, 1, 0}
    Infeasible systems are reported:
    >> LinearSolve[{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, {1, -2, 3}]
     : Linear equation encountered that has no solution.
     = LinearSolve[{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}, {1, -2, 3}]
    """

    messages = {
        'lslc': ("Coefficient matrix and target vector(s) or matrix "
                 "do not have the same dimensions."),
        'nosol': "Linear equation encountered that has no solution.",
    }

    def apply(self, m, b, evaluation):
        'LinearSolve[m_, b_]'

        matrix = matrix_data(m)
        if matrix is None:
            return
        if not b.has_form('List', None):
            return
        if len(b.leaves) != len(matrix):
            return evaluation.message('LinearSolve', 'lslc')
        system = [mm + [v] for mm, v in zip(matrix, b.leaves)]
        system = to_sympy_matrix(system)
        if system is None:
            return
        syms = [sympy.Dummy('LinearSolve_var%d' % k)
                for k in range(system.cols - 1)]
        sol = sympy.solve_linear_system(system, *syms)
        if sol:
            # substitute 0 for variables that are not in result dictionary
            free_vars = dict((sym, sympy.Integer(
                0)) for sym in syms if sym not in sol)
            sol.update(free_vars)
            sol = [(sol[sym] if sym in free_vars else sol[sym].subs(free_vars))
                   for sym in syms]
            return from_sympy(sol)
        else:
            return evaluation.message('LinearSolve', 'nosol')


class NullSpace(Builtin):
    """
    <dl>
    <dt>'NullSpace[$matrix$]'
        <dd>returns a list of vectors that span the nullspace of $matrix$.
    </dl>

    >> NullSpace[{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}]
     = {{1, -2, 1}}

    >> A = {{1, 1, 0}, {1, 0, 1}, {0, 1, 1}};
    >> NullSpace[A]
     = {}
    >> MatrixRank[A]
     = 3
    """

    def apply(self, m, evaluation):
        'NullSpace[m_]'

        matrix = to_sympy_matrix(m)
        if matrix is None:
            return
        nullspace = matrix.nullspace()
        # convert n x 1 matrices to vectors
        nullspace = [list(vec) for vec in nullspace]
        return from_sympy(nullspace)


class RowReduce(Builtin):
    """
    <dl>
    <dt>'RowReduce[$matrix$]'
        <dd>returns the reduced row-echelon form of $matrix$.
    </dl>

    >> RowReduce[{{1, 0, a}, {1, 1, b}}]
     = {{1, 0, a}, {0, 1, -a + b}}

    >> RowReduce[{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}] // MatrixForm
     = 1   0   -1
     .
     . 0   1   2
     .
     . 0   0   0

    #> RowReduce[{{1, 0}, {0}}]
     = RowReduce[{{1, 0}, {0}}]
    """

    def apply(self, m, evaluation):
        'RowReduce[m_]'

        matrix = to_sympy_matrix(m)
        if matrix is None:
            return
        reduced = matrix.rref()[0]
        return from_sympy(reduced)


class MatrixRank(Builtin):
    """
    <dl>
    <dt>'MatrixRank[$matrix$]'
        <dd>returns the rank of $matrix$.
    </dl>

    >> MatrixRank[{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}}]
     = 2
    >> MatrixRank[{{1, 1, 0}, {1, 0, 1}, {0, 1, 1}}]
     = 3
    >> MatrixRank[{{a, b}, {3 a, 3 b}}]
     = 1
    """

    def apply(self, m, evaluation):
        'MatrixRank[m_]'

        matrix = to_sympy_matrix(m)
        if matrix is None:
            return
        rank = len(matrix.rref()[1])
        return Integer(rank)


class Eigenvalues(Builtin):
    """
    <dl>
    <dt>'Eigenvalues[$m$]'
        <dd>computes the eigenvalues of the matrix $m$.
    </dl>

    >> Eigenvalues[{{1, 1, 0}, {1, 0, 1}, {0, 1, 1}}]
     = {2, -1, 1}

    >> Eigenvalues[{{Cos[theta],Sin[theta],0},{-Sin[theta],Cos[theta],0},{0,0,1}}]
     = {Cos[theta] + Sqrt[-1 + Cos[theta] ^ 2], Cos[theta] - Sqrt[-1 + Cos[theta] ^ 2], 1}
    """

    def apply(self, m, evaluation):
        'Eigenvalues[m_]'

        matrix = to_sympy_matrix(m)
        if matrix is None or matrix.cols != matrix.rows or matrix.cols == 0:
            return evaluation.message('Eigenvalues', 'matsq', m)
        eigenvalues = matrix.eigenvals()
        eigenvalues = sorted(eigenvalues.iteritems(),
                             key=lambda (v, c): (abs(v), -v), reverse=True)
        result = []
        for val, count in eigenvalues:
            result.extend([val] * count)
        return from_sympy(result)


class Eigenvectors(Builtin):
    """
    <dl>
    <dt>'Eigenvectors[$m$]'
        <dd>computes the eigenvectors of the matrix $m$.
    </dl>

    >> Eigenvectors[{{1, 1, 0}, {1, 0, 1}, {0, 1, 1}}]
     = {{1, 1, 1}, {1, -2, 1}, {-1, 0, 1}}
    >> Eigenvectors[{{1, 0, 0}, {0, 1, 0}, {0, 0, 0}}]
     = {{0, 1, 0}, {1, 0, 0}, {0, 0, 1}}
    >> Eigenvectors[{{2, 0, 0}, {0, -1, 0}, {0, 0, 0}}]
     = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}
    >> Eigenvectors[{{0.1, 0.2}, {0.8, 0.5}}]
     = {{0.309016994374947, 1.}, {-0.809016994374947, 1.}}

    #> Eigenvectors[{{-2, 1, -1}, {-3, 2, 1}, {-1, 1, 0}}]
     = {{1 / 3, 7 / 3, 1}, {1, 1, 0}, {0, 0, 0}}
    """

    messages = {
        'eigenvecnotimplemented': (
            "Eigenvectors is not yet implemented for the matrix `1`."),
    }

    # TODO: Normalise the eigenvectors

    def apply(self, m, evaluation):
        'Eigenvectors[m_]'

        matrix = to_sympy_matrix(m)
        if matrix is None or matrix.cols != matrix.rows or matrix.cols == 0:
            return evaluation.message('Eigenvectors', 'matsq', m)
        # sympy raises an error for some matrices that Mathematica can compute.
        try:
            eigenvects = matrix.eigenvects()
        except NotImplementedError:
            return evaluation.message(
                'Eigenvectors', 'eigenvecnotimplemented', m)

        # The eigenvectors are given in the same order as the eigenvalues.
        eigenvects = sorted(eigenvects, key=lambda (
            val, c, vect): (abs(val), -val), reverse=True)
        result = []
        for val, count, basis in eigenvects:
            # Select the i'th basis vector, convert matrix to vector,
            # and convert from sympy
            vects = [from_sympy(list(b)) for b in basis]

            # This follows Mathematica convention better; higher indexed pivots
            # are outputted first. e.g. {{0,1},{1,0}} instead of {{1,0},{0,1}}
            vects.reverse()

            # Add the vectors to results
            result.extend(vects)
        result.extend([Expression('List', *(
            [0] * matrix.rows))] * (matrix.rows - len(result)))
        return Expression('List', *result)

########NEW FILE########
__FILENAME__ = lists
# -*- coding: utf8 -*-

"""
List functions
"""

from mathics.builtin.base import (
    Builtin, Test, InvalidLevelspecError,
    PartError, PartDepthError, PartRangeError, SympyFunction)
from mathics.builtin.scoping import dynamic_scoping
from mathics.core.expression import Expression, String, Symbol, Integer, Number
from mathics.core.evaluation import BreakInterrupt, ContinueInterrupt
from mathics.core.rules import Pattern
from mathics.core.convert import from_sympy
from mathics.builtin.algebra import cancel

import sympy


class List(Builtin):
    """
    'List' is the head of lists.
    >> Head[{1, 2, 3}]
     = List

    Lists can be nested:
    >> {{a, b, {c, d}}}
     = {{a, b, {c, d}}}
    """

    attributes = ('Locked',)

    def apply_makeboxes(self, items, f, evaluation):
        '''MakeBoxes[{items___},
            f:StandardForm|TraditionalForm|OutputForm|InputForm]'''

        items = items.get_sequence()
        return Expression(
            'RowBox', Expression('List', *list_boxes(items, f, "{", "}")))


class ListQ(Test):
    """
    <dl>
    <dt>'ListQ[$expr$]'
        <dd>tests whether $expr$ is a 'List'.
    </dl>

    >> ListQ[{1, 2, 3}]
     = True
    >> ListQ[{{1, 2}, {3, 4}}]
     = True
    >> ListQ[x]
     = False
    """

    def test(self, expr):
        return expr.get_head_name() == 'List'


class NotListQ(Test):
    def test(self, expr):
        return expr.get_head_name() != 'List'


def list_boxes(items, f, open=None, close=None):
    result = [Expression('MakeBoxes', item, f) for item in items]
    if f.get_name() in ('OutputForm', 'InputForm'):
        sep = ", "
    else:
        sep = ","
    result = riffle(result, String(sep))
    if len(items) > 1:
        result = Expression('RowBox', Expression('List', *result))
    elif items:
        result = result[0]
    if result:
        result = [result]
    else:
        result = []
    if open is not None and close is not None:
        return [String(open)] + result + [String(close)]
    else:
        return result


class Length(Builtin):
    """
    >> Length[{1, 2, 3}]
     = 3
    'Length' operates on the 'FullForm' of expressions:
    >> Length[Exp[x]]
     = 2
    >> FullForm[Exp[x]]
     = Power[E, x]
    The length of atoms is 0:
    >> Length[a]
     = 0
    Note that rational and complex numbers are atoms, although their 'FullForm' might suggest the opposite:
    >> Length[1/3]
     = 0
    >> FullForm[1/3]
     = Rational[1, 3]
    """

    def apply(self, expr, evaluation):
        'Length[expr_]'

        if expr.is_atom():
            return Integer(0)
        else:
            return Integer(len(expr.leaves))


class Span(Builtin):
    """
    'Span' is the head of span ranges like '1;;3'.
    >> ;; // FullForm
     = Span[1, All]
    >> 1;;4;;2 // FullForm
     = Span[1, 4, 2]
    >> 2;;-2 // FullForm
     = Span[2, -2]
    >> ;;3 // FullForm
     = Span[1, 3]

    ## Test parsing : 8 cases to consider
    #> a ;; b ;; c // FullForm
     = Span[a, b, c]
    #>   ;; b ;; c // FullForm
     = Span[1, b, c]
    #> a ;;   ;; c // FullForm
     = Span[a, All, c]
    #>   ;;   ;; c // FullForm
     = Span[1, All, c]
    #> a ;; b      // FullForm
     = Span[a, b]
    #>   ;; b      // FullForm
     = Span[1, b]
    #> a ;;        // FullForm
     = Span[a, All]
    #>   ;;        // FullForm
     = Span[1, All]
    """

    # operator = ';;'
    # precedence = 305
    pass


def join_lists(lists):
    new_list = []
    for list in lists:
        new_list.extend(list)
    return new_list


def get_part(list, indices):
    " Simple part extraction. indices must be a list of python integers. "

    def rec(cur, rest):
        if rest:
            pos = rest[0]
            if cur.is_atom():
                raise PartDepthError
            try:
                if pos > 0:
                    part = cur.leaves[pos - 1]
                elif pos == 0:
                    part = cur.head
                else:
                    part = cur.leaves[pos]
            except IndexError:
                raise PartRangeError
            return rec(part, rest[1:])
        else:
            return cur
    return rec(list, indices)


def set_part(list, indices, new):
    " Simple part replacement. indices must be a list of python integers. "

    def rec(cur, rest):
        if len(rest) > 1:
            pos = rest[0]
            if cur.is_atom():
                raise PartDepthError
            try:
                if pos > 0:
                    part = cur.leaves[pos - 1]
                elif pos == 0:
                    part = cur.head
                else:
                    part = cur.leaves[pos]
            except IndexError:
                raise PartRangeError
            rec(part, rest[1:])
        elif len(rest) == 1:
            pos = rest[0]
            if cur.is_atom():
                raise PartDepthError
            try:
                if pos > 0:
                    cur.leaves[pos - 1] = new
                elif pos == 0:
                    cur.head = new
                else:
                    cur.leaves[pos] = new
            except IndexError:
                raise PartRangeError

    rec(list, indices)


def walk_parts(list_of_list, indices, evaluation, assign_list=None):
    list = list_of_list[0]

    # To get rid of duplicate entries (TODO: could be made faster!)
    list = list.copy()

    list.set_positions()
    list_of_list = [list]

    result = list.copy()
    result.set_positions()

    inner_list = [result]   # changed in loop

    list_of_result = [result]   # to be able to change it in replace_result

    def replace_item(all, item, new):
        if item.position is None:
            all[0] = new
        else:
            item.position.replace(new)

    for index in indices:
        if index.has_form('Span', None):
            if len(index.leaves) > 3:
                evaluation.message('Part', 'span', index)
                return False
            start = 1
            stop = None
            step = 1
            if len(index.leaves) > 0:
                start = index.leaves[0].get_int_value()
            if len(index.leaves) > 1:
                stop = index.leaves[1].get_int_value()
                if stop is None:
                    if index.leaves[1].get_name() == 'All':
                        stop = None
                    else:
                        evaluation.message('Part', 'span', index)
                        return False
            if len(index.leaves) > 2:
                step = index.leaves[2].get_int_value()
            if start is None or step is None:
                evaluation.message('Part', 'span', index)
                return False
            start, stop = python_seq(start, stop)
            for inner in inner_list:
                if inner.is_atom():
                    evaluation.message('Part', 'partd')
                    return False
                if stop is None:
                    inner.leaves = inner.leaves[start::step]
                else:
                    inner.leaves = inner.leaves[start:stop:step]
                inner.original = None
                inner.set_positions()
            inner_list = join_lists(inner.leaves for inner in inner_list)
        elif index.has_form('List', None):
            index_list = index
            indices = []
            for index in index_list.leaves:
                if not isinstance(index, Integer):
                    evaluation.message('Part', 'pspec', index_list)
                    return False
                index = index.value
                if index > 0:
                    py_index = index - 1
                else:
                    py_index = index
                indices.append((py_index, index))

            for inner in inner_list:
                if inner.is_atom():
                    evaluation.message('Part', 'partd')
                    return False

                new_leaves = []
                for py_index, index in indices:
                    try:
                        if index != 0:
                            part = inner.leaves[py_index]
                        else:
                            part = inner.head
                        new_leaves.append(part)
                    except IndexError:
                        evaluation.message('Part', 'partw', index, inner)
                        return False
                inner.leaves = new_leaves
                inner.original = None
                inner.set_positions()
            inner_list = join_lists(inner.leaves for inner in inner_list)
        elif isinstance(index, Integer):
            index = index.value
            if index > 0:
                py_index = index - 1
            else:
                py_index = index
            for inner in inner_list:
                if inner.is_atom():
                    evaluation.message('Part', 'partd')
                    return False
                try:
                    if index != 0:
                        part = inner.leaves[py_index]
                    else:
                        part = inner.head
                except IndexError:
                    evaluation.message('Part', 'partw', index, inner)
                    return False
                replace_item(list_of_result, inner, part)
                part.set_positions()
            inner_list = [inner.leaves[py_index] for inner in inner_list]

    result = list_of_result[0]

    if assign_list is not None:
        def process_level(item, assignment):
            if item.is_atom():
                replace_item(list_of_list, item.original, assignment)
            elif (assignment.get_head_name() != 'List' or
                  len(item.leaves) != len(assignment.leaves)):
                if item.original:
                    replace_item(list_of_list, item.original, assignment)
                else:
                    for leaf in item.leaves:
                        process_level(leaf, assignment)
            else:
                for sub_item, sub_assignment in zip(item.leaves,
                                                    assignment.leaves):
                    process_level(sub_item, sub_assignment)
        process_level(result, assign_list)
        return list_of_list[0]
    else:
        return result


def is_in_level(current, depth, start=1, stop=None):
    if stop is None:
        stop = current
    if start < 0:
        start += current + depth + 1
    if stop < 0:
        stop += current + depth + 1
    return start <= current <= stop


def walk_levels(expr, start=1, stop=None, current=0, heads=False,
                callback=lambda l: l, include_pos=False, cur_pos=[]):
    if expr.is_atom():
        depth = 0
        new_expr = expr
    else:
        depth = 0
        if heads:
            head, head_depth = walk_levels(
                expr.head, start, stop, current + 1, heads, callback,
                include_pos, cur_pos + [0])
        else:
            head = expr.head
        leaves = []
        for index, leaf in enumerate(expr.leaves):
            leaf, leaf_depth = walk_levels(
                leaf, start, stop, current + 1, heads, callback, include_pos,
                cur_pos + [index + 1])
            if leaf_depth + 1 > depth:
                depth = leaf_depth + 1
            leaves.append(leaf)
        new_expr = Expression(head, *leaves)
    if is_in_level(current, depth, start, stop):
        if include_pos:
            new_expr = callback(new_expr, cur_pos)
        else:
            new_expr = callback(new_expr)
    return new_expr, depth


def python_levelspec(levelspec):
    def value_to_level(expr):
        value = expr.get_int_value()
        if value is None:
            if expr == Expression('DirectedInfinity', 1):
                return None
            else:
                raise InvalidLevelspecError
        else:
            return value

    if levelspec.has_form('List', None):
        values = [value_to_level(leaf) for leaf in levelspec.leaves]
        if len(values) == 1:
            return values[0], values[0]
        elif len(values) == 2:
            return values[0], values[1]
        else:
            raise InvalidLevelspecError
    else:
        return 1, value_to_level(levelspec)


class Level(Builtin):
    """
    <dl>
    <dt>'Level[$expr$, $levelspec$]'
        <dd>gives a list of all subexpressions of $expr$ at the level(s) specified by $levelspec$.
    </dl>

    Level uses standard level specifications:

    <dl>
    <dt>$n$
        <dd>levels 1 through $n$
    <dt>'Infinity'
        <dd>all levels from level 1
    <dt>'{$n$}'
        <dd>level $n$ only
    <dt>'{$m$, $n$}'
        <dd>levels $m$ through $n$
    </dl>

    Level 0 corresponds to the whole expression.

    A negative level '-$n$' consists of parts with depth $n$.

    Level -1 is the set of atoms in an expression:
    >> Level[a + b ^ 3 * f[2 x ^ 2], {-1}]
     = {a, b, 3, 2, x, 2}

    >> Level[{{{{a}}}}, 3]
     = {{a}, {{a}}, {{{a}}}}
    >> Level[{{{{a}}}}, -4]
     = {{{{a}}}}
    >> Level[{{{{a}}}}, -5]
     = {}

    >> Level[h0[h1[h2[h3[a]]]], {0, -1}]
     = {a, h3[a], h2[h3[a]], h1[h2[h3[a]]], h0[h1[h2[h3[a]]]]}

    Use the option 'Heads -> True' to include heads:
    >> Level[{{{{a}}}}, 3, Heads -> True]
     = {List, List, List, {a}, {{a}}, {{{a}}}}
    >> Level[x^2 + y^3, 3, Heads -> True]
     = {Plus, Power, x, 2, x ^ 2, Power, y, 3, y ^ 3}

    >> Level[a ^ 2 + 2 * b, {-1}, Heads -> True]
     = {Plus, Power, a, 2, Times, 2, b}
    >> Level[f[g[h]][x], {-1}, Heads -> True]
     = {f, g, h, x}
    >> Level[f[g[h]][x], {-2, -1}, Heads -> True]
     = {f, g, h, g[h], x, f[g[h]][x]}
    """

    options = {
        'Heads': 'False',
    }

    def apply(self, expr, ls, evaluation, options={}):
        'Level[expr_, ls_, OptionsPattern[Level]]'

        try:
            start, stop = python_levelspec(ls)
        except InvalidLevelspecError:
            evaluation.message('Level', 'level', ls)
            return
        result = []

        def callback(level):
            result.append(level)
            return level

        heads = self.get_option(options, 'Heads', evaluation).is_true()
        walk_levels(expr, start, stop, heads=heads, callback=callback)
        return Expression('List', *result)


class LevelQ(Test):
    """
    <dl>
    <dt>'LevelQ[$expr$]'
        <dd>tests whether $expr$ is a valid level specification.
    </dl>

    >> LevelQ[2]
     = True
    >> LevelQ[{2, 4}]
     = True
    >> LevelQ[Infinity]
     = True
    >> LevelQ[a + b]
     = False
    """

    def test(self, ls):
        try:
            start, stop = python_levelspec(ls)
            return True
        except InvalidLevelspecError:
            return False


def python_seq(start, stop):
    if start > 0:
        start -= 1
    if stop is not None and stop < 0:
        stop += 1
        if stop == 0:
            stop = None
    return start, stop


def convert_seq(seq):
    start, stop, step = 1, None, 1
    name = seq.get_name()
    value = seq.get_int_value()
    if name == 'All':
        pass
    elif name == 'None':
        stop = 0
    elif value is not None:
        if value > 0:
            stop = value
        else:
            start = value
    elif seq.has_form('List', 1, 2, 3):
        if len(seq.leaves) == 1:
            start = stop = seq.leaves[0].get_int_value()
            if stop is None:
                return False
        else:
            start = seq.leaves[0].get_int_value()
            stop = seq.leaves[1].get_int_value()
            if start is None or stop is None:
                return False
        if len(seq.leaves) == 3:
            step = seq.leaves[2].get_int_value()
            if step is None:
                return False
    else:
        return False
    return (start, stop, step)


class Part(Builtin):
    """
    >> A = {a, b, c, d};
    >> A[[3]]
     = c

    Negative indizes count from the end:
    >> {a, b, c}[[-2]]
     = b

    'Part' can be applied on any expression, not necessarily lists.
    >> (a + b + c)[[2]]
     = b
    '$expr$[[0]]' gives the head of $expr$:
    >> (a + b + c)[[0]]
     = Plus

    Parts of nested lists:
    >> M = {{a, b}, {c, d}};
    >> M[[1, 2]]
     = b

    You can use 'Span' to specify a range of parts:
    >> {1, 2, 3, 4}[[2;;4]]
     = {2, 3, 4}
    >> {1, 2, 3, 4}[[2;;-1]]
     = {2, 3, 4}

    A list of parts extracts elements at certain indices:
    >> {a, b, c, d}[[{1, 3, 3}]]
     = {a, c, c}

    Get a certain column of a matrix:
    >> B = {{a, b, c}, {d, e, f}, {g, h, i}};
    >> B[[;;, 2]]
     = {b, e, h}
    Extract a submatrix of 1st and 3rd row and the two last columns:
    >> B = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
    >> B[[{1, 3}, -2;;-1]]
     = {{2, 3}, {8, 9}}

    Further examples:
    >> (a+b+c+d)[[-1;;-2]]
     = 0
    >> x[[2]]
     : Part specification is longer than depth of object.
     = x[[2]]

    Assignments to parts are possible:
    >> B[[;;, 2]] = {10, 11, 12}
     = {10, 11, 12}
    >> B
     = {{1, 10, 3}, {4, 11, 6}, {7, 12, 9}}
    >> B[[;;, 3]] = 13
     = 13
    >> B
     = {{1, 10, 13}, {4, 11, 13}, {7, 12, 13}}
    >> B[[1;;-2]] = t;
    >> B
     = {t, t, {7, 12, 13}}

    >> F = Table[i*j*k, {i, 1, 3}, {j, 1, 3}, {k, 1, 3}];
    >> F[[;; All, 2 ;; 3, 2]] = t;
    >> F
     = {{{1, 2, 3}, {2, t, 6}, {3, t, 9}}, {{2, 4, 6}, {4, t, 12}, {6, t, 18}}, {{3, 6, 9}, {6, t, 18}, {9, t, 27}}}
    >> F[[;; All, 1 ;; 2, 3 ;; 3]] = k;
    >> F
     = {{{1, 2, k}, {2, t, k}, {3, t, 9}}, {{2, 4, k}, {4, t, k}, {6, t, 18}}, {{3, 6, k}, {6, t, k}, {9, t, 27}}}

    Of course, part specifications have precedence over most arithmetic operations:
    >> A[[1]] + B[[2]] + C[[3]] // Hold // FullForm
     = Hold[Plus[Part[A, 1], Part[B, 2], Part[C, 3]]]
    """

    attributes = ('NHoldRest', 'ReadProtected')

    def apply_makeboxes(self, list, i, f, evaluation):
        '''MakeBoxes[Part[list_, i___],
            f:StandardForm|TraditionalForm|OutputForm|InputForm]'''

        i = i.get_sequence()
        list = Expression('MakeBoxes', list, f)
        if f.get_name() in ('OutputForm', 'InputForm'):
            open, close = "[[", "]]"
        else:
            open, close = u"\u301a", u"\u301b"
        indices = list_boxes(i, f, open, close)
        result = Expression('RowBox', Expression('List', list, *indices))
        return result

    def apply(self, list, i, evaluation):
        'Part[list_, i___]'

        indices = i.get_sequence()

        result = walk_parts([list], indices, evaluation)
        if result:
            return result


class Partition(Builtin):
    """
    <dl>
    <dt>'Partition[$list$, $n$]'
      <dd>partitions $list$ into sublists of length $n$.
    <dt>'Parition[$list$, $n$, $d$]'
      <dd>partitions $list$ into sublists of length $n$ which overlap $d$ indicies.
    </dl>

    >> Partition[{a, b, c, d, e, f}, 2]
     = {{a, b}, {c, d}, {e, f}}

    >> Partition[{a, b, c, d, e, f}, 3, 1]
     = {{a, b, c}, {b, c, d}, {c, d, e}, {d, e, f}}

    #> Partition[{a, b, c, d, e}, 2]
     = {{a, b}, {c, d}}
    """

    # TODO: Nested list length specifications
    """
    >> Partition[{{11, 12, 13}, {21, 22, 23}, {31, 32, 33}}, {2, 2}, 1]
     = {{{{11, 12}, {21, 22}}, {{12, 13}, {22, 23}}}, {{{21, 22}, {31, 32}}, {{22, 23}, {32, 33}}}}
    """

    rules = {
        'Parition[list_, n_, d_, k]': 'Partition[list, n, d, {k, k}]',
    }

    def chunks(self, l, n, d):
        assert n > 0 and d > 0
        return filter(lambda x: len(x) == n,
                      map(lambda i: l[i:i + n], xrange(0, len(l), d)))

    def apply_no_overlap(self, l, n, evaluation):
        'Partition[l_List, n_Integer]'
        # TODO: Error checking
        return Expression('List', *self.chunks(
            l.get_leaves(), n.get_int_value(), n.get_int_value()))

    def apply(self, l, n, d, evaluation):
        'Partition[l_List, n_Integer, d_Integer]'
        # TODO: Error checking
        return Expression('List', *self.chunks(
            l.get_leaves(), n.get_int_value(), d.get_int_value()))


class Extract(Builtin):
    """
    <dl>
    <dt>'Extract[$expr$, $list$]'
        <dd>extracts parts of $expr$ specified by $list$.
    <dt>'Extract[$expr$, {$list1$, $list2$, ...}]'
        <dd>extracts a list of parts.
    </dl>

    'Extract[$expr$, $i$, $j$, ...]' is equivalent to 'Part[$expr$, {$i$, $j$, ...}]'.

    >> Extract[a + b + c, {2}]
     = b
    >> Extract[{{a, b}, {c, d}}, {{1}, {2, 2}}]
     = {{a, b}, d}
    """

    attributes = ('NHoldRest',)

    rules = {
        'Extract[expr_, list_List]': 'Part[expr, Sequence @@ list]',
        'Extract[expr_, {lists___List}]': u'Extract[expr, #]& /@ {lists}',
    }


class First(Builtin):
    """
    <dl>
    <dt>'First[$expr$]'
        <dd>returns the first elment in $expr$.
    </dl>

    'First[$expr$]' is equivalent to '$expr$[[1]]'.

    >> First[{a, b, c}]
     = a
    >> First[a + b + c]
     = a
    >> First[x]
     : Nonatomic expression expected.
     = First[x]
    """

    def apply(self, expr, evaluation):
        'First[expr_]'

        if expr.is_atom():
            evaluation.message('First', 'normal')
            return
        return expr.leaves[0]


class Last(Builtin):
    """
    <dl>
    <dt>'Last[$expr$]'
        <dd>returns the last elment in $expr$.
    </dl>

    'Last[$expr$]' is equivalent to '$expr$[[-1]]'.

    >> Last[{a, b, c}]
     = c
    >> Last[x]
     : Nonatomic expression expected.
     = Last[x]
    """

    def apply(self, expr, evaluation):
        'Last[expr_]'

        if expr.is_atom():
            evaluation.message('Last', 'normal')
            return
        return expr.leaves[-1]


class Most(Builtin):
    """
    <dl>
    <dt>'Most[$expr$]'
        <dd>returns $expr$ with the last element removed.
    </dl>

    'Most[$expr$]' is equivalent to '$expr$[[;;-2]]'.

    >> Most[{a, b, c}]
     = {a, b}
    >> Most[a + b + c]
     = a + b
    >> Most[x]
     : Nonatomic expression expected.
     = Most[x]
    """

    def apply(self, expr, evaluation):
        'Most[expr_]'

        if expr.is_atom():
            evaluation.message('Most', 'normal')
            return
        return Expression(expr.head, *expr.leaves[:-1])


class Rest(Builtin):
    """
    <dl>
    <dt>'Rest[$expr$]'
        <dd>returns $expr$ with the first element removed.
    </dl>

    'Rest[$expr$]' is equivalent to '$expr$[[2;;]]'.

    >> Rest[{a, b, c}]
     = {b, c}
    >> Rest[a + b + c]
     = b + c
    >> Rest[x]
     : Nonatomic expression expected.
     = Rest[x]
    """

    def apply(self, expr, evaluation):
        'Rest[expr_]'

        if expr.is_atom():
            evaluation.message('Rest', 'normal')
            return
        return Expression(expr.head, *expr.leaves[1:])


class ReplacePart(Builtin):
    """
    >> ReplacePart[{a, b, c}, 1 -> t]
     = {t, b, c}
    >> ReplacePart[{{a, b}, {c, d}}, {2, 1} -> t]
     = {{a, b}, {t, d}}
    >> ReplacePart[{{a, b}, {c, d}}, {{2, 1} -> t, {1, 1} -> t}]
     = {{t, b}, {t, d}}
    >> ReplacePart[{a, b, c}, {{1}, {2}} -> t]
     = {t, t, c}

    Delayed rules are evaluated once for each replacement:
    >> n = 1;
    >> ReplacePart[{a, b, c, d}, {{1}, {3}} :> n++]
     = {1, b, 2, d}

    Non-existing parts are simply ignored:
    >> ReplacePart[{a, b, c}, 4 -> t]
     = {a, b, c}
    You can replace heads by replacing part 0:
    >> ReplacePart[{a, b, c}, 0 -> Times]
     = a b c
    (This is equivalent to 'Apply'.)

    Negative part numbers count from the end:
    >> ReplacePart[{a, b, c}, -1 -> t]
     = {a, b, t}
    """

    messages = {
        'reps': "`1` is not a list of replacement rules.",
    }

    rules = {
        'ReplacePart[expr_, (Rule|RuleDelayed)[i_, new_]]': (
            'ReplacePart[expr, {i -> new}]'),
        'ReplacePart[expr_, Pattern[rule, '
        'Rule|RuleDelayed][{indices___?(Head[#]===List&)}, new_]]': (
            'ReplacePart[expr, rule[#, new]& /@ {indices}]'),
    }

    def apply(self, expr, replacements, evaluation):
        'ReplacePart[expr_, {replacements___}]'

        new_expr = expr.copy()
        replacements = replacements.get_sequence()
        for replacement in replacements:
            if (not replacement.has_form('Rule', 2) and     # noqa
                not replacement.has_form('RuleDelayed', 2)):
                evaluation.message('ReplacePart', 'reps',
                                   Expression('List', *replacements))
                return
            position = replacement.leaves[0]
            replace = replacement.leaves[1]
            if position.has_form('List', None):
                position = position.leaves
            else:
                position = [position]
            for index, pos in enumerate(position):
                value = pos.get_int_value()
                if value is None:
                    position = None
                    break
                else:
                    position[index] = value
            if position is None:
                continue
            try:
                if replacement.get_head_name() == 'RuleDelayed':
                    replace_value = replace.evaluate(evaluation)
                else:
                    replace_value = replace
                set_part(new_expr, position, replace_value)
            except PartError:
                pass

        return new_expr


class Take(Builtin):
    """
    >> Take[{a, b, c, d}, 3]
     = {a, b, c}
    >> Take[{a, b, c, d}, -2]
     = {c, d}
    >> Take[{a, b, c, d, e}, {2, -2}]
     = {b, c, d}

    Take a submatrix:
    >> A = {{a, b, c}, {d, e, f}};
    >> Take[A, 2, 2]
     = {{a, b}, {d, e}}

    Take a single column:
    >> Take[A, All, {2}]
     = {{b}, {e}}
    """

    messages = {
        'take': "Cannot take positions `1` through `2` in `3`.",
    }

    def apply(self, list, seqs, evaluation):
        'Take[list_, seqs___]'

        seqs = seqs.get_sequence()

        list = list.copy()
        inner_list = [list]

        for seq in seqs:
            seq_tuple = convert_seq(seq)
            if not seq_tuple:
                evaluation.message('Take', 'seqs', seq)
                return
            start, stop, step = seq_tuple
            py_start, py_stop = python_seq(start, stop)
            for inner in inner_list:
                if (inner.is_atom() or      # noqa
                    abs(start) > len(inner.leaves) or
                    stop is not None and abs(stop) > len(inner.leaves)):
                    evaluation.message('Take', 'take', start, Symbol(
                        'Infinity') if stop is None else stop, inner)
                    return
                if stop is None:
                    inner.leaves = inner.leaves[py_start::step]
                else:
                    inner.leaves = inner.leaves[py_start:py_stop:step]
            inner_list = join_lists(inner.leaves for inner in inner_list)

        return list


class Drop(Builtin):
    """
    >> Drop[{a, b, c, d}, 3]
     = {d}
    >> Drop[{a, b, c, d}, -2]
     = {a, b}
    >> Drop[{a, b, c, d, e}, {2, -2}]
     = {a, e}

    Drop a submatrix:
    >> A = Table[i*10 + j, {i, 4}, {j, 4}]
     = {{11, 12, 13, 14}, {21, 22, 23, 24}, {31, 32, 33, 34}, {41, 42, 43, 44}}
    >> Drop[A, {2, 3}, {2, 3}]
     = {{11, 14}, {41, 44}}
    """

    messages = {
        'drop': "Cannot drop positions `1` through `2` in `3`.",
    }

    def apply(self, list, seqs, evaluation):
        'Drop[list_, seqs___]'

        seqs = seqs.get_sequence()

        list = list.copy()
        inner_list = [list]

        for seq in seqs:
            seq_tuple = convert_seq(seq)
            if not seq_tuple:
                evaluation.message('Drop', 'seqs', seq)
                return
            start, stop, step = seq_tuple
            py_start, py_stop = python_seq(start, stop)
            for inner in inner_list:
                if (inner.is_atom() or  # noqa
                    abs(start) > len(inner.leaves) or
                    stop is not None and abs(stop) > len(inner.leaves)):
                    evaluation.message('Drop', 'drop', start, stop, inner)
                    return
                if stop is None:
                    del inner.leaves[py_start::step]
                else:
                    del inner.leaves[py_start:py_stop:step]
            inner_list = join_lists(inner.leaves for inner in inner_list)

        return list


class Select(Builtin):
    """
    >> Select[{-3, 0, 1, 3, a}, #>0&]
     = {1, 3}
    >> Select[f[a, 2, 3], NumberQ]
     = f[2, 3]
    >> Select[a, True]
     : Nonatomic expression expected.
     = Select[a, True]
    """

    def apply(self, list, expr, evaluation):
        'Select[list_, expr_]'

        if list.is_atom():
            evaluation.message('Select', 'normal')
            return
        new_leaves = []
        for leaf in list.leaves:
            test = Expression(expr, leaf)
            if test.evaluate(evaluation).is_true():
                new_leaves.append(leaf)
        return Expression(list.head, *new_leaves)


class Split(Builtin):
    """
    <dl>
    <dt>'Split[$list$]'
      <dd>splits $list$ into collections of consecutive identical elements.
    <dt>'Split[$list$, $test$]'
      <dd>splits $list$ based on whether the function $test$ yields 'True' on consecutive elements.
    </dl>

    >> Split[{x, x, x, y, x, y, y, z}]
     = {{x, x, x}, {y}, {x}, {y, y}, {z}}

    #> Split[{x, x, x, y, x, y, y, z}, x]
     = {{x}, {x}, {x}, {y}, {x}, {y}, {y}, {z}}

    Split into increasing or decreasing runs of elements
    >> Split[{1, 5, 6, 3, 6, 1, 6, 3, 4, 5, 4}, Less]
     = {{1, 5, 6}, {3, 6}, {1, 6}, {3, 4, 5}, {4}}

    >> Split[{1, 5, 6, 3, 6, 1, 6, 3, 4, 5, 4}, Greater]
     = {{1}, {5}, {6, 3}, {6, 1}, {6, 3}, {4}, {5, 4}}

    Split based on first element
    >> Split[{x -> a, x -> y, 2 -> a, z -> c, z -> a}, First[#1] === First[#2] &]
     = {{x -> a, x -> y}, {2 -> a}, {z -> c, z -> a}}

    #> Split[{}]
     = {}
    """

    rules = {
        'Split[list_]': 'Split[list, SameQ]',
    }

    messages = {
        'normal': 'Nonatomic expression expected at position `1` in `2`.',
    }

    def apply(self, mlist, test, evaluation):
        'Split[mlist_, test_]'

        expr = Expression('Split', mlist, test)

        if mlist.is_atom():
            evaluation.message('Select', 'normal', 1, expr)
            return

        if len(mlist.leaves) == 0:
            result = []
        else:
            result = [[mlist.leaves[0]]]
            for leaf in mlist.leaves[1:]:
                applytest = Expression(test, result[-1][-1], leaf)
                if applytest.evaluate(evaluation).is_true():
                    result[-1].append(leaf)
                else:
                    result.append([leaf])

        return Expression(mlist.head, *[Expression('List', *l)
                                        for l in result])


class SplitBy(Builtin):
    """
    <dl>
    <dt>'Split[$list$, $f$]'
      <dd>splits $list$ into collections of consecutive elements that give the same result when $f$ is applied.
    </dl>

    >> SplitBy[Range[1, 3, 1/3], Round]
     = {{1, 4 / 3}, {5 / 3, 2, 7 / 3}, {8 / 3, 3}}

    >> SplitBy[{1, 2, 1, 1.2}, {Round, Identity}]
     = {{{1}}, {{2}}, {{1}, {1.2}}}

    >> SplitBy[{1, 2, 1, 1.2}, {Round, Identity}]
     = {{{1}}, {{2}}, {{1}, {1.2}}}

    #> SplitBy[Tuples[{1, 2}, 3], First]
     = {{{1, 1, 1}, {1, 1, 2}, {1, 2, 1}, {1, 2, 2}}, {{2, 1, 1}, {2, 1, 2}, {2, 2, 1}, {2, 2, 2}}}
    """

    rules = {
        'SplitBy[list_]': 'SplitBy[list, Identity]',
    }

    messages = {
        'normal': 'Nonatomic expression expected at position `1` in `2`.',
    }

    def apply(self, mlist, func, evaluation):
        'SplitBy[mlist_, func_?NotListQ]'

        expr = Expression('Split', mlist, func)

        if mlist.is_atom():
            evaluation.message('Select', 'normal', 1, expr)
            return

        plist = [l for l in mlist.leaves]

        result = [[plist[0]]]
        prev = Expression(func, plist[0]).evaluate(evaluation)
        for leaf in plist[1:]:
            curr = Expression(func, leaf).evaluate(evaluation)
            if curr == prev:
                result[-1].append(leaf)
            else:
                result.append([leaf])
            prev = curr

        return Expression(mlist.head, *[Expression('List', *l)
                                        for l in result])

    def apply_multiple(self, mlist, funcs, evaluation):
        'SplitBy[mlist_, funcs_?ListQ]'
        expr = Expression('Split', mlist, funcs)

        if mlist.is_atom():
            evaluation.message('Select', 'normal', 1, expr)
            return

        result = mlist
        for f in funcs.leaves[::-1]:
            result = self.apply(result, f, evaluation)

        return result


class Cases(Builtin):
    rules = {
        'Cases[list_, pattern_]': 'Select[list, MatchQ[#, pattern]&]',
    }


class MemberQ(Builtin):
    rules = {
        'MemberQ[list_, pattern_]': (
            'Length[Select[list, MatchQ[#, pattern]&]] > 0'),
    }


class Range(Builtin):
    """
    >> Range[5]
     = {1, 2, 3, 4, 5}
    >> Range[-3, 2]
     = {-3, -2, -1, 0, 1, 2}
    >> Range[0, 2, 1/3]
     = {0, 1 / 3, 2 / 3, 1, 4 / 3, 5 / 3, 2}
    """

    rules = {
        'Range[imax_?RealNumberQ]': 'Range[1, imax, 1]',
        'Range[imin_?RealNumberQ, imax_?RealNumberQ]': 'Range[imin, imax, 1]',
    }

    def apply(self, imin, imax, di, evaluation):
        'Range[imin_?RealNumberQ, imax_?RealNumberQ, di_?RealNumberQ]'

        imin = imin.value
        imax = imax.value
        di = di.value
        index = imin
        result = []
        while index <= imax:
            evaluation.check_stopped()
            result.append(Number.from_mp(index))
            index += di
        return Expression('List', *result)


class _IterationFunction(Builtin):
    attributes = ('HoldAll',)
    rules = {
        '%(name)s[expr_, {i_Symbol, imax_}]': (
            '%(name)s[expr, {i, 1, imax, 1}]'),
        '%(name)s[expr_, {i_Symbol, imin_, imax_}]': (
            '%(name)s[expr, {i, imin, imax, 1}]'),
    }

    allow_loopcontrol = False
    throw_iterb = True

    def get_result(self, items):
        pass

    def apply_max(self, expr, imax, evaluation):
        '%(name)s[expr_, {imax_}]'

        index = 0
        imax = imax.evaluate(evaluation).get_real_value()
        if imax is None:
            if self.throw_iterb:
                evaluation.message(self.get_name(), 'iterb')
            return
        result = []
        while index < imax:
            evaluation.check_stopped()
            try:
                result.append(expr.evaluate(evaluation))
            except ContinueInterrupt:
                if self.allow_loopcontrol:
                    pass
                else:
                    raise
            except BreakInterrupt:
                if self.allow_loopcontrol:
                    break
                else:
                    raise
            index += 1
        return self.get_result(result)

    def apply_iter(self, expr, i, imin, imax, di, evaluation):
        '%(name)s[expr_, {i_Symbol, imin_, imax_, di_}]'

        if isinstance(self, SympyFunction) and di.get_int_value() == 1:
            whole_expr = Expression(
                self.get_name(), expr, Expression('List', i, imin, imax))
            sympy_expr = whole_expr.to_sympy()

            # apply Together to produce results similar to Mathematica
            result = sympy.together(sympy_expr)
            result = from_sympy(result)
            result = cancel(result)

            if not result.same(whole_expr):
                return result

        index = imin.evaluate(evaluation)
        imax = imax.evaluate(evaluation)
        di = di.evaluate(evaluation)

        result = []
        while True:
            cont = Expression('LessEqual', index, imax).evaluate(evaluation)
            if cont == Symbol('False'):
                break
            if not cont.is_true():
                if self.throw_iterb:
                    evaluation.message(self.get_name(), 'iterb')
                return

            evaluation.check_stopped()
            try:
                item = dynamic_scoping(
                    expr.evaluate, {i.name: index}, evaluation)
                result.append(item)
            except ContinueInterrupt:
                if self.allow_loopcontrol:
                    pass
                else:
                    raise
            except BreakInterrupt:
                if self.allow_loopcontrol:
                    break
                else:
                    raise
            index = Expression('Plus', index, di).evaluate(evaluation)
        return self.get_result(result)

    def apply_list(self, expr, i, items, evaluation):
        '%(name)s[expr_, {i_Symbol, {items___}}]'

        items = items.evaluate(evaluation).get_sequence()
        result = []
        for item in items:
            evaluation.check_stopped()
            try:
                item = dynamic_scoping(
                    expr.evaluate, {i.name: item}, evaluation)
                result.append(item)
            except ContinueInterrupt:
                if self.allow_loopcontrol:
                    pass
                else:
                    raise
            except BreakInterrupt:
                if self.allow_loopcontrol:
                    break
                else:
                    raise
        return self.get_result(result)

    def apply_multi(self, expr, first, sequ, evaluation):
        '%(name)s[expr_, first_, sequ__]'

        sequ = sequ.get_sequence()
        name = self.get_name()
        return Expression(name, Expression(name, expr, *sequ), first)


class ConstantArray(Builtin):
    """
    >> ConstantArray[a, 3]
     = {a, a, a}
    >> ConstantArray[a, {2, 3}]
     = {{a, a, a}, {a, a, a}}
    """

    rules = {
        'ConstantArray[c_, dims_]': 'Apply[Table[c, ##]&, List /@ dims]',
        'ConstantArray[c_, n_Integer]': 'ConstantArray[c, {n}]',
    }


class Array(Builtin):
    """
    >> Array[f, 4]
     = {f[1], f[2], f[3], f[4]}
    >> Array[f, {2, 3}]
     = {{f[1, 1], f[1, 2], f[1, 3]}, {f[2, 1], f[2, 2], f[2, 3]}}
    >> Array[f, {2, 3}, 3]
     = {{f[3, 3], f[3, 4], f[3, 5]}, {f[4, 3], f[4, 4], f[4, 5]}}
    >> Array[f, {2, 3}, {4, 6}]
     = {{f[4, 6], f[4, 7], f[4, 8]}, {f[5, 6], f[5, 7], f[5, 8]}}
    >> Array[f, {2, 3}, 1, Plus]
     = f[1, 1] + f[1, 2] + f[1, 3] + f[2, 1] + f[2, 2] + f[2, 3]

    #> Array[f, {2, 3}, {1, 2, 3}]
     : {2, 3} and {1, 2, 3} should have the same length.
     = Array[f, {2, 3}, {1, 2, 3}]
    #> Array[f, a]
     : Single or list of non-negative integers expected at position 2.
     = Array[f, a]
    #> Array[f, 2, b]
     : Single or list of non-negative integers expected at position 3.
     = Array[f, 2, b]
    """

    messages = {
        'plen': "`1` and `2` should have the same length.",
    }

    def apply(self, f, dimsexpr, origins, head, evaluation):
        'Array[f_, dimsexpr_, origins_:1, head_:List]'

        if dimsexpr.has_form('List', None):
            dims = dimsexpr.leaves[:]
        else:
            dims = [dimsexpr]
        for index, dim in enumerate(dims):
            value = dim.get_int_value()
            if value is None:
                evaluation.message('Array', 'ilsnn', 2)
                return
            dims[index] = value
        if origins.has_form('List', None):
            if len(origins.leaves) != len(dims):
                evaluation.message('Array', 'plen', dimsexpr, origins)
                return
            origins = origins.leaves[:]
        else:
            origins = [origins] * len(dims)
        for index, origin in enumerate(origins):
            value = origin.get_int_value()
            if value is None:
                evaluation.message('Array', 'ilsnn', 3)
                return
            origins[index] = value

        dims = zip(dims, origins)

        def rec(rest_dims, current):
            evaluation.check_stopped()
            if rest_dims:
                level = []
                count, origin = rest_dims[0]
                for index in range(origin, origin + count):
                    level.append(rec(rest_dims[1:], current + [index]))
                return Expression(head, *level)
            else:
                return Expression(f, *(Integer(index) for index in current))

        return rec(dims, [])


class Table(_IterationFunction):
    """
    >> Table[x, {4}]
     = {x, x, x, x}
    >> n = 0;
    >> Table[n = n + 1, {5}]
     = {1, 2, 3, 4, 5}
    >> Table[i, {i, 4}]
     = {1, 2, 3, 4}
    >> Table[i, {i, 2, 5}]
     = {2, 3, 4, 5}
    >> Table[i, {i, 2, 6, 2}]
     = {2, 4, 6}
    >> Table[i, {i, Pi, 2 Pi, Pi / 2}]
     = {Pi, 3 Pi / 2, 2 Pi}
    >> Table[x^2, {x, {a, b, c}}]
     = {a ^ 2, b ^ 2, c ^ 2}

    'Table' supports multi-dimensional tables:
    >> Table[{i, j}, {i, {a, b}}, {j, 1, 2}]
     = {{{a, 1}, {a, 2}}, {{b, 1}, {b, 2}}}

    #> Table[x, {x,0,1/3}]
     = {0}
    #> Table[x, {x, -0.2, 3.9}]
     = {-0.2, 0.8, 1.8, 2.8, 3.8}
    """

    def get_result(self, items):
        return Expression('List', *items)


class Join(Builtin):
    """
    'Join' concatenates lists.
    >> Join[{a, b}, {c, d, e}]
     = {a, b, c, d, e}
    >> Join[{{a, b}, {c, d}}, {{1, 2}, {3, 4}}]
     = {{a, b}, {c, d}, {1, 2}, {3, 4}}

    The concatenated expressions may have any head.
    >> Join[a + b, c + d, e + f]
     = a + b + c + d + e + f
    However, it must be the same for all expressions.
    >> Join[a + b, c * d]
     : Heads Plus and Times are expected to be the same.
     = Join[a + b, c d]

    #> Join[x, y]
     = Join[x, y]
    #> Join[x + y, z]
     = Join[x + y, z]
    #> Join[x + y, y z, a]
     : Heads Plus and Times are expected to be the same.
     = Join[x + y, y z, a]
    #> Join[x, y + z, y z]
     = Join[x, y + z, y z]
    """

    attributes = ('Flat', 'OneIdentity')

    def apply(self, lists, evaluation):
        'Join[lists___]'

        result = []
        head = None
        for list in lists.get_sequence():
            if list.is_atom():
                return
            if head is not None and list.get_head() != head:
                evaluation.message('Join', 'heads', head, list.get_head())
                return
            head = list.get_head()
            result.extend(list.leaves)

        if result:
            return Expression(head, *result)
        else:
            return Expression('List')


def get_tuples(items):
    if not items:
        yield []
    else:
        for item in items[0]:
            for rest in get_tuples(items[1:]):
                yield [item] + rest


class Tuples(Builtin):
    """
    <dl>
    <dt>'Tuples[$list$, $n$]'
        <dd>returns a list of all $n$-tuples of elements in $list$.
    <dt>'Tuples[{$list1$, $list2$, ...}]'
        <dd>returns a list of tuples with elements from the given lists.
    </dl>

    >> Tuples[{a, b, c}, 2]
     = {{a, a}, {a, b}, {a, c}, {b, a}, {b, b}, {b, c}, {c, a}, {c, b}, {c, c}}
    >> Tuples[{}, 2]
     = {}
    >> Tuples[{a, b, c}, 0]
     = {{}}

    >> Tuples[{{a, b}, {1, 2, 3}}]
     = {{a, 1}, {a, 2}, {a, 3}, {b, 1}, {b, 2}, {b, 3}}

    The head of $list$ need not be 'List':
    >> Tuples[f[a, b, c], 2]
     = {f[a, a], f[a, b], f[a, c], f[b, a], f[b, b], f[b, c], f[c, a], f[c, b], f[c, c]}
    However, when specifying multiple expressions, 'List' is always used:
    >> Tuples[{f[a, b], g[c, d]}]
     = {{a, c}, {a, d}, {b, c}, {b, d}}
    """

    def apply_n(self, expr, n, evaluation):
        'Tuples[expr_, n_]'

        if expr.is_atom():
            evaluation.message('Tuples', 'normal')
            return
        n = n.get_int_value()
        if n is None or n < 0:
            evaluation.message('Tuples', 'intnn')
            return
        items = expr.leaves

        def iterate(n_rest):
            evaluation.check_stopped()
            if n_rest <= 0:
                yield []
            else:
                for item in items:
                    for rest in iterate(n_rest - 1):
                        yield [item] + rest

        return Expression('List', *(Expression(expr.head, *leaves)
                                    for leaves in iterate(n)))

    def apply_lists(self, exprs, evaluation):
        'Tuples[{exprs___}]'

        exprs = exprs.get_sequence()
        items = []
        for expr in exprs:
            evaluation.check_stopped()
            if expr.is_atom():
                evaluation.message('Tuples', 'normal')
                return
            items.append(expr.leaves)

        return Expression('List', *(Expression('List', *leaves)
                                    for leaves in get_tuples(items)))


class Reap(Builtin):
    """
    <dl>
    <dt>'Reap[$expr$]'
        <dd>gives the result of evaluating $expr$, together with all values sown during
        this evaluation. Values sown with different tags are given in different lists.
    <dt>'Reap[$expr$, $pattern$]'
        <dd>only yields values sown with a tag matching $pattern$.
        'Reap[$expr$]' is equivalent to 'Reap[$expr$, _]'.
    <dt>'Reap[$expr$, {$pattern1$, $pattern2$, ...}]'
        <dd>uses multiple patterns.
    <dt>'Reap[$expr$, $pattern$, $f$]'
        <dd>applies $f$ on each tag and the corresponding values sown
        in the form '$f$[tag, {e1, e2, ...}]'.
    </dl>

    >> Reap[Sow[3]; Sow[1]]
     = {1, {{3, 1}}}

    >> Reap[Sow[2, {x, x, x}]; Sow[3, x]; Sow[4, y]; Sow[4, 1], {_Symbol, _Integer, x}, f]
     = {4, {{f[x, {2, 2, 2, 3}], f[y, {4}]}, {f[1, {4}]}, {f[x, {2, 2, 2, 3}]}}}

    Find the unique elements of a list, keeping their order:
    >> Reap[Sow[Null, {a, a, b, d, c, a}], _, # &][[2]]
     = {a, b, d, c}

    Sown values are reaped by the innermost matching 'Reap':
    >> Reap[Reap[Sow[a, x]; Sow[b, 1], _Symbol, Print["Inner: ", #1]&];, _, f]
     | Inner: x
     = {Null, {f[1, {b}]}}

    When no value is sown, an empty list is returned:
    >> Reap[x]
     = {x, {}}
    """

    attributes = ('HoldFirst',)

    rules = {
        'Reap[expr_, pattern_, f_]': (
            '{#[[1]], #[[2, 1]]}& [Reap[expr, {pattern}, f]]'),
        'Reap[expr_, pattern_]': 'Reap[expr, pattern, #2&]',
        'Reap[expr_]': 'Reap[expr, _]',
    }

    def apply(self, expr, patterns, f, evaluation):
        'Reap[expr_, {patterns___}, f_]'

        patterns = patterns.get_sequence()
        sown = [(Pattern.create(pattern), []) for pattern in patterns]

        def listener(e, tag):
            result = False
            for pattern, items in sown:
                if pattern.does_match(tag, evaluation):
                    for item in items:
                        if item[0].same(tag):
                            item[1].append(e)
                            break
                    else:
                        items.append((tag, [e]))
                    result = True
            return result

        evaluation.add_listener('sow', listener)
        try:
            result = expr.evaluate(evaluation)
            items = []
            for pattern, tags in sown:
                list = Expression('List')
                for tag, elements in tags:
                    list.leaves.append(Expression(
                        f, tag, Expression('List', *elements)))
                items.append(list)
            return Expression('List', result, Expression('List', *items))
        finally:
            evaluation.remove_listener('sow', listener)


class Sow(Builtin):
    """
    <dl>
    <dt>'Sow[$e$]'
        <dd>sends the value $e$ to the innermost 'Reap'.
    <dt>'Sow[$e$, $tag$]'
        <dd>sows $e$ using $tag$. 'Sow[$e$]' is equivalent to 'Sow[$e$, Null]'.
    <dt>'Sow[$e$, {$tag1$, $tag2$, ...}]'
        <dd>uses multiple tags.
    </dl>
    """

    rules = {
        'Sow[e_]': 'Sow[e, {Null}]',
        'Sow[e_, tag_]': 'Sow[e, {tag}]',
    }

    def apply(self, e, tags, evaluation):
        'Sow[e_, {tags___}]'

        tags = tags.get_sequence()
        for tag in tags:
            evaluation.publish('sow', e, tag)
        return e


class UnitVector(Builtin):
    """
    >> UnitVector[2]
     = {0, 1}
    >> UnitVector[4, 3]
     = {0, 0, 1, 0}
    """

    messages = {
        'nokun': "There is no unit vector in direction `1` in `2` dimensions.",
    }

    rules = {
        'UnitVector[k_Integer]': 'UnitVector[2, k]',
    }

    def apply(self, n, k, evaluation):
        'UnitVector[n_Integer, k_Integer]'

        n = n.get_int_value()
        k = k.get_int_value()
        if n is None or k is None:
            return
        if not 1 <= k <= n:
            evaluation.message('UnitVector', 'nokun', k, n)
            return

        def item(i):
            if i == k:
                return Integer(1)
            else:
                return Integer(0)

        return Expression('List', *(item(i) for i in range(1, n + 1)))


def riffle(items, sep):
    result = items[:1]
    for item in items[1:]:
        result.append(sep)
        result.append(item)
    return result


def riffle_lists(items, seps):
    if len(seps) + 1 < len(items):  # Use seperators cyclically
        seps = seps * (len(items) / len(seps) + 1)
    if len(seps) > len(items):
        seps = seps[:len(items) - 1]
    return [val for pair in (map(None, items, seps))
            for val in pair if val is not None]


class Riffle(Builtin):
    """
    >> Riffle[{a, b, c}, x]
     = {a, x, b, x, c}
    >> Riffle[{a, b, c}, {x, y, z}]
     = {a, x, b, y, c, z}
    >> Riffle[{a, b, c, d, e, f}, {x, y, z}]
     = {a, x, b, y, c, z, d, x, e, y, f}

    #> Riffle[{1, 2, 3, 4}, {x, y, z, t}]
     = {1, x, 2, y, 3, z, 4, t}
    #> Riffle[{1, 2}, {1, 2, 3}]
     = {1, 1, 2}
    #> Riffle[{1, 2}, {1, 2}]
     = {1, 1, 2, 2}
    """

    def apply(self, list, sep, evaluation):
        'Riffle[list_List, sep_]'

        if sep.has_form('List', None):
            return Expression('List',
                              *riffle_lists(list.get_leaves(), sep.leaves))
        else:
            return Expression('List', *riffle_lists(list.get_leaves(), [sep]))


class DeleteDuplicates(Builtin):
    """
    <dl>
    <dt>'DeleteDuplicates[$list$]'
      <dd>deletes duplicates from $list$.
    <dt>'DeleteDuplicates[$list$, $test$]'
      <dd>deletes elements from $list$ based on whether the function $test$ yields 'True' on pairs of elements.
    </dl>

    >> DeleteDuplicates[{1, 7, 8, 4, 3, 4, 1, 9, 9, 2, 1}]
     = {1, 7, 8, 4, 3, 9, 2}

    >> DeleteDuplicates[{3,2,1,2,3,4}, Less]
     = {3, 2, 1}

    #> DeleteDuplicates[{3,2,1,2,3,4}, Greater]
     = {3, 3, 4}

    #> DeleteDuplicates[{}]
     = {}
    """

    rules = {
        'DeleteDuplicates[list_]': 'DeleteDuplicates[list, SameQ]',
    }

    messages = {
        'normal': 'Nonatomic expression expected at position `1` in `2`.',
    }

    def apply(self, mlist, test, evaluation):
        'DeleteDuplicates[mlist_, test_]'

        expr = Expression('DeleteDuplicates', mlist, test)

        if mlist.is_atom():
            evaluation.message('Select', 'normal', 1, expr)
            return

        result = []
        for leaf in mlist.leaves:
            matched = False
            for res in result:
                applytest = Expression(test, res, leaf)
                if applytest.evaluate(evaluation).is_true():
                    matched = True
                    break
            if not matched:
                result.append(leaf)

        return Expression(mlist.head, *result)


class Complement(Builtin):
    """
    <dl>
    <dt>'Complement[$all$, $e1$, $e2$, ...]'
      <dd>returns an expression containing the elements in the set $all$ that
      are not in any of $e1$, $e2$, etc.
    <dt>'Complement[$all$, $e1$, $e2$, ..., SameTest->$test$]'
      <dd>applies $test$ to the elements in $all$ and each of the $ei$
      to determine equality.
    </dl>

    The sets $all$, $e1$, etc can have any head, which must all match.
    The returned expression has the same head as the input
    expressions.

    >> Complement[{a, b, c}, {a, c}]
     = {b}
    >> Complement[{a, b, c}, {a, c}, {b}]
     = {}
    >> Complement[f[z, y, x, w], f[x], f[x, z]]
     = f[w, y]

    #> Complement[a, b]
     : Non-atomic expression expected at position 1 in Complement[a, b].
     = Complement[a, b]
    #> Complement[f[a], g[b]]
     : Heads f and g at positions 1 and 2 are expected to be the same.
     = Complement[f[a], g[b]]
    #> Complement[{a, b, c}, {a, c}, SameTest->(True&)]
     = {}
    #> Complement[{a, b, c}, {a, c}, SameTest->(False&)]
     = {a, b, c}
    """

    messages = {
        'normal': "Non-atomic expression expected at position `1` in `2`.",
        'heads': ("Heads `1` and `2` at positions `3` and `4` are expected "
                  "to be the same."),
        'smtst': ("Application of the SameTest yielded `1`, which evaluates "
                  "to `2`. The SameTest must evaluate to True or False at "
                  "every pair of elements."),
    }

    options = {
        'SameTest': 'SameQ',
    }

    def complement(self, all, others, evaluation, test):
        def test_pair(e1, e2):
            test_expr = Expression(test, e1, e2)
            result = test_expr.evaluate(evaluation)
            if not(result.is_symbol() and (result.has_symbol('True') or
                                           result.has_symbol('False'))):
                evaluation.message('Complement', 'smtst', test_expr, result)
            return result.is_true()
        all = set(all)
        for leaves in others:
            for e2 in leaves:
                for e1 in all.copy():
                    if test_pair(e1, e2):
                        all.discard(e1)
        return all

    def apply(self, all, others, evaluation, options={}):
        'Complement[all_, others__, OptionsPattern[Complement]]'

        # FIXME: is there a better way to get hold of the original
        # expression?
        def get_call():
            return Expression('Complement', all, *others.get_sequence())

        for pos, e in enumerate([all, others]):
            if e.is_atom():
                return evaluation.message(
                    'Complement', 'normal', pos + 1, get_call())

        for pos, e in enumerate([all] + others.get_sequence()):
            if e.is_atom():
                return evaluation.message(
                    'Complement', 'normal', pos + 1, get_call())
            if e.head != all.head:
                return evaluation.message(
                    'Complement', 'heads', all.head, e.head,
                    1, pos + 1)

        result_head = all.head
        same_test = self.get_option(options, 'SameTest', evaluation)
        others_leaves = [e.leaves for e in others.get_sequence()]

        result = Expression(result_head,
                            *self.complement(all.leaves, others_leaves,
                                             evaluation, same_test))
        result.sort()
        return result

########NEW FILE########
__FILENAME__ = logic
# -*- coding: utf8 -*-

from mathics.builtin.base import BinaryOperator, PrefixOperator
from mathics.core.expression import Expression, Symbol


class Or(BinaryOperator):
    """
    'Or[$expr1$, $expr2$, ...]' evaluates expressions until one evaluation results in 'True',
    in which case 'Or' returns 'True'. If all expressions evaluate to 'False', 'Or' returns 'False'.
    >> False || True
     = True
    >> a || False || b
     = a || b
    """

    operator = '||'
    precedence = 215
    attributes = ('Flat', 'HoldAll', 'OneIdentity')

    def apply(self, args, evaluation):
        'Or[args___]'

        args = args.get_sequence()
        leaves = []
        for arg in args:
            result = arg.evaluate(evaluation)
            if result.is_true():
                return Symbol('True')
            elif result != Symbol('False'):
                leaves.append(result)
        if leaves:
            if len(leaves) == 1:
                return leaves[0]
            else:
                return Expression('Or', *leaves)
        else:
            return Symbol('False')


class And(BinaryOperator):
    """
    <dl>
        <dt>'And[$expr1$, $expr2$, ...]'
        <dd>evaluates expressions until one evaluation results in 'False',
        in which case 'And' returns 'False'. If all expressions evaluate to 'True', 'And' returns 'True'.
    </dl>
    >> True && True && False
     = False
    >> a && b && True && c
     = a && b && c
    """

    operator = '&&'
    precedence = 215
    attributes = ('Flat', 'HoldAll', 'OneIdentity')

    def apply(self, args, evaluation):
        'And[args___]'

        args = args.get_sequence()
        leaves = []
        for arg in args:
            result = arg.evaluate(evaluation)
            if result == Symbol('False'):
                return Symbol('False')
            elif not result.is_true():
                leaves.append(result)
        if leaves:
            if len(leaves) == 1:
                return leaves[0]
            else:
                return Expression('And', *leaves)
        else:
            return Symbol('True')


class Not(PrefixOperator):
    """
    'Not' negates a logical expression.
    >> !True
     = False
    >> !False
     = True
    >> !b
     = !b
    """

    operator = '!'
    precedence = 230

    rules = {
        'Not[True]': 'False',
        'Not[False]': 'True',
    }

########NEW FILE########
__FILENAME__ = numbertheory
# -*- coding: utf8 -*-

"""
Number theoretic functions
"""

import sympy
from itertools import combinations

from mathics.builtin.base import Builtin, Test
from mathics.core.expression import (
    Expression, Integer, Rational, Symbol, from_python)


class PowerMod(Builtin):
    """
    >> PowerMod[2, 10000000, 3]
     = 1
    >> PowerMod[3, -2, 10]
     = 9
    >> PowerMod[0, -1, 2]
     : 0 is not invertible modulo 2.
     = PowerMod[0, -1, 2]
    >> PowerMod[5, 2, 0]
     : The argument 0 should be nonzero.
     = PowerMod[5, 2, 0]

    'PowerMod' does not support rational coefficients (roots) yet.
    """

    attributes = ('Listable',)

    messages = {
        'ninv': "`1` is not invertible modulo `2`.",
    }

    def apply(self, a, b, m, evaluation):
        'PowerMod[a_Integer, b_Integer, m_Integer]'

        a_int = a
        m_int = m
        a, b, m = a.value, b.value, m.value
        if m == 0:
            evaluation.message('PowerMod', 'divz', m)
            return
        if b < 0:
            b = -b
            if a == 0:
                evaluation.message('PowerMod', 'ninv', a_int, m_int)
                return
            a = sympy.invert(a, m)
        return Integer(sympy.Mod(a ** b, m))


class Mod(Builtin):
    """
    >> Mod[14, 6]
     = 2
    >> Mod[-3, 4]
     = 1
    >> Mod[-3, -4]
     = -3
    >> Mod[5, 0]
     : The argument 0 should be nonzero.
     = Mod[5, 0]
    """

    attributes = ('Listable', 'NumericFunction')

    def apply(self, n, m, evaluation):
        'Mod[n_Integer, m_Integer]'

        n_int, m_int = n, m
        n, m = n.value, m.value
        if m == 0:
            evaluation.message('Mod', 'divz', m)
            return
        return Integer(n % m)


class EvenQ(Test):
    """
    >> EvenQ[4]
     = True
    >> EvenQ[-3]
     = False
    >> EvenQ[n]
     = False
    """

    def test(self, n):
        value = n.get_int_value()
        return value is not None and value % 2 == 0


class OddQ(Test):
    """
    >> OddQ[-3]
     = True
    >> OddQ[0]
     = False
    """

    def test(self, n):
        value = n.get_int_value()
        return value is not None and value % 2 != 0


class GCD(Builtin):
    """
    <dl>
    <dt>'GCD[$n1$, $n2$, ...]'
        <dd>computes the greatest common divisor of the given integers.
    </dl>

    >> GCD[20, 30]
     = 10
    >> GCD[10, y]
     = GCD[10, y]

    'GCD' is 'Listable':
    >> GCD[4, {10, 11, 12, 13, 14}]
     = {2, 1, 4, 1, 2}

    'GCD' does not work for rational numbers and Gaussian integers yet.
    """

    attributes = ('Flat', 'Listable', 'OneIdentity', 'Orderless')

    def apply(self, ns, evaluation):
        'GCD[ns___Integer]'

        ns = ns.get_sequence()
        result = 0
        for n in ns:
            value = n.get_int_value()
            if value is None:
                return
            result = sympy.gcd(result, value)
        return Integer(result)

# FIXME: Previosuly this used gmpy's gcdext. sympy's gcdex is not as powerful
# class ExtendedGCD(Builtin):
#    u"""
#    >> ExtendedGCD[10, 15]
#     = {5, {-1, 1}}
#
#    'ExtendedGCD' works with any number of arguments:
#    >> ExtendedGCD[10, 15, 7]
#     = {1, {-3, 3, -2}}
#
#    Compute the greated common divisor and check the result:
#    >> numbers = {10, 20, 14};
#    >> {gcd, factors} = ExtendedGCD[Sequence @@ numbers]
#     = {2, {3, 0, -2}}
#    >> Plus @@ (numbers * factors)
#     = 2
#
#    'ExtendedGCD' does not work for rational numbers and Gaussian integers yet
#    """
#
#    attributes = ('Listable',)
#
#    def apply(self, ns, evaluation):
#        'ExtendedGCD[ns___Integer]'
#
#        ns = ns.get_sequence()
#        result = 0
#        coeff = []
#        for n in ns:
#            value = n.get_int_value()
#            if value is None:
#                return
#            new_result, c1, c2 = sympy.gcdex(result, value)
#            result = new_result
#            coeff = [c * c1 for c in coeff] + [c2]
#            return Expression('List', Integer(result), Expression(
#                'List', *(Integer(c) for c in coeff)))


class LCM(Builtin):
    """
    <dl>
    <dt>'LCM[$n1$, $n2$, ...]'
        <dd>computes the least common multiple of the given integers.
    </dl>

    >> LCM[15, 20]
     = 60
    >> LCM[20, 30, 40, 50]
     = 600
    """

    attributes = ('Flat', 'Listable', 'OneIdentity', 'Orderless')

    def apply(self, ns, evaluation):
        'LCM[ns___Integer]'

        ns = ns.get_sequence()
        result = 1
        for n in ns:
            value = n.get_int_value()
            if value is None:
                return
            result = sympy.lcm(result, value)
        return Integer(result)


class FactorInteger(Builtin):
    """
    <dl>
    <dt>'FactorInteger[$n$]'
        <dd>returns the factorization of $n$ as a list of factors and exponents.
    </dl>

    >> factors = FactorInteger[2010]
     = {{2, 1}, {3, 1}, {5, 1}, {67, 1}}
    To get back the original number:
    >> Times @@ Power @@@ factors
     = 2010
    'FactorInteger' factors rationals using negative exponents:
    >> FactorInteger[2010 / 2011]
     = {{2, 1}, {3, 1}, {5, 1}, {67, 1}, {2011, -1}}
    """

    # TODO: GausianIntegers option
    # e.g. FactorInteger[5, GaussianIntegers -> True]

    def apply(self, n, evaluation):
        'FactorInteger[n_]'

        if isinstance(n, Integer):
            factors = sympy.factorint(n.value)
            factors = sorted(factors.iteritems())
            return Expression('List', *(Expression('List', factor, exp)
                                        for factor, exp in factors))

        elif isinstance(n, Rational):
            factors, factors_denom = map(
                sympy.factorint, n.value.as_numer_denom())
            for factor, exp in factors_denom.iteritems():
                factors[factor] = factors.get(factor, 0) - exp
            factors = sorted(factors.iteritems())
            return Expression('List', *(Expression('List', factor, exp)
                                        for factor, exp in factors))
        else:
            return evaluation.message('FactorInteger', 'exact', n)


class IntegerExponent(Builtin):
    """
    <dl>
    <dt>'IntegerExponent[$n$, $b$]'
        <dd>gives the highest exponent of $b$ that divides $n$.
    </dl>

    >> IntegerExponent[16, 2]
     = 4

    >> IntegerExponent[-510000]
     = 4

    >> IntegerExponent[10, b]
     = IntegerExponent[10, b]
    """

    rules = {
        'IntegerExponent[n_]': 'IntegerExponent[n, 10]',
    }

    messages = {
        'int': 'Integer expected at position 1 in `1`',
        'ibase': 'Base `1` is not an integer greater than 1.',
    }

    def apply(self, n, b, evaluation):
        'IntegerExponent[n_Integer, b_Integer]'

        py_n, py_b = n.to_python(), b.to_python()
        expr = Expression('IntegerExponent', n, b)

        if not (isinstance(py_n, int) or isinstance(py_n, long)):
            evaluation.message('IntegerExponent', 'int', expr)
        py_n = abs(py_n)

        if not (isinstance(py_b, int) and py_b > 1):
            evaluation.message('IntegerExponent', 'ibase', b)

        # TODO: Optimise this (dont need to calc. base^result)
        # NOTE: IntegerExponent[a,b] causes a Python error here when a or b are
        # symbols
        result = 1
        while py_n % (py_b ** result) == 0:
            result += 1

        return from_python(result - 1)


class Prime(Builtin):
    """
    <dl>
    <dt>'Prime[$n$]'
        <dd>returns the $n$th prime number.
    </dl>

    >> Prime[1]
     = 2

    >> Prime[167]
     = 991
    """

    messages = {
        'intpp': 'Positive integer argument expected in `1`.',
    }

    def apply(self, n, evaluation):
        'Prime[n_]'
        n_int = n.to_python()
        if isinstance(n_int, int) and n_int > 0:
            return Integer(sympy.prime(n_int))

        expr = Expression('Prime', n)
        evaluation.message('Prime', 'intpp', expr)
        return


class PrimeQ(Builtin):
    """
    For very large numbers, 'PrimeQ' uses probabilistic prime testing, so it might be wrong sometimes
    (a number might be composite even though 'PrimeQ' says it is prime).
    The algorithm might be changed in the future.

    >> PrimeQ[2]
     = True
    >> PrimeQ[-3]
     = True
    >> PrimeQ[137]
     = True
    >> PrimeQ[2 ^ 127 - 1]
     = True

    #> PrimeQ[1]
     = False
    #> PrimeQ[2 ^ 255 - 1]
     = False

    All prime numbers between 1 and 100:
    >> Select[Range[100], PrimeQ]
     = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97}

    'PrimeQ' has attribute 'Listable':
    >> PrimeQ[Range[20]]
     = {False, True, True, False, True, False, True, False, False, False, True, False, True, False, False, False, True, False, True, False}
    """

    attributes = ('Listable',)

    def apply(self, n, evaluation):
        'PrimeQ[n_]'

        n = n.get_int_value()
        if n is None:
            return Symbol('False')

        n = abs(n)
        if sympy.isprime(n):
            return Symbol('True')
        else:
            return Symbol('False')

        # old variant using gmpy
        """count = 25
        while True:
            evaluation.check_stopped()
            result = n.is_prime(count)
            print result, count
            if result == 0:
                return Symbol('False')
            elif result == 2:
                return Symbol('True')
            count += 50"""


class CoprimeQ(Builtin):
    """
    Test whether two numbers are coprime by computing their greatest common divisor

    >> CoprimeQ[7, 9]
     = True

    >> CoprimeQ[-4, 9]
     = True

    >> CoprimeQ[12, 15]
     = False

    CoprimeQ also works for complex numbers
    >> CoprimeQ[1+2I, 1-I]
     = True

    >> CoprimeQ[4+2I, 6+3I]
     = False

    >> CoprimeQ[2, 3, 5]
     = True

    >> CoprimeQ[2, 4, 5]
     = False

    """
    attributes = ('Listable',)

    def apply(self, args, evaluation):
        'CoprimeQ[args__]'

        py_args = [arg.to_python() for arg in args.get_sequence()]
        if not all(isinstance(i, int) or isinstance(i, complex)
                   for i in py_args):
            return Symbol('False')

        if all(sympy.gcd(n, m) == 1 for (n, m) in combinations(py_args, 2)):
            return Symbol('True')
        else:
            return Symbol('False')


class PrimePowerQ(Builtin):
    """
    Tests wheter a number is a prime power

    >> PrimePowerQ[9]
     = True

    >> PrimePowerQ[52142]
     = False

    >> PrimePowerQ[-8]
     = True

    >> PrimePowerQ[371293]
     = True

    #> PrimePowerQ[1]
     = False
    """

    rules = {
        'PrimePowerQ[1]': 'False',
    }

    attributes = ('Listable', 'Protected', 'ReadProtected')

    # TODO: GaussianIntegers option
    """
    #> PrimePowerQ[5, GaussianIntegers -> True]
     = False
    """

    #TODO: Complex args
    """
    #> PrimePowerQ[{3 + I, 3 - 2 I, 3 + 4 I, 9 + 7 I}]
     = {False, True, True, False}
    """

    # TODO: Gaussian rationals
    """
    #> PrimePowerQ[2/125 - 11 I/125]
     = True
    """

    def apply(self, n, evaluation):
        'PrimePowerQ[n_]'
        n = n.get_int_value()
        if n is None:
            return Symbol('False')

        n = abs(n)
        if len(sympy.factorint(n)) == 1:
            return Symbol('True')
        else:
            return Symbol('False')


class PrimePi(Builtin):
    """
    <dl>
    <dt>'PrimePi[$x$]'
        <dd>gives the number of primes less than or equal to $x$
    </dl>

    >> PrimePi[100]
     = 25

    >> PrimePi[-1]
     = 0

    >> PrimePi[3.5]
     = 2

    >> PrimePi[E]
     = 1
    """

    # TODO: Traditional Form

    def apply(self, n, evaluation):
        'PrimePi[n_?NumericQ]'
        result = sympy.ntheory.primepi(n.to_python(n_evaluation=evaluation))
        return from_python(result)


class NextPrime(Builtin):
    """
    <dl>
    <dt>'NextPrime[$n$]'
        <dd>gives the next prime after $n$.
    <dt>'NextPrime[$n$,$k$]'
        <dd>gives the $k$th  prime after $n$.
    </dl>

    >> NextPrime[10000]
     = 10007

    >> NextPrime[100, -5]
     = 73

    >> NextPrime[10, -5]
    = -2

    >> NextPrime[100, 5]
     = 113

    >> NextPrime[5.5, 100]
     = 563

    >> NextPrime[5, 10.5]
     = NextPrime[5, 10.5]
    """

    rules = {
        'NextPrime[n_]': 'NextPrime[n, 1]',
    }

    def apply(self, n, k, evaluation):
        'NextPrime[n_?NumericQ, k_?IntegerQ]'
        py_k = k.to_python(n_evaluation=evaluation)
        py_n = n.to_python(n_evaluation=evaluation)

        if py_k >= 0:
            return from_python(sympy.ntheory.nextprime(py_n, py_k))

        # Hack to get earlier primes
        result = n.to_python()
        for i in range(-py_k):
            try:
                result = sympy.ntheory.prevprime(result)
            except ValueError:
                # No earlier primes
                return from_python(-1 * sympy.ntheory.nextprime(0, py_k - i))

        return from_python(result)


class RandomPrime(Builtin):
    """
    <dl>
    <dt>'RandomPrime[{$imin$, $imax}]'
        <dd>gives a random prime between $imin$ and $imax$.
    <dt>'RanomPrime[$imax$]
        <dd>gives a random prime between 2 and $imax$.
    <dt>'RandomPrime[$range$, $n$]'
        <dd>gives a list of $n$ random primes in $range$.
    </dl>

    >> RandomPrime[{14, 17}]
     = 17

    >> RandomPrime[{14, 16}, 1]
     : There are no primes in the specified interval.
     = RandomPrime[{14, 16}, 1]

    >> RandomPrime[{8,12}, 3]
     = {11, 11, 11}

    >> RandomPrime[{10,30}, {2,5}]
     = ...

    #> RandomPrime[{10,12}, {2,2}]
     = {{11, 11}, {11, 11}}

    #> RandomPrime[2, {3,2}]
     = {{2, 2}, {2, 2}, {2, 2}}
    """

    messages = {
        'posdim': (
            'The dimensions parameter `1` is expected to be a positive '
            'integer or a list of positive integers.'),
        'noprime': 'There are no primes in the specified interval.',
        'prmrng': ('First argument `1` is not a positive integer or a list '
                   'of two positive integers.'),
        'posint': ('The paramater `1` describing the interval is expected to '
                   'be a positive integer.'),
    }

    rules = {
        'RandomPrime[imax_?NotListQ]': 'RandomPrime[{1, imax}, 1]',
        'RandomPrime[int_?ListQ]': 'RandomPrime[int, 1]',
        'RandomPrime[imax_?ListQ, n_?ArrayQ]': (
            'ConstantArray[RandomPrime[imax, 1], n]'),
        'RandomPrime[imax_?NotListQ, n_?ArrayQ]': (
            'ConstantArray[RandomPrime[{1, imax}, 1], n]'),
    }

    # TODO: Use random state as in other randomised methods within mathics

    def apply(self, interval, n, evaluation):
        'RandomPrime[interval_?ListQ, n_]'

        if not isinstance(n, Integer):
            evaluation.message('RandomPrime', 'posdim', n)
            return
        py_n = n.to_python()

        py_int = interval.to_python()
        if not (isinstance(py_int, list) and len(py_int) == 2):
            evaluation.message('RandomPrime', 'prmrng', interval)

        imin, imax = min(py_int), max(py_int)
        if imin <= 0 or not isinstance(imin, int):
            evaluation.message('RandomPrime', 'posint', interval.leaves[0])
            return

        if imax <= 0 or not isinstance(imax, int):
            evaluation.message('RandomPrime', 'posint', interval.leaves[1])
            return

        try:
            if py_n == 1:
                return from_python(sympy.ntheory.randprime(imin, imax + 1))
            return from_python([sympy.ntheory.randprime(imin, imax + 1)
                                for i in range(py_n)])
        except ValueError:
            evaluation.message('RandomPrime', 'noprime')
            return

########NEW FILE########
__FILENAME__ = numeric
# -*- coding: utf8 -*-

"""
Numeric evaluation

Support for numeric evaluation with arbitrary precision is just a proof-of-concept.
Precision is not "guarded" through the evaluation process. Only integer precision is supported.
However, things like 'N[Pi, 100]' should work as expected.
"""

import sympy
import sympy.mpmath as mpmath

from mathics.builtin.base import Builtin, Predefined
from mathics.core.numbers import (dps, prec, convert_base,
                                  convert_int_to_digit_list)
from mathics.core.expression import (Integer, Rational, Real, Complex,
                                     Expression, Number, Symbol, from_python)
from mathics.core.convert import from_sympy
from mathics.settings import MACHINE_PRECISION

machine_precision = MACHINE_PRECISION


def get_precision(precision, evaluation):
    if precision.get_name() == 'MachinePrecision':
        return machine_precision
    elif isinstance(precision, (Integer, Rational, Real)):
        return prec(float(precision.to_sympy()))
    else:
        evaluation.message('N', 'precbd', precision)
        return None


class N(Builtin):
    """
    <dl>
    <dt>'N[$expr$, $prec$]'
        <dd>evaluates $expr$ numerically with a precision of $prec$ digits.
    </dl>
    >> N[Pi, 50]
     = 3.1415926535897932384626433832795028841971693993751

    >> N[1/7]
     = 0.142857142857142857

    >> N[1/7, 5]
     = 0.14286

    You can manually assign numerical values to symbols.
    When you do not specify a precision, 'MachinePrecision' is taken.
    >> N[a] = 10.9
     = 10.9
    >> a
     = a

    'N' automatically threads over expressions, except when a symbol has attributes 'NHoldAll', 'NHoldFirst', or 'NHoldRest'.
    >> N[a + b]
     = 10.9 + b
    >> N[a, 20]
     = a
    >> N[a, 20] = 11;
    >> N[a + b, 20]
     = 11. + b
    >> N[f[a, b]]
     = f[10.9, b]
    >> SetAttributes[f, NHoldAll]
    >> N[f[a, b]]
     = f[a, b]

    The precision can be a pattern:
    >> N[c, p_?(#>10&)] := p
    >> N[c, 3]
     = c
    >> N[c, 11]
     = 11.

    You can also use 'UpSet' or 'TagSet' to specify values for 'N':
    >> N[d] ^= 5;
    However, the value will not be stored in 'UpValues', but in 'NValues' (as for 'Set'):
    >> UpValues[d]
     = {}
    >> NValues[d]
     = {HoldPattern[N[d, MachinePrecision]] :> 5}
    >> e /: N[e] = 6;
    >> N[e]
     = 6.

    Values for 'N[$expr$]' must be associated with the head of $expr$:
    >> f /: N[e[f]] = 7;
     : Tag f not found or too deep for an assigned rule.

    You can use 'Condition':
    >> N[g[x_, y_], p_] := x + y * Pi /; x + y > 3
    >> SetAttributes[g, NHoldRest]
    >> N[g[1, 1]]
     = g[1., 1]
    >> N[g[2, 2]]
     = 8.28318530717958648

    #> p=N[Pi,100]
     = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068
    #> ToString[p]
     = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068
    """

    messages = {
        'precbd': (
            "Requested precision `1` is not a machine-sized real number."),
    }

    rules = {
        'N[expr_]': 'N[expr, MachinePrecision]',
    }

    def apply_other(self, expr, prec, evaluation):
        'N[expr_, prec_]'

        valid_prec = get_precision(prec, evaluation)

        if valid_prec is not None:
            if expr.get_head_name() in ('List', 'Rule'):
                return Expression(
                    expr.head, *[self.apply_other(leaf, prec, evaluation)
                                 for leaf in expr.leaves])
            if isinstance(expr, Number):
                return expr.round(valid_prec)

            name = expr.get_lookup_name()
            nexpr = Expression('N', expr, prec)
            result = evaluation.definitions.get_value(
                name, 'NValues', nexpr, evaluation)
            if result is not None:
                if not result.same(nexpr):
                    result = Expression('N', result, prec).evaluate(evaluation)
                return result

            if expr.is_atom():
                return expr.round(valid_prec)
            else:
                attributes = expr.head.get_attributes(evaluation.definitions)
                if 'NHoldAll' in attributes:
                    eval_range = []
                elif 'NHoldFirst' in attributes:
                    eval_range = range(1, len(expr.leaves))
                elif 'NHoldRest' in attributes:
                    if len(expr.leaves) > 0:
                        eval_range = (0,)
                    else:
                        eval_range = ()
                else:
                    eval_range = range(len(expr.leaves))
                head = Expression('N', expr.head, prec).evaluate(evaluation)
                leaves = expr.leaves[:]
                for index in eval_range:
                    leaves[index] = Expression(
                        'N', leaves[index], prec).evaluate(evaluation)
                return Expression(head, *leaves)


class MachinePrecision(Predefined):
    """
    <dl>
    <dt>'MachinePrecision'
        <dd>is a "pessimistic" (integer) estimation of the internally used standard precision.
    </dl>
    >> N[MachinePrecision]
     = 18.
    """

    def apply_N(self, prec, evaluation):
        'N[MachinePrecision, prec_]'

        prec = get_precision(prec, evaluation)
        if prec is not None:
            return Real(dps(machine_precision), prec)


class Precision(Builtin):
    """
    <dl>
    <dt>'Precision[$expr$]'
        <dd>examines the number of significant digits of $expr$.
    </dl>
    This is rather a proof-of-concept than a full implementation. Precision of
    compound expression is not supported yet.
    >> Precision[1]
     = Infinity
    >> Precision[1/2]
     = Infinity
    >> Precision[0.5]
     = 18.
    #> Precision[0.0]
     = 0.
    #> Precision[0.000000000000000000000000000000000000]
     = 0.
    #> Precision[-0.0]      (*Matematica gets this wrong *)
     = 0.
    #> Precision[-0.000000000000000000000000000000000000]
     = 0.
    """

    rules = {
        'Precision[_Integer]': 'Infinity',
        'Precision[_Rational]': 'Infinity',
        'Precision[_Symbol]': 'Infinity',
        'Precision[z:0.0]': '0.',
        'Precision[z:-0.0]': '0.',
    }

    def apply_real(self, x, evaluation):
        'Precision[x_Real]'

        return Real(dps(x.get_precision()))

    def apply_complex(self, x, evaluation):
        'Precision[x_Complex]'

        if x.is_inexact():
            return Real(dps(x.get_precision()))
        else:
            return Symbol('Infinity')


def round(value, k):
    n = (1. * value / k).as_real_imag()[0]
    if n >= 0:
        n = sympy.Integer(n + 0.5)
    else:
        n = sympy.Integer(n - 0.5)
    return n * k


class Round(Builtin):
    """
    <dl>
    <dt>'Round[$expr$]'
        <dd>rounds $expr$ to the nearest integer.
    <dt>'Round[$expr$, $k$]'
        <dd>rounds $expr$ to the closest multiple of $k$.
    </dl>

    >> Round[10.6]
     = 11
    >> Round[0.06, 0.1]
     = 0.1
    ## This should return 0. but doesn't due to a bug in sympy
    >> Round[0.04, 0.1]
     = 0

    Constants can be rounded too
    >> Round[Pi, .5]
     = 3.
    >> Round[Pi^2]
     = 10

    Round to exact value
    >> Round[2.6, 1/3]
     = 8 / 3
    >> Round[10, Pi]
     = 3 Pi

    Round complex numbers
    >> Round[6/(2 + 3 I)]
     = 1 - I
    >> Round[1 + 2 I, 2 I]
     = 2 I

    Round Negative numbers too
    >> Round[-1.4]
     = -1

    Expressions other than numbers remain unevaluated:
    >> Round[x]
     = Round[x]
    >> Round[1.5, k]
     = Round[1.5, k]
    """

    attributes = ('Listable', 'NumericFunction')

    rules = {
        'Round[expr_?NumericQ]': 'Round[Re[expr], 1] + I * Round[Im[expr], 1]',
        'Round[expr_Complex, k_RealNumberQ]': (
            'Round[Re[expr], k] + I * Round[Im[expr], k]'),
    }

    def apply(self, expr, k, evaluation):
        "Round[expr_?NumericQ, k_?NumericQ]"
        return from_sympy(round(expr.to_sympy(), k.to_sympy()))


def chop(expr, delta=10.0 ** (-10.0)):
    if isinstance(expr, Real):
        if -delta < expr.to_python() < delta:
            return Integer(0)
        # return expr
    elif isinstance(expr, Complex) and expr.get_precision() is not None:
        real, imag = expr.real, expr.imag
        if -delta < real.to_python() < delta:
            real = sympy.Integer(0)
        if -delta < imag.to_python() < delta:
            imag = sympy.Integer(0)
        if imag != 0:
            return Complex(real, imag)
        else:
            return Number.from_mp(real)
    elif isinstance(expr, Expression):
        return Expression(chop(expr.head), *[
            chop(leaf) for leaf in expr.leaves])
    return expr


class Chop(Builtin):
    """
    <dl>
    <dt>'Chop[$expr$]'
        <dd>replaces floating point numbers close to 0 by 0.
    <dt>'Chop[$expr$, $delta$]'
        <dd>uses a tolerance of $delta$. The default tolerance is '10^-10'.
    </dl>

    >> Chop[10.0 ^ -16]
     = 0
    >> Chop[10.0 ^ -9]
     = 1.*^-9
    >> Chop[10 ^ -11 I]
     = I / 100000000000
    >> Chop[0. + 10 ^ -11 I]
     = 0
    """

    messages = {
        'tolnn': "Tolerance specification a must be a non-negative number.",
    }

    rules = {
        'Chop[expr_]': 'Chop[expr, 10^-10]',
    }

    def apply(self, expr, delta, evaluation):
        'Chop[expr_, delta_:(10^-10)]'

        delta = delta.evaluate(evaluation).get_real_value()
        if delta is None or delta < 0:
            return evaluation.message('Chop', 'tolnn')

        return chop(expr, delta=delta)


class NumericQ(Builtin):
    """
    <dl>
    <dt>'NumericQ[$expr$]'
        <dd>tests whether $expr$ represents a numeric quantity.
    </dl>

    >> NumericQ[2]
     = True
    >> NumericQ[Sqrt[Pi]]
     = True
    >> NumberQ[Sqrt[Pi]]
     = False
    """

    def apply(self, expr, evaluation):
        'NumericQ[expr_]'

        def test(expr):
            if isinstance(expr, Expression):
                attr = evaluation.definitions.get_attributes(
                    expr.head.get_name())
                return 'NumericFunction' in attr and all(
                    test(leaf) for leaf in expr.leaves)
            else:
                return expr.is_numeric()

        return Symbol('True') if test(expr) else Symbol('False')


class BaseForm(Builtin):
    """
    <dl>
    <dt>'BaseForm[$expr$, $n$]'
        <dd>prints mumbers in $expr$ in base $n$.
    </dl>

    >> BaseForm[33, 2]
     = 100001_2

    >> BaseForm[234, 16]
     = ea_16

    >> BaseForm[12.3, 2]
     = 1100.010011001100110011_2

    >> BaseForm[-42, 16]
     = -2a_16

    >> BaseForm[x, 2]
     = x

    >> BaseForm[12, 3] // FullForm
     = BaseForm[12, 3]

    >> BaseForm[12, -3]
     : Positive machine-sized integer expected at position 2 in BaseForm[12, -3].
     : MakeBoxes[BaseForm[12, -3], OutputForm] is not a valid box structure.
    """

    messages = {
        'intpm': (
            "Positive machine-sized integer expected at position 2 in "
            "BaseForm[`1`, `2`]."),
    }

    def apply_makeboxes(self, expr, n, f, evaluation):
        '''MakeBoxes[BaseForm[expr_, n_],
            f:StandardForm|TraditionalForm|OutputForm]'''

        base = n.get_int_value()

        if base <= 0:
            evaluation.message('BaseForm', 'intpm', expr, n)
            return

        if not (isinstance(expr, Integer) or isinstance(expr, Real)):
            return Expression("MakeBoxes", expr, f)

        p = dps(expr.get_precision()) if isinstance(expr, Real) else 0
        val = convert_base(expr.get_real_value(), base, p)

        if f.get_name() == 'OutputForm':
            return from_python("%s_%d" % (val, base))
        else:
            return Expression(
                'SubscriptBox', from_python(val), from_python(base))


class IntegerDigits(Builtin):
    """
    <dl>
    <dt>'IntegerDigits[$n$]'
    <dd>returns a list of the base-10 digits in the integer $n$.
    <dt>'IntegerDigits[$n$, $base$]'
    <dd>returns a list of the base-$base$ digits in $n$.
    <dt>'IntegerDigits[$n$, $base$, $length$]'
    <dd>returns a list of length $length$, truncating or padding with
    zeroes on the left as necessary.
    </dl>

    >> IntegerDigits[76543]
     = {7, 6, 5, 4, 3}

    The sign of $n$ is discarded:
    >> IntegerDigits[-76543]
     = {7, 6, 5, 4, 3}

    >> IntegerDigits[15, 16]
     = {15}
    >> IntegerDigits[1234, 16]
     = {4, 13, 2}
    >> IntegerDigits[1234, 10, 5]
     = {0, 1, 2, 3, 4}

    #> IntegerDigits[1000, 10]
     = {1, 0, 0, 0}
    """

    attributes = ('Listable',)

    messages = {
        'int': 'Integer expected at position 1 in `1`',
        'ibase': 'Base `1` is not an integer greater than 1.',
    }

    rules = {
        'IntegerDigits[n_]': 'IntegerDigits[n, 10]',
    }

    def apply_len(self, n, base, length, evaluation):
        'IntegerDigits[n_, base_, length_]'

        if not(isinstance(length, Integer) and length.get_int_value() >= 0):
            return evaluation.message('IntegerDigits', 'intnn')

        return self.apply(n, base, evaluation,
                          nr_elements=length.get_int_value())

    def apply(self, n, base, evaluation, nr_elements=None):
        'IntegerDigits[n_, base_]'

        if not(isinstance(n, Integer)):
            return evaluation.message('IntegerDigits', 'int',
                                      Expression('IntegerDigits', n, base))

        if not(isinstance(base, Integer) and base.get_int_value() > 1):
            return evaluation.message('IntegerDigits', 'ibase', base)

        if nr_elements == 0:
            # trivial case: we don't want any digits
            return Expression('List')

        digits = convert_int_to_digit_list(
            n.get_int_value(), base.get_int_value())

        if nr_elements is not None:
            if len(digits) >= nr_elements:
                # Truncate, preserving the digits on the right
                digits = digits[-nr_elements:]
            else:
                # Pad with zeroes
                digits = [0] * (nr_elements - len(digits)) + digits

        return Expression('List', *digits)

########NEW FILE########
__FILENAME__ = options
# -*- coding: utf8 -*-

"""
Options and default arguments
"""

from mathics.builtin.base import Builtin, Test
from mathics.core.expression import Symbol, Expression, get_default_value


class Options(Builtin):
    """
    <dl>
    <dt>'Options[$f$]'
        <dd>gives a list of optional arguments to $f$ and their default values.
    </dl>

    You can assign values to 'Options' to specify options.
    >> Options[f] = {n -> 2}
     = {n -> 2}
    >> Options[f]
     = {n :> 2}
    >> f[x_, OptionsPattern[f]] := x ^ OptionValue[n]
    >> f[x]
     = x ^ 2
    >> f[x, n -> 3]
     = x ^ 3

    Delayed option rules are evaluated just when the corresponding 'OptionValue' is called:
    >> f[a :> Print["value"]] /. f[OptionsPattern[{}]] :> (OptionValue[a]; Print["between"]; OptionValue[a]);
     | value
     | between
     | value
    In contrast to that, normal option rules are evaluated immediately:
    >> f[a -> Print["value"]] /. f[OptionsPattern[{}]] :> (OptionValue[a]; Print["between"]; OptionValue[a]);
     | value
     | between

    Options must be rules or delayed rules:
    >> Options[f] = {a}
     : {a} is not a valid list of option rules.
     = {a}
    A single rule need not be given inside a list:
    >> Options[f] = a -> b
     = a -> b
    >> Options[f]
     = {a :> b}
    Options can only be assigned to symbols:
    >> Options[a + b] = {a -> b}
     : Argument a + b at position 1 is expected to be a symbol.
     = {a -> b}

    #> f /: Options[f] = {a -> b}
     = {a -> b}
    #> Options[f]
     = {a :> b}
    #> f /: Options[g] := {a -> b}
     : Rule for Options can only be attached to g.
     = $Failed

    #> Options[f] = a /; True
     : a /; True is not a valid list of option rules.
     = a /; True
    """

    def apply(self, f, evaluation):
        'Options[f_]'

        name = f.get_name()
        if not name:
            evaluation.message('Options', 'sym', f, 1)
            return
        options = evaluation.definitions.get_options(name)
        result = []
        for option, value in sorted(options.items(), key=lambda item: item[0]):
            # Don't use HoldPattern, since the returned List should be
            # assignable to Options again!
            result.append(Expression('RuleDelayed', Symbol(option), value))
        return Expression('List', *result)


class OptionValue(Builtin):
    """
    <dl>
    <dt>'OptionValue[$name$]'
        <dd>gives the value of the option $name$ as specified in a call to a function
        with 'OptionsPattern'.
    </dl>

    >> f[a->3] /. f[OptionsPattern[{}]] -> {OptionValue[a]}
     = {3}

    Unavailable options generate a message:
    >> f[a->3] /. f[OptionsPattern[{}]] -> {OptionValue[b]}
     : Option name b not found.
     = {OptionValue[b]}

    The argument of 'OptionValue' must be a symbol:
    >> f[a->3] /. f[OptionsPattern[{}]] -> {OptionValue[a+b]}
     : Argument a + b at position 1 is expected to be a symbol.
     = {OptionValue[a + b]}
    However, it can be evaluated dynamically:
    >> f[a->5] /. f[OptionsPattern[{}]] -> {OptionValue[Symbol["a"]]}
     = {5}
    """

    messages = {
        'optnf': "Option name `1` not found.",
    }

    def apply(self, symbol, evaluation):
        'OptionValue[symbol_]'

        if evaluation.options is None:
            return
        name = symbol.get_name()
        if not name:
            evaluation.message('OptionValue', 'sym', symbol, 1)
            return
        value = evaluation.options.get(name)
        if value is None:
            evaluation.message('OptionValue', 'optnf', symbol)
            return
        return value


class Default(Builtin):
    """
    <dl>
    <dt>'Default[$f$]'
        <dd>gives the default value for an omitted paramter of $f$.
    <dt>'Default[$f$, $k$]'
        <dd>gives the default value for a parameter on the $k$th position.
    <dt>'Default[$f$, $k$, $n$]'
        <dd>gives the default value for the $k$th parameter out of $n$.
    </dl>

    Assign values to 'Default' to specify default values.

    >> Default[f] = 1
     = 1
    >> f[x_.] := x ^ 2
    >> f[]
     = 1

    Default values are stored in 'DefaultValues':
    >> DefaultValues[f]
     = {HoldPattern[Default[f]] :> 1}

    You can use patterns for $k$ and $n$:
    >> Default[h, k_, n_] := {k, n}
    Note that the position of a parameter is relative to the pattern, not the matching expression:
    >> h[] /. h[___, ___, x_., y_., ___] -> {x, y}
     = {{3, 5}, {4, 5}}
    """

    def apply(self, f, i, evaluation):
        'Default[f_, i___]'

        i = i.get_sequence()
        if len(i) > 2:
            evaluation.message('Default', 'argb', 1 + len(i), 1, 3)
            return
        i = [index.get_int_value() for index in i]
        for index in i:
            if index is None or index < 1:
                evaluation.message('Default', 'intp')
                return
        name = f.get_name()
        if not name:
            evaluation.message('Default', 'sym', f, 1)
            return
        result = get_default_value(name, evaluation, *i)
        return result


class OptionQ(Test):
    """

    >> OptionQ[a -> True]
     = True
    >> OptionQ[a :> True]
     = True
    >> OptionQ[{a -> True}]
     = True
    >> OptionQ[{a :> True}]
     = True

    >> OptionQ[x]
     = False
    """

    def test(self, expr):
        if not expr.has_form('List', None):
            expr = [expr]
        else:
            expr = expr.get_leaves()
        return all(e.has_form('Rule', None) or e.has_form('RuleDelayed', 2)
                   for e in expr)


class NotOptionQ(Test):
    """
    >> NotOptionQ[x]
     = True
    >> NotOptionQ[2]
     = True
    >> NotOptionQ["abc"]
     = True

    >> NotOptionQ[a -> True]
     = False
    """

    def test(self, expr):
        if not expr.has_form('List', None):
            expr = [expr]
        else:
            expr = expr.get_leaves()
        return not all(e.has_form('Rule', None) or e.has_form('RuleDelayed', 2)
                       for e in expr)


def options_to_rules(options):
    items = sorted(options.iteritems())
    return [Expression('Rule', Symbol(name), value) for name, value in items]

########NEW FILE########
__FILENAME__ = patterns
# -*- coding: utf8 -*-

"""
Patterns and rules

Some examples:
>> a + b + c /. a + b -> t
 = c + t
>> a + 2 + b + c + x * y /. n_Integer + s__Symbol + rest_ -> {n, s, rest}
 = {2, a, b + c + x y}
>> f[a, b, c, d] /. f[first_, rest___] -> {first, {rest}}
 = {a, {b, c, d}}

Tests and Conditions:
>> f[4] /. f[x_?(# > 0&)] -> x ^ 2
 = 16
>> f[4] /. f[x_] /; x > 0 -> x ^ 2
 = 16

Leaves in the beginning of a pattern rather match fewer leaves:
>> f[a, b, c, d] /. f[start__, end__] -> {{start}, {end}}
 = {{a}, {b, c, d}}

Optional arguments using 'Optional':
>> f[a] /. f[x_, y_:3] -> {x, y}
 = {a, 3}

Options using 'OptionsPattern' and 'OptionValue':
>> f[y, a->3] /. f[x_, OptionsPattern[{a->2, b->5}]] -> {x, OptionValue[a], OptionValue[b]}
 = {y, 3, 5}

The attributes 'Flat', 'Orderless', and 'OneIdentity' affect pattern matching.
"""

from mathics.builtin.base import Builtin, BinaryOperator, PostfixOperator
from mathics.builtin.base import PatternObject

from mathics.core.expression import (
    Symbol, Expression, Number, Integer, Rational, Real)
from mathics.core.rules import Rule
from mathics.core.pattern import Pattern, StopGenerator


class Rule_(BinaryOperator):
    """
    >> a+b+c /. c->d
    = a + b + d
    >> {x,x^2,y} /. x->3
     = {3, 9, y}
    """

    # TODO: An error message should appear when Rule is called with a wrong
    # number of arguments
    """
    >> a /. Rule[1, 2, 3] -> t
     : Rule called with 3 arguments; 2 arguments are expected.
     = a
    """

    name = 'Rule'
    operator = '->'
    precedence = 120
    attributes = ('SequenceHold',)
    grouping = 'Right'
    needs_verbatim = True


class RuleDelayed(BinaryOperator):
    """
    >> Attributes[RuleDelayed]
     = {HoldRest, Protected, SequenceHold}
    """

    operator = ':>'
    precedence = 120
    attributes = ('SequenceHold', 'HoldRest')
    needs_verbatim = True


def create_rules(rules_expr, expr, name, evaluation, extra_args=[]):
    if rules_expr.has_form('List', None):
        rules = rules_expr.leaves
    else:
        rules = [rules_expr]
    any_lists = any(item.has_form('List', None) for item in rules)
    if any_lists:
        all_lists = all(item.has_form('List', None) for item in rules)
        if all_lists:
            return Expression(
                'List', *[Expression(name, expr, item, *extra_args)
                          for item in rules]), True
        else:
            evaluation.message(name, 'rmix', rules_expr)
            return None, True
    else:
        result = []
        for rule in rules:
            if rule.get_head_name() not in ('Rule', 'RuleDelayed'):
                evaluation.message(name, 'reps', rule)
                return None, True
            elif len(rule.leaves) != 2:
                evaluation.message(
                    rule.get_head_name(), 'argrx', rule.get_head_name(), 3, 2)
                return None, True
            else:
                result.append(Rule(rule.leaves[0], rule.leaves[1]))
        return result, False


class ReplaceAll(BinaryOperator):
    """
    >> a+b+c /. c->d
     = a + b + d
    >> g[a+b+c,a]/.g[x_+y_,x_]->{x,y}
     = {a, b + c}

    If $rules$ is a list of lists, a list of all possible respective replacements is returned:
    >> {a, b} /. {{a->x, b->y}, {a->u, b->v}}
     = {{x, y}, {u, v}}
    The list can be arbitrarily nested:
    >> {a, b} /. {{{a->x, b->y}, {a->w, b->z}}, {a->u, b->v}}
     = {{{x, y}, {w, z}}, {u, v}}
    >> {a, b} /. {{{a->x, b->y}, a->w, b->z}, {a->u, b->v}}
     : Elements of {{a -> x, b -> y}, a -> w, b -> z} are a mixture of lists and nonlists.
     = {{a, b} /. {{a -> x, b -> y}, a -> w, b -> z}, {u, v}}

    #> a + b /. x_ + y_ -> {x, y}
     = {a, b}
    """

    operator = '/.'
    precedence = 110
    grouping = 'Left'
    needs_verbatim = True

    messages = {
        'reps': "`1` is not a valid replacement rule.",
        'rmix': "Elements of `1` are a mixture of lists and nonlists.",
    }

    def apply(self, expr, rules, evaluation):
        'ReplaceAll[expr_, rules_]'

        rules, ret = create_rules(rules, expr, 'ReplaceAll', evaluation)
        if ret:
            return rules

        result, applied = expr.apply_rules(rules, evaluation)
        return result


class ReplaceRepeated(BinaryOperator):
    """
    >> a+b+c //. c->d
     = a + b + d

    Simplification of logarithms:
    >> logrules = {Log[x_ * y_] :> Log[x] + Log[y], Log[x_ ^ y_] :> y * Log[x]};
    >> Log[a * (b * c) ^ d ^ e * f] //. logrules
     = Log[a] + Log[f] + (Log[b] + Log[c]) d ^ e
    'ReplaceAll' just performs a single replacement:
    >> Log[a * (b * c) ^ d ^ e * f] /. logrules
     = Log[a] + Log[f (b c) ^ d ^ e]
    """

    operator = '//.'
    precedence = 110
    grouping = 'Left'
    needs_verbatim = True

    messages = {
        'reps': "`1` is not a valid replacement rule.",
        'rmix': "Elements of `1` are a mixture of lists and nonlists.",
    }

    def apply_list(self, expr, rules, evaluation):
        'ReplaceRepeated[expr_, rules_]'

        rules, ret = create_rules(rules, expr, 'ReplaceRepeated', evaluation)
        if ret:
            return rules

        while True:
            evaluation.check_stopped()
            result, applied = expr.apply_rules(rules, evaluation)
            if applied:
                result = result.evaluate(evaluation)
            if applied and not result.same(expr):
                expr = result
            else:
                break

        return result


class ReplaceList(Builtin):
    """
    Get all subsequences of a list:
    >> ReplaceList[{a, b, c}, {___, x__, ___} -> {x}]
     = {{a}, {a, b}, {a, b, c}, {b}, {b, c}, {c}}
    You can specify the maximum number of items:
    >> ReplaceList[{a, b, c}, {___, x__, ___} -> {x}, 3]
     = {{a}, {a, b}, {a, b, c}}
    >> ReplaceList[{a, b, c}, {___, x__, ___} -> {x}, 0]
     = {}
    If no rule matches, an empty list is returned:
    >> ReplaceList[a, b->x]
     = {}

    Like in 'ReplaceAll', $rules$ can be a nested list:
    >> ReplaceList[{a, b, c}, {{{___, x__, ___} -> {x}}, {{a, b, c} -> t}}, 2]
     = {{{a}, {a, b}}, {t}}
    >> ReplaceList[expr, {}, -1]
     : Non-negative integer or Infinity expected at position 3.
     = ReplaceList[expr, {}, -1]

    Possible matches for a sum:
    >> ReplaceList[a + b + c, x_ + y_ -> {x, y}]
     = {{a, b + c}, {b, a + c}, {c, a + b}, {a + b, c}, {a + c, b}, {b + c, a}}
    """

    messages = {
        'reps': "`1` is not a valid replacement rule.",
        'rmix': "Elements of `1` are a mixture of lists and nonlists.",
    }

    def apply(self, expr, rules, max, evaluation):
        'ReplaceList[expr_, rules_, max_:Infinity]'

        if max.get_name() == 'Infinity':
            max_count = None
        else:
            max_count = max.get_int_value()
            if max_count is None or max_count < 0:
                evaluation.message('ReplaceList', 'innf', 3)
                return

        rules, ret = create_rules(
            rules, expr, 'ReplaceList', evaluation, extra_args=[max])
        if ret:
            return rules

        list = []
        for rule in rules:
            result = rule.apply(
                expr, evaluation, return_list=True, max_list=max_count)
            list.extend(result)

        return Expression('List', *list)


class PatternTest(BinaryOperator, PatternObject):
    """
    >> MatchQ[3, _Integer?(#>0&)]
     = True
    >> MatchQ[-3, _Integer?(#>0&)]
     = False
    """

    operator = '?'
    precedence = 680

    arg_counts = [2]

    def init(self, expr):
        super(PatternTest, self).init(expr)
        self.pattern = Pattern.create(expr.leaves[0])
        self.test = expr.leaves[1]
        self.test_name = self.test.get_name()

    def quick_pattern_test(self, candidate, test):
        if test == 'NumberQ':
            return isinstance(candidate, Number)
        elif test == 'Negative':
            if isinstance(candidate, (Integer, Rational, Real)):
                return candidate.value < 0
            return False
            # pass
        elif test == 'NegativePowerQ':
            return (
                candidate.has_form('Power', 2) and
                isinstance(candidate.leaves[1], (Integer, Rational, Real)) and
                candidate.leaves[1].value < 0)
        elif test == 'NotNegativePowerQ':
            return not (
                candidate.has_form('Power', 2) and
                isinstance(candidate.leaves[1], (Integer, Rational, Real)) and
                candidate.leaves[1].value < 0)
        else:
            from mathics.builtin import builtins
            from mathics.builtin.base import Test

            builtin = builtins.get(test)
            if builtin is not None and isinstance(builtin, Test):
                return builtin.test(candidate)
        return None

    def match(self, yield_func, expression, vars, evaluation, **kwargs):
        # for vars_2, rest in self.pattern.match(expression, vars, evaluation):
        def yield_match(vars_2, rest):
            items = expression.get_sequence()
            for item in items:
                item = item.evaluate(evaluation)
                quick_test = self.quick_pattern_test(item, self.test_name)
                if quick_test is not None:
                    if not quick_test:
                        break
                        # raise StopGenerator
                else:
                    test_expr = Expression(self.test, item)
                    test_value = test_expr.evaluate(evaluation)
                    if not test_value.is_true():
                        break
                        # raise StopGenerator
            else:
                yield_func(vars_2, None)
        # try:
        self.pattern.match(yield_match, expression, vars, evaluation)
        # except StopGenerator:
        #    pass

    def get_match_count(self, vars={}):
        return self.pattern.get_match_count(vars)


class Alternatives(BinaryOperator, PatternObject):
    """
    >> a+b+c+d/.(a|b)->t
     = c + d + 2 t
    """

    operator = '|'
    precedence = 160
    needs_verbatim = True

    arg_counts = None

    def init(self, expr):
        super(Alternatives, self).init(expr)
        self.alternatives = [Pattern.create(leaf) for leaf in expr.leaves]

    def match(self, yield_func, expression, vars, evaluation, **kwargs):
        for alternative in self.alternatives:
            # for new_vars, rest in alternative.match(
            #     expression, vars, evaluation):
            #     yield_func(new_vars, rest)
            alternative.match(yield_func, expression, vars, evaluation)

    def get_match_count(self, vars={}):
        range = None
        for alternative in self.alternatives:
            sub = alternative.get_match_count(vars)
            if range is None:
                range = list(sub)
            else:
                if sub[0] < range[0]:
                    range[0] = sub[0]
                if range[1] is None or sub[1] > range[1]:
                    range[1] = sub[1]
        return range


def match(expr, form, evaluation):
    class StopGenerator_MatchQ(StopGenerator):
        pass

    form = Pattern.create(form)

    def yield_func(vars, rest):
        raise StopGenerator_MatchQ(Symbol("True"))
    try:
        form.match(yield_func, expr, {}, evaluation)
    except StopGenerator_MatchQ:
        return True
    return False


class MatchQ(Builtin):
    """
    <dl>
        <dt>'MatchQ[$expr$, $form$]'
        <dd>tests whether $expr$ matches $form$.
    </dl>

    >> MatchQ[123, _Integer]
     = True
    >> MatchQ[123, _Real]
     = False
    """

    def apply(self, expr, form, evaluation):
        'MatchQ[expr_, form_]'

        if match(expr, form, evaluation):
            return Symbol("True")
        return Symbol("False")


class Verbatim(PatternObject):
    """
    >> _ /. Verbatim[_]->t
     = t
    >> x /. Verbatim[_]->t
     = x
    >> x /. _->t
     = t
    """

    arg_counts = [1, 2]

    def init(self, expr):
        super(Verbatim, self).init(expr)
        self.content = expr.leaves[0]

    def match(self, yield_func, expression, vars, evaluation, **kwargs):
        if self.content.same(expression):
            yield_func(vars, None)


class HoldPattern(PatternObject):

    """
    'HoldPattern[$expr$]' is equivalent to $expr$ for pattern matching,
    but maintains it in an unevaluated form.

    >> HoldPattern[x + x]
     = HoldPattern[x + x]
    >> x /. HoldPattern[x] -> t
     = t

    'HoldPattern' has attribute 'HoldAll':
    >> Attributes[HoldPattern]
     = {HoldAll, Protected}
    """

    attributes = ('HoldAll',)

    arg_counts = [1]

    def init(self, expr):
        super(HoldPattern, self).init(expr)
        self.pattern = Pattern.create(expr.leaves[0])

    def match(self, yield_func, expression, vars, evaluation, **kwargs):
        # for new_vars, rest in self.pattern.match(
        #     expression, vars, evaluation):
        #     yield new_vars, rest
        self.pattern.match(yield_func, expression, vars, evaluation)


class Pattern_(PatternObject):
    """
    <dl>
    <dt>'Pattern[$symb$, $patt$]' or '$symb$ : $patt$'
        <dd>assigns the name $symb$ to the pattern $patt$.
    <dt>'$symb$_$head$'
        <dd>is equivalent to '$symb$ : _$head$' (accordingly with '__' and '___').
    <dt>'$symb$ : $patt$ : $default$'
        <dd>is a pattern with name $symb$ and default value $default$,
        equivalent to 'Optional[$patt$ : $symb$, $default$]'.
    </dl>

    >> FullForm[a_b]
     = Pattern[a, Blank[b]]
    >> FullForm[a:_:b]
     = Optional[Pattern[a, Blank[]], b]

    'Pattern' has attribute 'HoldFirst', so it does not evaluate its name:
    >> x = 2
     = 2
    >> x_
     = x_

    Nested 'Pattern' assign multiple names to the same pattern. Still,
    the last parameter is the default value.
    >> f[y] /. f[a:b:_:d] -> {a, b}
     = {y, y}
    This is equivalent to:
    >> f[] /. f[a:b_:d] -> {a, b}
     = {d, d}
    'FullForm':
    >> FullForm[a:b:c:d:e]
     = Optional[Pattern[a, b], Optional[Pattern[c, d], e]]

    ## Test parsing for following TODO test
    #> Hold[f[] /. f[a:b:_:d] -> {a, b}] // FullForm
     = Hold[ReplaceAll[f[], Rule[f[Pattern[a, Optional[Pattern[b, Blank[]], d]]], List[a, b]]]]
    """

    # TODO: This parses correctly (see above test) but computes incorrectly
    """
    >> f[] /. f[a:b:_:d] -> {a, b}
     = {d, d}
    """

    name = 'Pattern'

    arg_counts = [2]

    attributes = ('HoldFirst',)

    messages = {
        'patvar': "First element in pattern `1` is not a valid pattern name.",
        'nodef': ("No default setting found for `1` in "
                  "position `2` when length is `3`."),
    }

    rules = {
        'MakeBoxes[Verbatim[Pattern][symbol_Symbol, blank_Blank|blank_BlankSequence|blank_BlankNullSequence], f:StandardForm|TraditionalForm|InputForm|OutputForm]': 'MakeBoxes[symbol, f] <> MakeBoxes[blank, f]',
        # 'StringForm["`1``2`", HoldForm[symbol], blank]',
    }

    formats = {
        'Verbatim[Pattern][symbol_, '
        'pattern_?(!MatchQ[#, _Blank|_BlankSequence|_BlankNullSequence]&)]': (
            'Infix[{symbol, pattern}, ":", 140]'),
    }

    def init(self, expr):
        super(Pattern_, self).init(expr)
        self.varname = expr.leaves[0].get_name()
        if self.varname is None:
            self.error('patvar', expr)
        self.pattern = Pattern.create(expr.leaves[1])

    def get_match_count(self, vars={}):
        return self.pattern.get_match_count(vars)

    def match(self, yield_func, expression, vars, evaluation, **kwargs):
        existing = vars.get(self.varname, None)
        if existing is None:
            new_vars = vars.copy()
            new_vars[self.varname] = expression
            # for vars_2, rest in self.pattern.match(
            #    expression, new_vars, evaluation):
            #    yield vars_2, rest
            self.pattern.match(yield_func, expression, new_vars, evaluation)
        else:
            if existing.same(expression):
                yield_func(vars, None)

    def get_match_candidates(self, leaves, expression, attributes, evaluation,
                             vars={}):
        existing = vars.get(self.varname, None)
        if existing is None:
            return self.pattern.get_match_candidates(
                leaves, expression, attributes, evaluation, vars)
        else:
            # Treat existing variable as verbatim
            verbatim_expr = Expression('Verbatim', existing)
            verbatim = Verbatim(verbatim_expr)
            return verbatim.get_match_candidates(
                leaves, expression, attributes, evaluation, vars)


class Optional(BinaryOperator, PatternObject):
    """
    <dl>
    <dt>'Optional[$patt$, $default$]' or '$patt$ : $default$'
        <dd>is a pattern which matches $patt$ and which, if omitted should be replaced by $default$.
    </dl>

    >> f[x_, y_:1] := {x, y}
    >> f[1, 2]
     = {1, 2}
    >> f[a]
     = {a, 1}

    Note that '$symb$ : $patt$' represents a 'Pattern' object. However, there is no
    disambiguity, since $symb$ has to be a symbol in this case.

    >> x:_ // FullForm
     = Pattern[x, Blank[]]
    >> _:d // FullForm
     = Optional[Blank[], d]
    >> x:_+y_:d // FullForm
     = Pattern[x, Plus[Blank[], Optional[Pattern[y, Blank[]], d]]]

    's_.' is equivalent to 'Optional[s_]' and represents an optional parameter which, if omitted,
    gets its value from 'Default'.
    >> FullForm[s_.]
     = Optional[Pattern[s, Blank[]]]

    >> Default[h, k_] := k
    >> h[a] /. h[x_, y_.] -> {x, y}
     = {a, 2}
    """

    operator = ':'
    precedence = 140
    grouping = 'Right'

    default_formats = False

    def post_parse(self, expression):
        leaves = [leaf.post_parse() for leaf in expression.leaves]
        expression = Expression(expression.head.post_parse(), *leaves)
        if (expression.has_form('Optional', 2) and expression.leaves[0].get_name()):
            sub = expression.leaves[1]
            if sub.has_form(('Pattern', 'Optional'), 2):
                return Expression(
                    'Optional',
                    Expression('Pattern', expression.leaves[0], sub.leaves[0]),
                    sub.leaves[1])
            else:
                return Expression(
                    'Pattern',
                    *[leaf.post_parse() for leaf in expression.leaves])
        else:
            return expression

    rules = {
        'MakeBoxes[Verbatim[Optional][Verbatim[Pattern][symbol_Symbol, Verbatim[_]]], f:StandardForm|TraditionalForm|InputForm|OutputForm]': 'MakeBoxes[symbol, f] <> "_."',
        'MakeBoxes[Verbatim[Optional][Verbatim[_]], f:StandardForm|TraditionalForm|InputForm|OutputForm]': '"_."',
    }

    formats = {
        'Verbatim[Optional][pattern_Pattern, default_]': 'Infix[{HoldForm[pattern], HoldForm[default]}, ":", 150]',
    }

    arg_counts = [1, 2]

    def init(self, expr):
        super(Optional, self).init(expr)
        self.pattern = Pattern.create(expr.leaves[0])
        if len(expr.leaves) == 2:
            self.default = expr.leaves[1]
        else:
            self.default = None

    def match(self, yield_func, expression, vars, evaluation, head=None,
              leaf_index=None, leaf_count=None, **kwargs):
        if expression.has_form('Sequence', 0):
            if self.default is None:
                if head is None:  # head should be given by match_leaf!
                    default = None
                else:
                    name = head.get_name()
                    default = get_default_value(
                        name, evaluation, leaf_index, leaf_count)
                if default is None:
                    evaluation.message(
                        'Pattern', 'nodef', head, leaf_index, leaf_count)
                    return
            else:
                default = self.default

            expression = default
        # for vars_2, rest in self.pattern.match(expression, vars, evaluation):
        #    yield vars_2, rest
        self.pattern.match(yield_func, expression, vars, evaluation)

    def get_match_count(self, vars={}):
        return (0, 1)


def get_default_value(name, evaluation, k=None, n=None):
    pos = []
    if k is not None:
        pos.append(k)
    if n is not None:
        pos.append(n)
    for pos_len in reversed(range(len(pos) + 1)):
        # Try patterns from specific to general
        defaultexpr = Expression('Default', Symbol(name),
                                 *[Integer(index) for index in pos[:pos_len]])
        result = evaluation.definitions.get_value(name, 'DefaultValues',
                                                  defaultexpr, evaluation)
        if result is not None:
            if result.same(defaultexpr):
                result = result.evaluate(evaluation)
            return result
    return None


class _Blank(PatternObject):
    arg_counts = [0, 1]

    def init(self, expr):
        super(_Blank, self).init(expr)
        if expr.leaves:
            self.head = expr.leaves[0]
        else:
            self.head = None


class Blank(_Blank):
    rules = {
        'MakeBoxes[Verbatim[Blank][], f:StandardForm|TraditionalForm|OutputForm|InputForm]': '"_"',
        'MakeBoxes[Verbatim[Blank][head_Symbol], f:StandardForm|TraditionalForm|OutputForm|InputForm]': '"_" <> MakeBoxes[head, f]',
    }

    def match(self, yield_func, expression, vars, evaluation, **kwargs):
        if not expression.has_form('Sequence', 0):
            if self.head is not None:
                if expression.get_head().same(self.head):
                    yield_func(vars, None)
            else:
                yield_func(vars, None)


class BlankSequence(_Blank):
    rules = {
        'MakeBoxes[Verbatim[BlankSequence][], f:StandardForm|TraditionalForm|OutputForm|InputForm]': '"__"',
        'MakeBoxes[Verbatim[BlankSequence][head_Symbol], f:StandardForm|TraditionalForm|OutputForm|InputForm]': '"__" <> MakeBoxes[head, f]',
    }

    def match(self, yield_func, expression, vars, evaluation, **kwargs):
        leaves = expression.get_sequence()
        if not leaves:
            return
        if self.head:
            ok = True
            for leaf in leaves:
                if leaf.get_head() != self.head:
                    ok = False
                    break
            if ok:
                yield_func(vars, None)
        else:
            yield_func(vars, None)

    def get_match_count(self, vars={}):
        return (1, None)


class BlankNullSequence(_Blank):
    """
    >> ___symbol
     = ___symbol
    >> ___symbol //FullForm
     = BlankNullSequence[symbol]
    """

    rules = {
        'MakeBoxes[Verbatim[BlankNullSequence][], f:StandardForm|TraditionalForm|OutputForm|InputForm]': '"___"',
        'MakeBoxes[Verbatim[BlankNullSequence][head_Symbol], f:StandardForm|TraditionalForm|OutputForm|InputForm]': '"___" <> MakeBoxes[head, f]',
    }

    def match(self, yield_func, expression, vars, evaluation, **kwargs):
        leaves = expression.get_sequence()
        if self.head:
            ok = True
            for leaf in leaves:
                if leaf.get_head() != self.head:
                    ok = False
                    break
            if ok:
                yield_func(vars, None)
        else:
            yield_func(vars, None)

    def get_match_count(self, vars={}):
        return (0, None)


class Repeated(PostfixOperator, PatternObject):
    """
    >> a_Integer.. // FullForm
     = Repeated[Pattern[a, Blank[Integer]]]
    >> 0..1//FullForm
     = Repeated[0]
    >> {{}, {a}, {a, b}, {a, a, a}, {a, a, a, a}} /. {Repeated[x : a | b, 3]} -> x
     = {{}, a, {a, b}, a, {a, a, a, a}}
    >> f[x, 0, 0, 0] /. f[x, s:0..] -> s
     = Sequence[0, 0, 0]

    #> 1.. // FullForm
     = Repeated[1]
    #> 8^^1.. // FullForm   (* Mathematica gets this wrong *)
     = Repeated[1]
    """

    messages = {
        'range': (
            "Range specification in integers (max or {min, max}) "
            "expected at position `1` in `2`."),
    }

    operator = '..'
    precedence = 170

    arg_counts = [1, 2]

    def init(self, expr, min=1):
        self.pattern = Pattern.create(expr.leaves[0])

        self.max = None
        self.min = min
        if len(expr.leaves) == 2:
            leaf_1 = expr.leaves[1]
            if (leaf_1.has_form('List', 1, 2) and all(leaf.get_int_value() for leaf in leaf_1.leaves)):
                self.max = leaf_1.leaves[-1].get_int_value()
                self.min = leaf_1.leaves[0].get_int_value()
            elif leaf_1.get_int_value():
                self.max = leaf_1.get_int_value()
            else:
                self.error('range', 2, expr)

    def match(self, yield_func, expression, vars, evaluation, **kwargs):
        leaves = expression.get_sequence()
        if len(leaves) < self.min:
            return
        if self.max is not None and len(leaves) > self.max:
            return

        def iter(yield_iter, rest_leaves, vars):
            if rest_leaves:
                # for new_vars, rest in self.pattern.match(rest_leaves[0],
                # vars, evaluation):
                def yield_match(new_vars, rest):
                    # for sub_vars, sub_rest in iter(rest_leaves[1:],
                    #                                new_vars):
                    #    yield sub_vars, rest
                    iter(yield_iter, rest_leaves[1:], new_vars)

                self.pattern.match(
                    yield_match, rest_leaves[0], vars, evaluation)
            else:
                yield_iter(vars, None)

        # for vars, rest in iter(leaves, vars):
        #    yield_func(vars, rest)
        iter(yield_func, leaves, vars)

    def get_match_count(self, vars={}):
        return (self.min, self.max)


class RepeatedNull(Repeated):
    """
    >> a___Integer...//FullForm
     = RepeatedNull[Pattern[a, BlankNullSequence[Integer]]]
    >> f[x] /. f[x, 0...] -> t
     = t

    #> 1... // FullForm
     = RepeatedNull[1]
    #> 8^^1... // FullForm   (* Mathematica gets this wrong *)
     = RepeatedNull[1]
    """

    operator = '...'
    precedence = 170

    def init(self, expr):
        super(RepeatedNull, self).init(expr, min=0)


class Condition(BinaryOperator, PatternObject):
    """
    'Condition' sets a condition on the pattern to match, using variables of the pattern.

    >> f[3] /. f[x_] /; x>0 -> t
     = t
    >> f[-3] /. f[x_] /; x>0 -> t
     = f[-3]

    'Condition' can be used in an assignment:
    >> f[x_] := p[x] /; x>0
    >> f[3]
     = p[3]
    >> f[-3]
     = f[-3]
    """

    operator = '/;'
    precedence = 130

    # Don't know why this has attribute HoldAll in Mathematica
    attributes = ('HoldRest',)

    arg_counts = [2]

    def init(self, expr):
        super(Condition, self).init(expr)
        self.pattern = Pattern.create(expr.leaves[0])
        self.test = expr.leaves[1]

    def match(self, yield_func, expression, vars, evaluation, **kwargs):
        # for new_vars, rest in self.pattern.match(expression, vars,
        # evaluation):
        def yield_match(new_vars, rest):
            test_expr = self.test.replace_vars(new_vars)
            test_result = test_expr.evaluate(evaluation)
            if test_result.is_true():
                yield_func(new_vars, rest)
        self.pattern.match(yield_match, expression, vars, evaluation)


class OptionsPattern(PatternObject):
    """
    <dl>
    <dt>'OptionsPattern[$f$]'
        <dd>is a pattern that stands for a sequence of options given to a function,
        with default values taken from 'Options[$f$]'. The options can be of the form
        '$opt$->$value$' or '$opt$:>$value$', and might be in arbitrarily nested lists.
    <dt>'OptionsPattern[{$opt1$->$value1$, ...}]'
        <dd>takes explicit default values from the given list.
        The list may also contain symbols $f$, for which 'Options[$f$]' is taken into account;
        it may be arbitrarily nested.
        'OptionsPattern[{}]' does not use any default values.
    </dl>

    The option values can be accessed using 'OptionValue'.

    >> f[x_, OptionsPattern[{n->2}]] := x ^ OptionValue[n]
    >> f[x]
     = x ^ 2
    >> f[x, n->3]
     = x ^ 3

    Delayed rules as options:
    >> e = f[x, n:>a]
     = x ^ a
    >> a = 5;
    >> e
     = x ^ 5

    Options might be given in nested lists:
    >> f[x, {{{n->4}}}]
     = x ^ 4

    #> {opt -> b} /. OptionsPattern[{}] -> t
     = t

    #> Clear[f]
    #> Options[f] = {Power -> 2};
    #> f[x_, OptionsPattern[f]] := x ^ OptionValue[Power]
    #> f[10]
     = 100
    #> f[10, Power -> 3]
     = 1000
    #> Clear[f]

    #> Options[f] = {Power -> 2};
    #> f[x_, OptionsPattern[]] := x ^ OptionValue[Power]
    #> f[10]
     = 100
    #> f[10, Power -> 3]
     = 1000
    #> Clear[f]
    """

    arg_counts = [0, 1]

    def init(self, expr):
        super(OptionsPattern, self).init(expr)
        try:
            self.defaults = expr.leaves[0]
        except IndexError:
            # OptionsPattern[] takes default options of the nearest enclosing
            # function. Set to not None in self.match
            self.defaults = None

    def match(self, yield_func, expression, vars, evaluation, **kwargs):
        if self.defaults is None:
            self.defaults = kwargs['head']
        values = self.defaults.get_option_values(
            evaluation, allow_symbols=True, stop_on_error=False)
        sequence = expression.get_sequence()
        for options in sequence:
            option_values = options.get_option_values(evaluation)
            if option_values is None:
                return
            values.update(option_values)
        new_vars = vars.copy()
        for name, value in values.items():
            new_vars['_option_' + name] = value
        yield_func(new_vars, None)

    def get_match_count(self, vars={}):
        return (0, None)

    def get_match_candidates(self, leaves, expression, attributes, evaluation,
                             vars={}):
        def _match(leaf):
            return (leaf.has_form(('Rule', 'RuleDelayed'), 2) or
                    leaf.has_form('List', None))
        return [leaf for leaf in leaves if _match(leaf)]

########NEW FILE########
__FILENAME__ = physchemdata
# -*- coding: utf8 -*-

"""
Physical and Chemical data
"""

from csv import reader as csvreader

from mathics.builtin.base import Builtin
from mathics.core.expression import Expression, from_python, Symbol, String
from mathics.settings import ROOT_DIR


def load_element_data():
    element_file = open(ROOT_DIR + 'data/element.csv', 'rb')
    reader = csvreader(element_file, delimiter='\t')
    element_data = []
    for row in reader:
        element_data.append([value for value in row])
    element_file.close()
    return element_data

_ELEMENT_DATA = load_element_data()


class ElementData(Builtin):
    """
    <dl>
    <dt>'ElementData["$name$", "$property$"]
        <dd>gives the value of the $property$ for the chemical specified by $name$".
    <dt>'ElementData[$n$, "$property$"]
        <dd>gives the value of the $property$ for the $n$th chemical element".
    </dl>

    >> ElementData[74]
     = Tungsten

    >> ElementData["He", "AbsoluteBoilingPoint"]
     = 4.22

    >> ElementData["Carbon", "IonizationEnergies"]
     = {1086.5, 2352.6, 4620.5, 6222.7, 37831, 47277.}

    >> ElementData[16, "ElectronConfigurationString"]
     = [Ne] 3s2 3p4

    >> ElementData[73, "ElectronConfiguration"]
     = {{2}, {2, 6}, {2, 6, 10}, {2, 6, 10, 14}, {2, 6, 3}, {2}}

    The number of known elements:
    >> Length[ElementData[All]]
     = 118

    Some properties are not appropriate for certain elements:
    >> ElementData["He", "ElectroNegativity"]
     = Missing[NotApplicable]

    Some data is missing:
    >> ElementData["Tc", "SpecificHeat"]
     = Missing[NotAvailable]

    All the known properties:
    >> ElementData["Properties"]
     = {Abbreviation, AbsoluteBoilingPoint, AbsoluteMeltingPoint, AtomicNumber, AtomicRadius, AtomicWeight, Block, BoilingPoint, BrinellHardness, BulkModulus, CovalentRadius, CrustAbundance, Density, DiscoveryYear, ElectroNegativity, ElectronAffinity, ElectronConfiguration, ElectronConfigurationString, ElectronShellConfiguration, FusionHeat, Group, IonizationEnergies, LiquidDensity, MeltingPoint, MohsHardness, Name, Period, PoissonRatio, Series, ShearModulus, SpecificHeat, StandardName, ThermalConductivity, VanDerWaalsRadius, VaporizationHeat, VickersHardness, YoungModulus}

    >> ListPlot[Table[ElementData[z, "AtomicWeight"], {z, 118}]]
     = -Graphics-
    """

    rules = {
        'ElementData[n_]': 'ElementData[n, "StandardName"]',
        'ElementData[]': 'ElementData[All]',
        'ElementData["Properties"]': 'ElementData[All, "Properties"]',
    }

    messages = {
        'noent': ('`1` is not a known entity, class, or tag for ElementData. '
                  'Use ElementData[] for a list of entities.'),
        'noprop': ('`1` is not a known property for ElementData. '
                   'Use ElementData["Properties"] for a list of properties.'),
    }

    def apply_all(self, evaluation):
        'ElementData[All]'
        iprop = _ELEMENT_DATA[0].index('StandardName')
        return from_python([element[iprop] for element in _ELEMENT_DATA[1:]])

    def apply_all_properties(self, evaluation):
        'ElementData[All, "Properties"]'
        return from_python(sorted(_ELEMENT_DATA[0]))

    def apply_name(self, name, prop, evaluation):
        "ElementData[name_?StringQ, prop_]"
        py_name = name.to_python().strip('"')
        names = ['StandardName', 'Name', 'Abbreviation']
        iprops = [_ELEMENT_DATA[0].index(s) for s in names]

        indx = None
        for iprop in iprops:
            try:
                indx = [element[iprop] for element in
                        _ELEMENT_DATA[1:]].index(py_name) + 1
            except ValueError:
                pass

        if indx is None:
            evaluation.message("ElementData", "noent", name)
            return

        return self.apply_int(from_python(indx), prop, evaluation)

    def apply_int(self, n, prop, evaluation):
        "ElementData[n_?IntegerQ, prop_]"

        from mathics.core.parser import parse

        py_n = n.to_python()
        py_prop = prop.to_python()

        # Check element specifier n or "name"
        if isinstance(py_n, int):
            if not 1 <= py_n <= 118:
                evaluation.message("ElementData", "noent", n)
                return
        elif isinstance(py_n, unicode):
            pass
        else:
            evaluation.message("ElementData", "noent", n)
            return

        # Check property specifier
        if isinstance(py_prop, str) or isinstance(py_prop, unicode):
            py_prop = str(py_prop)

        if py_prop == '"Properties"':
            result = []
            for i, p in enumerate(_ELEMENT_DATA[py_n]):
                if p not in ["NOT_AVAILABLE", "NOT_APPLICABLE", "NOT_KNOWN"]:
                    result.append(_ELEMENT_DATA[0][i])
            return from_python(sorted(result))

        if not (isinstance(py_prop, str) and
                py_prop[0] == py_prop[-1] == '"' and
                py_prop.strip('"') in _ELEMENT_DATA[0]):
            evaluation.message("ElementData", "noprop", prop)
            return

        iprop = _ELEMENT_DATA[0].index(py_prop.strip('"'))
        result = _ELEMENT_DATA[py_n][iprop]

        if result == "NOT_AVAILABLE":
            return Expression("Missing", "NotAvailable")

        if result == "NOT_APPLICABLE":
            return Expression("Missing", "NotApplicable")

        if result == "NOT_KNOWN":
            return Expression("Missing", "Unknown")

        result = parse(result)
        if isinstance(result, Symbol):
            result = String(result.get_name())
        return result

########NEW FILE########
__FILENAME__ = plot
# -*- coding: utf8 -*-

"""
Plotting
"""

from math import sin, cos, pi, sqrt, isnan, isinf
import numbers

from mathics.core.expression import (Expression, Real, NumberError, Symbol,
                                     String, from_python)
from mathics.builtin.base import Builtin
from mathics.builtin.scoping import dynamic_scoping
from mathics.builtin.options import options_to_rules
from mathics.builtin.numeric import chop


class ColorDataFunction(Builtin):
    pass


class ColorData(Builtin):
    rules = {
        'ColorData["LakeColors"]': (
            """ColorDataFunction["LakeColors", "Gradients", {0, 1},
                Blend[{RGBColor[0.293416, 0.0574044, 0.529412],
                    RGBColor[0.563821, 0.527565, 0.909499],
                    RGBColor[0.762631, 0.846998, 0.914031],
                    RGBColor[0.941176, 0.906538, 0.834043]}, #1] &]"""),
    }


class Mesh(Builtin):
    """
    <dl>
    <dt>'Mesh'
        <dd>is an option for 'Plot' that specifies the mesh to be drawn. The default is 'Mesh->None'.
     </dl>

    >> Plot[Sin[Cos[x^2]],{x,-4,4},Mesh->All]
     = -Graphics-

    >> Plot[Sin[x], {x,0,4 Pi}, Mesh->Full]
     = -Graphics-

    >>DensityPlot[Sin[x y], {x, -2, 2}, {y, -2, 2}, Mesh->Full]
     = -Graphics-

    >>Plot3D[Sin[x y], {x, -2, 2}, {y, -2, 2}, Mesh->Full]
     = -Graphics3D-
    """

    messages = {
        'ilevels': "`1` is not a valid mesh specification.",
    }


def quiet_evaluate(expr, vars, evaluation, expect_list=False):
    """ Evaluates expr with given dynamic scoping values
    without producing arithmetic error messages. """
    expr = Expression('N', expr)
    quiet_expr = Expression('Quiet', expr, Expression(
        'List', Expression('MessageName', Symbol('Power'), String('infy'))))
    value = dynamic_scoping(quiet_expr.evaluate, vars, evaluation)
    if expect_list:
        if value.has_form('List', None):
            value = [chop(item).get_real_value() for item in value.leaves]
            if any(item is None for item in value):
                return None
            return value
        else:
            return None
    else:
        value = chop(value).get_real_value()
        if value is None or isinf(value) or isnan(value):
            return None
        return value


def zero_to_one(value):
    if value == 0:
        return 1
    return value


def automatic_plot_range(values):
    """ Calculates mean and standard deviation, throwing away all points
    which are more than 'thresh' number of standard deviations away from
    the mean. These are then used to find good vmin and vmax values. These
    values can then be used to find Automatic Plotrange. """

    if not values:
        return 0, 1

    thresh = 2.0
    values = sorted(values)
    valavg = sum(values) / len(values)
    valdev = sqrt(sum([(x - valavg) ** 2 for x in values]) / zero_to_one(len(values) - 1))

    n1, n2 = 0, len(values) - 1
    if valdev != 0:
        for v in values:
            if abs(v - valavg) / valdev < thresh:
                break
            n1 += 1
        for v in values[::-1]:
            if abs(v - valavg) / valdev < thresh:
                break
            n2 -= 1

    vrange = values[n2] - values[n1]
    vmin = values[n1] - 0.05 * vrange    # 5% extra looks nice
    vmax = values[n2] + 0.05 * vrange
    return vmin, vmax


def get_plot_range(values, all_values, option):
    if option == 'Automatic':
        result = automatic_plot_range(values)
    elif option == 'All':
        if not all_values:
            result = [0, 1]
        else:
            result = min(all_values), max(all_values)
    else:
        result = option
    if result[0] == result[1]:
        value = result[0]
        if value > 0:
            return 0, value * 2
        if value < 0:
            return value * 2, 0
        return -1, 1
    return result


class _Plot(Builtin):
    from graphics import Graphics

    attributes = ('HoldAll',)

    options = Graphics.options.copy()
    options.update({
        'Axes': 'True',
        'AspectRatio': '1 / GoldenRatio',
        'MaxRecursion': 'Automatic',
        'Mesh': 'None',
        'PlotRange': 'Automatic',
        'PlotPoints': 'None',
        'Exclusions': 'Automatic',
    })

    messages = {
        'invmaxrec': (
            "MaxRecursion must be a non-negative integer; the recursion value "
            "is limited to `2`. Using MaxRecursion -> `1`."),
        'prng': ("Value of option PlotRange -> `1` is not All, Automatic or "
                 "an appropriate list of range specifications."),
        'ppts': "Value of option PlotPoints -> `1` is not an integer >= 2.",
        'invexcl': ("Value of Exclusions -> `1` is not None, Automatic or an "
                    "appropriate list of constraints."),
    }

    def apply(self, functions, x, start, stop, evaluation, options):
        '''%(name)s[functions_, {x_Symbol, start_, stop_},
            OptionsPattern[%(name)s]]'''
        if functions.is_symbol() and functions.name is not x.get_name():
            rules = evaluation.definitions.get_ownvalues(functions.name)
            for rule in rules:
                functions = rule.apply(functions, evaluation, fully=True)

        if functions.get_head_name() == 'List':
            functions_param = self.get_functions_param(functions)
            for index, f in enumerate(functions_param):
                if f.is_symbol() and f.name is not x.get_name():
                    rules = evaluation.definitions.get_ownvalues(f.name)
                    for rule in rules:
                        f = rule.apply(f, evaluation, fully=True)
                functions_param[index] = f
            functions = functions.flatten(Symbol('List'))

        expr_limits = Expression('List', x, start, stop)
        expr = Expression(self.get_name(), functions, expr_limits,
                          *options_to_rules(options))
        functions = self.get_functions_param(functions)
        x_name = x.get_name()

        try:
            start = start.to_number(n_evaluation=evaluation)
        except NumberError:
            evaluation.message(self.get_name(), 'plln', start, expr)
            return
        try:
            stop = stop.to_number(n_evaluation=evaluation)
        except NumberError:
            evaluation.message(self.get_name(), 'plln', stop, expr)
            return
        if start >= stop:
            evaluation.message(self.get_name(), 'plld', expr_limits)
            return

        # PlotRange Option
        def check_range(range):
            if range in ('Automatic', 'All'):
                return True
            if isinstance(range, list) and len(range) == 2:
                if (isinstance(range[0], numbers.Real) and  # noqa
                    isinstance(range[1], numbers.Real)):
                    return True
            return False
        plotrange_option = self.get_option(options, 'PlotRange', evaluation)
        plotrange = plotrange_option.to_python(n_evaluation=evaluation)
        x_range, y_range = self.get_plotrange(plotrange, start, stop)
        if not check_range(x_range) or not check_range(y_range):
            evaluation.message(self.get_name(), 'prng', plotrange_option)
            x_range, y_range = [start, stop], 'Automatic'
        # x_range and y_range are now either Automatic, All, or of the form
        # [min, max]
        assert x_range in ('Automatic', 'All') or isinstance(x_range, list)
        assert y_range in ('Automatic', 'All') or isinstance(y_range, list)

        # Mesh Option
        mesh_option = self.get_option(options, 'Mesh', evaluation)
        mesh = mesh_option.to_python()
        if mesh not in ['None', 'Full', 'All']:
            evaluation.message('Mesh', 'ilevels', mesh_option)
            mesh = 'None'

        # PlotPoints Option
        plotpoints_option = self.get_option(options, 'PlotPoints', evaluation)
        plotpoints = plotpoints_option.to_python()
        if plotpoints == 'None':
            plotpoints = 57
        if not (isinstance(plotpoints, int) and plotpoints >= 2):
            return evaluation.message(self.get_name(), 'ppts', plotpoints)

        # MaxRecursion Option
        max_recursion_limit = 15
        maxrecursion_option = self.get_option(
            options, 'MaxRecursion', evaluation)
        maxrecursion = maxrecursion_option.to_python()
        try:
            if maxrecursion == 'Automatic':
                maxrecursion = 3
            elif maxrecursion == float('inf'):
                maxrecursion = max_recursion_limit
                raise ValueError
            elif isinstance(maxrecursion, int):
                if maxrecursion > max_recursion_limit:
                    maxrecursion = max_recursion_limit
                    raise ValueError
                if maxrecursion < 0:
                    maxrecursion = 0
                    raise ValueError
            else:
                maxrecursion = 0
                raise ValueError
        except ValueError:
            evaluation.message(self.get_name(), 'invmaxrec', maxrecursion,
                               max_recursion_limit)
        assert isinstance(maxrecursion, int)

        # Exclusions Option
        # TODO: Make exclusions option work properly with ParametricPlot
        def check_exclusion(excl):
            if isinstance(excl, list):
                return all(check_exclusion(e) for e in excl)
            if excl == 'Automatic':
                return True
            if not isinstance(excl, numbers.Real):
                return False
            return True

        exclusions_option = self.get_option(options, 'Exclusions', evaluation)
        exclusions = exclusions_option.to_python(n_evaluation=evaluation)
        # TODO Turn expressions into points E.g. Sin[x] == 0 becomes 0, 2 Pi...

        if exclusions in ['None', ['None']]:
            exclusions = 'None'
        elif not isinstance(exclusions, list):
            exclusions = [exclusions]

            if (isinstance(exclusions, list) and        # noqa
                all(check_exclusion(excl) for excl in exclusions)):
                pass

            else:
                evaluation.message(
                    self.get_name(), 'invexcl', exclusions_option)
                exclusions = ['Automatic']

        # exclusions is now either 'None' or a list of reals and 'Automatic'
        assert (exclusions == 'None' or isinstance(exclusions, list))

        # constants to generate colors
        hue = 0.67
        hue_pos = 0.236068
        hue_neg = -0.763932

        def get_points_minmax(points):
            xmin = xmax = ymin = ymax = None
            for line in points:
                for x, y in line:
                    if xmin is None or x < xmin:
                        xmin = x
                    if xmax is None or x > xmax:
                        xmax = x
                    if ymin is None or y < ymin:
                        ymin = y
                    if ymax is None or y > ymax:
                        ymax = y
            return xmin, xmax, ymin, ymax

        def get_points_range(points):
            xmin, xmax, ymin, ymax = get_points_minmax(points)
            if xmin is None or xmax is None:
                xmin, xmax = 0, 1
            if ymin is None or ymax is None:
                ymin, ymax = 0, 1
            return zero_to_one(xmax - xmin), zero_to_one(ymax - ymin)

        function_hues = []
        base_plot_points = []   # list of points in base subdivision
        plot_points = []        # list of all plotted points
        mesh_points = []
        graphics = []           # list of resulting graphics primitives
        for index, f in enumerate(functions):
            points = []
            xvalues = []  # x value for each point in points
            tmp_mesh_points = []  # For this function only
            continuous = False
            d = (stop - start) / (plotpoints - 1)
            for i in xrange(plotpoints):
                x_value = start + i * d
                point = self.eval_f(f, x_name, x_value, evaluation)
                if point is not None:
                    if continuous:
                        points[-1].append(point)
                        xvalues[-1].append(x_value)
                    else:
                        points.append([point])
                        xvalues.append([x_value])
                    continuous = True
                else:
                    continuous = False

            base_points = []
            for line in points:
                base_points.extend(line)
            base_plot_points.extend(base_points)

            xmin, xmax = automatic_plot_range([xx for xx, yy in base_points])
            xscale = 1. / zero_to_one(xmax - xmin)
            ymin, ymax = automatic_plot_range([yy for xx, yy in base_points])
            yscale = 1. / zero_to_one(ymax - ymin)

            if mesh == 'Full':
                for line in points:
                    tmp_mesh_points.extend(line)

            def find_excl(excl):
                # Find which line the exclusion is in
                for l in range(len(xvalues)):  # TODO: Binary Search faster?
                    if xvalues[l][0] <= excl and xvalues[l][-1] >= excl:
                        break
                    if (xvalues[l][-1] <= excl and      # nopep8
                        xvalues[min(l + 1, len(xvalues) - 1)][0] >= excl):
                        return min(l + 1, len(xvalues) - 1), 0, False
                xi = 0
                for xi in range(len(xvalues[l]) - 1):
                    if xvalues[l][xi] <= excl and xvalues[l][xi + 1] >= excl:
                        return l, xi + 1, True
                return l, xi + 1, False

            if exclusions != 'None':
                for excl in exclusions:
                        if excl != 'Automatic':
                            l, xi, split_required = find_excl(excl)
                            if split_required:
                                xvalues.insert(l + 1, xvalues[l][xi:])
                                xvalues[l] = xvalues[l][:xi]
                                points.insert(l + 1, points[l][xi:])
                                points[l] = points[l][:xi]
                        # assert(xvalues[l][-1] <= excl  <= xvalues[l+1][0])

            # Adaptive Sampling - loop again and interpolate highly angled
            # sections

            # Cos of the maximum angle between successive line segments
            ang_thresh = cos(pi / 180)

            for line, line_xvalues in zip(points, xvalues):
                recursion_count = 0
                smooth = False
                while not smooth and recursion_count < maxrecursion:
                    recursion_count += 1
                    smooth = True
                    i = 2
                    while i < len(line):
                        vec1 = (xscale * (line[i - 1][0] - line[i - 2][0]),
                                yscale * (line[i - 1][1] - line[i - 2][1]))
                        vec2 = (xscale * (line[i][0] - line[i - 1][0]),
                                yscale * (line[i][1] - line[i - 1][1]))
                        try:
                            angle = (vec1[0] * vec2[0] + vec1[1] * vec2[1]) \
                                / sqrt((vec1[0] ** 2 + vec1[1] ** 2) *
                                       (vec2[0] ** 2 + vec2[1] ** 2))
                        except ZeroDivisionError:
                            angle = 0.0
                        if abs(angle) < ang_thresh:
                            smooth = False
                            incr = 0

                            x_value = 0.5 * (line_xvalues[i - 1] +
                                             line_xvalues[i])

                            point = self.eval_f(f, x_name, x_value, evaluation)
                            if point is not None:
                                line.insert(i, point)
                                line_xvalues.insert(i, x_value)
                                incr += 1

                            x_value = 0.5 * (line_xvalues[i - 2] +
                                             line_xvalues[i - 1])
                            point = self.eval_f(f, x_name, x_value, evaluation)
                            if point is not None:
                                line.insert(i - 1, point)
                                line_xvalues.insert(i - 1, x_value)
                                incr += 1

                            i += incr
                        i += 1

            if exclusions == 'None':    # Join all the Lines
                points = [[(xx, yy) for line in points for xx, yy in line]]

            graphics.append(Expression('Hue', hue, 0.6, 0.6))
            graphics.append(Expression('Line', from_python(points)))

            for line in points:
                plot_points.extend(line)

            if mesh == 'All':
                for line in points:
                    tmp_mesh_points.extend(line)

            if mesh != 'None':
                mesh_points.append(tmp_mesh_points)

            function_hues.append(hue)

            if index % 4 == 0:
                hue += hue_pos
            else:
                hue += hue_neg
            if hue > 1:
                hue -= 1
            if hue < 0:
                hue += 1

        x_range = get_plot_range([xx for xx, yy in base_plot_points],
                                 [xx for xx, yy in plot_points], x_range)
        y_range = get_plot_range([yy for xx, yy in base_plot_points],
                                 [yy for xx, yy in plot_points], y_range)

        options['PlotRange'] = from_python([x_range, y_range])

        if mesh != 'None':
            for hue, points in zip(function_hues, mesh_points):
                graphics.append(Expression('Hue', hue, 0.6, 0.6))
                meshpoints = [Expression('List', xx, yy) for xx, yy in points]
                graphics.append(Expression(
                    'Point', Expression('List', *meshpoints)))

        return Expression('Graphics', Expression('List', *graphics),
                          *options_to_rules(options))


class _ListPlot(Builtin):
    messages = {
        'prng': ("Value of option PlotRange -> `1` is not All, Automatic or "
                 "an appropriate list of range specifications."),
        'joind': "Value of option Joined -> `1` is not True or False.",
    }

    def apply(self, points, evaluation, options):
        '%(name)s[points_, OptionsPattern[%(name)s]]'

        plot_name = self.get_name()
        all_points = points.to_python(n_evaluation=evaluation)
        expr = Expression(self.get_name(), points, *options_to_rules(options))

        # PlotRange Option
        def check_range(range):
            if range in ('Automatic', 'All'):
                return True
            if isinstance(range, list) and len(range) == 2:
                if (isinstance(range[0], numbers.Real) and      # noqa
                    isinstance(range[1], numbers.Real)):
                    return True
            return False

        plotrange_option = self.get_option(options, 'PlotRange', evaluation)
        plotrange = plotrange_option.to_python(n_evaluation=evaluation)
        if plotrange == 'All':
            plotrange = ['All', 'All']
        elif plotrange == 'Automatic':
            plotrange = ['Automatic', 'Automatic']
        elif isinstance(plotrange, numbers.Real):
            plotrange = [[-plotrange, plotrange], [-plotrange, plotrange]]
        elif isinstance(plotrange, list) and len(plotrange) == 2:
            if all(isinstance(pr, numbers.Real) for pr in plotrange):
                plotrange = ['All', plotrange]
            elif all(check_range(pr) for pr in plotrange):
                pass
        else:
            evaluation.message(self.get_name(), 'prng', plotrange_option)
            plotrange = ['Automatic', 'Automatic']

        x_range, y_range = plotrange[0], plotrange[1]
        assert x_range in ('Automatic', 'All') or isinstance(x_range, list)
        assert y_range in ('Automatic', 'All') or isinstance(y_range, list)

        # Filling option
        # TODO: Fill between corresponding points in two datasets:
        filling_option = self.get_option(options, 'Filling', evaluation)
        filling = filling_option.to_python(n_evaluation=evaluation)
        if (filling in ['Top', 'Bottom', 'Axis'] or     # noqa
            isinstance(filling, numbers.Real)):
            pass
        else:
            # Mathematica does not even check that filling is sane
            filling = None

        # Joined Option
        joined_option = self.get_option(options, 'Joined', evaluation)
        joined = joined_option.to_python()
        if joined not in [True, False]:
            evaluation.message(plot_name, 'joind', joined_option, expr)
            joined = False

        if isinstance(all_points, list) and len(all_points) != 0:
            if all(not isinstance(point, list) for point in all_points):
                # Only y values given
                all_points = [[[float(i + 1), all_points[i]]
                               for i in range(len(all_points))]]
            elif all(isinstance(line, list) and
                     len(line) == 2 for line in all_points):
                # Single list of (x,y) pairs
                all_points = [all_points]
            elif all(isinstance(line, list) for line in all_points):
                # List of lines
                if all(isinstance(point, list) and len(point) == 2
                       for line in all_points for point in line):
                    pass
                elif all(not isinstance(point, list)
                         for line in all_points for point in line):
                    all_points = [
                        [[float(i + 1), l] for i, l in enumerate(line)]
                        for line in all_points]
                else:
                    return
            else:
                return
        else:
            return

        # Split into segments at missing data
        all_points = [[line] for line in all_points]
        for l, line in enumerate(all_points):
            i = 0
            while i < len(all_points[l]):
                seg = line[i]
                for j, point in enumerate(seg):
                    if not ((isinstance(point[0], float) or
                             isinstance(point[0], int))
                            and (isinstance(point[1], float) or
                                 isinstance(point[1], int))):
                        all_points[l].insert(i, seg[:j])
                        all_points[l][i + 1] = seg[j + 1:]
                        i -= 1
                        break

                i += 1

        y_range = get_plot_range(
            [y for line in all_points for seg in line for x, y in seg],
            [y for line in all_points for seg in line for x, y in seg],
            y_range)
        x_range = get_plot_range(
            [x for line in all_points for seg in line for x, y in seg],
            [x for line in all_points for seg in line for x, y in seg],
            x_range)

        if filling == 'Axis':
            # TODO: Handle arbitary axis intercepts
            filling = 0.0
        elif filling == 'Bottom':
            filling = y_range[0]
        elif filling == 'Top':
            filling = y_range[1]

        hue = 0.67
        hue_pos = 0.236068
        hue_neg = -0.763932

        graphics = []
        for indx, line in enumerate(all_points):
            graphics.append(Expression('Hue', hue, 0.6, 0.6))
            for segment in line:
                if joined:
                    graphics.append(Expression('Line', from_python(segment)))
                    if filling is not None:
                        graphics.append(Expression('Hue', hue, 0.6, 0.6, 0.2))
                        fill_area = list(segment)
                        fill_area.append([segment[-1][0], filling])
                        fill_area.append([segment[0][0], filling])
                        graphics.append(Expression(
                            'Polygon', from_python(fill_area)))
                else:
                    graphics.append(Expression('Point', from_python(segment)))
                    if filling is not None:
                        for point in segment:
                            graphics.append(Expression(
                                'Line', from_python([[point[0], filling],
                                                    [point[0], point[1]]])))

            if indx % 4 == 0:
                hue += hue_pos
            else:
                hue += hue_neg
            if hue > 1:
                hue -= 1
            if hue < 0:
                hue += 1

        options['PlotRange'] = from_python([x_range, y_range])

        return Expression('Graphics', Expression('List', *graphics),
                          *options_to_rules(options))


class _Plot3D(Builtin):
    messages = {
        'invmaxrec': (
            "MaxRecursion must be a non-negative integer; the recursion value "
            "is limited to `2`. Using MaxRecursion -> `1`."),
        'prng': ("Value of option PlotRange -> `1` is not All, Automatic or "
                 "an appropriate list of range specifications."),
        'invmesh': "Mesh must be one of {None, Full, All}. Using Mesh->None.",
        'invpltpts': ("Value of PlotPoints -> `1` is not a positive integer "
                      "or appropriate list of positive integers."),
    }

    def apply(self, functions, x, xstart, xstop, y, ystart, ystop, evaluation,
              options):
        '''%(name)s[functions_, {x_Symbol, xstart_, xstop_},
                {y_Symbol, ystart_, ystop_}, OptionsPattern[%(name)s]]'''
        xexpr_limits = Expression('List', x, xstart, xstop)
        yexpr_limits = Expression('List', y, ystart, ystop)
        expr = Expression(self.get_name(), functions, xexpr_limits,
                          yexpr_limits, *options_to_rules(options))

        functions = self.get_functions_param(functions)
        plot_name = self.get_name()

        try:
            xstart, xstop, ystart, ystop = \
                [value.to_number(n_evaluation=evaluation)
                 for value in (xstart, xstop, ystart, ystop)]

        except NumberError:
            expr = Expression(
                plot_name, functions, Expression('List', x, xstart, xstop),
                Expression('List', y, ystart, ystop),
                *options_to_rules(options))
            evaluation.message(plot_name, 'plln', value, expr)
            return

        if ystart >= ystop:
            evaluation.message(plot_name, 'plln', ystop, expr)
            return

        if xstart >= xstop:
            evaluation.message(plot_name, 'plln', xstop, expr)
            return

        # Mesh Option
        mesh_option = self.get_option(options, 'Mesh', evaluation)
        mesh = mesh_option.to_python()
        if mesh not in ['None', 'Full', 'All']:
            evaluation.message('Mesh', 'ilevels', mesh_option)
            mesh = 'Full'

        # PlotPoints Option
        plotpoints_option = self.get_option(options, 'PlotPoints', evaluation)
        plotpoints = plotpoints_option.to_python()

        def check_plotpoints(steps):
            if isinstance(steps, int) and steps > 0:
                return True
            return False

        if plotpoints == 'None':
            plotpoints = [7, 7]
        elif check_plotpoints(plotpoints):
            plotpoints = [plotpoints, plotpoints]

        if not (isinstance(plotpoints, list) and len(plotpoints) == 2 and
                check_plotpoints(plotpoints[0]) and
                check_plotpoints(plotpoints[1])):
            evaluation.message(self.get_name(), 'invpltpts', plotpoints)
            plotpoints = [7, 7]

        graphics = []
        for indx, f in enumerate(functions):
            stored = {}

            def eval_f(x_value, y_value):
                value = stored.get((x_value, y_value), False)
                if value is False:
                    value = quiet_evaluate(f, {x: Real(
                        x_value), y: Real(y_value)}, evaluation)
                    # value = dynamic_scoping(
                    #    f.evaluate, {x: Real(x_value), y: Real(y_value)},
                    #    evaluation)
                    # value = chop(value).get_real_value()
                    if value is not None:
                        value = float(value)
                    stored[(x_value, y_value)] = value
                return value

            v_borders = [None, None]

            triangles = []

            eps = 0.01

            def triangle(x1, y1, x2, y2, x3, y3, depth=None):
                if depth is None:
                    x1, x2, x3 = [xstart + value * (xstop - xstart)
                                  for value in (x1, x2, x3)]
                    y1, y2, y3 = [ystart + value * (ystop - ystart)
                                  for value in (y1, y2, y3)]
                    depth = 0
                v1, v2, v3 = eval_f(x1, y1), eval_f(x2, y2), eval_f(x3, y3)
                for v in (v1, v2, v3):
                    if v is not None:
                        if v_borders[0] is None or v < v_borders[0]:
                            v_borders[0] = v
                        if v_borders[1] is None or v > v_borders[1]:
                            v_borders[1] = v
                if v1 is None or v2 is None or v3 is None:
                    if depth < 2:
                        triangle(x1, y1, (x1 + x2) / 2, (y1 + y2) / 2,
                                 (x1 + x3) / 2, (y1 + y3) / 2, depth + 1)
                        triangle(x2, y2, (x1 + x2) / 2, (y1 + y2) / 2,
                                 (x2 + x3) / 2, (y2 + y3) / 2, depth + 1)
                        triangle(x3, y3, (x1 + x3) / 2, (y1 + y3) / 2,
                                 (x2 + x3) / 2, (y2 + y3) / 2, depth + 1)
                        triangle((x1 + x2) / 2, (y1 + y2) / 2, (x2 + x3) / 2,
                                 (y2 + y3) / 2, (x1 + x3) / 2, (y1 + y3) / 2,
                                 depth + 1)
                    return
                limit = (v_borders[1] - v_borders[0]) * eps
                if depth < 2:
                    if abs(v1 - v2) > limit:
                        triangle(x1, y1, x3, y3, (x1 + x2) / 2, (y1 + y2) / 2,
                                 depth + 1)
                        triangle(x2, y2, x3, y3, (x1 + x2) / 2, (y1 + y2) / 2,
                                 depth + 1)
                        return
                    if abs(v2 - v3) > limit:
                        triangle(x1, y1, x2, y2, (
                            x2 + x3) / 2, (y2 + y3) / 2, depth + 1)
                        triangle(x1, y1, x3, y3, (
                            x2 + x3) / 2, (y2 + y3) / 2, depth + 1)
                        return
                    if abs(v1 - v3) > limit:
                        triangle(x2, y2, x1, y1, (
                            x1 + x3) / 2, (y1 + y3) / 2, depth + 1)
                        triangle(x2, y2, x3, y3, (
                            x1 + x3) / 2, (y1 + y3) / 2, depth + 1)
                        return
                triangles.append([(x1, y1, v1), (x2, y2, v2), (x3, y3, v3)])

            numx = plotpoints[0] * 1.0
            numy = plotpoints[1] * 1.0
            for xi in range(plotpoints[0]):
                for yi in range(plotpoints[1]):
                    triangle(xi / numx, yi / numy, (xi + 1) / numx,
                             (yi + 1) / numy, (xi + 1) / numx, yi / numy)
                    triangle(xi / numx, yi / numy, (xi + 1) / numx,
                             (yi + 1) / numy, xi / numx, (yi + 1) / numy)

            # Mesh should just be looking up stored values
            mesh_points = []
            for xi in range(plotpoints[0] + 1):
                xval = xstart + xi / numx * (xstop - xstart)
                mesh_row = []
                for yi in range(plotpoints[1] + 1):
                    yval = ystart + yi / numy * (ystop - ystart)
                    z = eval_f(xval, yval)
                    if z is not None:
                        mesh_row.append((xval, yval, z))
                mesh_points.append(mesh_row)

            for yi in range(plotpoints[1] + 1):
                yval = ystart + yi / numy * (ystop - ystart)
                mesh_col = []
                for xi in range(plotpoints[0] + 1):
                    xval = xstart + xi / numx * (xstop - xstart)
                    z = eval_f(xval, yval)
                    if z is not None:
                        mesh_col.append((xval, yval, z))
                mesh_points.append(mesh_col)

            # Fix the grid near recursions
            x_grids = [xstart + (xi / numx) * (xstop - xstart)
                       for xi in range(plotpoints[0] + 1)]
            y_grids = [ystart + (yi / numy) * (ystop - ystart)
                       for yi in range(plotpoints[1] + 1)]

            for (xval, yval) in stored.keys():
                if xval in x_grids:
                    x_index = int((xval - xstart) * numx / (xstop - xstart) +
                                  0.5)
                    z = eval_f(xval, yval)
                    if z is not None:
                        mesh_points[x_index].append((xval, yval, z))
                if yval in y_grids:
                    y_index = int((yval - ystart) * numy / (ystop - ystart) +
                                  plotpoints[0] + 1.5)
                    z = eval_f(xval, yval)
                    if z is not None:
                        mesh_points[y_index].append((xval, yval, z))

            for mesh_line in mesh_points:
                mesh_line.sort()

            v_min = v_max = None

            for t in triangles:
                for tx, ty, v in t:
                    if v_min is None or v < v_min:
                        v_min = v
                    if v_max is None or v > v_max:
                        v_max = v
            graphics.extend(self.construct_graphics(
                triangles, mesh_points, v_min, v_max, options, evaluation))
        return self.final_graphics(graphics, options)


class Plot(_Plot):
    """
    <dl>
    <dt>'Plot[$f$, {$x$, $xmin$, $xmax$}]'
        <dd>plots $f$ with $x$ ranging from $xmin$ to $xmax$.
    <dt>'Plot[{$f1$, $f2$, ...}, {$x$, $xmin$, $xmax$}]'
        <dd>plots several functions $f1$, $f2$, ...
    </dl>

    >> Plot[{Sin[x], Cos[x], x / 3}, {x, -Pi, Pi}]
     = -Graphics-

    >> Plot[Sin[x], {x, 0, 4 Pi}, PlotRange->{{0, 4 Pi}, {0, 1.5}}]
     = -Graphics-

    >> Plot[Tan[x], {x, -6, 6}, Mesh->Full]
     = -Graphics-

    >> Plot[x^2, {x, -1, 1}, MaxRecursion->5, Mesh->All]
     = -Graphics-

    >> Plot[Log[x], {x, 0, 5}, MaxRecursion->0]
     = -Graphics-

    >> Plot[Tan[x], {x, 0, 6}, Mesh->All, PlotRange->{{-1, 5}, {0, 15}}, MaxRecursion->10]
     = -Graphics-

    A constant function:
    >> Plot[3, {x, 0, 1}]
     = -Graphics-

    #> Plot[1 / x, {x, -1, 1}]
     = -Graphics-
    #> Plot[x, {y, 0, 2}]
     = -Graphics-

    #> Plot[{f[x],-49x/12+433/108},{x,-6,6}, PlotRange->{-10,10}, AspectRatio->{1}]
     = -Graphics-

    #> Plot[Sin[t],  {t, 0, 2 Pi}, PlotPoints -> 1]
     : Value of option PlotPoints -> 1 is not an integer >= 2.
     = Plot[Sin[t], {t, 0, 2 Pi}, PlotPoints -> 1]

    #> Plot[x*y, {x, -1, 1}]
     = -Graphics-
    """

    def get_functions_param(self, functions):
        if functions.has_form('List', None):
            functions = functions.leaves
        else:
            functions = [functions]
        return functions

    def get_plotrange(self, plotrange, start, stop):
        x_range = y_range = None
        if isinstance(plotrange, numbers.Real):
            plotrange = ['Full', [-plotrange, plotrange]]
        if plotrange == 'Automatic':
            plotrange = ['Full', 'Automatic']
        elif plotrange == 'All':
            plotrange = ['All', 'All']
        if isinstance(plotrange, list) and len(plotrange) == 2:
            if (isinstance(plotrange[0], numbers.Real) and      # noqa
                isinstance(plotrange[1], numbers.Real)):
                x_range, y_range = 'Full', plotrange
            else:
                x_range, y_range = plotrange
            if x_range == 'Full':
                x_range = [start, stop]
        return x_range, y_range

    def eval_f(self, f, x_name, x_value, evaluation):
        value = quiet_evaluate(f, {x_name: Real(x_value)}, evaluation)
        if value is None:
            return None
        return (x_value, value)


class ParametricPlot(_Plot):
    """
    <dl>
    <dt>'ParametricPlot[{$f_x$, $f_y$}, {$u$, $umin$, $umax$}]'
        <dd>plots parametric function $f$ with paramater $u$ ranging from $umin$ to $umax$.
    <dt>'ParametricPlot[{{$f_x$, $f_y$}, {$g_x$, $g_y$}, ...}, {$u$, $umin$, $umax$}]'
        <dd>plots several parametric functions $f$, $g$, ...
    <dt>'ParametricPlot[{$f_x$, $f_y$}, {$u$, $umin$, $umax$}, {$v$, $vmin$, $vmax$}]'
        <dd>plots a parametric area.
    <dt>'ParametricPlot[{{$f_x$, $f_y$}, {$g_x$, $g_y$}, ...}, {$u$, $umin$, $umax$}, {$v$, $vmin$, $vmax$}]'
        <dd>plots several parametric areas.
    </dl>

    >> ParametricPlot[{Sin[u], Cos[3 u]}, {u, 0, 2 Pi}]
     = -Graphics-

    >> ParametricPlot[{Cos[u] / u, Sin[u] / u}, {u, 0, 50}, PlotRange->0.5]
     = -Graphics-

    >> ParametricPlot[{{Sin[u], Cos[u]},{0.6 Sin[u], 0.6 Cos[u]}, {0.2 Sin[u], 0.2 Cos[u]}}, {u, 0, 2 Pi}, PlotRange->1, AspectRatio->1]
    = -Graphics-
    """

    def get_functions_param(self, functions):
        if (functions.has_form('List', 2) and
            not (functions.leaves[0].has_form('List', None) or
                 functions.leaves[1].has_form('List', None))):
            # One function given
            functions = [functions]
        else:
            # Multiple Functions
            functions = functions.leaves
        return functions

    def get_plotrange(self, plotrange, start, stop):
        x_range = y_range = None
        if isinstance(plotrange, numbers.Real):
            plotrange = [[-plotrange, plotrange], [-plotrange, plotrange]]
        if plotrange == 'Automatic':
            plotrange = ['Automatic', 'Automatic']
        elif plotrange == 'All':
            plotrange = ['All', 'All']
        if isinstance(plotrange, list) and len(plotrange) == 2:
            if (isinstance(plotrange[0], numbers.Real) and  # noqa
                isinstance(plotrange[1], numbers.Real)):
                x_range = [-plotrange[0], plotrange[1]]
                y_range = [-plotrange[1], plotrange[1]]
            else:
                x_range, y_range = plotrange
        return x_range, y_range

    def eval_f(self, f, x_name, x_value, evaluation):
        value = quiet_evaluate(
            f, {x_name: Real(x_value)}, evaluation, expect_list=True)
        if value is None or len(value) != 2:
            return None
        return value


class PolarPlot(_Plot):
    """
    <dl>
    <dt>'PolarPlot[$r$, {$t$, $tmin$, $tmax$}]'
      <dd>plots blah
    </dl>

    >> PolarPlot[Cos[5t], {t, 0, Pi}]
     = -Graphics-

    >> PolarPlot[{1, 1 + Sin[20 t] / 5}, {t, 0, 2 Pi}]
     = -Graphics-
   """

    def get_functions_param(self, functions):
        if functions.has_form('List', None):
            functions = functions.leaves
        else:
            functions = [functions]
        return functions

    def get_plotrange(self, plotrange, start, stop):
        x_range = y_range = None
        if isinstance(plotrange, numbers.Real):
            plotrange = [[-plotrange, plotrange], [-plotrange, plotrange]]
        if plotrange == 'Automatic':
            plotrange = ['Automatic', 'Automatic']
        elif plotrange == 'All':
            plotrange = ['All', 'All']
        if isinstance(plotrange, list) and len(plotrange) == 2:
            if (isinstance(plotrange[0], numbers.Real) and  # noqa
                isinstance(plotrange[1], numbers.Real)):
                x_range = [-plotrange[0], plotrange[1]]
                y_range = [-plotrange[1], plotrange[1]]
            else:
                x_range, y_range = plotrange
        return x_range, y_range

    def eval_f(self, f, x_name, x_value, evaluation):
        value = quiet_evaluate(f, {x_name: Real(x_value)}, evaluation)
        if value is None:
            return None
        return (value * cos(x_value), value * sin(x_value))


class ListPlot(_ListPlot):
    """
    <dl>
    <dt>'ListPlot[{$y_1$, $y_2$, ...}]'
        <dd>plots a list of y-values, assuming integer x-values 1, 2, 3, ...
    <dt>'ListPlot[{{$x_1$, $y_1$}, {$x_2$, $y_2$}, ...}]'
        <dd>plots a list of x,y pairs.
    <dt>'ListPlot[{$list_1$, $list_2$, ...}]'
        <dd>plots a several lists of points.
    </dl>

    >> ListPlot[Table[n ^ 2, {n, 10}]]
     = -Graphics-
    """

    from graphics import Graphics

    attributes = ('HoldAll',)

    options = Graphics.options.copy()
    options.update({
        'Axes': 'True',
        'AspectRatio': '1 / GoldenRatio',
        'Mesh': 'None',
        'PlotRange': 'Automatic',
        'PlotPoints': 'None',
        'Filling': 'None',
        'Joined': 'False',
    })


class ListLinePlot(_ListPlot):
    """
    <dl>
    <dt>'ListLinePlot[{$y_1$, $y_2$, ...}]'
        <dd>plots a line through a list of y-values, assuming integer x-values 1, 2, 3, ...
    <dt>'ListLinePlot[{{$x_1$, $y_1$}, {$x_2$, $y_2$}, ...}]'
        <dd>plots a line through a list of x,y pairs.
    <dt>'ListLinePlot[{$list_1$, $list_2$, ...}]'
        <dd>plots several lines.
    </dl>

    >> ListLinePlot[Table[{n, n ^ 0.5}, {n, 10}]]
     = -Graphics-

    >> ListLinePlot[{{-2, -1}, {-1, -1}}]
     = -Graphics-
    """
    from graphics import Graphics

    attributes = ('HoldAll',)

    options = Graphics.options.copy()
    options.update({
        'Axes': 'True',
        'AspectRatio': '1 / GoldenRatio',
        'Mesh': 'None',
        'PlotRange': 'Automatic',
        'PlotPoints': 'None',
        'Filling': 'None',
        'Joined': 'True',
    })


class Plot3D(_Plot3D):
    """
    <dl>
    <dt>'Plot3D[$f$, {$x$, $xmin$, $xmax$}, {$y$, $ymin$, $ymax$}]'
        <dd>creates a three-dimensional plot of $f$ with $x$ ranging from $xmin$ to $xmax$ and $y$ ranging from $ymin$ to $ymax$.
    </dl>

    >> Plot3D[x ^ 2 + 1 / y, {x, -1, 1}, {y, 1, 4}]
     = -Graphics3D-

    >> Plot3D[x y / (x ^ 2 + y ^ 2 + 1), {x, -2, 2}, {y, -2, 2}]
     = -Graphics3D-

    >> Plot3D[x / (x ^ 2 + y ^ 2 + 1), {x, -2, 2}, {y, -2, 2}, Mesh->None]
     = -Graphics3D-

    >> Plot3D[Sin[x y] /(x y), {x, -3, 3}, {y, -3, 3}, Mesh->All]
     = -Graphics3D-

    #> Plot3D[z, {x, 1, 20}, {y, 1, 10}]
     = -Graphics3D-

    """

    # FIXME: This test passes but the result is 511 lines long !
    """
    #> Plot3D[x + 2y, {x, -2, 2}, {y, -2, 2}] // TeXForm
    """

    from graphics import Graphics

    attributes = ('HoldAll',)

    options = Graphics.options.copy()
    options.update({
        'Axes': 'True',
        'AspectRatio': '1',
        'Mesh': 'Full',
        'PlotPoints': 'None',
        'BoxRatios': '{1, 1, 0.4}',
    })

    def get_functions_param(self, functions):
        if functions.has_form('List', None):
            return functions.leaves
        else:
            return [functions]

    def construct_graphics(self, triangles, mesh_points, v_min, v_max,
                           options, evaluation):
        mesh_option = self.get_option(options, 'Mesh', evaluation)
        mesh = mesh_option.to_python()

        graphics = []
        for p1, p2, p3 in triangles:
            graphics.append(Expression('Polygon', Expression(
                'List', Expression('List', *p1), Expression('List', *p2),
                Expression('List', *p3))))
        # Add the Grid
        if mesh == 'Full':
            for xi in range(len(mesh_points)):
                line = []
                for yi in range(len(mesh_points[xi])):
                    line.append(Expression(
                        'List', mesh_points[xi][yi][0], mesh_points[xi][yi][1],
                        mesh_points[xi][yi][2]))
                graphics.append(Expression('Line', Expression('List', *line)))
        elif mesh == 'All':
            for p1, p2, p3 in triangles:
                line = [from_python(p1), from_python(p2), from_python(p3)]
                graphics.append(Expression('Line', Expression('List', *line)))
        return graphics

    def final_graphics(self, graphics, options):
        return Expression('Graphics3D', Expression('List', *graphics),
                          *options_to_rules(options))


class DensityPlot(_Plot3D):
    """
    <dl>
    <dt>'DensityPlot[$f$, {$x$, $xmin$, $xmax$}, {$y$, $ymin$, $ymax$}]'
        <dd>plots a density plot of $f$ with $x$ ranging from $xmin$ to $xmax$ and $y$ ranging from $ymin$ to $ymax$.
    </dl>

    >> DensityPlot[x ^ 2 + 1 / y, {x, -1, 1}, {y, 1, 4}]
     = -Graphics-

    >> DensityPlot[1 / x, {x, 0, 1}, {y, 0, 1}]
     = -Graphics-

    >> DensityPlot[Sqrt[x * y], {x, -1, 1}, {y, -1, 1}]
     = -Graphics-

    >> DensityPlot[1/(x^2 + y^2 + 1), {x, -1, 1}, {y, -2,2}, Mesh->Full]
     = -Graphics-

    >> DensityPlot[x^2 y, {x, -1, 1}, {y, -1, 1}, Mesh->All]
     = -Graphics-
    """

    from graphics import Graphics

    attributes = ('HoldAll',)

    options = Graphics.options.copy()
    options.update({
        'Axes': 'False',
        'AspectRatio': '1',
        'Mesh': 'None',
        'Frame': 'True',
        'ColorFunction': 'Automatic',
        'ColorFunctionScaling': 'True',
        'PlotPoints': 'None',
    })

    def get_functions_param(self, functions):
        return [functions]

    def construct_graphics(self, triangles, mesh_points, v_min, v_max,
                           options, evaluation):
        mesh_option = self.get_option(options, 'Mesh', evaluation)
        mesh = mesh_option.to_python()

        color_function = self.get_option(
            options, 'ColorFunction', evaluation, pop=True)
        color_function_scaling = self.get_option(
            options, 'ColorFunctionScaling', evaluation, pop=True)

        color_function_min = color_function_max = None
        if color_function.get_name() == 'Automatic':
            color_function = String('LakeColors')
        if color_function.get_string_value():
            func = Expression(
                'ColorData',
                color_function.get_string_value()).evaluate(evaluation)
            if func.has_form('ColorDataFunction', 4):
                color_function_min = func.leaves[2].leaves[0].get_real_value()
                color_function_max = func.leaves[2].leaves[1].get_real_value()
                color_function = Expression('Function', Expression(
                    func.leaves[3], Expression('Slot', 1)))
            else:
                evaluation.message('DensityPlot', 'color', func)
                return
        if color_function.has_form('ColorDataFunction', 4):
            color_function_min = \
                color_function.leaves[2].leaves[0].get_real_value()
            color_function_max = \
                color_function.leaves[2].leaves[1].get_real_value()

        color_function_scaling = color_function_scaling.is_true()
        v_range = v_max - v_min

        if v_range == 0:
            v_range = 1

        if color_function.has_form('ColorDataFunction', 4):
            color_func = color_function.leaves[3]
        else:
            color_func = color_function
        if (color_function_scaling and      # noqa
            color_function_min is not None and
            color_function_max is not None):
            color_function_range = color_function_max - color_function_min

        colors = {}

        def eval_color(x, y, v):
            v_scaled = (v - v_min) / v_range
            if (color_function_scaling and      # noqa
                color_function_min is not None and
                color_function_max is not None):
                v_color_scaled = color_function_min + \
                    v_scaled * color_function_range
            else:
                v_color_scaled = v

            # Calculate and store 100 different shades max.
            v_lookup = int(v_scaled * 100 + 0.5)

            value = colors.get(v_lookup)
            if value is None:
                value = Expression(color_func, Real(v_color_scaled))
                value = value.evaluate(evaluation)
                colors[v_lookup] = value
            return value

        points = []
        vertex_colors = []
        graphics = []
        for p in triangles:
            points.append(
                Expression('List', *(Expression('List', *x[:2]) for x in p)))
            vertex_colors.append(
                Expression('List', *(eval_color(*x) for x in p)))

        graphics.append(Expression(
            'Polygon', Expression('List', *points),
            Expression('Rule', Symbol('VertexColors'),
                       Expression('List', *vertex_colors))))

        if mesh == 'Full':
            for xi in range(len(mesh_points)):
                line = []
                for yi in range(len(mesh_points[xi])):
                    line.append(Expression('List', mesh_points[xi][yi][0],
                                mesh_points[xi][yi][1]))
                graphics.append(Expression('Line', Expression('List', *line)))
        elif mesh == 'All':
            for p in triangles:
                graphics.append(Expression(
                    'Line',
                    Expression('List', *(from_python(x[:2]) for x in p))))
        return graphics

    def final_graphics(self, graphics, options):
        return Expression('Graphics', Expression('List', *graphics),
                          *options_to_rules(options))

########NEW FILE########
__FILENAME__ = magic
#!/usr/bin/env python
import sys
import os.path
import logging


class MagicRule(object):
    def __init__(
        self, mimeType, parentType, extensions, allowsLeadingWhiteSpace,
            magicNumbers, magicStrings):
        self.mimeType = mimeType
        self.parentType = parentType
        self.extensions = extensions
        self.allowsLeadingWhiteSpace = allowsLeadingWhiteSpace
        self.magicNumbers = magicNumbers
        self.magicStrings = magicStrings

    def __repr__(self):
        return "<rule %s>" % self.mimeType


class MagicDetector(object):
    def __init__(self, mimetypes):
        self.mimetypes = mimetypes

    def match(self, filename, data=None):
        if not data:
            file = open(filename, 'r')
        elif isinstance(data, str) or isinstance(data, unicode):
            from StringIO import StringIO

            file = StringIO(data)
        elif hasattr(data, 'read'):
            file = data
        else:
            from StringIO import StringIO

            file = StringIO(str(data))

        ext = os.path.splitext(filename)[1]

        if ext:
            ext = ext[1:]

        matches = {}

        buf = ''

        for mimetype, rules in self.mimetypes.items():
            for rule in rules:
                if rule.parentType and rule.parentType not in matches.keys():
                    continue

                if rule.extensions and ext not in rule.extensions:
                    continue

                for offset, value in rule.magicNumbers:
                    if offset + len(value) > len(buf):
                        buf += file.read(offset + len(value) - len(buf))

                    if buf[offset:offset + len(value)] == value:
                        matches[mimetype] = rule
                        break

                for caseSensitive, value in rule.magicStrings:
                    if len(value) > len(buf):
                        buf += file.read(len(value) - len(buf))

                    if buf[:len(value)] == value:
                        matches[mimetype] = rule
                        break

        return matches.keys()


class MagicLoader(object):
    def __init__(self, filename=None):
        if not filename:
            filename = os.path.join(os.path.dirname(__file__), 'mimetypes.xml')

        if not os.path.isfile(filename):
            raise IOError("magic mime type database '%s' doesn't exists" % filename)

        self.filename = filename
        self.mimetypes = {}

    def getText(self, node, name=None):
        from xml.dom.minidom import Node

        text = ''

        if name:
            for child in node.getElementsByTagName(name):
                text += self.getText(child)
        else:
            for child in node.childNodes:
                if child.nodeType == child.TEXT_NODE:
                    text += child.data.encode('utf-8', 'ignore')

        return text

    def getAttr(self, node, attr, default=''):
        if not node.hasAttribute(attr):
            return default

        return type(default)(node.getAttribute(attr))

    def load(self, filename=None):
        from binascii import unhexlify
        from xml.dom.minidom import parse

        dom = parse(filename or self.filename)

        logging.info("loading magic database from %s", filename or self.filename)

        descriptions = dom.getElementsByTagName('description')

        for desc in descriptions:
            mimeType = self.getText(desc, 'mimeType')
            parentType = self.getText(desc, 'parentType')
            extensions = self.getText(desc, 'extensions').split(',')
            allowsLeadingWhiteSpace = self.getText(desc, 'allowsLeadingWhiteSpace') == 'true'

            magicNumbers = []

            for magicNumber in desc.getElementsByTagName('magicNumber'):
                encoding = self.getAttr(magicNumber, 'encoding', 'string')
                offset = self.getAttr(magicNumber, 'offset', 0)
                value = self.getText(magicNumber)

                if encoding == 'hex':
                    value = unhexlify(value.replace(' ', ''))

                magicNumbers.append((offset, value))

            magicStrings = []

            for magicString in desc.getElementsByTagName('magicString'):
                caseSensitive = not (self.getAttr(magicString, 'caseSensitive') == 'false')
                value = self.getText(magicString)

                magicStrings.append((caseSensitive, value))

            self.mimetypes.setdefault(mimeType, []).append(MagicRule(mimeType, parentType, extensions, allowsLeadingWhiteSpace, magicNumbers, magicStrings))

        logging.info("loaded %d rules for %d MIME types from magic database", len(descriptions), len(self.mimetypes))

        return len(descriptions)

    def reload(self):
        self.mimetypes = {}
        self.load()

import unittest


class TestDetector(unittest.TestCase):
    detector = None

    def setUp(self):
        if not self.detector:
            loader = MagicLoader()
            loader.load()
            self.detector = MagicDetector(loader.mimetypes)

    def testMagicNumber(self):
        self.assertEquals(['application/zip'], self.detector.match('test.zip', 'PKtest'))
        self.assertEquals([], self.detector.match('test.zip', '_PKtest'))
        self.assertEquals([], self.detector.match('test.zip1', 'PKtest'))

        self.assertEquals(['application/gzip'], self.detector.match('test.gz', '\x1f\x8b\x08test'))
        self.assertEquals(['application/gzip'], self.detector.match('test.tgz', '\x1f\x8b\x08test'))
        self.assertEquals([], self.detector.match('test.gz1', '\x1f\x8b\x08test'))
        self.assertEquals([], self.detector.match('test.gz', '\x1f \x8b\x08test'))

        padding = ''.join([' ' for _ in xrange(257)])

        self.assertEquals(['application/x-tar'], self.detector.match('test.tar', padding + 'ustartest'))
        self.assertEquals([], self.detector.match('test.tar1', padding + 'ustartest'))
        self.assertEquals([], self.detector.match('test.tar', padding + 'ust artest'))


class TestLoader(unittest.TestCase):
    def testInit(self):
        self.assertRaises(IOError, MagicLoader, 'not_exists_file')

        self.assert_(MagicLoader().filename)

    def testLoad(self):
        loader = MagicLoader()

        self.assertFalse(loader.mimetypes)

        self.assert_(loader.load() > 0)

        self.assert_(loader.mimetypes)


def dump(mimetypes):
    for type, rules in mimetypes.items():
        print type

        for rule in rules:
            print "\textenions = %s" % rule.extensions
            print "\tmagic num = %s" % rule.magicNumbers
            print "\tmagic str = %s" % rule.magicStrings

if __name__ == '__main__':
    logging.basicConfig(
        level=logging.DEBUG if '-v' in sys.argv else logging.WARN,
        format='%(asctime)s %(levelname)-8s %(message)s')

    unittest.main()

########NEW FILE########
__FILENAME__ = randomnumbers
# -*- coding: utf8 -*-

"""
Random number generation

Random numbers are generated using the Mersenne Twister.
"""

from __future__ import with_statement

import random
import cPickle as pickle
import binascii
import hashlib

from mathics.builtin.base import Builtin
from mathics.core.expression import (Integer, String, Symbol, Real, Expression,
                                     Complex)


def get_random_state():
    state = random.getstate()
    state = pickle.dumps(state)
    state = binascii.b2a_hex(state)
    state = int(state, 16)
    return state


def set_random_state(state):
    if state is None:
        random.seed()
    else:
        state = hex(state)[2:]  # drop leading "0x"
        if state.endswith('L'):
            state = state[:-1]
        state = binascii.a2b_hex(state)
        state = pickle.loads(state)
        random.setstate(state)


class RandomEnv:
    def __init__(self, evaluation):
        self.evaluation = evaluation

    def __enter__(self):
        state = self.evaluation.get_config_value('$RandomState')
        set_random_state(state)
        return self

    def __exit__(self, exit_type, value, traceback):
        state = get_random_state()
        self.evaluation.set_config_value('$RandomState', state)

    def randint(self, a, b):
        return random.randint(a, b)

    def randreal(self, a, b):
        return random.uniform(a, b)

    def seed(self, x=None):
        random.seed(x)


class RandomState(Builtin):
    """
    <dl>
    <dt>'$RandomState'
        <dd>is a long number representing the internal state of the pseudorandom number generator.
    </dl>

    >> Mod[$RandomState, 10^100]
     = ...
    >> IntegerLength[$RandomState]
     = ...

    So far, it is not possible to assign values to '$RandomState'.
    >> $RandomState = 42
     : It is not possible to change the random state.
     = 42
    Not even to its own value:
    >> $RandomState = $RandomState;
     : It is not possible to change the random state.
    """

    name = '$RandomState'

    messages = {
        'rndst': "It is not possible to change the random state.",
        #"`1` is not a valid random state.",
    }

    def apply(self, evaluation):
        '$RandomState'

        with RandomEnv(evaluation):
            return Integer(get_random_state())


class SeedRandom(Builtin):
    """
    <dl>
    <dt>'SeedRandom[$n$]'
        <dd>resets the pseudorandom generator with seed $n$.
    <dt>'SeedRandom[]'
        <dd>uses the current date and time as seed.
    </dl>

    'SeedRandom' can be used to get reproducible random numbers:
    >> SeedRandom[42]
    >> RandomInteger[100]
     = 64
    >> RandomInteger[100]
     = 2
    >> SeedRandom[42]
    >> RandomInteger[100]
     = 64
    >> RandomInteger[100]
     = 2

    String seeds are supported as well:
    >> SeedRandom["Mathics"]
    >> RandomInteger[100]
     = 60

    #> SeedRandom[x]
     : Argument x should be an integer or string.
     = SeedRandom[x]
    """

    messages = {
        'seed': "Argument `1` should be an integer or string.",
    }

    def apply(self, x, evaluation):
        'SeedRandom[x_]'

        if isinstance(x, Integer):
            value = x.value
        elif isinstance(x, String):
            # OS/version-independent hash
            value = int(hashlib.md5(x.get_string_value()).hexdigest(), 16)
        else:
            return evaluation.message('SeedRandom', 'seed', x)
        with RandomEnv(evaluation) as rand:
            # TODO: This has different behavior in Python 3.2 (vs. 2.7),
            # so SeedRandom behavior will change.
            # Also, we should use version=1 when supporting Python 3.
            rand.seed(value)
        return Symbol('Null')

    def apply_empty(self, evaluation):
        'SeedRandom[]'

        with RandomEnv(evaluation) as rand:
            rand.seed()
        return Symbol('Null')


class RandomInteger(Builtin):
    """
    <dl>
    <dt>'RandomInteger[{$min$, $max$}]'
        <dd>yields a pseudorandom integer in the range from $min$ to $max$.
    <dt>'RandomInteger[$max$]'
        <dd>yields a pseudorandom integer in the range from 0 to $max$.
    <dt>'RandomInteger[]'
        <dd>gives 0 or 1.
    <dt>'RandomInteger[$range$, $n$]'
        <dd>gives a list of $n$ pseudorandom integers.
    <dt>'RandomInteger[$range$, {$n1$, $n2$, ...}]'
        <dd>gives a nested list of pseudorandom integers.
    </dl>

    >> RandomInteger[{1, 5}]
     = ...
    #> 1 <= % <= 5
     = True

    >> RandomInteger[100, {2, 3}] // TableForm
     = ...   ...   ...
     .
     . ...   ...   ...

    Calling 'RandomInteger' changes '$RandomState':
    >> previousState = $RandomState;
    >> RandomInteger[]
     = ...
    >> $RandomState != previousState
     = True
    """

    messages = {
        'unifr': ("The endpoints specified by `1` for the endpoints of the "
                  "discrete uniform distribution range are not integers."),
    }

    rules = {
        'RandomInteger[]': 'RandomInteger[{0, 1}]',
        'RandomInteger[max_Integer]': 'RandomInteger[{0, max}]',
        'RandomInteger[max_Integer, ns_]': 'RandomInteger[{0, max}, ns]',
        'RandomInteger[spec_, n_Integer]': 'RandomInteger[spec, {n}]',
    }

    def apply(self, rmin, rmax, evaluation):
        'RandomInteger[{rmin_, rmax_}]'

        if not isinstance(rmin, Integer) or not isinstance(rmax, Integer):
            return evaluation.message('RandomInteger', 'unifr',
                                      Expression('List', rmin, rmax))
        rmin, rmax = rmin.value, rmax.value
        with RandomEnv(evaluation) as rand:
            return Integer(rand.randint(rmin, rmax))

    def apply_list(self, rmin, rmax, ns, evaluation):
        'RandomInteger[{rmin_, rmax_}, ns_?ListQ]'
        if not isinstance(rmin, Integer) or not isinstance(rmax, Integer):
            return evaluation.message('RandomInteger', 'unifr',
                                      Expression('List', rmin, rmax))
        rmin, rmax = rmin.value, rmax.value
        result = ns.to_python()

        with RandomEnv(evaluation) as rand:
            def search_product(i):
                if i == len(result) - 1:
                        return Expression('List', *[
                            Integer(rand.randint(rmin, rmax))
                            for j in xrange(result[i])])
                else:
                    return Expression('List', *[
                        search_product(i + 1) for j in xrange(result[i])])
            return search_product(0)


class RandomReal(Builtin):
    """
    <dl>
    <dt>'RandomReal[{$min$, $max$}]'
        <dd>yields a pseudorandom real number in the range from $min$ to $max$.
    <dt>'RandomReal[$max$]'
        <dd>yields a pseudorandom real number in the range from 0 to $max$.
    <dt>'RandomReal[]'
        <dd>yields a pseudorandom real number in the range from 0 to 1.
    <dt>'RandomReal[$range$, $n$]'
        <dd>gives a list of $n$ pseudorandom real numbers.
    <dt>'RandomReal[$range$, {$n1$, $n2$, ...}]'
        <dd>gives a nested list of pseudorandom real numbers.
    </dl>

    >> RandomReal[]
     = ...
    #> 0 <= % <= 1
     = True

    >> RandomReal[{1, 5}]
     = ...

    ## needs too much horizontal space in TeX form
    #> RandomReal[100, {2, 3}] // TableForm
     = ...   ...   ...
     .
     . ...   ...   ...

    #> RandomReal[{0, 1}, {1, -1}]
     : The array dimensions {1, -1} given in position 2 of RandomReal[{0, 1}, {1, -1}] should be a list of non-negative machine-sized integers giving the dimensions for the result.
     = RandomReal[{0, 1}, {1, -1}]
    """

    messages = {
        'unifr': ("The endpoints specified by `1` for the endpoints of the "
                  "discrete uniform distribution range are not real valued."),
        'array': ("The array dimensions `2` given in position 2 of `1` should "
                  "be a list of non-negative machine-sized integers giving "
                  "the dimensions for the result."),
    }

    rules = {
        'RandomReal[]': 'RandomReal[{0, 1}]',
        'RandomReal[max_?NumberQ]': 'RandomReal[{0, max}]',
        'RandomReal[max_?NumberQ, ns_]': 'RandomReal[{0, max}, ns]',
        'RandomReal[spec_, n_Integer]': 'RandomReal[spec, {n}]',
    }

    def apply(self, xmin, xmax, evaluation):
        'RandomReal[{xmin_, xmax_}]'

        if not (isinstance(xmin, (Real, Integer)) and
                isinstance(xmax, (Real, Integer))):
            return evaluation.message('RandomReal', 'unifr',
                                      Expression('List', xmin, xmax))

        min_value, max_value = xmin.to_python(), xmax.to_python()

        with RandomEnv(evaluation) as rand:
            return Real(rand.randreal(min_value, max_value))

    def apply_list(self, xmin, xmax, ns, evaluation):
        'RandomReal[{xmin_, xmax_}, ns_?ListQ]'

        if not (isinstance(xmin, (Real, Integer)) and
                isinstance(xmax, (Real, Integer))):
            return evaluation.message('RandomReal', 'unifr',
                                      Expression('List', xmin, xmax))

        min_value, max_value = xmin.to_python(), xmax.to_python()
        result = ns.to_python()

        if not all([isinstance(i, int) and i >= 0 for i in result]):
            expr = Expression('RandomReal', Expression('List', xmin, xmax), ns)
            return evaluation.message('RandomReal', 'array', expr, ns)

        assert all([isinstance(i, int) for i in result])

        with RandomEnv(evaluation) as rand:
            def search_product(i):
                if i == len(result) - 1:
                        return Expression('List', *[
                            Real(rand.randreal(min_value, max_value))
                            for j in xrange(result[i])])
                else:
                    return Expression('List', *[
                        search_product(i + 1) for j in xrange(result[i])])
            return search_product(0)


class RandomComplex(Builtin):
    """
    <dl>
    <dt>'RandomComplex[{$z_min$, $z_max$}]'
        <dd>yields a pseudorandom complex number in the rectangle with complex corners $z_min$ and $z_max$.
    <dt>'RandomComplex[$z_max$]'
        <dd>yields a pseudorandom complex number in the rectangle with corners at the origin and at $z_max$.
    <dt>'RandomComplex[]'
        <dd>yields a pseudorandom complex number with real and imaginary parts from 0 to 1.
    <dt>'RandomComplex[$range$, $n$]'
        <dd>gives a list of $n$ pseudorandom complex numbers.
    <dt>'RandomComplex[$range$, {$n1$, $n2$, ...}]'
        <dd>gives a nested list of pseudorandom complex numbers.
    </dl>

    >> RandomComplex[]
     = ...
    #> 0 <= Re[%] <= 1 && 0 <= Im[%] <= 1
     = True

    >> RandomComplex[{1+I, 5+5I}]
     = ...
    #> 1 <= Re[%] <= 5 && 1 <= Im[%] <= 5
     = True

    >> RandomComplex[1+I, 5]
     = {..., ..., ..., ..., ...}

    >> RandomComplex[{1+I, 2+2I}, {2, 2}]
     = {{..., ...}, {..., ...}}
    """

    messages = {
        'unifr': (
            "The endpoints specified by `1` for the endpoints of the "
            "discrete uniform distribution range are not complex valued."),
        'array': (
            "The array dimensions `1` given in position 2 of `2` should be a "
            "list of non-negative machine-sized integers giving the "
            "dimensions for the result."),
    }

    rules = {
        'RandomComplex[]': 'RandomComplex[{0, 1+I}]',
        'RandomComplex[zmax_?NumberQ]': 'RandomComplex[{0, zmax}]',
        'RandomComplex[zmax_?NumberQ, ns_]': 'RandomComplex[{0, zmax}, ns]',
    }

    def apply(self, zmin, zmax, evaluation):
        'RandomComplex[{zmin_, zmax_}]'
        if Expression('RealNumberQ', zmin).evaluate(evaluation):
            zmin = Complex(zmin, 0.0)
        if Expression('RealNumberQ', zmax).evaluate(evaluation):
            zmax = Complex(zmax, 0.0)

        if not (isinstance(zmin, Complex) and isinstance(zmax, Complex)):
            return evaluation.message('RandomComplex', 'unifr',
                                      Expression('List', zmin, zmax))

        min_value, max_value = zmin.to_python(), zmax.to_python()

        with RandomEnv(evaluation) as rand:
            return Complex(rand.randreal(min_value.real, max_value.real),
                           rand.randreal(min_value.imag, max_value.imag))

    def apply_list(self, zmin, zmax, ns, evaluation):
        'RandomComplex[{zmin_, zmax_}, ns_]'
        expr = Expression('RandomComplex', Expression('List', zmin, zmax), ns)

        if Expression('RealNumberQ', zmin).evaluate(evaluation):
            zmin = Complex(zmin, 0.0)
        if Expression('RealNumberQ', zmax).evaluate(evaluation):
            zmax = Complex(zmax, 0.0)

        if not (isinstance(zmin, Complex) and isinstance(zmax, Complex)):
            return evaluation.message('RandomComplex', 'unifr',
                                      Expression('List', zmin, zmax))

        min_value, max_value = zmin.to_python(), zmax.to_python()

        py_ns = ns.to_python()
        if not isinstance(py_ns, list):
            py_ns = [py_ns]

        if not all([isinstance(i, int) and i >= 0 for i in py_ns]):
            return evaluation.message('RandomComplex', 'array', ns, expr)

        with RandomEnv(evaluation) as rand:
            def search_product(i):
                if i == len(py_ns) - 1:
                        return Expression('List', *[
                            Complex(
                                rand.randreal(min_value.real, max_value.real),
                                rand.randreal(min_value.imag, max_value.imag)
                            ) for j in xrange(py_ns[i])])
                else:
                    return Expression('List', *[
                        search_product(i + 1) for j in xrange(py_ns[i])])
            return search_product(0)

########NEW FILE########
__FILENAME__ = recurrence
# -*- coding: utf8 -*-

"""
Recurrence relation solvers
"""

import sympy
from mathics.builtin.base import Builtin
from mathics.core.expression import Expression
from mathics.core.convert import sympy_symbol_prefix, from_sympy


class RSolve(Builtin):
    """
    <dl>
    <dt>'RSolve[$eqn$, $a[n]$, $n$]'
        <dd>solves a recurrence equation for the function '$a[n]$'.
    </dl>

    >> RSolve[a[n] == a[n+1], a[n], n]
     = {{a[n] -> C[0]}}

    No boundary conditions gives two general paramaters:
    >> RSolve[{a[n + 2] == a[n]}, a, n]
     = {{a -> (Function[{n}, C[0] + C[1] -1 ^ n])}}

    One boundary condition:
    >> RSolve[{a[n + 2] == a[n], a[0] == 1}, a, n]
     = ...
    ## Order of terms depends on intepreter:
    ## PyPy:    {{a -> (Function[{n}, 1 - C[1] + C[1] -1 ^ n])}}
    ## CPython: {{a -> (Function[{n}, 1 + C[1] -1 ^ n - C[1]])}

    Two boundary conditions:
    >> RSolve[{a[n + 2] == a[n], a[0] == 1, a[1] == 4}, a, n]
     = {{a -> (Function[{n}, 5 / 2 - 3 -1 ^ n / 2])}}
    """

    messages = {
        'deqn': ('Equation or list of equations expected instead of `1` '
                 'in the first argument `1`.'),
        'deqx': ('Supplied equations are not difference equations of the '
                 'given functions.'),
        'dsfun': '`1` cannot be used as a function.',
        'dsvar': '`1` cannot be used as a variable.',
    }

    def apply(self, eqns, a, n, evaluation):
        'RSolve[eqns_, a_, n_]'

        # TODO: Do this with rules?
        if not eqns.has_form('List', None):
            eqns = Expression('List', eqns)

        if len(eqns.leaves) == 0:
            return

        for eqn in eqns.leaves:
            if eqn.get_head_name() != 'Equal':
                evaluation.message('RSolve', 'deqn', eqn)
                return

        if (n.is_atom() and not n.is_symbol()) or \
            n.get_head_name() in ('Plus', 'Times', 'Power') or \
                'Constant' in n.get_attributes(evaluation.definitions):
            evaluation.message('RSolve', 'dsvar')
            return

        try:
            a.leaves
            function_form = None
            func = a
        except AttributeError:
            func = Expression(a, n)
            function_form = Expression('List', n)

        if func.is_atom() or len(func.leaves) != 1:
            evaluation.message('RSolve', 'dsfun', a)

        if n not in func.leaves:
            evaluation.message('DSolve', 'deqx')

        # Seperate relations from conditions
        conditions = {}

        def is_relation(eqn):
            left, right = eqn.leaves
            for l, r in [(left, right), (right, left)]:
                if (left.get_head_name() == func.get_head_name() and    # noqa
                    len(left.leaves) == 1 and
                    isinstance(l.leaves[0].to_python(), int) and
                    r.is_numeric()):

                    conditions[l.leaves[0].to_python()] = r.to_sympy()
                    return False
            return True
        relation = filter(is_relation, eqns.leaves)[0]

        left, right = relation.leaves
        relation = Expression('Plus', left, Expression(
            'Times', -1, right)).evaluate(evaluation)

        sym_eq = relation.to_sympy(
            converted_functions=set([func.get_head_name()]))
        sym_n = sympy.symbols(str(sympy_symbol_prefix + n.name))
        sym_func = sympy.Function(str(
            sympy_symbol_prefix + func.get_head_name()))(sym_n)

        sym_conds = {}
        for cond in conditions:
            sym_conds[sympy.Function(str(
                sympy_symbol_prefix + func.get_head_name()))(cond)] = \
                conditions[cond]

        try:
            # Sympy raises error when given empty conditions. Fixed in
            # upcomming sympy release.
            if sym_conds != {}:
                sym_result = sympy.rsolve(sym_eq, sym_func, sym_conds)
            else:
                sym_result = sympy.rsolve(sym_eq, sym_func)

            if not isinstance(sym_result, list):
                sym_result = [sym_result]
        except ValueError:
            return

        if function_form is None:
            return Expression('List', *[
                Expression('List', Expression('Rule', a, from_sympy(soln)))
                for soln in sym_result])
        else:
            return Expression('List', *[
                Expression('List', Expression(
                    'Rule', a, Expression('Function', function_form,
                    from_sympy(soln)))) for soln in sym_result])

########NEW FILE########
__FILENAME__ = scoping
# -*- coding: utf8 -*-

from mathics.builtin.base import Builtin, Predefined
from mathics.core.expression import String, Symbol, Integer


def get_scoping_vars(var_list, msg_symbol='', evaluation=None):
    def message(tag, *args):
        if msg_symbol and evaluation:
            evaluation.message(msg_symbol, tag, *args)

    if var_list.get_head_name() != 'List':
        message('lvlist', var_list)
        return
    vars = var_list.leaves
    scoping_vars = set()
    for var in vars:
        var_name = None
        if var.has_form('Set', 2):
            var_name = var.leaves[0].get_name()
            new_def = var.leaves[1]
            new_def = new_def.evaluate(evaluation)
        elif var.has_form('Symbol'):
            var_name = var.get_name()
            new_def = None
        if not var_name:
            message('lvsym', var)
            continue
        if var_name in scoping_vars:
            message('dup', var_name)
        else:
            scoping_vars.add(var_name)
            yield var_name, new_def


def dynamic_scoping(func, vars, evaluation):
    original_definitions = {}
    for var_name, new_def in vars.items():
        original_definitions[
            var_name] = evaluation.definitions.get_user_definition(var_name)
        evaluation.definitions.reset_user_definition(var_name)
        if new_def is not None:
            new_def = new_def.evaluate(evaluation)
            evaluation.definitions.set_ownvalue(var_name, new_def)
    try:
        result = func(evaluation)
    finally:
        for name, definition in original_definitions.items():
            evaluation.definitions.add_user_definition(name, definition)
    return result


class Block(Builtin):
    """
    <dl>
    <dt>'Block[{$vars$}, $expr$]'
        <dd>temporarily stores the definitions of certain variables, evaluates
        $expr$ with reset values and restores the original definitions afterwards.
    <dt>'Block[{$x$=$x0$, $y$=$y0$, ...}, $expr$]'
        <dd>assigns initial values to the reset variables.
    </dl>
    >> n = 10
     = 10
    >> Block[{n = 5}, n ^ 2]
     = 25
    >> n
     = 10

    Values assigned to block variables are evaluated at the beginning of the block.
    Keep in mind that the result of 'Block' is evaluated again, so a returned block variable
    will get its original value.
    >> Block[{x = n+2, n}, {x, n}]
     = {12, 10}

    If the variable specification is not of the described form, an error message is raised:
    >> Block[{x + y}, x]
     : Local variable specification contains x + y, which is not a symbol or an assignment to a symbol.
     = x

    Variable names may not appear more than once:
    >> Block[{x, x}, x]
     : Duplicate local variable x found in local variable specification.
     = x
    """

    attributes = ('HoldAll',)

    messages = {
        'lvsym': ("Local variable specification contains `1`, "
                  "which is not a symbol or an assignment to a symbol."),
        'dup': ("Duplicate local variable `1` found in local variable "
                "specification."),
        'lvlist': "Local variable specification `1` is not a List.",
    }

    def apply(self, vars, expr, evaluation):
        'Block[vars_, expr_]'

        vars = dict(get_scoping_vars(vars, 'Block', evaluation))
        result = dynamic_scoping(expr.evaluate, vars, evaluation)

        # Variables may have changed: must revalute
        result.is_evaluated = False

        return result


class ModuleNumber(Predefined):
    """
    <dl>
    <dt>'$ModuleNumber'
        <dd>is the current "serial number" to be used for local module variables.
    </dl>

    >> Unprotect[$ModuleNumber]
    >> $ModuleNumber = 20;
    >> Module[{x}, x]
     = x$20

    >> $ModuleNumber = x;
     : Cannot set $ModuleNumber to x; value must be a positive integer.
    """

    name = '$ModuleNumber'

    messages = {
        'set': ("Cannot set $ModuleNumber to `1`; "
                "value must be a positive integer."),
    }

    rules = {
        '$ModuleNumber': '1',
    }


class Module(Builtin):
    """
    <dl>
    <dt>'Module[{$vars$}, $expr$]'
        <dd>localizes variables by giving them a temporary name of the form
    'name$number', where number is the current value of '$ModuleNumber'. Each time a module
    is evaluated, '$ModuleNumber' is incremented.
    </dl>

    >> x = 10;
    >> Module[{x=x}, x=x+1; x]
     = 11
    >> x
     = 10
    >> t === Module[{t}, t]
     = False

    Initial values are evaluated immediately:
    >> Module[{t=x}, x = x + 1; t]
     = 10
    >> x
     = 11

    Variables inside other scoping constructs are not affected by the renaming of 'Module':
    >> Module[{a}, Block[{a}, a]]
     = a
    >> Module[{a}, Block[{}, a]]
     = a$5
    """

    attributes = ('HoldAll',)

    messages = {
        'lvsym': ("Local variable specification contains `1`, "
                  "which is not a symbol or an assignment to a symbol."),
        'dup': ("Duplicate local variable `1` found in local variable "
                "specification."),
        'lvlist': "Local variable specification `1` is not a List.",
    }

    def apply(self, vars, expr, evaluation):
        'Module[vars_, expr_]'

        scoping_vars = get_scoping_vars(vars, 'Module', evaluation)
        replace = {}
        number = Symbol('$ModuleNumber').evaluate(evaluation).get_int_value()
        if number is None:
            number = 1
        evaluation.definitions.set_ownvalue(
            '$ModuleNumber', Integer(number + 1))
        for name, new_def in scoping_vars:
            new_name = '%s$%d' % (name, number)
            if new_def is not None:
                evaluation.definitions.set_ownvalue(new_name, new_def)
            replace[name] = Symbol(new_name)
        new_expr = expr.replace_vars(replace, in_scoping=False)
        result = new_expr.evaluate(evaluation)
        return result


class Context(Builtin):
    r"""
    <dl>
    <dt>'Context[$symbol$]'
        <dd>yields the name of the context where $symbol$ is defined in.
    </dl>

    Contexts are not really implemented in \Mathics. 'Context' just returns '"System`"'
    for built-in symbols and '"Global`"' for user-defined symbols.

    >> Context[a]
     = Global`
    >> Context[Sin] // InputForm
     = "System`"
    """

    def apply(self, symbol, evaluation):
        'Context[symbol_]'

        name = symbol.get_name()
        if not name:
            evaluation.message('Context', 'normal')
            return
        context = evaluation.definitions.get_definition(name).context
        return String(context)

########NEW FILE########
__FILENAME__ = specialfunctions
# -*- coding: utf8 -*-

"""
Special functions
"""

import sympy
import sympy.mpmath as mpmath

from mathics.builtin.base import Builtin
from mathics.builtin.arithmetic import _MPMathFunction
from mathics.core.expression import Integer
from mathics.core.numbers import mpmath2sympy
from mathics.core.convert import from_sympy
from mathics.builtin.numeric import get_precision


class Erf(_MPMathFunction):
    """
    <dl>
    <dt>'Erf[$z$]'
        <dd>returns the error function of $z$.
    </dl>

    >> Erf[1.0]
     = 0.842700792949714869
    >> Erf[0]
     = 0
    >> Plot[Erf[x], {x, -2, 2}]
     = -Graphics-
    """

    mpmath_name = 'erf'


class ProductLog(_MPMathFunction):
    """
    <dl>
    <dt>'ProductLog[$z$]'
        <dd>returns the value of the Lambert W function at $z$.
    </dl>

    The defining equation:
    >> z == ProductLog[z] * E ^ ProductLog[z]
     = True

    Some special values:
    >> ProductLog[0]
     = 0
    >> ProductLog[E]
     = 1

    The graph of 'ProductLog':
    >> Plot[ProductLog[x], {x, -1/E, E}]
     = -Graphics-
    """

    sympy_name = 'LambertW'  # function called LambertW in SymPy
    mpmath_name = 'lambertw'

    rules = {
        'ProductLog[0]': '0',
        'ProductLog[E]': '1',
        'ProductLog[z_] * E ^ ProductLog[z_]': 'z',
    }


class Zeta(_MPMathFunction):
    """
    <dl>
    <dt>'Zeta[$z$]'
      <dd>returns the Riemann zeta function of $z$.
    </dl>

    >> Zeta[2]
     = Pi ^ 2 / 6

    >> Zeta[-2.5 + I]
     = 0.0235936105863796486 + 0.00140779960583837704 I
    """

    sympy_name = 'zeta'
    mpmath_name = 'zeta'


class _Bessel(_MPMathFunction):

    attributes = ('Listable', 'NumericFunction', 'Protected', 'ReadProtected')

    nargs = 2

# Bessel Functions


class BesselJ(_Bessel):
    """
    <dl>
    <dt>'BesselJ[$n$, $z$]'
      <dd>returns the Bessel function of the first kind J_$n$($z$).
    </dl>

    >> BesselJ[0, 5.2]
     = -0.11029043979098654

    #> BesselJ[2.5, 1]
     = 0.0494968102284779423

    ## >> D[BesselJ[n, z], z]
    ##  = BesselJ[n - 1, z] / 2 - BesselJ[n + 1, z] / 2

    #> BesselJ[0., 0.]
     = 1.

    >> Plot[BesselJ[0, x], {x, 0, 10}]
     = -Graphics-
    """

    # TODO: Sympy Backend is not as powerful as Mathmeatica
    """
    >> BesselJ[1/2, x]
     = Sqrt[2 / Pi] Sin[x] / Sqrt[x]
    """

    attributes = ('Listable', 'NumericFunction', 'Protected')

    sympy_name = 'besselj'
    mpmath_name = 'besselj'


class BesselY(_Bessel):
    """
    <dl>
    <dt>'BesselY[$n$, $z$]'
      <dd>returns the Bessel function of the second kind Y_$n$($z$).
    </dl>

    >> BesselY[1.5, 4]
     = 0.367112032460934155

    ## Returns ComplexInfinity instead
    ## #> BesselY[0., 0.]
    ##  = -Infinity

    >> Plot[BesselY[0, x], {x, 0, 10}]
     = -Graphics-
    """

    # TODO: Special Values
    """
    >> BesselY[0, 0]
     = -Infinity
    """

    attributes = ('Listable', 'NumericFunction', 'Protected')

    sympy_name = 'bessely'
    mpmath_name = 'bessely'


class BesselI(_Bessel):
    """
    <dl>
    <dt>'BesselI[$n$, $z$]'
      <dd>returns the modified Bessel function of the first kind I_$n$($z$).
    </dl>

    >> BesselI[1.5, 4]
     = 8.17263323168659544

    >> Plot[BesselI[0, x], {x, 0, 5}]
     = -Graphics-
    """

    attributes = ('Listable', 'NumericFunction', 'Protected')

    sympy_name = 'besseli'
    mpmath_name = 'besseli'


class BesselK(_Bessel):
    """
    <dl>
    <dt>'BesselK[$n$, $z$]'
      <dd>returns the modified Bessel function of the second kind K_$n$($z$).
    </dl>

    >> BesselK[1.5, 4]
     = 0.0143470307207600668

    >> Plot[BesselK[0, x], {x, 0, 5}]
     = -Graphics-
    """

    attributes = ('Listable', 'NumericFunction', 'Protected')

    sympy_name = 'besselk'
    mpmath_name = 'besselk'

# TODO: Spherical Bessel Functions

# Hankel Functions


class HankelH1(_Bessel):
    """
    <dl>
    <dt>'HankelH1[$n$, $z$]'
      <dd>returns the Hankel function of the first kind H_$n$^1 ($z$).
    </dl>

    >> HankelH1[1.5, 4]
     = 0.185285948354268953 + 0.367112032460934155 I
    """

    sympy_name = 'hankel1'
    mpmath_name = 'hankel1'


class HankelH2(_Bessel):
    """
    <dl>
    <dt>'HankelH2[$n$, $z$]'
      <dd>returns the Hankel function of the second kind H_$n$^2 ($z$).
    </dl>

    >> HankelH2[1.5, 4]
     = 0.185285948354268953 - 0.367112032460934155 I
    """

    sympy_name = 'hankel2'
    mpmath_name = 'hankel2'

# Airy Functions


class AiryAi(_MPMathFunction):
    """
    <dl>
    <dt>'AiryAi[$x$]'
      <dd>returns the Airy function Ai($x$).
    </dl>

    >> AiryAi[0.5]
     = 0.23169360648083349

    >> AiryAi[0.5 + I]
     = 0.157118446499986172 - 0.241039813840210768 I

    >> Plot[AiryAi[x], {x, -10, 10}]
     = -Graphics-
    """

    sympy_name = ''
    mpmath_name = 'airyai'


class AiryBi(_MPMathFunction):
    """
    <dl>
    <dt>'AiryBi[$x$]'
      <dd>returns the Airy function Bi($x$).
    </dl>

    >> AiryBi[0.5]
     = 0.854277043103155493

    >> AiryBi[0.5 + I]
     = 0.688145273113482414 + 0.370815390737010831 I

    >> Plot[AiryBi[x], {x, -10, 2}]
     = -Graphics-
    """

    sympy_name = ''
    mpmath_name = 'airybi'

# Kelvin Functions


class KelvinBer(_Bessel):
    """
    <dl>
    <dt>'KelvinBer[$z$]'
      <dd>returns the Kelvin function ber($z$).
    <dt>'KelvinBer[$n$, $z$]'
      <dd>returns the Kelvin function ber_$n$($z$).
    </dl>

    >> KelvinBer[0.5]
     = 0.999023463990838256

    >> KelvinBer[1.5 + I]
     = 1.11620420872233787 - 0.117944469093970067 I

    >> KelvinBer[0.5, 0.25]
     = 0.148824330530639942

    >> Plot[KelvinBer[x], {x, 0, 10}]
     = -Graphics-
    """

    rules = {
        'KelvinBer[z_]': 'KelvinBer[0, z]',
    }

    sympy_name = ''
    mpmath_name = 'ber'


class KelvinBei(_Bessel):
    """
    <dl>
    <dt>'KelvinBei[$z$]'
      <dd>returns the Kelvin function bei($z$).
    <dt>'KelvinBei[$n$, $z$]'
      <dd>returns the Kelvin function bei_$n$($z$).
    </dl>

    >> KelvinBei[0.5]
     = 0.0624932183821994586

    >> KelvinBei[1.5 + I]
     = 0.326323348699806294 + 0.75560557861089228 I

    >> KelvinBei[0.5, 0.25]
     = 0.370152900194021013

    >> Plot[KelvinBei[x], {x, 0, 10}]
     = -Graphics-
    """

    rules = {
        'KelvinBei[z_]': 'KelvinBei[0, z]',
    }

    sympy_name = ''
    mpmath_name = 'bei'


class KelvinKer(_Bessel):
    """
    <dl>
    <dt>'KelvinKer[$z$]'
      <dd>returns the Kelvin function ker($z$).
    <dt>'KelvinKer[$n$, $z$]'
      <dd>returns the Kelvin function ker_$n$($z$).
    </dl>

    >> KelvinKer[0.5]
     = 0.855905872118634214

    >> KelvinKer[1.5 + I]
     = -0.167162242027385125 - 0.184403720314419905 I

    >> KelvinKer[0.5, 0.25]
     = 0.450022838747182502

    >> Plot[KelvinKer[x], {x, 0, 10}]
     = -Graphics-
    """

    rules = {
        'KelvinKer[z_]': 'KelvinKer[0, z]',
    }

    sympy_name = ''
    mpmath_name = 'ker'


class KelvinKei(_Bessel):
    """
    <dl>
    <dt>'KelvinKei[$z$]'
      <dd>returns the Kelvin function kei($z$).
    <dt>'KelvinKei[$n$, $z$]'
      <dd>returns the Kelvin function kei_$n$($z$).
    </dl>

    >> KelvinKei[0.5]
     = -0.671581695094367603

    >> KelvinKei[1.5 + I]
     = -0.248993863536003923 + 0.303326291875385478 I

    >> KelvinKei[0.5, 0.25]
     = -2.05169683896315934

    >> Plot[KelvinKei[x], {x, 0, 10}]
     = -Graphics-
    """

    rules = {
        'KelvinKei[z_]': 'KelvinKei[0, z]',
    }

    sympy_name = ''
    mpmath_name = 'kei'

# Struve and Related Functions


class StruveH(_Bessel):
    """
    <dl>
    <dt>'StruveH[$n$, $z$]'
      <dd>returns the Struve function H_$n$($z$).
    </dl>

    >> StruveH[1.5, 3.5]
     = 1.13192125271801312

    >> Plot[StruveH[0, x], {x, 0, 20}]
     = -Graphics-
    """

    sympy_name = ''
    mpmath_name = 'struveh'


class StruveL(_Bessel):
    """
    <dl>
    <dt>'StruveL[$n$, $z$]'
      <dd>returns the modified Struve function L_$n$($z$).
    </dl>

    >> StruveL[1.5, 3.5]
     = 4.41126360920433996

    >> Plot[StruveL[0, x], {x, 0, 5}]
     = -Graphics-
    """

    sympy_name = ''
    mpmath_name = 'struvel'


class AngerJ(_Bessel):
    """
    <dl>
    <dt>'AngerJ[$n$, $z$]'
      <dd>returns the Anger function J_$n$($z$).
    </dl>

    >> AngerJ[1.5, 3.5]
     = 0.294478574459563408

    >> Plot[AngerJ[1, x], {x, -10, 10}]
     = -Graphics-
    """

    # TODO: Associated Anger function AngerJ[v, u, z]

    sympy_name = ''
    mpmath_name = 'angerj'


class WeberE(_Bessel):
    """
    <dl>
    <dt>'WeberE[$n$, $z$]'
      <dd>returns the Weber function E_$n$($z$).
    </dl>

    >> WeberE[1.5, 3.5]
     = -0.397256259210030809

    >> Plot[WeberE[1, x], {x, -10, 10}]
     = -Graphics-
    """

    # TODO: Associated Weber function WeberE[v, u, z]

    sympy_name = ''
    mpmath_name = 'webere'

# Function Zeros


class BesselJZero(_Bessel):
    """
    <dl>
    <dt>'BesselJZero[$n$, $k$]'
      <dd>returns the $k$th zero of the Bessel function of the first kind J_$n$($z$).
    </dl>

    >> N[BesselJZero[0, 1]]
     = 2.40482555769577277
    """

    sympy_name = ''
    mpmath_name = 'besseljzero'


class BesselYZero(_Bessel):
    """
    <dl>
    <dt>'BesselJZero[$n$, $k$]'
      <dd>returns the $k$th zero of the Bessel function of the second kind Y_$n$($z$).
    </dl>

    >> N[BesselYZero[0, 1]]
     = 0.893576966279167522
    """

    sympy_name = ''
    mpmath_name = 'besselyzero'


class AiryAiZero(Builtin):
    """
    <dl>
    <dt>'AiryAiZero[$k$]'
      <dd>returns the $k$th zero of the Airy function Ai($z$).
    </dl>

    >> N[AiryAiZero[1]]
     = -2.33810741045976704

    #> AiryAiZero[1]
     = AiryAiZero[1]

    #> AiryAiZero[1.]
     = AiryAiZero[1.]

    #> AiryAi[AiryAiZero[1]]
     = 0
    """

    # TODO: 'AiryAiZero[$k$, $x0$]' - $k$th zero less than x0

    attributes = ('Listable', 'NHoldFirst',
                  'NumericFunction', 'Protected', 'ReadProtected')

    rules = {
        'AiryAi[AiryAiZero[k_]]': '0',
    }

    def apply_N(self, k, precision, evaluation):
        'N[AiryAiZero[k_Integer], precision_]'

        prec = get_precision(precision, evaluation)
        k_int = k.get_int_value()

        with mpmath.workprec(prec):
            result = mpmath2sympy(mpmath.airyaizero(k_int), prec)
        return from_sympy(result)


class AiryBiZero(Builtin):
    """
    <dl>
    <dt>'AiryBiZero[$k$]'
      <dd>returns the $k$th zero of the Airy function Bi($z$).
    </dl>

    >> N[AiryBiZero[1]]
     = -1.17371322270912792

    #> AiryBiZero[1]
     = AiryBiZero[1]

    #> AiryBiZero[1.]
     = AiryBiZero[1.]

    #> AiryBi[AiryBiZero[1]]
     = 0
    """

    # TODO: 'AiryBiZero[$k$, $x0$]' - $k$th zero less than x0

    attributes = ('Listable', 'NHoldFirst',
                  'NumericFunction', 'Protected', 'ReadProtected')

    rules = {
        'AiryBi[AiryBiZero[z_]]': '0',
    }

    def apply_N(self, k, precision, evaluation):
        'N[AiryBiZero[k_Integer], precision_]'

        prec = get_precision(precision, evaluation)
        k_int = k.get_int_value()

        with mpmath.workprec(prec):
            result = mpmath2sympy(mpmath.airybizero(k_int), prec)
        return from_sympy(result)

# Orthogonal Polynomials


class LegendreP(_MPMathFunction):
    """
    <dl>
    <dt>'LegendreP[$n$, $x$]'
      <dd>returns the Legendre polynomial P_$n$($x$).
    <dt>'LegendreP[$n$, $m$, $x$]'
      <dd>returns the associated Legendre polynomial P^$m$_$n$($x$).
    </dl>

    >> LegendreP[4, x]
     = 3 / 8 - 15 x ^ 2 / 4 + 35 x ^ 4 / 8

    >> LegendreP[5/2, 1.5]
     = 4.17761913892745532

    >> LegendreP[1.75, 1.4, 0.53]
     = -1.32619280980662145

    >> LegendreP[1.6, 3.1, 1.5]
     = -0.303998161489593441 - 1.91936885256334894 I

    'LegendreP' can be used to draw generalized Lissajous figures:
    >> ParametricPlot[ {LegendreP[7, x], LegendreP[5, x]}, {x, -1, 1}]
     = -Graphics-
    """

    # FIXME: Sympy can't handle associated polynomials
    """
    >> LegendreP[2, 1, x]
     = -3 x Sqrt[1 - x^2]
    """

    rules = {
        'LegendreP[n_, x_]': 'LegendreP[n, 0, x]'
    }

    nargs = 3
    sympy_name = 'legendre'
    mpmath_name = 'legenp'

    def prepare_sympy(self, leaves):
        if leaves[1] == Integer(0):
            return leaves[:1] + leaves[2:]
        return leaves


class LegendreQ(_MPMathFunction):
    """
    <dl>
    <dt>'LegendreQ[$n$, $x$]'
      <dd>returns the Legendre function of the second kind Q_$n$($x$).
    <dt>'LegendreQ[$n$, $m$, $x$]'
      <dd>returns the associated Legendre function of the second Q^$m$_$n$($x$).
    </dl>

    >> LegendreQ[5/2, 1.5]
     = 0.0362109671796812979 - 6.56218879817530572 I

    >> LegendreQ[1.75, 1.4, 0.53]
     = 2.05498907857609114

    >> LegendreQ[1.6, 3.1, 1.5]
     = -1.71931290970694153 - 7.70273279782676974 I
    """

    # FIXME: Sympy is missing the Legendre function of the second kind so
    # symbolic manipulations are limited
    """
    >> LegendreQ[2, x]
     = -3 x / 2 - 3 x ^ 2 Log[1 - x] / 4 + 3 x ^ 2 Log[1 + x] / 4 - Log[1 + x] / 4 + Log[1 - x] / 4
    """

    rules = {
        'LegendreQ[n_, x_]': 'LegendreQ[n, 0, x]'
    }

    nargs = 3
    sympy_name = ''
    mpmath_name = 'legenq'

    def prepare_sympy(self, leaves):
        if leaves[1] == Integer(0):
            return leaves[:1] + leaves[2:]
        return leaves


class JacobiP(_MPMathFunction):
    """
    <dl>
    <dt>'JacobiP[$n$, $a$, $b$, $x$]'
      <dd>returns the Jacobi polynomial P_$n$^($a$,$b$)($x$).
    </dl>

    >> JacobiP[1, a, b, z]
     = a / 2 - b / 2 + z (1 + a / 2 + b / 2)

    >> JacobiP[3.5 + I, 3, 2, 4 - I]
     = 1410.02011674512937 + 5797.29855312717469 I
    """

    nargs = 4
    sympy_name = 'jacobi'
    mpmath_name = 'jacobi'


class SphericalHarmonicY(_MPMathFunction):
    u"""
    <dl>
    <dt>'SphericalHarmonicY[$l$, $m$, $theta$, $phi$]'
      <dd>returns the spherical harmonic functin Y_$l$^$m$(theta, phi).
    </dl>

    >> SphericalHarmonicY[3/4, 0.5, Pi/5, Pi/3]
     = 0.254247340352667373 + 0.146789770393358909 I

    ## Results depend on sympy version
    >> SphericalHarmonicY[3, 1, theta, phi]
     = ...

    #> SphericalHarmonicY[1,1,x,y]
     = -Sqrt[6] E ^ (I y) Sin[x] / (4 Sqrt[Pi])
    """

    nargs = 4
    sympy_name = 'Ynm'
    mpmath_name = 'spherharm'

    def prepare_mathics(self, sympy_expr):
        return sympy_expr.expand(func=True).simplify()


class GegenbauerC(_MPMathFunction):
    """
    <dl>
    <dt>'GegenbauerC[$n$, $m$, $x$]'
      <dd>returns the Generbauer polynomial C_$n$^($m$)($x$).
    </dl>

    >> GegenbauerC[6, 1, x]
     = -1 + 24 x ^ 2 - 80 x ^ 4 + 64 x ^ 6

    >> GegenbauerC[4 - I, 1 + 2 I, 0.7]
     = -3.26209595216525854 - 24.9739397455269944 I
    """

    # TODO: Two argument renormalized form GegenbauerC[n, x]

    nargs = 3
    sympy_name = 'gegenbauer'
    mpmath_name = 'gegenbauer'


class ChebyshevT(_MPMathFunction):
    """
    <dl>
    <dt>'ChebyshevT[$n$, $x$]'
      <dd>returns the Chebyshev polynomial of the first kind T_$n$($x$).
    </dl>

    >> ChebyshevT[8, x]
     = 1 - 32 x ^ 2 + 160 x ^ 4 - 256 x ^ 6 + 128 x ^ 8

    >> ChebyshevT[1 - I, 0.5]
     = 0.800143428851193116 + 1.08198360440499884 I
    """

    nargs = 2
    sympy_name = 'chebyshevt'
    mpmath_name = 'chebyt'


class ChebyshevU(_MPMathFunction):
    """
    <dl>
    <dt>'ChebyshevU[$n$, $x$]'
      <dd>returns the Chebyshev polynomial of the second kind U_$n$($x$).
    </dl>

    >> ChebyshevU[8, x]
     = 1 - 40 x ^ 2 + 240 x ^ 4 - 448 x ^ 6 + 256 x ^ 8

    >> ChebyshevU[1 - I, 0.5]
     = 1.60028685770238623 + 0.721322402936665892 I
    """

    nargs = 2
    sympy_name = 'chebyshevu'
    mpmath_name = 'chebyu'


class HermiteH(_MPMathFunction):
    """
    <dl>
    <dt>'ChebyshevU[$n$, $x$]'
      <dd>returns the Hermite polynomial H_$n$($x$).
    </dl>

    >> HermiteH[8, x]
     = 1680 - 13440 x ^ 2 + 13440 x ^ 4 - 3584 x ^ 6 + 256 x ^ 8

    >> HermiteH[3, 1 + I]
     = -28 + 4 I

    >> HermiteH[4.2, 2]
     = 77.5290837369752225
    """

    nargs = 2
    sympy_name = 'hermite'
    mpmath_name = 'hermite'


class LaguerreL(_MPMathFunction):
    """
    <dl>
    <dt>'LaguerreL[$n$, $x$]'
      <dd>returns the Laguerre polynomial L_$n$($x$).
    <dt>'LaguerreL[$n$, $a$, $x$]'
      <dd>returns the generalised Laguerre polynomial L^$a$_$n$($x$).
    </dl>

    >> LaguerreL[8, x]
     = 1 - 8 x + 14 x ^ 2 - 28 x ^ 3 / 3 + 35 x ^ 4 / 12 - 7 x ^ 5 / 15 + 7 x ^ 6 / 180 - x ^ 7 / 630 + x ^ 8 / 40320

    >> LaguerreL[3/2, 1.7]
     = -0.94713399725341823

    >> LaguerreL[5, 2, x]
     = 21 - 35 x + 35 x ^ 2 / 2 - 7 x ^ 3 / 2 + 7 x ^ 4 / 24 - x ^ 5 / 120
    """

    rules = {
        'LaguerreL[n_, x_]': 'LaguerreL[n, 0, x]',
    }

    nargs = 3
    sympy_name = 'laguerre_poly'
    mpmath_name = 'laguerre'

    def prepare_sympy(self, leaves):
        if len(leaves) == 3:
            return [leaves[0], leaves[2], leaves[1]]
        return leaves

# TODO: Zernike polynomials not yet implemented in mpmath nor sympy
#
# class ZernikeR(_MPMathFunction):
#    """
#    <dl>
#    <dt>'ZernikeR[$n$, $m$,  $r$]'
#      <dd>returns the radial Zernike polynomial R_$n$^$m$($r$).
#    </dl>
#
#    >> ZernikeR[3, 1, r]
#     = -2 r + 3 r ^ 3
#
#    >> ZernikeR[5, 1, 1/2]
#     = 5 / 16
#
#    >> ZernikeR[3 - I, 4.5, 1.5 + I]
#     = 1.12642179606815007 - 1.21017262353631061 I
#    """
#
#    nargs = 3
#    sympy_name = ''
#    mpmath_name = ''

########NEW FILE########
__FILENAME__ = strings
# -*- coding: utf8 -*-

"""
String functions
"""

from mathics.builtin.base import BinaryOperator, Builtin, Test
from mathics.core.expression import (Expression, Symbol, String, Integer,
                                     from_python)


class StringJoin(BinaryOperator):
    """
    >> StringJoin["a", "b", "c"]
     = abc
    >> "a" <> "b" <> "c" // InputForm
     = "abc"

    'StringJoin' flattens lists out:
    >> StringJoin[{"a", "b"}] // InputForm
     = "ab"
    >> Print[StringJoin[{"Hello", " ", {"world"}}, "!"]]
     | Hello world!
    """

    operator = '<>'
    precedence = 600
    attributes = ('Flat', 'OneIdentity')

    def apply(self, items, evaluation):
        'StringJoin[items___]'

        result = ''
        items = items.flatten(Symbol('List'))
        if items.get_head_name() == 'List':
            items = items.leaves
        else:
            items = items.get_sequence()
        for item in items:
            if not isinstance(item, String):
                evaluation.message('StringJoin', 'string')
                return
            result += item.value
        return String(result)


class StringSplit(Builtin):
    """
    >> StringSplit["abc,123", ","]
     = {abc, 123}

    >> StringSplit["abc 123"]
     = {abc, 123}

    #> StringSplit["  abc    123  "]
     = {abc, 123}

    >> StringSplit["abc,123.456", {",", "."}]
     = {abc, 123, 456}

    #> StringSplit["x", "x"]
     = {}

    #> StringSplit[x]
     : String or list of strings expected at position 1 in StringSplit[x].
     = StringSplit[x]

    #> StringSplit["x", x]      (* Mathematica uses StringExpression *)
     : String or list of strings expected at position 2 in StringSplit[x, x].
     = StringSplit[x, x]
    """

    messages = {
        'strse': 'String or list of strings expected at position `1` in `2`.',
    }

    def apply(self, string, seps, evaluation):
        'StringSplit[string_String, seps_List]'
        py_string, py_seps = string.get_string_value(), seps.get_leaves()
        result = [py_string]

        for py_sep in py_seps:
            if not isinstance(py_sep, String):
                evaluation.message('StringSplit', 'strse', Integer(2),
                                   Expression('StringSplit', string, seps))
                return

        py_seps = [py_sep.get_string_value() for py_sep in py_seps]

        for py_sep in py_seps:
            result = [t for s in result for t in s.split(py_sep)]
        return from_python(filter(lambda x: x != u'', result))

    def apply_single(self, string, sep, evaluation):
        'StringSplit[string_String, sep_?NotListQ]'
        if not isinstance(sep, String):
            evaluation.message('StringSplit', 'strse', Integer(2),
                               Expression('StringSplit', string, sep))
            return
        return self.apply(string, Expression('List', sep), evaluation)

    def apply_empty(self, string, evaluation):
        'StringSplit[string_String]'
        py_string = string.get_string_value()
        result = py_string.split()
        return from_python(filter(lambda x: x != u'', result))

    def apply_strse1(self, x, evaluation):
        'StringSplit[x_/;Not[StringQ[x]]]'
        evaluation.message('StringSplit', 'strse', Integer(1),
                           Expression('StringSplit', x))
        return

    def apply_strse2(self, x, y, evaluation):
        'StringSplit[x_/;Not[StringQ[x]], y_]'
        evaluation.message('StringSplit', 'strse', Integer(1),
                           Expression('StringSplit', x))
        return


class StringLength(Builtin):
    """
    'StringLength' gives the length of a string.
    >> StringLength["abc"]
     = 3
    'StringLength' is listable:
    >> StringLength[{"a", "bc"}]
     = {1, 2}

    >> StringLength[x]
     : String expected.
     = StringLength[x]
    """

    attributes = ('Listable',)

    def apply(self, str, evaluation):
        'StringLength[str_]'

        if not isinstance(str, String):
            evaluation.message('StringLength', 'string')
            return
        return Integer(len(str.value))


class StringReplace(Builtin):
    """
    <dl>
    <dt>'StringReplace["$string$", $s$->$sp$]' or 'StringReplace["$string$", {$s1$->$sp1$, $s2$->$sp2$}]'
      <dd>replace the string $si$ by $spi$ for all occurances in "$string$".
    <dt>'StringReplace["$string$", $srules$, $n$]'
      <dd>only perform the first $n$ replacements.
    <dt>'StringReplace[{"$string1$", "$string2$", ...}, srules]'
      <dd>perform replacements on a list of strings
    </dl>

    StringReplace replaces all occurances of one substring with another:
    >> StringReplace["xyxyxyyyxxxyyxy", "xy" -> "A"]
     = AAAyyxxAyA

    Multiple replacements can be supplied:
    >> StringReplace["xyzwxyzwxxyzxyzw", {"xyz" -> "A", "w" -> "BCD"}]
     = ABCDABCDxAABCD

    Only replace the first 2 occurances:
    >> StringReplace["xyxyxyyyxxxyyxy", "xy" -> "A", 2]
     = AAxyyyxxxyyxy

    StringReplace acts on lists of strings too:
    >> StringReplace[{"xyxyxxy", "yxyxyxxxyyxy"}, "xy" -> "A"]
     = {AAxA, yAAxxAyA}

    #> StringReplace["abcabc", "a" -> "b", Infinity]
     = bbcbbc
    #> StringReplace[x, "a" -> "b"]
     : String or list of strings expected at position 1 in StringReplace[x, a -> b].
     = StringReplace[x, a -> b]
    #> StringReplace["xyzwxyzwaxyzxyzw", x]
     : x is not a valid string replacement rule.
     = StringReplace[xyzwxyzwaxyzxyzw, x]
    #> StringReplace["xyzwxyzwaxyzxyzw", x -> y]
     : x -> y is not a valid string replacement rule.
     = StringReplace[xyzwxyzwaxyzxyzw, x -> y]
    #> StringReplace["abcabc", "a" -> "b", x]
     : Non-negative integer or Infinity expected at position 3 in StringReplace[abcabc, a -> b, x].
     = StringReplace[abcabc, a -> b, x]
    """

    attributes = ('Protected')

    # TODO: Implement these options
    options = {
        'IgnoreCase': 'False',
        'MetaCharacters': 'None',
    }

    messages = {
        'strse': 'String or list of strings expected at position `1` in `2`.',
        'srep': '`1` is not a valid string replacement rule.',
        'innf': ('Non-negative integer or Infinity expected at '
                 'position `1` in `2`.'),
    }

    # TODO: Implement StringExpression replacements
    def check_arguments(self, string, rule, n, evaluation):
        if n is None:
            expr = Expression('StringReplace', string, rule)
        else:
            expr = Expression('StringReplace', string, rule, n)

        # Check first argument
        if string.has_form('List', None):
            py_string = [s.get_string_value() for s in string.get_leaves()]
            if None in py_string:
                evaluation.message('StringReplace', 'strse', Integer(1), expr)
                return
        else:
            py_string = string.get_string_value()
            if py_string is None:
                evaluation.message('StringReplace', 'strse', Integer(1), expr)
                return

        # Check second argument
        def check_rule(r):
            tmp = [s.get_string_value() for s in r.get_leaves()]
            if not (r.has_form('Rule', None) and len(tmp) == 2 and
                    all(r is not None for r in tmp)):
                evaluation.message('StringReplace', 'srep', r)
                return None
            return tmp

        if rule.has_form('List', None):
            tmp_rules = rule.get_leaves()
            py_rules = []
            for r in tmp_rules:
                tmp = check_rule(r)
                if tmp is None:
                    return None
                py_rules.append(tmp)
        else:
            tmp = check_rule(rule)
            if tmp is None:
                return None
            py_rules = [tmp]

        if n is None:
            return (py_string, py_rules)
        elif n == Expression('DirectedInfinity', Integer(1)):
            return (py_string, py_rules, None)
        else:
            py_n = n.get_int_value()
            if py_n < 0:
                evaluation.message('StringReplace', 'innf', Integer(3), expr)
                return None
            return (py_string, py_rules, py_n)

    def apply(self, string, rule, evaluation):
        'StringReplace[string_, rule_]'

        args = self.check_arguments(string, rule, None, evaluation)
        if args is None:
            return None
        (py_string, py_rules) = args

        def do_replace(s):
            for sp in py_rules:
                s = s.replace(sp[0], sp[1])
            return s

        if isinstance(py_string, list):
            result = [do_replace(s) for s in py_string]
        else:
            result = do_replace(py_string)

        return from_python(result)

    def apply_n(self, string, rule, n, evaluation):
        'StringReplace[string_, rule_, n_]'

        args = self.check_arguments(string, rule, n, evaluation)

        if args is None:
            return None
        (py_string, py_rules, py_n) = args

        def do_replace(s):
            for sp in py_rules:
                if py_n is None:
                    s = s.replace(sp[0], sp[1])
                else:
                    s = s.replace(sp[0], sp[1], py_n)
            return s

        if isinstance(py_string, list):
            result = [do_replace(s) for s in py_string]
        else:
            result = do_replace(py_string)

        return from_python(result)


class Characters(Builtin):
    u"""
    >> Characters["abc"]
     = {a, b, c}

    #> \\.78\\.79\\.7A
     = xyz

    #> \\:0078\\:0079\\:007A
     = xyz

    #> \\101\\102\\103\\061\\062\\063
     = ABC123

    #> \\[Alpha]\\[Beta]\\[Gamma]
     = \u03B1\u03B2\u03B3
    """

    attributes = ('Listable',)

    def apply(self, string, evaluation):
        'Characters[string_String]'

        return Expression('List', *(String(c) for c in string.value))


class CharacterRange(Builtin):
    """
    >> CharacterRange["a", "e"]
     = {a, b, c, d, e}
    >> CharacterRange["b", "a"]
     = {}
    """

    attributes = ('ReadProtected',)

    messages = {
        'argtype': "Arguments `1` and `2` are not both strings of length 1.",
    }

    def apply(self, start, stop, evaluation):
        'CharacterRange[start_String, stop_String]'

        if len(start.value) != 1 or len(stop.value) != 1:
            evaluation.message('CharacterRange', 'argtype', start, stop)
            return
        start = ord(start.value[0])
        stop = ord(stop.value[0])
        return Expression('List', *[
            String(unichr(code)) for code in xrange(start, stop + 1)])


class String_(Builtin):
    """
    'String' is the head of strings.
    >> Head["abc"]
     = String
    >> "abc"
     = abc
    Use 'InputForm' to display quotes around strings:
    >> InputForm["abc"]
     = "abc"
    'FullForm' also displays quotes:
    >> FullForm["abc" + 2]
     = Plus[2, "abc"]
    """

    name = 'String'


class ToString(Builtin):
    """
    >> ToString[2]
     = 2
    >> ToString[2] // InputForm
     = "2"
    >> ToString[a+b]
     = a + b
    >> "U" <> 2
     : String expected.
     = U <> 2
    >> "U" <> ToString[2]
     = U2
    """

    def apply(self, value, evaluation):
        'ToString[value_]'

        text = value.format(evaluation, 'OutputForm').boxes_to_text(
            evaluation=evaluation)
        return String(text)


class ToExpression(Builtin):
    """
    <dl>
    <dt>'ToExpression[$input$]'
      <dd>inteprets a given string as Mathics input.
    <dt>'ToExpression[$input$, $form$]'
      <dd>reads the given input in the specified form.
    <dt>'ToExpression[$input$, $form$, $h$]'
      <dd>applies the head $h$ to the expression before evaluating it.
    </dl>

    >> ToExpression["1 + 2"]
     = 3

    >> ToExpression["{2, 3, 1}", InputForm, Max]
     = 3

    #> ToExpression["log(x)", InputForm]
     = log x

    #> ToExpression["1+"]
     : Incomplete expression; more input is needed .
     = $Failed

    #> ToExpression[]
     : ToExpression called with 0 arguments; between 1 and 3 arguments are expected.
     = ToExpression[]
    """

    # TODO: Other forms
    """
    >> ToExpression["log(x)", TraditionalForm]
     = Log[x]
    #> ToExpression["log(x)", StandardForm]
     = log x
    """

    attributes = ('Listable', 'Protected')

    messages = {
        'argb': ('`1` called with `2` arguments; '
                 'between `3` and `4` arguments are expected.'),
        'interpfmt': ('`1` is not a valid interpretation format. '
                      'Valid interpretation formats include InputForm '
                      'and any member of $BoxForms.'),
        'notstr': 'The format type `1` is valid only for string input.',
        'sntxi': 'Incomplete expression; more input is needed `1`.',
    }

    def apply(self, seq, evaluation):
        'ToExpression[seq__]'

        # Organise Arguments
        py_seq = seq.get_sequence()
        if len(py_seq) == 1:
            (inp, form, head) = (py_seq[0], Symbol('InputForm'), None)
        elif len(py_seq) == 2:
            (inp, form, head) = (py_seq[0], py_seq[1], None)
        elif len(py_seq) == 3:
            (inp, form, head) = (py_seq[0], py_seq[1], py_seq[2])
        else:
            assert len(py_seq) > 3  # 0 case handled by apply_empty
            evaluation.message('ToExpression', 'argb', 'ToExpression',
                               Integer(len(py_seq)), Integer(1), Integer(3))
            return

        # Apply the differnet forms
        if form == Symbol('InputForm'):
            if isinstance(inp, String):
                from mathics.core.parser import parse, ParseError
                try:
                    result = parse(inp.get_string_value())
                except ParseError:
                    evaluation.message('ToExpression', 'sntxi', String(''))
                    return Symbol('$Failed')
            else:
                result = inp
        else:
            evaluation.message('ToExpression', 'interpfmt', form)
            return

        # Apply head if present
        if head is not None:
            result = Expression(head, result).evaluate(evaluation)

        return result

    def apply_empty(self, evaluation):
        'ToExpression[]'
        evaluation.message('ToExpression', 'argb', 'ToExpression',
                           Integer(0), Integer(1), Integer(3))
        return


class ToCharacterCode(Builtin):
    """
    <dl>
    <dt>'ToCharacterCode["string"]'
      <dd>converts the string to a list of integer character codes.
    <dt>'ToCharacterCode[{"string1", "string2", ...}]'
      <dd>converts a list of strings to character codes.
    </dl>

    >> ToCharacterCode["abc"]
     = {97, 98, 99}
    >> FromCharacterCode[%]
     = abc

    >> ToCharacterCode["\[Alpha]\[Beta]\[Gamma]"]
     = {945, 946, 947}

    >> ToCharacterCode[{"ab", "c"}]
     = {{97, 98}, {99}}

    #> ToCharacterCode[{"ab"}]
     = {{97, 98}}

    #> ToCharacterCode[{{"ab"}}]
     : String or list of strings expected at position 1 in ToCharacterCode[{{ab}}].
     = ToCharacterCode[{{ab}}]

    >> ToCharacterCode[{"ab", x}]
     : String or list of strings expected at position 1 in ToCharacterCode[{ab, x}].
     = ToCharacterCode[{ab, x}]

    >> ListPlot[ToCharacterCode["plot this string"], Filling -> Axis]
     = -Graphics-

    #> ToCharacterCode[x]
     : String or list of strings expected at position 1 in ToCharacterCode[x].
     = ToCharacterCode[x]

    #> ToCharacterCode[""]
     = {}
    """

    messages = {
        'strse': 'String or list of strings expected at position `1` in `2`.',
    }

    #TODO: encoding

    def apply(self, string, evaluation):
        "ToCharacterCode[string_]"

        exp = Expression('ToCharacterCode', string)

        if string.has_form('List', None):
            string = [substring.get_string_value()
                      for substring in string.leaves]
            if any(substring is None for substring in string):
                evaluation.message('ToCharacterCode', 'strse', Integer(1), exp)
                return None
        else:
            string = string.get_string_value()
            if string is None:
                evaluation.message('ToCharacterCode', 'strse', Integer(1), exp)
                return None

        if isinstance(string, list):
            codes = [[ord(char) for char in substring] for substring in string]
        elif isinstance(string, basestring):
            codes = [ord(char) for char in string]
        return from_python(codes)


class FromCharacterCode(Builtin):
    """
    <dl>
    <dt>'FromCharacterCode[$n$]'
        <dd>returns the character corresponding to character code $n$.
    <dt>'FromCharacterCode[{$n1$, $n2$, ...}]'
        <dd>returns a string with characters corresponding to $n_i$.
    <dt>'FromCharacterCode[{{$n11$, $n12$, ...}, {$n21$, $n22$, ...}, ...}]'
        <dd>returns a list of strings.
    </dl>

    >> FromCharacterCode[100]
     = d

    >> FromCharacterCode[{100, 101, 102}]
     = def
    >> ToCharacterCode[%]
     = {100, 101, 102}

    >> FromCharacterCode[{{97, 98, 99}, {100, 101, 102}}]
     = {abc, def}

    >> ToCharacterCode["abc 123"] // FromCharacterCode
     = abc 123

    #> #1 == ToCharacterCode[FromCharacterCode[#1]] & [RandomInteger[{0, 65535}, 100]]
     = True

    #> FromCharacterCode[{}] // InputForm
     = ""

    #> FromCharacterCode[65536]
     : A character code, which should be a non-negative integer less than 65536, is expected at position 1 in {65536}.
     = FromCharacterCode[65536]
    #> FromCharacterCode[-1]
     : Non-negative machine-sized integer expected at position 1 in FromCharacterCode[-1].
     = FromCharacterCode[-1]
    #> FromCharacterCode[444444444444444444444444444444444444]
     : Non-negative machine-sized integer expected at position 1 in FromCharacterCode[444444444444444444444444444444444444].
     = FromCharacterCode[444444444444444444444444444444444444]

    #> FromCharacterCode[{100, 101, -1}]
     : A character code, which should be a non-negative integer less than 65536, is expected at position 3 in {100, 101, -1}.
     = FromCharacterCode[{100, 101, -1}]
    #> FromCharacterCode[{100, 101, 65536}]
     : A character code, which should be a non-negative integer less than 65536, is expected at position 3 in {100, 101, 65536}.
     = FromCharacterCode[{100, 101, 65536}]
    #> FromCharacterCode[{100, 101, x}]
     : A character code, which should be a non-negative integer less than 65536, is expected at position 3 in {100, 101, x}.
     = FromCharacterCode[{100, 101, x}]
    #> FromCharacterCode[{100, {101}}]
     : A character code, which should be a non-negative integer less than 65536, is expected at position 2 in {100, {101}}.
     = FromCharacterCode[{100, {101}}]

    #> FromCharacterCode[{{97, 98, 99}, {100, 101, x}}]
     : A character code, which should be a non-negative integer less than 65536, is expected at position 3 in {100, 101, x}.
     = FromCharacterCode[{{97, 98, 99}, {100, 101, x}}]
    #> FromCharacterCode[{{97, 98, x}, {100, 101, x}}]
     : A character code, which should be a non-negative integer less than 65536, is expected at position 3 in {97, 98, x}.
     = FromCharacterCode[{{97, 98, x}, {100, 101, x}}]
    """

    messages = {
        'notunicode': (
            'A character code, which should be a non-negative integer less '
            'than 65536, is expected at position `2` in `1`.'),
        'intnm': (
            'Non-negative machine-sized integer expected at '
            'position `2` in `1`.'),
    }

    def apply(self, n, evaluation):
        "FromCharacterCode[n_]"
        exp = Expression('FromCharacterCode', n)
        pyn = n.to_python()

        def convert(pyn, encoding=None):
            if encoding is not None:
                raise NotImplementedError

            for i, pyni in enumerate(pyn):
                if not (isinstance(pyni, int) and 0 <= pyni <= 0xffff):
                    return evaluation.message(
                        'FromCharacterCode', 'notunicode', pyn, Integer(i + 1))

            return ''.join(unichr(pyni) for pyni in pyn)

        if isinstance(pyn, list):
            if pyn == []:
                string = ''
            elif all(isinstance(ni, list) for ni in pyn):
                string = []
                for pyni in pyn:
                    stringi = convert(pyni)
                    if stringi is None:
                        string = None
                        break
                    else:
                        string.append(stringi)
            else:
                string = convert(pyn)
        else:
            if not (isinstance(pyn, int) and pyn > 0):
                evaluation.message(
                    'FromCharacterCode', 'intnm', exp, Integer(1))
                return
            string = convert([pyn])

        if string is not None:
            return from_python(string)


class StringQ(Test):
    """
    <dl>
    <dt>'StringQ[$expr$]'
      <dd>returns 'True' if $expr$ is a 'String' or 'False' otherwise.
    </dl>

    >> StringQ["abc"]
     = True
    >> StringQ[1.5]
     = False
    >> Select[{"12", 1, 3, 5, "yz", x, y}, StringQ]
     = {12, yz}
    """

    def test(self, expr):
        return isinstance(expr, String)

########NEW FILE########
__FILENAME__ = structure
# -*- coding: utf8 -*-

from mathics.builtin.base import Builtin, Predefined, BinaryOperator, Test
from mathics.core.expression import Expression, String, Symbol, Integer
from mathics.core.rules import Pattern

from mathics.builtin.lists import (python_levelspec, walk_levels,
                                   InvalidLevelspecError)


class Sort(Builtin):
    """
    <dl>
    <dt>'Sort[$list$]'
    <dd>sorts $list$ (or the leaves of any other expression) according to canonical ordering.
    <dt>'Sort[$list$, $p$]'
    <dd>sorts using $p$ to determine the order of two elements.
    </dl>

    >> Sort[{4, 1.0, a, 3+I}]
     = {1., 3 + I, 4, a}

    Sort uses 'OrderedQ' to determine ordering by default.
    You can sort patterns according to their precedence using 'PatternsOrderedQ':
    >> Sort[{items___, item_, OptionsPattern[], item_symbol, item_?test}, PatternsOrderedQ]
     = {item_symbol, item_ ? test, item_, items___, OptionsPattern[]}

    When sorting patterns, values of atoms do not matter:
    >> Sort[{a, b/;t}, PatternsOrderedQ]
     = {b /; t, a}
    >> Sort[{2+c_, 1+b__}, PatternsOrderedQ]
     = {2 + c_, 1 + b__}
    >> Sort[{x_ + n_*y_, x_ + y_}, PatternsOrderedQ]
     = {x_ + n_ y_, x_ + y_}

    #> Sort[{x_, y_}, PatternsOrderedQ]
     = {x_, y_}

    ## Test ordering of monomials:
    #> a^2f+a b f
     = a ^ 2 f + a b f
    #> a^4 b^2 + e^3 b
     = a ^ 4 b ^ 2 + b e ^ 3
    #> Expand[(1+x)^3 y]
     = y + 3 x y + 3 x ^ 2 y + x ^ 3 y
    #> Expand[(x+y)^3]
     = x ^ 3 + 3 x ^ 2 y + 3 x y ^ 2 + y ^ 3
    #> y+x y^(1/2)
     = x Sqrt[y] + y
    ## Numeric parts:
    #> 1+Pi+Pi^2+Sin[9/4*Pi]+x+x^2+Sin[x+x^2]
     = 1 + Pi + Pi ^ 2 + Sqrt[2] / 2 + x + x ^ 2 + Sin[x + x ^ 2]
    """

    def apply(self, list, evaluation):
        'Sort[list_]'

        if list.is_atom():
            evaluation.message('Sort', 'normal')
        else:
            new_leaves = sorted(list.leaves)
            return Expression(list.head, *new_leaves)

    def apply_predicate(self, list, p, evaluation):
        'Sort[list_, p_]'

        if list.is_atom():
            evaluation.message('Sort', 'normal')
        else:
            def compare(e1, e2):
                result = Expression(p, e1, e2).evaluate(evaluation)
                if result.is_true():
                    result = Expression(p, e2, e1).evaluate(evaluation)
                    if result.is_true():
                        return 0
                    else:
                        return -1
                else:
                    return 1
            new_leaves = sorted(list.leaves, cmp=compare)
            return Expression(list.head, *new_leaves)


class PatternsOrderedQ(Builtin):
    """
    >> PatternsOrderedQ[x__, x_]
     = False
    >> PatternsOrderedQ[x_, x__]
     = True
    >> PatternsOrderedQ[b, a]
     = True
    """

    def apply(self, p1, p2, evaluation):
        'PatternsOrderedQ[p1_, p2_]'

        result = cmp(p1.get_sort_key(True), p2.get_sort_key(True))
        if result <= 0:
            return Symbol('True')
        else:
            return Symbol('False')


class OrderedQ(Builtin):
    """
    >> OrderedQ[a, b]
     = True
    >> OrderedQ[b, a]
     = False
    """

    def apply(self, e1, e2, evaluation):
        'OrderedQ[e1_, e2_]'

        result = cmp(e1, e2)
        if result <= 0:
            return Symbol('True')
        else:
            return Symbol('False')


class Head(Builtin):
    """
    >> Head[a * b]
     = Times
    >> Head[6]
     = Integer
    >> Head[x]
     = Symbol
    """

    def apply(self, expr, evaluation):
        'Head[expr_]'

        return expr.get_head()


class ApplyLevel(BinaryOperator):
    """
    <dl>
    <dt>'ApplyLevel[$f$, $expr$]' or '$f$ @@@ $expr$'
        <dd>is equivalent to 'Apply[$f$, $expr$, {1}]'.
    </dl>

    >> f @@@ {{a, b}, {c, d}}
     = {f[a, b], f[c, d]}
    """

    operator = '@@@'
    precedence = 620
    grouping = 'Right'

    rules = {
        'ApplyLevel[f_, expr_]': 'Apply[f, expr, {1}]',
    }


class Apply(BinaryOperator):
    u"""
    <dl>
    <dt>'Apply[$f$, $expr$]' or '$f$ @@ $expr$'
        <dd>replaces the head of $expr$ with $f$.
    <dt>'Apply[$f$, $expr$, $levelspec$]'
        <dd>applies $f$ on the parts specified by $levelspec$.
    </dl>

    >> f @@ {1, 2, 3}
     = f[1, 2, 3]
    >> Plus @@ {1, 2, 3}
     = 6

    The head of $expr$ need not be 'List':
    >> f @@ (a + b + c)
     = f[a, b, c]

    Apply on level 1:
    >> Apply[f, {a + b, g[c, d, e * f], 3}, {1}]
     = {f[a, b], f[c, d, e f], 3}
    The default level is 0:
    >> Apply[f, {a, b, c}, {0}]
     = f[a, b, c]

    Range of levels, including negative level (counting from bottom):
    >> Apply[f, {{{{{a}}}}}, {2, -3}]
     = {{f[f[{a}]]}}

    Convert all operations to lists:
    >> Apply[List, a + b * c ^ e * f[g], {0, Infinity}]
     = {a, {b, {c, e}, {g}}}

    #> Apply[f, {a, b, c}, x+y]
     : Level specification x + y is not of the form n, {n}, or {m, n}.
     = Apply[f, {a, b, c}, x + y]
    """

    operator = '@@'
    precedence = 620
    grouping = 'Right'

    options = {
        'Heads': 'False',
    }

    def apply_invalidlevel(self, f, expr, ls, evaluation, options={}):
        'Apply[f_, expr_, ls_, OptionsPattern[Apply]]'

        evaluation.message('Apply', 'level', ls)

    def apply(self, f, expr, ls, evaluation, options={}):
        '''Apply[f_, expr_, Optional[Pattern[ls, _?LevelQ], {0}],
                OptionsPattern[Apply]]'''

        try:
            start, stop = python_levelspec(ls)
        except InvalidLevelspecError:
            evaluation.message('Apply', 'level', ls)
            return

        def callback(level):
            if level.is_atom():
                return level
            else:
                return Expression(f, *level.leaves)

        heads = self.get_option(options, 'Heads', evaluation).is_true()
        result, depth = walk_levels(
            expr, start, stop, heads=heads, callback=callback)

        return result


class Map(BinaryOperator):
    """
    <dl>
    <dt>'Map[$f$, $expr$]' or '$f$ /@ $expr$'
        <dd>applies $f$ to each part on the first level of $expr$.
    <dt>'Map[$f$, $expr$, $levelspec$]'
        <dd>applies $f$ to each level specified by $levelspec$ of $expr$.
    </dl>

    >> f /@ {1, 2, 3}
     = {f[1], f[2], f[3]}
    >> #^2& /@ {1, 2, 3, 4}
     = {1, 4, 9, 16}

    Map $f$ on the second level:
    >> Map[f, {{a, b}, {c, d, e}}, {2}]
     = {{f[a], f[b]}, {f[c], f[d], f[e]}}

    Include heads:
    >> Map[f, a + b + c, Heads->True]
     = f[Plus][f[a], f[b], f[c]]

    #> Map[f, expr, a+b, Heads->True]
     : Level specification a + b is not of the form n, {n}, or {m, n}.
     = Map[f, expr, a + b, Heads -> True]
    """

    operator = '/@'
    precedence = 620
    grouping = 'Right'

    options = {
        'Heads': 'False',
    }

    def apply_invalidlevel(self, f, expr, ls, evaluation, options={}):
        'Map[f_, expr_, ls_, OptionsPattern[Map]]'

        evaluation.message('Map', 'level', ls)

    def apply_level(self, f, expr, ls, evaluation, options={}):
        '''Map[f_, expr_, Optional[Pattern[ls, _?LevelQ], {1}],
                OptionsPattern[Map]]'''

        try:
            start, stop = python_levelspec(ls)
        except InvalidLevelspecError:
            evaluation.message('Map', 'level', ls)
            return

        def callback(level):
            return Expression(f, level)

        heads = self.get_option(options, 'Heads', evaluation).is_true()
        result, depth = walk_levels(
            expr, start, stop, heads=heads, callback=callback)

        return result


class MapIndexed(Builtin):
    """
    <dl>
    <dt>'MapIndexed[$f$, $expr$]'
        <dd>applies $f$ to each part on the first level of $expr$, including the part positions
        in the call to $f$.
    <dt>'MapIndexed[$f$, $expr$, $levelspec$]'
        <dd>applies $f$ to each level specified by $levelspec$ of $expr$.
    </dl>

    >> MapIndexed[f, {a, b, c}]
     = {f[a, {1}], f[b, {2}], f[c, {3}]}

    Include heads (index 0):
    >> MapIndexed[f, {a, b, c}, Heads->True]
     = f[List, {0}][f[a, {1}], f[b, {2}], f[c, {3}]]

    Map on levels 0 through 1 (outer expression gets index '{}'):
    >> MapIndexed[f, a + b + c * d, {0, 1}]
     = f[f[a, {1}] + f[b, {2}] + f[c d, {3}], {}]

    Get the positions of atoms in an expression (convert operations to 'List' first
    to disable 'Listable' functions):
    >> expr = a + b * c ^ e * f[g];
    >> listified = Apply[List, expr, {0, Infinity}];
    >> MapIndexed[#2 &, listified, {-1}]
     = {{1}, {{2, 1}, {{2, 2, 1}, {2, 2, 2}}, {{2, 3, 1}}}}
    Replace the heads with their positions, too:
    >> MapIndexed[#2 &, listified, {-1}, Heads -> True]
     = {0}[{1}, {2, 0}[{2, 1}, {2, 2, 0}[{2, 2, 1}, {2, 2, 2}], {2, 3, 0}[{2, 3, 1}]]]
    The positions are given in the same format as used by 'Extract'.
    Thus, mapping 'Extract' on the indices given by 'MapIndexed' re-constructs the original expression:
    >> MapIndexed[Extract[expr, #2] &, listified, {-1}, Heads -> True]
     = a + b c ^ e f[g]

    #> MapIndexed[f, {1, 2}, a+b]
     : Level specification a + b is not of the form n, {n}, or {m, n}.
     = MapIndexed[f, {1, 2}, a + b]
    """

    options = {
        'Heads': 'False',
    }

    def apply_invalidlevel(self, f, expr, ls, evaluation, options={}):
        'MapIndexed[f_, expr_, ls_, OptionsPattern[MapIndexed]]'

        evaluation.message('MapIndexed', 'level', ls)

    def apply_level(self, f, expr, ls, evaluation, options={}):
        '''MapIndexed[f_, expr_, Optional[Pattern[ls, _?LevelQ], {1}],
                OptionsPattern[MapIndexed]]'''

        try:
            start, stop = python_levelspec(ls)
        except InvalidLevelspecError:
            evaluation.message('MapIndexed', 'level', ls)
            return

        def callback(level, pos):
            return Expression(f, level, Expression('List', *[
                Integer(p) for p in pos]))

        heads = self.get_option(options, 'Heads', evaluation).is_true()
        result, depth = walk_levels(expr, start, stop, heads=heads,
                                    callback=callback, include_pos=True)

        return result


class Thread(Builtin):
    """
    <dl>
    <dt>'Thread[$f$[$args$]]'
        <dd>threads $f$ over any lists that appear in $args$.
    <dt>'Thread[$f$[$args$], $h$]'
        <dd>threads over any parts with head $h$.
    </dl>

    >> Thread[f[{a, b, c}]]
     = {f[a], f[b], f[c]}
    >> Thread[f[{a, b, c}, t]]
     = {f[a, t], f[b, t], f[c, t]}
    >> Thread[f[a + b + c], Plus]
     = f[a] + f[b] + f[c]

    Functions with attribute 'Listable' are automatically threaded over lists:
    >> {a, b, c} + {d, e, f} + g
     = {a + d + g, b + e + g, c + f + g}
    """

    messages = {
        'tdlen': "Objects of unequal length cannot be combined.",
    }

    rules = {
        'Thread[f_[args___]]': 'Thread[f[args], List]',
    }

    def apply(self, f, args, h, evaluation):
        'Thread[f_[args___], h_]'

        args = args.get_sequence()
        expr = Expression(f, *args)
        threaded, result = expr.thread(evaluation, head=h)
        return result


class FreeQ(Builtin):
    """
    >> FreeQ[y, x]
     = True
    >> FreeQ[a+b+c, a+b]
     = False
    >> FreeQ[{1, 2, a^(a+b)}, Plus]
     = False
    >> FreeQ[a+b, x_+y_+z_]
     = True
    >> FreeQ[a+b+c, x_+y_+z_]
     = False
    """

    def apply(self, expr, form, evaluation):
        'FreeQ[expr_, form_]'

        form = Pattern.create(form)
        if expr.is_free(form, evaluation):
            return Symbol('True')
        else:
            return Symbol('False')


class Flatten(Builtin):
    """
    <dl>
    <dt>'Flatten[$expr$]'
        <dd>flattens out nested lists in $expr$.
    <dt>'Flatten[$expr$, $n$]'
        <dd>stops flattening at level $n$.
    <dt>'Flatten[$expr$, $n$, $h$]'
        <dd>flattens expressions with head $h$ instead of 'List'.
    </dl>
    >> Flatten[{{a, b}, {c, {d}, e}, {f, {g, h}}}]
     = {a, b, c, d, e, f, g, h}
    >> Flatten[{{a, b}, {c, {e}, e}, {f, {g, h}}}, 1]
     = {a, b, c, {e}, e, f, {g, h}}
    >> Flatten[f[a, f[b, f[c, d]], e], Infinity, f]
     = f[a, b, c, d, e]
    """

    rules = {
        'Flatten[expr_]': 'Flatten[expr, Infinity, List]',
        'Flatten[expr_, n_]': 'Flatten[expr, n, List]',
    }

    messages = {
        'flpi': (
            "Level to be flattened together in `1` "
            "should be a non-negative integer."),
    }

    def apply(self, expr, n, h, evaluation):
        'Flatten[expr_, n_, h_]'

        if n == Expression('DirectedInfinity', 1):
            n = None
        else:
            n_int = n.get_int_value()
            if n_int is None or n_int < 0:
                return evaluation.message('Flatten', 'flpi', n)
            n = n_int

        return expr.flatten(h, level=n)


class Null(Predefined):
    """
    'Null' is the implicit result of expressions that do not yield a result:
    >> FullForm[a:=b]
     = Null

    It is not displayed in StandardForm,
    >> a:=b
    in contrast to the empty string:
    >> ""
     = 
    (watch the empty line).
    """


class AtomQ(Test):
    """
    >> AtomQ[x]
     = True
    >> AtomQ[1.2]
     = True
    >> AtomQ[2 + I]
     = True
    >> AtomQ[2 / 3]
     = True
    >> AtomQ[x + y]
     = False
    """

    def test(self, expr):
        return expr.is_atom()


class SymbolQ(Test):
    """
    >> SymbolQ[a]
     = True
    >> SymbolQ[1]
     = False
    >> SymbolQ[a + b]
     = False
    """

    def test(self, expr):
        return isinstance(expr, Symbol)


class Symbol_(Builtin):
    u"""
    'Symbol' is the head of symbols.
    >> Head[x]
     = Symbol
    You can use 'Symbol' to create symbols from strings:
    >> Symbol["x"] + Symbol["x"]
     = 2 x

    #> {\[Eta], \[CapitalGamma]\[Beta], Z\[Infinity], \[Angle]XYZ, \[FilledSquare]r, i\[Ellipsis]j}
     = {\u03b7, \u0393\u03b2, Z\u221e, \u2220XYZ, \u25a0r, i\u2026j}
    """

    name = 'Symbol'
    attributes = ('Locked',)

    messages = {
        'symname': ("The string `1` cannot be used for a symbol name. "
                    "A symbol name must start with a letter "
                    "followed by letters and numbers."),
    }

    def apply(self, string, evaluation):
        'Symbol[string_String]'

        from mathics.core.parser import is_symbol_name

        text = string.get_string_value()
        if is_symbol_name(text):
            return Symbol(string.value)
        else:
            evaluation.message('Symbol', 'symname', string)


class SymbolName(Builtin):
    """
    >> SymbolName[x] // InputForm
     = "x"
    """

    def apply(self, symbol, evaluation):
        'SymbolName[symbol_Symbol]'

        return String(symbol.get_name())


class Depth(Builtin):
    """
    <dl>
    <dt>'Depth[$expr$]'
    <dd>gives the depth of $expr$
    </dl>

    The depth of an expression is defined as one plus the maximum
    number of 'Part' indices required to reach any part of $expr$,
    except for heads.

    >> Depth[x]
     = 1
    >> Depth[x + y]
     = 2
    >> Depth[{{{{x}}}}]
     = 5

    Complex numbers are atomic, and hence have depth 1:
    >> Depth[1 + 2 I]
     = 1

    'Depth' ignores heads:
    >> Depth[f[a, b][c]]
     = 2
    """

    def apply(self, expr, evaluation):
        'Depth[expr_]'
        expr, depth = walk_levels(expr)
        return Integer(depth + 1)


class Operate(Builtin):
    """
    <dl>
    <dt>'Operate[$p$, $expr$]'
    <dd>applies $p$ to the head of $expr$.
    <dt>'Operate[$p$, $expr$, $n$]'
    <dd>applies $p$ to the $n$th head of $expr$.
    </dl>

    >> Operate[p, f[a, b]]
     = p[f][a, b]

    The default value of $n$ is 1:
    >> Operate[p, f[a, b], 1]
     = p[f][a, b]

    With $n$=0, 'Operate' acts like 'Apply':
    >> Operate[p, f[a][b][c], 0]
     = p[f[a][b][c]]

    #> Operate[p, f[a][b][c]]
     = p[f[a][b]][c]
    #> Operate[p, f[a][b][c], 1]
     = p[f[a][b]][c]
    #> Operate[p, f[a][b][c], 2]
     = p[f[a]][b][c]
    #> Operate[p, f[a][b][c], 3]
     = p[f][a][b][c]
    #> Operate[p, f[a][b][c], 4]
     = f[a][b][c]
    #> Operate[p, f]
     = f
    #> Operate[p, f, 0]
     = p[f]
    #> Operate[p, f, -1]
     : Non-negative integer expected at position 3 in Operate[p, f, -1].
     = Operate[p, f, -1]
    """

    messages = {
        'intnn': "Non-negative integer expected at position `2` in `1`.",
    }

    def apply(self, p, expr, n, evaluation):
        'Operate[p_, expr_, Optional[n_, 1]]'

        head_depth = n.get_int_value()
        if head_depth is None or head_depth < 0:
            return evaluation.message('Operate', 'intnn',
                                      Expression('Operate', p, expr, n), 3)

        if head_depth == 0:
            # Act like Apply
            return Expression(p, expr)

        if expr.is_atom():
            return expr

        expr = expr.copy()
        e = expr

        for i in range(1, head_depth):
            e = e.head
            if e.is_atom():
                # n is higher than the depth of heads in expr: return
                # expr unmodified.
                return expr

        # Otherwise, if we get here, e.head points to the head we need
        # to apply p to. Python's reference semantics mean that this
        # assignment modifies expr as well.
        e.head = Expression(p, e.head)

        return expr


class Through(Builtin):
    """
    <dl>
    <dt>'Through[$p$[$f$][$x$]]'
    <dd>gives $p$[$f$[$x$]].
    </dl>

    >> Through[f[g][x]]
     = f[g[x]]
    >> Through[p[f, g][x]]
     = p[f[x], g[x]]

    #> Through[p[f, g][x, y]]
     = p[f[x, y], g[x, y]]
    #> Through[p[f, g][]]
     = p[f[], g[]]
    #> Through[p[f, g]]
     = Through[p[f, g]]
    #> Through[f[][x]]
     = f[]
    """

    def apply(self, p, args, x, evaluation):
        'Through[p_[args___][x___]]'

        items = []
        for leaf in args.get_sequence():
            items.append(Expression(leaf, *x.get_sequence()))
        return Expression(p, *items)

########NEW FILE########
__FILENAME__ = system
# -*- coding: utf8 -*-

"""
System functions
"""

import re

from mathics.core.expression import Expression, String
from mathics.builtin.base import Builtin, Predefined
from mathics import get_version_string


class Version(Predefined):
    """
    <dl>
    <dt>'$Version'
        <dd>returns a string with the current Mathics version and the versions of relevant libraries.
    </dl>

    >> $Version
     = Mathics ...
    """

    name = '$Version'

    def evaluate(self, evaluation):
        return String(get_version_string(True))


class Names(Builtin):
    """
    <dl>
    <dt>'Names["$pattern$"]'
        <dd>returns the list of names matching $pattern$.
    </dl>

    >> Names["List"]
     = {List}
    >> Names["List*"]
     = {List, ListLinePlot, ListPlot, ListQ, Listable}
    >> Names["List@"]
     = {Listable}

    >> x = 5;
    >> Names["Global`*"]
     = {x}

    The number of built-in symbols:
    >> Length[Names["System`*"]]
     = ...

    #> Length[Names["System`*"]] > 350
     = True
    """

    def apply(self, pattern, evaluation):
        'Names[pattern_String]'

        pattern = pattern.get_string_value()
        if pattern is None:
            return

        if pattern.startswith('System`'):
            names = evaluation.definitions.get_builtin_names()
        elif pattern.startswith('Global`'):
            names = (evaluation.definitions.get_user_names() -
                     evaluation.definitions.get_builtin_names())
        else:
            names = evaluation.definitions.get_names()
        if '`' in pattern:
            pattern = pattern[pattern.find('`') + 1:]

        pattern = pattern.replace('@', '[a-z]+').replace('*', '.*')
        pattern = re.compile('^' + pattern + '$')

        def match_pattern(name):
            return pattern.match(name) is not None

        names = [name for name in names if match_pattern(name)]
        names.sort()

        return Expression('List', *[String(name) for name in names])

########NEW FILE########
__FILENAME__ = tensors
# -*- coding: utf8 -*-

"""
Tensor functions
"""

from mathics.builtin.base import Builtin, BinaryOperator
from mathics.core.expression import Expression, Symbol, Integer
from mathics.core.rules import Pattern

from mathics.builtin.lists import get_part


class ArrayQ(Builtin):
    """
    <dl>
    <dt>'ArrayQ[$expr$]'
        <dd>tests whether $expr$ is a full array.
    <dt>'ArrayQ[$expr$, $pattern$]'
        <dd>also tests whether the array depth of $expr$ matches $pattern$.
    <dt>'ArrayQ[$expr$, $pattern$, $test$]'</dt>
        <dd>furthermore tests whether $test$ yields 'True' for all elements of $expr$.
        'ArrayQ[$expr$]' is equivalent to 'ArrayQ[$expr$, _, True&]'.
    </dl>
    >> ArrayQ[a]
     = False
    >> ArrayQ[{a}]
     = True
    >> ArrayQ[{{{a}},{{b,c}}}]
     = False
    >> ArrayQ[{{a, b}, {c, d}}, 2, SymbolQ]
     = True
    """

    rules = {
        'ArrayQ[expr_]': 'ArrayQ[expr, _, True&]',
        'ArrayQ[expr_, pattern_]': 'ArrayQ[expr, pattern, True&]',
    }

    def apply(self, expr, pattern, test, evaluation):
        'ArrayQ[expr_, pattern_, test_]'

        pattern = Pattern.create(pattern)

        dims = [len(expr.get_leaves())]  # to ensure an atom is not an array

        def check(level, expr):
            if not expr.has_form('List', None):
                test_expr = Expression(test, expr)
                if test_expr.evaluate(evaluation) != Symbol('True'):
                    return False
                level_dim = None
            else:
                level_dim = len(expr.leaves)

            if len(dims) > level:
                if dims[level] != level_dim:
                    return False
            else:
                dims.append(level_dim)
            if level_dim is not None:
                for leaf in expr.leaves:
                    if not check(level + 1, leaf):
                        return False
            return True

        if not check(0, expr):
            return Symbol('False')

        depth = len(dims) - 1  # None doesn't count
        if not pattern.does_match(Integer(depth), evaluation):
            return Symbol('False')
        return Symbol('True')


class VectorQ(Builtin):
    """
    >> VectorQ[{a, b, c}]
     = True
    """

    rules = {
        'VectorQ[expr_]': 'ArrayQ[expr, 1]',
        'VectorQ[expr_, test_]': 'ArrayQ[expr, 1, test]',
    }


class MatrixQ(Builtin):
    """
    >> MatrixQ[{{1, 3}, {4.0, 3/2}}, NumberQ]
     = True
    """

    rules = {
        'MatrixQ[expr_]': 'ArrayQ[expr, 2]',
        'MatrixQ[expr_, test_]': 'ArrayQ[expr, 2, test]',
    }


def get_dimensions(expr, head=None):
    if expr.is_atom():
        return []
    else:
        if head is not None and not expr.head.same(head):
            return []
        sub_dim = None
        for leaf in expr.leaves:
            sub = get_dimensions(leaf, expr.head)
            if sub_dim is None:
                sub_dim = sub
            else:
                if sub_dim != sub:
                    sub = []
                    break
        return [len(expr.leaves)] + sub


class Dimensions(Builtin):
    """
    >> Dimensions[{a, b, c}]
     = {3}
    >> Dimensions[{{a, b}, {c, d}, {e, f}}]
     = {3, 2}

    Ragged arrays are not taken into account:
    >> Dimensions[{{a, b}, {b, c}, {c, d, e}}]
     = {3}

    The expression can have any head:
    >> Dimensions[f[f[a, b, c]]]
     = {1, 3}
    """

    def apply(self, expr, evaluation):
        'Dimensions[expr_]'

        return Expression('List', *[
            Integer(dim) for dim in get_dimensions(expr)])


class ArrayDepth(Builtin):
    """
    >> ArrayDepth[{{a,b},{c,d}}]
     = 2
    >> ArrayDepth[x]
     = 0
    """

    rules = {
        'ArrayDepth[list_]': 'Length[Dimensions[list]]',
    }


class Dot(BinaryOperator):
    """
    Scalar product of vectors:
    >> {a, b, c} . {x, y, z}
     = a x + b y + c z
    Product of matrices and vectors:
    >> {{a, b}, {c, d}} . {x, y}
     = {a x + b y, c x + d y}
    Matrix product:
    >> {{a, b}, {c, d}} . {{r, s}, {t, u}}
     = {{a r + b t, a s + b u}, {c r + d t, c s + d u}}
    >> a . b
     = a . b
    """

    operator = '.'
    precedence = 490
    attributes = ('Flat', 'OneIdentity')

    rules = {
        'Dot[a_List, b_List]': 'Inner[Times, a, b, Plus]',
    }


class Inner(Builtin):
    """
    >> Inner[f, {a, b}, {x, y}, g]
     = g[f[a, x], f[b, y]]

    The inner product of two boolean matrices:
    >> Inner[And, {{False, False}, {False, True}}, {{True, False}, {True, True}}, Or]
     = {{False, False}, {True, True}}

    Inner works with tensors of any depth:
    >> Inner[f, {{{a, b}}, {{c, d}}}, {{1}, {2}}, g]
     = {{{g[f[a, 1], f[b, 2]]}}, {{g[f[c, 1], f[d, 2]]}}}
    """

    rules = {
        'Inner[f_, list1_, list2_]': 'Inner[f, list1, list2, Plus]',
    }

    messages = {
        'incom': ("Length `1` of dimension `2` in `3` is incommensurate with "
                  "length `4` of dimension 1 in `5."),
    }

    def apply(self, f, list1, list2, g, evaluation):
        'Inner[f_, list1_, list2_, g_]'

        m = get_dimensions(list1)
        n = get_dimensions(list2)

        if not m or not n:
            evaluation.message('Inner', 'normal')
            return
        if list1.head != list2.head:
            evaluation.message('Inner', 'heads', list1.head, list2.head)
            return
        if m[-1] != n[0]:
            evaluation.message(
                'Inner', 'incom', m[-1], len(m), list1, n[0], list2)
            return

        head = list1.head
        inner_dim = n[0]

        def rec(i_cur, j_cur, i_rest, j_rest):
            evaluation.check_stopped()
            if i_rest:
                new = Expression(head)
                for i in xrange(1, i_rest[0] + 1):
                    new.leaves.append(
                        rec(i_cur + [i], j_cur, i_rest[1:], j_rest))
                return new
            elif j_rest:
                new = Expression(head)
                for j in xrange(1, j_rest[0] + 1):
                    new.leaves.append(
                        rec(i_cur, j_cur + [j], i_rest, j_rest[1:]))
                return new
            else:
                def summand(i):
                    return Expression(f, get_part(list1, i_cur + [i]),
                                      get_part(list2, [i] + j_cur))
                part = Expression(
                    g, *[summand(i) for i in xrange(1, inner_dim + 1)])
                # cur_expr.leaves.append(part)
                return part

        return rec([], [], m[:-1], n[1:])


class Outer(Builtin):
    """
    >> Outer[f, {a, b}, {1, 2, 3}]
     = {{f[a, 1], f[a, 2], f[a, 3]}, {f[b, 1], f[b, 2], f[b, 3]}}

    Outer product of two matrices:
    >> Outer[Times, {{a, b}, {c, d}}, {{1, 2}, {3, 4}}]
     = {{{{a, 2 a}, {3 a, 4 a}}, {{b, 2 b}, {3 b, 4 b}}}, {{{c, 2 c}, {3 c, 4 c}}, {{d, 2 d}, {3 d, 4 d}}}}

    'Outer' of multiple lists:
    >> Outer[f, {a, b}, {x, y, z}, {1, 2}]
     = {{{f[a, x, 1], f[a, x, 2]}, {f[a, y, 1], f[a, y, 2]}, {f[a, z, 1], f[a, z, 2]}}, {{f[b, x, 1], f[b, x, 2]}, {f[b, y, 1], f[b, y, 2]}, {f[b, z, 1], f[b, z, 2]}}}

    Arrays can be ragged:
    >> Outer[Times, {{1, 2}}, {{a, b}, {c, d, e}}]
     = {{{{a, b}, {c, d, e}}, {{2 a, 2 b}, {2 c, 2 d, 2 e}}}}

    Word combinations:
    >> Outer[StringJoin, {"", "re", "un"}, {"cover", "draw", "wind"}, {"", "ing", "s"}] // InputForm
     = {{{"cover", "covering", "covers"}, {"draw", "drawing", "draws"}, {"wind", "winding", "winds"}}, {{"recover", "recovering", "recovers"}, {"redraw", "redrawing", "redraws"}, {"rewind", "rewinding", "rewinds"}}, {{"uncover", "uncovering", "uncovers"}, {"undraw", "undrawing", "undraws"}, {"unwind", "unwinding", "unwinds"}}}

    Compositions of trigonometric functions:
    >> trigs = Outer[Composition, {Sin, Cos, Tan}, {ArcSin, ArcCos, ArcTan}]
     = {{Composition[Sin, ArcSin], Composition[Sin, ArcCos], Composition[Sin, ArcTan]}, {Composition[Cos, ArcSin], Composition[Cos, ArcCos], Composition[Cos, ArcTan]}, {Composition[Tan, ArcSin], Composition[Tan, ArcCos], Composition[Tan, ArcTan]}}
    Evaluate at 0:
    >> Map[#[0] &, trigs, {2}]
     = {{0, 1, 0}, {1, 0, 1}, {0, ComplexInfinity, 0}}
    """

    def apply(self, f, lists, evaluation):
        'Outer[f_, lists__]'

        lists = lists.get_sequence()
        head = None
        for list in lists:
            if list.is_atom():
                evaluation.message('Outer', 'normal')
                return
            if head is None:
                head = list.head
            elif not list.head.same(head):
                evaluation.message('Outer', 'heads', head, list.head)
                return

        def rec(item, rest_lists, current):
            evaluation.check_stopped()
            if item.is_atom() or not item.head.same(head):
                if rest_lists:
                    return rec(rest_lists[0], rest_lists[1:], current + [item])
                else:
                    return Expression(f, *(current + [item]))
            else:
                leaves = []
                for leaf in item.leaves:
                    leaves.append(rec(leaf, rest_lists, current))
                return Expression(head, *leaves)

        return rec(lists[0], lists[1:], [])


class Transpose(Builtin):
    """
    <dl>
    <dt>'Tranpose[$m$]'
        <dd>transposes rows and columns in the matrix $m$.
    </dl>

    >> Transpose[{{1, 2, 3}, {4, 5, 6}}]
     = {{1, 4}, {2, 5}, {3, 6}}
    >> MatrixForm[%]
     = 1   4
     .
     . 2   5
     .
     . 3   6

    #> Transpose[x]
     = Transpose[x]
    """

    def apply(self, m, evaluation):
        'Transpose[m_?MatrixQ]'

        result = []
        for row_index, row in enumerate(m.leaves):
            for col_index, item in enumerate(row.leaves):
                if row_index == 0:
                    result.append([item])
                else:
                    result[col_index].append(item)
        return Expression('List', *[Expression('List', *row)
                                    for row in result])


class DiagonalMatrix(Builtin):
    """
    <dl>
    <dt>'DiagonalMatrix[$list$]'
        <dd>gives a matrix with the values in $list$ on its diagonal and zeroes elsewhere.
    </dl>

    >> DiagonalMatrix[{1, 2, 3}]
     = {{1, 0, 0}, {0, 2, 0}, {0, 0, 3}}
    >> MatrixForm[%]
     = 1   0   0
     .
     . 0   2   0
     .
     . 0   0   3

    #> DiagonalMatrix[a + b]
     = DiagonalMatrix[a + b]
    """

    def apply(self, list, evaluation):
        'DiagonalMatrix[list_List]'

        result = []
        n = len(list.leaves)
        for index, item in enumerate(list.leaves):
            row = [Integer(0)] * n
            row[index] = item
            result.append(Expression('List', *row))
        return Expression('List', *result)


class IdentityMatrix(Builtin):
    """
    <dl>
    <dt>'IdentityMatrix[$n$]'
        <dd>gives the identity matrix with $n$ rows and columns.
    </dl>

    >> IdentityMatrix[3]
     = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}}
    """

    rules = {
        'IdentityMatrix[n_Integer]': 'DiagonalMatrix[Table[1, {n}]]',
    }

########NEW FILE########
__FILENAME__ = characters
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011 Jan Pöschko

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation either version 3 of the License or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not see <http://www.gnu.org/licenses/>.
"""

# Character ranges of letters
letters = u'a-zA-Z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u0103\u0106\u0107\
\u010c-\u010f\u0112-\u0115\u011a-\u012d\u0131\u0141\u0142\u0147\u0148\
\u0150-\u0153\u0158-\u0161\u0164\u0165\u016e-\u0171\u017d\u017e\
\u0391-\u03a1\u03a3-\u03a9\u03b1-\u03c9\u03d1\u03d2\u03d5\u03d6\
\u03da-\u03e1\u03f0\u03f1\u03f5\u210a-\u210c\u2110-\u2113\u211b\u211c\
\u2128\u212c\u212d\u212f-\u2131\u2133-\u2138\uf6b2-\uf6b5\uf6b7\uf6b9\
\uf6ba-\uf6bc\uf6be\uf6bf\uf6c1-\uf700\uf730\uf731\uf770\uf772\uf773\
\uf776\uf779\uf77a\uf77d-\uf780\uf782-\uf78b\uf78d-\uf78f\uf790\
\uf793-\uf79a\uf79c-\uf7a2\uf7a4-\uf7bd\uf800-\uf833\ufb01\ufb02'

# Character ranges of letterlikes
letterlikes = u'\u0024\u00A1\u00A2\u00A3\u00A5\u00A7\u00A9\u00AB\u00AE\
\u00B0\u00B5\u00B6\u00B8\u00BB\u00BF\u02C7\u02D8\u2013\u2014\u2020\u2021\
\u2022\u2026\u2032\u2033\u2035\u2036\u2060\u20AC\u210F\u2122\u2127\u212B\
\u21B5\u2205\u221E\u221F\u2220\u2221\u2222\u22EE\u22EF\u22F0\u22F1\u2300\
\u2318\u231A\u23B4\u23B5\u2500\u2502\u25A0\u25A1\u25AA\u25AE\u25AF\u25B2\
\u25B3\u25BC\u25BD\u25C0\u25C6\u25C7\u25CB\u25CF\u25E6\u25FB\u25FC\u2605\
\u2639\u263A\u2660\u2661\u2662\u2663\u266D\u266E\u266F\u2736\uF3A0\uF3B8\
\uF3B9\uF527\uF528\uF720\uF721\uF722\uF723\uF725\uF749\uF74A\uF74D\uF74E\
\uF74F\uF750\uF751\uF752\uF753\uF754\uF755\uF756\uF757\uF760\uF763\uF766\
\uF768\uF769\uF76A\uF76B\uF76C\uF7D4\uF800\uF801\uF802\uF803\uF804\uF805\
\uF806\uF807\uF808\uF809\uF80A\uF80B\uF80C\uF80D\uF80E\uF80F\uF810\uF811\
\uF812\uF813\uF814\uF815\uF816\uF817\uF818\uF819\uF81A\uF81B\uF81C\uF81D\
\uF81E\uF81F\uF820\uF821\uF822\uF823\uF824\uF825\uF826\uF827\uF828\uF829\
\uF82A\uF82B\uF82C\uF82D\uF82E\uF82F\uF830\uF831\uF832\uF833\uFE35\uFE36\
\uFE37\uFE38'

# All supported longname characters
named_characters = {
    'AAcute': u'\u00E1',
    'ABar': u'\u0101',
    'ACup': u'\u0103',
    'ADoubleDot': u'\u00E4',
    'AE': u'\u00E6',
    'AGrave': u'\u00E0',
    'AHat': u'\u00E2',
    'Aleph': u'\u2135',
    'AliasDelimiter': u'\uF764',
    'AliasIndicator': u'\uF768',
    'AlignmentMarker': u'\uF760',
    'Alpha': u'\u03B1',
    'AltKey': u'\uF7D1',
    'And': u'\u2227',
    'Angle': u'\u2220',
    'Angstrom': u'\u212B',
    'ARing': u'\u00E5',
    'AscendingEllipsis': u'\u22F0',
    'ATilde': u'\u00E3',
    'AutoLeftMatch': u'\uF3A8',
    'AutoOperand': u'\uF3AE',
    'AutoPlaceholder': u'\uF3A4',
    'AutoRightMatch': u'\uF3A9',
    'AutoSpace': u'\uF3AD',
    'Backslash': u'\u2216',
    'BeamedEighthNote': u'\u266B',
    'BeamedSixteenthNote': u'\u266C',
    'Because': u'\u2235',
    'Bet': u'\u2136',
    'Beta': u'\u03B2',
    'BlackBishop': u'\u265D',
    'BlackKing': u'\u265A',
    'BlackKnight': u'\u265E',
    'BlackPawn': u'\u265F',
    'BlackQueen': u'\u265B',
    'BlackRook': u'\u265C',
    'Breve': u'\u02D8',
    'Bullet': u'\u2022',
    'CAcute': u'\u0107',
    'CapitalAAcute': u'\u00C1',
    'CapitalABar': u'\u0100',
    'CapitalACup': u'\u0102',
    'CapitalADoubleDot': u'\u00C4',
    'CapitalAE': u'\u00C6',
    'CapitalAGrave': u'\u00C0',
    'CapitalAHat': u'\u00C2',
    'CapitalAlpha': u'\u0391',
    'CapitalARing': u'\u00C5',
    'CapitalATilde': u'\u00C3',
    'CapitalBeta': u'\u0392',
    'CapitalCAcute': u'\u0106',
    'CapitalCCedilla': u'\u00C7',
    'CapitalCHacek': u'\u010C',
    'CapitalChi': u'\u03A7',
    'CapitalDelta': u'\u0394',
    'CapitalDHacek': u'\u010E',
    'CapitalDifferentialD': u'\uF74B',
    'CapitalDigamma': u'\u03DC',
    'CapitalEAcute': u'\u00C9',
    'CapitalEBar': u'\u0112',
    'CapitalECup': u'\u0114',
    'CapitalEDoubleDot': u'\u00CB',
    'CapitalEGrave': u'\u00C8',
    'CapitalEHacek': u'\u011A',
    'CapitalEHat': u'\u00CA',
    'CapitalEpsilon': u'\u0395',
    'CapitalEta': u'\u0397',
    'CapitalEth': u'\u00D0',
    'CapitalGamma': u'\u0393',
    'CapitalIAcute': u'\u00CD',
    'CapitalICup': u'\u012C',
    'CapitalIDoubleDot': u'\u00CF',
    'CapitalIGrave': u'\u00CC',
    'CapitalIHat': u'\u00CE',
    'CapitalIota': u'\u0399',
    'CapitalKappa': u'\u039A',
    'CapitalKoppa': u'\u03DE',
    'CapitalLambda': u'\u039B',
    'CapitalLSlash': u'\u0141',
    'CapitalMu': u'\u039C',
    'CapitalNHacek': u'\u0147',
    'CapitalNTilde': u'\u00D1',
    'CapitalNu': u'\u039D',
    'CapitalOAcute': u'\u00D3',
    'CapitalODoubleAcute': u'\u0150',
    'CapitalODoubleDot': u'\u00D6',
    'CapitalOE': u'\u0152',
    'CapitalOGrave': u'\u00D2',
    'CapitalOHat': u'\u00D4',
    'CapitalOmega': u'\u03A9',
    'CapitalOmicron': u'\u039F',
    'CapitalOSlash': u'\u00D8',
    'CapitalOTilde': u'\u00D5',
    'CapitalPhi': u'\u03A6',
    'CapitalPi': u'\u03A0',
    'CapitalPsi': u'\u03A8',
    'CapitalRHacek': u'\u0158',
    'CapitalRho': u'\u03A1',
    'CapitalSampi': u'\u03E0',
    'CapitalSHacek': u'\u0160',
    'CapitalSigma': u'\u03A3',
    'CapitalStigma': u'\u03DA',
    'CapitalTau': u'\u03A4',
    'CapitalTHacek': u'\u0164',
    'CapitalTheta': u'\u0398',
    'CapitalThorn': u'\u00DE',
    'CapitalUAcute': u'\u00DA',
    'CapitalUDoubleAcute': u'\u0170',
    'CapitalUDoubleDot': u'\u00DC',
    'CapitalUGrave': u'\u00D9',
    'CapitalUHat': u'\u00DB',
    'CapitalUpsilon': u'\u03A5',
    'CapitalURing': u'\u016E',
    'CapitalXi': u'\u039E',
    'CapitalYAcute': u'\u00DD',
    'CapitalZeta': u'\u0396',
    'CapitalZHacek': u'\u017D',
    'Cap': u'\u2322',
    'CCedilla': u'\u00E7',
    'Cedilla': u'\u00B8',
    'CenterDot': u'\u00B7',
    'CenterEllipsis': u'\u22EF',
    'Cent': u'\u00A2',
    'CHacek': u'\u010D',
    'Checkmark': u'\u2713',
    'Chi': u'\u03C7',
    'CircleDot': u'\u2299',
    'CircleMinus': u'\u2296',
    'CirclePlus': u'\u2295',
    'CircleTimes': u'\u2297',
    'ClockwiseContourIntegral': u'\u2232',
    'CloseCurlyDoubleQuote': u'\u201D',
    'CloseCurlyQuote': u'\u2019',
    'CloverLeaf': u'\u2318',
    'ClubSuit': u'\u2663',
    'Colon': u'\u2236',
    'CommandKey': u'\uF76A',
    'Congruent': u'\u2261',
    'Conjugate': u'\uF3C8',
    'ConjugateTranspose': u'\uF3C9',
    'ConstantC': u'\uF7DA',
    'Continuation': u'\uF3B1',
    'ContourIntegral': u'\u222E',
    'ControlKey': u'\uF763',
    'Coproduct': u'\u2210',
    'Copyright': u'\u00A9',
    'CounterClockwiseContourIntegral': u'\u2233',
    'Cross': u'\uF4A0',
    'CupCap': u'\u224D',
    'Cup': u'\u2323',
    'CurlyCapitalUpsilon': u'\u03D2',
    'CurlyEpsilon': u'\u03B5',
    'CurlyKappa': u'\u03F0',
    'CurlyPhi': u'\u03C6',
    'CurlyPi': u'\u03D6',
    'CurlyRho': u'\u03F1',
    'CurlyTheta': u'\u03D1',
    'Currency': u'\u00A4',
    'Dagger': u'\u2020',
    'Dalet': u'\u2138',
    'Dash': u'\u2013',
    'Degree': u'\u00B0',
    'DeleteKey': u'\uF7D0',
    'Del': u'\u2207',
    'Delta': u'\u03B4',
    'DescendingEllipsis': u'\u22F1',
    'DHacek': u'\u010F',
    'Diameter': u'\u2300',
    'Diamond': u'\u22C4',
    'DiamondSuit': u'\u2662',
    'DifferenceDelta': u'\u2206',
    'DifferentialD': u'\uF74C',
    'Digamma': u'\u03DD',
    'DiscreteRatio': u'\uF4A4',
    'DiscreteShift': u'\uF4A3',
    'DiscretionaryHyphen': u'\u00AD',
    'DiscretionaryLineSeparator': u'\uF76E',
    'DiscretionaryParagraphSeparator': u'\uF76F',
    'Divide': u'\u00F7',
    'DotEqual': u'\u2250',
    'DotlessI': u'\u0131',
    'DotlessJ': u'\uF700',
    'DottedSquare': u'\uF751',
    'DoubleContourIntegral': u'\u222F',
    'DoubleDagger': u'\u2021',
    'DoubledGamma': u'\uF74A',
    'DoubleDownArrow': u'\u21D3',
    'DoubledPi': u'\uF749',
    'DoubleLeftArrow': u'\u21D0',
    'DoubleLeftRightArrow': u'\u21D4',
    'DoubleLeftTee': u'\u2AE4',
    'DoubleLongLeftArrow': u'\u27F8',
    'DoubleLongLeftRightArrow': u'\u27FA',
    'DoubleLongRightArrow': u'\u27F9',
    'DoublePrime': u'\u2033',
    'DoubleRightArrow': u'\u21D2',
    'DoubleRightTee': u'\u22A8',
    'DoubleStruckA': u'\uF6E6',
    'DoubleStruckB': u'\uF6E7',
    'DoubleStruckC': u'\uF6E8',
    'DoubleStruckCapitalA': u'\uF7A4',
    'DoubleStruckCapitalB': u'\uF7A5',
    'DoubleStruckCapitalC': u'\uF7A6',
    'DoubleStruckCapitalD': u'\uF7A7',
    'DoubleStruckCapitalE': u'\uF7A8',
    'DoubleStruckCapitalF': u'\uF7A9',
    'DoubleStruckCapitalG': u'\uF7AA',
    'DoubleStruckCapitalH': u'\uF7AB',
    'DoubleStruckCapitalI': u'\uF7AC',
    'DoubleStruckCapitalJ': u'\uF7AD',
    'DoubleStruckCapitalK': u'\uF7AE',
    'DoubleStruckCapitalL': u'\uF7AF',
    'DoubleStruckCapitalM': u'\uF7B0',
    'DoubleStruckCapitalN': u'\uF7B1',
    'DoubleStruckCapitalO': u'\uF7B2',
    'DoubleStruckCapitalP': u'\uF7B3',
    'DoubleStruckCapitalQ': u'\uF7B4',
    'DoubleStruckCapitalR': u'\uF7B5',
    'DoubleStruckCapitalS': u'\uF7B6',
    'DoubleStruckCapitalT': u'\uF7B7',
    'DoubleStruckCapitalU': u'\uF7B8',
    'DoubleStruckCapitalV': u'\uF7B9',
    'DoubleStruckCapitalW': u'\uF7BA',
    'DoubleStruckCapitalX': u'\uF7BB',
    'DoubleStruckCapitalY': u'\uF7BC',
    'DoubleStruckCapitalZ': u'\uF7BD',
    'DoubleStruckD': u'\uF6E9',
    'DoubleStruckE': u'\uF6EA',
    'DoubleStruckEight': u'\uF7E3',
    'DoubleStruckF': u'\uF6EB',
    'DoubleStruckFive': u'\uF7E0',
    'DoubleStruckFour': u'\uF7DF',
    'DoubleStruckG': u'\uF6EC',
    'DoubleStruckH': u'\uF6ED',
    'DoubleStruckI': u'\uF6EE',
    'DoubleStruckJ': u'\uF6EF',
    'DoubleStruckK': u'\uF6F0',
    'DoubleStruckL': u'\uF6F1',
    'DoubleStruckM': u'\uF6F2',
    'DoubleStruckN': u'\uF6F3',
    'DoubleStruckNine': u'\uF7E4',
    'DoubleStruckO': u'\uF6F4',
    'DoubleStruckOne': u'\uF7DC',
    'DoubleStruckP': u'\uF6F5',
    'DoubleStruckQ': u'\uF6F6',
    'DoubleStruckR': u'\uF6F7',
    'DoubleStruckS': u'\uF6F8',
    'DoubleStruckSeven': u'\uF7E2',
    'DoubleStruckSix': u'\uF7E1',
    'DoubleStruckT': u'\uF6F9',
    'DoubleStruckThree': u'\uF7DE',
    'DoubleStruckTwo': u'\uF7DD',
    'DoubleStruckU': u'\uF6FA',
    'DoubleStruckV': u'\uF6FB',
    'DoubleStruckW': u'\uF6FC',
    'DoubleStruckX': u'\uF6FD',
    'DoubleStruckY': u'\uF6FE',
    'DoubleStruckZ': u'\uF6FF',
    'DoubleStruckZero': u'\uF7DB',
    'DoubleUpArrow': u'\u21D1',
    'DoubleUpDownArrow': u'\u21D5',
    'DoubleVerticalBar': u'\u2225',
    'DownArrowBar': u'\u2913',
    'DownArrow': u'\u2193',
    'DownArrowUpArrow': u'\u21F5',
    'DownBreve': u'\uF755',
    'DownExclamation': u'\u00A1',
    'DownLeftRightVector': u'\u2950',
    'DownLeftTeeVector': u'\u295E',
    'DownLeftVector': u'\u21BD',
    'DownLeftVectorBar': u'\u2956',
    'DownPointer': u'\u25BE',
    'DownQuestion': u'\u00BF',
    'DownRightTeeVector': u'\u295F',
    'DownRightVector': u'\u21C1',
    'DownRightVectorBar': u'\u2957',
    'DownTeeArrow': u'\u21A7',
    'DownTee': u'\u22A4',
    'EAcute': u'\u00E9',
    'Earth': u'\u2641',
    'EBar': u'\u0113',
    'ECup': u'\u0115',
    'EDoubleDot': u'\u00EB',
    'EGrave': u'\u00E8',
    'EHacek': u'\u011B',
    'EHat': u'\u00EA',
    'EighthNote': u'\u266A',
    'Element': u'\u2208',
    'Ellipsis': u'\u2026',
    'EmptyCircle': u'\u25CB',
    'EmptyDiamond': u'\u25C7',
    'EmptyDownTriangle': u'\u25BD',
    'EmptyRectangle': u'\u25AF',
    'EmptySet': u'\u2205',
    'EmptySmallCircle': u'\u25E6',
    'EmptySmallSquare': u'\u25FB',
    'EmptySquare': u'\u25A1',
    'EmptyUpTriangle': u'\u25B3',
    'EmptyVerySmallSquare': u'\u25AB',
    'EnterKey': u'\uF7D4',
    'EntityEnd': u'\uF3B9',
    'EntityStart': u'\uF3B8',
    'Epsilon': u'\u03F5',
    'Equal': u'\uF431',
    'EqualTilde': u'\u2242',
    'Equilibrium': u'\u21CC',
    'Equivalent': u'\u29E6',
    'ErrorIndicator': u'\uF767',
    'EscapeKey': u'\uF769',
    'Eta': u'\u03B7',
    'Eth': u'\u00F0',
    'Euro': u'\u20AC',
    'Exists': u'\u2203',
    'ExponentialE': u'\uF74D',
    'FiLigature': u'\uFB01',
    'FilledCircle': u'\u25CF',
    'FilledDiamond': u'\u25C6',
    'FilledDownTriangle': u'\u25BC',
    'FilledLeftTriangle': u'\u25C0',
    'FilledRectangle': u'\u25AE',
    'FilledRightTriangle': u'\u25B6',
    'FilledSmallCircle': u'\uF750',
    'FilledSmallSquare': u'\u25FC',
    'FilledSquare': u'\u25A0',
    'FilledUpTriangle': u'\u25B2',
    'FilledVerySmallSquare': u'\u25AA',
    'FinalSigma': u'\u03C2',
    'FirstPage': u'\uF7FA',
    'FivePointedStar': u'\u2605',
    'Flat': u'\u266D',
    'FlLigature': u'\uFB02',
    'Florin': u'\u0192',
    'ForAll': u'\u2200',
    'FormalA': u'\uF800',
    'FormalB': u'\uF801',
    'FormalC': u'\uF802',
    'FormalCapitalA': u'\uF81A',
    'FormalCapitalB': u'\uF81B',
    'FormalCapitalC': u'\uF81C',
    'FormalCapitalD': u'\uF81D',
    'FormalCapitalE': u'\uF81E',
    'FormalCapitalF': u'\uF81F',
    'FormalCapitalG': u'\uF820',
    'FormalCapitalH': u'\uF821',
    'FormalCapitalI': u'\uF822',
    'FormalCapitalJ': u'\uF823',
    'FormalCapitalK': u'\uF824',
    'FormalCapitalL': u'\uF825',
    'FormalCapitalM': u'\uF826',
    'FormalCapitalN': u'\uF827',
    'FormalCapitalO': u'\uF828',
    'FormalCapitalP': u'\uF829',
    'FormalCapitalQ': u'\uF82A',
    'FormalCapitalR': u'\uF82B',
    'FormalCapitalS': u'\uF82C',
    'FormalCapitalT': u'\uF82D',
    'FormalCapitalU': u'\uF82E',
    'FormalCapitalV': u'\uF82F',
    'FormalCapitalW': u'\uF830',
    'FormalCapitalX': u'\uF831',
    'FormalCapitalY': u'\uF832',
    'FormalCapitalZ': u'\uF833',
    'FormalD': u'\uF803',
    'FormalE': u'\uF804',
    'FormalF': u'\uF805',
    'FormalG': u'\uF806',
    'FormalH': u'\uF807',
    'FormalI': u'\uF808',
    'FormalJ': u'\uF809',
    'FormalK': u'\uF80A',
    'FormalL': u'\uF80B',
    'FormalM': u'\uF80C',
    'FormalN': u'\uF80D',
    'FormalO': u'\uF80E',
    'FormalP': u'\uF80F',
    'FormalQ': u'\uF810',
    'FormalR': u'\uF811',
    'FormalS': u'\uF812',
    'FormalT': u'\uF813',
    'FormalU': u'\uF814',
    'FormalV': u'\uF815',
    'FormalW': u'\uF816',
    'FormalX': u'\uF817',
    'FormalY': u'\uF818',
    'FormalZ': u'\uF819',
    'FreakedSmiley': u'\uF721',
    'Function': u'\uF4A1',
    'Gamma': u'\u03B3',
    'Gimel': u'\u2137',
    'GothicA': u'\uF6CC',
    'GothicB': u'\uF6CD',
    'GothicC': u'\uF6CE',
    'GothicCapitalA': u'\uF78A',
    'GothicCapitalB': u'\uF78B',
    'GothicCapitalC': u'\u212D',
    'GothicCapitalD': u'\uF78D',
    'GothicCapitalE': u'\uF78E',
    'GothicCapitalF': u'\uF78F',
    'GothicCapitalG': u'\uF790',
    'GothicCapitalH': u'\u210C',
    'GothicCapitalI': u'\u2111',
    'GothicCapitalJ': u'\uF793',
    'GothicCapitalK': u'\uF794',
    'GothicCapitalL': u'\uF795',
    'GothicCapitalM': u'\uF796',
    'GothicCapitalN': u'\uF797',
    'GothicCapitalO': u'\uF798',
    'GothicCapitalP': u'\uF799',
    'GothicCapitalQ': u'\uF79A',
    'GothicCapitalR': u'\u211C',
    'GothicCapitalS': u'\uF79C',
    'GothicCapitalT': u'\uF79D',
    'GothicCapitalU': u'\uF79E',
    'GothicCapitalV': u'\uF79F',
    'GothicCapitalW': u'\uF7A0',
    'GothicCapitalX': u'\uF7A1',
    'GothicCapitalY': u'\uF7A2',
    'GothicCapitalZ': u'\u2128',
    'GothicD': u'\uF6CF',
    'GothicE': u'\uF6D0',
    'GothicEight': u'\uF7ED',
    'GothicF': u'\uF6D1',
    'GothicFive': u'\uF7EA',
    'GothicFour': u'\uF7E9',
    'GothicG': u'\uF6D2',
    'GothicH': u'\uF6D3',
    'GothicI': u'\uF6D4',
    'GothicJ': u'\uF6D5',
    'GothicK': u'\uF6D6',
    'GothicL': u'\uF6D7',
    'GothicM': u'\uF6D8',
    'GothicN': u'\uF6D9',
    'GothicNine': u'\uF7EF',
    'GothicO': u'\uF6DA',
    'GothicOne': u'\uF7E6',
    'GothicP': u'\uF6DB',
    'GothicQ': u'\uF6DC',
    'GothicR': u'\uF6DD',
    'GothicS': u'\uF6DE',
    'GothicSeven': u'\uF7EC',
    'GothicSix': u'\uF7EB',
    'GothicT': u'\uF6DF',
    'GothicThree': u'\uF7E8',
    'GothicTwo': u'\uF7E7',
    'GothicU': u'\uF6E0',
    'GothicV': u'\uF6E1',
    'GothicW': u'\uF6E2',
    'GothicX': u'\uF6E3',
    'GothicY': u'\uF6E4',
    'GothicZ': u'\uF6E5',
    'GothicZero': u'\uF7E5',
    'GrayCircle': u'\uF753',
    'GraySquare': u'\uF752',
    'GreaterEqualLess': u'\u22DB',
    'GreaterEqual': u'\u2265',
    'GreaterFullEqual': u'\u2267',
    'GreaterGreater': u'\u226B',
    'GreaterLess': u'\u2277',
    'GreaterSlantEqual': u'\u2A7E',
    'GreaterTilde': u'\u2273',
    'Hacek': u'\u02C7',
    'HappySmiley': u'\u263A',
    'HBar': u'\u210F',
    'HeartSuit': u'\u2661',
    'HermitianConjugate': u'\uF3CE',
    'HorizontalLine': u'\u2500',
    'HumpDownHump': u'\u224E',
    'HumpEqual': u'\u224F',
    'Hyphen': u'\u2010',
    'IAcute': u'\u00ED',
    'ICup': u'\u012D',
    'IDoubleDot': u'\u00EF',
    'IGrave': u'\u00EC',
    'IHat': u'\u00EE',
    'ImaginaryI': u'\uF74E',
    'ImaginaryJ': u'\uF74F',
    'ImplicitPlus': u'\uF39E',
    'Implies': u'\uF523',
    'Infinity': u'\u221E',
    'Integral': u'\u222B',
    'Intersection': u'\u22C2',
    'InvisibleApplication': u'\uF76D',
    'InvisibleComma': u'\uF765',
    'InvisiblePostfixScriptBase': u'\uF3B4',
    'InvisiblePrefixScriptBase': u'\uF3B3',
    'InvisibleSpace': u'\uF360',
    'InvisibleTimes': u'\u2062',
    'Iota': u'\u03B9',
    'Jupiter': u'\u2643',
    'Kappa': u'\u03BA',
    'KernelIcon': u'\uF756',
    'Koppa': u'\u03DF',
    'Lambda': u'\u03BB',
    'LastPage': u'\uF7FB',
    'LeftAngleBracket': u'\u2329',
    'LeftArrowBar': u'\u21E4',
    'LeftArrow': u'\u2190',
    'LeftArrowRightArrow': u'\u21C6',
    'LeftBracketingBar': u'\uF603',
    'LeftCeiling': u'\u2308',
    'LeftDoubleBracket': u'\u301A',
    'LeftDoubleBracketingBar': u'\uF605',
    'LeftDownTeeVector': u'\u2961',
    'LeftDownVectorBar': u'\u2959',
    'LeftDownVector': u'\u21C3',
    'LeftFloor': u'\u230A',
    'LeftGuillemet': u'\u00AB',
    'LeftModified': u'\uF76B',
    'LeftPointer': u'\u25C2',
    'LeftRightArrow': u'\u2194',
    'LeftRightVector': u'\u294E',
    'LeftSkeleton': u'\uF761',
    'LeftTee': u'\u22A3',
    'LeftTeeArrow': u'\u21A4',
    'LeftTeeVector': u'\u295A',
    'LeftTriangle': u'\u22B2',
    'LeftTriangleBar': u'\u29CF',
    'LeftTriangleEqual': u'\u22B4',
    'LeftUpDownVector': u'\u2951',
    'LeftUpTeeVector': u'\u2960',
    'LeftUpVector': u'\u21BF',
    'LeftUpVectorBar': u'\u2958',
    'LeftVector': u'\u21BC',
    'LeftVectorBar': u'\u2952',
    'LessEqual': u'\u2264',
    'LessEqualGreater': u'\u22DA',
    'LessFullEqual': u'\u2266',
    'LessGreater': u'\u2276',
    'LessLess': u'\u226A',
    'LessSlantEqual': u'\u2A7D',
    'LessTilde': u'\u2272',
    'LetterSpace': u'\uF754',
    'LightBulb': u'\uF723',
    'LongDash': u'\u2014',
    'LongEqual': u'\uF7D9',
    'LongLeftArrow': u'\u27F5',
    'LongLeftRightArrow': u'\u27F7',
    'LongRightArrow': u'\u27F6',
    'LowerLeftArrow': u'\u2199',
    'LowerRightArrow': u'\u2198',
    'LSlash': u'\u0142',
    'Mars': u'\u2642',
    'MathematicaIcon': u'\uF757',
    'MeasuredAngle': u'\u2221',
    'MediumSpace': u'\u205F',
    'Mercury': u'\u263F',
    'Mho': u'\u2127',
    'Micro': u'\u00B5',
    'MinusPlus': u'\u2213',
    'Mu': u'\u03BC',
    'Nand': u'\u22BC',
    'Natural': u'\u266E',
    'NegativeMediumSpace': u'\uF383',
    'NegativeThickSpace': u'\uF384',
    'NegativeThinSpace': u'\uF382',
    'NegativeVeryThinSpace': u'\uF380',
    'Neptune': u'\u2646',
    'NestedGreaterGreater': u'\u2AA2',
    'NestedLessLess': u'\u2AA1',
    'NeutralSmiley': u'\uF722',
    'NHacek': u'\u0148',
    'NoBreak': u'\u2060',
    'NonBreakingSpace': u'\u00A0',
    'Nor': u'\u22BD',
    'NotCongruent': u'\u2262',
    'NotCupCap': u'\u226D',
    'NotDoubleVerticalBar': u'\u2226',
    'NotElement': u'\u2209',
    'NotEqual': u'\u2260',
    'NotEqualTilde': u'\uF400',
    'NotExists': u'\u2204',
    'NotGreater': u'\u226F',
    'NotGreaterEqual': u'\u2271',
    'NotGreaterFullEqual': u'\u2269',
    'NotGreaterGreater': u'\uF427',
    'NotGreaterLess': u'\u2279',
    'NotGreaterSlantEqual': u'\uF429',
    'NotGreaterTilde': u'\u2275',
    'NotHumpDownHump': u'\uF402',
    'NotHumpEqual': u'\uF401',
    'NotLeftTriangle': u'\u22EA',
    'NotLeftTriangleBar': u'\uF412',
    'NotLeftTriangleEqual': u'\u22EC',
    'NotLessEqual': u'\u2270',
    'NotLessFullEqual': u'\u2268',
    'NotLessGreater': u'\u2278',
    'NotLess': u'\u226E',
    'NotLessLess': u'\uF422',
    'NotLessSlantEqual': u'\uF424',
    'NotLessTilde': u'\u2274',
    'Not': u'\u00AC',
    'NotNestedGreaterGreater': u'\uF428',
    'NotNestedLessLess': u'\uF423',
    'NotPrecedes': u'\u2280',
    'NotPrecedesEqual': u'\uF42B',
    'NotPrecedesSlantEqual': u'\u22E0',
    'NotPrecedesTilde': u'\u22E8',
    'NotReverseElement': u'\u220C',
    'NotRightTriangle': u'\u22EB',
    'NotRightTriangleBar': u'\uF413',
    'NotRightTriangleEqual': u'\u22ED',
    'NotSquareSubset': u'\uF42E',
    'NotSquareSubsetEqual': u'\u22E2',
    'NotSquareSuperset': u'\uF42F',
    'NotSquareSupersetEqual': u'\u22E3',
    'NotSubset': u'\u2284',
    'NotSubsetEqual': u'\u2288',
    'NotSucceeds': u'\u2281',
    'NotSucceedsEqual': u'\uF42D',
    'NotSucceedsSlantEqual': u'\u22E1',
    'NotSucceedsTilde': u'\u22E9',
    'NotSuperset': u'\u2285',
    'NotSupersetEqual': u'\u2289',
    'NotTilde': u'\u2241',
    'NotTildeEqual': u'\u2244',
    'NotTildeFullEqual': u'\u2247',
    'NotTildeTilde': u'\u2249',
    'NotVerticalBar': u'\u2224',
    'NTilde': u'\u00F1',
    'Nu': u'\u03BD',
    'Null': u'\uF3A0',
    'NumberSign': u'\uF724',
    'OAcute': u'\u00F3',
    'ODoubleAcute': u'\u0151',
    'ODoubleDot': u'\u00F6',
    'OE': u'\u0153',
    'OGrave': u'\u00F2',
    'OHat': u'\u00F4',
    'Omega': u'\u03C9',
    'Omicron': u'\u03BF',
    'OpenCurlyDoubleQuote': u'\u201C',
    'OpenCurlyQuote': u'\u2018',
    'OptionKey': u'\uF7D2',
    'Or': u'\u2228',
    'OSlash': u'\u00F8',
    'OTilde': u'\u00F5',
    'OverBrace': u'\uFE37',
    'OverBracket': u'\u23B4',
    'OverParenthesis': u'\uFE35',
    'Paragraph': u'\u00B6',
    'PartialD': u'\u2202',
    'Phi': u'\u03D5',
    'Pi': u'\u03C0',
    'Piecewise': u'\uF361',
    'Placeholder': u'\uF528',
    'PlusMinus': u'\u00B1',
    'Pluto': u'\u2647',
    'Precedes': u'\u227A',
    'PrecedesEqual': u'\u2AAF',
    'PrecedesSlantEqual': u'\u227C',
    'PrecedesTilde': u'\u227E',
    'Prime': u'\u2032',
    'Product': u'\u220F',
    'Proportion': u'\u2237',
    'Proportional': u'\u221D',
    'Psi': u'\u03C8',
    'QuarterNote': u'\u2669',
    'RawAmpersand': u'\u0026',
    'RawAt': u'\u0040',
    'RawBackquote': u'\u0060',
    'RawBackslash': u'\u005C',
    'RawColon': u'\u003A',
    'RawComma': u'\u002C',
    'RawDash': u'\u002D',
    'RawDollar': u'\u0024',
    'RawDot': u'\u002E',
    'RawDoubleQuote': u'\u0022',
    'RawEqual': u'\u003D',
    'RawEscape': u'\u001B',
    'RawExclamation': u'\u0021',
    'RawGreater': u'\u003E',
    'RawLeftBrace': u'\u007B',
    'RawLeftBracket': u'\u005B',
    'RawLeftParenthesis': u'\u0028',
    'RawLess': u'\u003C',
    'RawNumberSign': u'\u0023',
    'RawPercent': u'\u0025',
    'RawPlus': u'\u002B',
    'RawQuestion': u'\u003F',
    'RawQuote': u'\u0027',
    'RawRightBrace': u'\u007D',
    'RawRightBracket': u'\u005D',
    'RawRightParenthesis': u'\u0029',
    'RawSemicolon': u'\u003B',
    'RawSlash': u'\u002F',
    'RawSpace': u'\u0020',
    'RawStar': u'\u002A',
    'RawTab': u'\u0009',
    'RawTilde': u'\u007E',
    'RawUnderscore': u'\u005F',
    'RawVerticalBar': u'\u007C',
    'RawWedge': u'\u005E',
    'RegisteredTrademark': u'\u00AE',
    'ReturnIndicator': u'\u21B5',
    'ReturnKey': u'\uF766',
    'ReverseDoublePrime': u'\u2036',
    'ReverseElement': u'\u220B',
    'ReverseEquilibrium': u'\u21CB',
    'ReversePrime': u'\u2035',
    'ReverseUpEquilibrium': u'\u296F',
    'RHacek': u'\u0159',
    'Rho': u'\u03C1',
    'RightAngle': u'\u221F',
    'RightAngleBracket': u'\u232A',
    'RightArrow': u'\u2192',
    'RightArrowBar': u'\u21E5',
    'RightArrowLeftArrow': u'\u21C4',
    'RightBracketingBar': u'\uF604',
    'RightCeiling': u'\u2309',
    'RightDoubleBracket': u'\u301B',
    'RightDoubleBracketingBar': u'\uF606',
    'RightDownTeeVector': u'\u295D',
    'RightDownVector': u'\u21C2',
    'RightDownVectorBar': u'\u2955',
    'RightFloor': u'\u230B',
    'RightGuillemet': u'\u00BB',
    'RightModified': u'\uF76C',
    'RightPointer': u'\u25B8',
    'RightSkeleton': u'\uF762',
    'RightTee': u'\u22A2',
    'RightTeeArrow': u'\u21A6',
    'RightTeeVector': u'\u295B',
    'RightTriangle': u'\u22B3',
    'RightTriangleBar': u'\u29D0',
    'RightTriangleEqual': u'\u22B5',
    'RightUpDownVector': u'\u294F',
    'RightUpTeeVector': u'\u295C',
    'RightUpVector': u'\u21BE',
    'RightUpVectorBar': u'\u2954',
    'RightVector': u'\u21C0',
    'RightVectorBar': u'\u2953',
    'RoundImplies': u'\u2970',
    'RoundSpaceIndicator': u'\uF3B2',
    'Rule': u'\uF522',
    'RuleDelayed': u'\uF51F',
    'SadSmiley': u'\u2639',
    'Sampi': u'\u03E0',
    'Saturn': u'\u2644',
    'ScriptA': u'\uF6B2',
    'ScriptB': u'\uF6B3',
    'ScriptC': u'\uF6B4',
    'ScriptCapitalA': u'\uF770',
    'ScriptCapitalB': u'\u212C',
    'ScriptCapitalC': u'\uF772',
    'ScriptCapitalD': u'\uF773',
    'ScriptCapitalE': u'\u2130',
    'ScriptCapitalF': u'\u2131',
    'ScriptCapitalG': u'\uF776',
    'ScriptCapitalH': u'\u210B',
    'ScriptCapitalI': u'\u2110',
    'ScriptCapitalJ': u'\uF779',
    'ScriptCapitalK': u'\uF77A',
    'ScriptCapitalL': u'\u2112',
    'ScriptCapitalM': u'\u2133',
    'ScriptCapitalN': u'\uF77D',
    'ScriptCapitalO': u'\uF77E',
    'ScriptCapitalP': u'\u2118',
    'ScriptCapitalQ': u'\uF780',
    'ScriptCapitalR': u'\u211B',
    'ScriptCapitalS': u'\uF782',
    'ScriptCapitalT': u'\uF783',
    'ScriptCapitalU': u'\uF784',
    'ScriptCapitalV': u'\uF785',
    'ScriptCapitalW': u'\uF786',
    'ScriptCapitalX': u'\uF787',
    'ScriptCapitalY': u'\uF788',
    'ScriptCapitalZ': u'\uF789',
    'ScriptD': u'\uF6B5',
    'ScriptDotlessI': u'\uF730',
    'ScriptDotlessJ': u'\uF731',
    'ScriptE': u'\u212F',
    'ScriptEight': u'\uF7F8',
    'ScriptF': u'\uF6B7',
    'ScriptFive': u'\uF7F5',
    'ScriptFour': u'\uF7F4',
    'ScriptG': u'\u210A',
    'ScriptH': u'\uF6B9',
    'ScriptI': u'\uF6BA',
    'ScriptJ': u'\uF6BB',
    'ScriptK': u'\uF6BC',
    'ScriptL': u'\u2113',
    'ScriptM': u'\uF6BE',
    'ScriptN': u'\uF6BF',
    'ScriptNine': u'\uF7F9',
    'ScriptO': u'\u2134',
    'ScriptOne': u'\uF7F1',
    'ScriptP': u'\uF6C1',
    'ScriptQ': u'\uF6C2',
    'ScriptR': u'\uF6C3',
    'ScriptS': u'\uF6C4',
    'ScriptSeven': u'\uF7F7',
    'ScriptSix': u'\uF7F6',
    'ScriptT': u'\uF6C5',
    'ScriptThree': u'\uF7F3',
    'ScriptTwo': u'\uF7F2',
    'ScriptU': u'\uF6C6',
    'ScriptV': u'\uF6C7',
    'ScriptW': u'\uF6C8',
    'ScriptX': u'\uF6C9',
    'ScriptY': u'\uF6CA',
    'ScriptZ': u'\uF6CB',
    'ScriptZero': u'\uF7F0',
    'Section': u'\u00A7',
    'SelectionPlaceholder': u'\uF527',
    'SHacek': u'\u0161',
    'Sharp': u'\u266F',
    'ShortLeftArrow': u'\uF526',
    'ShortRightArrow': u'\uF525',
    'Sigma': u'\u03C3',
    'SixPointedStar': u'\u2736',
    'SkeletonIndicator': u'\u2043',
    'SmallCircle': u'\u2218',
    'SpaceIndicator': u'\u2423',
    'SpaceKey': u'\uF7BF',
    'SpadeSuit': u'\u2660',
    'SpanFromAbove': u'\uF3BB',
    'SpanFromBoth': u'\uF3BC',
    'SpanFromLeft': u'\uF3BA',
    'SphericalAngle': u'\u2222',
    'Sqrt': u'\u221A',
    'Square': u'\uF520',
    'SquareIntersection': u'\u2293',
    'SquareSubset': u'\u228F',
    'SquareSubsetEqual': u'\u2291',
    'SquareSuperset': u'\u2290',
    'SquareSupersetEqual': u'\u2292',
    'SquareUnion': u'\u2294',
    'Star': u'\u22C6',
    'Sterling': u'\u00A3',
    'Stigma': u'\u03DB',
    'Subset': u'\u2282',
    'SubsetEqual': u'\u2286',
    'Succeeds': u'\u227B',
    'SucceedsEqual': u'\u2AB0',
    'SucceedsSlantEqual': u'\u227D',
    'SucceedsTilde': u'\u227F',
    'SuchThat': u'\u220D',
    'Sum': u'\u2211',
    'Superset': u'\u2283',
    'SupersetEqual': u'\u2287',
    'SystemEnterKey': u'\uF75F',
    'SZ': u'\u00DF',
    'TabKey': u'\uF7BE',
    'Tau': u'\u03C4',
    'THacek': u'\u0165',
    'Therefore': u'\u2234',
    'Theta': u'\u03B8',
    'ThickSpace': u'\u2005',
    'ThinSpace': u'\u2009',
    'Thorn': u'\u00FE',
    'Tilde': u'\u223C',
    'TildeEqual': u'\u2243',
    'TildeFullEqual': u'\u2245',
    'TildeTilde': u'\u2248',
    'Times': u'\u00D7',
    'Trademark': u'\u2122',
    'Transpose': u'\uF3C7',
    'UAcute': u'\u00FA',
    'UDoubleAcute': u'\u0171',
    'UDoubleDot': u'\u00FC',
    'UGrave': u'\u00F9',
    'UHat': u'\u00FB',
    'UnderBrace': u'\uFE38',
    'UnderBracket': u'\u23B5',
    'UnderParenthesis': u'\uFE36',
    'Union': u'\u22C3',
    'UnionPlus': u'\u228E',
    'UpArrow': u'\u2191',
    'UpArrowBar': u'\u2912',
    'UpArrowDownArrow': u'\u21C5',
    'UpDownArrow': u'\u2195',
    'UpEquilibrium': u'\u296E',
    'UpperLeftArrow': u'\u2196',
    'UpperRightArrow': u'\u2197',
    'UpPointer': u'\u25B4',
    'Upsilon': u'\u03C5',
    'UpTee': u'\u22A5',
    'UpTeeArrow': u'\u21A5',
    'Uranus': u'\u2645',
    'URing': u'\u016F',
    'Vee': u'\u22C1',
    'Venus': u'\u2640',
    'VerticalBar': u'\u2223',
    'VerticalEllipsis': u'\u22EE',
    'VerticalLine': u'\u2502',
    'VerticalSeparator': u'\uF432',
    'VerticalTilde': u'\u2240',
    'VeryThinSpace': u'\u200A',
    'WarningSign': u'\uF725',
    'WatchIcon': u'\u231A',
    'Wedge': u'\u22C0',
    'WeierstrassP': u'\u2118',
    'WhiteBishop': u'\u2657',
    'WhiteKing': u'\u2654',
    'WhiteKnight': u'\u2658',
    'WhitePawn': u'\u2659',
    'WhiteQueen': u'\u2655',
    'WhiteRook': u'\u2656',
    'Wolf': u'\uF720',
    'Xi': u'\u03BE',
    'Xnor': u'\uF4A2',
    'Xor': u'\u22BB',
    'YAcute': u'\u00FD',
    'YDoubleDot': u'\u00FF',
    'Yen': u'\u00A5',
    'Zeta': u'\u03B6',
    'ZHacek': u'\u017E',
}

aliased_characters = {
    u"a'": u'\u00E1',
    u'a-': u'\u0101',
    u'au': u'\u0103',
    u'a"': u'\u00E4',
    u'ae': u'\u00E6',
    u'a`': u'\u00E0',
    u'a^': u'\u00E2',
    u'al': u'\u2135',
    u'esc': u'\uF768',
    u'am': u'\uF760',
    u'a': u'\u03B1',
    u'alpha': u'\u03B1',
    u'alt': u'\uF7D1',
    u'&&': u'\u2227',
    u'and': u'\u2227',
    u'Ang': u'\u212B',
    u'ao': u'\u00E5',
    u'a~': u'\u00E3',
    u'\\': u'\u2216',
    u'be': u'\u2136',
    u'b': u'\u03B2',
    u'beta': u'\u03B2',
    u'bv': u'\u02D8',
    u'bu': u'\u2022',
    u"c'": u'\u0107',
    u"A'": u'\u00C1',
    u'A-': u'\u0100',
    u'Au': u'\u0102',
    u'A"': u'\u00C4',
    u'AE': u'\u00C6',
    u'A`': u'\u00C0',
    u'A^': u'\u00C2',
    u'A': u'\u0391',
    u'Alpha': u'\u0391',
    u'Ao': u'\u00C5',
    u'A~': u'\u00C3',
    u'B': u'\u0392',
    u'Beta': u'\u0392',
    u"C'": u'\u0106',
    u'C,': u'\u00C7',
    u'Cv': u'\u010C',
    u'Ch': u'\u03A7',
    u'Chi': u'\u03A7',
    u'C': u'\u03A7',
    u'D': u'\u0394',
    u'Delta': u'\u0394',
    u'Dv': u'\u010E',
    u'DD': u'\uF74B',
    u'Di': u'\u03DC',
    u'Digamma': u'\u03DC',
    u"E'": u'\u00C9',
    u'E-': u'\u0112',
    u'Eu': u'\u0114',
    u'E"': u'\u00CB',
    u'E`': u'\u00C8',
    u'Ev': u'\u011A',
    u'E^': u'\u00CA',
    u'E': u'\u0395',
    u'Epsilon': u'\u0395',
    u'Et': u'\u0397',
    u'Eta': u'\u0397',
    u'H': u'\u0397',
    u'D-': u'\u00D0',
    u'G': u'\u0393',
    u'Gamma': u'\u0393',
    u"I'": u'\u00CD',
    u'Iu': u'\u012C',
    u'I"': u'\u00CF',
    u'I`': u'\u00CC',
    u'I^': u'\u00CE',
    u'I': u'\u0399',
    u'Iota': u'\u0399',
    u'K': u'\u039A',
    u'Kappa': u'\u039A',
    u'Ko': u'\u03DE',
    u'Koppa': u'\u03DE',
    u'L': u'\u039B',
    u'Lambda': u'\u039B',
    u'L/': u'\u0141',
    u'M': u'\u039C',
    u'Mu': u'\u039C',
    u'Nv': u'\u0147',
    u'N~': u'\u00D1',
    u'N': u'\u039D',
    u'Nu': u'\u039D',
    u"O'": u'\u00D3',
    u"O''": u'\u0150',
    u'O"': u'\u00D6',
    u'OE': u'\u0152',
    u'O`': u'\u00D2',
    u'O^': u'\u00D4',
    u'O': u'\u03A9',
    u'Omega': u'\u03A9',
    u'W': u'\u03A9',
    u'Om': u'\u039F',
    u'Omicron': u'\u039F',
    u'O/': u'\u00D8',
    u'O~': u'\u00D5',
    u'Ph': u'\u03A6',
    u'Phi': u'\u03A6',
    u'F': u'\u03A6',
    u'P': u'\u03A0',
    u'Pi': u'\u03A0',
    u'Ps': u'\u03A8',
    u'Psi': u'\u03A8',
    u'Y': u'\u03A8',
    u'Rv': u'\u0158',
    u'R': u'\u03A1',
    u'Rho': u'\u03A1',
    u'Sa': u'\u03E0',
    u'Sampi': u'\u03E0',
    u'Sv': u'\u0160',
    u'S': u'\u03A3',
    u'Sigma': u'\u03A3',
    u'T': u'\u03A4',
    u'Tau': u'\u03A4',
    u'Tv': u'\u0164',
    u'Th': u'\u0398',
    u'Theta': u'\u0398',
    u'Q': u'\u0398',
    u'Thn': u'\u00DE',
    u"U'": u'\u00DA',
    u"U''": u'\u0170',
    u'U"': u'\u00DC',
    u'U`': u'\u00D9',
    u'U^': u'\u00DB',
    u'U': u'\u03A5',
    u'Upsilon': u'\u03A5',
    u'Uo': u'\u016E',
    u'X': u'\u039E',
    u'Xi': u'\u039E',
    u"Y'": u'\u00DD',
    u'Z': u'\u0396',
    u'Zeta': u'\u0396',
    u'Zv': u'\u017D',
    u'c,': u'\u00E7',
    u'cd': u'\u00B8',
    u'.': u'\u00B7',
    u'cent': u'\u00A2',
    u'cv': u'\u010D',
    u'ch': u'\u03C7',
    u'chi': u'\u03C7',
    u'c': u'\u03C7',
    u'c.': u'\u2299',
    u'c-': u'\u2296',
    u'c+': u'\u2295',
    u'c*': u'\u2297',
    u'ccint': u'\u2232',
    u'cl': u'\u2318',
    u':': u'\u2236',
    u'cmd': u'\uF76A',
    u'===': u'\u2261',
    u'co': u'\uF3C8',
    u'conj': u'\uF3C8',
    u'ct': u'\uF3C9',
    u'cont': u'\uF3B1',
    u'cint': u'\u222E',
    u'ctrl': u'\uF763',
    u'coprod': u'\u2210',
    u'cccint': u'\u2233',
    u'cross': u'\uF4A0',
    u'cU': u'\u03D2',
    u'cUpsilon': u'\u03D2',
    u'ce': u'\u03B5',
    u'cepsilon': u'\u03B5',
    u'ck': u'\u03F0',
    u'ckappa': u'\u03F0',
    u'j': u'\u03C6',
    u'cph': u'\u03C6',
    u'cphi': u'\u03C6',
    u'cp': u'\u03D6',
    u'cpi': u'\u03D6',
    u'cr': u'\u03F1',
    u'crho': u'\u03F1',
    u'cq': u'\u03D1',
    u'cth': u'\u03D1',
    u'ctheta': u'\u03D1',
    u'dg': u'\u2020',
    u'da': u'\u2138',
    u'-': u'\u2013',
    u'deg': u'\u00B0',
    u' del': u'\uF7D0',
    u'del': u'\u2207',
    u'd': u'\u03B4',
    u'delta': u'\u03B4',
    u'dv': u'\u010F',
    u'dia': u'\u22C4',
    u'diffd': u'\u2206',
    u'dd': u'\uF74C',
    u'di': u'\u03DD',
    u'digamma': u'\u03DD',
    u'dratio': u'\uF4A4',
    u'shift': u'\uF4A3',
    u'dhy': u'\u00AD',
    u'dlsep': u'\uF76E',
    u'dpsep': u'\uF76F',
    u'div': u'\u00F7',
    u'.=': u'\u2250',
    u'ddg': u'\u2021',
    u'gg': u'\uF74A',
    u'pp': u'\uF749',
    u' <=': u'\u21D0',
    u'<=>': u'\u21D4',
    u'<==': u'\u27F8',
    u'<==>': u'\u27FA',
    u'==>': u'\u27F9',
    u"''": u'\u2033',
    u' =>': u'\u21D2',
    u'dsa': u'\uF6E6',
    u'dsb': u'\uF6E7',
    u'dsc': u'\uF6E8',
    u'dsA': u'\uF7A4',
    u'dsB': u'\uF7A5',
    u'dsC': u'\uF7A6',
    u'dsD': u'\uF7A7',
    u'dsE': u'\uF7A8',
    u'dsF': u'\uF7A9',
    u'dsG': u'\uF7AA',
    u'dsH': u'\uF7AB',
    u'dsI': u'\uF7AC',
    u'dsJ': u'\uF7AD',
    u'dsK': u'\uF7AE',
    u'dsL': u'\uF7AF',
    u'dsM': u'\uF7B0',
    u'dsN': u'\uF7B1',
    u'dsO': u'\uF7B2',
    u'dsP': u'\uF7B3',
    u'dsQ': u'\uF7B4',
    u'dsR': u'\uF7B5',
    u'dsS': u'\uF7B6',
    u'dsT': u'\uF7B7',
    u'dsU': u'\uF7B8',
    u'dsV': u'\uF7B9',
    u'dsW': u'\uF7BA',
    u'dsX': u'\uF7BB',
    u'dsY': u'\uF7BC',
    u'dsZ': u'\uF7BD',
    u'dsd': u'\uF6E9',
    u'dse': u'\uF6EA',
    u'ds8': u'\uF7E3',
    u'dsf': u'\uF6EB',
    u'ds5': u'\uF7E0',
    u'ds4': u'\uF7DF',
    u'dsg': u'\uF6EC',
    u'dsh': u'\uF6ED',
    u'dsi': u'\uF6EE',
    u'dsj': u'\uF6EF',
    u'dsk': u'\uF6F0',
    u'dsl': u'\uF6F1',
    u'dsm': u'\uF6F2',
    u'dsn': u'\uF6F3',
    u'ds9': u'\uF7E4',
    u'dso': u'\uF6F4',
    u'ds1': u'\uF7DC',
    u'dsp': u'\uF6F5',
    u'dsq': u'\uF6F6',
    u'dsr': u'\uF6F7',
    u'dss': u'\uF6F8',
    u'ds7': u'\uF7E2',
    u'ds6': u'\uF7E1',
    u'dst': u'\uF6F9',
    u'ds3': u'\uF7DE',
    u'ds2': u'\uF7DD',
    u'dsu': u'\uF6FA',
    u'dsv': u'\uF6FB',
    u'dsw': u'\uF6FC',
    u'dsx': u'\uF6FD',
    u'dsy': u'\uF6FE',
    u'dsz': u'\uF6FF',
    u'ds0': u'\uF7DB',
    u' ||': u'\u2225',
    u'dbv': u'\uF755',
    u'd!': u'\u00A1',
    u'd?': u'\u00BF',
    u'dT': u'\u22A4',
    u"e'": u'\u00E9',
    u'e-': u'\u0113',
    u'eu': u'\u0115',
    u'e"': u'\u00EB',
    u'e`': u'\u00E8',
    u'ev': u'\u011B',
    u'e^': u'\u00EA',
    u'el': u'\u2208',
    u'elem': u'\u2208',
    u'...': u'\u2026',
    u'eci': u'\u25CB',
    u'es': u'\u2205',
    u'esci': u'\u25E6',
    u'essq': u'\u25FB',
    u'esq': u'\u25A1',
    u'ent': u'\uF7D4',
    u'e': u'\u03F5',
    u'epsilon': u'\u03F5',
    u'==': u'\uF431',
    u'=~': u'\u2242',
    u'equi': u'\u21CC',
    u'equiv': u'\u29E6',
    u' esc': u'\uF769',
    u'et': u'\u03B7',
    u'eta': u'\u03B7',
    u'h': u'\u03B7',
    u'd-': u'\u00F0',
    u'ex': u'\u2203',
    u'ee': u'\uF74D',
    u'fci': u'\u25CF',
    u'fsci': u'\uF750',
    u'fssq': u'\u25FC',
    u'fsq': u'\u25A0',
    u'fvssq': u'\u25AA',
    u'fs': u'\u03C2',
    u'*5': u'\u2605',
    u'fa': u'\u2200',
    u'$a': u'\uF800',
    u'$b': u'\uF801',
    u'$c': u'\uF802',
    u'$A': u'\uF81A',
    u'$B': u'\uF81B',
    u'$C': u'\uF81C',
    u'$D': u'\uF81D',
    u'$E': u'\uF81E',
    u'$F': u'\uF81F',
    u'$G': u'\uF820',
    u'$H': u'\uF821',
    u'$I': u'\uF822',
    u'$J': u'\uF823',
    u'$K': u'\uF824',
    u'$L': u'\uF825',
    u'$M': u'\uF826',
    u'$N': u'\uF827',
    u'$O': u'\uF828',
    u'$P': u'\uF829',
    u'$Q': u'\uF82A',
    u'$R': u'\uF82B',
    u'$S': u'\uF82C',
    u'$T': u'\uF82D',
    u'$U': u'\uF82E',
    u'$V': u'\uF82F',
    u'$W': u'\uF830',
    u'$X': u'\uF831',
    u'$Y': u'\uF832',
    u'$Z': u'\uF833',
    u'$d': u'\uF803',
    u'$e': u'\uF804',
    u'$f': u'\uF805',
    u'$g': u'\uF806',
    u'$h': u'\uF807',
    u'$i': u'\uF808',
    u'$j': u'\uF809',
    u'$k': u'\uF80A',
    u'$l': u'\uF80B',
    u'$m': u'\uF80C',
    u'$n': u'\uF80D',
    u'$o': u'\uF80E',
    u'$p': u'\uF80F',
    u'$q': u'\uF810',
    u'$r': u'\uF811',
    u'$s': u'\uF812',
    u'$t': u'\uF813',
    u'$u': u'\uF814',
    u'$v': u'\uF815',
    u'$w': u'\uF816',
    u'$x': u'\uF817',
    u'$y': u'\uF818',
    u'$z': u'\uF819',
    u':-@': u'\uF721',
    u'fn': u'\uF4A1',
    u'g': u'\u03B3',
    u'gamma': u'\u03B3',
    u'gi': u'\u2137',
    u'goa': u'\uF6CC',
    u'gob': u'\uF6CD',
    u'goc': u'\uF6CE',
    u'goA': u'\uF78A',
    u'goB': u'\uF78B',
    u'goC': u'\u212D',
    u'goD': u'\uF78D',
    u'goE': u'\uF78E',
    u'goF': u'\uF78F',
    u'goG': u'\uF790',
    u'goH': u'\u210C',
    u'goI': u'\u2111',
    u'goJ': u'\uF793',
    u'goK': u'\uF794',
    u'goL': u'\uF795',
    u'goM': u'\uF796',
    u'goN': u'\uF797',
    u'goO': u'\uF798',
    u'goP': u'\uF799',
    u'goQ': u'\uF79A',
    u'goR': u'\u211C',
    u'goS': u'\uF79C',
    u'goT': u'\uF79D',
    u'goU': u'\uF79E',
    u'goV': u'\uF79F',
    u'goW': u'\uF7A0',
    u'goX': u'\uF7A1',
    u'goY': u'\uF7A2',
    u'goZ': u'\u2128',
    u'god': u'\uF6CF',
    u'goe': u'\uF6D0',
    u'go8': u'\uF7ED',
    u'gof': u'\uF6D1',
    u'go5': u'\uF7EA',
    u'go4': u'\uF7E9',
    u'gog': u'\uF6D2',
    u'goh': u'\uF6D3',
    u'goi': u'\uF6D4',
    u'goj': u'\uF6D5',
    u'gok': u'\uF6D6',
    u'gol': u'\uF6D7',
    u'gom': u'\uF6D8',
    u'gon': u'\uF6D9',
    u'go9': u'\uF7EF',
    u'goo': u'\uF6DA',
    u'go1': u'\uF7E6',
    u'gop': u'\uF6DB',
    u'goq': u'\uF6DC',
    u'gor': u'\uF6DD',
    u'gos': u'\uF6DE',
    u'go7': u'\uF7EC',
    u'go6': u'\uF7EB',
    u'got': u'\uF6DF',
    u'go3': u'\uF7E8',
    u'go2': u'\uF7E7',
    u'gou': u'\uF6E0',
    u'gov': u'\uF6E1',
    u'gow': u'\uF6E2',
    u'gox': u'\uF6E3',
    u'goy': u'\uF6E4',
    u'goz': u'\uF6E5',
    u'go0': u'\uF7E5',
    u'gci': u'\uF753',
    u'gsq': u'\uF752',
    u'>=': u'\u2265',
    u'>/': u'\u2A7E',
    u'>~': u'\u2273',
    u'hck': u'\u02C7',
    u':)': u'\u263A',
    u':-)': u'\u263A',
    u'hb': u'\u210F',
    u'hc': u'\uF3CE',
    u'hline': u'\u2500',
    u'h=': u'\u224F',
    u"i'": u'\u00ED',
    u'iu': u'\u012D',
    u'i"': u'\u00EF',
    u'i`': u'\u00EC',
    u'i^': u'\u00EE',
    u'ii': u'\uF74E',
    u'jj': u'\uF74F',
    u'+': u'\uF39E',
    u'=>': u'\uF523',
    u'inf': u'\u221E',
    u'int': u'\u222B',
    u'inter': u'\u22C2',
    u'@': u'\uF76D',
    u',': u'\uF765',
    u'is': u'\uF360',
    u'i': u'\u03B9',
    u'iota': u'\u03B9',
    u'k': u'\u03BA',
    u'kappa': u'\u03BA',
    u'ko': u'\u03DF',
    u'koppa': u'\u03DF',
    u'l': u'\u03BB',
    u'lambda': u'\u03BB',
    u'<': u'\u2329',
    u'<-': u'\u2190',
    u'l|': u'\uF603',
    u'lc': u'\u2308',
    u'[[': u'\u301A',
    u'l||': u'\uF605',
    u'lf': u'\u230A',
    u'g<<': u'\u00AB',
    u'[': u'\uF76B',
    u'<->': u'\u2194',
    u'lT': u'\u22A3',
    u'<=': u'\u2264',
    u'</': u'\u2A7D',
    u'<~': u'\u2272',
    u'_': u'\uF754',
    u'ls': u'\uF754',
    u'--': u'\u2014',
    u'<--': u'\u27F5',
    u'<-->': u'\u27F7',
    u'-->': u'\u27F6',
    u'l/': u'\u0142',
    u'math': u'\uF757',
    u'   ': u'\u205F',
    u'mho': u'\u2127',
    u'mi': u'\u00B5',
    u'-+': u'\u2213',
    u'm': u'\u03BC',
    u'mu': u'\u03BC',
    u'nand': u'\u22BC',
    u'-   ': u'\uF383',
    u'-    ': u'\uF384',
    u'-  ': u'\uF382',
    u'- ': u'\uF380',
    u':-|': u'\uF722',
    u'nv': u'\u0148',
    u'nb': u'\u2060',
    u'nbs': u'\u00A0',
    u'nor': u'\u22BD',
    u'!===': u'\u2262',
    u'!||': u'\u2226',
    u'!el': u'\u2209',
    u'!elem': u'\u2209',
    u'!=': u'\u2260',
    u'!=~': u'\uF400',
    u'!ex': u'\u2204',
    u'!>': u'\u226F',
    u'!>=': u'\u2271',
    u'!>/': u'\uF429',
    u'!>~': u'\u2275',
    u'!h=': u'\uF401',
    u'!<=': u'\u2270',
    u'!<': u'\u226E',
    u'!</': u'\uF424',
    u'!<~': u'\u2274',
    u'!': u'\u00AC',
    u'not': u'\u00AC',
    u'!mem': u'\u220C',
    u'!sub': u'\u2284',
    u'!sub=': u'\u2288',
    u'!sup': u'\u2285',
    u'!sup=': u'\u2289',
    u'!~': u'\u2241',
    u'!~=': u'\u2244',
    u'!~==': u'\u2247',
    u'!~~': u'\u2249',
    u'!|': u'\u2224',
    u'n~': u'\u00F1',
    u'n': u'\u03BD',
    u'nu': u'\u03BD',
    u'null': u'\uF3A0',
    u"o'": u'\u00F3',
    u"o''": u'\u0151',
    u'o"': u'\u00F6',
    u'oe': u'\u0153',
    u'o`': u'\u00F2',
    u'o^': u'\u00F4',
    u'o': u'\u03C9',
    u'omega': u'\u03C9',
    u'w': u'\u03C9',
    u'om': u'\u03BF',
    u'omicron': u'\u03BF',
    u'opt': u'\uF7D2',
    u'||': u'\u2228',
    u'or': u'\u2228',
    u'o/': u'\u00F8',
    u'o~': u'\u00F5',
    u'o{': u'\uFE37',
    u'o[': u'\u23B4',
    u'o(': u'\uFE35',
    u'pd': u'\u2202',
    u'ph': u'\u03D5',
    u'phi': u'\u03D5',
    u'f': u'\u03D5',
    u'p': u'\u03C0',
    u'pi': u'\u03C0',
    u'pw': u'\uF361',
    u'pl': u'\uF528',
    u'+-': u'\u00B1',
    u"'": u'\u2032',
    u'prod': u'\u220F',
    u'prop': u'\u221D',
    u'ps': u'\u03C8',
    u'psi': u'\u03C8',
    u'y': u'\u03C8',
    u'rtm': u'\u00AE',
    u'ret': u'\u21B5',
    u' ret': u'\uF766',
    u'``': u'\u2036',
    u'mem': u'\u220B',
    u'`': u'\u2035',
    u'rv': u'\u0159',
    u'r': u'\u03C1',
    u'rho': u'\u03C1',
    u'>': u'\u232A',
    u' ->': u'\u2192',
    u'r|': u'\uF604',
    u'rc': u'\u2309',
    u']]': u'\u301B',
    u'r||': u'\uF606',
    u'rf': u'\u230B',
    u'g>>': u'\u00BB',
    u']': u'\uF76C',
    u'rT': u'\u22A2',
    u'vec': u'\u21C0',
    u'->': u'\uF522',
    u':>': u'\uF51F',
    u':-(': u'\u2639',
    u'sa': u'\u03E0',
    u'sampi': u'\u03E0',
    u'sca': u'\uF6B2',
    u'scb': u'\uF6B3',
    u'scc': u'\uF6B4',
    u'scA': u'\uF770',
    u'scB': u'\u212C',
    u'scC': u'\uF772',
    u'scD': u'\uF773',
    u'scE': u'\u2130',
    u'scF': u'\u2131',
    u'scG': u'\uF776',
    u'scH': u'\u210B',
    u'scI': u'\u2110',
    u'scJ': u'\uF779',
    u'scK': u'\uF77A',
    u'scL': u'\u2112',
    u'scM': u'\u2133',
    u'scN': u'\uF77D',
    u'scO': u'\uF77E',
    u'scP': u'\u2118',
    u'scQ': u'\uF780',
    u'scR': u'\u211B',
    u'scS': u'\uF782',
    u'scT': u'\uF783',
    u'scU': u'\uF784',
    u'scV': u'\uF785',
    u'scW': u'\uF786',
    u'scX': u'\uF787',
    u'scY': u'\uF788',
    u'scZ': u'\uF789',
    u'scd': u'\uF6B5',
    u'sce': u'\u212F',
    u'sc8': u'\uF7F8',
    u'scf': u'\uF6B7',
    u'sc5': u'\uF7F5',
    u'sc4': u'\uF7F4',
    u'scg': u'\u210A',
    u'sch': u'\uF6B9',
    u'sci': u'\uF6BA',
    u'scj': u'\uF6BB',
    u'sck': u'\uF6BC',
    u'scl': u'\u2113',
    u'scm': u'\uF6BE',
    u'scn': u'\uF6BF',
    u'sc9': u'\uF7F9',
    u'sco': u'\u2134',
    u'sc1': u'\uF7F1',
    u'scp': u'\uF6C1',
    u'scq': u'\uF6C2',
    u'scr': u'\uF6C3',
    u'scs': u'\uF6C4',
    u'sc7': u'\uF7F7',
    u'sc6': u'\uF7F6',
    u'sct': u'\uF6C5',
    u'sc3': u'\uF7F3',
    u'sc2': u'\uF7F2',
    u'scu': u'\uF6C6',
    u'scv': u'\uF6C7',
    u'scw': u'\uF6C8',
    u'scx': u'\uF6C9',
    u'scy': u'\uF6CA',
    u'scz': u'\uF6CB',
    u'sc0': u'\uF7F0',
    u'spl': u'\uF527',
    u'sv': u'\u0161',
    u's': u'\u03C3',
    u'sigma': u'\u03C3',
    u'*6': u'\u2736',
    u'sc': u'\u2218',
    u'space': u'\u2423',
    u'spc': u'\uF7BF',
    u'sqrt': u'\u221A',
    u'sq': u'\uF520',
    u'star': u'\u22C6',
    u'sti': u'\u03DB',
    u'stigma': u'\u03DB',
    u'sub': u'\u2282',
    u'sub=': u'\u2286',
    u'st': u'\u220D',
    u'sum': u'\u2211',
    u'sup': u'\u2283',
    u'sup=': u'\u2287',
    u'sz': u'\u00DF',
    u'ss': u'\u00DF',
    u'tab': u'\uF7BE',
    u't': u'\u03C4',
    u'tau': u'\u03C4',
    u'tv': u'\u0165',
    u'tf': u'\u2234',
    u'th': u'\u03B8',
    u'theta': u'\u03B8',
    u'q': u'\u03B8',
    u'    ': u'\u2005',
    u'  ': u'\u2009',
    u'thn': u'\u00FE',
    u'~': u'\u223C',
    u'~=': u'\u2243',
    u'~==': u'\u2245',
    u'~~': u'\u2248',
    u'*': u'\u00D7',
    u'tm': u'\u2122',
    u'tr': u'\uF3C7',
    u"u'": u'\u00FA',
    u"u''": u'\u0171',
    u'u"': u'\u00FC',
    u'u`': u'\u00F9',
    u'u^': u'\u00FB',
    u'u{': u'\uFE38',
    u'u[': u'\u23B5',
    u'u(': u'\uFE36',
    u'un': u'\u22C3',
    u'u': u'\u03C5',
    u'upsilon': u'\u03C5',
    u'uT': u'\u22A5',
    u'uo': u'\u016F',
    u'v': u'\u22C1',
    u' |': u'\u2223',
    u'vline': u'\u2502',
    u'|': u'\uF432',
    u' ': u'\u200A',
    u'^': u'\u22C0',
    u'wp': u'\u2118',
    u'wf': u'\uF720',
    u'wolf': u'\uF720',
    u'x': u'\u03BE',
    u'xi': u'\u03BE',
    u'xnor': u'\uF4A2',
    u'xor': u'\u22BB',
    u"y'": u'\u00FD',
    u'z': u'\u03B6',
    u'zeta': u'\u03B6',
    u'zv': u'\u017E',
}

########NEW FILE########
__FILENAME__ = convert
# -*- coding: utf8 -*-

"""
Converts expressions from SymPy to Mathics expressions.
Conversion to SymPy is handled directly in BaseExpression descendants.
"""

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sympy

sympy_symbol_prefix = '_Mathics_User_'
sympy_slot_prefix = '_Mathics_Slot_'


def create_symbol(self, name):
    from mathics.core import expression
    return expression.Symbol(name)


class ConvertSubstitutions(object):
    head_name = '___SageSubst___'

    def __init__(self):
        self.subs = []

    def substitute(self, expr):
        from mathics.core import expression

        index = len(self.subs)
        self.subs.append(expr)
        return expression.Expression(self.head_name, expression.Integer(index),
                                     *expr.get_atoms())

if sympy.__version__ == '0.7.3':
    # Monkeypatch bug in sympy.Expr._expand_hint

    def _expand_hint(expr, hint, deep=True, **hints):
        """
        Helper for ``expand()``.  Recursively calls ``expr._eval_expand_hint()``.

        Returns ``(expr, hit)``, where expr is the (possibly) expanded
        ``expr`` and ``hit`` is ``True`` if ``expr`` was truly expanded and
        ``False`` otherwise.
        """
        hit = False
        # XXX: Hack to support non-Basic args
        #              |
        #              V
        if deep and getattr(expr, 'args', ()) and not expr.is_Atom:
            sargs = []
            for arg in expr.args:
                arg, arghit = _expand_hint(arg, hint, **hints)
                hit |= arghit
                sargs.append(arg)

            if hit:
                expr = expr.func(*sargs)

        if hasattr(expr, hint):
            newexpr = getattr(expr, hint)(**hints)
            if newexpr != expr:
                return (newexpr, True)

        return (expr, hit)

    sympy.Expr._expand_hint = _expand_hint


BasicSympy = sympy.Expr


class SympyExpression(BasicSympy):
    is_Function = True
    nargs = None

    def __new__(cls, expr):
        obj = BasicSympy.__new__(
            cls, *(expr.head.to_sympy(),) + tuple(leaf.to_sympy()
                                                  for leaf in expr.leaves))
        obj.expr = expr
        return obj

    """def new(self, *args):
        from mathics.core import expression

        expr = expression.Expression(from_sympy(args[0]),
            *(from_sympy(arg) for arg in args[1:]))
        return SympyExpression(expr)"""

    @property
    def func(self):
        class SympyExpressionFunc(object):
            def __new__(cls, *args):
                return SympyExpression(self.expr)
                # return SympyExpression(expression.Expression(self.expr.head,
                # *(from_sympy(arg) for arg in args[1:])))
        return SympyExpressionFunc

    def has_any_symbols(self, *syms):
        result = any(arg.has_any_symbols(*syms) for arg in self.args)
        return result

    def _eval_subs(self, old, new):
        if self == old:
            return new
        old, new = from_sympy(old), from_sympy(new)
        old_name = old.get_name()
        if old_name:
            new_expr = self.expr.replace_vars({old_name: new})
            return SympyExpression(new_expr)
        return self

    def _eval_rewrite(self, pattern, rule, **hints):
        return self

    @property
    def is_commutative(self):
        if all(getattr(t, 'is_commutative') for t in self.args):
            return True
        else:
            return False

    def __str__(self):
        return '%s[%s]' % (super(SympyExpression, self).__str__(), self.expr)


def from_sympy(expr):
    from mathics.builtin import sympy_to_mathics
    from mathics.core.expression import (
        Symbol, Integer, Rational, Real, Complex, String, Expression)

    from sympy.core import numbers, function, symbol

    if isinstance(expr, (tuple, list)):
        return Expression('List', *[from_sympy(item) for item in expr])
    if isinstance(expr, int):
        return Integer(expr)
    if isinstance(expr, float):
        return Real(expr)
    if isinstance(expr, complex):
        return Complex(expr.real, expr.imag)
    if isinstance(expr, str):
        return String(expr)
    if expr is None:
        return Symbol('Null')
    if isinstance(expr, sympy.Matrix):
        return Expression('List', *[
            Expression('List', *[from_sympy(item) for item in row])
            for row in expr.tolist()])
    if expr.is_Atom:
        name = None
        if expr.is_Symbol:
            name = unicode(expr)
            if isinstance(expr, symbol.Dummy):
                name = name + ('__Dummy_%d' % expr.dummy_index)
                return Symbol(name, sympy_dummy=expr)
            if ((not name.startswith(sympy_symbol_prefix) or     # noqa
                 name.startswith(sympy_slot_prefix)) and
                name.startswith('C')):
                return Expression('C', int(name[1:]))
            if name.startswith(sympy_symbol_prefix):
                name = name[len(sympy_symbol_prefix):]
            if name.startswith(sympy_slot_prefix):
                index = name[len(sympy_slot_prefix):]
                return Expression('Slot', int(index))
        elif expr.is_NumberSymbol:
            name = unicode(expr)
        if name is not None:
            builtin = sympy_to_mathics.get(name)
            if builtin is not None:
                name = builtin.get_name()
            return Symbol(name)
        elif isinstance(expr, (numbers.Infinity, numbers.ComplexInfinity)):
            return Symbol(expr.__class__.__name__)
        elif isinstance(expr, numbers.NegativeInfinity):
            return Expression('Times', Integer(-1), Symbol('Infinity'))
        elif isinstance(expr, numbers.ImaginaryUnit):
            return Complex(0, 1)
        elif isinstance(expr, numbers.Integer):
            return Integer(expr.p)
        elif isinstance(expr, numbers.Rational):
            if expr.q == 0:
                if expr.p > 0:
                    return Symbol('Infinity')
                elif expr.p < 0:
                    return Expression('Times', Integer(-1), Symbol('Infinity'))
                else:
                    assert expr.p == 0
                    return Symbol('Indeterminate')
            return Rational(expr.p, expr.q)
        elif isinstance(expr, numbers.Float):
            return Real(expr)
        elif isinstance(expr, numbers.NaN):
            return Symbol('Indeterminate')
        elif isinstance(expr, function.FunctionClass):
            return Symbol(unicode(expr))
    elif expr.is_number and all([x.is_Number for x in expr.as_real_imag()]):
        # Hack to convert 3 * I to Complex[0, 3]
        return Complex(*[from_sympy(arg) for arg in expr.as_real_imag()])
    elif expr.is_Add:
        return Expression('Plus', *sorted([
            from_sympy(arg) for arg in expr.args]))
    elif expr.is_Mul:
        return Expression('Times', *sorted([
            from_sympy(arg) for arg in expr.args]))
    elif expr.is_Pow:
        return Expression('Power', *[from_sympy(arg) for arg in expr.args])
    elif expr.is_Equality:
        return Expression('Equal', *[from_sympy(arg) for arg in expr.args])

    elif isinstance(expr, SympyExpression):
        # print "SympyExpression: %s" % expr
        return expr.expr

    elif isinstance(expr, sympy.RootSum):
        return Expression('RootSum', from_sympy(expr.poly),
                          from_sympy(expr.fun))
    elif isinstance(expr, sympy.PurePoly):
        coeffs = expr.coeffs()
        monoms = expr.monoms()
        result = []
        for coeff, monom in zip(coeffs, monoms):
            factors = []
            if coeff != 1:
                factors.append(from_sympy(coeff))
            for index, exp in enumerate(monom):
                if exp != 0:
                    slot = Expression('Slot', index + 1)
                    if exp == 1:
                        factors.append(slot)
                    else:
                        factors.append(Expression(
                            'Power', slot, from_sympy(exp)))
            if factors:
                result.append(Expression('Times', *factors))
            else:
                result.append(Integer(1))
        return Expression('Function', Expression('Plus', *result))
    elif isinstance(expr, sympy.Lambda):
        vars = [sympy.Symbol('%s%d' % (sympy_slot_prefix, index + 1))
                for index in range(len(expr.variables))]
        return Expression('Function', from_sympy(expr(*vars)))

    elif expr.is_Function or isinstance(
        expr, (sympy.Integral, sympy.Derivative,
               sympy.Sum, sympy.Product)):
        if isinstance(expr, sympy.Integral):
            name = 'Integral'
        elif isinstance(expr, sympy.Derivative):
            name = 'Derivative'
        else:
            name = expr.func.__name__
            if name.startswith(sympy_symbol_prefix):
                name = name[len(sympy_symbol_prefix):]
        args = [from_sympy(arg) for arg in expr.args]
        builtin = sympy_to_mathics.get(name)
        if builtin is not None:
            name = builtin.get_name()
            args = builtin.from_sympy(args)
        return Expression(Symbol(name), *args)

    elif isinstance(expr, sympy.Tuple):
        return Expression('List', *[from_sympy(arg) for arg in expr.args])

    # elif isinstance(expr, sympy.Sum):
    #    return Expression('Sum', )

    elif isinstance(expr, sympy.LessThan):
        return Expression('LessEqual',
                          [from_sympy(arg) for arg in expr.args])
    elif isinstance(expr, sympy.StrictLessThan):
        return Expression('Less',
                          [from_sympy(arg) for arg in expr.args])
    elif isinstance(expr, sympy.GreaterThan):
        return Expression('GreaterEqual',
                          [from_sympy(arg) for arg in expr.args])
    elif isinstance(expr, sympy.StrictGreaterThan):
        return Expression('Greater',
                          [from_sympy(arg) for arg in expr.args])
    elif isinstance(expr, sympy.Unequality):
        return Expression('Unequal',
                          [from_sympy(arg) for arg in expr.args])
    elif isinstance(expr, sympy.Equality):
        return Expression('Equal',
                          [from_sympy(arg) for arg in expr.args])
    else:
        raise ValueError("Unknown SymPy expression: %s" % expr)

########NEW FILE########
__FILENAME__ = definitions
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import cPickle as pickle
import os
import base64


def get_file_time(file):
    try:
        return os.stat(file).st_mtime
    except OSError:
        return 0


def valuesname(name):
    " 'NValues' -> 'n' "

    if name == 'Messages':
        return 'messages'
    else:
        return name[:-6].lower()


class Definitions(object):
    def __init__(self, add_builtin=False, builtin_filename=None):
        super(Definitions, self).__init__()
        self.builtin = {}
        self.user = {}
        self.autoload_stage = False

        if add_builtin:
            from mathics.builtin import modules, contribute
            from mathics.core.evaluation import Evaluation
            from mathics.settings import ROOT_DIR

            loaded = False
            if builtin_filename is not None:
                builtin_dates = [get_file_time(module.__file__)
                                 for module in modules]
                builtin_time = max(builtin_dates)
                if get_file_time(builtin_filename) > builtin_time:
                    builtin_file = open(builtin_filename, 'r')
                    self.builtin = pickle.load(builtin_file)
                    loaded = True
            if not loaded:
                contribute(self)
                if builtin_filename is not None:
                    builtin_file = open(builtin_filename, 'w')
                    pickle.dump(self.builtin, builtin_file, -1)

            self.autoload_stage = True
            for root, dirs, files in os.walk(   # noqa
                os.path.join(ROOT_DIR, 'autoload')):

                for f in filter(lambda x: x.endswith('.m'), files):
                    with open(os.path.join(root, f)) as stream:
                        Evaluation(stream.read(), self, timeout=30)
            self.autoload_stage = False

    def get_builtin_names(self):
        return set(self.builtin)

    def get_user_names(self):
        return set(self.user)

    def get_names(self):
        return self.get_builtin_names() | self.get_user_names()

    def get_definition(self, name):
        user = self.user.get(name, None)
        builtin = self.builtin.get(name, None)

        if builtin:
            context = 'System`'
        else:
            context = 'Global`'

        if user is None and builtin is None:
            return Definition(name=name, context=context)
        if builtin is None:
            user.context = context
            return user
        if user is None:
            builtin.context = context
            return builtin

        if user:
            attributes = user.attributes
        elif builtin:
            attributes = builtin.attributes
        else:
            attributes = set()
        if not user:
            user = Definition(name=name)
        if not builtin:
            builtin = Definition(name=name)
        options = builtin.options.copy()
        options.update(user.options)
        formatvalues = builtin.formatvalues.copy()
        for form, rules in user.formatvalues.iteritems():
            if form in formatvalues:
                formatvalues[form].extend(rules)
            else:
                formatvalues[form] = rules

        return Definition(name=name,
                          ownvalues=user.ownvalues + builtin.ownvalues,
                          downvalues=user.downvalues + builtin.downvalues,
                          subvalues=user.subvalues + builtin.subvalues,
                          upvalues=user.upvalues + builtin.upvalues,
                          formatvalues=formatvalues,
                          messages=user.messages + builtin.messages,
                          attributes=attributes,
                          options=options,
                          nvalues=user.nvalues + builtin.nvalues,
                          defaultvalues=user.defaultvalues +
                          builtin.defaultvalues,
                          context=context,
                          )

    def get_attributes(self, name):
        return self.get_definition(name).attributes

    def get_ownvalues(self, name):
        return self.get_definition(name).ownvalues

    def get_downvalues(self, name):
        return self.get_definition(name).downvalues

    def get_subvalues(self, name):
        return self.get_definition(name).subvalues

    def get_upvalues(self, name):
        return self.get_definition(name).upvalues

    def get_formats(self, name, format=''):
        formats = self.get_definition(name).formatvalues
        result = formats.get(format, []) + formats.get('', [])
        result.sort()
        return result

    def get_nvalues(self, name):
        return self.get_definition(name).nvalues

    def get_defaultvalues(self, name):
        return self.get_definition(name).defaultvalues

    def get_value(self, name, pos, pattern, evaluation):
        rules = self.get_definition(name).get_values_list(valuesname(pos))
        for rule in rules:
            result = rule.apply(pattern, evaluation)
            if result is not None:
                return result

    def get_user_definition(self, name, create=True):
        if self.autoload_stage:
            existing = self.builtin.get(name)
            if existing is None:
                if not create:
                    return None
                self.builtin[name] = Definition(name=name, attributes=set())
                return self.builtin[name]

        existing = self.user.get(name)
        if existing:
            return existing
        else:
            if not create:
                return None
            builtin = self.builtin.get(name)
            if builtin:
                attributes = builtin.attributes
            else:
                attributes = set()
            self.user[name] = Definition(name=name, attributes=attributes)
            return self.user[name]

    def reset_user_definition(self, name):
        del self.user[name]

    def add_user_definition(self, name, definition):
        self.user[name] = definition

    def set_attribute(self, name, attribute):
        definition = self.get_user_definition(name)
        definition.attributes.add(attribute)

    def set_attributes(self, name, attributes):
        definition = self.get_user_definition(name)
        definition.attributes = set(attributes)

    def clear_attribute(self, name, attribute):
        definition = self.get_user_definition(name)
        if attribute in definition.attributes:
            definition.attributes.remove(attribute)

    def add_rule(self, name, rule, position=None):
        if position is None:
            return self.get_user_definition(name).add_rule(rule)
        else:
            return self.get_user_definition(name).add_rule_at(rule, position)

    def add_format(self, name, rule, form=''):
        definition = self.get_user_definition(name)
        if isinstance(form, tuple) or isinstance(form, list):
            forms = form
        else:
            forms = [form]
        for form in forms:
            if form not in definition.formatvalues:
                definition.formatvalues[form] = []
            insert_rule(definition.formatvalues[form], rule)

    def add_nvalue(self, name, rule):
        definition = self.get_user_definition(name)
        definition.add_rule_at(rule, 'n')

    def add_default(self, name, rule):
        definition = self.get_user_definition(name)
        definition.add_rule_at(rule, 'default')

    def add_message(self, name, rule):
        definition = self.get_user_definition(name)
        definition.add_rule_at(rule, 'messages')

    def set_values(self, name, values, rules):
        pos = valuesname(values)
        definition = self.get_user_definition(name)
        definition.set_values_list(pos, rules)

    def get_options(self, name):
        return self.get_definition(name).options

    def reset_user_definitions(self):
        self.user = {}

    def get_user_definitions(self):
        return base64.b64encode(pickle.dumps(self.user, protocol=pickle.HIGHEST_PROTOCOL))

    def set_user_definitions(self, definitions):
        if definitions:
            self.user = pickle.loads(base64.b64decode(definitions))
        else:
            self.user = {}

    def get_ownvalue(self, name):
        ownvalues = self.get_definition(name).ownvalues
        if ownvalues:
            return ownvalues[0]
        return None

    def set_ownvalue(self, name, value):
        from expression import Symbol
        from rules import Rule

        self.add_rule(name, Rule(Symbol(name), value))

    def set_options(self, name, options):
        definition = self.get_user_definition(name)
        definition.options = options

    def unset(self, name, expr):
        definition = self.get_user_definition(name)
        return definition.remove_rule(expr)


def get_tag_position(pattern, name):
    if pattern.get_name() == name:
        return 'own'
    elif pattern.is_atom():
        return None
    else:
        head_name = pattern.get_head_name()
        if head_name == name:
            return 'down'
        elif head_name == 'Condition' and len(pattern.leaves) > 0:
            return get_tag_position(pattern.leaves[0], name)
        elif pattern.get_lookup_name() == name:
            return 'sub'
        else:
            for leaf in pattern.leaves:
                if leaf.get_lookup_name() == name:
                    return 'up'
        return None


def insert_rule(values, rule):
    for index, existing in enumerate(values):
        if existing.pattern.same(rule.pattern):
            del values[index]
            break
    values.insert(0, rule)
    values.sort()


class Definition(object):
    def __init__(self, name, rules=None, ownvalues=None, downvalues=None,
                 subvalues=None, upvalues=None, formatvalues=None,
                 messages=None, attributes=(), options=None, nvalues=None,
                 defaultvalues=None, builtin=None, context='Global`'):

        super(Definition, self).__init__()
        self.name = name

        if rules is None:
            rules = []
        if ownvalues is None:
            ownvalues = []
        if downvalues is None:
            downvalues = []
        if subvalues is None:
            subvalues = []
        if upvalues is None:
            upvalues = []
        if formatvalues is None:
            formatvalues = {}
        if options is None:
            options = {}
        if nvalues is None:
            nvalues = []
        if defaultvalues is None:
            defaultvalues = []
        if messages is None:
            messages = []

        self.ownvalues = ownvalues
        self.downvalues = downvalues
        self.subvalues = subvalues
        self.upvalues = upvalues
        for rule in rules:
            self.add_rule(rule)
        self.formatvalues = dict((name, list)
                                 for name, list in formatvalues.items())
        self.messages = messages
        self.attributes = set(attributes)
        self.options = options
        self.nvalues = nvalues
        self.defaultvalues = defaultvalues
        self.builtin = builtin
        self.context = context

    def get_values_list(self, pos):
        if pos == 'messages':
            return self.messages
        else:
            return getattr(self, '%svalues' % pos)

    def set_values_list(self, pos, rules):
        if pos == 'messages':
            self.messages = rules
        else:
            setattr(self, '%svalues' % pos, rules)

    def add_rule_at(self, rule, position):
        values = self.get_values_list(position)
        insert_rule(values, rule)
        return True

    def add_rule(self, rule):
        pos = get_tag_position(rule.pattern, self.name)
        if pos:
            return self.add_rule_at(rule, pos)
        return False

    def remove_rule(self, lhs):
        position = get_tag_position(lhs, self.name)
        if position:
            values = self.get_values_list(position)
            for index, existing in enumerate(values):
                if existing.pattern.expr.same(lhs):
                    del values[index]
                    return True
        return False

    def __repr__(self):
        s = (
            u'<Definition: name: %s, '
            u'downvalues: %s, formats: %s, attributes: %s>') % (
                self.name, self.downvalues, self.formatvalues, self.attributes)
        return s.encode('unicode_escape')

########NEW FILE########
__FILENAME__ = evaluation
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import cPickle as pickle
import interruptingcow

from mathics import settings

FORMATS = ['StandardForm', 'FullForm', 'TraditionalForm',
           'OutputForm', 'InputForm',
           'TeXForm', 'MathMLForm',
           'MatrixForm', 'TableForm']


class EvaluationInterrupt(Exception):
    pass


class AbortInterrupt(EvaluationInterrupt):
    pass


class TimeoutInterrupt(EvaluationInterrupt):
    pass


class ReturnInterrupt(EvaluationInterrupt):
    pass


class BreakInterrupt(EvaluationInterrupt):
    pass


class ContinueInterrupt(EvaluationInterrupt):
    pass


class Out(object):
    def __init__(self):
        self.is_message = False
        self.is_print = False
        self.text = ''


class Message(Out):
    def __init__(self, symbol, tag, text):
        super(Message, self).__init__()
        self.is_message = True
        self.symbol = symbol
        self.tag = tag
        self.text = text

    def __str__(self):
        return ' : ' + self.text

    def __cmp__(self, other):
        if self.is_message == other.is_message and self.text == other.text:
            return 0
        else:
            return 1

    def get_data(self):
        return {
            'message': True,
            'symbol': self.symbol,
            'tag': self.tag,
            'prefix': u'%s::%s' % (self.symbol, self.tag),
            'text': self.text,
        }


class Print(Out):
    def __init__(self, text):
        super(Print, self).__init__()
        self.is_print = True
        self.text = text

    def __str__(self):
        return ' | ' + self.text

    def __cmp__(self, other):
        if self.is_message == other.is_message and self.text == other.text:
            return 0
        else:
            return 1

    def get_data(self):
        return {
            'message': False,
            'text': self.text,
        }


class Result(object):
    def __init__(self, out, result, line_no):
        self.out = out
        self.result = result
        self.line_no = line_no

    def get_data(self):
        return {
            'out': [out.get_data() for out in self.out],
            'result': self.result,
            'line': self.line_no,
        }


class Evaluation(object):
    def __init__(self, input=None, definitions=None, timeout=None,
                 out_callback=None, format='text', catch_interrupt=True):
        from mathics.core.definitions import Definitions

        if definitions is None:
            definitions = Definitions()
        self.definitions = definitions
        self.recursion_depth = 0
        self.timeout = False
        self.stopped = False
        self.out = []
        self.out_callback = out_callback
        self.listeners = {}
        self.options = None

        self.quiet_all = False
        self.quiet_messages = set()

        self.format = format

        queries = []
        last_parse_error = None
        if input is not None:
            from mathics.core.parser import parse, TranslateError

            lines = input.splitlines()
            query = ''
            for line in lines:
                if line:
                    query += line
                    try:
                        expression = parse(query)
                        if expression is not None:
                            queries.append(expression)
                        query = ''
                        last_parse_error = None
                    except TranslateError, exc:
                        last_parse_error = exc
                else:
                    query += ' '

        self.results = []

        for query in queries:
            self.recursion_depth = 0
            self.timeout = False
            self.stopped = False

            from mathics.core.expression import Symbol, Expression, Integer
            from mathics.core.rules import Rule

            line_no = self.get_config_value('$Line', 0)
            line_no += 1
            self.definitions.set_ownvalue('$Line', Integer(line_no))

            history_length = self.get_config_value('$HistoryLength', 100)
            if history_length is None or history_length > 100:
                history_length = 100

            def evaluate():
                if history_length > 0:
                    self.definitions.add_rule('In', Rule(
                        Expression('In', line_no), query))
                result = query.evaluate(self)
                if history_length > 0:
                    stored_result = self.get_stored_result(result)
                    self.definitions.add_rule('Out', Rule(
                        Expression('Out', line_no), stored_result))
                if result != Symbol('Null'):
                    return self.format_output(result)
                else:
                    return None

            try:
                result = None
                exc_result = None
                try:
                    if timeout is None:
                        result = evaluate()
                    else:
                        with interruptingcow.timeout(timeout, TimeoutInterrupt):
                            result = evaluate()
                except KeyboardInterrupt:
                    if catch_interrupt:
                        exc_result = Symbol('$Aborted')
                    else:
                        raise
                except ValueError, exc:
                    text = unicode(exc)
                    if (text == 'mpz.pow outrageous exponent' or    # noqa
                        text == 'mpq.pow outrageous exp num'):
                        self.message('General', 'ovfl')
                        exc_result = Expression('Overflow')
                    else:
                        raise
                except OverflowError:
                    self.message('General', 'ovfl')
                    exc_result = Expression('Overflow')
                except BreakInterrupt:
                    self.message('Break', 'nofdw')
                    exc_result = Expression('Hold', Expression('Break'))
                except ContinueInterrupt:
                    self.message('Continue', 'nofdw')
                    exc_result = Expression('Hold', Expression('Continue'))
                except TimeoutInterrupt:
                    self.stopped = False
                    self.timeout = True
                    self.message('General', 'timeout')
                    exc_result = Symbol('$Aborted')
                except AbortInterrupt:  # , error:
                    exc_result = Symbol('$Aborted')
                if exc_result is not None:
                    self.recursion_depth = 0
                    result = self.format_output(exc_result)

                self.results.append(Result(self.out, result, line_no))
                self.out = []
            finally:
                self.stop()

            history_length = self.get_config_value('$HistoryLength', 100)
            if history_length is None or history_length > 100:
                history_length = 100
            line = line_no - history_length
            while line > 0:
                unset_in = self.definitions.unset('In', Expression('In', line))
                unset_out = self.definitions.unset(
                    'Out', Expression('Out', line))
                if not (unset_in or unset_out):
                    break
                line -= 1

        if last_parse_error is not None:
            self.recursion_depth = 0
            self.stopped = False
            self.message('General', 'syntax', unicode(last_parse_error))
            self.results.append(Result(self.out, None, None))

    def get_stored_result(self, result):
        from mathics.core.expression import Symbol

        # Remove outer format
        if result.has_form(FORMATS, 1):
            result = result.leaves[0]

        # Prevent too large results from being stored, as this can exceed the
        # DB's max_allowed_packet size
        data = pickle.dumps(result)
        if len(data) > 10000:
            return Symbol('Null')
        return result

    def stop(self):
        self.stopped = True

    def format_output(self, expr):
        from mathics.core.expression import Expression, String, BoxError

        if self.format == 'text':
            result = expr.format(self, 'OutputForm')
        elif self.format == 'xml':
            result = Expression(
                'StandardForm', expr).format(self, 'MathMLForm')
        elif self.format == 'tex':
            result = Expression('StandardForm', expr).format(self, 'TeXForm')
        else:
            raise ValueError
        try:
            boxes = result.boxes_to_text(evaluation=self)
        except BoxError:
            self.message('General', 'notboxes', String('%s' % result))
            boxes = None
        return boxes

    def message(self, symbol, tag, *args):
        from mathics.core.expression import (String, Symbol, Expression,
                                             from_python)

        if (symbol, tag) in self.quiet_messages or self.quiet_all:
            return

        if settings.DEBUG_PRINT:
            print 'MESSAGE: %s::%s (%s)' % (symbol, tag, args)

        pattern = Expression('MessageName', Symbol(symbol), String(tag))
        text = self.definitions.get_value(symbol, 'Messages', pattern, self)
        if text is None:
            pattern = Expression('MessageName', Symbol('General'), String(tag))
            text = self.definitions.get_value(
                'General', 'Messages', pattern, self)

        if text is None:
            text = String("Message %s::%s not found." % (symbol, tag))

        text = self.format_output(Expression(
            'StringForm', text, *(from_python(arg) for arg in args)))

        self.out.append(Message(symbol, tag, text))
        if self.out_callback:
            self.out_callback(self.out[-1])

    def print_out(self, text):
        from mathics.core.expression import from_python

        text = self.format_output(from_python(text))

        self.out.append(Print(text))
        if self.out_callback:
            self.out_callback(self.out[-1])
        if settings.DEBUG_PRINT:
            print 'OUT: ' + text

    def error(self, symbol, tag, *args):
        # Temporarily reset the recursion limit, to allow the message being
        # formatted
        self.recursion_depth, depth = 0, self.recursion_depth
        try:
            self.message(symbol, tag, *args)
        finally:
            self.recursion_depth = depth
        raise AbortInterrupt

    def error_args(self, symbol, given, *needed):
        self.message_args(symbol, given, *needed)
        raise AbortInterrupt

    def message_args(self, symbol, given, *needed):
        from mathics.core.expression import Symbol

        if len(needed) == 1:
            needed = needed[0]
            if given > 1 and needed > 1:
                self.message(symbol, 'argrx', Symbol(symbol), given, needed)
            elif given == 1:
                self.message(symbol, 'argr', Symbol(symbol), needed)
            elif needed == 1:
                self.message(symbol, 'argx', Symbol(symbol), given)
        elif len(needed) == 2:
            if given == 1:
                self.message(symbol, 'argtu', Symbol(symbol), *needed)
            else:
                self.message(symbol, 'argt', Symbol(symbol), *needed)
        else:
            raise NotImplementedError

    def check_stopped(self):
        if self.stopped:
            raise TimeoutInterrupt

    def get_config_value(self, name, default=None):
        # Infinity -> None, otherwise returns integer

        # Temporarily reset the recursion limit, to allow the evaluation
        # $RecursionLimit and the possible message formatting to use some
        # recursion.
        # self.recursion_depth, depth = 0, self.recursion_depth
        value = self.definitions.get_definition(name).ownvalues
        if value:
            try:
                value = value[0].replace
            except AttributeError:
                return None
            if value.get_name() == 'Infinity':
                return None

            return int(value.get_int_value())
        else:
            return default

    def set_config_value(self, name, new_value):
        from mathics.core.expression import Integer

        self.definitions.set_ownvalue(name, Integer(new_value))

    def inc_recursion_depth(self):
        self.check_stopped()

        limit = self.get_config_value(
            '$RecursionLimit', settings.MAX_RECURSION_DEPTH)
        if limit is not None:
            if limit < 20:
                limit = 20
            self.recursion_depth += 1
            if self.recursion_depth > limit:
                self.error('$RecursionLimit', 'reclim', limit)

    def dec_recursion_depth(self):
        self.recursion_depth -= 1

    def add_listener(self, tag, listener):
        existing = self.listeners.get(tag)
        if existing is None:
            existing = self.listeners[tag] = []
        existing.insert(0, listener)

    def remove_listener(self, tag, listener):
        self.listeners.get(tag).remove(listener)

    def publish(self, tag, *args, **kwargs):
        listeners = self.listeners.get(tag, [])
        for listener in listeners:
            if listener(*args, **kwargs):
                break

########NEW FILE########
__FILENAME__ = expression
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sympy
import sympy.mpmath as mpmath
import re

from mathics.core.numbers import get_type, dps, prec, min_prec
from mathics.core.convert import sympy_symbol_prefix, SympyExpression


class BoxError(Exception):
    def __init__(self, box, form):
        super(BoxError, self).__init__(
            'Box %s cannot be formatted as %s' % (box, form))
        self.box = box
        self.form = form


class NumberError(Exception):
    def __init__(self, value):
        super(NumberError, self).__init__()


class ExpressionPointer(object):
    def __init__(self, parent, position):
        self.parent = parent
        self.position = position

    def replace(self, new):
        if self.position == 0:
            self.parent.head = new
        else:
            self.parent.leaves[self.position - 1] = new

    def __str__(self):
        return u'%s[[%s]]' % (self.parent, self.position)


def from_python(arg):
    number_type = get_type(arg)
    if isinstance(arg, (int, long)) or number_type == 'z':
        return Integer(arg)
    elif isinstance(arg, float) or number_type == 'f':
        return Real(arg)
    elif number_type == 'q':
        return Rational(arg)
    elif isinstance(arg, complex) or number_type == 'c':
        return Complex(arg.real, arg.imag)
    elif isinstance(arg, basestring):
        return String(arg)
        # if arg[0] == arg[-1] == '"':
        #     return String(arg[1:-1])
        # else:
        #     return Symbol(arg)
    elif isinstance(arg, BaseExpression):
        return arg
    elif isinstance(arg, list) or isinstance(arg, tuple):
        return Expression('List', *[from_python(leaf) for leaf in arg])
    else:
        raise NotImplementedError


class BaseExpression(object):
    def __init__(self, *args, **kwargs):
        super(BaseExpression, self).__init__()

        self.options = None

        # For parsing purposes (could in fact be stored only for parsed
        # expressions):
        self.parenthesized = False

        self.pattern_sequence = False

        self.unformatted = self

    def get_attributes(self, definitions):
        return set()

    def evaluate(self, evaluation):
        evaluation.check_stopped()
        return self

    def get_atoms(self, include_heads=True):
        return []

    def get_name(self):
        " Returns symbol's name if Symbol instance "

        return ''

    def is_symbol(self):
        return False

    def get_lookup_name(self):
        " Returns symbol name of leftmost head "

        return self.get_name()

    def get_head(self):
        return None

    def get_head_name(self):
        return self.get_head().get_name()

    def get_leaves(self):
        return []

    def get_int_value(self):
        return None

    def get_real_value(self):
        return None

    def get_string_value(self):
        return None

    def is_atom(self):
        return False

    def is_true(self):
        return False

    def is_numeric(self):
        # used by NumericQ and expression ordering
        return False

    def flatten(self, head, pattern_only=False, callback=None):
        return self

    def __hash__(self):
        """
        To allow usage of expression as dictionary keys,
        as in Expression.get_pre_choices
        """

        return hash(unicode(self))

    def __cmp__(self, other):
        if not hasattr(other, 'get_sort_key'):
            return False
        return cmp(self.get_sort_key(), other.get_sort_key())

    def same(self, other):
        pass

    def is_sequence(self):
        return self.get_head_name() == 'Sequence'

    def get_sequence(self):
        if self.get_head().get_name() == 'Sequence':
            return self.leaves
        else:
            return [self]

    def evaluate_leaves(self, evaluation):
        return self

    def apply_rules(self, rules, evaluation):
        for rule in rules:
            result = rule.apply(self, evaluation, fully=False)
            if result is not None:
                return result, True
        return self, False

    def do_format(self, evaluation, form):
        formats = ('InputForm', 'OutputForm', 'StandardForm',
                   'FullForm', 'TraditionalForm', 'TeXForm', 'MathMLForm')

        evaluation.inc_recursion_depth()
        try:
            expr = self
            head = self.get_head_name()
            include_form = False
            if head in formats and len(self.get_leaves()) == 1:
                expr = self.leaves[0]
                if not (form == 'OutputForm' and head == 'StandardForm'):
                    form = head

                    include_form = True
            unformatted = expr

            def format_expr(expr):
                if not(expr.is_atom()) and not(expr.head.is_atom()):
                    # expr is of the form f[...][...]
                    name = ''
                else:
                    name = expr.get_lookup_name()
                formats = evaluation.definitions.get_formats(name, form)
                for rule in formats:
                    result = rule.apply(expr, evaluation)
                    if result is not None and result != expr:
                        # print rule
                        return result.evaluate(evaluation)
                return None

            if form != 'FullForm':
                formatted = format_expr(expr)
                if formatted is not None:
                    result = formatted.do_format(evaluation, form)
                    if include_form:
                        result = Expression(form, result)
                    result.unformatted = unformatted
                    return result

                head = expr.get_head_name()
                if head in formats:
                    expr = expr.do_format(evaluation, form)
                elif (head != 'FullForm' and not expr.is_atom() and
                      head != 'Graphics'):
                    new_leaves = [leaf.do_format(evaluation, form)
                                  for leaf in expr.leaves]
                    expr = Expression(
                        expr.head.do_format(evaluation, form), *new_leaves)

            if include_form:
                expr = Expression(form, expr)
            expr.unformatted = unformatted
            return expr
        finally:
            evaluation.dec_recursion_depth()

    def format(self, evaluation, form):
        expr = self.do_format(evaluation, form)
        result = Expression(
            'MakeBoxes', expr, Symbol(form)).evaluate(evaluation)
        return result

    def is_free(self, form, evaluation):
        from mathics.core.pattern import StopGenerator

        class StopGenerator_BaseExpression_is_free(StopGenerator):
            pass

        # for vars, rest in form.match(self, {}, evaluation, fully=False):
        def yield_match(vars, rest):
            raise StopGenerator_BaseExpression_is_free(False)
            # return False
        try:
            form.match(yield_match, self, {}, evaluation, fully=False)
        except StopGenerator_BaseExpression_is_free, exc:
            return exc.value
        if self.is_atom():
            return True
        else:
            return self.head.is_free(form, evaluation) and all(
                leaf.is_free(form, evaluation) for leaf in self.leaves)

    def post_parse(self):
        return self

    def is_inexact(self):
        return self.get_precision() is not None

    def get_precision(self):
        return None

    def get_option_values(self, evaluation, allow_symbols=False,
                          stop_on_error=True):
        options = self
        if options.has_form('List', None):
            options = options.flatten(Symbol('List'))
            values = options.leaves
        else:
            values = [options]
        option_values = {}
        for option in values:
            symbol_name = option.get_name()
            if allow_symbols and symbol_name:
                options = evaluation.definitions.get_options(symbol_name)
                option_values.update(options)
            else:
                if not option.has_form(('Rule', 'RuleDelayed'), 2):
                    if stop_on_error:
                        return None
                    else:
                        continue
                name = option.leaves[0].get_name()
                if not name:
                    if stop_on_error:
                        return None
                    else:
                        continue
                option_values[name] = option.leaves[1]
        return option_values

    def get_rules_list(self):
        from mathics.core.rules import Rule

        list_expr = self.flatten(Symbol('List'))
        list = []
        if list_expr.has_form('List', None):
            list.extend(list_expr.leaves)
        else:
            list.append(list_expr)
        rules = []
        for item in list:
            if not item.has_form(('Rule', 'RuleDelayed'), 2):
                return None
            rule = Rule(item.leaves[0], item.leaves[1])
            rules.append(rule)
        return rules

    def to_number(self, min=None, max=None, n_evaluation=None):
        if n_evaluation is not None:
            value = Expression('N', self).evaluate(n_evaluation)
        else:
            value = self
        number = value.get_real_value()
        if number is None:
            raise NumberError(self)
        if min is not None and number < min:
            number = min
        if max is not None and number > max:
            number = max
        return float(number)

    def to_sympy(self, **kwargs):
        raise NotImplementedError


class Monomial(object):
    """
    An object to sort monomials, used in Expression.get_sort_key and
    Symbol.get_sort_key.
    """

    def __init__(self, exps_dict):
        self.exps = exps_dict

    def __cmp__(self, other):
        return self.__cmp(other)

    def __cmp(self, other):
        self_exps = self.exps.copy()
        other_exps = other.exps.copy()
        for var in self.exps:
            if var in other.exps:
                dec = min(self_exps[var], other_exps[var])
                self_exps[var] -= dec
                if not self_exps[var]:
                    del self_exps[var]
                other_exps[var] -= dec
                if not other_exps[var]:
                    del other_exps[var]
        self_exps = sorted((var, exp) for var, exp in self_exps.iteritems())
        other_exps = sorted((var, exp) for var, exp in other_exps.iteritems())

        index = 0
        self_len = len(self_exps)
        other_len = len(other_exps)
        while True:
            if index >= self_len and index >= other_len:
                return 0
            if index >= self_len:
                return -1   # self < other
            if index >= other_len:
                return 1    # self > other
            self_var, self_exp = self_exps[index]
            other_var, other_exp = other_exps[index]
            var_cmp = cmp(self_var, other_var)
            if var_cmp != 0:
                return var_cmp
            if self_exp != other_exp:
                if index + 1 == self_len or index + 1 == other_len:
                    # smaller exponents first
                    return cmp(self_exp, other_exp)
                else:
                    # bigger exponents first
                    return -cmp(self_exp, other_exp)
            index += 1
        return 0


class Expression(BaseExpression):
    def __init__(self, head, *leaves, **kwargs):
        super(Expression, self).__init__(**kwargs)
        if isinstance(head, basestring):
            head = Symbol(head)
        self.head = head
        self.leaves = [from_python(leaf) for leaf in leaves]

        self.parse_operator = kwargs.get('parse_operator')
        self.is_evaluated = False

    def copy(self):
        result = Expression(
            self.head.copy(), *[leaf.copy() for leaf in self.leaves])
        result.options = self.options
        result.original = self
        return result

    def set_positions(self, position=None):
        self.position = position
        self.head.set_positions(ExpressionPointer(self, 0))
        for index, leaf in enumerate(self.leaves):
            leaf.set_positions(ExpressionPointer(self, index + 1))

    def get_head(self):
        return self.head

    def get_leaves(self):
        return self.leaves

    def get_lookup_name(self):
        return self.head.get_lookup_name()

    def has_form(self, heads, *leaf_counts):
        """
        leaf_counts:
            (,):        no leaves allowed
            (None,):    no constraint on number of leaves
            (n, None):  leaf count >= n
            (n1, n2, ...):    leaf count in {n1, n2, ...}
        """

        head_name = self.head.get_name()
        if isinstance(heads, (tuple, list, set)):
            if not head_name in heads:
                return False
        else:
            if head_name != heads:
                return False
        if not leaf_counts:
            return False
        if leaf_counts and leaf_counts[0] is not None:
            count = len(self.leaves)
            if count not in leaf_counts:
                if (len(leaf_counts) == 2 and   # noqa
                    leaf_counts[1] is None and count >= leaf_counts[0]):
                    return True
                else:
                    return False
        return True

    def has_symbol(self, symbol_name):
        return self.head.has_symbol(symbol_name) or any(
            leaf.has_symbol(symbol_name) for leaf in self.leaves)

    def to_sympy(self, **kwargs):
        from mathics.builtin import mathics_to_sympy

        if 'converted_functions' in kwargs:
            functions = kwargs['converted_functions']
            if len(self.leaves) > 0 and self.get_head_name() in functions:
                sym_args = [leaf.to_sympy() for leaf in self.leaves]
                func = sympy.Function(str(
                    sympy_symbol_prefix + self.get_head_name()))(*sym_args)
                return func

        lookup_name = self.get_lookup_name()
        builtin = mathics_to_sympy.get(lookup_name)
        if builtin is not None:
            sympy_expr = builtin.to_sympy(self, **kwargs)
            if sympy_expr is not None:
                return sympy_expr

        return SympyExpression(self)

    def to_python(self, *args, **kwargs):
        """
        Convert the Expression to a Python object:
        List[...]  -> Python list
        DirectedInfinity[1] -> inf
        DirectedInfinity[-1] -> -inf
        True/False -> True/False
        Null       -> None
        Symbol     -> '...'
        String     -> '"..."'
        numbers    -> Python number
        If kwarg n_evaluation is given, apply N first to the expression.
        """

        n_evaluation = kwargs.get('n_evaluation')
        if n_evaluation is not None:
            value = Expression('N', self).evaluate(n_evaluation)
            return value.to_python()
        head_name = self.head.get_name()
        if head_name == 'List':
            return [leaf.to_python(*args, **kwargs) for leaf in self.leaves]
        if head_name == 'DirectedInfinity' and len(self.leaves) == 1:
            direction = self.leaves[0].get_int_value()
            if direction == 1:
                return float('inf')
            if direction == -1:
                return -float('inf')
        return self

    def get_sort_key(self, pattern_sort=False):

        if pattern_sort:
            """
            Pattern sort key structure:
            0: 0/2:        Atom / Expression
            1: pattern:    0 / 11-31 for blanks / 1 for empty Alternatives /
                               40 for OptionsPattern
            2: 0/1:        0 for PatternTest
            3: 0/1:        0 for Pattern
            4: 0/1:        1 for Optional
            5: head / 0 for atoms
            6: leaves / 0 for atoms
            7: 0/1:        0 for Condition
            """

            name = self.head.get_name()
            pattern = 0
            if name == 'Blank':
                pattern = 1
            elif name == 'BlankSequence':
                pattern = 2
            elif name == 'BlankNullSequence':
                pattern = 3
            if pattern > 0:
                if self.leaves:
                    pattern += 10
                else:
                    pattern += 20
            if pattern > 0:
                return [2, pattern, 1, 1, 0, self.head.get_sort_key(True),
                        [leaf.get_sort_key(True) for leaf in self.leaves], 1]

            if name == 'PatternTest':
                if len(self.leaves) != 2:
                    return [3, 0, 0, 0, 0, self.head, self.leaves, 1]
                sub = self.leaves[0].get_sort_key(True)
                sub[2] = 0
                return sub
            elif name == 'Condition':
                if len(self.leaves) != 2:
                    return [3, 0, 0, 0, 0, self.head, self.leaves, 1]
                sub = self.leaves[0].get_sort_key(True)
                sub[7] = 0
                return sub
            elif name == 'Pattern':
                if len(self.leaves) != 2:
                    return [3, 0, 0, 0, 0, self.head, self.leaves, 1]
                sub = self.leaves[1].get_sort_key(True)
                sub[3] = 0
                return sub
            elif name == 'Optional':
                if len(self.leaves) not in (1, 2):
                    return [3, 0, 0, 0, 0, self.head, self.leaves, 1]
                sub = self.leaves[0].get_sort_key(True)
                sub[4] = 1
                return sub
            elif name == 'Alternatives':
                min_key = [4]
                min = None
                for leaf in self.leaves:
                    key = leaf.get_sort_key(True)
                    if key < min_key:
                        min = leaf
                        min_key = key
                if min is None:
                    # empty alternatives -> very restrictive pattern
                    return [2, 1]
                return min_key
            elif name == 'Verbatim':
                if len(self.leaves) != 1:
                    return [3, 0, 0, 0, 0, self.head, self.leaves, 1]
                return self.leaves[0].get_sort_key(True)
            elif name == 'OptionsPattern':
                return [2, 40, 0, 1, 1, 0, self.head, self.leaves, 1]
            else:
                # Append (4,) to leaves so that longer expressions have higher
                # precedence
                result = [
                    2, 0, 1, 1, 0, self.head.get_sort_key(True),
                    [leaf.get_sort_key(True) for leaf in self.leaves] + [(4,)],
                    1]
                return result
        else:
            exps = {}
            head = self.head.get_name()
            if head == 'Times':
                for leaf in self.leaves:
                    name = leaf.get_name()
                    if leaf.has_form('Power', 2):
                        var = leaf.leaves[0].get_name()
                        exp = leaf.leaves[1].get_real_value()
                        if var and exp is not None:
                            exps[var] = exps.get(var, 0) + exp
                    elif name:
                        exps[name] = exps.get(name, 0) + 1
            elif self.has_form('Power', 2):
                var = self.leaves[0].get_name()
                exp = self.leaves[1].get_real_value()
                if var and exp is not None:
                    exps[var] = exps.get(var, 0) + exp
            if exps:
                return [1 if self.is_numeric() else 2, 2, Monomial(exps), 1,
                        self.head, self.leaves, 1]
            else:
                return [1 if self.is_numeric() else 2, 3, self.head,
                        self.leaves, 1]

    def same(self, other):
        if self.get_head_name() != other.get_head_name():
            return False
        if not self.head.same(other.get_head()):
            return False
        if len(self.leaves) != len(other.get_leaves()):
            return False
        for leaf, other in zip(self.leaves, other.get_leaves()):
            if not leaf.same(other):
                return False
        return True

    def flatten(self, head, pattern_only=False, callback=None, level=None):
        if level is not None and level <= 0:
            return self
        sub_level = None if level is None else level - 1
        do_flatten = False
        for leaf in self.leaves:
            if leaf.get_head() == head and (not pattern_only or
                                            leaf.pattern_sequence):
                do_flatten = True
                break
        if do_flatten:
            new_leaves = []
            for leaf in self.leaves:
                if leaf.get_head() == head and (not pattern_only or
                                                leaf.pattern_sequence):
                    new_leaf = leaf.flatten(head, pattern_only, callback,
                                            level=sub_level)
                    if callback is not None:
                        callback(new_leaf.leaves, leaf)
                    new_leaves.extend(new_leaf.leaves)
                else:
                    new_leaves.append(leaf)
            return Expression(self.head, *new_leaves)
        else:
            return self

    def evaluate(self, evaluation):
        evaluation.inc_recursion_depth()
        old_options = evaluation.options
        if hasattr(self, 'options') and self.options:
            evaluation.options = self.options
        try:
            if self.is_evaluated:
                return self
            head = self.head.evaluate(evaluation)
            attributes = head.get_attributes(evaluation.definitions)
            leaves = self.leaves[:]
            if 'HoldAll' in attributes or 'HoldAllComplete' in attributes:
                eval_range = []
            elif 'HoldFirst' in attributes:
                eval_range = range(1, len(leaves))
            elif 'HoldRest' in attributes:
                if len(leaves) > 0:
                    eval_range = [0]
                else:
                    eval_range = []
            else:
                eval_range = range(len(leaves))

            if 'HoldAllComplete' not in attributes:
                for index, leaf in enumerate(self.leaves):
                    if (leaf.has_form('Evaluate', 1) and    # noqa
                        index not in eval_range):
                        eval_range.append(index)
            eval_range.sort()
            for index in eval_range:
                if not leaves[index].has_form('Unevaluated', 1):
                    leaves[index] = leaves[index].evaluate(evaluation)

            new = Expression(head, *leaves)
            if ('SequenceHold' not in attributes and    # noqa
                'HoldAllComplete' not in attributes):
                new = new.flatten(Symbol('Sequence'))
            leaves = new.leaves

            for leaf in leaves:
                leaf.unevaluated = False
            if not 'HoldAllComplete' in attributes:
                for index, leaf in enumerate(leaves):
                    if leaf.has_form('Unevaluated', 1):
                        leaves[index] = leaf.leaves[0]
                        leaves[index].unevaluated = True

            def flatten_callback(new_leaves, old):
                for leaf in new_leaves:
                    leaf.unevaluated = old.unevaluated

            new = Expression(head, *leaves)
            if 'Flat' in attributes:
                new = new.flatten(new.head, callback=flatten_callback)
            if 'Orderless' in attributes:
                new.sort()

            new.is_evaluated = True
            if 'Listable' in attributes:
                done, threaded = new.thread(evaluation)
                if done:
                    if not threaded.same(new):
                        threaded = threaded.evaluate(evaluation)
                    return threaded
            rules = []
            rules_names = set()
            if not 'HoldAllComplete' in attributes:
                for leaf in leaves:
                    name = leaf.get_lookup_name()
                    if name not in rules_names:
                        rules_names.add(name)
                        rules.extend(evaluation.definitions.get_upvalues(name))
            lookup_name = new.get_lookup_name()
            if lookup_name == new.get_head_name():
                rules += evaluation.definitions.get_downvalues(lookup_name)
            else:
                rules += evaluation.definitions.get_subvalues(lookup_name)
            for rule in rules:
                result = rule.apply(new, evaluation, fully=False)
                if result is not None:
                    if not result.same(new):
                        result = result.evaluate(evaluation)
                    return result

            # Expression did not change, re-apply Unevaluated
            for index, leaf in enumerate(new.leaves):
                if leaf.unevaluated:
                    new.leaves[index] = Expression('Unevaluated', leaf)

            new.unformatted = self.unformatted
            return new

        finally:
            evaluation.options = old_options
            evaluation.dec_recursion_depth()

    def post_parse(self):
        if self.parse_operator is not None:
            return self.parse_operator.post_parse(self)
        else:
            return Expression(self.head.post_parse(),
                              *[leaf.post_parse() for leaf in self.leaves])

    def evaluate_leaves(self, evaluation):
        leaves = [leaf.evaluate(evaluation) for leaf in self.leaves]
        head = self.head.evaluate_leaves(evaluation)
        return Expression(head, *leaves)

    def __str__(self):
        return u'%s[%s]' % (
            self.head, u', '.join([unicode(leaf) for leaf in self.leaves]))

    def __repr__(self):
        # This .encode("unicode_escape") is necessary because Python
        # implicitly calls the equivalent of .encode("ascii") if we
        # return a Unicode string here, which might raise
        # UnicodeEncodeError in awkward places.
        return (u'<Expression: %s>' % self).encode('unicode_escape')

    def process_style_box(self, options):
        if self.has_form('StyleBox', 1, None):
            rules = self.leaves[1:]
            for rule in rules:
                if rule.has_form('Rule', 2):
                    name = rule.leaves[0].get_name()
                    value = rule.leaves[1]
                    if name == 'ShowStringCharacters':
                        value = value.is_true()
                        options = options.copy()
                        options['show_string_characters'] = value
                    elif name == 'ImageSizeMultipliers':
                        if value.has_form('List', 2):
                            m1 = value.leaves[0].get_real_value()
                            m2 = value.leaves[1].get_real_value()
                            if m1 is not None and m2 is not None:
                                options = options.copy()
                                options['image_size_multipliers'] = (m1, m2)
            return True, options
        else:
            return False, options

    def boxes_to_text(self, **options):
        from mathics.builtin import box_constructs
        from mathics.builtin.base import BoxConstructError

        is_style, options = self.process_style_box(options)
        if is_style:
            return self.leaves[0].boxes_to_text(**options)
        head = self.head.get_name()
        box_construct = box_constructs.get(head)
        if box_construct is not None:
            try:
                return box_construct.boxes_to_text(self.leaves, **options)
            except BoxConstructError:
                raise BoxError(self, 'text')
        if (self.has_form('RowBox', 1) and  # nopep8
            self.leaves[0].has_form('List', None)):
            return ''.join([leaf.boxes_to_text(**options)
                            for leaf in self.leaves[0].leaves])
        else:
            raise BoxError(self, 'text')

    def boxes_to_xml(self, **options):
        from mathics.builtin import box_constructs
        from mathics.builtin.base import BoxConstructError

        is_style, options = self.process_style_box(options)
        if is_style:
            return self.leaves[0].boxes_to_xml(**options)
        head = self.head.get_name()
        box_construct = box_constructs.get(head)
        if box_construct is not None:
            try:
                return box_construct.boxes_to_xml(self.leaves, **options)
            except BoxConstructError:
                # raise # uncomment this to see what is going wrong in
                # constructing boxes
                raise BoxError(self, 'xml')
        name = self.head.get_name()
        if (name == 'RowBox' and len(self.leaves) == 1 and  # nopep8
            self.leaves[0].get_head_name() == 'List'):
            result = []
            inside_row = options.get('inside_row')
            # inside_list = options.get('inside_list')
            options = options.copy()

            def is_list_interior(content):
                if (content.has_form('List', None) and
                    all(leaf.get_string_value() == ','
                        for leaf in content.leaves[1::2])):
                    return True
                return False

            is_list_row = False
            if (len(self.leaves[0].leaves) == 3 and     # nopep8
                self.leaves[0].leaves[0].get_string_value() == '{' and
                self.leaves[0].leaves[2].get_string_value() == '}' and
                self.leaves[0].leaves[1].has_form('RowBox', 1)):
                content = self.leaves[0].leaves[1].leaves[0]
                if is_list_interior(content):
                    is_list_row = True

            if not inside_row and is_list_interior(self.leaves[0]):
                is_list_row = True

            if is_list_row:
                options['inside_list'] = True
            else:
                options['inside_row'] = True

            for leaf in self.leaves[0].get_leaves():
                result.append(leaf.boxes_to_xml(**options))
            return '<mrow>%s</mrow>' % ' '.join(result)
        else:
            options = options.copy()
            options['inside_row'] = True
            if name == 'SuperscriptBox' and len(self.leaves) == 2:
                return '<msup>%s %s</msup>' % (
                    self.leaves[0].boxes_to_xml(**options),
                    self.leaves[1].boxes_to_xml(**options))
            if name == 'SubscriptBox' and len(self.leaves) == 2:
                return '<msub>%s %s</msub>' % (
                    self.leaves[0].boxes_to_xml(**options),
                    self.leaves[1].boxes_to_xml(**options))
            if name == 'SubsuperscriptBox' and len(self.leaves) == 3:
                return '<msubsup>%s %s %s</msubsup>' % (
                    self.leaves[0].boxes_to_xml(**options),
                    self.leaves[1].boxes_to_xml(**options),
                    self.leaves[2].boxes_to_xml(**options))
            elif name == 'FractionBox' and len(self.leaves) == 2:
                return '<mfrac>%s %s</mfrac>' % (
                    self.leaves[0].boxes_to_xml(**options),
                    self.leaves[1].boxes_to_xml(**options))
            elif name == 'SqrtBox' and len(self.leaves) == 1:
                return '<msqrt>%s</msqrt>' % (
                    self.leaves[0].boxes_to_xml(**options))
            else:
                raise BoxError(self, 'xml')

    def boxes_to_tex(self, **options):
        from mathics.builtin import box_constructs
        from mathics.builtin.base import BoxConstructError

        def block(tex, only_subsup=False):
            if len(tex) == 1:
                return tex
            else:
                if not only_subsup or '_' in tex or '^' in tex:
                    return '{%s}' % tex
                else:
                    return tex

        is_style, options = self.process_style_box(options)
        if is_style:
            return self.leaves[0].boxes_to_tex(**options)
        head = self.head.get_name()
        box_construct = box_constructs.get(head)
        if box_construct is not None:
            try:
                return box_construct.boxes_to_tex(self.leaves, **options)
            except BoxConstructError:
                raise BoxError(self, 'tex')
        name = self.head.get_name()
        if (name == 'RowBox' and len(self.leaves) == 1 and  # nopep8
            self.leaves[0].get_head_name() == 'List'):
            return ''.join([leaf.boxes_to_tex(**options)
                            for leaf in self.leaves[0].get_leaves()])
        elif name == 'SuperscriptBox' and len(self.leaves) == 2:
            tex1 = self.leaves[0].boxes_to_tex(**options)
            sup_string = self.leaves[1].get_string_value()
            if sup_string == u'\u2032':
                return "%s'" % tex1
            elif sup_string == u'\u2032\u2032':
                return "%s''" % tex1
            else:
                return '%s^%s' % (
                    block(tex1, True),
                    block(self.leaves[1].boxes_to_tex(**options)))
        elif name == 'SubscriptBox' and len(self.leaves) == 2:
            return '%s_%s' % (
                block(self.leaves[0].boxes_to_tex(**options), True),
                block(self.leaves[1].boxes_to_tex(**options)))
        elif name == 'SubsuperscriptBox' and len(self.leaves) == 3:
            return '%s_%s^%s' % (
                block(self.leaves[0].boxes_to_tex(**options), True),
                block(self.leaves[1].boxes_to_tex(**options)),
                block(self.leaves[2].boxes_to_tex(**options)))
        elif name == 'FractionBox' and len(self.leaves) == 2:
            return '\\frac{%s}{%s}' % (
                self.leaves[0].boxes_to_tex(**options),
                self.leaves[1].boxes_to_tex(**options))
        elif name == 'SqrtBox' and len(self.leaves) == 1:
            return '\\sqrt{%s}' % self.leaves[0].boxes_to_tex(**options)
        else:
            raise BoxError(self, 'tex')

    def default_format(self, evaluation, form):
        return '%s[%s]' % (self.head.default_format(evaluation, form),
                           ', '.join([leaf.default_format(evaluation, form)
                                      for leaf in self.leaves]))

    def sort(self, pattern=False):
        " Sort the leaves according to internal ordering. "

        if pattern:
            self.leaves.sort(key=lambda e: e.get_sort_key(pattern_sort=True))
        else:
            self.leaves.sort()

    def filter_leaves(self, head_name):
        # TODO: should use sorting

        return [leaf for leaf in self.leaves
                if leaf.get_head_name() == head_name]

    def apply_rules(self, rules, evaluation):
        """for rule in rules:
            result = rule.apply(self, evaluation, fully=False)
            if result is not None:
                return result"""
        result, applied = super(
            Expression, self).apply_rules(rules, evaluation)
        if applied:
            return result, True
        head, applied = self.head.apply_rules(rules, evaluation)

        # to be able to access it inside inner function
        new_applied = [applied]

        def apply_leaf(leaf):
            new, sub_applied = leaf.apply_rules(rules, evaluation)
            new_applied[0] = new_applied[0] or sub_applied
            return new

        return (Expression(head, *[apply_leaf(leaf) for leaf in self.leaves]),
                new_applied[0])

    def replace_vars(self, vars, options=None,
                     in_scoping=True, in_function=True):
        from mathics.builtin.scoping import get_scoping_vars

        if not in_scoping:
            if (self.head.get_name() in ('Module', 'Block', 'With')  # nopep8
                and len(self.leaves) > 0):
                scoping_vars = set(
                    name for name, new_def in get_scoping_vars(self.leaves[0]))
                """for var in new_vars:
                    if var in scoping_vars:
                        del new_vars[var]"""
                vars = dict((var, value) for var, value in vars.items()
                            if var not in scoping_vars)

        leaves = self.leaves
        if in_function:
            if (self.head.get_name() == 'Function' and len(self.leaves) > 1 and
                (self.leaves[0].has_form('List', None) or
                 self.leaves[0].get_name())):
                if self.leaves[0].get_name():
                    func_params = [self.leaves[0].get_name()]
                else:
                    func_params = [leaf.get_name()
                                   for leaf in self.leaves[0].leaves]
                if '' not in func_params:
                    body = self.leaves[1]
                    replacement = dict((name, Symbol(
                        name + '$')) for name in func_params)
                    func_params = [Symbol(name + '$') for name in func_params]
                    body = body.replace_vars(replacement, options, in_scoping)
                    leaves = [Expression('List', *func_params), body] + \
                        self.leaves[2:]

        return Expression(
            self.head.replace_vars(
                vars, options=options, in_scoping=in_scoping),
            *[leaf.replace_vars(vars, options=options, in_scoping=in_scoping)
              for leaf in leaves])

    def replace_slots(self, slots, evaluation):
        if self.head.get_name() == 'Slot':
            if len(self.leaves) != 1:
                evaluation.message_args('Slot', len(self.leaves), 1)
            else:
                slot = self.leaves[0].get_int_value()
                if slot is None or slot < 0:
                    evaluation.message('Function', 'slot', self.leaves[0])
                elif slot > len(slots) - 1:
                    evaluation.message('Function', 'slotn', slot)
                else:
                    return slots[int(slot)]
        elif self.head.get_name() == 'SlotSequence':
            if len(self.leaves) != 1:
                evaluation.message_args('SlotSequence', len(self.leaves), 1)
            else:
                slot = self.leaves[0].get_int_value()
                if slot is None or slot < 1:
                    evaluation.error('Function', 'slot', self.leaves[0])
            return Expression('Sequence', *slots[slot:])
        elif self.head.get_name() == 'Function' and len(self.leaves) == 1:
            # do not replace Slots in nested Functions
            return self
        return Expression(self.head.replace_slots(slots, evaluation),
                          *[leaf.replace_slots(slots, evaluation)
                            for leaf in self.leaves])

    def thread(self, evaluation, head=None):
        if head is None:
            head = Symbol('List')

        items = []
        dim = None
        for leaf in self.leaves:
            if leaf.get_head() == head:
                if dim is None:
                    dim = len(leaf.leaves)
                    items = [(items + [leaf]) for leaf in leaf.leaves]
                elif len(leaf.leaves) != dim:
                    evaluation.message('Thread', 'tdlen')
                    return True, self
                else:
                    for index in range(dim):
                        items[index].append(leaf.leaves[index])
            else:
                if dim is None:
                    items.append(leaf)
                else:
                    for item in items:
                        item.append(leaf)
        if dim is None:
            return False, self
        else:
            leaves = [Expression(self.head, *item) for item in items]
            return True, Expression(head, *leaves)

    def is_numeric(self):
        return (self.head.get_name() in (
            'Sqrt', 'Times', 'Plus', 'Subtract', 'Minus', 'Power', 'Abs',
            'Divide', 'Sin') and
            all(leaf.is_numeric() for leaf in self.leaves))
        # TODO: complete list of numeric functions, or access NumericFunction
        # attribute

    def numerify(self, evaluation):
        _prec = None
        for leaf in self.leaves:
            if leaf.is_inexact():
                leaf_prec = leaf.get_precision()
                if _prec is None or leaf_prec < _prec:
                    _prec = leaf_prec
        if _prec is not None:
            new_leaves = self.leaves[:]
            for index in range(len(self.leaves)):
                leaf = self.leaves[index]
                # Don't "numerify" numbers: they should be numerified
                # automatically by the processing function,
                # and we don't want to lose exactness in e.g. 1.0+I.
                if not isinstance(leaf, Number):
                    n_expr = Expression('N', leaf, Integer(dps(_prec)))
                    new_leaves[index] = n_expr.evaluate(evaluation)
            return Expression(self.head, *new_leaves)
        else:
            return self

    def get_atoms(self, include_heads=True):
        if include_heads:
            atoms = self.head.get_atoms()
        else:
            atoms = []
        for leaf in self.leaves:
            atoms.extend(leaf.get_atoms())
        return atoms


class Atom(BaseExpression):

    def is_atom(self):
        return True

    def has_form(self, heads, *leaf_counts):
        if leaf_counts:
            return False
        name = self.get_atom_name()
        if isinstance(heads, tuple):
            return name in heads
        else:
            return heads == name

    def has_symbol(self, symbol_name):
        return False

    def get_head(self):
        return Symbol(self.get_atom_name())

    def get_atom_name(self):
        return self.__class__.__name__

    def __repr__(self):
        return (u'<%s: %s>' % (self.get_atom_name(), self)).encode(
            'unicode_escape')

    def replace_vars(self, vars, options=None, in_scoping=True):
        return self

    def replace_slots(self, slots, evaluation):
        return self

    def round(self, prec):
        return self

    def numerify(self, evaluation):
        return self

    def copy(self):
        result = self.do_copy()
        result.original = self
        return result

    def set_positions(self, position=None):
        self.position = position

    def get_sort_key(self, pattern_sort=False):
        if pattern_sort:
            return [0, 0, 1, 1, 0, 0, 0, 1]
        else:
            raise NotImplementedError

    def get_atoms(self, include_heads=True):
        return [self]


class Symbol(Atom):
    def __init__(self, name, sympy_dummy=None, **kwargs):
        super(Symbol, self).__init__(**kwargs)
        self.name = name
        self.sympy_dummy = sympy_dummy

    def __str__(self):
        return self.name

    def do_copy(self):
        return Symbol(self.name)

    def boxes_to_text(self, **options):
        return str(self.name)

    def to_sympy(self, **kwargs):
        from mathics.builtin import mathics_to_sympy

        if self.sympy_dummy is not None:
            return self.sympy_dummy

        builtin = mathics_to_sympy.get(self.name)
        if (builtin is None or not builtin.sympy_name or    # nopep8
            not builtin.is_constant()):
            return sympy.Symbol(sympy_symbol_prefix + self.name.encode('utf8'))
        else:
            return getattr(sympy, builtin.sympy_name)

    def to_python(self, *args, **kwargs):
        if self.name == 'True':
            return True
        if self.name == 'False':
            return False
        if self.name == 'Null':
            return None
        n_evaluation = kwargs.get('n_evaluation')
        if n_evaluation is not None:
            value = Expression('N', self).evaluate(n_evaluation)
            return value.to_python()

        # return name as string (Strings are returned with quotes)
        return self.name

    def default_format(self, evaluation, form):
        return self.name

    def get_attributes(self, definitions):
        return definitions.get_attributes(self.name)

    def get_name(self):
        return self.name

    def is_symbol(self):
        return True

    def get_sort_key(self, pattern_sort=False):
        if pattern_sort:
            return super(Symbol, self).get_sort_key(True)
        else:
            return [1 if self.is_numeric() else 2,
                    2, Monomial({self.name: 1}), 0, self.name, 1]

    def same(self, other):
        return isinstance(other, Symbol) and self.name == other.name

    def replace_vars(self, vars, options={}, in_scoping=True):
        var = vars.get(self.name, None)
        if var is None:
            return self
        else:
            return var

    def has_symbol(self, symbol_name):
        return self.name == symbol_name

    def evaluate(self, evaluation):
        rules = evaluation.definitions.get_ownvalues(self.name)
        for rule in rules:
            result = rule.apply(self, evaluation, fully=True)
            if result is not None and result != self:
                return result.evaluate(evaluation)
        return self

    def is_true(self):
        return self.name == 'True'

    def is_numeric(self):
        return self.name in ('Pi', 'E', 'EulerGamma', 'GoldenRatio',
                             'MachinePrecision', 'Catalan')


class Number(Atom):
    def __str__(self):
        return str(self.value)

    @staticmethod
    def from_string(value):
        if 'I' in value:
            return Complex(value)
        elif '.' in value:
            return Real(value)
        elif '/' in value:
            return Rational(value)
        else:
            return Integer(value)

    @staticmethod
    def from_mp(value, prec=None):
        # assert(value.is_number)
        if isinstance(value, Number):
            if prec is None:
                return value
            return value.round(prec)
        t = get_type(value)
        if t == 'z':
            return Integer(value)
        elif t == 'q':
            return Rational(value)
        elif t == 'f':
            return Real(value, prec)
        elif t == 'c':
            real, imag = value.as_real_imag()
            return Complex(real, imag, prec)

        if isinstance(value, (int, long)):
            return Integer(value)
        elif isinstance(value, float):
            return Real(value)

        raise TypeError('Unknown number type: %s (type %s)' % (
            value, type(value)))

    def is_numeric(self):
        return True


def number_boxes(text):
    assert text is not None
    if text.endswith('.0'):
        text = text[:-1]
    if text.startswith('-'):
        return Expression('RowBox',
                          Expression('List', String('-'), String(text[1:])))
    else:
        return String(text)


class Integer(Number):
    def __init__(self, value, **kwargs):
        super(Integer, self).__init__(**kwargs)
        self.value = int(value)

    def __getstate__(self):
        return {'value': self.value}

    def __setstate__(self, dict):
        self.value = dict['value']

    def boxes_to_text(self, **options):
        return str(self.value)

    def boxes_to_xml(self, **options):
        return self.make_boxes('MathMLForm').boxes_to_xml(**options)

    def boxes_to_tex(self, **options):
        return str(self.value)

    def make_boxes(self, form):
        return number_boxes(str(self.value))

    def default_format(self, evaluation, form):
        return str(self.value)

    def to_sympy(self, **kwargs):
        return sympy.Integer(self.value)

    def to_python(self, *args, **kwargs):
        return self.value

    def get_int_value(self):
        return self.value

    def same(self, other):
        return isinstance(other, Integer) and self.value == other.value

    def evaluate(self, evaluation):
        evaluation.check_stopped()
        return self

    def round(self, precision):
        return Real(sympy.Float(self.value, dps(precision)))

    def get_sort_key(self, pattern_sort=False):
        if pattern_sort:
            return super(Integer, self).get_sort_key(True)
        else:
            return [0, 0, self.value, 0, 1]

    def get_real_value(self):
        return sympy.Rational(self.value, 1)

    def do_copy(self):
        return Integer(self.value)


class Rational(Number):
    def __init__(self, numerator, denominator=None, **kwargs):
        super(Rational, self).__init__(**kwargs)
        self.value = sympy.Rational(numerator, denominator)

    def __getstate__(self):
        return {'value': str(self.value)}

    def __setstate__(self, dict):
        self.value = sympy.Rational(dict['value'])

    def to_sympy(self, **kwargs):
        return self.value

    def to_python(self, *args, **kwargs):
        return float(self.value)

    def same(self, other):
        return isinstance(other, Rational) and self.value == other.value

    def numerator(self):
        return Number.from_mp(self.value.as_numer_denom()[0])

    def denominator(self):
        return Number.from_mp(self.value.as_numer_denom()[1])

    def do_format(self, evaluation, form):
        if form == 'FullForm':
            return Expression(
                Expression('HoldForm', Symbol('Rational')), self.numerator(),
                self.denominator()).do_format(evaluation, form)
        else:
            numerator = self.numerator()
            minus = numerator.value < 0
            if minus:
                numerator = Integer(-numerator.value)
            result = Expression('Divide', numerator, self.denominator())
            if minus:
                result = Expression('Minus', result)
            result = Expression('HoldForm', result)
            return result.do_format(evaluation, form)

    def default_format(self, evaluation, form):
        return 'Rational[%s, %s]' % self.value.as_numer_denom()

    def evaluate(self, evaluation):
        evaluation.check_stopped()
        return self

    def round(self, precision):
        return Real(self.value.n(dps(precision)), precision)

    def get_sort_key(self, pattern_sort=False):
        if pattern_sort:
            return super(Rational, self).get_sort_key(True)
        else:
            # HACK: otherwise "Bus error" when comparing 1==1.
            return [0, 0, sympy.Float(self.value), 0, 1]

    def get_real_value(self):
        from mathics.builtin.numeric import machine_precision
        return self.value.n(machine_precision)

    def do_copy(self):
        return Rational(self.value)


class Real(Number):
    def __init__(self, value, p=None):
        from mathics.builtin.numeric import machine_precision
        super(Real, self).__init__()

        if isinstance(value, basestring):
            value = str(value)
            if p is None:
                digits = (''.join(re.findall('[0-9]+', value))).lstrip('0')
                if digits == '':     # Handle weird Mathematica zero case
                    p = max(prec(len(value.replace('0.', ''))),
                            machine_precision)
                else:
                    p = prec(len(digits.zfill(dps(machine_precision))))
        elif isinstance(value,
                        (Integer, sympy.Number, mpmath.mpf, float, int)):
            value = str(value)
        else:
            raise TypeError('Unknown number type: %s (type %s)' % (
                value, type(value)))
        if p is None:
            p = machine_precision

        self.value = sympy.Float(value, dps(p))
        self.prec = p

    def __getstate__(self):
        p = self.prec
        s = self.value
        return {'value': s, 'prec': p}

    def __setstate__(self, dict):
        # TODO: Check this
        self.prec = dict['prec']
        self.value = dict['value']

    def boxes_to_text(self, **options):
        return self.make_boxes('OutputForm').boxes_to_text(**options)

    def boxes_to_xml(self, **options):
        return self.make_boxes('MathMLForm').boxes_to_xml(**options)

    def boxes_to_tex(self, **options):
        return self.make_boxes('TeXForm').boxes_to_tex(**options)

    def make_boxes(self, form):
        from mathics.builtin.numeric import machine_precision
        if self.to_sympy() == sympy.Float('0.0'):
            if self.prec == machine_precision:
                base, exp = ('0.', '0')
            else:
                base, exp = ('0.', '-' + str(dps(self.prec)))
        else:
            s = str(self.to_sympy())
            if 'e' in s:
                base, exp = map(str, s.split('e'))
            else:
                if self.to_sympy() < 0:
                    prefix = '-'
                    s = s[1:]
                else:
                    prefix = ''
                iexp = s.index('.') - 1
                if -6 < iexp < 6:
                    base, exp = prefix + s, '0'
                else:
                    s = s.replace('.', '') + '0'
                    base = s[0] + '.' + s[1:]
                    base = prefix + base.lstrip('0')
                    exp = str(iexp)
            base, exp = base.rstrip('0'), exp.lstrip('+')
        if exp != '0':
            if form in ('InputForm', 'OutputForm', 'FullForm'):
                return Expression('RowBox', Expression(
                    'List', base, String('*^'), String(exp)))
            else:
                return Expression('RowBox', Expression(
                    'List', base, String(u'\u00d7'),
                    Expression('SuperscriptBox', String('10'), String(exp))))
        else:
            return number_boxes(base)

    def to_sympy(self, **kwargs):
        return self.value

    def to_python(self, *args, **kwargs):
        return float(self.value)

    def same(self, other):
        return isinstance(other, Real) and self.to_sympy() == other.to_sympy()

    def evaluate(self, evaluation):
        evaluation.check_stopped()
        return self

    def round(self, precision):
        return Real(self.to_sympy().n(dps(precision)), precision)

    def get_precision(self):
        return self.prec

    def get_sort_key(self, pattern_sort=False):
        if pattern_sort:
            return super(Real, self).get_sort_key(True)
        return [0, 0, self.value, 0, 1]

    def get_real_value(self):
        return float(self.value)

    def do_copy(self):
        return Real(self.value, self.prec)

    def __cmp__(self, other):
        if isinstance(other, Real):
            # MMA Docs: "Approximate numbers that differ in their last seven
            # binary digits are considered equal"
            _prec = min_prec(self, other) - 7
            return cmp(self.to_sympy().n(dps(_prec)),
                       other.to_sympy().n(dps(_prec)))
        if not hasattr(other, 'get_sort_key'):
            return False
        return cmp(self.get_sort_key(), other.get_sort_key())


class Complex(Number):
    def __init__(self, real, imag, p=None, **kwargs):
        super(Complex, self).__init__(**kwargs)

        if isinstance(real, basestring):
            real = str(real)
            if '.' in real:
                self.real = Real(real, p)
            else:
                self.real = Integer(real)
        elif isinstance(real, Number):
            self.real = real
        else:
            self.real = Number.from_mp(real)

        if isinstance(imag, basestring):
            imag = str(imag)
            if '.' in imag:
                self.imag = Real(imag, p)
            else:
                self.imag = Integer(imag)
        elif isinstance(imag, Number):
            self.imag = imag
        else:
            self.imag = Number.from_mp(imag)

        if p is None:
            p = min_prec(self.real, self.imag)

        if p is not None:
            self.real = self.real.round(p)
            self.imag = self.imag.round(p)

        self.sympy = self.real.to_sympy() + sympy.I * self.imag.to_sympy()
        self.value = (self.real, self.imag)
        self.prec = p

    def to_sympy(self, **kwargs):
        return self.sympy

    def to_python(self, *args, **kwargs):
        return complex(*self.sympy.as_real_imag())

    def do_format(self, evaluation, form):
        if form == 'FullForm':
            return Expression(Expression('HoldForm', Symbol('Complex')),
                              self.real, self.imag).do_format(evaluation, form)

        sum = []
        if not self.real.same(Integer(0)):
            sum.append(self.real)
        if self.imag.same(Integer(1)):
            sum.append(Symbol('I'))
        else:
            sum.append(Expression('Times', self.imag, Symbol('I')))
        if len(sum) == 1:
            sum = sum[0]
        else:
            sum = Expression('Plus', *sum)
        return Expression('HoldForm', sum).do_format(evaluation, form)

    def default_format(self, evaluation, form):
        return 'Complex[%s, %s]' % (self.real.default_format(evaluation, form),
                                    self.imag.default_format(evaluation, form))

    def get_sort_key(self, pattern_sort=False):
        if pattern_sort:
            return super(Complex, self).get_sort_key(True)
        else:
            return [0, 0, self.real.get_sort_key()[2],
                    self.imag.get_sort_key()[2], 1]

    def same(self, other):
        return (isinstance(other, Complex) and self.real == other.real and
                self.imag == other.imag)

    def evaluate(self, evaluation):
        evaluation.check_stopped()
        return self

    def round(self, precision):
        real = self.real.round(precision)
        imag = self.imag.round(precision)
        return Complex(real, imag, precision)

    def get_precision(self):
        return self.prec

    def do_copy(self):
        return Complex(self.real.do_copy(), self.imag.do_copy())


def encode_mathml(text):
    text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
    text = text.replace('"', '&quot;').replace(' ', '&nbsp;')
    return text.replace('\n', '<mspace linebreak="newline" />')

TEX_REPLACE = {
    '{': r'\{',
    '}': r'\}',
    '_': r'\_',
    '$': r'\$',
    '%': r'\%',
    '#': r'\#',
    '&': r'\&',
    '\\': r'\backslash{}',
    '^': r'{}^{\wedge}',
    '~': r'\sim{}',
    '|': r'\vert{}',
}
TEX_TEXT_REPLACE = TEX_REPLACE.copy()
TEX_TEXT_REPLACE.update({
    '<': r'$<$',
    '>': r'$>$',
    '~': r'$\sim$',
    '|': r'$\vert$',
    '\\': r'$\backslash$',
    '^': r'${}^{\wedge}$',
})
TEX_REPLACE_RE = re.compile('([' + ''.join(
    [re.escape(c) for c in TEX_REPLACE]) + '])')


def encode_tex(text, in_text=False):
    def replace(match):
        c = match.group(1)
        repl = TEX_TEXT_REPLACE if in_text else TEX_REPLACE
        # return TEX_REPLACE[c]
        return repl.get(c, c)

    text = TEX_REPLACE_RE.sub(replace, text)
    text = text.replace('\n', '\\newline\n')
    return text

extra_operators = set((',', '(', ')', '[', ']', '{', '}',
                       u'\u301a', u'\u301b', u'\u00d7', u'\u2032',
                       u'\u2032\u2032', ' ', u'\u2062', u'\u222b', u'\u2146'))


class String(Atom):
    def __init__(self, value, **kwargs):
        super(String, self).__init__(**kwargs)
        self.value = value

    def __str__(self):
        return u'"%s"' % self.value

    def boxes_to_text(self, show_string_characters=False, **options):
        value = self.value
        if (not show_string_characters and      # nopep8
            value.startswith('"') and value.endswith('"')):
            value = value[1:-1]
        return value

    def boxes_to_xml(self, show_string_characters=False, **options):
        from mathics.core.parser import is_symbol_name
        from mathics.builtin import builtins

        operators = set()
        for name, builtin in builtins.iteritems():
            operator = builtin.get_operator_display()
            if operator is not None:
                operators.add(operator)

        text = self.value

        if text.startswith('"') and text.endswith('"'):
            if show_string_characters:
                return '<ms>%s</ms>' % encode_mathml(text[1:-1])
            else:
                return '<mtext>%s</mtext>' % encode_mathml(text[1:-1])
        elif text and ('0' <= text[0] <= '9' or text[0] == '.'):
            return '<mn>%s</mn>' % encode_mathml(text)
        else:
            if text in operators or text in extra_operators:
                if text == u'\u2146':
                    return (
                        '<mo form="prefix" lspace="0.2em" rspace="0">%s</mo>'
                        % encode_mathml(text))
                if text == u'\u2062':
                    return (
                        '<mo form="prefix" lspace="0" rspace="0.2em">%s</mo>'
                        % encode_mathml(text))
                return '<mo>%s</mo>' % encode_mathml(text)
            elif is_symbol_name(text):
                return '<mi>%s</mi>' % encode_mathml(text)
            else:
                return '<mtext>%s</mtext>' % encode_mathml(text)

    def boxes_to_tex(self, show_string_characters=False, **options):
        from mathics.builtin import builtins

        operators = set()
        for name, builtin in builtins.iteritems():
            operator = builtin.get_operator_display()
            if operator is not None:
                operators.add(operator)

        text = self.value

        if text.startswith('"') and text.endswith('"'):
            if show_string_characters:
                return r'\text{"%s"}' % encode_tex(text[1:-1], in_text=True)
            else:
                return r'\text{%s}' % encode_tex(text[1:-1], in_text=True)
        elif text and ('0' <= text[0] <= '9' or text[0] == '.'):
            return encode_tex(text)
        else:
            if text == u'\u2032':
                return "'"
            elif text == u'\u2032\u2032':
                return "''"
            elif text == u'\u2062':
                return ' '
            elif text == u'\u221e':
                return r'\infty '
            elif text == u'\u00d7':
                return r'\times '
            elif text in ('(', '[', '{'):
                return r'\left%s' % encode_tex(text)
            elif text in (')', ']', '}'):
                return r'\right%s' % encode_tex(text)
            elif text == u'\u301a':
                return r'\left[\left['
            elif text == u'\u301b':
                return r'\right]\right]'
            elif text == ',' or text == ', ':
                return text
            elif text == u'\u222b':
                return r'\int'
            elif text == u'\u2146':
                return r'\, d'
            elif text == u'\u2211':
                return r'\sum'
            elif text == u'\u220f':
                return r'\prod'
            elif len(text) > 1:
                return r'\text{%s}' % encode_tex(text, in_text=True)
            else:
                return encode_tex(text)

    def do_copy(self):
        return String(self.value)

    def default_format(self, evaluation, form):
        value = self.value.replace('\\', '\\\\').replace('"', '\\"')
        return u'"%s"' % value

    def get_sort_key(self, pattern_sort=False):
        if pattern_sort:
            return super(String, self).get_sort_key(True)
        else:
            return [0, 1, self.value, 0, 1]

    def same(self, other):
        return isinstance(other, String) and self.value == other.value

    def get_string_value(self):
        return self.value

    def to_sympy(self, **kwargs):
        return self.value

    def to_python(self, *args, **kwargs):
        return '"%s"' % self.value  # add quotes to distinguish from Symbols


def get_default_value(name, evaluation, k=None, n=None):
    pos = []
    if k is not None:
        pos.append(k)
    if n is not None:
        pos.append(n)
    for pos_len in reversed(range(len(pos) + 1)):
        # Try patterns from specific to general
        defaultexpr = Expression('Default', Symbol(name),
                                 *[Integer(index) for index in pos[:pos_len]])
        result = evaluation.definitions.get_value(
            name, 'DefaultValues', defaultexpr, evaluation)
        if result is not None:
            if result.same(defaultexpr):
                result = result.evaluate(evaluation)
            return result
    return None


def print_parenthesizes(precedence, outer_precedence=None,
                        parenthesize_when_equal=False):
    return (outer_precedence is not None and (
        outer_precedence > precedence or (
            outer_precedence == precedence and parenthesize_when_equal)))

########NEW FILE########
__FILENAME__ = numbers
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from __future__ import with_statement

import sympy
import sympy.mpmath as mpmath
from math import log

from mathics.core.util import unicode_superscript


def get_type(value):
    if isinstance(value, sympy.Integer):
        return 'z'
    elif isinstance(value, sympy.Rational):
        return 'q'
    elif isinstance(value, sympy.Float) or isinstance(value, mpmath.mpf):
        return 'f'
    elif (isinstance(value, sympy.Expr) and value.is_number and
          not value.is_real) or isinstance(value, mpmath.mpc):
        return 'c'
    else:
        return None


def same(v1, v2):
    return get_type(v1) == get_type(v2) and v1 == v2


def is_0(value):
    return get_type(value) == 'z' and value == 0


def sympy2mpmath(value, prec=None):
    if prec is None:
        from mathics.builtin.numeric import machine_precision
        prec = machine_precision
    value = value.n(dps(prec))
    if value.is_real:
        return mpmath.mpf(value)
    elif value.is_number:
        return mpmath.mpc(*value.as_real_imag())
    else:
        return None


class SpecialValueError(Exception):
    def __init__(self, name):
        self.name = name


def mpmath2sympy(value, prec=None):
    if prec is None:
        from mathics.builtin.numeric import machine_precision
        prec = machine_precision
    if isinstance(value, mpmath.mpc):
        return (sympy.Float(str(value.real), dps(prec)) +
                sympy.I * sympy.Float(str(value.imag), dps(prec)))
    elif isinstance(value, mpmath.mpf):
        if str(value) in ('+inf', '-inf'):
            raise SpecialValueError('ComplexInfinity')
        return sympy.Float(str(value), dps(prec))
    else:
        return None

C = log(10, 2)  # ~ 3.3219280948873626


def dps(prec):
    return max(1, int(round(int(prec) / C - 1)))


def prec(dps):
    return max(1, int(round((int(dps) + 1) * C)))


def format_float(value, pretty=True, parenthesize_plus=False):
    s = str(value)
    s = s.split('e')
    if len(s) == 2:
        man, exp = s
        if pretty:
            return u'%s\u00d710%s' % (
                format_float(man), unicode_superscript(exp))
        else:
            result = u'%s*10^%s' % (format_float(man), exp)
            if parenthesize_plus:
                result = '(%s)' % result
            return result
    else:
        return s[0]


def mul(x, y):
    return x * y


def add(x, y):
    return x + y


def min_prec(*args):
    result = None
    for arg in args:
        prec = arg.get_precision()
        if result is None or (prec is not None and prec < result):
            result = prec
    return result


def pickle_mp(value):
    return (get_type(value), str(value))


def unpickle_mp(value):
    type, value = value
    if type == 'z':
        return sympy.Integer(value)
    elif type == 'q':
        return sympy.Rational(value)
    elif type == 'f':
        return sympy.Float(value)
    else:
        return value

# algorithm based on
# http://stackoverflow.com/questions/5110177/how-to-convert-floating-point-number-to-base-3-in-python       # nopep8


def convert_base(x, base, precision=10):
    sign = -1 if x < 0 else 1
    x *= sign

    length_of_int = int(log(x, base))
    iexps = range(length_of_int, -1, -1)
    import string
    digits = string.digits + string.lowercase

    def convert(x, base, exponents):
        out = []
        for e in exponents:
            d = int(x // (base ** e))
            x -= d * (base ** e)
            out.append(digits[d])
            if x == 0 and e < 0:
                break
        return out

    int_part = convert(int(x), base, iexps)
    if sign == -1:
        int_part.insert(0, '-')

    if (isinstance(x, float)):
        fexps = range(-1, -int(precision + 1), -1)
        real_part = convert(x - int(x), base, fexps)

        return "%s.%s" % (''.join(int_part), ''.join(real_part))
    else:
        return ''.join(int_part)


def convert_int_to_digit_list(x, base):
    x = abs(x)

    length_of_int = int(log(x, base)) + 1
    iexps = range(length_of_int, -1, -1)

    def convert(x, base, exponents):
        out = []
        for e in exponents:
            d = int(x // (base ** e))
            x -= d * (base ** e)
            if out or d != 0:   # drop any leading zeroes
                out.append(d)
            if x == 0 and e < 0:
                break
        return out

    return convert(x, base, iexps)

########NEW FILE########
__FILENAME__ = parser
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import ply.lex as lex
import ply.yacc as yacc

import re
from math import log10

from mathics.core.expression import (BaseExpression, Expression, Integer,
                                     Real, Symbol, String, Rational)
from mathics.core.numbers import dps
from mathics.core.characters import letters, letterlikes, named_characters

from mathics.builtin.numeric import machine_precision


class TranslateError(Exception):
    pass


class ScanError(TranslateError):
    def __init__(self, pos):
        super(ScanError, self).__init__()
        self.pos = pos

    def __unicode__(self):
        return u"Lexical error at position {0}.".format(self.pos)


class InvalidCharError(TranslateError):
    def __init__(self, char):
        super(InvalidCharError, self).__init__()
        self.char = char

    def __unicode__(self):
        return u"Invalid character at '%s'." % self.char  # .decode('utf-8')


class ParseError(TranslateError):
    def __init__(self, token):
        super(ParseError, self).__init__()
        self.token = token

    def __unicode__(self):
        return u"Parse error at or near token %s." % str(self.token)

# Symbols can be any letters
base_symb = ur'((?![0-9])([0-9${0}{1}])+)'.format(letters, letterlikes)

symbol_re = re.compile(ur'`?{0}(`{0})*'.format(base_symb))


def is_symbol_name(text):
    return symbol_re.sub('', text) == ''

prefix_operators = {
    'Del': 'Del',
    'Square': 'Square',
    'ForAll': 'ForAll',
    'Exists': 'Exists',
    'NotExists': 'NotExists',
}

infix_operators = {
    'PatternTest': 'PatternTest',
    'Apply': 'Apply1',
    'Map': 'Map',
    'MapAll': 'MapAll',
    'PlusMinus': 'PlusMinus',
    'MinusPlus': 'MinusPlus',
    'RightTee': 'RightTee',
    'DoubleRightTee': 'DoubleRightTee',
    'Power': 'Power',
    'LeftTee': 'LeftTee',
    'DoubleLeftTee': 'DoubleLeftTee',
    'Implies': 'Implies',
    'SuchThat': 'SuchThat',
    'Condition': 'Condition',
    'Rule': ['op_Rule', 'Rule'],
    'RuleDelayed': ['op_RuleDelayed', 'RuleDelayed'],
    'ReplaceAll': 'ReplaceAll',
    'ReplaceRepeated': 'ReplaceRepeated',
    'AddTo': 'AddTo',
    'SubtractFrom': 'SubtractFrom',
    'TimesBy': 'TimesBy',
    'DivideBy': 'DivideBy',
    'Therefore': 'Therefore',
    'Because': 'Because',
    'UpSet': 'UpSet',
    'UpSetDelayed': 'UpSetDelayed',
}

flat_infix_operators = {
    'StringJoin': 'StringJoin',
    'SmallCircle': 'SmallCircle',
    'CircleDot': 'CircleDot',
    'NonCommutativeMultiply': 'NonCommutativeMultiply',
    'Cross': 'Cross',
    'Dot': 'RawDot',
    'Plus': 'Plus',
    'Intersection': 'Intersection',
    'Union': 'Union',
    'Diamond': 'Diamond',
    'Wedge': 'Wedge',
    'Vee': 'Vee',
    'CircleTimes': 'CircleTimes',
    'CirclePlus': 'CirclePlus',
    'CircleMinus': 'CircleMinus',
    'CenterDot': 'CenterDot',
    'VerticalTilde': 'VerticalTilde',
    'Coproduct': 'Coproduct',
    'Cap': 'Cap',
    'Cup': 'Cup',
    'Star': 'Star',
    'Backslash': 'RawBackslash',
    'VerticalBar': 'VerticalBar',
    'NotVerticalBar': 'NotVerticalBar',
    'DoubleVerticalBar': 'DoubleVerticalBar',
    'NotDoubleVerticalBar': 'NotDoubleVerticalBar',
    'SameQ': 'SameQ',
    'UnsameQ': 'UnsameQ',
    'Element': 'Element',
    'NotElement': 'NotElement',
    'Subset': 'Subset',
    'Superset': 'Superset',
    'And': ['And', 'op_And'],
    'Nand': 'Nand',
    'Xor': 'Xor',
    'Xnor': 'Xnor',
    'Or': ['op_Or', 'Or'],
    'Nor': 'Nor',
    'Equivalent': 'Equivalent',
    'Alternatives': 'Alternatives',
    'StringExpression': 'StringExpression',
    'Colon': 'Colon',
    'VerticalSeparator': 'VerticalSeparator',
}

postfix_operators = {
    'Increment': 'Increment',
    'Decrement': 'Decrement',
    'Factorial': 'Factorial',
    'Factorial2': 'Factorial2',
    'Conjugate': 'Conjugate',
    'Transpose': 'Transpose',
    'ConjugateTranspose': ['ConjugateTranspose', 'HermitianConjugate'],
    'Repeated': 'Repeated',
    'RepeatedNull': 'RepeatedNull',
    'Function': 'RawAmpersand',
}

innequality_operators = {
    'Equal': ['op_Equal', 'LongEqual', 'Equal'],
    'Unequal': ['op_Unequal', 'NotEqual'],
    'Greater': 'Greater',
    'Less': 'Less',
    'GreaterEqual': ['op_GreaterEqual', 'GreaterEqual', 'GreaterSlantEqual'],
    'LessEqual': ['op_LessEqual', 'LessEqual', 'LessSlantEqual'],
}

precedence = (
    ('right', 'FormBox'),
    ('left', 'Semicolon'),                  # flat - custom
    ('left', 'Put', 'PutAppend'),
    ('right', 'Set', 'SetDelayed', 'Function',
     'UpSet', 'UpSetDelayed', 'TagSet', 'Unset'),
    ('left', 'Because'),
    ('right', 'Therefore'),
    ('left', 'VerticalSeparator'),          # flat
    ('left', 'Postfix'),
    ('right', 'Colon'),                     # flat
    ('left', 'RawAmpersand'),
    ('right', 'AddTo', 'SubtractFrom', 'TimesBy', 'DivideBy'),
    ('left', 'ReplaceAll', 'ReplaceRepeated'),
    ('right', 'Rule', 'op_Rule', 'RuleDelayed', 'op_RuleDelayed'),
    ('left', 'Condition'),
    ('left', 'StringExpression'),           # flat
    ('right', 'RawColon'),
    ('left', 'Alternatives'),               # flat
    ('nonassoc', 'Repeated', 'RepeatedNull'),
    ('right', 'SuchThat'),
    ('left', 'LeftTee', 'DoubleLeftTee'),
    ('right', 'RightTee', 'DoubleRightTee'),
    ('right', 'Implies'),
    ('left', 'Equivalent'),                 # flat
    ('left', 'Or', 'op_Or', 'Nor'),         # flat
    ('left', 'Xor', 'Xnor'),                # flat
    ('left', 'And', 'op_And', 'Nand'),      # flat
    ('right', 'Not'),
    ('right', 'ForAll', 'Exists', 'NotExists'),
    ('left', 'Element', 'NotElement', 'Subset', 'Superset'),    # flat
    ('left', 'SameQ', 'UnsameQ'),           # flat
    ('left', 'Equal', 'op_Equal', 'LongEqual', 'op_Unequal', 'NotEqual',
     'Greater', 'Less', 'GreaterEqual', 'op_GreaterEqual', 'GreaterSlantEqual',
     'LessEqual', 'op_LessEqual', 'LessSlantEqual', 'VerticalBar',
     'NotVerticalBar', 'DoubleVerticalBar', 'NotDoubleVerticalBar'),
    ('nonassoc', 'Span'),
    ('left', 'Union'),                      # flat
    ('left', 'Intersection'),               # flat
    ('left', 'Plus', 'Minus', 'PlusMinus', 'MinusPlus'),  # flat
    #('left', 'Sum'),                       # flat
    ('left', 'CirclePlus', 'CircleMinus'),  # flat
    ('left', 'Cap', 'Cup'),                 # flat
    ('left', 'Coproduct'),                  # flat
    ('left', 'VerticalTilde'),              # flat
    #('left', 'Product'),
    ('left', 'Star'),                       # flat
    # This is a hack to get implicit times working properly:
    ('left', 'Times', 'RawStar', 'blanks', 'blankdefault', 'out', 'slot',
     'slotseq', 'string', 'symbol', 'number', 'RawLeftBrace',
     'RawLeftParenthesis'),  # flat,
    ('left', 'CenterDot'),                  # flat
    ('left', 'CircleTimes'),                # flat
    ('left', 'Vee'),                        # flat
    ('left', 'Wedge'),                      # flat
    ('left', 'Diamond'),                    # flat
    ('nonassoc', 'RawBackslash'),
    ('left', 'RawSlash', 'Divide', 'Fraction'),
    ('right', 'UPlus', 'UMinus', 'UPlusMinus', 'UMinusPlus'),
    ('left', 'RawDot'),                     # flat
    ('left', 'Cross'),                      # flat
    ('left', 'NonCommutativeMultiply'),     # flat
    ('right', 'CircleDot'),
    ('left', 'SmallCircle'),                # flat
    ('right', 'Square'),
    ('right', 'Del'),
    ('right', 'Integral', 'DifferentialD'),
    ('right', 'Sqrt'),
    ('right', 'Power', 'Superscript'),
    ('left', 'StringJoin'),                 # flat
    ('left', 'Derivative'),
    ('left', 'Conjugate', 'Transpose', 'ConjugateTranspose'),
    ('left', 'Factorial', 'Factorial2'),
    ('right', 'Apply1', 'Apply2', 'Map', 'MapAll'),
    ('left', 'Infix'),
    ('right', 'Prefix'),
    ('right', 'PreIncrement', 'PreDecrement'),
    ('left', 'Increment', 'Decrement'),
    ('left', 'PART', 'RawLeftBracket', 'RawRightBracket'),
    ('nonassoc', 'PatternTest'),
    ('nonassoc', 'InterpretedBox'),
    ('right', 'Subscript'),
    ('right', 'Overscript', 'Underscript'),
    ('nonassoc', 'Get'),
    #('nonassoc', 'blanks', 'blankdefault'),
    #('nonassoc', 'out'),
    #('nonassoc', 'slot', 'slotseq'),
    ('nonassoc', 'MessageName'),
    #('nonassoc', 'string'),
    #('nonassoc', 'symbol'),
    #('nonassoc', 'number'),
)

tokens = (
    'symbol',
    'number',
    'string',
    'blanks',
    'blankdefault',
    'out',
    'slot',
    'slotseq',
    'filename',
    'Span',
    'RawLeftBracket',
    'RawRightBracket',
    'RawLeftBrace',
    'RawRightBrace',
    'RawLeftParenthesis',
    'RawRightParenthesis',
    'LeftBoxParenthesis',
    'RightBoxParenthesis',
    'LeftBoxParenthesisInternal',
    'RightBoxParenthesisInternal',
    'RawComma',
    'Get',
    'Put',
    'PutAppend',
    'MessageName',
    'Superscript',
    'Subscript',
    'Overscript',
    'Underscript',
    'Otherscript',
    'Fraction',
    'Sqrt',
    'FormBox',
    'InterpretedBox',
    'PatternTest',
    'Increment',
    'Decrement',
    'Prefix',
    'Infix',
    'Apply1',
    'Apply2',
    'Map',
    'MapAll',
    'Factorial',
    'Factorial2',
    'Conjugate',
    'Transpose',
    'ConjugateTranspose',
    'HermitianConjugate',
    'Derivative',
    'StringJoin',
    'Power',
    'Integral',
    'DifferentialD',
    #'PartialD',
    'Del',
    'Square',
    'CircleDot',
    'SmallCircle',
    'NonCommutativeMultiply',
    'Cross',
    'RawDot',
    'Plus',
    'Minus',
    'PlusMinus',
    'MinusPlus',
    'RawSlash',
    'RawBackslash',
    'Diamond',
    'Wedge',
    'Vee',
    'CircleTimes',
    'CenterDot',
    'Star',
    #'Sum',
    #'Product',
    'RawStar',
    'Times',
    'Divide',
    'op_Equal',
    'op_Unequal',
    'Greater',
    'Less',
    'op_GreaterEqual',
    'op_LessEqual',
    'SameQ',
    'UnsameQ',
    'op_And',
    'op_Or',
    'Repeated',
    'RepeatedNull',
    'Alternatives',
    'RawColon',
    'StringExpression',
    'Condition',
    'op_Rule',
    'op_RuleDelayed',
    'ReplaceAll',
    'ReplaceRepeated',
    'AddTo',
    'SubtractFrom',
    'TimesBy',
    'DivideBy',
    'RawAmpersand',
    'Colon',
    'Postfix',
    'Set',
    'SetDelayed',
    'UpSet',
    'UpSetDelayed',
    'TagSet',
    'Unset',
    'Semicolon',
    #'DiscreteShift',
    #'DiscreteRatio',
    #'DifferenceDelta',
    'VerticalTilde',
    'Coproduct',
    'Cap',
    'Cup',
    'CirclePlus',
    'CircleMinus',
    'Intersection',
    'Union',
    'Equal',
    'LongEqual',
    'NotEqual',
    'LessEqual',
    'LessSlantEqual',
    'GreaterEqual',
    'GreaterSlantEqual',
    'VerticalBar',
    'NotVerticalBar',
    'DoubleVerticalBar',
    'NotDoubleVerticalBar',
    'Element',
    'NotElement',
    'Subset',
    'Superset',
    'ForAll',
    'Exists',
    'NotExists',
    'Not',
    'And',
    'Nand',
    'Xor',
    'Xnor',
    'Or',
    'Nor',
    'Equivalent',
    'Implies',
    'RightTee',
    'DoubleRightTee',
    'LeftTee',
    'DoubleLeftTee',
    'SuchThat',
    'Rule',
    'RuleDelayed',
    'VerticalSeparator',
    'Therefore',
    'Because',
    'Function',
)


class MathicsScanner:
    tokens = tokens
    precedence = precedence

    states = (
        ('file', 'exclusive'),
        ('boxes', 'inclusive'),
    )

    t_ANY_ignore = ' \t\n '

    t_RawLeftBracket = r' \[ '
    t_RawRightBracket = r' \] '
    t_RawLeftBrace = r' \{ '
    t_RawRightBrace = r' \} '
    t_RawLeftParenthesis = r' \( '
    t_RawRightParenthesis = r' \) '

    t_RawComma = r' \, '

    t_Span = r' \;\; '

    t_MessageName = r' \:\: '

    # Box Constructors
    t_InterpretedBox = r' \\\! '
    t_boxes_Superscript = r' \\\^ '
    t_boxes_Subscript = r' \\\_ '
    t_boxes_Overscript = r' \\\& '
    t_boxes_Underscript = r' \\\+ '
    t_boxes_Otherscript = r' \\\% '
    t_boxes_Fraction = r' \\\/ '
    t_boxes_Sqrt = r' \\\@ '
    t_boxes_FormBox = r' \\\` '

    t_PatternTest = r' \? '
    t_Increment = r' \+\+ '
    t_Decrement = r' \-\- '

    t_Prefix = r' \@ '
    t_Infix = r' \~ '
    t_Apply1 = r' \@\@ '
    t_Apply2 = r' \@\@\@ '
    t_Map = r' \/\@ '
    t_MapAll = r' \/\/\@ '

    t_Factorial = r' \! '
    t_Factorial2 = r' \!\! '

    t_Transpose = ur' \uf3c7 '
    t_Conjugate = ur' \uf3c8 '
    t_ConjugateTranspose = ur' \uf3c9 '
    t_HermitianConjugate = ur' \uf3ce '

    t_Derivative = r' \'+ '
    t_StringJoin = r' \<\> '

    t_Power = r' \^ '

    t_Integral = ur' \u222b '
    t_DifferentialD = ur' \uf74c '
    # t_PartialD = ur' \u2202 '
    t_Del = ur' \u2207 '

    t_Square = ur' \uf520 '
    t_SmallCircle = ur' \u2218 '
    t_CircleDot = ur' \u2299 '

    t_NonCommutativeMultiply = r' \*\* '

    t_Cross = ur' \uf4a0 '
    t_RawDot = r' \. '

    t_Plus = r' \+ '
    t_Minus = r' \- '
    t_RawSlash = r' \/ '
    t_RawBackslash = r' \\ '

    t_Diamond = ur' \u22c4 '
    t_Wedge = ur' \u22c0 '
    t_Vee = ur' \u22c1 '
    t_CircleTimes = ur' \u2297 '
    t_CenterDot = ur' \u00b7 '
    t_Star = ur' \u22c6'

    # t_Sum = ur' \u2211 '
    # t_Product = ur' \u220f '

    t_RawStar = r' \* '
    t_Times = ur' \u00d7 '
    t_Divide = ur' \u00f7 '

    t_PlusMinus = ur' \u00b1 '
    t_MinusPlus = ur' \u2213 '

    t_op_Equal = r' \=\= '
    t_op_Unequal = r' \!\= '
    t_Greater = r' \> '
    t_Less = r' \< '
    t_op_GreaterEqual = r' \>\= '
    t_op_LessEqual = r' \<\= '

    t_SameQ = r' \=\=\= '
    t_UnsameQ = r' \=\!\= '

    t_op_And = r' \&\& '
    t_op_Or = r' \|\|  '

    t_Or = ur' \u2228 '
    t_Nor = ur' \u22BD '

    t_And = ur' \u2227 '
    t_Nand = ur' \u22BC '

    t_Xor = ur' \u22BB '
    t_Xnor = ur' \uF4A2 '

    t_Repeated = r' \.\. '
    t_RepeatedNull = r' \.\.\. '
    t_Alternatives = r' \| '

    t_RawColon = r' \: '
    t_StringExpression = r' \~\~ '
    t_Condition = r' \/\; '

    t_op_Rule = r' \-\> '
    t_op_RuleDelayed = r' \:\> '
    t_ReplaceAll = r' \/\. '
    t_ReplaceRepeated = r' \/\/\. '

    t_AddTo = r' \+\= '
    t_SubtractFrom = r' \-\=  '
    t_TimesBy = r' \*\= '
    t_DivideBy = r' \/\=  '

    t_RawAmpersand = r' \& '
    t_Colon = ur' \u2236 '
    t_Postfix = r' \/\/ '

    t_Set = r' \= '
    t_SetDelayed = r' \:\= '
    t_UpSet = r' \^\= '
    t_UpSetDelayed = r' \^\:\= '
    t_TagSet = r' \/\: '
    t_Unset = r' \=\. '

    t_Semicolon = r' \; '

    # t_DiscreteShift = ur' \uf4a3 '
    # t_DiscreteRatio = ur' \uf4a4 '
    # t_DifferenceDelta = ur' \u2206 '
    t_VerticalTilde = ur' \u2240 '
    t_Coproduct = ur' \u2210 '
    t_Cap = ur' \u2322 '
    t_Cup = ur' \u2323 '
    t_CirclePlus = ur' \u2295 '
    t_CircleMinus = ur' \u2296 '
    t_Intersection = ur' \u22c2 '
    t_Union = ur' \u22c3 '
    t_Equal = ur' \uf431 '
    t_LongEqual = ur' \uf7d9 '
    t_NotEqual = ur' \u2260 '
    t_LessEqual = ur' \u2264 '
    t_LessSlantEqual = ur' \u2a7d '
    t_GreaterEqual = ur' \u2265 '
    t_GreaterSlantEqual = ur' \u2a7e '
    t_VerticalBar = ur' \u2223 '
    t_NotVerticalBar = ur' \u2224 '
    t_DoubleVerticalBar = ur' \u2225 '
    t_NotDoubleVerticalBar = ur' \u2226 '
    t_Element = ur' \u2208 '
    t_NotElement = ur' \u2209 '
    t_Subset = ur' \u2282 '
    t_Superset = ur' \u2283 '
    t_ForAll = ur' \u2200 '
    t_Exists = ur' \u2203 '
    t_NotExists = ur' \u2204 '
    t_Not = ur' \u00AC '
    t_Equivalent = ur' \u29E6 '
    t_Implies = ur' \uF523 '
    t_RightTee = ur' \u22A2 '
    t_DoubleRightTee = ur' \u22A8 '
    t_LeftTee = ur' \u22A3 '
    t_DoubleLeftTee = ur' \u2AE4 '
    t_SuchThat = ur' \u220D '
    t_Rule = ur' \uF522 '
    t_RuleDelayed = ur' \uF51F '
    t_VerticalSeparator = ur' \uF432 '
    t_Therefore = ur' \u2234 '
    t_Because = ur' \u2235 '
    t_Function = ur' \uF4A1 '

    def build(self, **kwargs):
        self.lexer = lex.lex(
            debug=False,
            module=self,
            **kwargs)

        self.precompiled_regex = {
            'longnames': re.compile(r'(?<!\\)(\\\[[a-zA-Z]+\])'),
            'oct': re.compile(r'(?<!\\)(\\[0-7]{3})'),
            'hex': re.compile(
                r'(?<!\\)(\\\.[0-9a-fA-F]{2}|\\\:[0-9a-fA-F]{4})')
        }

    def tokenize(self, input_string):
        self.tokens = []
        self.lexer.input(input_string)
        while True:
            tok = self.lexer.token()
            if not tok:
                break
            self.tokens.append(tok)
        return self.tokens

    def convert_character_codes(self, s):
        "Converts character codes to characters E.g. \.7A -> z, \:004a -> J"
        def repl_hex_char(match):
            return unichr(int(match.group(0)[2:], 16))

        def repl_oct_char(match):
            return unichr(int(match.group(0)[1:], 8))

        hex_re = self.precompiled_regex['hex']
        oct_re = self.precompiled_regex['oct']

        s = hex_re.sub(repl_hex_char, s)
        s = oct_re.sub(repl_oct_char, s)

        return s

    def convert_unicode_longnames(self, s):
        "Converts unicode longnames to characters. E.g. \[Theta] -> \u03B8"

        def repl_named_char(match):
            name = match.group(0)[2:-1]
            char = named_characters.get(name)
            if char is not None:
                return char
            else:
                # TODO: Syntax::sntufn message
                return '\\[' + name + ']'

        longnames_re = self.precompiled_regex['longnames']

        return longnames_re.sub(repl_named_char, s)

    @staticmethod
    def string_escape(s):
        s = s.replace('\\\\', '\\').replace('\\"', '"')
        s = s.replace('\\r\\n', '\r\n')
        s = s.replace('\\r', '\r')
        s = s.replace('\\n', '\n')
        return s

    def t_comment(self, t):
        r' (?s) \(\* .*? \*\) '
        return None

    # Lex '1..' as [1, RepeatedNull]. MMA fails when base given e.g. '8^^1..'
    def t_intRepeated(self, t):
        r' (\d+\^\^[a-zA-Z0-9]+|\d+)(?=\.\.) '
        t = self.t_number(t)
        t.type = 'number'
        return t

    def t_number(self, t):
        r'''
        ( (?# Two possible forms depending on whether base is specified)
            (\d+\^\^([a-zA-Z0-9]+\.?[a-zA-Z0-9]*|[a-zA-Z0-9]*\.?[a-zA-Z0-9]+))
            | (\d+\.?\d*|\d*\.?\d+)
        )
        (``?(\+|-)?(\d+\.?\d*|\d*\.?\d+)|`)?        (?# Precision / Accuracy)
        (\*\^(\+|-)?\d+)?                           (?# Exponent)
        '''
        s = t.value

        # Look for base
        s = s.split('^^')
        if len(s) == 1:
            base, s = 10, s[0]
        else:
            assert len(s) == 2
            base, s = int(s[0]), s[1]
            assert 2 <= base <= 36

        # Look for mantissa
        s = s.split('*^')
        if len(s) == 1:
            n, s = 0, s[0]
        else:
            # TODO: modify regex and provide error message if n not an int
            n, s = int(s[1]), s[0]

        # Look at precision ` suffix to get precision/accuracy
        prec, acc = None, None
        s = s.split('`', 1)
        if len(s) == 1:
            suffix, s = None, s[0]
        else:
            suffix, s = s[1], s[0]

            if suffix == '':
                prec = machine_precision
            elif suffix.startswith('`'):
                acc = float(suffix[1:])
            else:
                if re.match('0+$', s) is not None:
                    t.value = Integer(0)
                    return t
                prec = float(suffix)

        # Look for decimal point
        if s.count('.') == 0:
            if suffix is None:
                if n < 0:
                    t.value = Rational(int(s, base), base ** abs(n))
                else:
                    t.value = Integer(int(s, base) * (base ** n))
                return t
            else:
                s = s + '.'

        if base == 10:
            if n != 0:
                s = s + 'E' + str(n)    # sympy handles this

            if acc is not None:
                if float(s) == 0:
                    prec = 0.
                else:
                    prec = acc + log10(float(s)) + n

            # XXX
            if prec is not None:
                prec = dps(prec)
            t.value = Real(s, prec)
            # t.value = Real(s, prec, acc)
        else:
            # Convert the base
            assert isinstance(base, int) and 2 <= base <= 36

            # Put into standard form mantissa * base ^ n
            s = s.split('.')
            if len(s) == 1:
                man = s[0]
            else:
                n -= len(s[1])
                man = s[0] + s[1]

            man = int(man, base)

            if n >= 0:
                result = Integer(man * base ** n)
            else:
                result = Rational(man, base ** -n)

            if acc is None and prec is None:
                acc = len(s[1])
                acc10 = acc * log10(base)
                prec10 = acc10 + log10(result.to_python())
                if prec10 < 18:
                    prec10 = None
            elif acc is not None:
                acc10 = acc * log10(base)
                prec10 = acc10 + log10(result.to_python())
            elif prec is not None:
                if prec == machine_precision:
                    prec10 = machine_precision
                else:
                    prec10 = prec * log10(base)
            # XXX
            if prec10 is None:
                prec10 = machine_precision
            else:
                prec10 = dps(prec10)

            t.value = result.round(prec10)

        return t

    def t_string(self, t):
        r' "([^\\"]|\\\\|\\"|\\n|\\r|\\r\\n)*" '
        t.value = self.string_escape(t.value[1:-1])
        return t

    @lex.TOKEN(ur'{0}?_\.'.format(base_symb))
    def t_blankdefault(self, t):    # this must come before t_blanks
        # r' ([a-zA-Z$][a-zA-Z0-9$]*)?_\. '
        return t

    @lex.TOKEN(ur'{0}?_(__?)?{0}?'.format(base_symb))
    def t_blanks(self, t):
        # r' ([a-zA-Z$][a-zA-Z0-9$]*)?_(__?)?([a-zA-Z$][a-zA-Z0-9$]*)? '
        return t

    @lex.TOKEN(ur'`?{0}(`{0})*'.format(base_symb))
    def t_symbol(self, t):
        # r' `?[a-zA-Z$][a-zA-Z0-9$]*(`[a-zA-Z$][a-zA-Z0-9$]*)* '
        s = t.value
        if s.startswith('`'):
            # FIXME: Replace Global with the current value of $Context
            s = 'Global' + s
        t.value = s
        return t

    def t_slotseq_1(self, t):
        r' \#\#\d+ '
        (t.type, t.value) = ('slotseq', int(t.value[2:]))
        return t

    def t_slotseq_2(self, t):
        r' \#\# '
        (t.type, t.value) = ('slotseq', 1)
        return t

    def t_slotsingle_1(self, t):
        r' \#\d+ '
        (t.type, t.value) = ('slot', int(t.value[1:]))
        return t

    def t_slotsingle_2(self, t):
        r' \# '
        (t.type, t.value) = ('slot', 1)
        return t

    def t_out_1(self, t):
        r' \%\d+ '
        (t.type, t.value) = ('out', int(t.value[1:]))
        return t

    def t_out_2(self, t):
        r' \%+ '
        (t.type, t.value) = ('out', -len(t.value))
        return t

    def t_INITIAL_LeftBoxParenthesis(self, t):
        r' \\\( '
        t.lexer.level = 1
        t.lexer.begin('boxes')
        return t

    def t_boxes_LeftBoxParenthesis(self, t):
        r' \\\( '
        t.lexer.level += 1
        t.type = 'LeftBoxParenthesisInternal'
        return t

    def t_boxes_RightBoxParenthesis(self, t):
        r' \\\) '
        t.lexer.level -= 1
        if t.lexer.level == 0:
            t.lexer.begin('INITIAL')
            return t
        else:
            t.type = 'RightBoxParenthesisInternal'
            return t

    def t_PutAppend(self, t):
        r' \>\>\> '
        t.lexer.begin('file')
        return t

    def t_Put(self, t):
        r' \>\> '
        t.lexer.begin('file')
        return t

    def t_Get(self, t):
        r' \<\< '
        t.lexer.begin('file')
        return t

    def t_file_filename(self, t):
        r'''
        (?P<quote>\"?)                              (?# Opening quotation mark)
            [a-zA-Z0-9\`/\.\\\!\-\:\_\$\*\~\?]+     (?# Literal characters)
        (?P=quote)                                  (?# Closing quotation mark)
        '''
        s = t.value
        if s.startswith('"'):
            s = s[1:-1]
        s = self.string_escape(s)
        s = s.replace('\\', '\\\\')
        t.value = String(s)
        t.lexer.begin('INITIAL')
        return t

    def t_ANY_error(self, t):
        # print t
        raise ScanError(self.lexer.lexpos)


class AbstractToken(object):
    def __init__(self, items):
        self.items = items


class SequenceToken(AbstractToken):
    pass


class ArgsToken(AbstractToken):
    pass


class PositionToken(AbstractToken):
    pass

# Decorator hack to convince ply that a parsing rule only accepts one argument


def ONEARG(f):
    def wrapped(args):
        return f(args)
    return wrapped


class MathicsParser:
    tokens = tokens
    precedence = precedence
    start = 'Expression'

    def __init__(self):
        for prefix_op in prefix_operators:
            @ONEARG
            def tmp(args, op=prefix_op):
                args[0] = Expression(op, args[2])
            tokens = prefix_operators[prefix_op]
            if not isinstance(tokens, list):
                tokens = [tokens]
            tmp.__doc__ = 'expr : ' + '\n     | '.join(
                ['{0} expr'.format(token) for token in tokens])
            setattr(self, 'p_{0}_prefix'.format(prefix_op), tmp)

        for infix_op in infix_operators:
            tokens = infix_operators[infix_op]
            if not isinstance(tokens, list):
                tokens = [tokens]

            @ONEARG
            def tmp(args, op=infix_op):
                args[0] = Expression(op, args[1], args[3])
            tmp.__doc__ = 'expr : ' + '\n     | '.join(
                ['expr {0} expr'.format(token) for token in tokens])
            setattr(self, 'p_{0}_infix'.format(infix_op), tmp)

        for flat_infix_op in flat_infix_operators:
            tokens = flat_infix_operators[flat_infix_op]
            if not isinstance(tokens, list):
                tokens = [tokens]

            @ONEARG
            def tmp(args, op=flat_infix_op):
                if args[1].get_head_name() == op:
                    args[1].leaves.append(args[3])
                    args[0] = args[1]
                else:
                    args[0] = Expression(op, args[1], args[3])
            tmp.__doc__ = 'expr : ' + '\n     | '.join(
                ['expr {0} expr'.format(token) for token in tokens])
            setattr(self, 'p_{0}_infix'.format(flat_infix_op), tmp)

        for postfix_op in postfix_operators:
            @ONEARG
            def tmp(args, op=postfix_op):
                args[0] = Expression(op, args[1])
            tokens = postfix_operators[postfix_op]
            if not isinstance(tokens, list):
                tokens = [tokens]
            tmp.__doc__ = 'expr : ' + '\n     | '.join(
                ['expr {0}'.format(token) for token in tokens])
            setattr(self, 'p_{0}_postfix'.format(postfix_op), tmp)

        for innequality_op in innequality_operators:
            @ONEARG
            def tmp(args, op=innequality_op):
                head = args[1].get_head_name()
                if head == op:
                    args[1].leaves.append(args[3])
                    args[0] = args[1]
                elif head == 'Inequality':
                    args[1].leaves.append(Symbol(op))
                    args[1].leaves.append(args[3])
                    args[0] = args[1]
                elif head in innequality_operators.keys():
                    leaves = []
                    for i, leaf in enumerate(args[1].leaves):
                        if i != 0:
                            leaves.append(Symbol(head))
                        leaves.append(leaf)
                    leaves.append(Symbol(op))
                    leaves.append(args[3])
                    args[0] = Expression('Inequality', *leaves)
                else:
                    args[0] = Expression(op, args[1], args[3])
            tokens = innequality_operators[innequality_op]
            if not isinstance(tokens, list):
                tokens = [tokens]
            tmp.__doc__ = 'expr : ' + '\n     | '.join(
                ['expr {0} expr'.format(token) for token in tokens])
            setattr(self, 'p_{0}_innequality'.format(innequality_op), tmp)

    def build(self, **kwargs):
        self.parser = yacc.yacc(
            module=self,
            debug=False,
            tabmodule='mathics.core.parsetab',  # where to look for parsetab
            outputdir='mathics/core/',          # where to store parsetab
            **kwargs)

    def p_error(self, p):
        if p is not None:
            p = p.value
        raise ParseError(p)

    def parse(self, string):
        result = self.parser.parse(string)
        if result is not None:
            result = result.post_parse()
        return result

    def p_Expression(self, args):
        'Expression : expr'
        args[0] = args[1]

    def p_Empty(self, args):
        'Expression :'
        args[0] = None

    def p_parenthesis(self, args):
        'expr : RawLeftParenthesis expr RawRightParenthesis'
        expr = args[2]
        expr.parenthesized = True
        args[0] = expr

    def p_call(self, args):
        'expr : expr args %prec PART'
        expr = Expression(args[1], *args[2].items)
        expr.parenthesized = True  # to handle e.g. Power[a,b]^c correctly
        args[0] = expr

    def p_part(self, args):
        'expr : expr position %prec PART'
        args[0] = Expression('Part', args[1], *args[2].items)

    def p_args(self, args):
        'args : RawLeftBracket sequence RawRightBracket'
        args[0] = ArgsToken(args[2].items)

    def p_list(self, args):
        'expr : RawLeftBrace sequence RawRightBrace'
        args[0] = Expression('List', *args[2].items)

    def p_position(self, args):
        'position : RawLeftBracket RawLeftBracket sequence RawRightBracket RawRightBracket'     # nopep8
        args[0] = PositionToken(args[3].items)

    def p_sequence(self, args):
        '''sequence :
                    | sequence1'''
        if len(args) == 1:
            args[0] = SequenceToken([])
        else:
            args[0] = args[1]

    def p_sequence1(self, args):
        '''sequence1 : sequence1 RawComma expr
                     | sequence1 RawComma
                     | RawComma sequence1
                     | expr
                     | RawComma '''
        if len(args) == 4:
            args[1].items.append(args[3])
            args[0] = args[1]
        elif len(args) == 3:
            if args[2] == ',':
                args[1].items.append(Symbol('Null'))
                args[0] = args[1]
            elif args[1] == ',':
                args[2].items.insert(0, Symbol('Null'))
                args[0] = args[2]
        elif len(args) == 2:
            if isinstance(args[1], BaseExpression):
                args[0] = SequenceToken([args[1]])
            elif args[1] == ',':
                args[0] = SequenceToken([Symbol('Null'), Symbol('Null')])

    def p_symbol(self, args):
        'expr : symbol'
        args[0] = Symbol(args[1])

    def p_number(self, args):
        'expr : number'
        args[0] = args[1]

    def p_blanks(self, args):
        'pattern : blanks'
        pieces = args[1].split('_')
        count = len(pieces) - 1
        if count == 1:
            name = 'Blank'
        elif count == 2:
            name = 'BlankSequence'
        elif count == 3:
            name = 'BlankNullSequence'
        if pieces[-1]:
            blank = Expression(name, Symbol(pieces[-1]))
        else:
            blank = Expression(name)
        if pieces[0]:
            args[0] = Expression('Pattern', Symbol(pieces[0]), blank)
        else:
            args[0] = blank

    def p_blankdefault(self, args):
        'pattern : blankdefault'
        name = args[1][:-2]
        if name:
            args[0] = Expression('Optional', Expression(
                'Pattern', Symbol(name), Expression('Blank')))
        else:
            args[0] = Expression('Optional', Expression('Blank'))

    def p_pattern(self, args):
        'expr : pattern'
        args[0] = args[1]

    def p_slot(self, args):
        'expr : slot'
        args[0] = Expression('Slot', Integer(args[1]))

    def p_slotseq(self, args):
        'expr : slotseq'
        args[0] = Expression('SlotSequence', Integer(args[1]))

    def p_out(self, args):
        'expr : out'
        if args[1] == -1:
            args[0] = Expression('Out')
        else:
            args[0] = Expression('Out', Integer(args[1]))

    def p_string(self, args):
        'expr : string'
        args[0] = String(args[1])

    def p_Get(self, args):
        'expr : Get filename'
        args[0] = Expression('Get', args[2])

    def p_MessageName(self, args):
        '''expr : expr MessageName string MessageName string
                | expr MessageName symbol MessageName string
                | expr MessageName symbol
                | expr MessageName string'''

        if len(args) == 4:
            args[0] = Expression('MessageName', args[1], String(args[3]))
        elif len(args) == 6:
            args[0] = Expression('MessageName', args[
                                 1], String(args[3]), String(args[5]))

    def p_PreIncrement(self, args):
        'expr : Increment expr %prec PreIncrement'
        args[0] = Expression('PreIncrement', args[2])

    def p_PreDecrement(self, args):
        'expr : Decrement expr %prec PreDecrement'
        args[0] = Expression('PreDecrement', args[2])

    def p_Prefix(self, args):
        'expr : expr Prefix expr'
        args[0] = Expression(args[1], args[3])

    def p_Infix(self, args):
        'expr : expr Infix expr Infix expr'
        args[0] = Expression(args[3], args[1], args[5])

    def p_Apply2(self, args):
        'expr : expr Apply2 expr'
        assert args[2] == '@@@'
        args[0] = Expression('Apply', args[1], args[
                             3], Expression('List', Integer(1)))

    def p_Derivative(self, args):
        'expr : expr Derivative'
        n = len(args[2])
        if (isinstance(args[1], Expression) and     # nopep8
            isinstance(args[1].head, Expression) and
            args[1].head.get_head_name() == 'Derivative' and
            args[1].head.leaves[0].get_int_value() is not None):
            n += args[1].head.leaves[0].get_int_value()
            args[1] = args[1].leaves[0]
        args[0] = Expression(Expression('Derivative', Integer(n)), args[1])

    def p_Integrate(self, args):
        'expr : Integral expr DifferentialD expr %prec Integral'
        args[0] = Expression('Integrate', args[2], args[4])

    def p_Minus(self, args):
        'expr : expr Minus expr'
        args[0] = Expression('Plus', args[1],
                             Expression('Times', Integer(-1), args[3]))

    def p_UPlus(self, args):
        'expr : Plus expr %prec UPlus'
        args[0] = args[2]

    def p_UMinus(self, args):
        'expr : Minus expr %prec UMinus'''
        if args[2].get_head_name() in ['Integer', 'Real']:
            args[2].value = -args[2].value
            args[0] = args[2]
        else:
            args[0] = Expression('Times', Integer(-1), args[2])

    def p_UPlusMinus(self, args):
        'expr : PlusMinus expr %prec UPlusMinus'''
        args[0] = Expression('PlusMinus', args[2])

    def p_UMinusPlus(self, args):
        'expr : MinusPlus expr %prec UMinusPlus'''
        args[0] = Expression('MinusPlus', args[2])

    def p_Slash(self, args):
        '''expr : expr RawSlash expr
                | expr Divide expr'''
        args[0] = Expression('Times', args[1],
                             Expression('Power', args[3], Integer(-1)))

    def p_Times(self, args):
        '''expr : expr Times expr
                | expr RawStar expr
                | expr expr %prec Times'''
        if len(args) == 3:
            assert args[2].get_head_name != 'Times'
            if args[1].get_head_name() == 'Times':
                args[1].leaves.append(args[2])
                args[0] = args[1]
            else:
                args[0] = Expression('Times', args[1], args[2])
        elif len(args) == 4:
            assert args[3].get_head_name != 'Times'
            if args[1].get_head_name() == 'Times':
                args[1].leaves.append(args[3])
                args[0] = args[1]
            else:
                args[0] = Expression('Times', args[1], args[3])

    def p_Span(self, args):
        '''expr : expr Span expr Span expr
                | expr Span      Span expr
                |      Span expr Span expr
                |      Span      Span expr
                | expr Span expr
                | expr Span
                |      Span expr
                |      Span'''

        if len(args) == 6:
            args[0] = Expression('Span', args[1], args[3], args[5])
        elif len(args) == 5:
            if isinstance(args[1], BaseExpression):
                args[0] = Expression('Span', args[1], Symbol('All'), args[4])
            elif isinstance(args[2], BaseExpression):
                args[0] = Expression('Span', Integer(1), args[2], args[4])
        elif len(args) == 4:
            if isinstance(args[1], BaseExpression):
                args[0] = Expression('Span', args[1], args[3])
            else:
                args[0] = Expression('Span', Integer(1), Symbol('All'),
                                     args[3])
        elif len(args) == 3:
            if isinstance(args[1], BaseExpression):
                args[0] = Expression('Span', args[1], Symbol('All'))
            elif isinstance(args[2], BaseExpression):
                args[0] = Expression('Span', Integer(1), args[2])
        elif len(args) == 2:
                args[0] = Expression('Span', Integer(1), Symbol('All'))

    def p_Not(self, args):
        '''expr : Not expr
                | Factorial expr %prec Not
                | Factorial2 expr %prec Not'''
        args[0] = Expression('Not', args[2])
        if args[1] == '!!':
            args[0] = Expression('Not', args[0])

    def p_Pattern(self, args):
        '''expr : symbol RawColon pattern RawColon expr
                | symbol RawColon expr'''
        args[0] = Expression('Pattern', Symbol(args[1]), args[3])
        if len(args) == 6:
            args[0] = Expression('Optional', args[0], args[5])
        elif args[3].get_head_name() == 'Pattern':
            args[0] = Expression(
                'Optional',
                Expression('Pattern', Symbol(args[1]), args[3].leaves[0]),
                args[3].leaves[1])

    def p_Optional(self, args):
        'expr : pattern RawColon expr'
        args[0] = Expression('Optional', args[1], args[3])

    def p_Postfix(self, args):
        'expr : expr Postfix expr'
        args[0] = Expression(args[3], args[1])

    def p_Set(self, args):
        '''expr : expr TagSet expr Set expr
                | expr Set expr'''
        if len(args) == 4:
            args[0] = Expression('Set', args[1], args[3])
        elif len(args) == 6:
            args[0] = Expression('TagSet', args[1], args[3], args[5])

    def p_SetDelayed(self, args):
        '''expr : expr TagSet expr SetDelayed expr
                | expr SetDelayed expr'''
        if len(args) == 4:
            args[0] = Expression('SetDelayed', args[1], args[3])
        elif len(args) == 6:
            args[0] = Expression('TagSetDelayed', args[1], args[3], args[5])

    def p_Unset(self, args):
        '''expr : expr TagSet expr Unset
                | expr Unset'''
        if len(args) == 3:
            args[0] = Expression('Unset', args[1])
        elif len(args) == 4:
            args[0] = Expression('TagUnset', args[1], args[3])

    def p_Function(self, args):
        'expr : expr Function expr'
        args[0] = Expression('Function', Expression('List', args[1]), args[3])

    def p_Put(self, args):
        'expr : expr Put filename'
        args[0] = Expression('Put', args[1], args[3])

    def p_PutAppend(self, args):
        'expr : expr PutAppend filename'
        args[0] = Expression('PutAppend', args[1], args[3])

    def p_Compound(self, args):
        '''expr : expr Semicolon expr
                | expr Semicolon'''
        if args[1].get_head_name() == 'CompoundExpression':
            pass
        else:
            args[1] = Expression('CompoundExpression', args[1])
        if len(args) == 4:
            args[1].leaves.append(args[3])
        else:
            args[1].leaves.append(Symbol('Null'))
        args[0] = args[1]

    def p_box_to_expr(self, args):
        '''expr : LeftBoxParenthesis boxes RightBoxParenthesis
                | InterpretedBox LeftBoxParenthesis boxes RightBoxParenthesis %prec InterpretedBox'''   # nopep8
        if len(args) == 4:
            args[0] = args[2]
        else:
            result = Expression('MakeExpression', args[3])
            args[0] = Expression('ReleaseHold', result)  # remove HoldComplete

    def p_box(self, args):
        'box : expr'
        args[0] = Expression('MakeBoxes', args[1])

    def p_form(self, args):
        'form : expr'
        if args[1].get_head_name() == 'Symbol':
            args[0] = args[1]
        else:
            args[0] = Expression('Removed', String("$$Failure"))

    def p_boxes(self, args):
        '''boxTOKEN : box
                    | boxTOKEN box
              boxes : boxTOKEN
                    |'''
        if len(args) == 1:
            args[0] = String("")
        if len(args) == 2:
            if isinstance(args[1], list):
                if len(args[1]) > 1:
                    args[0] = Expression('RowBox', *args[1])
                else:
                    args[0] = args[1][0]
            else:
                args[0] = [args[1]]
        elif len(args) == 3:
            args[1].append(args[2])
            args[0] = args[1]

    def p_RowBox(self, args):       # used for grouping raw boxes
        'box : LeftBoxParenthesisInternal boxes RightBoxParenthesisInternal'
        args[2].parenthesized = True
        args[0] = args[2]

    def p_SuperscriptBox(self, args):
        '''box : box Superscript box Otherscript box %prec Superscript
               | box Superscript box'''
        if len(args) == 4:
            args[0] = Expression('SuperscriptBox', args[1], args[3])
        elif len(args) == 6:
            args[0] = Expression(
                'SubsuperscriptBox', args[1], args[5], args[3])

    def p_Subscript(self, args):
        '''box : box Subscript box Otherscript box %prec Subscript
               | box Subscript box'''
        if len(args) == 4:
            args[0] = Expression('SubscriptBox', args[1], args[3])
        elif len(args) == 6:
            args[0] = Expression(
                'SubsuperscriptBox', args[1], args[3], args[5])

    def p_OverscriptBox(self, args):
        '''box : box Overscript box Otherscript box %prec Overscript
               | box Overscript box'''
        if len(args) == 4:
            args[0] = Expression('OverscriptBox', args[1], args[3])
        elif len(args) == 6:
            args[0] = Expression(
                'UnderoverscriptBox', args[1], args[5], args[3])

    def p_UnderscriptBox(self, args):
        '''box : box Underscript box Otherscript box %prec Underscript
               | box Underscript box'''
        if len(args) == 4:
            args[0] = Expression('UnderscriptBox', args[1], args[3])
        elif len(args) == 6:
            args[0] = Expression(
                'UnderoverscriptBox', args[1], args[3], args[5])

    def p_FractionBox(self, args):
        'box : box Fraction box'
        args[0] = Expression('FractionBox', args[1], args[3])

    def p_SqrtBox(self, args):
        '''box : Sqrt box Otherscript box %prec Sqrt
               | Sqrt box'''
        if len(args) == 3:
            args[0] = Expression('SqrtBox', args[2])
        elif len(args) == 5:
            args[0] = Expression('RadicalBox', args[2], args[4])

    def p_FormBox(self, args):
        'box : form FormBox box'
        args[0] = Expression('FormBox', args[3], args[1])

scanner = MathicsScanner()
scanner.build()
parser = MathicsParser()
parser.build()


def parse(string):
    scanner.lexer.begin('INITIAL')      # Reset the lexer state (known lex bug)

    string = scanner.convert_unicode_longnames(string)
    string = scanner.convert_character_codes(string)

    return parser.parse(string)

########NEW FILE########
__FILENAME__ = parsetab

# mathics/core/parsetab.py
# This file is automatically generated. Do not edit.
_tabversion = '3.2'

_lr_method = 'LALR'

_lr_signature = '\x96\x11\xbc\xfd\x0c\x9fZ\xe8\xcb\xab\x8c\xf9_9*\x87'
    
_lr_action_items = {'PlusMinus':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[1,1,-123,1,1,-126,1,1,1,-125,-122,-124,1,1,1,-119,1,1,1,-121,1,1,1,58,1,1,1,-120,-118,1,-142,-141,58,-140,58,1,-179,1,1,58,1,1,-79,58,58,58,1,-127,58,-143,58,-23,58,1,1,1,-16,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-68,1,1,1,1,1,1,1,1,1,-137,1,1,1,1,-69,1,1,1,1,1,1,1,1,-106,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,-37,1,1,1,1,1,1,1,1,-17,1,-39,1,1,1,1,1,1,-148,1,1,1,-45,-18,1,1,1,1,-36,1,1,1,1,-89,1,1,1,1,1,1,1,1,1,-169,1,1,1,1,1,-107,-22,-132,58,58,1,1,-133,1,-180,1,1,1,1,1,-194,1,-175,58,1,58,-105,-65,58,58,58,58,-99,58,58,58,58,-52,58,58,58,-139,-64,-26,58,58,-8,-13,58,58,58,58,-66,58,58,58,58,58,-6,58,58,-78,-172,58,58,58,58,-171,58,-11,-136,58,-5,-147,-144,58,-146,58,-56,58,58,-21,58,58,-96,58,58,1,-10,-24,-80,-9,58,-54,58,58,58,58,58,-19,58,58,58,-100,58,-145,58,58,58,-134,58,-20,58,58,58,58,-53,-67,-130,-131,58,58,58,-12,58,58,58,1,-82,58,58,58,58,58,-109,1,-122,58,-138,-189,-191,-192,-187,-185,-183,1,-195,-176,58,1,1,-168,1,1,58,-108,58,1,1,1,1,1,-193,58,58,-135,58,-129,-128,58,-188,-190,-186,-184,-110,]),'DoubleVerticalBar':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,59,-120,-118,-142,-141,59,-140,59,59,-79,59,59,-155,-156,-127,59,-143,59,-23,59,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,59,59,-133,-175,59,-154,-152,-105,-65,-29,-92,59,59,-99,-31,59,59,-48,-52,59,-43,59,-139,-64,-26,59,59,-8,-13,59,-90,59,59,-66,59,59,59,-51,59,-6,59,-91,-78,-172,59,59,59,59,-171,-46,-11,-136,-58,-5,-147,-144,59,-146,59,-56,-41,59,-21,59,-97,-96,59,-153,-156,-10,-24,-80,-9,-40,-54,59,-32,59,59,59,-19,59,59,59,-100,59,-145,-61,59,59,-134,59,-20,-42,-50,59,59,-53,-67,-130,-131,-49,59,59,-12,59,-33,59,-82,59,59,59,59,59,-109,-122,59,-138,-176,-151,-168,-154,-150,-108,59,59,59,-135,-149,-129,-128,59,-110,]),'Union':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,60,-120,-118,-142,-141,60,-140,60,60,-79,60,60,60,-156,-127,60,-143,60,-23,60,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,60,60,-133,-175,60,-154,60,-105,-65,60,-92,60,60,-99,60,60,60,60,-52,60,60,60,-139,-64,-26,60,60,-8,-13,60,60,60,60,-66,60,60,60,60,60,-6,60,60,-78,-172,60,60,60,60,-171,-46,-11,-136,60,-5,-147,-144,60,-146,60,-56,60,60,-21,60,60,-96,60,60,-156,-10,-24,-80,-9,60,-54,60,60,60,60,60,-19,60,60,60,-100,60,-145,60,60,60,-134,60,-20,60,60,60,60,-53,-67,-130,-131,60,60,60,-12,60,60,60,-82,60,60,60,60,60,-109,-122,60,-138,-176,60,-168,-154,60,-108,60,60,60,-135,60,-129,-128,60,-110,]),'ConjugateTranspose':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,61,-120,-118,61,61,61,61,61,61,61,61,61,61,-156,-127,61,61,61,61,61,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,61,-45,-18,-36,-89,-169,-107,-22,-132,61,61,-133,-175,61,-154,61,-105,61,61,61,61,61,61,61,61,61,61,-52,61,61,61,61,-64,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,-172,61,61,61,61,-171,61,61,-136,61,-5,61,61,61,61,61,61,61,61,61,61,61,61,61,61,-156,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,61,-134,61,61,61,61,61,61,-53,61,-130,-131,61,61,61,61,61,61,61,61,61,61,61,61,61,-109,-122,61,61,-176,61,-168,-154,61,-108,61,61,61,-135,61,-129,-128,61,-110,]),'ReplaceRepeated':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,62,-120,-118,-142,-141,-157,-140,62,62,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,62,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,62,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,62,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,62,-66,-63,62,62,-51,62,-6,62,-91,-78,-172,-101,-72,62,62,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,62,-21,-27,-97,-96,62,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,62,-81,-76,-19,-85,62,-3,-100,-74,-145,-61,-2,62,-134,-102,-20,-42,-50,-75,62,-53,-67,-130,-131,-49,-86,-44,-12,62,-33,-30,-82,-83,62,-4,-70,62,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,62,62,62,-135,-149,-129,-128,-160,-110,]),'UpSetDelayed':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,63,-120,-118,-142,-141,-157,-140,63,63,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,63,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,63,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,63,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,63,-66,-63,-7,63,-51,-84,-6,63,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,63,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,63,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,63,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,63,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,63,63,63,-135,-149,-129,-128,-160,-110,]),'RepeatedNull':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,85,-120,-118,-142,-141,-157,-140,85,85,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,85,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,85,-133,-175,85,-154,-152,-105,-65,-29,-92,85,85,-99,-31,-47,85,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,85,-66,-63,85,85,-51,85,-6,85,-91,-78,-172,-101,-72,85,85,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,85,-21,-27,-97,-96,85,-153,-156,-10,-24,-80,-9,-40,-54,85,-32,85,85,85,-19,-85,85,-3,-100,85,-145,-61,85,85,-134,-102,-20,-42,-50,85,85,-53,-67,-130,-131,-49,-86,-44,-12,85,-33,-30,-82,-83,85,-4,85,85,-109,-122,85,-138,-176,-151,-168,-154,-150,-108,85,85,85,-135,-149,-129,-128,85,-110,]),'op_Equal':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,65,-120,-118,-142,-141,65,-140,65,65,-79,65,65,-155,-156,-127,65,-143,65,-23,65,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,65,65,-133,-175,65,-154,-152,-105,-65,-29,-92,65,65,-99,-31,65,65,-48,-52,65,-43,65,-139,-64,-26,65,65,-8,-13,65,-90,65,65,-66,65,65,65,-51,65,-6,65,-91,-78,-172,65,65,65,65,-171,-46,-11,-136,-58,-5,-147,-144,65,-146,65,-56,-41,65,-21,65,-97,-96,65,-153,-156,-10,-24,-80,-9,-40,-54,65,-32,65,65,65,-19,65,65,65,-100,65,-145,-61,65,65,-134,65,-20,-42,-50,65,65,-53,-67,-130,-131,-49,65,65,-12,65,-33,65,-82,65,65,65,65,65,-109,-122,65,-138,-176,-151,-168,-154,-150,-108,65,65,65,-135,-149,-129,-128,65,-110,]),'LeftTee':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,66,-120,-118,-142,-141,-157,-140,66,66,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,66,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,66,-133,-175,66,-154,-152,-105,-65,-29,-92,66,66,-99,-31,-47,66,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,66,-66,-63,66,66,-51,66,-6,66,-91,-78,-172,-101,-72,66,66,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,66,-21,-27,-97,-96,66,-153,-156,-10,-24,-80,-9,-40,-54,66,-32,66,66,66,-19,66,66,-3,-100,66,-145,-61,66,66,-134,-102,-20,-42,-50,66,66,-53,-67,-130,-131,-49,-86,-44,-12,66,-33,-30,-82,-83,66,-4,66,66,-109,-122,66,-138,-176,-151,-168,-154,-150,-108,66,66,66,-135,-149,-129,-128,66,-110,]),'slotseq':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[11,11,-123,11,11,-126,11,11,11,-125,-122,-124,11,11,11,-119,11,11,11,-121,11,11,11,11,11,11,11,-120,-118,11,-142,-141,11,-140,11,11,-179,11,11,11,11,11,-79,11,11,11,11,-127,11,-143,11,-23,11,11,11,11,-16,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-68,11,11,11,11,11,11,11,11,11,-137,11,11,11,11,-69,11,11,11,11,11,11,11,11,-106,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,-37,11,11,11,11,11,11,11,11,-17,11,-39,11,11,11,11,11,11,-148,11,11,11,-45,-18,11,11,11,11,-36,11,11,11,11,-89,11,11,11,11,11,11,11,11,11,-169,11,11,11,11,11,-107,-22,-132,11,11,11,11,-133,11,-180,11,11,11,11,11,-194,11,-175,11,11,11,-105,11,11,11,11,11,11,11,11,11,11,-52,11,11,11,11,-64,-26,11,11,11,-13,11,11,11,11,11,11,11,11,11,11,-6,11,11,-78,-172,11,11,11,11,-171,11,11,-136,11,-5,-147,-144,11,-146,11,-56,11,11,11,11,11,-96,11,11,11,-10,-24,11,-9,11,11,11,11,11,11,11,11,11,11,11,-100,11,-145,11,11,11,-134,11,-20,11,11,11,11,-53,-67,-130,-131,11,11,11,11,11,11,11,11,-82,11,11,11,11,11,-109,11,-122,11,-138,-189,-191,-192,-187,-185,-183,11,-195,-176,11,11,11,-168,11,11,11,-108,11,11,11,11,11,11,-193,11,11,-135,11,-129,-128,11,-188,-190,-186,-184,-110,]),'op_LessEqual':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,68,-120,-118,-142,-141,68,-140,68,68,-79,68,68,-155,-156,-127,68,-143,68,-23,68,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,68,68,-133,-175,68,-154,-152,-105,-65,-29,-92,68,68,-99,-31,68,68,-48,-52,68,-43,68,-139,-64,-26,68,68,-8,-13,68,-90,68,68,-66,68,68,68,-51,68,-6,68,-91,-78,-172,68,68,68,68,-171,-46,-11,-136,-58,-5,-147,-144,68,-146,68,-56,-41,68,-21,68,-97,-96,68,-153,-156,-10,-24,-80,-9,-40,-54,68,-32,68,68,68,-19,68,68,68,-100,68,-145,-61,68,68,-134,68,-20,-42,-50,68,68,-53,-67,-130,-131,-49,68,68,-12,68,-33,68,-82,68,68,68,68,68,-109,-122,68,-138,-176,-151,-168,-154,-150,-108,68,68,68,-135,-149,-129,-128,68,-110,]),'slot':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[2,2,-123,2,2,-126,2,2,2,-125,-122,-124,2,2,2,-119,2,2,2,-121,2,2,2,2,2,2,2,-120,-118,2,-142,-141,2,-140,2,2,-179,2,2,2,2,2,-79,2,2,2,2,-127,2,-143,2,-23,2,2,2,2,-16,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,-68,2,2,2,2,2,2,2,2,2,-137,2,2,2,2,-69,2,2,2,2,2,2,2,2,-106,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,-37,2,2,2,2,2,2,2,2,-17,2,-39,2,2,2,2,2,2,-148,2,2,2,-45,-18,2,2,2,2,-36,2,2,2,2,-89,2,2,2,2,2,2,2,2,2,-169,2,2,2,2,2,-107,-22,-132,2,2,2,2,-133,2,-180,2,2,2,2,2,-194,2,-175,2,2,2,-105,2,2,2,2,2,2,2,2,2,2,-52,2,2,2,2,-64,-26,2,2,2,-13,2,2,2,2,2,2,2,2,2,2,-6,2,2,-78,-172,2,2,2,2,-171,2,2,-136,2,-5,-147,-144,2,-146,2,-56,2,2,2,2,2,-96,2,2,2,-10,-24,2,-9,2,2,2,2,2,2,2,2,2,2,2,-100,2,-145,2,2,2,-134,2,-20,2,2,2,2,-53,-67,-130,-131,2,2,2,2,2,2,2,2,-82,2,2,2,2,2,-109,2,-122,2,-138,-189,-191,-192,-187,-185,-183,2,-195,-176,2,2,2,-168,2,2,2,-108,2,2,2,2,2,2,-193,2,2,-135,2,-129,-128,2,-188,-190,-186,-184,-110,]),'MapAll':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,69,-120,-118,69,69,69,69,69,69,69,69,69,69,-156,-127,69,69,69,69,69,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,69,-45,-18,-36,-89,-169,-107,-22,-132,69,69,-133,-175,69,-154,69,-105,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,-64,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,-172,69,69,69,69,-171,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,-156,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,69,-134,69,69,69,69,69,69,69,69,-130,-131,69,69,69,69,69,69,69,69,69,69,69,69,69,-109,-122,69,69,-176,69,-168,-154,69,-108,69,69,69,-135,69,-129,-128,69,-110,]),'RawAmpersand':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,138,-120,-118,-142,-141,-157,-140,138,138,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,138,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,138,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,138,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,138,-66,-63,138,138,-51,-84,-6,138,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,138,-21,-27,-97,-96,138,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,138,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,138,-134,-102,-20,-42,-50,-75,138,-53,-67,-130,-131,-49,-86,-44,-12,138,-33,-30,-82,-83,138,-4,-70,138,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,138,138,138,-135,-149,-129,-128,-160,-110,]),'Greater':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,71,-120,-118,-142,-141,71,-140,71,71,-79,71,71,-155,-156,-127,71,-143,71,-23,71,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,71,71,-133,-175,71,-154,-152,-105,-65,-29,-92,71,71,-99,-31,71,71,-48,-52,71,-43,71,-139,-64,-26,71,71,-8,-13,71,-90,71,71,-66,71,71,71,-51,71,-6,71,-91,-78,-172,71,71,71,71,-171,-46,-11,-136,-58,-5,-147,-144,71,-146,71,-56,-41,71,-21,71,-97,-96,71,-153,-156,-10,-24,-80,-9,-40,-54,71,-32,71,71,71,-19,71,71,71,-100,71,-145,-61,71,71,-134,71,-20,-42,-50,71,71,-53,-67,-130,-131,-49,71,71,-12,71,-33,71,-82,71,71,71,71,71,-109,-122,71,-138,-176,-151,-168,-154,-150,-108,71,71,71,-135,-149,-129,-128,71,-110,]),'Equivalent':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,72,-120,-118,-142,-141,-157,-140,72,72,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,72,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,72,-133,-175,72,-154,-152,-105,-65,-29,-92,72,72,-99,-31,72,72,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,72,-66,-63,72,72,-51,72,-6,72,-91,-78,-172,-101,72,72,72,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,72,-56,-41,72,-21,72,-97,-96,72,-153,-156,-10,-24,-80,-9,-40,-54,72,-32,72,72,72,-19,72,72,-3,-100,72,-145,-61,72,72,-134,-102,-20,-42,-50,72,72,-53,-67,-130,-131,-49,-86,72,-12,72,-33,-30,-82,-83,72,-4,72,72,-109,-122,72,-138,-176,-151,-168,-154,-150,-108,72,72,72,-135,-149,-129,-128,72,-110,]),'Minus':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[3,3,-123,3,3,-126,3,3,3,-125,-122,-124,3,3,3,-119,3,3,3,-121,3,3,3,73,3,3,3,-120,-118,3,-142,-141,73,-140,73,3,-179,3,3,73,3,3,-79,73,73,73,3,-127,73,-143,73,-23,73,3,3,3,-16,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,-68,3,3,3,3,3,3,3,3,3,-137,3,3,3,3,-69,3,3,3,3,3,3,3,3,-106,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,-37,3,3,3,3,3,3,3,3,-17,3,-39,3,3,3,3,3,3,-148,3,3,3,-45,-18,3,3,3,3,-36,3,3,3,3,-89,3,3,3,3,3,3,3,3,3,-169,3,3,3,3,3,-107,-22,-132,73,73,3,3,-133,3,-180,3,3,3,3,3,-194,3,-175,73,3,73,-105,-65,73,73,73,73,-99,73,73,73,73,-52,73,73,73,-139,-64,-26,73,73,-8,-13,73,73,73,73,-66,73,73,73,73,73,-6,73,73,-78,-172,73,73,73,73,-171,73,-11,-136,73,-5,-147,-144,73,-146,73,-56,73,73,-21,73,73,-96,73,73,3,-10,-24,-80,-9,73,-54,73,73,73,73,73,-19,73,73,73,-100,73,-145,73,73,73,-134,73,-20,73,73,73,73,-53,-67,-130,-131,73,73,73,-12,73,73,73,3,-82,73,73,73,73,73,-109,3,-122,73,-138,-189,-191,-192,-187,-185,-183,3,-195,-176,73,3,3,-168,3,3,73,-108,73,3,3,3,3,3,-193,73,73,-135,73,-129,-128,73,-188,-190,-186,-184,-110,]),'PatternTest':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,74,-120,-118,74,74,74,74,74,74,74,74,74,74,-156,-127,74,74,74,74,74,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,74,-45,-18,-36,-89,-169,-107,-22,74,74,74,74,-175,74,-154,74,-105,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,None,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,-172,74,74,74,74,-171,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,-156,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,74,-130,-131,74,74,74,74,74,74,74,74,74,74,74,74,74,-109,-122,74,74,-176,74,-168,-154,74,-108,74,74,74,74,74,-129,-128,74,-110,]),'Not':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[4,4,-123,4,4,-126,4,4,4,-125,-122,-124,4,4,4,-119,-156,4,4,-121,4,4,4,4,4,4,4,-120,-118,4,-142,-141,4,-140,4,4,-179,4,4,4,4,4,-79,-35,-60,-155,-156,-127,4,-143,-38,-23,4,4,4,4,-16,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,-68,4,4,4,4,4,4,4,4,4,-137,4,4,4,4,-69,4,4,4,4,4,4,4,4,-106,4,4,4,4,4,4,4,4,4,4,-154,4,4,4,4,-37,4,4,4,4,4,4,4,4,-17,4,-39,4,4,4,4,4,4,-148,4,4,4,-45,-18,4,4,4,4,-36,4,4,4,4,-89,4,4,4,4,4,4,4,4,4,-169,4,4,4,4,4,-107,-22,-132,4,4,4,4,-133,4,-180,4,4,4,4,4,-194,4,-175,4,-154,-152,-105,-65,-29,-92,4,4,-99,-31,4,4,-48,-52,-59,-43,4,-139,-64,-26,-93,4,-8,-13,4,-90,4,4,-66,4,4,4,-51,4,-6,4,-91,-78,-172,4,4,4,4,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,4,-56,-41,4,-21,4,-97,-96,4,-153,-156,-10,-24,-80,-9,-40,-54,4,-32,4,4,4,-19,4,4,4,-100,4,-145,-61,4,4,-134,4,-20,-42,-50,4,4,-53,-67,-130,-131,-49,-86,4,-12,4,-33,-30,4,-82,-83,4,4,4,4,-109,4,-122,4,-138,-189,-191,-192,-187,-185,-183,4,-195,-176,-151,4,4,-168,4,-154,-150,-108,4,4,4,4,4,4,-193,4,4,-135,-149,-129,-128,4,-188,-190,-186,-184,-110,]),'RawDot':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,75,-120,-118,75,75,75,75,75,75,-79,75,75,75,-156,-127,75,75,75,-23,75,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,75,-45,-18,-36,-89,-169,-107,-22,-132,75,75,-133,-175,75,-154,75,-105,75,75,75,75,75,75,75,75,75,75,-52,75,75,75,75,-64,-26,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,-78,-172,75,75,75,75,-171,75,75,-136,75,-5,75,75,75,75,75,-56,75,75,75,75,75,75,75,75,-156,-10,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,-134,75,-20,75,75,75,75,-53,-67,-130,-131,75,75,75,75,75,75,75,-82,75,75,75,75,75,-109,-122,75,-138,-176,75,-168,-154,75,-108,75,75,75,-135,75,-129,-128,75,-110,]),'UnsameQ':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,76,-120,-118,-142,-141,76,-140,76,76,-79,76,76,-155,-156,-127,76,-143,76,-23,76,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,76,76,-133,-175,76,-154,-152,-105,-65,-29,-92,76,76,-99,-31,76,76,-48,-52,76,-43,76,-139,-64,-26,-93,76,-8,-13,76,-90,76,76,-66,76,76,76,-51,76,-6,76,-91,-78,-172,76,76,76,76,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,76,-56,-41,76,-21,76,-97,-96,76,-153,-156,-10,-24,-80,-9,-40,-54,76,-32,76,76,76,-19,76,76,76,-100,76,-145,-61,76,76,-134,76,-20,-42,-50,76,76,-53,-67,-130,-131,-49,76,76,-12,76,-33,76,-82,76,76,76,76,76,-109,-122,76,-138,-176,-151,-168,-154,-150,-108,76,76,76,-135,-149,-129,-128,76,-110,]),'Nor':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,77,-120,-118,-142,-141,-157,-140,77,77,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,77,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,77,-133,-175,77,-154,-152,-105,-65,-29,-92,77,77,-99,-31,77,77,-48,-52,-59,-43,77,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,77,-66,-63,77,77,-51,77,-6,77,-91,-78,-172,-101,77,77,77,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,77,-56,-41,77,-21,77,-97,-96,77,-153,-156,-10,-24,-80,-9,-40,-54,77,-32,77,77,77,-19,77,77,-3,-100,77,-145,-61,77,77,-134,-102,-20,-42,-50,77,77,-53,-67,-130,-131,-49,-86,77,-12,77,-33,-30,-82,-83,77,-4,77,77,-109,-122,77,-138,-176,-151,-168,-154,-150,-108,77,77,77,-135,-149,-129,-128,77,-110,]),'string':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[5,5,-123,5,5,-126,5,5,5,-125,-122,-124,5,5,5,-119,5,5,5,-121,5,5,5,5,5,5,5,-120,-118,5,-142,-141,5,-140,5,5,-179,5,5,5,5,5,-79,5,5,5,5,-127,5,-143,5,-23,5,5,5,5,-16,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,-68,5,5,5,5,5,5,5,5,5,-137,5,5,5,5,-69,5,5,5,5,5,5,5,5,-106,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,-37,5,5,5,5,5,5,5,5,-17,5,-39,5,5,5,5,5,5,-148,5,5,5,-45,-18,5,5,5,5,-36,5,5,5,5,-89,295,5,5,5,5,5,5,5,5,5,-169,5,5,5,5,5,-107,-22,-132,5,5,5,5,-133,5,-180,5,5,5,5,5,-194,5,-175,5,5,5,-105,5,5,5,5,5,5,5,5,5,5,-52,5,5,5,5,-64,-26,5,5,5,-13,5,5,5,5,5,5,5,5,5,5,-6,5,5,-78,-172,5,5,5,5,-171,5,5,-136,5,-5,-147,-144,5,-146,5,-56,5,5,5,5,5,-96,5,5,5,-10,-24,5,-9,5,5,5,5,5,5,5,5,5,5,5,-100,5,-145,5,5,5,-134,5,-20,5,5,5,5,-53,-67,-130,-131,5,5,5,5,5,5,5,5,-82,5,5,5,5,5,-109,5,-122,5,-138,-189,-191,-192,-187,-185,-183,5,-195,-176,5,5,5,-168,5,5,5,348,349,-108,5,5,5,5,5,5,-193,5,5,-135,5,-129,-128,5,-188,-190,-186,-184,-110,]),'Cap':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,78,-120,-118,-142,-141,78,-140,78,78,-79,78,78,78,-156,-127,78,-143,78,-23,78,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,78,78,-133,-175,78,-154,78,-105,78,78,78,78,78,-99,78,78,78,78,-52,78,78,78,78,-64,-26,78,78,-8,-13,78,78,78,78,78,78,78,78,78,78,-6,78,78,-78,-172,78,78,78,78,-171,78,78,-136,78,-5,-147,-144,78,-146,78,-56,78,78,-21,78,78,-96,78,78,-156,-10,-24,-80,-9,78,78,78,78,78,78,78,-19,78,78,78,-100,78,-145,78,78,78,-134,78,-20,78,78,78,78,-53,-67,-130,-131,78,78,78,78,78,78,78,-82,78,78,78,78,78,-109,-122,78,-138,-176,78,-168,-154,78,-108,78,78,78,-135,78,-129,-128,78,-110,]),'CircleTimes':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,79,-120,-118,-142,-141,79,-140,79,79,-79,79,79,79,-156,-127,79,-143,79,-23,79,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,79,-45,-18,-36,-89,-169,-107,-22,-132,79,79,-133,-175,79,-154,79,-105,79,79,79,79,79,79,79,79,79,79,-52,79,79,79,79,-64,-26,79,79,79,-13,79,79,79,79,79,79,79,79,79,79,-6,79,79,-78,-172,79,79,79,79,-171,79,79,-136,79,-5,79,-144,79,79,79,-56,79,79,79,79,79,-96,79,79,-156,-10,-24,79,79,79,79,79,79,79,79,79,79,79,79,79,-100,79,-145,79,79,79,-134,79,-20,79,79,79,79,-53,-67,-130,-131,79,79,79,79,79,79,79,-82,79,79,79,79,79,-109,-122,79,-138,-176,79,-168,-154,79,-108,79,79,79,-135,79,-129,-128,79,-110,]),'Nand':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,80,-120,-118,-142,-141,-157,-140,80,80,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,80,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,80,-133,-175,80,-154,-152,-105,-65,-29,-92,80,80,-99,-31,80,80,-48,-52,-59,-43,80,-139,-64,-26,-93,80,-8,-13,-55,-90,80,80,-66,80,80,80,-51,80,-6,80,-91,-78,-172,80,80,80,80,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,80,-56,-41,80,-21,80,-97,-96,80,-153,-156,-10,-24,-80,-9,-40,-54,80,-32,80,80,80,-19,80,80,-3,-100,80,-145,-61,80,80,-134,80,-20,-42,-50,80,80,-53,-67,-130,-131,-49,-86,80,-12,80,-33,-30,-82,-83,80,-4,80,80,-109,-122,80,-138,-176,-151,-168,-154,-150,-108,80,80,80,-135,-149,-129,-128,80,-110,]),'op_Unequal':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,81,-120,-118,-142,-141,81,-140,81,81,-79,81,81,-155,-156,-127,81,-143,81,-23,81,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,81,81,-133,-175,81,-154,-152,-105,-65,-29,-92,81,81,-99,-31,81,81,-48,-52,81,-43,81,-139,-64,-26,81,81,-8,-13,81,-90,81,81,-66,81,81,81,-51,81,-6,81,-91,-78,-172,81,81,81,81,-171,-46,-11,-136,-58,-5,-147,-144,81,-146,81,-56,-41,81,-21,81,-97,-96,81,-153,-156,-10,-24,-80,-9,-40,-54,81,-32,81,81,81,-19,81,81,81,-100,81,-145,-61,81,81,-134,81,-20,-42,-50,81,81,-53,-67,-130,-131,-49,81,81,-12,81,-33,81,-82,81,81,81,81,81,-109,-122,81,-138,-176,-151,-168,-154,-150,-108,81,81,81,-135,-149,-129,-128,81,-110,]),'op_Or':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,82,-120,-118,-142,-141,-157,-140,82,82,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,82,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,82,-133,-175,82,-154,-152,-105,-65,-29,-92,82,82,-99,-31,82,82,-48,-52,-59,-43,82,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,82,-66,-63,82,82,-51,82,-6,82,-91,-78,-172,-101,82,82,82,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,82,-56,-41,82,-21,82,-97,-96,82,-153,-156,-10,-24,-80,-9,-40,-54,82,-32,82,82,82,-19,82,82,-3,-100,82,-145,-61,82,82,-134,-102,-20,-42,-50,82,82,-53,-67,-130,-131,-49,-86,82,-12,82,-33,-30,-82,-83,82,-4,82,82,-109,-122,82,-138,-176,-151,-168,-154,-150,-108,82,82,82,-135,-149,-129,-128,82,-110,]),'RuleDelayed':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,142,-120,-118,-142,-141,-157,-140,142,142,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,142,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,142,-133,-175,-162,-154,-152,-105,-65,-29,-92,142,142,-99,-31,-47,142,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,142,-66,-63,142,142,-51,142,-6,142,-91,-78,-172,-101,-72,142,142,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,142,-21,-27,-97,-96,142,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,142,-81,142,-19,-85,142,-3,-100,142,-145,-61,-2,142,-134,-102,-20,-42,-50,142,142,-53,-67,-130,-131,-49,-86,-44,-12,142,-33,-30,-82,-83,142,-4,142,142,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,142,142,142,-135,-149,-129,-128,-160,-110,]),'Plus':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[6,6,-123,6,6,-126,6,6,6,-125,-122,-124,6,6,6,-119,6,6,6,-121,6,6,6,84,6,6,6,-120,-118,6,-142,-141,84,-140,84,6,-179,6,6,84,6,6,-79,84,84,84,6,-127,84,-143,84,-23,84,6,6,6,-16,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,-68,6,6,6,6,6,6,6,6,6,-137,6,6,6,6,-69,6,6,6,6,6,6,6,6,-106,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,-37,6,6,6,6,6,6,6,6,-17,6,-39,6,6,6,6,6,6,-148,6,6,6,-45,-18,6,6,6,6,-36,6,6,6,6,-89,6,6,6,6,6,6,6,6,6,-169,6,6,6,6,6,-107,-22,-132,84,84,6,6,-133,6,-180,6,6,6,6,6,-194,6,-175,84,6,84,-105,-65,84,84,84,84,-99,84,84,84,84,-52,84,84,84,-139,-64,-26,84,84,-8,-13,84,84,84,84,-66,84,84,84,84,84,-6,84,84,-78,-172,84,84,84,84,-171,84,-11,-136,84,-5,-147,-144,84,-146,84,-56,84,84,-21,84,84,-96,84,84,6,-10,-24,-80,-9,84,-54,84,84,84,84,84,-19,84,84,84,-100,84,-145,84,84,84,-134,84,-20,84,84,84,84,-53,-67,-130,-131,84,84,84,-12,84,84,84,6,-82,84,84,84,84,84,-109,6,-122,84,-138,-189,-191,-192,-187,-185,-183,6,-195,-176,84,6,6,-168,6,6,84,-108,84,6,6,6,6,6,-193,84,84,-135,84,-129,-128,84,-188,-190,-186,-184,-110,]),'VerticalTilde':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,64,-120,-118,-142,-141,64,-140,64,64,-79,64,64,64,-156,-127,64,-143,64,-23,64,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,64,64,-133,-175,64,-154,64,-105,64,64,64,64,64,-99,64,64,64,64,-52,64,64,64,64,-64,-26,64,64,64,-13,64,64,64,64,64,64,64,64,64,64,-6,64,64,-78,-172,64,64,64,64,-171,64,64,-136,64,-5,-147,-144,64,-146,64,-56,64,64,64,64,64,-96,64,64,-156,-10,-24,-80,-9,64,64,64,64,64,64,64,64,64,64,64,-100,64,-145,64,64,64,-134,64,-20,64,64,64,64,-53,-67,-130,-131,64,64,64,64,64,64,64,-82,64,64,64,64,64,-109,-122,64,-138,-176,64,-168,-154,64,-108,64,64,64,-135,64,-129,-128,64,-110,]),'DifferentialD':([2,5,9,10,11,16,17,21,30,31,33,34,35,36,37,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,187,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,-164,-166,-135,-149,-129,-128,-160,-110,]),'Or':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,86,-120,-118,-142,-141,-157,-140,86,86,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,86,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,86,-133,-175,86,-154,-152,-105,-65,-29,-92,86,86,-99,-31,86,86,-48,-52,-59,-43,86,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,86,-66,-63,86,86,-51,86,-6,86,-91,-78,-172,-101,86,86,86,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,86,-56,-41,86,-21,86,-97,-96,86,-153,-156,-10,-24,-80,-9,-40,-54,86,-32,86,86,86,-19,86,86,-3,-100,86,-145,-61,86,86,-134,-102,-20,-42,-50,86,86,-53,-67,-130,-131,-49,-86,86,-12,86,-33,-30,-82,-83,86,-4,86,86,-109,-122,86,-138,-176,-151,-168,-154,-150,-108,86,86,86,-135,-149,-129,-128,86,-110,]),'Divide':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,143,-120,-118,-142,-141,143,-140,143,143,-79,143,143,143,-156,-127,143,-143,143,-23,143,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,143,-45,-18,-36,-89,-169,-107,-22,-132,143,143,-133,-175,143,-154,143,-105,143,143,143,143,143,143,143,143,143,143,-52,143,143,143,143,-64,-26,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,-78,-172,143,143,143,143,-171,143,143,-136,143,-5,143,-144,143,143,143,-56,143,143,143,143,143,143,143,143,-156,-10,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,143,-145,143,143,143,-134,143,-20,143,143,143,143,-53,-67,-130,-131,143,143,143,143,143,143,143,-82,143,143,143,143,143,-109,-122,143,-138,-176,143,-168,-154,143,-108,143,143,143,-135,143,-129,-128,143,-110,]),'Because':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,87,-120,-118,-142,-141,-157,-140,87,87,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,87,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,87,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,87,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,87,-66,-63,-7,87,-51,-84,-6,87,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,87,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,87,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,87,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,87,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,87,87,87,-135,-149,-129,-128,-160,-110,]),'Semicolon':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,88,-120,-118,-142,-141,-157,-140,88,88,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,88,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,88,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,88,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,88,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,88,-164,-166,-135,-149,-129,-128,-160,-110,]),'Less':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,89,-120,-118,-142,-141,89,-140,89,89,-79,89,89,-155,-156,-127,89,-143,89,-23,89,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,89,89,-133,-175,89,-154,-152,-105,-65,-29,-92,89,89,-99,-31,89,89,-48,-52,89,-43,89,-139,-64,-26,89,89,-8,-13,89,-90,89,89,-66,89,89,89,-51,89,-6,89,-91,-78,-172,89,89,89,89,-171,-46,-11,-136,-58,-5,-147,-144,89,-146,89,-56,-41,89,-21,89,-97,-96,89,-153,-156,-10,-24,-80,-9,-40,-54,89,-32,89,89,89,-19,89,89,89,-100,89,-145,-61,89,89,-134,89,-20,-42,-50,89,89,-53,-67,-130,-131,-49,89,89,-12,89,-33,89,-82,89,89,89,89,89,-109,-122,89,-138,-176,-151,-168,-154,-150,-108,89,89,89,-135,-149,-129,-128,89,-110,]),'Integral':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[7,7,-123,7,7,-126,7,7,7,-125,-122,-124,7,7,7,-119,7,7,7,-121,7,7,7,7,7,7,7,-120,-118,7,7,7,7,7,7,7,-179,7,7,7,7,7,7,7,7,7,7,-127,7,7,7,7,7,7,7,7,-16,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,-68,7,7,7,7,7,7,7,7,7,-137,7,7,7,7,-69,7,7,7,7,7,7,7,7,-106,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,-37,7,7,7,7,7,7,7,7,-17,7,-39,7,7,7,7,7,7,7,7,7,7,-45,-18,7,7,7,7,-36,7,7,7,7,-89,7,7,7,7,7,7,7,7,7,-169,7,7,7,7,7,-107,-22,-132,7,7,7,7,-133,7,-180,7,7,7,7,7,-194,7,-175,7,7,7,-105,7,7,7,7,7,7,7,7,7,7,-52,7,7,7,7,-64,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,-172,7,7,7,7,-171,7,7,-136,7,-5,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,-134,7,7,7,7,7,7,-53,-67,-130,-131,7,7,7,7,7,7,7,7,-82,7,7,7,7,7,-109,7,-122,7,7,-189,-191,-192,-187,-185,-183,7,-195,-176,7,7,7,-168,7,7,7,-108,7,7,7,7,7,7,-193,7,7,-135,7,-129,-128,7,-188,-190,-186,-184,-110,]),'SubtractFrom':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,90,-120,-118,-142,-141,-157,-140,90,90,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,90,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,90,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,90,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,90,-66,-63,90,90,-51,90,-6,90,-91,-78,-172,-101,-72,90,90,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,90,-21,-27,-97,-96,90,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,90,-81,-76,-19,-85,90,-3,-100,-74,-145,-61,-2,90,-134,-102,-20,-42,-50,-75,90,-53,-67,-130,-131,-49,-86,-44,-12,90,-33,-30,-82,-83,90,-4,-70,90,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,90,90,90,-135,-149,-129,-128,-160,-110,]),'RawBackslash':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,91,-120,-118,-142,-141,91,-140,91,91,-79,91,91,91,-156,-127,91,-143,91,-23,91,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,91,-45,-18,-36,-89,-169,-107,-22,-132,91,91,-133,-175,91,-154,91,-105,91,91,91,91,91,91,91,91,91,91,-52,91,91,91,91,-64,-26,91,91,91,91,91,91,91,91,91,91,91,91,91,91,None,91,91,-78,-172,91,91,91,91,-171,91,91,-136,91,-5,91,-144,91,91,91,-56,91,91,91,91,91,91,91,91,-156,-10,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,91,-145,91,91,91,-134,91,-20,91,91,91,91,-53,-67,-130,-131,91,91,91,91,91,91,91,-82,91,91,91,91,91,-109,-122,91,-138,-176,91,-168,-154,91,-108,91,91,91,-135,91,-129,-128,91,-110,]),'TagSet':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,92,-120,-118,-142,-141,-157,-140,92,92,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,92,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,92,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,92,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,92,-66,-63,-7,92,-51,-84,-6,92,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,92,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,92,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,92,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,92,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,92,92,92,-135,-149,-129,-128,-160,-110,]),'CircleMinus':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,104,-120,-118,-142,-141,104,-140,104,104,-79,104,104,104,-156,-127,104,-143,104,-23,104,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,104,104,-133,-175,104,-154,104,-105,104,104,104,104,104,-99,104,104,104,104,-52,104,104,104,104,-64,-26,104,104,-8,-13,104,104,104,104,104,104,104,104,104,104,-6,104,104,-78,-172,104,104,104,104,-171,104,-11,-136,104,-5,-147,-144,104,-146,104,-56,104,104,-21,104,104,-96,104,104,-156,-10,-24,-80,-9,104,104,104,104,104,104,104,-19,104,104,104,-100,104,-145,104,104,104,-134,104,-20,104,104,104,104,-53,-67,-130,-131,104,104,104,-12,104,104,104,-82,104,104,104,104,104,-109,-122,104,-138,-176,104,-168,-154,104,-108,104,104,104,-135,104,-129,-128,104,-110,]),'NotEqual':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,93,-120,-118,-142,-141,93,-140,93,93,-79,93,93,-155,-156,-127,93,-143,93,-23,93,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,93,93,-133,-175,93,-154,-152,-105,-65,-29,-92,93,93,-99,-31,93,93,-48,-52,93,-43,93,-139,-64,-26,93,93,-8,-13,93,-90,93,93,-66,93,93,93,-51,93,-6,93,-91,-78,-172,93,93,93,93,-171,-46,-11,-136,-58,-5,-147,-144,93,-146,93,-56,-41,93,-21,93,-97,-96,93,-153,-156,-10,-24,-80,-9,-40,-54,93,-32,93,93,93,-19,93,93,93,-100,93,-145,-61,93,93,-134,93,-20,-42,-50,93,93,-53,-67,-130,-131,-49,93,93,-12,93,-33,93,-82,93,93,93,93,93,-109,-122,93,-138,-176,-151,-168,-154,-150,-108,93,93,93,-135,-149,-129,-128,93,-110,]),'SmallCircle':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,94,-120,-118,94,94,94,94,94,94,-79,94,94,94,-156,-127,94,94,94,-23,94,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,94,-45,-18,-36,-89,-169,-107,-22,-132,94,94,-133,-175,94,-154,94,-105,94,94,94,94,94,94,94,94,94,94,-52,94,94,94,94,-64,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,-78,-172,94,94,94,94,-171,94,94,-136,94,-5,94,94,94,94,94,94,94,94,94,94,94,94,94,94,-156,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,94,-134,94,94,94,94,94,94,-53,-67,-130,-131,94,94,94,94,94,94,94,-82,94,94,94,94,94,-109,-122,94,-138,-176,94,-168,-154,94,-108,94,94,94,-135,94,-129,-128,94,-110,]),'LeftBoxParenthesis':([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[8,8,-123,8,8,-126,8,8,8,-125,-122,-124,46,8,8,8,-119,-156,8,8,-121,8,8,8,8,8,8,8,-120,-118,8,-142,-141,-157,-140,8,8,-179,8,8,8,8,8,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,8,8,8,8,-16,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,8,-68,8,8,-174,8,8,8,8,8,8,-137,8,8,8,8,-69,8,8,8,8,8,8,8,8,-106,8,8,8,8,8,8,8,8,8,8,-154,8,8,8,8,-37,8,8,8,8,8,8,8,8,-17,8,-39,8,8,8,8,8,8,-148,8,8,8,-45,-18,8,8,8,8,-36,8,8,8,8,-89,8,8,8,8,8,8,8,8,8,-169,8,8,8,8,8,-107,-22,-132,-159,8,8,8,-133,8,-180,8,8,8,8,8,-194,8,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,8,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,8,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,8,-82,-83,-95,-4,-70,-14,-109,8,-122,-161,-138,-189,-191,-192,-187,-185,-183,8,-195,-176,-151,8,8,-168,8,-154,-150,-108,8,8,8,8,8,8,-193,-164,-166,-135,-149,-129,-128,-160,-188,-190,-186,-184,-110,]),'Fraction':([2,5,9,10,11,16,17,21,30,31,33,34,35,36,39,43,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,188,195,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,317,318,319,320,321,322,324,325,326,329,331,332,335,343,344,345,346,347,348,349,351,352,353,354,355,356,],[-123,-126,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,191,-177,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,191,-194,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-189,-191,-192,-187,-185,-183,191,-176,-151,-168,-154,-150,-108,-193,-164,-166,-135,-149,-129,-128,-160,-188,-190,-186,-184,-110,]),'Derivative':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,95,-120,-118,95,95,95,95,95,95,95,95,95,95,-156,-127,95,95,95,95,95,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,95,-45,-18,-36,-89,-169,-107,-22,-132,95,95,-133,-175,95,-154,95,-105,95,95,95,95,95,95,95,95,95,95,-52,95,95,95,95,-64,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,-172,95,95,95,95,-171,95,95,-136,95,-5,95,95,95,95,95,95,95,95,95,95,95,95,95,95,-156,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,95,-134,95,95,95,95,95,95,-53,95,-130,-131,95,95,95,95,95,95,95,95,95,95,95,95,95,-109,-122,95,95,-176,95,-168,-154,95,-108,95,95,95,-135,95,-129,-128,95,-110,]),'Subscript':([2,5,9,10,11,16,17,21,30,31,33,34,35,36,39,43,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,188,195,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,317,318,319,320,321,322,324,325,326,329,331,332,335,343,344,345,346,347,348,349,351,352,353,354,355,356,],[-123,-126,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,192,-177,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,192,192,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-189,-191,192,192,192,-183,192,-176,-151,-168,-154,-150,-108,192,-164,-166,-135,-149,-129,-128,-160,-188,-190,192,192,-110,]),'PutAppend':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,96,-120,-118,-142,-141,-157,-140,96,96,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,96,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,96,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,96,-51,-84,-6,96,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,96,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,96,-164,-166,-135,-149,-129,-128,-160,-110,]),'out':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[9,9,-123,9,9,-126,9,9,9,-125,-122,-124,9,9,9,-119,9,9,9,-121,9,9,9,9,9,9,9,-120,-118,9,-142,-141,9,-140,9,9,-179,9,9,9,9,9,-79,9,9,9,9,-127,9,-143,9,-23,9,9,9,9,-16,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,-68,9,9,9,9,9,9,9,9,9,-137,9,9,9,9,-69,9,9,9,9,9,9,9,9,-106,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,-37,9,9,9,9,9,9,9,9,-17,9,-39,9,9,9,9,9,9,-148,9,9,9,-45,-18,9,9,9,9,-36,9,9,9,9,-89,9,9,9,9,9,9,9,9,9,-169,9,9,9,9,9,-107,-22,-132,9,9,9,9,-133,9,-180,9,9,9,9,9,-194,9,-175,9,9,9,-105,9,9,9,9,9,9,9,9,9,9,-52,9,9,9,9,-64,-26,9,9,9,-13,9,9,9,9,9,9,9,9,9,9,-6,9,9,-78,-172,9,9,9,9,-171,9,9,-136,9,-5,-147,-144,9,-146,9,-56,9,9,9,9,9,-96,9,9,9,-10,-24,9,-9,9,9,9,9,9,9,9,9,9,9,9,-100,9,-145,9,9,9,-134,9,-20,9,9,9,9,-53,-67,-130,-131,9,9,9,9,9,9,9,9,-82,9,9,9,9,9,-109,9,-122,9,-138,-189,-191,-192,-187,-185,-183,9,-195,-176,9,9,9,-168,9,9,9,-108,9,9,9,9,9,9,-193,9,9,-135,9,-129,-128,9,-188,-190,-186,-184,-110,]),'Xnor':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,97,-120,-118,-142,-141,-157,-140,97,97,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,97,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,97,-133,-175,97,-154,-152,-105,-65,-29,-92,97,97,-99,-31,97,97,-48,-52,-59,-43,97,-139,-64,-26,-93,97,-8,-13,-55,-90,97,97,-66,97,97,97,-51,97,-6,97,-91,-78,-172,-101,97,97,97,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,97,-56,-41,97,-21,97,-97,-96,97,-153,-156,-10,-24,-80,-9,-40,-54,97,-32,97,97,97,-19,97,97,-3,-100,97,-145,-61,97,97,-134,-102,-20,-42,-50,97,97,-53,-67,-130,-131,-49,-86,97,-12,97,-33,-30,-82,-83,97,-4,97,97,-109,-122,97,-138,-176,-151,-168,-154,-150,-108,97,97,97,-135,-149,-129,-128,97,-110,]),'RightTee':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,98,-120,-118,-142,-141,-157,-140,98,98,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,98,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,98,-133,-175,98,-154,-152,-105,-65,-29,-92,98,98,-99,-31,98,98,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,98,-66,-63,98,98,-51,98,-6,98,-91,-78,-172,-101,98,98,98,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,98,-56,-41,98,-21,98,-97,-96,98,-153,-156,-10,-24,-80,-9,-40,-54,98,-32,98,98,98,-19,98,98,-3,-100,98,-145,-61,98,98,-134,-102,-20,-42,-50,98,98,-53,-67,-130,-131,-49,-86,-44,-12,98,-33,-30,-82,-83,98,-4,98,98,-109,-122,98,-138,-176,-151,-168,-154,-150,-108,98,98,98,-135,-149,-129,-128,98,-110,]),'TimesBy':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,99,-120,-118,-142,-141,-157,-140,99,99,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,99,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,99,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,99,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,99,-66,-63,99,99,-51,99,-6,99,-91,-78,-172,-101,-72,99,99,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,99,-21,-27,-97,-96,99,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,99,-81,-76,-19,-85,99,-3,-100,-74,-145,-61,-2,99,-134,-102,-20,-42,-50,-75,99,-53,-67,-130,-131,-49,-86,-44,-12,99,-33,-30,-82,-83,99,-4,-70,99,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,99,99,99,-135,-149,-129,-128,-160,-110,]),'filename':([18,96,102,],[52,238,243,]),'DivideBy':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,100,-120,-118,-142,-141,-157,-140,100,100,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,100,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,100,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,100,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,100,-66,-63,100,100,-51,100,-6,100,-91,-78,-172,-101,-72,100,100,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,100,-21,-27,-97,-96,100,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,100,-81,-76,-19,-85,100,-3,-100,-74,-145,-61,-2,100,-134,-102,-20,-42,-50,-75,100,-53,-67,-130,-131,-49,-86,-44,-12,100,-33,-30,-82,-83,100,-4,-70,100,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,100,100,100,-135,-149,-129,-128,-160,-110,]),'Repeated':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,101,-120,-118,-142,-141,-157,-140,101,101,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,101,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,101,-133,-175,101,-154,-152,-105,-65,-29,-92,101,101,-99,-31,-47,101,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,101,-66,-63,101,101,-51,101,-6,101,-91,-78,-172,-101,-72,101,101,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,101,-21,-27,-97,-96,101,-153,-156,-10,-24,-80,-9,-40,-54,101,-32,101,101,101,-19,-85,101,-3,-100,101,-145,-61,101,101,-134,-102,-20,-42,-50,101,101,-53,-67,-130,-131,-49,-86,-44,-12,101,-33,-30,-82,-83,101,-4,101,101,-109,-122,101,-138,-176,-151,-168,-154,-150,-108,101,101,101,-135,-149,-129,-128,101,-110,]),'op_RuleDelayed':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,67,-120,-118,-142,-141,-157,-140,67,67,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,67,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,67,-133,-175,-162,-154,-152,-105,-65,-29,-92,67,67,-99,-31,-47,67,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,67,-66,-63,67,67,-51,67,-6,67,-91,-78,-172,-101,-72,67,67,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,67,-21,-27,-97,-96,67,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,67,-81,67,-19,-85,67,-3,-100,67,-145,-61,-2,67,-134,-102,-20,-42,-50,67,67,-53,-67,-130,-131,-49,-86,-44,-12,67,-33,-30,-82,-83,67,-4,67,67,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,67,67,67,-135,-149,-129,-128,-160,-110,]),'Put':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,102,-120,-118,-142,-141,-157,-140,102,102,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,102,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,102,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,102,-51,-84,-6,102,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,102,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,102,-164,-166,-135,-149,-129,-128,-160,-110,]),'Intersection':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,103,-120,-118,-142,-141,103,-140,103,103,-79,103,103,103,-156,-127,103,-143,103,-23,103,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,103,103,-133,-175,103,-154,103,-105,-65,103,103,103,103,-99,103,103,103,103,-52,103,103,103,-139,-64,-26,103,103,-8,-13,103,103,103,103,-66,103,103,103,103,103,-6,103,103,-78,-172,103,103,103,103,-171,-46,-11,-136,103,-5,-147,-144,103,-146,103,-56,103,103,-21,103,103,-96,103,103,-156,-10,-24,-80,-9,103,-54,103,103,103,103,103,-19,103,103,103,-100,103,-145,103,103,103,-134,103,-20,103,103,103,103,-53,-67,-130,-131,103,103,103,-12,103,103,103,-82,103,103,103,103,103,-109,-122,103,-138,-176,103,-168,-154,103,-108,103,103,103,-135,103,-129,-128,103,-110,]),'$end':([0,2,5,9,10,11,16,17,21,24,26,30,31,33,34,35,36,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,344,345,346,347,348,349,351,356,],[-104,-123,-126,-125,-122,-124,-119,-156,-121,0,-103,-120,-118,-142,-141,-157,-140,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,-164,-166,-135,-149,-129,-128,-160,-110,]),'Apply2':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,105,-120,-118,105,105,105,105,105,105,105,105,105,105,-156,-127,105,105,105,105,105,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,105,-45,-18,-36,-89,-169,-107,-22,-132,105,105,-133,-175,105,-154,105,-105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,-64,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,-172,105,105,105,105,-171,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,-156,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,105,-134,105,105,105,105,105,105,105,105,-130,-131,105,105,105,105,105,105,105,105,105,105,105,105,105,-109,-122,105,105,-176,105,-168,-154,105,-108,105,105,105,-135,105,-129,-128,105,-110,]),'NotDoubleVerticalBar':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,106,-120,-118,-142,-141,106,-140,106,106,-79,106,106,-155,-156,-127,106,-143,106,-23,106,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,106,106,-133,-175,106,-154,-152,-105,-65,-29,-92,106,106,-99,-31,106,106,-48,-52,106,-43,106,-139,-64,-26,106,106,-8,-13,106,-90,106,106,-66,106,106,106,-51,106,-6,106,-91,-78,-172,106,106,106,106,-171,-46,-11,-136,-58,-5,-147,-144,106,-146,106,-56,-41,106,-21,106,-97,-96,106,-153,-156,-10,-24,-80,-9,-40,-54,106,-32,106,106,106,-19,106,106,106,-100,106,-145,-61,106,106,-134,106,-20,-42,-50,106,106,-53,-67,-130,-131,-49,106,106,-12,106,-33,106,-82,106,106,106,106,106,-109,-122,106,-138,-176,-151,-168,-154,-150,-108,106,106,106,-135,-149,-129,-128,106,-110,]),'Apply1':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,107,-120,-118,107,107,107,107,107,107,107,107,107,107,-156,-127,107,107,107,107,107,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,107,-45,-18,-36,-89,-169,-107,-22,-132,107,107,-133,-175,107,-154,107,-105,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,-64,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,-172,107,107,107,107,-171,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,-156,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,107,-134,107,107,107,107,107,107,107,107,-130,-131,107,107,107,107,107,107,107,107,107,107,107,107,107,-109,-122,107,107,-176,107,-168,-154,107,-108,107,107,107,-135,107,-129,-128,107,-110,]),'RawStar':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,108,-120,-118,-142,-141,108,-140,108,108,-79,108,108,108,-156,-127,108,-143,108,-23,108,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,108,108,-133,-175,108,-154,108,-105,108,108,108,108,108,108,108,108,108,108,-52,108,108,108,108,-64,-26,108,108,108,-13,108,108,108,108,108,108,108,108,108,108,-6,108,108,-78,-172,108,108,108,108,-171,108,108,-136,108,-5,-147,-144,108,-146,108,-56,108,108,108,108,108,-96,108,108,-156,-10,-24,108,-9,108,108,108,108,108,108,108,108,108,108,108,-100,108,-145,108,108,108,-134,108,-20,108,108,108,108,-53,-67,-130,-131,108,108,108,108,108,108,108,-82,108,108,108,108,108,-109,-122,108,-138,-176,108,-168,-154,108,-108,108,108,108,-135,108,-129,-128,108,-110,]),'RawSlash':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,109,-120,-118,-142,-141,109,-140,109,109,-79,109,109,109,-156,-127,109,-143,109,-23,109,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,109,-45,-18,-36,-89,-169,-107,-22,-132,109,109,-133,-175,109,-154,109,-105,109,109,109,109,109,109,109,109,109,109,-52,109,109,109,109,-64,-26,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,-78,-172,109,109,109,109,-171,109,109,-136,109,-5,109,-144,109,109,109,-56,109,109,109,109,109,109,109,109,-156,-10,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,109,-145,109,109,109,-134,109,-20,109,109,109,109,-53,-67,-130,-131,109,109,109,109,109,109,109,-82,109,109,109,109,109,-109,-122,109,-138,-176,109,-168,-154,109,-108,109,109,109,-135,109,-129,-128,109,-110,]),'SameQ':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,110,-120,-118,-142,-141,110,-140,110,110,-79,110,110,-155,-156,-127,110,-143,110,-23,110,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,110,110,-133,-175,110,-154,-152,-105,-65,-29,-92,110,110,-99,-31,110,110,-48,-52,110,-43,110,-139,-64,-26,-93,110,-8,-13,110,-90,110,110,-66,110,110,110,-51,110,-6,110,-91,-78,-172,110,110,110,110,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,110,-56,-41,110,-21,110,-97,-96,110,-153,-156,-10,-24,-80,-9,-40,-54,110,-32,110,110,110,-19,110,110,110,-100,110,-145,-61,110,110,-134,110,-20,-42,-50,110,110,-53,-67,-130,-131,-49,110,110,-12,110,-33,110,-82,110,110,110,110,110,-109,-122,110,-138,-176,-151,-168,-154,-150,-108,110,110,110,-135,-149,-129,-128,110,-110,]),'Times':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,112,-120,-118,-142,-141,112,-140,112,112,-79,112,112,112,-156,-127,112,-143,112,-23,112,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,112,112,-133,-175,112,-154,112,-105,112,112,112,112,112,112,112,112,112,112,-52,112,112,112,112,-64,-26,112,112,112,-13,112,112,112,112,112,112,112,112,112,112,-6,112,112,-78,-172,112,112,112,112,-171,112,112,-136,112,-5,-147,-144,112,-146,112,-56,112,112,112,112,112,-96,112,112,-156,-10,-24,112,-9,112,112,112,112,112,112,112,112,112,112,112,-100,112,-145,112,112,112,-134,112,-20,112,112,112,112,-53,-67,-130,-131,112,112,112,112,112,112,112,-82,112,112,112,112,112,-109,-122,112,-138,-176,112,-168,-154,112,-108,112,112,112,-135,112,-129,-128,112,-110,]),'RightBoxParenthesis':([2,5,8,9,10,11,16,17,21,30,31,33,34,35,36,38,39,43,44,46,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,188,195,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,317,318,319,320,321,322,324,325,326,329,331,332,335,343,344,345,346,347,348,349,351,352,353,354,355,356,],[-123,-126,-182,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,-181,-179,-177,197,-182,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,-180,-194,-175,-162,325,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-189,-191,-192,-187,-185,-183,-195,-176,-151,-168,-154,-150,-108,-193,-164,-166,-135,-149,-129,-128,-160,-188,-190,-186,-184,-110,]),'DoubleRightTee':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,113,-120,-118,-142,-141,-157,-140,113,113,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,113,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,113,-133,-175,113,-154,-152,-105,-65,-29,-92,113,113,-99,-31,113,113,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,113,-66,-63,113,113,-51,113,-6,113,-91,-78,-172,-101,113,113,113,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,113,-56,-41,113,-21,113,-97,-96,113,-153,-156,-10,-24,-80,-9,-40,-54,113,-32,113,113,113,-19,113,113,-3,-100,113,-145,-61,113,113,-134,-102,-20,-42,-50,113,113,-53,-67,-130,-131,-49,-86,-44,-12,113,-33,-30,-82,-83,113,-4,113,113,-109,-122,113,-138,-176,-151,-168,-154,-150,-108,113,113,113,-135,-149,-129,-128,113,-110,]),'RawColon':([10,21,30,31,314,],[45,-121,-120,185,338,]),'InterpretedBox':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[12,12,-123,12,12,-126,12,12,12,-125,-122,-124,12,12,12,-119,12,12,12,-121,12,12,12,12,12,12,12,-120,-118,12,12,12,12,12,12,12,-179,12,12,12,12,12,12,12,12,12,12,-127,12,12,12,12,12,12,12,12,-16,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,-68,12,12,12,12,12,12,12,12,12,-137,12,12,12,12,-69,12,12,12,12,12,12,12,12,-106,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,-17,12,-39,12,12,12,12,12,12,12,12,12,12,12,-18,12,12,12,12,12,12,12,12,12,-89,12,12,12,12,12,12,12,12,12,-169,12,12,12,12,12,-107,12,12,12,12,12,12,12,12,-180,12,12,12,12,12,-194,12,-175,12,12,12,-105,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,-172,12,12,12,12,-171,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,12,-130,-131,12,12,12,12,12,12,12,12,12,12,12,12,12,12,-109,12,-122,12,12,-189,-191,-192,-187,-185,-183,12,-195,-176,12,12,12,-168,12,12,12,-108,12,12,12,12,12,12,-193,12,12,12,12,-129,-128,12,-188,-190,-186,-184,-110,]),'NonCommutativeMultiply':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,114,-120,-118,114,114,114,114,114,114,-79,114,114,114,-156,-127,114,114,114,-23,114,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,114,-45,-18,-36,-89,-169,-107,-22,-132,114,114,-133,-175,114,-154,114,-105,114,114,114,114,114,114,114,114,114,114,-52,114,114,114,114,-64,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,-78,-172,114,114,114,114,-171,114,114,-136,114,-5,114,114,114,114,114,-56,114,114,114,114,114,114,114,114,-156,-10,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,114,-134,114,114,114,114,114,114,-53,-67,-130,-131,114,114,114,114,114,114,114,-82,114,114,114,114,114,-109,-122,114,-138,-176,114,-168,-154,114,-108,114,114,114,-135,114,-129,-128,114,-110,]),'Superscript':([2,5,9,10,11,16,17,21,30,31,33,34,35,36,39,43,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,188,195,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,317,318,319,320,321,322,324,325,326,329,331,332,335,343,344,345,346,347,348,349,351,352,353,354,355,356,],[-123,-126,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,193,-177,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,193,193,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-189,-191,193,-187,193,-183,193,-176,-151,-168,-154,-150,-108,193,-164,-166,-135,-149,-129,-128,-160,-188,-190,-186,193,-110,]),'GreaterEqual':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,115,-120,-118,-142,-141,115,-140,115,115,-79,115,115,-155,-156,-127,115,-143,115,-23,115,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,115,115,-133,-175,115,-154,-152,-105,-65,-29,-92,115,115,-99,-31,115,115,-48,-52,115,-43,115,-139,-64,-26,115,115,-8,-13,115,-90,115,115,-66,115,115,115,-51,115,-6,115,-91,-78,-172,115,115,115,115,-171,-46,-11,-136,-58,-5,-147,-144,115,-146,115,-56,-41,115,-21,115,-97,-96,115,-153,-156,-10,-24,-80,-9,-40,-54,115,-32,115,115,115,-19,115,115,115,-100,115,-145,-61,115,115,-134,115,-20,-42,-50,115,115,-53,-67,-130,-131,-49,115,115,-12,115,-33,115,-82,115,115,115,115,115,-109,-122,115,-138,-176,-151,-168,-154,-150,-108,115,115,115,-135,-149,-129,-128,115,-110,]),'Square':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[13,13,-123,13,13,-126,13,13,13,-125,-122,-124,13,13,13,-119,13,13,13,-121,13,13,13,13,13,13,13,-120,-118,13,13,13,13,13,13,13,-179,13,13,13,13,13,13,13,13,13,13,-127,13,13,13,-23,13,13,13,13,-16,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,-68,13,13,13,13,13,13,13,13,13,-137,13,13,13,13,-69,13,13,13,13,13,13,13,13,-106,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,-37,13,13,13,13,13,13,13,13,-17,13,-39,13,13,13,13,13,13,13,13,13,13,-45,-18,13,13,13,13,-36,13,13,13,13,-89,13,13,13,13,13,13,13,13,13,-169,13,13,13,13,13,-107,-22,-132,13,13,13,13,-133,13,-180,13,13,13,13,13,-194,13,-175,13,13,13,-105,13,13,13,13,13,13,13,13,13,13,-52,13,13,13,13,-64,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,-172,13,13,13,13,-171,13,13,-136,13,-5,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,13,-134,13,13,13,13,13,13,-53,-67,-130,-131,13,13,13,13,13,13,13,13,-82,13,13,13,13,13,-109,13,-122,13,-138,-189,-191,-192,-187,-185,-183,13,-195,-176,13,13,13,-168,13,13,13,-108,13,13,13,13,13,13,-193,13,13,-135,13,-129,-128,13,-188,-190,-186,-184,-110,]),'Exists':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[14,14,-123,14,14,-126,14,14,14,-125,-122,-124,14,14,14,-119,-156,14,14,-121,14,14,14,14,14,14,14,-120,-118,14,-142,-141,14,-140,14,14,-179,14,14,14,14,14,-79,14,14,-155,-156,-127,14,-143,14,-23,14,14,14,14,-16,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,14,-68,14,14,14,14,14,14,14,14,14,-137,14,14,14,14,-69,14,14,14,14,14,14,14,14,-106,14,14,14,14,14,14,14,14,14,14,-154,14,14,14,14,-37,14,14,14,14,14,14,14,14,-17,14,-39,14,14,14,14,14,14,-148,14,14,14,-45,-18,14,14,14,14,-36,14,14,14,14,-89,14,14,14,14,14,14,14,14,14,-169,14,14,14,14,14,-107,-22,-132,14,14,14,14,-133,14,-180,14,14,14,14,14,-194,14,-175,14,-154,-152,-105,-65,-29,-92,14,14,-99,-31,14,14,-48,-52,-59,-43,14,-139,-64,-26,-93,14,-8,-13,14,-90,14,14,-66,14,14,14,-51,14,-6,14,-91,-78,-172,14,14,14,14,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,14,-56,-41,14,-21,14,-97,-96,14,-153,-156,-10,-24,-80,-9,-40,-54,14,-32,14,14,14,-19,14,14,14,-100,14,-145,-61,14,14,-134,14,-20,-42,-50,14,14,-53,-67,-130,-131,-49,-86,14,-12,14,-33,-30,14,-82,-83,14,14,14,14,-109,14,-122,14,-138,-189,-191,-192,-187,-185,-183,14,-195,-176,-151,14,14,-168,14,-154,-150,-108,14,14,14,14,14,14,-193,14,14,-135,-149,-129,-128,14,-188,-190,-186,-184,-110,]),'Otherscript':([2,5,9,10,11,16,17,21,30,31,33,34,35,36,43,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,195,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,317,318,319,320,321,322,324,325,326,329,331,332,335,343,344,345,346,347,348,349,351,352,353,354,355,356,],[-123,-126,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,-177,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,323,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,339,340,-192,341,342,-183,-195,-176,-151,-168,-154,-150,-108,-193,-164,-166,-135,-149,-129,-128,-160,-188,-190,-186,-184,-110,]),'NotExists':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[15,15,-123,15,15,-126,15,15,15,-125,-122,-124,15,15,15,-119,-156,15,15,-121,15,15,15,15,15,15,15,-120,-118,15,-142,-141,15,-140,15,15,-179,15,15,15,15,15,-79,15,15,-155,-156,-127,15,-143,15,-23,15,15,15,15,-16,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,15,-68,15,15,15,15,15,15,15,15,15,-137,15,15,15,15,-69,15,15,15,15,15,15,15,15,-106,15,15,15,15,15,15,15,15,15,15,-154,15,15,15,15,-37,15,15,15,15,15,15,15,15,-17,15,-39,15,15,15,15,15,15,-148,15,15,15,-45,-18,15,15,15,15,-36,15,15,15,15,-89,15,15,15,15,15,15,15,15,15,-169,15,15,15,15,15,-107,-22,-132,15,15,15,15,-133,15,-180,15,15,15,15,15,-194,15,-175,15,-154,-152,-105,-65,-29,-92,15,15,-99,-31,15,15,-48,-52,-59,-43,15,-139,-64,-26,-93,15,-8,-13,15,-90,15,15,-66,15,15,15,-51,15,-6,15,-91,-78,-172,15,15,15,15,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,15,-56,-41,15,-21,15,-97,-96,15,-153,-156,-10,-24,-80,-9,-40,-54,15,-32,15,15,15,-19,15,15,15,-100,15,-145,-61,15,15,-134,15,-20,-42,-50,15,15,-53,-67,-130,-131,-49,-86,15,-12,15,-33,-30,15,-82,-83,15,15,15,15,-109,15,-122,15,-138,-189,-191,-192,-187,-185,-183,15,-195,-176,-151,15,15,-168,15,-154,-150,-108,15,15,15,15,15,15,-193,15,15,-135,-149,-129,-128,15,-188,-190,-186,-184,-110,]),'Infix':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,116,-120,-118,116,116,116,116,116,116,116,116,116,116,-156,-127,116,116,116,116,116,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,116,-45,-18,-36,-89,-169,-107,-22,-132,116,116,-133,-175,116,-154,116,-105,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,-64,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,-172,116,116,116,116,-171,116,116,116,116,116,116,116,116,116,116,116,116,330,116,116,116,116,116,116,-156,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,116,-134,116,116,116,116,116,116,116,116,-130,-131,116,116,116,116,116,116,116,116,116,116,116,116,116,-109,-122,116,116,-176,116,-168,-154,116,-108,116,116,116,-135,116,-129,-128,116,-110,]),'Cup':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,117,-120,-118,-142,-141,117,-140,117,117,-79,117,117,117,-156,-127,117,-143,117,-23,117,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,117,117,-133,-175,117,-154,117,-105,117,117,117,117,117,-99,117,117,117,117,-52,117,117,117,117,-64,-26,117,117,-8,-13,117,117,117,117,117,117,117,117,117,117,-6,117,117,-78,-172,117,117,117,117,-171,117,117,-136,117,-5,-147,-144,117,-146,117,-56,117,117,-21,117,117,-96,117,117,-156,-10,-24,-80,-9,117,117,117,117,117,117,117,-19,117,117,117,-100,117,-145,117,117,117,-134,117,-20,117,117,117,117,-53,-67,-130,-131,117,117,117,117,117,117,117,-82,117,117,117,117,117,-109,-122,117,-138,-176,117,-168,-154,117,-108,117,117,117,-135,117,-129,-128,117,-110,]),'Overscript':([2,5,9,10,11,16,17,21,30,31,33,34,35,36,39,43,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,188,195,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,317,318,319,320,321,322,324,325,326,329,331,332,335,343,344,345,346,347,348,349,351,352,353,354,355,356,],[-123,-126,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,189,-177,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,189,189,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,189,189,189,189,189,-183,189,-176,-151,-168,-154,-150,-108,189,-164,-166,-135,-149,-129,-128,-160,189,189,189,189,-110,]),'DoubleLeftTee':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,118,-120,-118,-142,-141,-157,-140,118,118,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,118,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,118,-133,-175,118,-154,-152,-105,-65,-29,-92,118,118,-99,-31,-47,118,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,118,-66,-63,118,118,-51,118,-6,118,-91,-78,-172,-101,-72,118,118,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,118,-21,-27,-97,-96,118,-153,-156,-10,-24,-80,-9,-40,-54,118,-32,118,118,118,-19,118,118,-3,-100,118,-145,-61,118,118,-134,-102,-20,-42,-50,118,118,-53,-67,-130,-131,-49,-86,-44,-12,118,-33,-30,-82,-83,118,-4,118,118,-109,-122,118,-138,-176,-151,-168,-154,-150,-108,118,118,118,-135,-149,-129,-128,118,-110,]),'number':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[16,16,-123,16,16,-126,16,16,16,-125,-122,-124,16,16,16,-119,16,16,16,-121,16,16,16,16,16,16,16,-120,-118,16,-142,-141,16,-140,16,16,-179,16,16,16,16,16,-79,16,16,16,16,-127,16,-143,16,-23,16,16,16,16,-16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,-68,16,16,16,16,16,16,16,16,16,-137,16,16,16,16,-69,16,16,16,16,16,16,16,16,-106,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,-37,16,16,16,16,16,16,16,16,-17,16,-39,16,16,16,16,16,16,-148,16,16,16,-45,-18,16,16,16,16,-36,16,16,16,16,-89,16,16,16,16,16,16,16,16,16,-169,16,16,16,16,16,-107,-22,-132,16,16,16,16,-133,16,-180,16,16,16,16,16,-194,16,-175,16,16,16,-105,16,16,16,16,16,16,16,16,16,16,-52,16,16,16,16,-64,-26,16,16,16,-13,16,16,16,16,16,16,16,16,16,16,-6,16,16,-78,-172,16,16,16,16,-171,16,16,-136,16,-5,-147,-144,16,-146,16,-56,16,16,16,16,16,-96,16,16,16,-10,-24,16,-9,16,16,16,16,16,16,16,16,16,16,16,-100,16,-145,16,16,16,-134,16,-20,16,16,16,16,-53,-67,-130,-131,16,16,16,16,16,16,16,16,-82,16,16,16,16,16,-109,16,-122,16,-138,-189,-191,-192,-187,-185,-183,16,-195,-176,16,16,16,-168,16,16,16,-108,16,16,16,16,16,16,-193,16,16,-135,16,-129,-128,16,-188,-190,-186,-184,-110,]),'Sqrt':([2,5,8,9,10,11,16,17,21,30,31,33,34,35,36,38,39,40,41,43,46,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,317,318,319,320,321,322,323,324,325,326,329,331,332,335,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[-123,-126,41,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,41,-179,41,41,-177,41,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,-180,41,41,41,41,41,-194,41,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-189,-191,-192,-187,-185,-183,41,-195,-176,-151,-168,-154,-150,-108,41,41,41,41,-193,-164,-166,-135,-149,-129,-128,-160,-188,-190,-186,-184,-110,]),'VerticalBar':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,119,-120,-118,-142,-141,119,-140,119,119,-79,119,119,-155,-156,-127,119,-143,119,-23,119,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,119,119,-133,-175,119,-154,-152,-105,-65,-29,-92,119,119,-99,-31,119,119,-48,-52,119,-43,119,-139,-64,-26,119,119,-8,-13,119,-90,119,119,-66,119,119,119,-51,119,-6,119,-91,-78,-172,119,119,119,119,-171,-46,-11,-136,-58,-5,-147,-144,119,-146,119,-56,-41,119,-21,119,-97,-96,119,-153,-156,-10,-24,-80,-9,-40,-54,119,-32,119,119,119,-19,119,119,119,-100,119,-145,-61,119,119,-134,119,-20,-42,-50,119,119,-53,-67,-130,-131,-49,119,119,-12,119,-33,119,-82,119,119,119,119,119,-109,-122,119,-138,-176,-151,-168,-154,-150,-108,119,119,119,-135,-149,-129,-128,119,-110,]),'Vee':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,120,-120,-118,-142,-141,120,-140,120,120,-79,120,120,120,-156,-127,120,-143,120,-23,120,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,120,-45,-18,-36,-89,-169,-107,-22,-132,120,120,-133,-175,120,-154,120,-105,120,120,120,120,120,120,120,120,120,120,-52,120,120,120,120,-64,-26,120,120,120,120,120,120,120,120,120,120,120,120,120,120,-6,120,120,-78,-172,120,120,120,120,-171,120,120,-136,120,-5,120,-144,120,120,120,-56,120,120,120,120,120,-96,120,120,-156,-10,-24,120,120,120,120,120,120,120,120,120,120,120,120,120,-100,120,-145,120,120,120,-134,120,-20,120,120,120,120,-53,-67,-130,-131,120,120,120,120,120,120,120,-82,120,120,120,120,120,-109,-122,120,-138,-176,120,-168,-154,120,-108,120,120,120,-135,120,-129,-128,120,-110,]),'Therefore':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,121,-120,-118,-142,-141,-157,-140,121,121,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,121,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,121,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,121,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,121,-66,-63,121,121,-51,-84,-6,121,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,121,-21,-27,-97,-96,121,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,121,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,121,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,121,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,121,121,121,-135,-149,-129,-128,-160,-110,]),'Xor':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,151,-120,-118,-142,-141,-157,-140,151,151,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,151,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,151,-133,-175,151,-154,-152,-105,-65,-29,-92,151,151,-99,-31,151,151,-48,-52,-59,-43,151,-139,-64,-26,-93,151,-8,-13,-55,-90,151,151,-66,151,151,151,-51,151,-6,151,-91,-78,-172,-101,151,151,151,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,151,-56,-41,151,-21,151,-97,-96,151,-153,-156,-10,-24,-80,-9,-40,-54,151,-32,151,151,151,-19,151,151,-3,-100,151,-145,-61,151,151,-134,-102,-20,-42,-50,151,151,-53,-67,-130,-131,-49,-86,151,-12,151,-33,-30,-82,-83,151,-4,151,151,-109,-122,151,-138,-176,-151,-168,-154,-150,-108,151,151,151,-135,-149,-129,-128,151,-110,]),'CircleDot':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,123,-120,-118,123,123,123,123,123,123,-79,123,123,123,-156,-127,123,123,123,-23,123,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,123,-45,-18,-36,-89,-169,-107,-22,-132,123,123,-133,-175,123,-154,123,-105,123,123,123,123,123,123,123,123,123,123,-52,123,123,123,123,-64,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,-78,-172,123,123,123,123,-171,123,123,-136,123,-5,123,123,123,123,123,123,123,123,123,123,123,123,123,123,-156,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,123,-134,123,123,123,123,123,123,-53,-67,-130,-131,123,123,123,123,123,123,123,-82,123,123,123,123,123,-109,-122,123,-138,-176,123,-168,-154,123,-108,123,123,123,-135,123,-129,-128,123,-110,]),'Diamond':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,124,-120,-118,-142,-141,124,-140,124,124,-79,124,124,124,-156,-127,124,-143,124,-23,124,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,124,-45,-18,-36,-89,-169,-107,-22,-132,124,124,-133,-175,124,-154,124,-105,124,124,124,124,124,124,124,124,124,124,-52,124,124,124,124,-64,-26,124,124,124,124,124,124,124,124,124,124,124,124,124,124,-6,124,124,-78,-172,124,124,124,124,-171,124,124,-136,124,-5,124,-144,124,124,124,-56,124,124,124,124,124,124,124,124,-156,-10,-24,124,124,124,124,124,124,124,124,124,124,124,124,124,124,124,-145,124,124,124,-134,124,-20,124,124,124,124,-53,-67,-130,-131,124,124,124,124,124,124,124,-82,124,124,124,124,124,-109,-122,124,-138,-176,124,-168,-154,124,-108,124,124,124,-135,124,-129,-128,124,-110,]),'Star':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,125,-120,-118,-142,-141,125,-140,125,125,-79,125,125,125,-156,-127,125,-143,125,-23,125,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,125,125,-133,-175,125,-154,125,-105,125,125,125,125,125,125,125,125,125,125,-52,125,125,125,125,-64,-26,125,125,125,-13,125,125,125,125,125,125,125,125,125,125,-6,125,125,-78,-172,125,125,125,125,-171,125,125,-136,125,-5,-147,-144,125,-146,125,-56,125,125,125,125,125,-96,125,125,-156,-10,-24,-80,-9,125,125,125,125,125,125,125,125,125,125,125,-100,125,-145,125,125,125,-134,125,-20,125,125,125,125,-53,-67,-130,-131,125,125,125,125,125,125,125,-82,125,125,125,125,125,-109,-122,125,-138,-176,125,-168,-154,125,-108,125,125,125,-135,125,-129,-128,125,-110,]),'CenterDot':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,126,-120,-118,-142,-141,126,-140,126,126,-79,126,126,126,-156,-127,126,-143,126,-23,126,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,126,-45,-18,-36,-89,-169,-107,-22,-132,126,126,-133,-175,126,-154,126,-105,126,126,126,126,126,126,126,126,126,126,-52,126,126,126,126,-64,-26,126,126,126,-13,126,126,126,126,126,126,126,126,126,126,-6,126,126,-78,-172,126,126,126,126,-171,126,126,-136,126,-5,126,-144,126,126,126,-56,126,126,126,126,126,-96,126,126,-156,-10,-24,126,-9,126,126,126,126,126,126,126,126,126,126,126,-100,126,-145,126,126,126,-134,126,-20,126,126,126,126,-53,-67,-130,-131,126,126,126,126,126,126,126,-82,126,126,126,126,126,-109,-122,126,-138,-176,126,-168,-154,126,-108,126,126,126,-135,126,-129,-128,126,-110,]),'Get':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[18,18,-123,18,18,-126,18,18,18,-125,-122,-124,18,18,18,-119,18,18,18,-121,18,18,18,18,18,18,18,-120,-118,18,18,18,18,18,18,18,-179,18,18,18,18,18,18,18,18,18,18,-127,18,18,18,18,18,18,18,18,-16,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,-68,18,18,18,18,18,18,18,18,18,-137,18,18,18,18,-69,18,18,18,18,18,18,18,18,-106,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,-17,18,-39,18,18,18,18,18,18,18,18,18,18,18,-18,18,18,18,18,18,18,18,18,18,-89,18,18,18,18,18,18,18,18,18,-169,18,18,18,18,18,-107,18,18,18,18,18,18,18,18,-180,18,18,18,18,18,-194,18,-175,18,18,18,-105,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,-172,18,18,18,18,-171,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,18,-130,-131,18,18,18,18,18,18,18,18,18,18,18,18,18,18,-109,18,-122,18,18,-189,-191,-192,-187,-185,-183,18,-195,-176,18,18,18,-168,18,18,18,-108,18,18,18,18,18,18,-193,18,18,18,18,-129,-128,18,-188,-190,-186,-184,-110,]),'Factorial':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[19,19,-123,19,19,-126,19,19,19,-125,-122,-124,19,19,19,-119,19,19,19,-121,19,19,19,127,19,19,19,-120,-118,19,127,127,127,127,127,19,-179,19,19,127,19,19,127,127,127,127,19,-127,127,127,127,127,127,19,19,19,-16,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,-68,19,19,19,19,19,19,19,19,19,-137,19,19,19,19,-69,19,19,19,19,19,19,19,19,-106,19,19,19,19,19,19,19,19,19,19,19,19,19,19,19,-37,19,19,19,19,19,19,19,19,-17,19,-39,19,19,19,19,19,19,127,19,19,19,-45,-18,19,19,19,19,-36,19,19,19,19,-89,19,19,19,19,19,19,19,19,19,-169,19,19,19,19,19,-107,-22,-132,127,127,19,19,-133,19,-180,19,19,19,19,19,-194,19,-175,127,19,127,-105,127,127,127,127,127,127,127,127,127,127,-52,127,127,127,127,-64,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,-172,127,127,127,127,-171,127,127,-136,127,-5,127,127,127,127,127,127,127,127,127,127,127,127,127,127,19,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,127,-134,127,127,127,127,127,127,-53,127,-130,-131,127,127,127,127,127,127,127,19,127,127,127,127,127,127,-109,19,-122,127,127,-189,-191,-192,-187,-185,-183,19,-195,-176,127,19,19,-168,19,19,127,-108,127,19,19,19,19,19,-193,127,127,-135,127,-129,-128,127,-188,-190,-186,-184,-110,]),'op_GreaterEqual':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,128,-120,-118,-142,-141,128,-140,128,128,-79,128,128,-155,-156,-127,128,-143,128,-23,128,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,128,128,-133,-175,128,-154,-152,-105,-65,-29,-92,128,128,-99,-31,128,128,-48,-52,128,-43,128,-139,-64,-26,128,128,-8,-13,128,-90,128,128,-66,128,128,128,-51,128,-6,128,-91,-78,-172,128,128,128,128,-171,-46,-11,-136,-58,-5,-147,-144,128,-146,128,-56,-41,128,-21,128,-97,-96,128,-153,-156,-10,-24,-80,-9,-40,-54,128,-32,128,128,128,-19,128,128,128,-100,128,-145,-61,128,128,-134,128,-20,-42,-50,128,128,-53,-67,-130,-131,-49,128,128,-12,128,-33,128,-82,128,128,128,128,128,-109,-122,128,-138,-176,-151,-168,-154,-150,-108,128,128,128,-135,-149,-129,-128,128,-110,]),'MinusPlus':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[20,20,-123,20,20,-126,20,20,20,-125,-122,-124,20,20,20,-119,20,20,20,-121,20,20,20,129,20,20,20,-120,-118,20,-142,-141,129,-140,129,20,-179,20,20,129,20,20,-79,129,129,129,20,-127,129,-143,129,-23,129,20,20,20,-16,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,-68,20,20,20,20,20,20,20,20,20,-137,20,20,20,20,-69,20,20,20,20,20,20,20,20,-106,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,-37,20,20,20,20,20,20,20,20,-17,20,-39,20,20,20,20,20,20,-148,20,20,20,-45,-18,20,20,20,20,-36,20,20,20,20,-89,20,20,20,20,20,20,20,20,20,-169,20,20,20,20,20,-107,-22,-132,129,129,20,20,-133,20,-180,20,20,20,20,20,-194,20,-175,129,20,129,-105,-65,129,129,129,129,-99,129,129,129,129,-52,129,129,129,-139,-64,-26,129,129,-8,-13,129,129,129,129,-66,129,129,129,129,129,-6,129,129,-78,-172,129,129,129,129,-171,129,-11,-136,129,-5,-147,-144,129,-146,129,-56,129,129,-21,129,129,-96,129,129,20,-10,-24,-80,-9,129,-54,129,129,129,129,129,-19,129,129,129,-100,129,-145,129,129,129,-134,129,-20,129,129,129,129,-53,-67,-130,-131,129,129,129,-12,129,129,129,20,-82,129,129,129,129,129,-109,20,-122,129,-138,-189,-191,-192,-187,-185,-183,20,-195,-176,129,20,20,-168,20,20,129,-108,129,20,20,20,20,20,-193,129,129,-135,129,-129,-128,129,-188,-190,-186,-184,-110,]),'blankdefault':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[21,21,-123,21,21,-126,21,21,21,-125,-122,-124,21,21,21,-119,21,21,21,-121,21,21,21,21,21,21,21,-120,-118,21,-142,-141,21,-140,21,21,-179,21,21,21,21,21,-79,21,21,21,21,-127,21,-143,21,-23,21,21,21,21,-16,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,-68,21,21,21,21,21,21,21,21,21,-137,21,21,21,21,-69,21,21,21,21,21,21,21,21,-106,21,21,21,21,21,21,21,21,21,21,21,21,21,21,21,-37,21,21,21,21,21,21,21,21,-17,21,-39,21,21,21,21,21,21,-148,21,21,21,-45,-18,21,21,21,21,-36,21,21,21,21,-89,21,21,21,21,21,21,21,21,21,-169,21,21,21,21,21,-107,-22,-132,21,21,21,21,-133,21,-180,21,21,21,21,21,-194,21,-175,21,21,21,-105,21,21,21,21,21,21,21,21,21,21,-52,21,21,21,21,-64,-26,21,21,21,-13,21,21,21,21,21,21,21,21,21,21,-6,21,21,-78,-172,21,21,21,21,-171,21,21,-136,21,-5,-147,-144,21,-146,21,-56,21,21,21,21,21,-96,21,21,21,-10,-24,21,-9,21,21,21,21,21,21,21,21,21,21,21,-100,21,-145,21,21,21,-134,21,-20,21,21,21,21,-53,-67,-130,-131,21,21,21,21,21,21,21,21,-82,21,21,21,21,21,-109,21,-122,21,-138,-189,-191,-192,-187,-185,-183,21,-195,-176,21,21,21,-168,21,21,21,-108,21,21,21,21,21,21,-193,21,21,-135,21,-129,-128,21,-188,-190,-186,-184,-110,]),'ForAll':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[22,22,-123,22,22,-126,22,22,22,-125,-122,-124,22,22,22,-119,-156,22,22,-121,22,22,22,22,22,22,22,-120,-118,22,-142,-141,22,-140,22,22,-179,22,22,22,22,22,-79,22,22,-155,-156,-127,22,-143,22,-23,22,22,22,22,-16,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,22,-68,22,22,22,22,22,22,22,22,22,-137,22,22,22,22,-69,22,22,22,22,22,22,22,22,-106,22,22,22,22,22,22,22,22,22,22,-154,22,22,22,22,-37,22,22,22,22,22,22,22,22,-17,22,-39,22,22,22,22,22,22,-148,22,22,22,-45,-18,22,22,22,22,-36,22,22,22,22,-89,22,22,22,22,22,22,22,22,22,-169,22,22,22,22,22,-107,-22,-132,22,22,22,22,-133,22,-180,22,22,22,22,22,-194,22,-175,22,-154,-152,-105,-65,-29,-92,22,22,-99,-31,22,22,-48,-52,-59,-43,22,-139,-64,-26,-93,22,-8,-13,22,-90,22,22,-66,22,22,22,-51,22,-6,22,-91,-78,-172,22,22,22,22,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,22,-56,-41,22,-21,22,-97,-96,22,-153,-156,-10,-24,-80,-9,-40,-54,22,-32,22,22,22,-19,22,22,22,-100,22,-145,-61,22,22,-134,22,-20,-42,-50,22,22,-53,-67,-130,-131,-49,-86,22,-12,22,-33,-30,22,-82,-83,22,22,22,22,-109,22,-122,22,-138,-189,-191,-192,-187,-185,-183,22,-195,-176,-151,22,22,-168,22,-154,-150,-108,22,22,22,22,22,22,-193,22,22,-135,-149,-129,-128,22,-188,-190,-186,-184,-110,]),'Condition':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,130,-120,-118,-142,-141,-157,-140,130,130,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,130,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,130,-133,-175,-162,-154,-152,-105,-65,-29,-92,130,130,-99,-31,-47,130,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,130,-66,-63,130,130,-51,130,-6,130,-91,-78,-172,-101,-72,130,130,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,130,-21,-27,-97,-96,130,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,130,-81,130,-19,-85,130,-3,-100,130,-145,-61,-2,130,-134,-102,-20,-42,-50,130,130,-53,-67,-130,-131,-49,-86,-44,-12,130,-33,-30,-82,-83,130,-4,130,130,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,130,130,130,-135,-149,-129,-128,-160,-110,]),'LongEqual':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,131,-120,-118,-142,-141,131,-140,131,131,-79,131,131,-155,-156,-127,131,-143,131,-23,131,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,131,131,-133,-175,131,-154,-152,-105,-65,-29,-92,131,131,-99,-31,131,131,-48,-52,131,-43,131,-139,-64,-26,131,131,-8,-13,131,-90,131,131,-66,131,131,131,-51,131,-6,131,-91,-78,-172,131,131,131,131,-171,-46,-11,-136,-58,-5,-147,-144,131,-146,131,-56,-41,131,-21,131,-97,-96,131,-153,-156,-10,-24,-80,-9,-40,-54,131,-32,131,131,131,-19,131,131,131,-100,131,-145,-61,131,131,-134,131,-20,-42,-50,131,131,-53,-67,-130,-131,-49,131,131,-12,131,-33,131,-82,131,131,131,131,131,-109,-122,131,-138,-176,-151,-168,-154,-150,-108,131,131,131,-135,-149,-129,-128,131,-110,]),'SetDelayed':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,132,-120,-118,-142,-141,-157,-140,132,132,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,132,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,132,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,132,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,132,-66,-63,-7,132,-51,-84,-6,328,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,132,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,132,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,132,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,132,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,132,132,132,-135,-149,-129,-128,-160,-110,]),'StringExpression':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,133,-120,-118,-142,-141,-157,-140,133,133,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,133,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,133,-133,-175,-162,-154,-152,-105,-65,-29,-92,133,133,-99,-31,-47,133,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,133,-66,-63,133,133,-51,133,-6,133,-91,-78,-172,-101,-72,133,133,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,133,-21,-27,-97,-96,133,-153,-156,-10,-24,-80,-9,-40,-54,133,-32,133,-81,133,-19,-85,133,-3,-100,133,-145,-61,-2,133,-134,-102,-20,-42,-50,133,133,-53,-67,-130,-131,-49,-86,-44,-12,133,-33,-30,-82,-83,133,-4,133,133,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,133,133,133,-135,-149,-129,-128,-160,-110,]),'Underscript':([2,5,9,10,11,16,17,21,30,31,33,34,35,36,39,43,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,188,195,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,317,318,319,320,321,322,324,325,326,329,331,332,335,343,344,345,346,347,348,349,351,352,353,354,355,356,],[-123,-126,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,190,-177,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,190,190,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,190,190,190,190,190,-183,190,-176,-151,-168,-154,-150,-108,190,-164,-166,-135,-149,-129,-128,-160,190,190,190,190,-110,]),'Rule':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,134,-120,-118,-142,-141,-157,-140,134,134,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,134,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,134,-133,-175,-162,-154,-152,-105,-65,-29,-92,134,134,-99,-31,-47,134,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,134,-66,-63,134,134,-51,134,-6,134,-91,-78,-172,-101,-72,134,134,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,134,-21,-27,-97,-96,134,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,134,-81,134,-19,-85,134,-3,-100,134,-145,-61,-2,134,-134,-102,-20,-42,-50,134,134,-53,-67,-130,-131,-49,-86,-44,-12,134,-33,-30,-82,-83,134,-4,134,134,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,134,134,134,-135,-149,-129,-128,-160,-110,]),'Coproduct':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,135,-120,-118,-142,-141,135,-140,135,135,-79,135,135,135,-156,-127,135,-143,135,-23,135,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,135,135,-133,-175,135,-154,135,-105,135,135,135,135,135,-99,135,135,135,135,-52,135,135,135,135,-64,-26,135,135,135,-13,135,135,135,135,135,135,135,135,135,135,-6,135,135,-78,-172,135,135,135,135,-171,135,135,-136,135,-5,-147,-144,135,-146,135,-56,135,135,135,135,135,-96,135,135,-156,-10,-24,-80,-9,135,135,135,135,135,135,135,-19,135,135,135,-100,135,-145,135,135,135,-134,135,-20,135,135,135,135,-53,-67,-130,-131,135,135,135,135,135,135,135,-82,135,135,135,135,135,-109,-122,135,-138,-176,135,-168,-154,135,-108,135,135,135,-135,135,-129,-128,135,-110,]),'LeftBoxParenthesisInternal':([2,5,8,9,10,11,16,17,21,30,31,33,34,35,36,38,39,40,41,43,46,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,317,318,319,320,321,322,323,324,325,326,329,331,332,335,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[-123,-126,40,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,40,-179,40,40,-177,40,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,-180,40,40,40,40,40,-194,40,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-189,-191,-192,-187,-185,-183,40,-195,-176,-151,-168,-154,-150,-108,40,40,40,40,-193,-164,-166,-135,-149,-129,-128,-160,-188,-190,-186,-184,-110,]),'Del':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[23,23,-123,23,23,-126,23,23,23,-125,-122,-124,23,23,23,-119,23,23,23,-121,23,23,23,23,23,23,23,-120,-118,23,23,23,23,23,23,23,-179,23,23,23,23,23,23,23,23,23,23,-127,23,23,23,23,23,23,23,23,-16,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,-68,23,23,23,23,23,23,23,23,23,-137,23,23,23,23,-69,23,23,23,23,23,23,23,23,-106,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,-37,23,23,23,23,23,23,23,23,-17,23,-39,23,23,23,23,23,23,23,23,23,23,-45,-18,23,23,23,23,-36,23,23,23,23,-89,23,23,23,23,23,23,23,23,23,-169,23,23,23,23,23,-107,-22,-132,23,23,23,23,-133,23,-180,23,23,23,23,23,-194,23,-175,23,23,23,-105,23,23,23,23,23,23,23,23,23,23,-52,23,23,23,23,-64,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,-172,23,23,23,23,-171,23,23,-136,23,-5,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,-134,23,23,23,23,23,23,-53,-67,-130,-131,23,23,23,23,23,23,23,23,-82,23,23,23,23,23,-109,23,-122,23,-138,-189,-191,-192,-187,-185,-183,23,-195,-176,23,23,23,-168,23,23,23,-108,23,23,23,23,23,23,-193,23,23,-135,23,-129,-128,23,-188,-190,-186,-184,-110,]),'HermitianConjugate':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,136,-120,-118,-142,-141,-157,-140,136,136,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,136,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,136,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,136,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,136,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,136,-164,-166,-135,-149,-129,-128,-160,-110,]),'SuchThat':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,137,-120,-118,-142,-141,-157,-140,137,137,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,137,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,137,-133,-175,137,-154,-152,-105,-65,-29,-92,137,137,-99,-31,-47,137,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,137,-66,-63,137,137,-51,137,-6,137,-91,-78,-172,-101,-72,137,137,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,137,-21,-27,-97,-96,137,-153,-156,-10,-24,-80,-9,-40,-54,137,-32,137,137,137,-19,137,137,-3,-100,137,-145,-61,137,137,-134,-102,-20,-42,-50,137,137,-53,-67,-130,-131,-49,-86,-44,-12,137,-33,-30,-82,-83,137,-4,137,137,-109,-122,137,-138,-176,-151,-168,-154,-150,-108,137,137,137,-135,-149,-129,-128,137,-110,]),'NotElement':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,70,-120,-118,-142,-141,70,-140,70,70,-79,70,70,-155,-156,-127,70,-143,70,-23,70,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,70,70,-133,-175,70,-154,-152,-105,-65,-29,-92,70,70,-99,-31,70,70,-48,-52,-59,-43,70,-139,-64,-26,-93,70,-8,-13,70,-90,70,70,-66,70,70,70,-51,70,-6,70,-91,-78,-172,70,70,70,70,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,70,-56,-41,70,-21,70,-97,-96,70,-153,-156,-10,-24,-80,-9,-40,-54,70,-32,70,70,70,-19,70,70,70,-100,70,-145,-61,70,70,-134,70,-20,-42,-50,70,70,-53,-67,-130,-131,-49,-86,70,-12,70,-33,-30,-82,-83,70,70,70,70,-109,-122,70,-138,-176,-151,-168,-154,-150,-108,70,70,70,-135,-149,-129,-128,70,-110,]),'AddTo':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,139,-120,-118,-142,-141,-157,-140,139,139,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,139,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,139,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,139,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,139,-66,-63,139,139,-51,139,-6,139,-91,-78,-172,-101,-72,139,139,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,139,-21,-27,-97,-96,139,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,139,-81,-76,-19,-85,139,-3,-100,-74,-145,-61,-2,139,-134,-102,-20,-42,-50,-75,139,-53,-67,-130,-131,-49,-86,-44,-12,139,-33,-30,-82,-83,139,-4,-70,139,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,139,139,139,-135,-149,-129,-128,-160,-110,]),'And':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,140,-120,-118,-142,-141,-157,-140,140,140,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,140,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,140,-133,-175,140,-154,-152,-105,-65,-29,-92,140,140,-99,-31,140,140,-48,-52,-59,-43,140,-139,-64,-26,-93,140,-8,-13,-55,-90,140,140,-66,140,140,140,-51,140,-6,140,-91,-78,-172,140,140,140,140,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,140,-56,-41,140,-21,140,-97,-96,140,-153,-156,-10,-24,-80,-9,-40,-54,140,-32,140,140,140,-19,140,140,-3,-100,140,-145,-61,140,140,-134,140,-20,-42,-50,140,140,-53,-67,-130,-131,-49,-86,140,-12,140,-33,-30,-82,-83,140,-4,140,140,-109,-122,140,-138,-176,-151,-168,-154,-150,-108,140,140,140,-135,-149,-129,-128,140,-110,]),'Wedge':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,141,-120,-118,-142,-141,141,-140,141,141,-79,141,141,141,-156,-127,141,-143,141,-23,141,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,141,-45,-18,-36,-89,-169,-107,-22,-132,141,141,-133,-175,141,-154,141,-105,141,141,141,141,141,141,141,141,141,141,-52,141,141,141,141,-64,-26,141,141,141,141,141,141,141,141,141,141,141,141,141,141,-6,141,141,-78,-172,141,141,141,141,-171,141,141,-136,141,-5,141,-144,141,141,141,-56,141,141,141,141,141,141,141,141,-156,-10,-24,141,141,141,141,141,141,141,141,141,141,141,141,141,-100,141,-145,141,141,141,-134,141,-20,141,141,141,141,-53,-67,-130,-131,141,141,141,141,141,141,141,-82,141,141,141,141,141,-109,-122,141,-138,-176,141,-168,-154,141,-108,141,141,141,-135,141,-129,-128,141,-110,]),'Set':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,83,-120,-118,-142,-141,-157,-140,83,83,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,83,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,83,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,83,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,83,-66,-63,-7,83,-51,-84,-6,327,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,83,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,83,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,83,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,83,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,83,83,83,-135,-149,-129,-128,-160,-110,]),'RawLeftParenthesis':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[25,25,-123,25,25,-126,25,25,25,-125,-122,-124,25,25,25,-119,25,25,25,-121,25,25,25,25,25,25,25,-120,-118,25,-142,-141,25,-140,25,25,-179,25,25,25,25,25,-79,25,25,25,25,-127,25,-143,25,-23,25,25,25,25,-16,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,-68,25,25,25,25,25,25,25,25,25,-137,25,25,25,25,-69,25,25,25,25,25,25,25,25,-106,25,25,25,25,25,25,25,25,25,25,25,25,25,25,25,-37,25,25,25,25,25,25,25,25,-17,25,-39,25,25,25,25,25,25,-148,25,25,25,-45,-18,25,25,25,25,-36,25,25,25,25,-89,25,25,25,25,25,25,25,25,25,-169,25,25,25,25,25,-107,-22,-132,25,25,25,25,-133,25,-180,25,25,25,25,25,-194,25,-175,25,25,25,-105,25,25,25,25,25,25,25,25,25,25,-52,25,25,25,25,-64,-26,25,25,25,-13,25,25,25,25,25,25,25,25,25,25,-6,25,25,-78,-172,25,25,25,25,-171,25,25,-136,25,-5,-147,-144,25,-146,25,-56,25,25,25,25,25,-96,25,25,25,-10,-24,25,-9,25,25,25,25,25,25,25,25,25,25,25,-100,25,-145,25,25,25,-134,25,-20,25,25,25,25,-53,-67,-130,-131,25,25,25,25,25,25,25,25,-82,25,25,25,25,25,-109,25,-122,25,-138,-189,-191,-192,-187,-185,-183,25,-195,-176,25,25,25,-168,25,25,25,-108,25,25,25,25,25,25,-193,25,25,-135,25,-129,-128,25,-188,-190,-186,-184,-110,]),'NotVerticalBar':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,144,-120,-118,-142,-141,144,-140,144,144,-79,144,144,-155,-156,-127,144,-143,144,-23,144,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,144,144,-133,-175,144,-154,-152,-105,-65,-29,-92,144,144,-99,-31,144,144,-48,-52,144,-43,144,-139,-64,-26,144,144,-8,-13,144,-90,144,144,-66,144,144,144,-51,144,-6,144,-91,-78,-172,144,144,144,144,-171,-46,-11,-136,-58,-5,-147,-144,144,-146,144,-56,-41,144,-21,144,-97,-96,144,-153,-156,-10,-24,-80,-9,-40,-54,144,-32,144,144,144,-19,144,144,144,-100,144,-145,-61,144,144,-134,144,-20,-42,-50,144,144,-53,-67,-130,-131,-49,144,144,-12,144,-33,144,-82,144,144,144,144,144,-109,-122,144,-138,-176,-151,-168,-154,-150,-108,144,144,144,-135,-149,-129,-128,144,-110,]),'Alternatives':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,146,-120,-118,-142,-141,-157,-140,146,146,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,146,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,146,-133,-175,146,-154,-152,-105,-65,-29,-92,146,146,-99,-31,-47,146,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,146,-66,-63,146,146,-51,146,-6,146,-91,-78,-172,-101,-72,146,146,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,146,-21,-27,-97,-96,146,-153,-156,-10,-24,-80,-9,-40,-54,146,-32,146,146,146,-19,-85,146,-3,-100,146,-145,-61,-2,146,-134,-102,-20,-42,-50,146,146,-53,-67,-130,-131,-49,-86,-44,-12,146,-33,-30,-82,-83,146,-4,146,146,-109,-122,146,-138,-176,-151,-168,-154,-150,-108,146,146,146,-135,-149,-129,-128,146,-110,]),'VerticalSeparator':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,147,-120,-118,-142,-141,-157,-140,147,147,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,147,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,147,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,147,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,147,-66,-63,147,147,-51,-84,-6,147,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,147,-21,-27,-97,-96,147,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,147,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,147,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,147,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,147,147,147,-135,-149,-129,-128,-160,-110,]),'Prefix':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,148,-120,-118,148,148,148,148,148,148,148,148,148,148,-156,-127,148,148,148,148,148,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,148,-45,-18,-36,-89,-169,-107,-22,-132,148,148,-133,-175,148,-154,148,-105,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,-64,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,-172,148,148,148,148,-171,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,-156,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,148,-130,-131,148,148,148,148,148,148,148,148,148,148,148,148,148,-109,-122,148,148,-176,148,-168,-154,148,-108,148,148,148,148,148,-129,-128,148,-110,]),'Increment':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[27,27,-123,27,27,-126,27,27,27,-125,-122,-124,27,27,27,-119,27,27,27,-121,27,27,27,149,27,27,27,-120,-118,27,149,149,149,149,149,27,-179,27,27,149,27,27,149,149,149,149,27,-127,149,149,149,149,149,27,27,27,-16,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,-68,27,27,27,27,27,27,27,27,27,-137,27,27,27,27,-69,27,27,27,27,27,27,27,27,-106,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,27,-17,27,-39,27,27,27,27,27,27,149,27,27,27,-45,-18,27,27,27,27,27,27,27,27,27,-89,27,27,27,27,27,27,27,27,27,-169,27,27,27,27,27,-107,-22,149,149,149,27,27,149,27,-180,27,27,27,27,27,-194,27,-175,149,27,149,-105,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,-64,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,-172,149,149,149,149,-171,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,27,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,149,-130,-131,149,149,149,149,149,149,149,27,149,149,149,149,149,149,-109,27,-122,149,149,-189,-191,-192,-187,-185,-183,27,-195,-176,149,27,27,-168,27,27,149,-108,149,27,27,27,27,27,-193,149,149,149,149,-129,-128,149,-188,-190,-186,-184,-110,]),'Conjugate':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,150,-120,-118,150,150,150,150,150,150,150,150,150,150,-156,-127,150,150,150,150,150,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,150,-45,-18,-36,-89,-169,-107,-22,-132,150,150,-133,-175,150,-154,150,-105,150,150,150,150,150,150,150,150,150,150,-52,150,150,150,150,-64,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,-172,150,150,150,150,-171,150,150,-136,150,-5,150,150,150,150,150,150,150,150,150,150,150,150,150,150,-156,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,150,-134,150,150,150,150,150,150,-53,150,-130,-131,150,150,150,150,150,150,150,150,150,150,150,150,150,-109,-122,150,150,-176,150,-168,-154,150,-108,150,150,150,-135,150,-129,-128,150,-110,]),'RawRightBrace':([2,5,9,10,11,16,17,21,29,30,31,33,34,35,36,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,181,182,183,184,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,312,313,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,-111,-120,-118,-142,-141,-157,-140,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,311,-112,-116,-117,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-114,-115,-122,-161,-138,-176,-151,-168,-154,-150,-108,-113,-164,-166,-135,-149,-129,-128,-160,-110,]),'Span':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[17,17,-123,17,17,-126,17,17,17,-125,-122,-124,17,17,17,-119,51,17,17,-121,17,17,17,122,17,17,17,-120,-118,17,-142,-141,122,-140,122,17,-179,17,17,122,17,17,-79,122,122,200,51,-127,122,-143,122,-23,122,17,17,17,-16,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,-68,17,17,17,17,17,17,17,17,17,-137,17,17,17,17,-69,17,17,17,17,17,17,17,17,-106,17,17,17,17,17,17,17,17,17,17,263,17,17,17,17,-37,17,17,17,17,17,17,17,17,-17,17,-39,17,17,17,17,17,17,-148,17,17,17,-45,-18,17,17,17,17,-36,17,17,17,17,-89,17,17,17,17,17,17,17,17,17,-169,17,17,17,17,17,-107,-22,-132,122,122,17,17,-133,17,-180,17,17,17,17,17,-194,17,-175,122,263,200,-105,-65,122,-92,122,122,-99,122,122,122,122,-52,122,122,122,-139,-64,-26,122,122,-8,-13,122,122,122,122,-66,122,122,122,122,122,-6,122,122,-78,-172,122,122,122,122,-171,-46,-11,-136,122,-5,-147,-144,122,-146,122,-56,122,122,-21,122,122,-96,122,331,51,-10,-24,-80,-9,122,-54,122,122,122,122,122,-19,122,122,122,-100,122,-145,122,122,122,-134,122,-20,122,122,122,122,-53,-67,-130,-131,122,122,122,-12,122,122,122,17,-82,122,122,122,122,122,-109,17,-122,122,-138,-189,-191,-192,-187,-185,-183,17,-195,-176,331,17,17,-168,17,263,200,-108,122,17,17,17,17,17,-193,122,122,-135,331,-129,-128,122,-188,-190,-186,-184,-110,]),'Cross':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,152,-120,-118,152,152,152,152,152,152,-79,152,152,152,-156,-127,152,152,152,-23,152,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,152,-45,-18,-36,-89,-169,-107,-22,-132,152,152,-133,-175,152,-154,152,-105,152,152,152,152,152,152,152,152,152,152,-52,152,152,152,152,-64,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,-78,-172,152,152,152,152,-171,152,152,-136,152,-5,152,152,152,152,152,-56,152,152,152,152,152,152,152,152,-156,-10,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,152,-134,152,-20,152,152,152,152,-53,-67,-130,-131,152,152,152,152,152,152,152,-82,152,152,152,152,152,-109,-122,152,-138,-176,152,-168,-154,152,-108,152,152,152,-135,152,-129,-128,152,-110,]),'GreaterSlantEqual':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,153,-120,-118,-142,-141,153,-140,153,153,-79,153,153,-155,-156,-127,153,-143,153,-23,153,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,153,153,-133,-175,153,-154,-152,-105,-65,-29,-92,153,153,-99,-31,153,153,-48,-52,153,-43,153,-139,-64,-26,153,153,-8,-13,153,-90,153,153,-66,153,153,153,-51,153,-6,153,-91,-78,-172,153,153,153,153,-171,-46,-11,-136,-58,-5,-147,-144,153,-146,153,-56,-41,153,-21,153,-97,-96,153,-153,-156,-10,-24,-80,-9,-40,-54,153,-32,153,153,153,-19,153,153,153,-100,153,-145,-61,153,153,-134,153,-20,-42,-50,153,153,-53,-67,-130,-131,-49,153,153,-12,153,-33,153,-82,153,153,153,153,153,-109,-122,153,-138,-176,-151,-168,-154,-150,-108,153,153,153,-135,-149,-129,-128,153,-110,]),'LessSlantEqual':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,154,-120,-118,-142,-141,154,-140,154,154,-79,154,154,-155,-156,-127,154,-143,154,-23,154,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,154,154,-133,-175,154,-154,-152,-105,-65,-29,-92,154,154,-99,-31,154,154,-48,-52,154,-43,154,-139,-64,-26,154,154,-8,-13,154,-90,154,154,-66,154,154,154,-51,154,-6,154,-91,-78,-172,154,154,154,154,-171,-46,-11,-136,-58,-5,-147,-144,154,-146,154,-56,-41,154,-21,154,-97,-96,154,-153,-156,-10,-24,-80,-9,-40,-54,154,-32,154,154,154,-19,154,154,154,-100,154,-145,-61,154,154,-134,154,-20,-42,-50,154,154,-53,-67,-130,-131,-49,154,154,-12,154,-33,154,-82,154,154,154,154,154,-109,-122,154,-138,-176,-151,-168,-154,-150,-108,154,154,154,-135,-149,-129,-128,154,-110,]),'Factorial2':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[28,28,-123,28,28,-126,28,28,28,-125,-122,-124,28,28,28,-119,28,28,28,-121,28,28,28,155,28,28,28,-120,-118,28,155,155,155,155,155,28,-179,28,28,155,28,28,155,155,155,155,28,-127,155,155,155,155,155,28,28,28,-16,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,-68,28,28,28,28,28,28,28,28,28,-137,28,28,28,28,-69,28,28,28,28,28,28,28,28,-106,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,-37,28,28,28,28,28,28,28,28,-17,28,-39,28,28,28,28,28,28,155,28,28,28,-45,-18,28,28,28,28,-36,28,28,28,28,-89,28,28,28,28,28,28,28,28,28,-169,28,28,28,28,28,-107,-22,-132,155,155,28,28,-133,28,-180,28,28,28,28,28,-194,28,-175,155,28,155,-105,155,155,155,155,155,155,155,155,155,155,-52,155,155,155,155,-64,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,-172,155,155,155,155,-171,155,155,-136,155,-5,155,155,155,155,155,155,155,155,155,155,155,155,155,155,28,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,155,-134,155,155,155,155,155,155,-53,155,-130,-131,155,155,155,155,155,155,155,28,155,155,155,155,155,155,-109,28,-122,155,155,-189,-191,-192,-187,-185,-183,28,-195,-176,155,28,28,-168,28,28,155,-108,155,28,28,28,28,28,-193,155,155,-135,155,-129,-128,155,-188,-190,-186,-184,-110,]),'op_Rule':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,156,-120,-118,-142,-141,-157,-140,156,156,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,156,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,156,-133,-175,-162,-154,-152,-105,-65,-29,-92,156,156,-99,-31,-47,156,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,156,-66,-63,156,156,-51,156,-6,156,-91,-78,-172,-101,-72,156,156,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,156,-21,-27,-97,-96,156,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,156,-81,156,-19,-85,156,-3,-100,156,-145,-61,-2,156,-134,-102,-20,-42,-50,156,156,-53,-67,-130,-131,-49,-86,-44,-12,156,-33,-30,-82,-83,156,-4,156,156,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,156,156,156,-135,-149,-129,-128,-160,-110,]),'Function':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,157,-120,-118,-142,-141,-157,-140,157,157,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,157,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,157,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,157,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,157,-66,-63,-7,157,-51,-84,-6,157,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,157,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,157,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,157,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,157,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,157,157,157,-135,-149,-129,-128,-160,-110,]),'Map':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,158,-120,-118,158,158,158,158,158,158,158,158,158,158,-156,-127,158,158,158,158,158,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,158,-45,-18,-36,-89,-169,-107,-22,-132,158,158,-133,-175,158,-154,158,-105,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,-64,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,-172,158,158,158,158,-171,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,-156,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,158,-134,158,158,158,158,158,158,158,158,-130,-131,158,158,158,158,158,158,158,158,158,158,158,158,158,-109,-122,158,158,-176,158,-168,-154,158,-108,158,158,158,-135,158,-129,-128,158,-110,]),'Power':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,159,-120,-118,159,159,159,159,159,159,159,159,159,159,-156,-127,159,159,159,159,159,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,159,-45,-18,-36,-89,-169,-107,-22,-132,159,159,-133,-175,159,-154,159,-105,159,159,159,159,159,159,159,159,159,159,-52,159,159,159,159,-64,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,-172,159,159,159,159,-171,159,159,-136,159,-5,159,159,159,159,159,159,159,159,159,159,159,159,159,159,-156,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,159,-134,159,159,159,159,159,159,-53,159,-130,-131,159,159,159,159,159,159,159,-82,159,159,159,159,159,-109,-122,159,159,-176,159,-168,-154,159,-108,159,159,159,-135,159,-129,-128,159,-110,]),'Transpose':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,160,-120,-118,160,160,160,160,160,160,160,160,160,160,-156,-127,160,160,160,160,160,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,160,-45,-18,-36,-89,-169,-107,-22,-132,160,160,-133,-175,160,-154,160,-105,160,160,160,160,160,160,160,160,160,160,-52,160,160,160,160,-64,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,-172,160,160,160,160,-171,160,160,-136,160,-5,160,160,160,160,160,160,160,160,160,160,160,160,160,160,-156,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,-134,160,160,160,160,160,160,-53,160,-130,-131,160,160,160,160,160,160,160,160,160,160,160,160,160,-109,-122,160,160,-176,160,-168,-154,160,-108,160,160,160,-135,160,-129,-128,160,-110,]),'RawLeftBrace':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[29,29,-123,29,29,-126,29,29,29,-125,-122,-124,29,29,29,-119,29,29,29,-121,29,29,29,29,29,29,29,-120,-118,29,-142,-141,29,-140,29,29,-179,29,29,29,29,29,-79,29,29,29,29,-127,29,-143,29,-23,29,29,29,29,-16,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,-68,29,29,29,29,29,29,29,29,29,-137,29,29,29,29,-69,29,29,29,29,29,29,29,29,-106,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,-37,29,29,29,29,29,29,29,29,-17,29,-39,29,29,29,29,29,29,-148,29,29,29,-45,-18,29,29,29,29,-36,29,29,29,29,-89,29,29,29,29,29,29,29,29,29,-169,29,29,29,29,29,-107,-22,-132,29,29,29,29,-133,29,-180,29,29,29,29,29,-194,29,-175,29,29,29,-105,29,29,29,29,29,29,29,29,29,29,-52,29,29,29,29,-64,-26,29,29,29,-13,29,29,29,29,29,29,29,29,29,29,-6,29,29,-78,-172,29,29,29,29,-171,29,29,-136,29,-5,-147,-144,29,-146,29,-56,29,29,29,29,29,-96,29,29,29,-10,-24,29,-9,29,29,29,29,29,29,29,29,29,29,29,-100,29,-145,29,29,29,-134,29,-20,29,29,29,29,-53,-67,-130,-131,29,29,29,29,29,29,29,29,-82,29,29,29,29,29,-109,29,-122,29,-138,-189,-191,-192,-187,-185,-183,29,-195,-176,29,29,29,-168,29,29,29,-108,29,29,29,29,29,29,-193,29,29,-135,29,-129,-128,29,-188,-190,-186,-184,-110,]),'MessageName':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,161,-120,-118,161,161,161,161,161,161,161,161,161,161,-156,-127,161,161,161,161,161,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,161,-45,-18,-36,-89,-169,-107,-22,161,161,161,161,-175,161,-154,161,-105,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,-172,161,161,161,161,-171,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,-156,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,161,-130,-131,161,161,161,161,161,161,161,161,161,161,161,161,161,-109,-122,161,161,-176,161,-168,-154,161,-108,161,161,161,161,161,-129,-128,161,-110,]),'LessEqual':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,162,-120,-118,-142,-141,162,-140,162,162,-79,162,162,-155,-156,-127,162,-143,162,-23,162,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,162,162,-133,-175,162,-154,-152,-105,-65,-29,-92,162,162,-99,-31,162,162,-48,-52,162,-43,162,-139,-64,-26,162,162,-8,-13,162,-90,162,162,-66,162,162,162,-51,162,-6,162,-91,-78,-172,162,162,162,162,-171,-46,-11,-136,-58,-5,-147,-144,162,-146,162,-56,-41,162,-21,162,-97,-96,162,-153,-156,-10,-24,-80,-9,-40,-54,162,-32,162,162,162,-19,162,162,162,-100,162,-145,-61,162,162,-134,162,-20,-42,-50,162,162,-53,-67,-130,-131,-49,162,162,-12,162,-33,162,-82,162,162,162,162,162,-109,-122,162,-138,-176,-151,-168,-154,-150,-108,162,162,162,-135,-149,-129,-128,162,-110,]),'Superset':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,163,-120,-118,-142,-141,163,-140,163,163,-79,163,163,-155,-156,-127,163,-143,163,-23,163,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,163,163,-133,-175,163,-154,-152,-105,-65,-29,-92,163,163,-99,-31,163,163,-48,-52,-59,-43,163,-139,-64,-26,-93,163,-8,-13,163,-90,163,163,-66,163,163,163,-51,163,-6,163,-91,-78,-172,163,163,163,163,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,163,-56,-41,163,-21,163,-97,-96,163,-153,-156,-10,-24,-80,-9,-40,-54,163,-32,163,163,163,-19,163,163,163,-100,163,-145,-61,163,163,-134,163,-20,-42,-50,163,163,-53,-67,-130,-131,-49,-86,163,-12,163,-33,-30,-82,-83,163,163,163,163,-109,-122,163,-138,-176,-151,-168,-154,-150,-108,163,163,163,-135,-149,-129,-128,163,-110,]),'RawRightBracket':([2,5,9,10,11,16,17,21,30,31,33,34,35,36,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,169,171,177,178,179,180,182,183,184,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,325,326,329,331,332,335,336,337,344,345,346,347,348,349,350,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-111,-169,-107,-22,-132,-159,-112,-116,-117,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,335,-111,-82,-83,-95,-4,-70,-14,-109,-114,-115,-122,-161,-138,-176,-151,-168,-154,-150,-108,350,-113,-164,-166,-135,-149,-129,-128,356,-160,-110,]),'blanks':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[30,30,-123,30,30,-126,30,30,30,-125,-122,-124,30,30,30,-119,30,30,30,-121,30,30,30,30,30,30,30,-120,-118,30,-142,-141,30,-140,30,30,-179,30,30,30,30,30,-79,30,30,30,30,-127,30,-143,30,-23,30,30,30,30,-16,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,-68,30,30,30,30,30,30,30,30,30,-137,30,30,30,30,-69,30,30,30,30,30,30,30,30,-106,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,-37,30,30,30,30,30,30,30,30,-17,30,-39,30,30,30,30,30,30,-148,30,30,30,-45,-18,30,30,30,30,-36,30,30,30,30,-89,30,30,30,30,30,30,30,30,30,-169,30,30,30,30,30,-107,-22,-132,30,30,30,30,-133,30,-180,30,30,30,30,30,-194,30,-175,30,30,30,-105,30,30,30,30,30,30,30,30,30,30,-52,30,30,30,30,-64,-26,30,30,30,-13,30,30,30,30,30,30,30,30,30,30,-6,30,30,-78,-172,30,30,30,30,-171,30,30,-136,30,-5,-147,-144,30,-146,30,-56,30,30,30,30,30,-96,30,30,30,-10,-24,30,-9,30,30,30,30,30,30,30,30,30,30,30,-100,30,-145,30,30,30,-134,30,-20,30,30,30,30,-53,-67,-130,-131,30,30,30,30,30,30,30,30,-82,30,30,30,30,30,-109,30,-122,30,-138,-189,-191,-192,-187,-185,-183,30,-195,-176,30,30,30,-168,30,30,30,-108,30,30,30,30,30,30,-193,30,30,-135,30,-129,-128,30,-188,-190,-186,-184,-110,]),'Implies':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,164,-120,-118,-142,-141,-157,-140,164,164,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,164,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,164,-133,-175,164,-154,-152,-105,-65,-29,-92,164,164,-99,-31,164,164,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,164,-66,-63,164,164,-51,164,-6,164,-91,-78,-172,-101,164,164,164,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,164,-56,-41,164,-21,164,-97,-96,164,-153,-156,-10,-24,-80,-9,-40,-54,164,-32,164,164,164,-19,164,164,-3,-100,164,-145,-61,164,164,-134,-102,-20,-42,-50,164,164,-53,-67,-130,-131,-49,-86,164,-12,164,-33,-30,-82,-83,164,-4,164,164,-109,-122,164,-138,-176,-151,-168,-154,-150,-108,164,164,164,-135,-149,-129,-128,164,-110,]),'CirclePlus':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,165,-120,-118,-142,-141,165,-140,165,165,-79,165,165,165,-156,-127,165,-143,165,-23,165,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,165,165,-133,-175,165,-154,165,-105,165,165,165,165,165,-99,165,165,165,165,-52,165,165,165,165,-64,-26,165,165,-8,-13,165,165,165,165,165,165,165,165,165,165,-6,165,165,-78,-172,165,165,165,165,-171,165,-11,-136,165,-5,-147,-144,165,-146,165,-56,165,165,-21,165,165,-96,165,165,-156,-10,-24,-80,-9,165,165,165,165,165,165,165,-19,165,165,165,-100,165,-145,165,165,165,-134,165,-20,165,165,165,165,-53,-67,-130,-131,165,165,165,-12,165,165,165,-82,165,165,165,165,165,-109,-122,165,-138,-176,165,-168,-154,165,-108,165,165,165,-135,165,-129,-128,165,-110,]),'RawComma':([2,5,9,10,11,16,17,21,29,30,31,33,34,35,36,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,169,171,177,178,179,180,182,183,184,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,313,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,184,-120,-118,-142,-141,-157,-140,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,184,-169,-107,-22,-132,-159,312,-116,184,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,184,-82,-83,-95,-4,-70,-14,-109,-114,312,-122,-161,-138,-176,-151,-168,-154,-150,-108,-113,-164,-166,-135,-149,-129,-128,-160,-110,]),'Postfix':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,166,-120,-118,-142,-141,-157,-140,166,166,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,166,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,166,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,166,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,166,-66,-63,166,166,-51,-84,-6,166,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,166,-21,-27,-97,-96,166,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,166,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,166,-134,-102,-20,-42,-50,-75,166,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,166,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,166,166,166,-135,-149,-129,-128,-160,-110,]),'symbol':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[31,31,-123,31,31,-126,31,31,31,-125,-122,-124,31,31,31,-119,31,31,31,-121,31,31,31,31,31,31,31,-120,-118,31,-142,-141,31,-140,31,31,-179,31,31,31,31,31,-79,31,31,31,31,-127,31,-143,31,-23,31,31,31,31,-16,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,-68,31,31,31,31,31,31,31,31,31,-137,31,31,31,31,-69,31,31,31,31,31,31,31,31,-106,31,31,31,31,31,31,31,31,31,31,31,31,31,31,31,-37,31,31,31,31,31,31,31,31,-17,31,-39,31,31,31,31,31,31,-148,31,31,31,-45,-18,31,31,31,31,-36,31,31,31,31,-89,294,31,31,31,31,31,31,31,31,31,-169,31,31,31,31,31,-107,-22,-132,31,31,31,31,-133,31,-180,31,31,31,31,31,-194,31,-175,31,31,31,-105,31,31,31,31,31,31,31,31,31,31,-52,31,31,31,31,-64,-26,31,31,31,-13,31,31,31,31,31,31,31,31,31,31,-6,31,31,-78,-172,31,31,31,31,-171,31,31,-136,31,-5,-147,-144,31,-146,31,-56,31,31,31,31,31,-96,31,31,31,-10,-24,31,-9,31,31,31,31,31,31,31,31,31,31,31,-100,31,-145,31,31,31,-134,31,-20,31,31,31,31,-53,-67,-130,-131,31,31,31,31,31,31,31,31,-82,31,31,31,31,31,-109,31,-122,31,-138,-189,-191,-192,-187,-185,-183,31,-195,-176,31,31,31,-168,31,31,31,-108,31,31,31,31,31,31,-193,31,31,-135,31,-129,-128,31,-188,-190,-186,-184,-110,]),'RawRightParenthesis':([2,5,9,10,11,16,17,21,30,31,33,34,35,36,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,202,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,-164,-166,-135,-149,-129,-128,-160,-110,]),'Equal':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,167,-120,-118,-142,-141,167,-140,167,167,-79,167,167,-155,-156,-127,167,-143,167,-23,167,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,167,167,-133,-175,167,-154,-152,-105,-65,-29,-92,167,167,-99,-31,167,167,-48,-52,167,-43,167,-139,-64,-26,167,167,-8,-13,167,-90,167,167,-66,167,167,167,-51,167,-6,167,-91,-78,-172,167,167,167,167,-171,-46,-11,-136,-58,-5,-147,-144,167,-146,167,-56,-41,167,-21,167,-97,-96,167,-153,-156,-10,-24,-80,-9,-40,-54,167,-32,167,167,167,-19,167,167,167,-100,167,-145,-61,167,167,-134,167,-20,-42,-50,167,167,-53,-67,-130,-131,-49,167,167,-12,167,-33,167,-82,167,167,167,167,167,-109,-122,167,-138,-176,-151,-168,-154,-150,-108,167,167,167,-135,-149,-129,-128,167,-110,]),'Element':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,168,-120,-118,-142,-141,168,-140,168,168,-79,168,168,-155,-156,-127,168,-143,168,-23,168,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,168,168,-133,-175,168,-154,-152,-105,-65,-29,-92,168,168,-99,-31,168,168,-48,-52,-59,-43,168,-139,-64,-26,-93,168,-8,-13,168,-90,168,168,-66,168,168,168,-51,168,-6,168,-91,-78,-172,168,168,168,168,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,168,-56,-41,168,-21,168,-97,-96,168,-153,-156,-10,-24,-80,-9,-40,-54,168,-32,168,168,168,-19,168,168,168,-100,168,-145,-61,168,168,-134,168,-20,-42,-50,168,168,-53,-67,-130,-131,-49,-86,168,-12,168,-33,-30,-82,-83,168,168,168,168,-109,-122,168,-138,-176,-151,-168,-154,-150,-108,168,168,168,-135,-149,-129,-128,168,-110,]),'RawLeftBracket':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,169,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,169,-120,-118,169,169,169,169,169,169,169,169,169,169,-156,-127,169,169,169,169,169,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,169,-45,-18,-36,-89,304,-169,-107,-22,169,169,169,169,-175,169,-154,169,-105,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,-64,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,-172,169,169,169,169,-171,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,-156,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,169,-130,-131,169,169,169,169,169,169,169,169,169,169,169,169,169,-109,-122,169,169,-176,169,-168,-154,169,-108,169,169,169,169,169,-129,-128,169,-110,]),'StringJoin':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,170,-120,-118,170,170,170,170,170,170,170,170,170,170,-156,-127,170,170,170,170,170,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,170,-45,-18,-36,-89,-169,-107,-22,-132,170,170,-133,-175,170,-154,170,-105,170,170,170,170,170,170,170,170,170,170,-52,170,170,170,170,-64,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,-172,170,170,170,170,-171,170,170,-136,170,-5,170,170,170,170,170,170,170,170,170,170,170,170,170,170,-156,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,170,-134,170,170,170,170,170,170,-53,170,-130,-131,170,170,170,170,170,170,170,-82,170,170,170,170,170,-109,-122,170,170,-176,170,-168,-154,170,-108,170,170,170,-135,170,-129,-128,170,-110,]),'FormBox':([2,5,9,10,11,16,17,21,30,31,33,34,35,36,42,43,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,196,-178,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,-164,-166,-135,-149,-129,-128,-160,-110,]),'Unset':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,171,-120,-118,-142,-141,-157,-140,171,171,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,171,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,171,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,171,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,171,-66,-63,-7,171,-51,-84,-6,329,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,171,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,171,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,171,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,171,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,171,171,171,-135,-149,-129,-128,-160,-110,]),'Subset':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,172,-120,-118,-142,-141,172,-140,172,172,-79,172,172,-155,-156,-127,172,-143,172,-23,172,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,172,172,-133,-175,172,-154,-152,-105,-65,-29,-92,172,172,-99,-31,172,172,-48,-52,-59,-43,172,-139,-64,-26,-93,172,-8,-13,172,-90,172,172,-66,172,172,172,-51,172,-6,172,-91,-78,-172,172,172,172,172,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,172,-56,-41,172,-21,172,-97,-96,172,-153,-156,-10,-24,-80,-9,-40,-54,172,-32,172,172,172,-19,172,172,172,-100,172,-145,-61,172,172,-134,172,-20,-42,-50,172,172,-53,-67,-130,-131,-49,-86,172,-12,172,-33,-30,-82,-83,172,172,172,172,-109,-122,172,-138,-176,-151,-168,-154,-150,-108,172,172,172,-135,-149,-129,-128,172,-110,]),'UpSet':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,173,-120,-118,-142,-141,-157,-140,173,173,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,173,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,173,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,173,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,173,-66,-63,-7,173,-51,-84,-6,173,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,173,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,173,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,173,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,173,-4,-70,-14,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,173,173,173,-135,-149,-129,-128,-160,-110,]),'op_And':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,174,-120,-118,-142,-141,-157,-140,174,174,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,174,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,174,-133,-175,174,-154,-152,-105,-65,-29,-92,174,174,-99,-31,174,174,-48,-52,-59,-43,174,-139,-64,-26,-93,174,-8,-13,-55,-90,174,174,-66,174,174,174,-51,174,-6,174,-91,-78,-172,174,174,174,174,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,174,-56,-41,174,-21,174,-97,-96,174,-153,-156,-10,-24,-80,-9,-40,-54,174,-32,174,174,174,-19,174,174,-3,-100,174,-145,-61,174,174,-134,174,-20,-42,-50,174,174,-53,-67,-130,-131,-49,-86,174,-12,174,-33,-30,-82,-83,174,-4,174,174,-109,-122,174,-138,-176,-151,-168,-154,-150,-108,174,174,174,-135,-149,-129,-128,174,-110,]),'RightBoxParenthesisInternal':([2,5,9,10,11,16,17,21,30,31,33,34,35,36,38,39,40,43,47,48,49,50,51,52,53,54,55,56,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,186,188,194,195,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,317,318,319,320,321,322,324,325,326,329,331,332,335,343,344,345,346,347,348,349,351,352,353,354,355,356,],[-123,-126,-125,-122,-124,-119,-156,-121,-120,-118,-142,-141,-157,-140,-181,-179,-182,-177,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,-133,-180,322,-194,-175,-162,-154,-152,-105,-65,-29,-92,-71,-94,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,-165,-66,-63,-7,-173,-51,-84,-6,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,-21,-27,-97,-96,-87,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,-167,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,-98,-134,-102,-20,-42,-50,-75,-170,-53,-67,-130,-131,-49,-86,-44,-12,-163,-33,-30,-82,-83,-95,-4,-70,-14,-109,-122,-161,-138,-189,-191,-192,-187,-185,-183,-195,-176,-151,-168,-154,-150,-108,-193,-164,-166,-135,-149,-129,-128,-160,-188,-190,-186,-184,-110,]),'ReplaceAll':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,175,-120,-118,-142,-141,-157,-140,175,175,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,175,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,175,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,175,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,175,-66,-63,175,175,-51,175,-6,175,-91,-78,-172,-101,-72,175,175,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,175,-21,-27,-97,-96,175,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,175,-81,-76,-19,-85,175,-3,-100,-74,-145,-61,-2,175,-134,-102,-20,-42,-50,-75,175,-53,-67,-130,-131,-49,-86,-44,-12,175,-33,-30,-82,-83,175,-4,-70,175,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,175,175,175,-135,-149,-129,-128,-160,-110,]),'Colon':([2,5,9,10,11,16,17,21,26,30,31,33,34,35,36,37,43,47,48,49,50,51,52,53,54,55,56,57,61,85,88,95,101,111,122,127,136,138,145,149,150,155,160,171,177,178,179,180,183,186,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,305,306,307,308,309,310,311,314,315,316,325,326,329,331,332,335,337,344,345,346,347,348,349,351,356,],[-123,-126,-125,-122,-124,-119,-156,-121,176,-120,-118,-142,-141,-157,-140,176,176,-79,-35,-60,-155,-156,-127,-158,-143,-38,-23,176,-16,-68,-174,-137,-69,-106,-154,-37,-17,-39,-148,-45,-18,-36,-89,-169,-107,-22,-132,-159,176,-133,-175,-162,-154,-152,-105,-65,-29,-92,-71,176,-99,-31,-47,-73,-48,-52,-59,-43,-34,-139,-64,-26,-93,-57,-8,-13,-55,-90,-62,176,-66,-63,176,176,-51,-84,-6,176,-91,-78,-172,-101,-72,-88,-25,-171,-46,-11,-136,-58,-5,-147,-144,-77,-146,-28,-56,-41,176,-21,-27,-97,-96,176,-153,-156,-10,-24,-80,-9,-40,-54,-15,-32,176,-81,-76,-19,-85,-1,-3,-100,-74,-145,-61,-2,176,-134,-102,-20,-42,-50,-75,176,-53,-67,-130,-131,-49,-86,-44,-12,176,-33,-30,-82,-83,176,-4,-70,176,-109,-122,-161,-138,-176,-151,-168,-154,-150,-108,176,176,176,-135,-149,-129,-128,-160,-110,]),'Decrement':([0,1,2,3,4,5,6,7,8,9,10,11,13,14,15,16,17,19,20,21,22,23,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,43,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,183,184,185,186,187,188,189,190,191,192,193,195,196,197,198,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,304,305,306,307,308,309,310,311,312,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,335,337,338,339,340,341,342,343,344,345,346,347,348,349,351,352,353,354,355,356,],[32,32,-123,32,32,-126,32,32,32,-125,-122,-124,32,32,32,-119,32,32,32,-121,32,32,32,178,32,32,32,-120,-118,32,178,178,178,178,178,32,-179,32,32,178,32,32,178,178,178,178,32,-127,178,178,178,178,178,32,32,32,-16,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,-68,32,32,32,32,32,32,32,32,32,-137,32,32,32,32,-69,32,32,32,32,32,32,32,32,-106,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,-17,32,-39,32,32,32,32,32,32,178,32,32,32,-45,-18,32,32,32,32,32,32,32,32,32,-89,32,32,32,32,32,32,32,32,32,-169,32,32,32,32,32,-107,-22,178,178,178,32,32,178,32,-180,32,32,32,32,32,-194,32,-175,178,32,178,-105,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,-64,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,-172,178,178,178,178,-171,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,32,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,178,-130,-131,178,178,178,178,178,178,178,32,178,178,178,178,178,178,-109,32,-122,178,178,-189,-191,-192,-187,-185,-183,32,-195,-176,178,32,32,-168,32,32,178,-108,178,32,32,32,32,32,-193,178,178,178,178,-129,-128,178,-188,-190,-186,-184,-110,]),}

_lr_action = { }
for _k, _v in _lr_action_items.items():
   for _x,_y in zip(_v[0],_v[1]):
      if not _x in _lr_action:  _lr_action[_x] = { }
      _lr_action[_x][_k] = _y
del _lr_action_items

_lr_goto_items = {'box':([8,38,40,41,46,189,190,191,192,193,196,323,339,340,341,342,],[39,188,39,195,39,317,318,319,320,321,324,343,352,353,354,355,]),'boxTOKEN':([8,40,46,],[38,38,38,]),'form':([8,38,40,41,46,189,190,191,192,193,196,323,339,340,341,342,],[42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,]),'sequence':([29,169,304,],[181,303,336,]),'expr':([0,1,3,4,6,7,8,13,14,15,17,19,20,22,23,25,26,27,28,29,32,33,34,35,36,37,38,40,41,43,45,46,47,48,49,50,51,53,54,55,56,57,58,59,60,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86,87,88,89,90,91,92,93,94,97,98,99,100,103,104,105,106,107,108,109,110,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,137,139,140,141,142,143,144,145,146,147,148,149,151,152,153,154,155,156,157,158,159,162,163,164,165,166,167,168,169,170,172,173,174,175,176,178,179,180,183,184,185,186,187,189,190,191,192,193,196,198,200,201,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,239,240,241,242,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,296,297,298,299,300,301,302,304,305,306,307,308,309,310,312,315,316,323,326,327,328,330,331,332,337,338,339,340,341,342,344,345,346,347,351,],[26,33,34,35,36,37,43,47,48,49,50,53,54,55,56,57,145,179,180,183,186,145,145,145,145,145,43,43,43,145,198,43,145,145,145,145,201,145,145,145,145,145,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,239,240,241,242,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,264,265,266,267,53,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,145,283,284,285,179,286,287,288,289,180,290,291,292,293,296,297,298,299,300,301,302,183,305,306,307,308,309,310,186,145,145,145,183,315,145,316,43,43,43,43,43,43,145,326,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,332,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,145,183,145,145,145,145,145,145,337,145,145,43,145,344,345,346,347,145,145,351,43,43,43,43,145,145,145,145,145,]),'args':([26,33,34,35,36,37,43,47,48,49,50,53,54,55,56,57,145,179,180,183,186,198,201,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,239,240,241,242,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,296,297,298,299,300,301,302,305,306,307,308,309,310,315,316,326,332,337,344,345,346,347,351,],[111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,111,]),'boxes':([8,40,46,],[44,194,199,]),'sequence1':([29,169,184,304,],[182,182,313,182,]),'pattern':([0,1,3,4,6,7,8,13,14,15,17,19,20,22,23,25,26,27,28,29,32,33,34,35,36,37,38,40,41,43,45,46,47,48,49,50,51,53,54,55,56,57,58,59,60,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86,87,88,89,90,91,92,93,94,97,98,99,100,103,104,105,106,107,108,109,110,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,137,139,140,141,142,143,144,145,146,147,148,149,151,152,153,154,155,156,157,158,159,162,163,164,165,166,167,168,169,170,172,173,174,175,176,178,179,180,183,184,185,186,187,189,190,191,192,193,196,198,200,201,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,239,240,241,242,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,296,297,298,299,300,301,302,304,305,306,307,308,309,310,312,315,316,323,326,327,328,330,331,332,337,338,339,340,341,342,344,345,346,347,351,],[10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,314,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,]),'position':([26,33,34,35,36,37,43,47,48,49,50,53,54,55,56,57,145,179,180,183,186,198,201,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,239,240,241,242,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,296,297,298,299,300,301,302,305,306,307,308,309,310,315,316,326,332,337,344,345,346,347,351,],[177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,177,]),'Expression':([0,],[24,]),}

_lr_goto = { }
for _k, _v in _lr_goto_items.items():
   for _x,_y in zip(_v[0],_v[1]):
       if not _x in _lr_goto: _lr_goto[_x] = { }
       _lr_goto[_x][_k] = _y
del _lr_goto_items
_lr_productions = [
  ("S' -> Expression","S'",1,None,None,None),
  ('expr -> expr AddTo expr','expr',3,'p_AddTo_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Alternatives expr','expr',3,'p_Alternatives_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr And expr','expr',3,'p_And_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr op_And expr','expr',3,'p_And_infix','/home/angus/prog/Mathics/mathics/core/parser.py',927),
  ('expr -> expr Apply1 expr','expr',3,'p_Apply_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr RawBackslash expr','expr',3,'p_Backslash_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Because expr','expr',3,'p_Because_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Cap expr','expr',3,'p_Cap_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr CenterDot expr','expr',3,'p_CenterDot_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr CircleDot expr','expr',3,'p_CircleDot_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr CircleMinus expr','expr',3,'p_CircleMinus_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr CirclePlus expr','expr',3,'p_CirclePlus_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr CircleTimes expr','expr',3,'p_CircleTimes_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Colon expr','expr',3,'p_Colon_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Condition expr','expr',3,'p_Condition_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr ConjugateTranspose','expr',2,'p_ConjugateTranspose_postfix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr HermitianConjugate','expr',2,'p_ConjugateTranspose_postfix','/home/angus/prog/Mathics/mathics/core/parser.py',927),
  ('expr -> expr Conjugate','expr',2,'p_Conjugate_postfix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Coproduct expr','expr',3,'p_Coproduct_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Cross expr','expr',3,'p_Cross_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Cup expr','expr',3,'p_Cup_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Decrement','expr',2,'p_Decrement_postfix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> Del expr','expr',2,'p_Del_prefix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Diamond expr','expr',3,'p_Diamond_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr DivideBy expr','expr',3,'p_DivideBy_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr RawDot expr','expr',3,'p_Dot_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr DoubleLeftTee expr','expr',3,'p_DoubleLeftTee_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr DoubleRightTee expr','expr',3,'p_DoubleRightTee_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr DoubleVerticalBar expr','expr',3,'p_DoubleVerticalBar_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Element expr','expr',3,'p_Element_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr op_Equal expr','expr',3,'p_Equal_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr LongEqual expr','expr',3,'p_Equal_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',927),
  ('expr -> expr Equal expr','expr',3,'p_Equal_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',928),
  ('expr -> expr Equivalent expr','expr',3,'p_Equivalent_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> Exists expr','expr',2,'p_Exists_prefix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Factorial2','expr',2,'p_Factorial2_postfix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Factorial','expr',2,'p_Factorial_postfix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> ForAll expr','expr',2,'p_ForAll_prefix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr RawAmpersand','expr',2,'p_Function_postfix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr op_GreaterEqual expr','expr',3,'p_GreaterEqual_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr GreaterEqual expr','expr',3,'p_GreaterEqual_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',927),
  ('expr -> expr GreaterSlantEqual expr','expr',3,'p_GreaterEqual_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',928),
  ('expr -> expr Greater expr','expr',3,'p_Greater_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Implies expr','expr',3,'p_Implies_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Increment','expr',2,'p_Increment_postfix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Intersection expr','expr',3,'p_Intersection_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr LeftTee expr','expr',3,'p_LeftTee_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr op_LessEqual expr','expr',3,'p_LessEqual_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr LessEqual expr','expr',3,'p_LessEqual_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',927),
  ('expr -> expr LessSlantEqual expr','expr',3,'p_LessEqual_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',928),
  ('expr -> expr Less expr','expr',3,'p_Less_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr MapAll expr','expr',3,'p_MapAll_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Map expr','expr',3,'p_Map_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr MinusPlus expr','expr',3,'p_MinusPlus_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Nand expr','expr',3,'p_Nand_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr NonCommutativeMultiply expr','expr',3,'p_NonCommutativeMultiply_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Nor expr','expr',3,'p_Nor_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr NotDoubleVerticalBar expr','expr',3,'p_NotDoubleVerticalBar_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr NotElement expr','expr',3,'p_NotElement_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> NotExists expr','expr',2,'p_NotExists_prefix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr NotVerticalBar expr','expr',3,'p_NotVerticalBar_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr op_Or expr','expr',3,'p_Or_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Or expr','expr',3,'p_Or_infix','/home/angus/prog/Mathics/mathics/core/parser.py',927),
  ('expr -> expr PatternTest expr','expr',3,'p_PatternTest_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr PlusMinus expr','expr',3,'p_PlusMinus_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Plus expr','expr',3,'p_Plus_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Power expr','expr',3,'p_Power_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr RepeatedNull','expr',2,'p_RepeatedNull_postfix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Repeated','expr',2,'p_Repeated_postfix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr ReplaceAll expr','expr',3,'p_ReplaceAll_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr ReplaceRepeated expr','expr',3,'p_ReplaceRepeated_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr RightTee expr','expr',3,'p_RightTee_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr op_RuleDelayed expr','expr',3,'p_RuleDelayed_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr RuleDelayed expr','expr',3,'p_RuleDelayed_infix','/home/angus/prog/Mathics/mathics/core/parser.py',927),
  ('expr -> expr op_Rule expr','expr',3,'p_Rule_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Rule expr','expr',3,'p_Rule_infix','/home/angus/prog/Mathics/mathics/core/parser.py',927),
  ('expr -> expr SameQ expr','expr',3,'p_SameQ_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr SmallCircle expr','expr',3,'p_SmallCircle_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> Square expr','expr',2,'p_Square_prefix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Star expr','expr',3,'p_Star_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr StringExpression expr','expr',3,'p_StringExpression_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr StringJoin expr','expr',3,'p_StringJoin_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Subset expr','expr',3,'p_Subset_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr SubtractFrom expr','expr',3,'p_SubtractFrom_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr SuchThat expr','expr',3,'p_SuchThat_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Superset expr','expr',3,'p_Superset_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Therefore expr','expr',3,'p_Therefore_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr TimesBy expr','expr',3,'p_TimesBy_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Transpose','expr',2,'p_Transpose_postfix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr op_Unequal expr','expr',3,'p_Unequal_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr NotEqual expr','expr',3,'p_Unequal_innequality','/home/angus/prog/Mathics/mathics/core/parser.py',927),
  ('expr -> expr Union expr','expr',3,'p_Union_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr UnsameQ expr','expr',3,'p_UnsameQ_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr UpSetDelayed expr','expr',3,'p_UpSetDelayed_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr UpSet expr','expr',3,'p_UpSet_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Vee expr','expr',3,'p_Vee_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr VerticalBar expr','expr',3,'p_VerticalBar_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr VerticalSeparator expr','expr',3,'p_VerticalSeparator_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr VerticalTilde expr','expr',3,'p_VerticalTilde_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Wedge expr','expr',3,'p_Wedge_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Xnor expr','expr',3,'p_Xnor_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('expr -> expr Xor expr','expr',3,'p_Xor_infix','/home/angus/prog/Mathics/mathics/core/parser.py',926),
  ('Expression -> expr','Expression',1,'p_Expression','/home/angus/prog/Mathics/mathics/core/parser.py',1027),
  ('Expression -> <empty>','Expression',0,'p_Empty','/home/angus/prog/Mathics/mathics/core/parser.py',1031),
  ('expr -> RawLeftParenthesis expr RawRightParenthesis','expr',3,'p_parenthesis','/home/angus/prog/Mathics/mathics/core/parser.py',1035),
  ('expr -> expr args','expr',2,'p_call','/home/angus/prog/Mathics/mathics/core/parser.py',1041),
  ('expr -> expr position','expr',2,'p_part','/home/angus/prog/Mathics/mathics/core/parser.py',1047),
  ('args -> RawLeftBracket sequence RawRightBracket','args',3,'p_args','/home/angus/prog/Mathics/mathics/core/parser.py',1051),
  ('expr -> RawLeftBrace sequence RawRightBrace','expr',3,'p_list','/home/angus/prog/Mathics/mathics/core/parser.py',1055),
  ('position -> RawLeftBracket RawLeftBracket sequence RawRightBracket RawRightBracket','position',5,'p_position','/home/angus/prog/Mathics/mathics/core/parser.py',1059),
  ('sequence -> <empty>','sequence',0,'p_sequence','/home/angus/prog/Mathics/mathics/core/parser.py',1063),
  ('sequence -> sequence1','sequence',1,'p_sequence','/home/angus/prog/Mathics/mathics/core/parser.py',1064),
  ('sequence1 -> sequence1 RawComma expr','sequence1',3,'p_sequence1','/home/angus/prog/Mathics/mathics/core/parser.py',1071),
  ('sequence1 -> sequence1 RawComma','sequence1',2,'p_sequence1','/home/angus/prog/Mathics/mathics/core/parser.py',1072),
  ('sequence1 -> RawComma sequence1','sequence1',2,'p_sequence1','/home/angus/prog/Mathics/mathics/core/parser.py',1073),
  ('sequence1 -> expr','sequence1',1,'p_sequence1','/home/angus/prog/Mathics/mathics/core/parser.py',1074),
  ('sequence1 -> RawComma','sequence1',1,'p_sequence1','/home/angus/prog/Mathics/mathics/core/parser.py',1075),
  ('expr -> symbol','expr',1,'p_symbol','/home/angus/prog/Mathics/mathics/core/parser.py',1093),
  ('expr -> number','expr',1,'p_number','/home/angus/prog/Mathics/mathics/core/parser.py',1097),
  ('pattern -> blanks','pattern',1,'p_blanks','/home/angus/prog/Mathics/mathics/core/parser.py',1101),
  ('pattern -> blankdefault','pattern',1,'p_blankdefault','/home/angus/prog/Mathics/mathics/core/parser.py',1120),
  ('expr -> pattern','expr',1,'p_pattern','/home/angus/prog/Mathics/mathics/core/parser.py',1128),
  ('expr -> slot','expr',1,'p_slot','/home/angus/prog/Mathics/mathics/core/parser.py',1132),
  ('expr -> slotseq','expr',1,'p_slotseq','/home/angus/prog/Mathics/mathics/core/parser.py',1136),
  ('expr -> out','expr',1,'p_out','/home/angus/prog/Mathics/mathics/core/parser.py',1140),
  ('expr -> string','expr',1,'p_string','/home/angus/prog/Mathics/mathics/core/parser.py',1147),
  ('expr -> Get filename','expr',2,'p_Get','/home/angus/prog/Mathics/mathics/core/parser.py',1151),
  ('expr -> expr MessageName string MessageName string','expr',5,'p_MessageName','/home/angus/prog/Mathics/mathics/core/parser.py',1155),
  ('expr -> expr MessageName symbol MessageName string','expr',5,'p_MessageName','/home/angus/prog/Mathics/mathics/core/parser.py',1156),
  ('expr -> expr MessageName symbol','expr',3,'p_MessageName','/home/angus/prog/Mathics/mathics/core/parser.py',1157),
  ('expr -> expr MessageName string','expr',3,'p_MessageName','/home/angus/prog/Mathics/mathics/core/parser.py',1158),
  ('expr -> Increment expr','expr',2,'p_PreIncrement','/home/angus/prog/Mathics/mathics/core/parser.py',1166),
  ('expr -> Decrement expr','expr',2,'p_PreDecrement','/home/angus/prog/Mathics/mathics/core/parser.py',1170),
  ('expr -> expr Prefix expr','expr',3,'p_Prefix','/home/angus/prog/Mathics/mathics/core/parser.py',1174),
  ('expr -> expr Infix expr Infix expr','expr',5,'p_Infix','/home/angus/prog/Mathics/mathics/core/parser.py',1178),
  ('expr -> expr Apply2 expr','expr',3,'p_Apply2','/home/angus/prog/Mathics/mathics/core/parser.py',1182),
  ('expr -> expr Derivative','expr',2,'p_Derivative','/home/angus/prog/Mathics/mathics/core/parser.py',1187),
  ('expr -> Integral expr DifferentialD expr','expr',4,'p_Integrate','/home/angus/prog/Mathics/mathics/core/parser.py',1191),
  ('expr -> expr Minus expr','expr',3,'p_Minus','/home/angus/prog/Mathics/mathics/core/parser.py',1195),
  ('expr -> Plus expr','expr',2,'p_UPlus','/home/angus/prog/Mathics/mathics/core/parser.py',1199),
  ('expr -> Minus expr','expr',2,'p_UMinus','/home/angus/prog/Mathics/mathics/core/parser.py',1203),
  ('expr -> PlusMinus expr','expr',2,'p_UPlusMinus','/home/angus/prog/Mathics/mathics/core/parser.py',1211),
  ('expr -> MinusPlus expr','expr',2,'p_UMinusPlus','/home/angus/prog/Mathics/mathics/core/parser.py',1215),
  ('expr -> expr RawSlash expr','expr',3,'p_Slash','/home/angus/prog/Mathics/mathics/core/parser.py',1219),
  ('expr -> expr Divide expr','expr',3,'p_Slash','/home/angus/prog/Mathics/mathics/core/parser.py',1220),
  ('expr -> expr Times expr','expr',3,'p_Times','/home/angus/prog/Mathics/mathics/core/parser.py',1224),
  ('expr -> expr RawStar expr','expr',3,'p_Times','/home/angus/prog/Mathics/mathics/core/parser.py',1225),
  ('expr -> expr expr','expr',2,'p_Times','/home/angus/prog/Mathics/mathics/core/parser.py',1226),
  ('expr -> expr Span expr Span expr','expr',5,'p_Span','/home/angus/prog/Mathics/mathics/core/parser.py',1243),
  ('expr -> expr Span Span expr','expr',4,'p_Span','/home/angus/prog/Mathics/mathics/core/parser.py',1244),
  ('expr -> Span expr Span expr','expr',4,'p_Span','/home/angus/prog/Mathics/mathics/core/parser.py',1245),
  ('expr -> Span Span expr','expr',3,'p_Span','/home/angus/prog/Mathics/mathics/core/parser.py',1246),
  ('expr -> expr Span expr','expr',3,'p_Span','/home/angus/prog/Mathics/mathics/core/parser.py',1247),
  ('expr -> expr Span','expr',2,'p_Span','/home/angus/prog/Mathics/mathics/core/parser.py',1248),
  ('expr -> Span expr','expr',2,'p_Span','/home/angus/prog/Mathics/mathics/core/parser.py',1249),
  ('expr -> Span','expr',1,'p_Span','/home/angus/prog/Mathics/mathics/core/parser.py',1250),
  ('expr -> Not expr','expr',2,'p_Not','/home/angus/prog/Mathics/mathics/core/parser.py',1273),
  ('expr -> Factorial expr','expr',2,'p_Not','/home/angus/prog/Mathics/mathics/core/parser.py',1274),
  ('expr -> Factorial2 expr','expr',2,'p_Not','/home/angus/prog/Mathics/mathics/core/parser.py',1275),
  ('expr -> symbol RawColon pattern RawColon expr','expr',5,'p_Pattern','/home/angus/prog/Mathics/mathics/core/parser.py',1281),
  ('expr -> symbol RawColon expr','expr',3,'p_Pattern','/home/angus/prog/Mathics/mathics/core/parser.py',1282),
  ('expr -> pattern RawColon expr','expr',3,'p_Optional','/home/angus/prog/Mathics/mathics/core/parser.py',1290),
  ('expr -> expr Postfix expr','expr',3,'p_Postfix','/home/angus/prog/Mathics/mathics/core/parser.py',1294),
  ('expr -> expr TagSet expr Set expr','expr',5,'p_Set','/home/angus/prog/Mathics/mathics/core/parser.py',1298),
  ('expr -> expr Set expr','expr',3,'p_Set','/home/angus/prog/Mathics/mathics/core/parser.py',1299),
  ('expr -> expr TagSet expr SetDelayed expr','expr',5,'p_SetDelayed','/home/angus/prog/Mathics/mathics/core/parser.py',1306),
  ('expr -> expr SetDelayed expr','expr',3,'p_SetDelayed','/home/angus/prog/Mathics/mathics/core/parser.py',1307),
  ('expr -> expr TagSet expr Unset','expr',4,'p_Unset','/home/angus/prog/Mathics/mathics/core/parser.py',1314),
  ('expr -> expr Unset','expr',2,'p_Unset','/home/angus/prog/Mathics/mathics/core/parser.py',1315),
  ('expr -> expr Function expr','expr',3,'p_Function','/home/angus/prog/Mathics/mathics/core/parser.py',1322),
  ('expr -> expr Put filename','expr',3,'p_Put','/home/angus/prog/Mathics/mathics/core/parser.py',1326),
  ('expr -> expr PutAppend filename','expr',3,'p_PutAppend','/home/angus/prog/Mathics/mathics/core/parser.py',1330),
  ('expr -> expr Semicolon expr','expr',3,'p_Compound','/home/angus/prog/Mathics/mathics/core/parser.py',1334),
  ('expr -> expr Semicolon','expr',2,'p_Compound','/home/angus/prog/Mathics/mathics/core/parser.py',1335),
  ('expr -> LeftBoxParenthesis boxes RightBoxParenthesis','expr',3,'p_box_to_expr','/home/angus/prog/Mathics/mathics/core/parser.py',1347),
  ('expr -> InterpretedBox LeftBoxParenthesis boxes RightBoxParenthesis','expr',4,'p_box_to_expr','/home/angus/prog/Mathics/mathics/core/parser.py',1348),
  ('box -> expr','box',1,'p_box','/home/angus/prog/Mathics/mathics/core/parser.py',1356),
  ('form -> expr','form',1,'p_form','/home/angus/prog/Mathics/mathics/core/parser.py',1360),
  ('boxTOKEN -> box','boxTOKEN',1,'p_boxes','/home/angus/prog/Mathics/mathics/core/parser.py',1367),
  ('boxTOKEN -> boxTOKEN box','boxTOKEN',2,'p_boxes','/home/angus/prog/Mathics/mathics/core/parser.py',1368),
  ('boxes -> boxTOKEN','boxes',1,'p_boxes','/home/angus/prog/Mathics/mathics/core/parser.py',1369),
  ('boxes -> <empty>','boxes',0,'p_boxes','/home/angus/prog/Mathics/mathics/core/parser.py',1370),
  ('box -> LeftBoxParenthesisInternal boxes RightBoxParenthesisInternal','box',3,'p_RowBox','/home/angus/prog/Mathics/mathics/core/parser.py',1386),
  ('box -> box Superscript box Otherscript box','box',5,'p_SuperscriptBox','/home/angus/prog/Mathics/mathics/core/parser.py',1391),
  ('box -> box Superscript box','box',3,'p_SuperscriptBox','/home/angus/prog/Mathics/mathics/core/parser.py',1392),
  ('box -> box Subscript box Otherscript box','box',5,'p_Subscript','/home/angus/prog/Mathics/mathics/core/parser.py',1399),
  ('box -> box Subscript box','box',3,'p_Subscript','/home/angus/prog/Mathics/mathics/core/parser.py',1400),
  ('box -> box Overscript box Otherscript box','box',5,'p_OverscriptBox','/home/angus/prog/Mathics/mathics/core/parser.py',1407),
  ('box -> box Overscript box','box',3,'p_OverscriptBox','/home/angus/prog/Mathics/mathics/core/parser.py',1408),
  ('box -> box Underscript box Otherscript box','box',5,'p_UnderscriptBox','/home/angus/prog/Mathics/mathics/core/parser.py',1415),
  ('box -> box Underscript box','box',3,'p_UnderscriptBox','/home/angus/prog/Mathics/mathics/core/parser.py',1416),
  ('box -> box Fraction box','box',3,'p_FractionBox','/home/angus/prog/Mathics/mathics/core/parser.py',1423),
  ('box -> Sqrt box Otherscript box','box',4,'p_SqrtBox','/home/angus/prog/Mathics/mathics/core/parser.py',1427),
  ('box -> Sqrt box','box',2,'p_SqrtBox','/home/angus/prog/Mathics/mathics/core/parser.py',1428),
  ('box -> form FormBox box','box',3,'p_FormBox','/home/angus/prog/Mathics/mathics/core/parser.py',1435),
]

########NEW FILE########
__FILENAME__ = pattern
# -*- coding: utf8 -*-
# cython: profile=False

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from mathics.core.expression import Expression
from mathics.core.util import subsets, subranges, permutations

# from mathics.core.pattern_nocython import (
#    StopGenerator #, Pattern #, ExpressionPattern)
# from mathics.core import pattern_nocython


def Pattern_create(expr):
    from mathics.builtin import pattern_objects
    # from mathics.core.pattern import AtomPattern, ExpressionPattern

    name = expr.get_head_name()
    pattern_object = pattern_objects.get(name)
    if pattern_object is not None:
        return pattern_object(expr)
    if expr.is_atom():
        return AtomPattern(expr)
    else:
        return ExpressionPattern(expr)


class StopGenerator(Exception):
    def __init__(self, value=None):
        self.value = value


class StopGenerator_ExpressionPattern_match(StopGenerator):
    pass


class StopGenerator_Pattern(StopGenerator):
    pass


class Pattern(object):
    #@staticmethod
    # def create(expr):

    create = staticmethod(Pattern_create)

    def match(self, yield_func, expression, vars, evaluation, head=None,
              leaf_index=None, leaf_count=None, fully=True, wrap_oneid=True):
        raise NotImplementedError

    """def match(self, expression, vars, evaluation,
              head=None, leaf_index=None, leaf_count=None,
        fully=True, wrap_oneid=True):
        #raise NotImplementedError
        result = []
        def yield_func(vars, rest):
            result.append(vars, rest)
        self._match(yield_func, expression, vars, evaluation, head,
                    leaf_index, leaf_count, fully, wrap_oneid)
        return result"""

    def does_match(self, expression, evaluation, vars=None, fully=True):

        if vars is None:
            vars = {}
        # for sub_vars, rest in self.match(  # nopep8
        #    expression, vars, evaluation, fully=fully):
        #    return True

        def yield_match(sub_vars, rest):
            raise StopGenerator_Pattern(True)
        try:
            self.match(yield_match, expression, vars, evaluation, fully=fully)
        except StopGenerator_Pattern, exc:
            return exc.value
        return False

    def get_name(self):
        return self.expr.get_name()

    def is_atom(self):
        return self.expr.is_atom()

    def get_head_name(self):
        return self.expr.get_head_name()

    def same(self, other):
        return self.expr.same(other.expr)

    def get_head(self):
        return self.expr.get_head()

    def get_leaves(self):
        return self.expr.get_leaves()

    def get_sort_key(self, pattern_sort=False):
        return self.expr.get_sort_key(pattern_sort=pattern_sort)

    def get_lookup_name(self):
        return self.expr.get_lookup_name()

    def get_attributes(self, definitions):
        return self.expr.get_attributes(definitions)

    def get_sequence(self):
        return self.expr.get_sequence()

    def get_option_values(self):
        return self.expr.get_option_values()

    def has_form(self, *args):
        return self.expr.has_form(*args)

    def get_match_candidates(
            self, leaves, expression, attributes, evaluation, vars={}):
        return []

    def get_match_candidates_count(
            self, leaves, expression, attributes, evaluation, vars={}):
        return len(self.get_match_candidates(
            leaves, expression, attributes, evaluation, vars))


class AtomPattern(Pattern):
    def __init__(self, expr):
        self.atom = expr
        self.expr = expr

    def __repr__(self):
        return (u'<AtomPattern: %s>' % self.atom).encode('unicode_escape')

    def match(self, yield_func, expression, vars, evaluation, head=None,
              leaf_index=None, leaf_count=None, fully=True, wrap_oneid=True):
        if expression.same(self.atom):
            # yield vars, None
            yield_func(vars, None)

    def get_match_candidates(
            self, leaves, expression, attributes, evaluation, vars={}):
        return [leaf for leaf in leaves if leaf.same(self.atom)]

    def get_match_count(self, vars={}):
        return (1, 1)


# class StopGenerator_ExpressionPattern_match(StopGenerator):
#    pass

class ExpressionPattern(Pattern):
    # get_pre_choices = pattern_nocython.get_pre_choices
    # match = pattern_nocython.match

    def match(self, yield_func, expression, vars, evaluation, head=None,
              leaf_index=None, leaf_count=None, fully=True, wrap_oneid=True):
        evaluation.check_stopped()

        attributes = self.head.get_attributes(evaluation.definitions)
        if 'Flat' not in attributes:
            fully = True
        if not expression.is_atom():
            # don't do this here, as self.get_pre_choices changes the
            # ordering of the leaves!
            # if self.leaves:
            #    next_leaf = self.leaves[0]
            #    next_leaves = self.leaves[1:]

            def yield_choice(pre_vars):
                next_leaf = self.leaves[0]
                next_leaves = self.leaves[1:]
                for leaf in self.leaves:
                    match_count = leaf.get_match_count()
                    candidates = leaf.get_match_candidates_count(
                        expression.leaves, expression, attributes, evaluation,
                        pre_vars)
                    if candidates < match_count[0]:
                        raise StopGenerator_ExpressionPattern_match()
                # for new_vars, rest in self.match_leaf(    # nopep8
                #    self.leaves[0], self.leaves[1:], ([], expression.leaves),
                #    pre_vars, expression, attributes, evaluation, first=True,
                #    fully=fully, leaf_count=len(self.leaves),
                #    wrap_oneid=expression.get_head_name() != 'MakeBoxes'):
                # def yield_leaf(new_vars, rest):
                #    yield_func(new_vars, rest)
                self.match_leaf(
                    yield_func, next_leaf, next_leaves,
                    ([], expression.leaves), pre_vars, expression, attributes,
                    evaluation, first=True, fully=fully,
                    leaf_count=len(self.leaves),
                    wrap_oneid=expression.get_head_name() != 'MakeBoxes')

            # for head_vars, _ in self.head.match(expression.get_head(), vars,
            # evaluation):
            def yield_head(head_vars, _):
                if self.leaves:
                    # pre_choices = self.get_pre_choices(
                    #    expression, attributes, head_vars)
                    # for pre_vars in pre_choices:

                    self.get_pre_choices(
                        yield_choice, expression, attributes, head_vars)
                else:
                    if not expression.leaves:
                        yield_func(head_vars, None)
                    else:
                        return
            try:
                self.head.match(
                    yield_head, expression.get_head(), vars, evaluation)
            except StopGenerator_ExpressionPattern_match:
                return
        if (wrap_oneid and 'OneIdentity' in attributes and      # nopep8
            expression.get_head() != self.head and expression != self.head):
            # and 'OneIdentity' not in
            # (expression.get_attributes(evaluation.definitions) |
            # expression.get_head().get_attributes(evaluation.definitions)):
            new_expression = Expression(self.head, expression)
            for leaf in self.leaves:
                leaf.match_count = leaf.get_match_count()
                leaf.candidates = [expression]
                # leaf.get_match_candidates(
                #    new_expression.leaves, new_expression, attributes,
                #    evaluation, vars)
                if len(leaf.candidates) < leaf.match_count[0]:
                    return
            # for new_vars, rest in self.match_leaf(
            #    self.leaves[0], self.leaves[1:],
            #    ([], [expression]), vars, new_expression, attributes,
            #    evaluation, first=True, fully=fully,
            #    leaf_count=len(self.leaves), wrap_oneid=True):
            # def yield_leaf(new_vars, rest):
            #    yield_func(new_vars, rest)
            self.match_leaf(
                yield_func, self.leaves[0], self.leaves[1:],
                ([], [expression]), vars, new_expression, attributes,
                evaluation, first=True, fully=fully,
                leaf_count=len(self.leaves), wrap_oneid=True)

    def get_pre_choices(self, yield_func, expression, attributes, vars):
        if 'Orderless' in attributes:
            self.sort()
            patterns = self.filter_leaves('Pattern')
            groups = {}
            prev_pattern = prev_name = None
            for pattern in patterns:
                name = pattern.leaves[0].get_name()
                existing = vars.get(name, None)
                if existing is None:
                    # There's no need for pre-choices if the variable is
                    # already set.
                    if name == prev_name:
                        if name in groups:
                            groups[name].append(pattern)
                        else:
                            groups[name] = [prev_pattern, pattern]
                    prev_pattern = pattern
                    prev_name = name
            expr_groups = {}
            # prev_leaf = None
            for leaf in expression.leaves:
                if leaf in expr_groups:
                    expr_groups[leaf] += 1
                else:
                    expr_groups[leaf] = 1

            def per_name(yield_name, groups, vars):
                """
                Yields possible variable settings (dictionaries) for the
                remaining pattern groups
                """

                if groups:
                    name, patterns = groups[0]

                    match_count = [0, None]
                    for pattern in patterns:
                        sub_match_count = pattern.get_match_count()
                        if sub_match_count[0] > match_count[0]:
                            match_count[0] = sub_match_count[0]
                        if (match_count[1] is None or
                            (sub_match_count[1] is not None and
                             sub_match_count[1] < match_count[1])):
                            match_count[1] = sub_match_count[1]
                    # possibilities = [{}]
                    # sum = 0

                    def per_expr(yield_expr, expr_groups, sum=0):
                        """
                        Yields possible values (sequence lists) for the current
                        variable (name) taking into account the
                        (expression, count)'s in expr_groups
                        """

                        if expr_groups:
                            expr, count = expr_groups[0]
                            max_per_pattern = count / len(patterns)
                            for per_pattern in range(max_per_pattern, -1, -1):
                                for next in per_expr(   # nopep8
                                    expr_groups[1:], sum + per_pattern):
                                    yield_expr([expr] * per_pattern + next)
                        else:
                            if sum >= match_count[0]:
                                yield_expr([])

                    # for sequence in per_expr(expr_groups.items()):
                    def yield_expr(sequence):
                        wrappings = self.get_wrappings(
                            sequence, match_count[1], expression, attributes)
                        for wrapping in wrappings:
                            # for next in per_name(groups[1:], vars):
                            def yield_next(next):
                                setting = next.copy()
                                setting[name] = wrapping
                                yield_name(setting)
                            per_name(yield_next, groups[1:], vars)
                    per_expr(yield_expr, expr_groups.items())
                else:  # no groups left
                    yield_name(vars)

            # for setting in per_name(groups.items(), vars):
            # def yield_name(setting):
            #    yield_func(setting)
            per_name(yield_func, groups.items(), vars)
        else:
            yield_func(vars)

    def __init__(self, expr):
        self.head = Pattern.create(expr.head)
        self.leaves = [Pattern.create(leaf) for leaf in expr.leaves]
        self.expr = expr

    def filter_leaves(self, head_name):
        return [leaf for leaf in self.leaves
                if leaf.get_head_name() == head_name]

    def __repr__(self):
        return (u'<ExpressionPattern: %s>' % self.expr).encode('unicode_escape')

    def get_match_count(self, vars={}):
        return (1, 1)

    def get_wrappings(self, yield_func, items, max_count,
                      expression, attributes, include_flattened=True):
        if len(items) == 1:
            yield_func(items[0])
        else:
            if max_count is None or len(items) <= max_count:
                if 'Orderless' in attributes:
                    for perm in permutations(items):
                        sequence = Expression('Sequence', *perm)
                        sequence.pattern_sequence = True
                        yield_func(sequence)
                else:
                    sequence = Expression('Sequence', *items)
                    sequence.pattern_sequence = True
                    yield_func(sequence)
            if 'Flat' in attributes and include_flattened:
                yield_func(Expression(expression.get_head(), *items))

    def match_leaf(self, yield_func, leaf, rest_leaves, rest_expression, vars,
                   expression, attributes, evaluation, leaf_index=1,
                   leaf_count=None, first=False, fully=True, depth=1,
                   wrap_oneid=True):

        if rest_expression is None:
            rest_expression = ([], [])

        evaluation.check_stopped()

        match_count = leaf.get_match_count(vars)
        leaf_candidates = leaf.get_match_candidates(
            rest_expression[1],  # leaf.candidates,
            expression, attributes, evaluation, vars)

        if len(leaf_candidates) < match_count[0]:
            return

        # STRANGE: candidate in leaf_candidates causes BusError for
        # Real ^ Integer (e.g. 2.0^3) when not converted to a set!
        leaf_candidates = set(leaf_candidates)

        candidates = rest_expression[1]

        # "Artificially" only use more leaves than specified for some kind
        # of pattern.
        # TODO: This could be further optimized!
        try_flattened = ('Flat' in attributes) and (leaf.get_head_name() in (
            'Pattern', 'PatternTest', 'Condition', 'Optional',
            'Blank', 'BlankSequence', 'BlankNullSequence', 'Alternatives',
            'OptionsPattern', 'Repeated', 'RepeatedNull'))

        if try_flattened:
            set_lengths = (match_count[0], None)
        else:
            set_lengths = match_count

        # try_flattened is used later to decide whether wrapping of leaves
        # into one operand may occur.
        # This can of course also be when flat and same head.
        try_flattened = try_flattened or ((
            'Flat' in attributes) and leaf.get_head() == expression.head)

        less_first = len(rest_leaves) > 0

        if 'Orderless' in attributes:
            sets = None
            if leaf.get_head_name() == 'Pattern':
                varname = leaf.leaves[0].get_name()
                existing = vars.get(varname, None)
                if existing is not None:
                    head = existing.get_head()
                    if (head.get_name() == 'Sequence' or (
                            'Flat' in attributes and
                            head == expression.get_head())):
                        needed = existing.leaves
                    else:
                        needed = [existing]
                    available = candidates[:]
                    for needed_leaf in needed:
                        if (needed_leaf in available and        # nopep8
                            needed_leaf in leaf_candidates):
                            available.remove(needed_leaf)
                        else:
                            return
                    sets = [(needed, ([], available))]

            if sets is None:
                sets = subsets(candidates, included=leaf_candidates,
                               less_first=less_first, *set_lengths)
        else:
            sets = subranges(candidates, flexible_start=first and not fully,
                             included=leaf_candidates, less_first=less_first,
                             *set_lengths)

        # print "Match %s in %s" % (leaf, expression)

        if rest_leaves:
            next_leaf = rest_leaves[0]
            next_rest_leaves = rest_leaves[1:]
        next_depth = depth + 1
        next_index = leaf_index + 1

        for items, items_rest in sets:
            # try:
            # print (u"  " + u", ".join(unicode(item)
            #        for item in items)).encode('utf-8')
            # except
            # Include wrappings like Plus[a, b] only if not all items taken
            # - in that case we would match the same expression over and over.

            include_flattened = (try_flattened and
                                 0 < len(items) < len(expression.leaves))

            # Don't try flattened when the expression would remain the same!

            def leaf_yield(next_vars, next_rest):
                # if next_rest is None:
                #    next_rest = ([], [])
                # yield_func(next_vars, (rest_expression[0] + items_rest[0],
                # next_rest[1]))
                if next_rest is None:
                    yield_func(
                        next_vars,
                        (rest_expression[0] + items_rest[0], []))
                else:
                    yield_func(
                        next_vars,
                        (rest_expression[0] + items_rest[0], next_rest[1]))

            def match_yield(new_vars, _):
                if rest_leaves:
                    self.match_leaf(
                        leaf_yield, next_leaf, next_rest_leaves, items_rest,
                        new_vars, expression, attributes, evaluation,
                        fully=fully, depth=next_depth, leaf_index=next_index,
                        leaf_count=leaf_count, wrap_oneid=wrap_oneid)
                else:
                    if not fully or (not items_rest[0] and not items_rest[1]):
                        yield_func(new_vars, items_rest)

            def yield_wrapping(item):
                leaf.match(match_yield, item, vars, evaluation, fully=True,
                           head=expression.head, leaf_index=leaf_index,
                           leaf_count=leaf_count, wrap_oneid=wrap_oneid)

            self.get_wrappings(
                yield_wrapping, items, match_count[1], expression, attributes,
                include_flattened=include_flattened)

    def get_match_candidates(self, leaves, expression, attributes, evaluation,
                             vars={}):
        """
        Finds possible leaves that could match the pattern, ignoring future
        pattern variable definitions, but taking into account already fixed
        variables.
        """
        # TODO: fixed_vars!

        return [leaf for leaf in leaves
                if self.does_match(leaf, evaluation, vars)]

    def get_match_candidates_count(self, leaves, expression, attributes,
                                   evaluation, vars={}):
        """
        Finds possible leaves that could match the pattern, ignoring future
        pattern variable definitions, but taking into account already fixed
        variables.
        """
        # TODO: fixed_vars!

        count = 0
        for leaf in leaves:
            if self.does_match(leaf, evaluation, vars):
                count += 1
        return count

    def sort(self):
        self.leaves.sort(key=lambda e: e.get_sort_key(pattern_sort=True))

########NEW FILE########
__FILENAME__ = rules
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from mathics.core.expression import Expression, Symbol
# from mathics.core.util import subsets, subranges, permutations
from mathics.core.pattern import Pattern, StopGenerator

"""_tagged_stop_generators = {}

def StopGenerator(tag):
    existing = _tagged_stop_generators.get(tag)
    if existing is not None:
        return existing

    class TaggedStopGenerator(Exception):
        def __init__(self, value=None):
            self.value = value
    TaggedStopGenerator.__name__ = 'TaggedStopGenerator_%s' % tag

    _tagged_stop_generators[tag] = TaggedStopGenerator
    return TaggedStopGenerator"""


class StopGenerator_BaseRule(StopGenerator):
    pass


class BaseRule(object):
    def __init__(self, pattern, system=False):
        super(BaseRule, self).__init__()
        self.pattern = Pattern.create(pattern)
        self.system = system

    def apply(self, expression, evaluation, fully=True, return_list=False,
              max_list=None):
        result_list = []
        # count = 0

        if return_list and max_list is not None and max_list <= 0:
            return []

        def yield_match(vars, rest):
            # print "Yield match %s" % vars
            if rest is None:
                rest = ([], [])
            if 0 < len(rest[0]) + len(rest[1]) == len(expression.get_leaves()):
                # continue
                return
            options = {}
            for name, value in vars.items():
                if name.startswith('_option_'):
                    options[name[len('_option_'):]] = value
                    del vars[name]
            # print sorted((name.encode('utf-8'),
            # unicode(value).encode('utf-8')) for name, value in
            # vars.iteritems())
            new_expression = self.do_replace(vars, options, evaluation)
            if new_expression is None:
                new_expression = expression
            if rest[0] or rest[1]:
                result = Expression(expression.get_head(), *(
                    rest[0] + [new_expression] + rest[1]))
            else:
                result = new_expression
            # Flatten out sequences (important for Rule itself!)

            def flatten(expr):
                new_expr = expr.flatten(Symbol('Sequence'), pattern_only=True)
                if not new_expr.is_atom():
                    for index, leaf in enumerate(new_expr.leaves):
                        new_expr.leaves[index] = flatten(leaf)
                if hasattr(expr, 'options'):
                    new_expr.options = expr.options
                return new_expr

            # print "Flatten"
            result = flatten(result)
            # print "Flattened"
            if return_list:
                result_list.append(result)
                # count += 1
                if max_list is not None and len(result_list) >= max_list:
                    # return result_list
                    raise StopGenerator_BaseRule(result_list)
            else:
                # return result
                # print "Return %s" % result
                # raise StopGenerator("BaseRule_apply")(result)
                # exc = ValueError()
                # exc.value = result
                # print "raise"
                # raise exc
                raise StopGenerator_BaseRule(result)

                # only first possibility counts

        try:
            self.pattern.match(
                yield_match, expression, {}, evaluation, fully=fully)
        # except StopGenerator("BaseRule_apply"), exc:
        except StopGenerator_BaseRule, exc:
            # print "exc"
            # print "Apply %s -> %s" % (self, exc.value)
            return exc.value

        if return_list:
            return result_list
        else:
            return None

    def __cmp__(self, other):
        if other is None:
            # None is not equal to any rule
            return -1
        return cmp((self.system, self.pattern.get_sort_key(True)),
                   (other.system, other.pattern.get_sort_key(True)))


class Rule(BaseRule):
    def __init__(self, pattern, replace, system=False):
        super(Rule, self).__init__(pattern, system=system)
        self.replace = replace

    def do_replace(self, vars, options, evaluation):
        new = self.replace.replace_vars(vars)
        new.options = options
        return new

    def __repr__(self):
        return (u'<Rule: %s -> %s>' % (self.pattern, self.replace)).encode(
            'unicode_escape')


class BuiltinRule(BaseRule):
    def __init__(self, pattern, function, system=False):
        super(BuiltinRule, self).__init__(pattern, system=system)
        self.function = function

    def do_replace(self, vars, options, evaluation):
        if options:
            return self.function(
                evaluation=evaluation, options=options, **vars)
        else:
            return self.function(evaluation=evaluation, **vars)

    def __repr__(self):
        s = u'<BuiltinRule: %s -> %s>' % (self.pattern, self.function)
        return s.encode('unicode_escape')

    def __getstate__(self):
        odict = self.__dict__.copy()
        del odict['function']
        odict['function_'] = (
            self.function.im_self.get_name(), self.function.__name__)
        return odict

    def __setstate__(self, dict):
        from mathics.builtin import builtins

        self.__dict__.update(dict)   # update attributes
        cls, name = dict['function_']

        self.function = getattr(builtins[cls], name)

########NEW FILE########
__FILENAME__ = util
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import re

FORMAT_RE = re.compile(r'\`(\d*)\`')


def interpolate_string(text, get_param):
    index = [1]

    def get_item(index):
        if 1 <= index <= len(args):
            return args[index - 1]
        else:
            return ''

    if isinstance(get_param, list):
        args = get_param
        get_param = get_item

    def repl(match):
        arg = match.group(1)
        if arg == '' or arg == '0':
            arg = index[0]
        else:
            arg = int(arg)
        index[0] += 1
        param = get_param(arg)
        return param
    return FORMAT_RE.sub(repl, text)

"""
NOTE: Maybe see
http://www.cosc.canterbury.ac.nz/tad.takaoka/isaac.pdf
resp.
http://www.cosc.canterbury.ac.nz/tad.takaoka/perm.p
for a permutation generating algorithm for multisets.
"""


def permutations(items, without_duplicates=True):
    if not items:
        yield []
    # already_taken = set()
    # first yield identical permutation without recursion
    yield items
    for index in range(len(items)):
        item = items[index]
        # if item not in already_taken:
        for sub in permutations(items[:index] + items[index + 1:]):
            yield [item] + sub
            # already_taken.add(item)


def subsets(items, min, max, included=None, less_first=False):
    if max is None:
        max = len(items)
    lengths = range(min, max + 1)
    if not less_first:
        lengths = reversed(lengths)
    lengths = list(lengths)
    if lengths and lengths[0] == 0:
        lengths = lengths[1:] + [0]

    def decide(chosen, not_chosen, rest, count):
        if count < 0 or len(rest) < count:
            return
        if count == 0:
            yield chosen, not_chosen + rest
        elif len(rest) == count:
            if included is None or all(item in included for item in rest):
                yield chosen + rest, not_chosen
        elif rest:
            item = rest[0]
            if included is None or item in included:
                for set in decide(chosen + [item], not_chosen, rest[1:],
                                  count - 1):
                    yield set
            for set in decide(chosen, not_chosen + [item], rest[1:], count):
                yield set

    for length in lengths:
        for chosen, not_chosen in decide([], [], items, length):
            yield chosen, ([], not_chosen)


def subsets_2(items, min, max, without_duplicates=True):
    """ max may only be 1 or None (= infinity).
    Respects include property of items
    """

    if min <= max == 1:
        for index in range(len(items)):
            if items[index].include:
                yield [items[index]], ([], items[:index] + items[index + 1:])
        if min == 0:
            yield [], ([], items)
    else:
        counts = {}
        for item in items:
            if item.include:
                if item in counts:
                    counts[item] += 1
                else:
                    counts[item] = 1
        already = set()

        def decide(chosen, not_chosen, rest):
            if not rest:
                if len(chosen) >= min:
                    """if False and len(chosen) > 1 and (
                            permutate_until is None or
                            len(chosen) <= permutate_until):
                        for perm in permutations(chosen):
                            yield perm, ([], not_chosen)
                    else:"""
                    yield chosen, ([], not_chosen)
            else:
                if rest[0].include:
                    for set in decide(chosen + [rest[0]], not_chosen,
                                      rest[1:]):
                        yield set
                for set in decide(chosen, not_chosen + [rest[0]], rest[1:]):
                    yield set
        for subset in decide([], [], counts.keys()):
            t = tuple(subset[0])
            if t not in already:
                yield subset
                already.add(t)
            else:
                print 'already taken'


def subranges(items, min_count, max, flexible_start=False, included=None,
              less_first=False):
    # TODO: take into account included

    if max is None:
        max = len(items)
    max = min(max, len(items))
    if flexible_start:
        starts = range(len(items) - max + 1)
    else:
        starts = (0,)
    for start in starts:
        lengths = range(min_count, max + 1)
        if not less_first:
            lengths = reversed(lengths)
        lengths = list(lengths)
        if lengths == [0, 1]:
            lengths = [1, 0]
        for length in lengths:
            yield (items[start:start + length],
                   (items[:start], items[start + length:]))


def unicode_superscript(value):
    def repl_char(c):
        if c == '1':
            value = 185
        elif c == '2':
            value = 178
        elif c == '3':
            value = 179
        elif '0' <= c <= '9':
            value = 8304 + (ord(c) - ord('0'))
        elif c == '-':
            value = 8315
        elif c == '(':
            value = 8317
        elif c == ')':
            value = 8318
        else:
            value = ord(c)
        return unichr(value)
    return u''.join(repl_char(c) for c in value)

########NEW FILE########
__FILENAME__ = doc
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from __future__ import with_statement

import re
from os import listdir, path
import pickle

from django.utils.html import escape, linebreaks
from django.template.defaultfilters import slugify
from django.utils.safestring import mark_safe

from mathics import settings

from mathics import builtin
from mathics.builtin import get_module_doc
from mathics.core.evaluation import Message, Print

CHAPTER_RE = re.compile('(?s)<chapter title="(.*?)">(.*?)</chapter>')
SECTION_RE = re.compile('(?s)(.*?)<section title="(.*?)">(.*?)</section>')
SUBSECTION_RE = re.compile('(?s)<subsection title="(.*?)">')
SUBSECTION_END_RE = re.compile('</subsection>')

TESTCASE_RE = re.compile(r'''(?mx)^
    ((?:.|\n)*?)
    ^\s*(>|\#)>[ ](.*)
    ((?:\n\s*(?:[:|=.][ ]|\.).*)*)
''')
TESTCASE_OUT_RE = re.compile(r'^\s*([:|=])(.*)$')

MATHICS_RE = re.compile(r"(?<!\\)\'(.*?)(?<!\\)\'")
LATEX_RE = re.compile(r"(\s?)\$(\w+?)\$(\s?)")
                      # preserve space before and after inline code variables
DL_RE = re.compile(r"(?s)<dl>(.*?)</dl>")
DL_ITEM_RE = re.compile(
    r"(?s)<dt>(.*?)(?:</dt>|)?\s*<dd>(.*?)(?:</dd>|(?=<dt>)|$)")
LIST_RE = re.compile(r"(?s)<(?P<tag>ul|ol)>(?P<content>.*?)</(?P=tag)>")
LIST_ITEM_RE = re.compile(r"(?s)<li>(.*?)(?:</li>|(?=<li>)|$)")
CONSOLE_RE = re.compile(
    r"(?s)<(?P<tag>con|console)>(?P<content>.*?)</(?P=tag)>")
IMG_RE = re.compile(
    r'<img src="(?P<src>.*?)" title="(?P<title>.*?)" label="(?P<label>.*?)">')
REF_RE = re.compile(r'<ref label="(?P<label>.*?)">')
PYTHON_RE = re.compile(r'(?s)<python>(.*?)</python>')
LATEX_CHAR_RE = re.compile(r"(?<!\\)(\^)")

QUOTATIONS_RE = re.compile(r'\"([\w\s,]*?)\"')
HYPERTEXT_RE = re.compile(r"(?s)<(?P<tag>em|url)>(?P<content>.*?)</(?P=tag)>")

OUTSIDE_ASY_RE = re.compile(r"(?s)((?:^|\\end\{asy\}).*?(?:$|\\begin\{asy\}))")
LATEX_TEXT_RE = re.compile(
    r"(?s)\\text\{([^{}]*?(?:[^{}]*?\{[^{}]*?(?:[^{}]*?\{[^{}]*?\}[^{}]*?)*?"
    r"[^{}]*?\}[^{}]*?)*?[^{}]*?)\}")
LATEX_TESTOUT_RE = re.compile(
    r"(?s)\\begin\{(?P<tag>testmessage|testprint|testresult)\}"
    r"(?P<content>.*?)\\end\{(?P=tag)\}")
LATEX_TESTOUT_DELIM_RE = re.compile(r',')
NUMBER_RE = re.compile(r'(\d*(?<!\.)\.\d+|\d+\.(?!\.)\d*|\d+)')
LATEX_ARRAY_RE = re.compile(
    r'(?s)\\begin\{testresult\}\\begin\{array\}\{l\}(.*?)'
    r'\\end\{array\}\\end\{testresult\}')
LATEX_INLINE_END_RE = re.compile(r"(?s)(?P<all>\\lstinline'[^']*?'\}?[.,;:])")
LATEX_CONSOLE_RE = re.compile(r"\\console\{(.*?)\}")

ALLOWED_TAGS = ('dl', 'dd', 'dt', 'em', 'url', 'ul',
                'ol', 'li', 'con', 'console', 'img', 'ref', 'subsection')
ALLOWED_TAGS_RE = dict((allowed, re.compile(
    '&lt;(%s.*?)&gt;' % allowed)) for allowed in ALLOWED_TAGS)

SPECIAL_COMMANDS = {
    'LaTeX': (r'<em>LaTeX</em>', r'\LaTeX{}'),
    'Mathematica': (r'<em>Mathematica</em>&reg;',
                    r'\emph{Mathematica}\textregistered{}'),
    'Mathics': (r'<em>Mathics</em>', r'\emph{Mathics}'),
    'Sage': (r'<em>Sage</em>', r'\emph{Sage}'),
    'Wolfram': (r'<em>Wolfram</em>', r'\emph{Wolfram}'),

    'skip': (r'<br /><br />', r'\bigskip'),
}

try:
    with open(settings.DOC_XML_DATA, 'r') as xml_data_file:
        xml_data = pickle.load(xml_data_file)
except IOError:
    xml_data = {}


def filter_comments(doc):
    return u'\n'.join(line for line in doc.splitlines()
                      if not line.lstrip().startswith('##'))


def get_latex_escape_char(text):
    for escape_char in ("'", '~', '@'):
        if escape_char not in text:
            return escape_char
    raise ValueError


def _replace_all(text, pairs):
    for (i, j) in pairs:
        text = text.replace(i, j)
    return text


def escape_latex_output(text):
    " Escape Mathics output "

    text = _replace_all(text, [('\\', '\\\\'), ('{', '\\{'), ('}', '\\}'),
                               ('~', '\\~'), ('&', '\\&'), ('%', '\\%'),
                               ('$', r'\$')])
    return text


def escape_latex_code(text):
    " Escape verbatim Mathics input "

    text = escape_latex_output(text)
    escape_char = get_latex_escape_char(text)
    return u'\\lstinline%s%s%s' % (escape_char, text, escape_char)


def escape_latex(text):
    " Escape documentation text "

    def repl_python(match):
        return r"""\begin{lstlisting}[style=python]
%s
\end{lstlisting}""" % match.group(1).strip()
    text, post_substitutions = pre_sub(PYTHON_RE, text, repl_python)

    text = _replace_all(text, [('\\', '\\\\'), ('{', '\\{'), ('}', '\\}'),
                               ('~', '\\~{ }'), ('&', '\\&'), ('%', '\\%')])

    def repl(match):
        text = match.group(1)
        if text:
            text = _replace_all(text, [("\\'", "'"), ('^', '\\^')])
            escape_char = get_latex_escape_char(text)
            text = LATEX_RE.sub(
                lambda m: u"%s%s\\codevar{\\textit{%s}}%s\\lstinline%s" % (
                    escape_char, m.group(1), m.group(2), m.group(3),
                    escape_char),
                text)
            if text.startswith(' '):
                text = r'\ ' + text[1:]
            if text.endswith(' '):
                text = text[:-1] + r'\ '
            return u"\\code{\\lstinline%s%s%s}" % (
                escape_char, text, escape_char)
        else:
            # treat double '' literaly
            return "''"

    text = MATHICS_RE.sub(repl, text)

    text = LATEX_RE.sub(lambda m: u'%s\\textit{%s}%s' % (
        m.group(1), m.group(2), m.group(3)), text)

    text = text.replace("\\\\'", "'")

    def repl_dl(match):
        text = match.group(1)
        text = DL_ITEM_RE.sub(lambda m: u'\\dt{%s}\n\\dd{%s}' % (
            m.group(1), m.group(2)), text)
        return u'\\begin{definitions}%s\\end{definitions}' % text
    text = DL_RE.sub(repl_dl, text)

    def repl_list(match):
        tag = match.group('tag')
        content = match.group('content')
        content = LIST_ITEM_RE.sub(
            lambda m: u'\\item %s\n' % m.group(1), content)
        env = 'itemize' if tag == 'ul' else 'enumerate'
        return u'\\begin{%s}%s\\end{%s}' % (env, content, env)
    text = LIST_RE.sub(repl_list, text)

    text = _replace_all(text, [('$', r'\$'), (u'\u03c0', '$\pi$')])

    def repl_char(match):
        char = match.group(1)
        return {
            '^': '$^\wedge$',
        }[char]
    text = LATEX_CHAR_RE.sub(repl_char, text)

    def repl_img(match):
        src = match.group('src')
        title = match.group('title')
        label = match.group('label')
        return r"""\begin{figure*}[htp]
\centering
\includegraphics[width=\textwidth]{images/%(src)s}
\caption{%(title)s}
\label{%(label)s}
\end{figure*}""" % {
            'src': src,
            'title': title,
            'label': label,
        }
    text = IMG_RE.sub(repl_img, text)

    def repl_ref(match):
        return r'figure \ref{%s}' % match.group('label')
    text = REF_RE.sub(repl_ref, text)

    def repl_quotation(match):
        return r"``%s''" % match.group(1)

    def repl_hypertext(match):
        tag = match.group('tag')
        content = match.group('content')
        if tag == 'em':
            return r'\emph{%s}' % content
        elif tag == 'url':
            return r'\url{%s}' % content

    text = QUOTATIONS_RE.sub(repl_quotation, text)
    text = HYPERTEXT_RE.sub(repl_hypertext, text)

    def repl_console(match):
        tag = match.group('tag')
        content = match.group('content')
        content = content.strip()
        content = content.replace(r'\$', '$')
        if tag == 'con':
            return '\\console{%s}' % content
        else:
            return '\\begin{lstlisting}\n%s\n\\end{lstlisting}' % content
    text = CONSOLE_RE.sub(repl_console, text)

    '''def repl_asy(match):
        """
        Ensure \begin{asy} and \end{asy} are on their own line,
        but there shall be no extra empty lines
        """
        #tag = match.group(1)
        #return '\n%s\n' % tag
        #print "replace"
        return '\\end{asy}\n\\begin{asy}'
    text = LATEX_BETWEEN_ASY_RE.sub(repl_asy, text)'''

    def repl_subsection(match):
        return '\n\\subsection*{%s}\n' % match.group(1)
    text = SUBSECTION_RE.sub(repl_subsection, text)
    text = SUBSECTION_END_RE.sub('', text)

    for key, (xml, tex) in SPECIAL_COMMANDS.iteritems():
        # "\" has been escaped already => 2 \
        text = text.replace('\\\\' + key, tex)

    text = post_sub(text, post_substitutions)

    return text


def post_process_latex(result):
    """
    Some post-processing hacks of generated LaTeX code to handle linebreaks
    """

    WORD_SPLIT_RE = re.compile(r'(\s+|\\newline\s*)')

    def wrap_word(word):
        if word.strip() == r'\newline':
            return word
        return r'\text{%s}' % word

    def repl_text(match):
        text = match.group(1)
        if not text:
            return r'\text{}'
        words = WORD_SPLIT_RE.split(text)
        assert len(words) >= 1
        if len(words) > 1:
            text = ""
            index = 0
            while index < len(words) - 1:
                text += '%s%s\\allowbreak{}' % (wrap_word(
                    words[index]), wrap_word(words[index + 1]))
                index += 2
            text += wrap_word(words[-1])
        else:
            text = r'\text{%s}' % words[0]
        if not text:
            return r'\text{}'
        text = text.replace('><', r'>}\allowbreak\text{<')
        return text

    def repl_out_delim(match):
        return ',\\allowbreak{}'

    def repl_number(match):
        guard = r'\allowbreak{}'
        inter_groups_pre = r'\,\discretionary{\~{}}{\~{}}{}'
        inter_groups_post = r'\discretionary{\~{}}{\~{}}{}'
        number = match.group(1)
        parts = number.split('.')
        if len(number) <= 3:
            return number
        assert 1 <= len(parts) <= 2
        pre_dec = parts[0]
        groups = []
        while pre_dec:
            groups.append(pre_dec[-3:])
            pre_dec = pre_dec[:-3]
        pre_dec = inter_groups_pre.join(reversed(groups))
        if len(parts) == 2:
            post_dec = parts[1]
            groups = []
            while post_dec:
                groups.append(post_dec[:3])
                post_dec = post_dec[3:]
            post_dec = inter_groups_post.join(groups)
            result = pre_dec + '.' + post_dec
        else:
            result = pre_dec
        return guard + result + guard

    def repl_array(match):
        content = match.group(1)
        lines = content.split('\\\\')
        content = ''.join(r'\begin{dmath*}%s\end{dmath*}' %
                          line for line in lines if line.strip())
        return r'\begin{testresultlist}%s\end{testresultlist}' % content

    def repl_out(match):
        tag = match.group('tag')
        content = match.group('content')
        content = LATEX_TESTOUT_DELIM_RE.sub(repl_out_delim, content)
        content = NUMBER_RE.sub(repl_number, content)
        content = content.replace(r'\left[', r'\left[\allowbreak{}')
        return '\\begin{%s}%s\\end{%s}' % (tag, content, tag)

    def repl_inline_end(match):
        " Prevent linebreaks between inline code and sentence delimeters "

        code = match.group('all')
        if code[-2] == '}':
            code = code[:-2] + code[-1] + code[-2]
        return r'\mbox{%s}' % code

    def repl_console(match):
        code = match.group(1)
        code = code.replace('/', r'/\allowbreak{}')
        return r'\console{%s}' % code

    def repl_nonasy(match):
        result = match.group(1)
        result = LATEX_TEXT_RE.sub(repl_text, result)
        result = LATEX_TESTOUT_RE.sub(repl_out, result)
        result = LATEX_ARRAY_RE.sub(repl_array, result)
        result = LATEX_INLINE_END_RE.sub(repl_inline_end, result)
        result = LATEX_CONSOLE_RE.sub(repl_console, result)
        return result

    return OUTSIDE_ASY_RE.sub(repl_nonasy, result)

POST_SUBSTITUTION_TAG = '_POST_SUBSTITUTION%d_'


def pre_sub(re, text, repl_func):
    post_substitutions = []

    def repl_pre(match):
        repl = repl_func(match)
        index = len(post_substitutions)
        post_substitutions.append(repl)
        return POST_SUBSTITUTION_TAG % index

    text = re.sub(repl_pre, text)

    return text, post_substitutions


def post_sub(text, post_substitutions):
    for index, sub in enumerate(post_substitutions):
        text = text.replace(POST_SUBSTITUTION_TAG % index, sub)
    return text


def escape_html(text, verbatim_mode=False, counters=None, single_line=False):
    def repl_python(match):
        return r"""<pre><![CDATA[
%s
]]></pre>""" % match.group(1).strip()
    text, post_substitutions = pre_sub(PYTHON_RE, text, repl_python)

    text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

    if not verbatim_mode:
        def repl_quotation(match):
            return r"&ldquo;%s&rdquo;" % match.group(1)
        text = QUOTATIONS_RE.sub(repl_quotation, text)

    if counters is None:
        counters = {}

    text = text.replace('"', '&quot;')
    if not verbatim_mode:
        def repl_latex(match):
            return '%s<var>%s</var>%s' % (
                match.group(1), match.group(2), match.group(3))

        text = LATEX_RE.sub(repl_latex, text)

        def repl_mathics(match):
            text = match.group(1)
            text = text.replace("\\'", "'")
            text = text.replace(' ', '&nbsp;')
            if text:
                return "<code>%s</code>" % text
            else:
                return "'"

        def repl_allowed(match):
            content = _replace_all(match.group(1), [
                ('&ldquo;', '"'), ('&rdquo;', '"'), ('&quot;', '"')])
            return '<%s>' % content

        text = MATHICS_RE.sub(repl_mathics, text)
        for allowed in ALLOWED_TAGS:
            text = ALLOWED_TAGS_RE[allowed].sub(repl_allowed, text)
            text = text.replace('&lt;/%s&gt;' % allowed, '</%s>' % allowed)

        def repl_dl(match):
            text = match.group(1)
            text = DL_ITEM_RE.sub(lambda m: '<dt>%s</dt>\n<dd>%s</dd>' % (
                m.group(1), m.group(2)), text)
            return '<dl>%s</dl>' % text

        text = DL_RE.sub(repl_dl, text)

        def repl_list(match):
            tag = match.group('tag')
            content = match.group('content')
            content = LIST_ITEM_RE.sub(
                lambda m: u'<li>%s</li>' % m.group(1), content)
            return u'<%s>%s</%s>' % (tag, content, tag)

        text = LIST_RE.sub(repl_list, text)

        def repl_hypertext(match):
            tag = match.group('tag')
            content = match.group('content')
            if tag == 'em':
                return r'<em>%s</em>' % content
            elif tag == 'url':
                return r'<a href="%s">%s</a>' % (content, content)

        text = HYPERTEXT_RE.sub(repl_hypertext, text)

        def repl_console(match):
            tag = match.group('tag')
            content = match.group('content')
            tag = 'div' if tag == 'console' else 'span'
            content = content.strip()
            pre = post = ''

            # gets replaced for <br /> later by DocText.html()
            content = content.replace('\n', '<br>')

            return r'<%s class="console">%s%s%s</%s>' % (
                tag, pre, content, post, tag)

        text = CONSOLE_RE.sub(repl_console, text)

        def repl_img(match):
            src = match.group('src')
            title = match.group('title')
            return (r'<a href="/media/doc/%(src)s.pdf">'
                    r'<img src="/media/doc/%(src)s.png" title="%(title)s" />'
                    r'</a>') % {'src': src, 'title': title}
        text = IMG_RE.sub(repl_img, text)

        def repl_ref(match):
            # TODO: this is not an optimal solution - maybe we need figure
            # numbers in the XML doc as well?
            return r'the following figure'
        text = REF_RE.sub(repl_ref, text)

        def repl_subsection(match):
            return '\n<h2>%s</h2>\n' % match.group(1)
        text = SUBSECTION_RE.sub(repl_subsection, text)
        text = SUBSECTION_END_RE.sub('', text)

        text = text.replace("\\'", "'")
    else:
        text = text.replace(' ', '&nbsp;')
        text = '<code>%s</code>' % text
    text = text.replace("'", '&#39;')
    text = text.replace('---', '&mdash;')
    for key, (xml, tex) in SPECIAL_COMMANDS.iteritems():
        text = text.replace('\\' + key, xml)

    if not single_line:
        text = linebreaks(text)
        text = text.replace('<br />', '\n').replace('<br>', '<br />')

    text = post_sub(text, post_substitutions)

    text = text.replace('<p><pre>', '<pre>').replace('</pre></p>', '</pre>')

    return text


class Tests(object):
    def __init__(self, part, chapter, section, tests):
        self.part, self.chapter = part, chapter
        self.section, self.tests = section, tests


class DocElement(object):
    def href(self, ajax=False):
        if ajax:
            return "javascript:loadDoc('%s')" % self.get_url()
        else:
            return "/doc%s" % self.get_url()

    def get_prev(self):
        return self.get_prev_next()[0]

    def get_next(self):
        return self.get_prev_next()[1]

    def get_collection(self):
        return []

    def get_prev_next(self):
        collection = self.get_collection()
        index = collection.index(self)
        prev = collection[index - 1] if index > 0 else None
        next = collection[index + 1] if index < len(collection) - 1 else None
        return prev, next

    def get_title_html(self):
        return mark_safe(escape_html(self.title, single_line=True))


class Documentation(DocElement):
    def __init__(self):
        self.title = "Overview"
        self.parts = []
        self.parts_by_slug = {}
        dir = settings.DOC_DIR
        files = listdir(dir)
        files.sort()
        appendix = []
        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(dir + file, 'r').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        for title, modules, builtins_by_module, start in [(     # nopep8
            "Reference of built-in symbols", builtin.modules,
            builtin.builtins_by_module, True)]:
            #("Reference of optional symbols", optional.modules,
            # optional.optional_builtins_by_module, False)]:
            builtin_part = DocPart(self, title, is_reference=start)
            for module in modules:
                title, text = get_module_doc(module)
                chapter = DocChapter(builtin_part, title, Doc(text))
                builtins = builtins_by_module[module.__name__]
                for instance in builtins:
                    section = DocSection(
                        chapter, instance.get_name(), instance.__doc__ or '',
                        operator=instance.get_operator())
                    chapter.sections.append(section)
                builtin_part.chapters.append(chapter)
            self.parts.append(builtin_part)

        for part in appendix:
            self.parts.append(part)

        # set keys of tests
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)

    def __str__(self):
        return '\n\n\n'.join(str(part) for part in self.parts)

    def get_tests(self):
        for part in self.parts:
            for chapter in part.chapters:
                tests = chapter.doc.get_tests()
                if tests:
                    yield Tests(part.title, chapter.title, '', tests)
                for section in chapter.sections:
                    tests = section.doc.get_tests()
                    if tests:
                        yield Tests(
                            part.title, chapter.title, section.title, tests)

    def get_part(self, part_slug):
        return self.parts_by_slug.get(part_slug)

    def get_chapter(self, part_slug, chapter_slug):
        part = self.parts_by_slug.get(part_slug)
        if part:
            return part.chapters_by_slug.get(chapter_slug)
        return None
        """for part in self.parts:
            if part.slug == part_slug:
                for chapter in self:
                    pass"""

    def get_section(self, part_slug, chapter_slug, section_slug):
        part = self.parts_by_slug.get(part_slug)
        if part:
            chapter = part.chapters_by_slug.get(chapter_slug)
            if chapter:
                return chapter.sections_by_slug.get(section_slug)
        return None

    def latex(self, output):
        parts = []
        appendix = False
        for part in self.parts:
            text = part.latex(output)
            if part.is_appendix and not appendix:
                appendix = True
                text = '\n\\appendix\n' + text
            parts.append(text)
        result = '\n\n'.join(parts)
        result = post_process_latex(result)
        return result

    def get_url(self):
        return '/'

    def search(self, query):
        query = query.strip()
        query_parts = [q.strip().lower() for q in query.split()]

        def matches(text):
            text = text.lower()
            return all(q in text for q in query_parts)

        result = []
        for part in self.parts:
            if matches(part.title):
                result.append((False, part))
            for chapter in part.chapters:
                if matches(chapter.title):
                    result.append((False, chapter))
                for section in chapter.sections:
                    if matches(section.title):
                        result.append((section.title == query, section))
                    elif query == section.operator:
                        result.append((True, section))
        return result


class DocPart(DocElement):
    def __init__(self, doc, title, is_reference=False):
        self.doc = doc
        self.title = title
        self.slug = slugify(title)
        self.chapters = []
        self.chapters_by_slug = {}
        self.is_reference = is_reference
        self.is_appendix = False
        doc.parts_by_slug[self.slug] = self

    def __str__(self):
        return '%s\n\n%s' % (
            self.title, '\n'.join(str(chapter) for chapter in self.chapters))

    def latex(self, output):
        result = '\n\n\\part{%s}\n\n' % escape_latex(self.title) + (
            '\n\n'.join(chapter.latex(output) for chapter in self.chapters))
        if self.is_reference:
            result = '\n\n\\referencestart' + result
        return result

    def get_url(self):
        return '/%s/' % self.slug

    def get_collection(self):
        return self.doc.parts


class DocChapter(DocElement):
    def __init__(self, part, title, doc=None):
        self.part = part
        self.title = title
        self.slug = slugify(title)
        self.doc = doc
        self.sections = []
        self.sections_by_slug = {}
        part.chapters_by_slug[self.slug] = self

    def __str__(self):
        return '= %s =\n\n%s' % (
            self.title, '\n'.join(str(section) for section in self.sections))

    def latex(self, output):
        intro = self.doc.latex(output).strip()
        if intro:
            short = 'short' if len(intro) < 300 else ''
            intro = '\\begin{chapterintro%s}\n%s\n\n\\end{chapterintro%s}' % (
                short, intro, short)
        return ''.join([
            '\n\n\\chapter{%(title)s}\n\\chapterstart\n\n%(intro)s' % {
                'title': escape_latex(self.title),
                'intro': intro},
            '\\chaptersections\n',
            '\n\n'.join(
                section.latex(output) for section in self.sections),
            '\n\\chapterend\n'])

    def get_url(self):
        return '/%s/%s/' % (self.part.slug, self.slug)

    def get_collection(self):
        return self.part.chapters


class DocSection(DocElement):
    def __init__(self, chapter, title, text, operator=None):
        self.chapter = chapter
        self.title = title
        self.slug = slugify(title)
        if text.count("<dl>") != text.count("</dl>"):
            raise ValueError("Missing opening or closing <dl> tag in "
                             "{} documentation".format(title))
        self.doc = Doc(text)
        self.operator = operator
        chapter.sections_by_slug[self.slug] = self

    def __str__(self):
        return '== %s ==\n%s' % (self.title, self.doc)

    def latex(self, output):
        title = escape_latex(self.title)
        if self.operator:
            title += " (\\code{%s})" % escape_latex_code(self.operator)
        index = '\index{%s}' % escape_latex(
            self.title) if self.chapter.part.is_reference else ''
        return (
            '\n\n\\section*{%(title)s}%(index)s\n'
            '\\sectionstart\n\n%(content)s\\sectionend'
            '\\addcontentsline{toc}{section}{%(title)s}') % {
                'title': title,
                'index': index,
                'content': self.doc.latex(output)}

    def get_url(self):
        return '/%s/%s/%s/' % (
            self.chapter.part.slug, self.chapter.slug, self.slug)

    def get_collection(self):
        return self.chapter.sections

    def html_data(self):
        indices = set()
        for test in self.doc.items:
            indices.update(test.test_indices())
        result = {}
        for index in indices:
            result[index] = xml_data.get((
                self.chapter.part.title, self.chapter.title, self.title,
                index))
        return result


class Doc(object):
    def __init__(self, doc):
        self.items = []
        # remove commented lines
        doc = filter_comments(doc)
        # pre-substitute Python code because it might contain tests
        doc, post_substitutions = pre_sub(
            PYTHON_RE, doc, lambda m: u'<python>%s</python>' % m.group(1))
        # HACK: Artificially construct a last testcase to get the "intertext"
        # after the last (real) testcase. Ignore the test, of course.
        doc += '\n>> test\n = test'
        testcases = TESTCASE_RE.findall(doc)
        tests = None
        for index in range(len(testcases)):
            testcase = list(testcases[index])
            text = testcase.pop(0).strip()
            if text:
                if tests is not None:
                    self.items.append(tests)
                    tests = None
                text = post_sub(text, post_substitutions)
                self.items.append(DocText(text))
                tests = None
            if index < len(testcases) - 1:
                test = DocTest(index, testcase)
                if tests is None:
                    tests = DocTests()
                tests.tests.append(test)
            if tests is not None:
                self.items.append(tests)
                tests = None

    def __str__(self):
        return '\n'.join(str(item) for item in self.items)

    def get_tests(self):
        tests = []
        for item in self.items:
            tests.extend(item.get_tests())
        return tests

    def latex(self, output):
        return '\n'.join(item.latex(output) for item in self.items
                         if not item.is_private())

    def html(self):
        counters = {}
        return mark_safe('\n'.join(item.html(counters) for item in self.items
                         if not item.is_private()))


class DocText(object):
    def __init__(self, text):
        self.text = text

    def get_tests(self):
        return []

    def is_private(self):
        return False

    def __str__(self):
        return self.text

    def latex(self, output):
        return escape_latex(self.text)

    def html(self, counters=None):
        result = escape_html(self.text, counters=counters)
        return result

    def test_indices(self):
        return []


class DocTests(object):
    def __init__(self):
        self.tests = []

    def get_tests(self):
        return self.tests

    def is_private(self):
        return all(test.private for test in self.tests)

    def __str__(self):
        return '\n'.join(str(test) for test in self.tests)

    def latex(self, output):
        return '\\begin{tests}%%\n%s%%\n\\end{tests}' % (
            '%\n'.join(test.latex(output) for test in self.tests
            if not test.private))

    def html(self, counters=None):
        return '<ul class="tests">%s</ul>' % (
            '\n'.join('<li>%s</li>' % test.html() for test in self.tests
            if not test.private))

    def test_indices(self):
        return [test.index for test in self.tests]


class DocTest(object):
    def __init__(self, index, testcase):
        self.index = index
        self.test = testcase[1].strip()
        self.result = None
        self.outs = []
        self.private = testcase[0] == '#'
        self.key = None
        outs = testcase[2].splitlines()
        for line in outs:
            line = line.strip()
            if line:
                if line.startswith('.'):
                    text = line[1:]
                    if text.startswith(' '):
                        text = text[1:]
                    text = '\n' + text
                    if self.result is not None:
                        self.result += text
                    elif self.outs:
                        self.outs[-1] += text
                    continue

                match = TESTCASE_OUT_RE.match(line)
                symbol, text = match.group(1), match.group(2)
                text = text.strip()
                if symbol == '=':
                    self.result = text
                elif text:
                    if symbol == ':':
                        out = Message('', '', text)
                    elif symbol == '|':
                        out = Print(text)
                    self.outs.append(out)

    def __str__(self):
        return self.test

    def latex(self, output):
        text = u''
        text += u"\\begin{testcase}\n"
        text += u"\\test{%s}\n" % escape_latex_code(self.test)
        if self.key is None:
            return ''
        results = output[self.key]['results']
        for result in results:
            for out in result['out']:
                kind = 'message' if out['message'] else 'print'
                text += u"\\begin{test%s}%s\\end{test%s}" % (
                    kind, out['text'], kind)
            if result['result']:  # is not None and result['result'].strip():
                text += u"\\begin{testresult}%s\\end{testresult}" % result[
                    'result']
        text += "\\end{testcase}"
        return text

    def html(self):
        result = '<div class="test"><span class="move"></span>'
        result += '<ul class="test" id="test_%d">' % self.index
        result += '<li class="test">%s</li>' % escape_html(self.test, True)
        result += '</ul>'
        result += '</div>'
        return result

########NEW FILE########
__FILENAME__ = main
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import os
import argparse
import re
import locale

from mathics.core.definitions import Definitions
from mathics.core.expression import Integer
from mathics.core.evaluation import Evaluation
from mathics import print_version, print_license, get_version_string
from mathics import settings


class TerminalShell(object):
    def __init__(self, definitions, colors):
        self.input_encoding = locale.getpreferredencoding()

        # Try importing readline to enable arrow keys support etc.
        self.using_readline = False
        try:
            import readline
            self.using_readline = sys.stdin.isatty() and sys.stdout.isatty()
            self.ansi_color_re = re.compile("\033\\[[0-9;]+m")
        except ImportError:
            pass

        # Try importing colorama to escape ansi sequences for cross platform
        # colors
        try:
            from colorama import init as colorama_init
        except ImportError:
            colors = 'NoColor'
        else:
            colorama_init()
            if colors is None:
                terminal_supports_color = (sys.stdout.isatty() and
                                           os.getenv('TERM') != 'dumb')
                colors = 'Linux' if terminal_supports_color else 'NoColor'

        color_schemes = {
            'NOCOLOR': (
                ['', '', '', ''],
                ['', '', '', '']),
            'LINUX': (
                ['\033[32m', '\033[1m', '\033[22m', '\033[39m'],
                ['\033[31m', '\033[1m', '\033[22m', '\033[39m']),
            'LIGHTBG': (
                ['\033[34m', '\033[1m', '\033[22m', '\033[39m'],
                ['\033[31m', '\033[1m', '\033[22m', '\033[39m']),
        }

        # Handle any case by using .upper()
        term_colors = color_schemes.get(colors.upper())
        if term_colors is None:
            out_msg = "The 'colors' argument must be {0} or None"
            print out_msg.format(repr(color_schemes.keys()))
            quit()

        self.incolors, self.outcolors = term_colors
        self.definitions = definitions

    def get_last_line_number(self):
        line = self.definitions.get_definition('$Line').ownvalues[0].replace
        return line.get_int_value()

    def get_in_prompt(self, continued=False):
        next_line_number = self.get_last_line_number() + 1
        if continued:
            return ' ' * len('In[{0}]:= '.format(next_line_number))
        else:
            return '{1}In[{2}{0}{3}]:= {4}'.format(next_line_number,
                                                   *self.incolors)

    def get_out_prompt(self):
        line_number = self.get_last_line_number()
        return '{1}Out[{2}{0}{3}]= {4}'.format(line_number, *self.outcolors)

    def evaluate(self, text):
        evaluation = Evaluation(text,
                                self.definitions,
                                timeout=settings.TIMEOUT,
                                out_callback=out_callback)
        for result in evaluation.results:
            if result.result is not None:
                print(self.get_out_prompt() +
                      to_output(unicode(result.result)) + '\n')

    def read_line(self, prompt):
        if self.using_readline:
            return self.rl_read_line(prompt)
        return raw_input(prompt)

    def rl_read_line(self, prompt):
        # sys.stdout is wrapped by a codecs.StreamWriter object in
        # mathics/__init__.py, which interferes with raw_input's use
        # of readline.
        #
        # To work around this issue, call raw_input with the original
        # file object as sys.stdout, which is in the undocumented
        # 'stream' field of codecs.StreamWriter.
        orig_stdout = sys.stdout
        try:
            # Wrap ANSI colour sequences in \001 and \002, so readline
            # knows that they're nonprinting.
            prompt = self.ansi_color_re.sub(
                lambda m: "\001" + m.group(0) + "\002", prompt)
            sys.stdout = sys.stdout.stream
            ret = raw_input(prompt)
            return ret
        finally:
            sys.stdout = orig_stdout


def to_output(text):
    return '\n        '.join(text.splitlines())


def out_callback(out):
    print to_output(unicode(out))

# Adapted from code at http://mydezigns.wordpress.com/2009/09/22/balanced-brackets-in-python/       # nopep8


def wait_for_line(input_string):
    """
    Should the intepreter wait for another line of input or try to evaluate the
    current line as is.
    """
    trailing_ops = ['+', '-', '/', '*', '^', '=',
                    '>', '<', '/;', '/:', '/.', '&&', '||']
    if any(input_string.rstrip().endswith(op) for op in trailing_ops):
        return True

    brackets = [('(', ')'), ('[', ']'), ('{', '}')]
    kStart, kEnd, stack = 0, 1, []
    for char in input_string:
        for bracketPair in brackets:
            if char == bracketPair[kStart]:
                stack.append(char)
            elif char == bracketPair[kEnd]:
                if len(stack) == 0:
                    return False
                if stack.pop() != bracketPair[kStart]:
                    # Brackets are not balanced, but return False so that a
                    # parse error can be raised
                    return False
    if len(stack) == 0 and input_string.count('"') % 2 == 0:
        return False
    return True


def main():
    argparser = argparse.ArgumentParser(
        prog='mathics',
        usage='%(prog)s [options] [FILE]',
        add_help=False,
        description="Mathics is a general-purpose computer algebra system.",
        epilog="""Please feel encouraged to contribute to Mathics! Create
            your own fork, make the desired changes, commit, and make a pull
            request.""")

    argparser.add_argument(
        'FILE', nargs='?', type=argparse.FileType('r'),
        help='execute commands from FILE')

    argparser.add_argument(
        '--help', '-h', help='show this help message and exit', action='help')

    argparser.add_argument(
        '--persist', help='go to interactive shell after evaluating FILE',
        action='store_true')

    argparser.add_argument(
        '--quiet', '-q', help='don\'t print message at startup',
        action='store_true')

    argparser.add_argument(
        '-script', help='run a mathics file in script mode',
        action='store_true')

    argparser.add_argument(
        '--execute', '-e', nargs='?', help='execute a command')

    argparser.add_argument(
        '--colors', nargs='?', help='interactive shell colors')

    argparser.add_argument(
        '--version', '-v', action='version', version=get_version_string(False))

    args = argparser.parse_args()

    quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-D'

    definitions = Definitions(add_builtin=True)

    definitions.set_ownvalue('$Line', Integer(0))  # Reset the line number

    shell = TerminalShell(definitions, args.colors)

    if not (args.quiet or args.script):
        print_version(is_server=False)
        print_license()
        print u"Quit by pressing {0}\n".format(quit_command)

    if args.execute:
        total_input = args.execute.decode(shell.input_encoding)
        print shell.get_in_prompt() + total_input
        shell.evaluate(total_input)
        return

    if args.FILE is not None:
        total_input = ''
        for line_no, line in enumerate(args.FILE):
            try:
                line = line.decode('utf-8')     # TODO: other encodings
                if args.script and line_no == 0 and line.startswith('#!'):
                    continue
                print shell.get_in_prompt(continued=total_input != '') + line,
                total_input += ' ' + line
                if line != "" and wait_for_line(total_input):
                    continue
                shell.evaluate(total_input)
                total_input = ""
            except (KeyboardInterrupt):
                print '\nKeyboardInterrupt'
            except (SystemExit, EOFError):
                print "\n\nGood bye!\n"
                break
        if not args.persist:
            return

    total_input = ""
    while True:
        try:
            line = shell.read_line(
                shell.get_in_prompt(continued=total_input != ''))
            line = line.decode(shell.input_encoding)
            total_input += line
            if line != "" and wait_for_line(total_input):
                continue
            shell.evaluate(total_input)
            total_input = ""
        except (KeyboardInterrupt):
            print '\nKeyboardInterrupt'
        except (SystemExit, EOFError):
            print "\n\nGood bye!\n"
            break

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "mathics.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = profile
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import cProfile
import pstats

from mathics.core.definitions import Definitions
from mathics.core.evaluation import Evaluation

definitions = Definitions(add_builtin=True)


def prepare():
    pass

result = None


def run():
    global result
    # prompt = '(1+a)(1+b)(1+c)(1+d)(1+e)//Expand'
    # prompt = 'f/@Range[20000];'
    # prompt = 'Plus @@ Range[50000]'
    # prompt = 'Range[100000];'
    try:
        # prompt = 'SetAttributes[v, Flat]; v[x_]:={x}; v[a,b]'
        # prompt = """(Plus@@Symbol/@CharacterRange["a","z"])^2//Expand;"""
        # prompt = (
        #     'Plus@@f/@Symbol/@StringJoin/@Tuples[CharacterRange["a","z"],2]')
        # prompt = 'FullForm[Nest[1+Sqrt[1+#]&, x, 20]]'
        # prompt = '1+2'
        prompt = 'DensityPlot[x*y,{x,-1,1},{y,-1,1}]'
        evaluation = Evaluation(prompt, definitions, format='xml')
        if evaluation.results:
            result = evaluation.results[0].result
    except KeyboardInterrupt:
        result = 'INTERRUPTED'


def _profile():
    global result
    prepare()
    cProfile.run('run()', 'profile')
    # print 'Result: %s\n' % result
    p = pstats.Stats('profile')
    p.sort_stats('cumulative').print_stats(50)
    p.print_callees(20)

if __name__ == '__main__':
    _profile()

########NEW FILE########
__FILENAME__ = server
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import os
import argparse
import socket
import errno

import mathics
from mathics import print_version, print_license
from mathics import settings as mathics_settings  # Prevents UnboundLocalError


def main():
    # Check for the database
    database_file = mathics_settings.DATABASES['default']['NAME']
    if not os.path.exists(database_file):
        print "Error: Mathics database not found!"
        print "Please change to the mathics install directory and run:\n"
        print "   $> {python} setup.py initialize\n".format(
            python=sys.executable or 'python')
        print "as the current user"
        sys.exit(1)

    os.environ['DJANGO_SETTINGS_MODULE'] = 'mathics.settings'
    # os.putenv('DJANGO_SETTINGS_MODULE', 'mathics.settings')

    from django.conf import settings
    from django.core.servers.basehttp import run
    from django.core.handlers.wsgi import WSGIHandler

    argparser = argparse.ArgumentParser(
        prog='mathicsserver',
        usage='%(prog)s [options]',
        add_help=False,
        description="""Mathics server for the graphical user interface in a
            web browser. It is not intended for production use on a public Web
            server!""",
        epilog="""Please feel encouraged to contribute to Mathics! Create
            your own fork, make the desired changes, commit, and make a pull
            request.""")

    argparser.add_argument(
        '--help', '-h', help='show this help message and exit', action='help')
    argparser.add_argument(
        '--quiet', '-q', help='don\'t print message at startup',
        action='store_true')
    argparser.add_argument(
        '--version', '-v', action='version',
        version='%(prog)s ' + mathics.__version__)
    argparser.add_argument(
        "--port", "-p", dest="port", metavar="PORT", default=8000, type=int,
        help="use PORT as server port")
    argparser.add_argument(
        "--external", "-e", dest="external", action="store_true",
        help="allow external access to server")

    args = argparser.parse_args()

    quit_command = 'CTRL-BREAK' if sys.platform == 'win32' else 'CONTROL-C'
    port = args.port

    if not args.quiet:
        print_version(is_server=True)
        print_license()
        print u"Quit by pressing %s\n" % quit_command

        print u"""Open the graphical user interface at
http://localhost:%d\nin Firefox, Chrome, or Safari to use Mathics\n""" % port

    if args.external:
        addr = '0.0.0.0'
    else:
        addr = '127.0.0.1'

    try:
        if settings.DJANGO_VERSION < (1, 4):
            from django.core.servers.basehttp import AdminMediaHandler
            handler = AdminMediaHandler(WSGIHandler(), '')
        else:
            from django.core.servers.basehttp import (
                get_internal_wsgi_application)
            handler = get_internal_wsgi_application()
        run(addr, port, handler)
    except socket.error as e:
        # Use helpful error messages instead of ugly tracebacks.
        ERRORS = {
            errno.EACCES: "You don't have permission to access that port.",
            errno.EADDRINUSE: "That port is already in use.",
            errno.EADDRNOTAVAIL: "That IP address can't be assigned to.",
        }
        try:
            error_text = ERRORS[e.errno]
        except KeyError:
            error_text = str(e)
        sys.stderr.write("Error: %s" % error_text + '\n')
        # Need to use an OS exit because sys.exit doesn't work in a thread
        os._exit(1)
    except KeyboardInterrupt:
        print "\nGoodbye!\n"
        sys.exit(0)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import pkg_resources
import sys
import os
from os import path

import django
DJANGO_VERSION = django.VERSION

DEBUG = True
TEMPLATE_DEBUG = DEBUG

# set only to True in DEBUG mode
DEBUG_MAIL = True
PROPAGATE_EXCEPTIONS = True
DISPLAY_EXCEPTIONS = True
DEBUG_PRINT = False

LOG_QUERIES = False

TIMEOUT = None
MAX_RECURSION_DEPTH = 512

# number of bits of precision for inexact calculations
MACHINE_PRECISION = 64

ADMINS = (
    (u'Admin', 'mail@test.com'),
)
MANAGERS = ADMINS

ROOT_DIR = pkg_resources.resource_filename('mathics', '') + '/'
if sys.platform.startswith('win'):
    DATA_DIR = os.environ['APPDATA'].replace(os.sep, '/') + '/Python/Mathics/'
else:
    DATA_DIR = path.expanduser('~/.local/var/mathics/')
# if not path.exists(DATA_DIR):
#    os.makedirs(DATA_DIR)

DOC_DIR = ROOT_DIR + 'doc/documentation/'
DOC_TEX_DATA = ROOT_DIR + 'doc/tex/data'
DOC_XML_DATA = ROOT_DIR + 'doc/xml/data'
DOC_LATEX_FILE = ROOT_DIR + 'doc/tex/documentation.tex'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': DATA_DIR + 'mathics.sqlite'
    }
}

REQUIRE_LOGIN = False

SERVER_EMAIL = 'mathics@localhost'

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'Europe/Vienna'

# Set this True if you prefer 12 hour time to be the default
TIME_12HOUR = False

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# Leave this True unless you have specific reason for not permitting
# users to access local files
ENABLE_FILES_MODULE = True

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# Absolute path to the directory that holds media.
# Example: "/home/media/media.lawrence.com/"
MEDIA_ROOT = ROOT_DIR + 'web/media/'

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash if there is a path component (optional in other cases).
# Examples: "http://media.lawrence.com", "http://example.com/media/"
MEDIA_URL = '/media/'

# URL prefix for admin media -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/media/", "/media/".
if DJANGO_VERSION < (1, 3):
    ADMIN_MEDIA_PREFIX = '/media/admin/'

# Make this unique, and don't share it with anybody.
SECRET_KEY = 'uvbhuiasaeaph6Duh)r@3ex1i@et=0j4h(!p4@!r6s-=a_ev*e'

# List of callables that know how to import templates from various sources.
# TEMPLATE_LOADERS = (
#    'django.template.loaders.filesystem.load_template_source',
#    'django.template.loaders.app_directories.load_template_source',
#)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
)

ROOT_URLCONF = 'mathics.urls'

TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or
    # "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
    ROOT_DIR + 'web/templates/',
)

AUTHENTICATION_BACKENDS = (
    'mathics.web.authentication.EmailModelBackend',
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'mathics.web',
)

########NEW FILE########
__FILENAME__ = test
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from __future__ import with_statement

import sys
import re
import pickle
import os
from argparse import ArgumentParser

import mathics
from mathics.core.definitions import Definitions
from mathics.core.evaluation import Evaluation
from mathics.builtin import builtins
from mathics.doc import documentation
from mathics import get_version_string

from mathics import settings

definitions = Definitions(add_builtin=True)

sep = '-' * 70 + '\n'


def compare(result, wanted):
    if result == wanted:
        return True
    if result is None or wanted is None:
        return False
    result = result.splitlines()
    wanted = wanted.splitlines()
    if len(result) != len(wanted):
        return False
    for r, w in zip(result, wanted):
        wanted_re = re.escape(w.strip())
        wanted_re = wanted_re.replace('\\.\\.\\.', '.*?')
        wanted_re = '^%s$' % wanted_re
        if not re.match(wanted_re, r.strip()):
            return False
    return True


def test_case(test, tests, index=0, quiet=False):
    test, wanted_out, wanted = test.test, test.outs, test.result
    part, chapter, section = tests.part, tests.chapter, tests.section

    def fail(why):
        print u"%sTest failed: %s in %s / %s\n%s\n%s\n" % (
            sep, section, part, chapter, test, why)
        return False

    if not quiet:
        print '%4d. TEST %s' % (index, test)
    try:
        evaluation = Evaluation(test, definitions, catch_interrupt=False)
    except Exception, exc:
        fail(u"Exception %s" % exc)
        info = sys.exc_info()
        sys.excepthook(*info)
        return False

    if evaluation.results:
        if len(evaluation.results) > 1:
            return fail(u"Too many results: %s" % evaluation.results)
        result = evaluation.results[0].result
        out = evaluation.results[0].out
    else:
        result = None
        out = []
    if not compare(result, wanted):
        return fail(u"Result: %s\nWanted: %s" % (result, wanted))
    output_ok = True
    if len(out) != len(wanted_out):
        output_ok = False
    else:
        for got, wanted in zip(out, wanted_out):
            if not got == wanted:
                output_ok = False
                break
    if not output_ok:
        return fail(u"Output:\n%s\nWanted:\n%s" % (
            u'\n'.join(unicode(o) for o in out),
            u'\n'.join(unicode(o) for o in wanted_out)))
    return True


def test_tests(tests, index, quiet=False):
    # print tests
    definitions.reset_user_definitions()
    count = failed = 0
    failed_symbols = set()
    for test in tests.tests:
        count += 1
        index += 1
        if not test_case(test, tests, index, quiet):
            failed += 1
            failed_symbols.add((tests.part, tests.chapter, tests.section))
    return count, failed, failed_symbols, index


def create_output(tests, output_xml, output_tex):
    for format, output in [('xml', output_xml), ('tex', output_tex)]:
        definitions.reset_user_definitions()
        for test in tests.tests:
            key = test.key
            result = Evaluation(
                test.test, definitions, format=format, catch_interrupt=False)
            output[key] = {
                'query': test.test,
                'results': [r.get_data() for r in result.results],
            }


def test_section(section, quiet=False):
    failed = 0
    index = 0
    print 'Testing section %s' % section
    for tests in documentation.get_tests():
        if tests.section == section or tests.section == '$' + section:
            for test in tests.tests:
                index += 1
                if not test_case(test, tests, index, quiet=quiet):
                    failed += 1

    print ''
    if failed > 0:
        print '%d test%s failed.' % (failed, 's' if failed != 1 else '')
    else:
        print 'OK'


def open_ensure_dir(f, *args, **kwargs):
    try:
        return open(f, *args, **kwargs)
    except (IOError, OSError):
        d = os.path.dirname(f)
        if d and not os.path.exists(d):
            os.makedirs(d)
        return open(f, *args, **kwargs)


def test_all(quiet=False, generate_output=False):
    if not quiet:
        print "Testing %s" % get_version_string(False)

    try:
        index = 0
        count = failed = 0
        failed_symbols = set()
        output_xml = {}
        output_tex = {}
        for tests in documentation.get_tests():
            sub_count, sub_failed, symbols, index = test_tests(
                tests, index, quiet=quiet)
            if generate_output:
                create_output(tests, output_xml, output_tex)
            count += sub_count
            failed += sub_failed
            failed_symbols.update(symbols)
        builtin_count = len(builtins)
    except KeyboardInterrupt:
        print "\nAborted.\n"
        return

    if failed > 0:
        print '%s' % sep
    print "%d Tests for %d built-in symbols, %d passed, %d failed." % (
        count, builtin_count, count - failed, failed)
    if failed_symbols:
        print "Failed:"
        for part, chapter, section in sorted(failed_symbols):
            print '  - %s in %s / %s' % (section, part, chapter)

    if failed == 0:
        print '\nOK'

        if generate_output:
            print 'Save XML'
            with open_ensure_dir(settings.DOC_XML_DATA, 'w') as output_file:
                pickle.dump(output_xml, output_file, 0)

            print 'Save TEX'
            with open_ensure_dir(settings.DOC_TEX_DATA, 'w') as output_file:
                pickle.dump(output_tex, output_file, 0)
    else:
        print '\nFAILED'
        return sys.exit(1)      # Travis-CI knows the tests have failed


def write_latex():
    print "Load data"
    with open_ensure_dir(settings.DOC_TEX_DATA, 'r') as output_file:
        output_tex = pickle.load(output_file)

    print 'Print documentation'
    with open_ensure_dir(settings.DOC_LATEX_FILE, 'w') as doc:
        content = documentation.latex(output_tex)
        content = content.encode('utf-8')
        doc.write(content)


def main():
    parser = ArgumentParser(description="Mathics test suite.", add_help=False)
    parser.add_argument(
        '--help', '-h', help='show this help message and exit', action='help')
    parser.add_argument(
        '--version', '-v', action='version',
        version='%(prog)s ' + mathics.__version__)
    parser.add_argument('--section', '-s', dest="section",
                        metavar="SECTION", help="only test SECTION")
    parser.add_argument('--output', '-o', dest="output", action="store_true",
                        help="generate TeX and XML output data")
    parser.add_argument('--tex', '-t', dest="tex", action="store_true",
                        help="generate TeX documentation file")
    parser.add_argument('--quiet', '-q', dest="quiet",
                        action="store_true", help="hide passed tests")
    args = parser.parse_args()

    if args.tex:
        write_latex()
    else:
        if args.section:
            test_section(args.section)
        else:
            test_all(quiet=args.quiet, generate_output=args.output)

if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from django.conf.urls import *

from django.conf import settings

# Uncomment the next two lines to enable the admin:
# from django.contrib import admin
# admin.autodiscover()

handler404 = 'mathics.web.views.error_404_view'
handler500 = 'mathics.web.views.error_500_view'

urlpatterns = patterns(
    '',
    (r'^media/(?P<path>.*)$', 'django.views.static.serve', {
        'document_root': settings.MEDIA_ROOT, 'show_indexes': False}),
    (r'^', include('mathics.web.urls')),

    # Uncomment the admin/doc line below and add 'django.contrib.admindocs'
    # to INSTALLED_APPS to enable admin documentation:
    # (r'^admin/doc/', include('django.contrib.admindocs.urls')),

    # Uncomment the next line to enable the admin:
    # (r'^admin/(.*)', admin.site.root),
)

########NEW FILE########
__FILENAME__ = version
# -*- coding: utf8 -*-

__version__ = '0.6.0rc1'

########NEW FILE########
__FILENAME__ = authentication
# -*- coding: UTF-8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from django.conf import settings
from django.contrib.auth.models import User


class EmailModelBackend(object):
    def authenticate(self, username=None, password=None):
        try:
            user = User.objects.get(email=username)
        except User.DoesNotExist:
            return None

        if user.check_password(password):
            return user

    def get_user(self, user_id):
        try:
            return User.objects.get(pk=user_id)
        except User.DoesNotExist:
            return None

########NEW FILE########
__FILENAME__ = forms
# -*- coding: UTF-8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from django import forms


class AjaxForm(forms.Form):
    def as_json(self, general_errors=[]):
        field_errors = dict((key, [unicode(error) for error in errors])
                            for key, errors in self.errors.items())
        gen_errors = general_errors + self.non_field_errors()
        result = {}
        if field_errors:
            result['fieldErrors'] = field_errors
        if gen_errors:
            result['generalErrors'] = gen_errors
        if hasattr(self, 'cleaned_data'):
            result['values'] = self.cleaned_data
        return result


class LoginForm(AjaxForm):
    email = forms.EmailField(max_length=80)
    password = forms.CharField(
        required=False, max_length=40, widget=forms.PasswordInput,
        help_text=(
            u'<p class="helptext">Leave this field empty '
            u"if you don't have an account yet,\n"
            u"or if you have forgotten your pass&shy;word.\n"
            u"A new password will be sent to your e-mail address.</p>")
    )


class SaveForm(AjaxForm):
    name = forms.CharField(
        required=True, max_length=30,
        help_text=('<p class="helptext">Worksheet names '
                   'are not case-sensitive.</p>')
    )

########NEW FILE########
__FILENAME__ = models
# -*- coding: UTF-8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from django.db import models
from django.contrib.auth.models import User


class Query(models.Model):
    time = models.DateTimeField(auto_now_add=True)
    query = models.TextField()
    result = models.TextField(null=True)
    timeout = models.BooleanField()
    out = models.TextField()
    error = models.BooleanField()

    remote_user = models.CharField(max_length=255, null=True)
    remote_addr = models.TextField(null=True)
    remote_host = models.TextField(null=True)
    browser = models.TextField(null=True)
    meta = models.TextField(null=True)

    log = models.TextField(null=True)


class Worksheet(models.Model):
    user = models.ForeignKey(User, related_name='worksheets', null=True)
    name = models.CharField(max_length=30)
    content = models.TextField()

    class Meta:
        unique_together = (('user', 'name'),)

########NEW FILE########
__FILENAME__ = doc
# -*- coding: UTF-8 -*-

from django import template
from django.utils.safestring import mark_safe
from django.utils.html import escape
import json

from mathics.doc.doc import escape_html

register = template.Library()


@register.filter
def link(object, ajax):
    if object:
        href = object.href(ajax)
        return mark_safe('<a href="%s">%s</a>' % (
            escape(href), object.get_title_html()))
    else:
        return ''


@register.filter
def js(data):
    return mark_safe(json.dumps(data))

########NEW FILE########
__FILENAME__ = urls
# -*- coding: UTF-8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

from django.conf.urls import *

urlpatterns = patterns(
    'mathics.web.views',
    ('^$', 'main_view'),
    ('^ajax/query/$', 'query'),
    ('^ajax/login/$', 'login'),
    ('^ajax/logout/$', 'logout'),
    ('^ajax/save/$', 'save'),
    ('^ajax/open/$', 'open'),
    ('^ajax/getworksheets/$', 'get_worksheets'),
    ('^(?P<ajax>(?:ajax/)?)doc/$', 'doc'),
    ('^ajax/doc/search/$', 'doc_search'),
    ('^(?P<ajax>(?:ajax/)?)doc/(?P<part>[\w-]+)/$',
     'doc_part'),
    ('^(?P<ajax>(?:ajax/)?)doc/(?P<part>[\w-]+)/(?P<chapter>[\w-]+)/$',
     'doc_chapter'),
    ('^(?P<ajax>(?:ajax/)?)doc/(?P<part>[\w-]+)/(?P<chapter>[\w-]+)/'
     '(?P<section>[\w-]+)/$', 'doc_section'),
)

########NEW FILE########
__FILENAME__ = views
# -*- coding: UTF-8 -*-

u"""
    Mathics: a general-purpose computer algebra system
    Copyright (C) 2011-2013 The Mathics Team

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import sys
import traceback

from django.shortcuts import render_to_response
from django.template import RequestContext, loader
from django.http import (HttpResponse, HttpResponseNotFound,
                         HttpResponseServerError, Http404)
import json
from django.conf import settings
from django.contrib import auth
from django.contrib.auth.models import User

from mathics.core.parser import parse, TranslateError
from mathics.core.definitions import Definitions
from mathics.core.evaluation import Evaluation, Message, Result

from mathics.web.models import Query, Worksheet
from mathics.web.forms import LoginForm, SaveForm
from mathics.doc import documentation
from mathics.doc.doc import DocPart, DocChapter, DocSection

if settings.DEBUG:
    JSON_CONTENT_TYPE = 'text/html'
else:
    JSON_CONTENT_TYPE = 'application/json'


def get_content_type(request):
    return ('text/html' if 'MSIE' in request.META.get('HTTP_USER_AGENT', '')
            else 'application/xhtml+xml')


class JsonResponse(HttpResponse):
    def __init__(self, result={}):
        response = json.dumps(result)
        super(JsonResponse, self).__init__(response, content_type=JSON_CONTENT_TYPE)


def require_ajax_login(func):
    def new_func(request, *args, **kwargs):
        if not request.user.is_authenticated():
            return JsonResponse({'requireLogin': True})
        return func(request, *args, **kwargs)
    return new_func

definitions = Definitions(add_builtin=True)


def require_ajax_login(f):
    return f


def main_view(request):
    content_type = get_content_type(request)
    return render_to_response('main.html', {
        'login_form': LoginForm(),
        'save_form': SaveForm(),
        'require_login': settings.REQUIRE_LOGIN,
    }, context_instance=RequestContext(request), content_type=content_type)


def error_404_view(request):
    t = loader.get_template('404.html')
    return HttpResponseNotFound(t.render(RequestContext(request, {
        'title': u'Page not found',
        'request_path': request.path,
    })))


def error_500_view(request):
    t = loader.get_template('500.html')
    return HttpResponseServerError(t.render(RequestContext(request, {
        'title': u'Server error',
    })))


def query(request):
    input = request.POST.get('query', '')
    if settings.DEBUG and not input:
        input = request.GET.get('query', '')

    if settings.LOG_QUERIES:
        query_log = Query(query=input, error=True,
                          browser=request.META.get('HTTP_USER_AGENT', ''),
                          remote_user=request.META.get('REMOTE_USER', ''),
                          remote_addr=request.META.get('REMOTE_ADDR', ''),
                          remote_host=request.META.get('REMOTE_HOST', ''),
                          meta=unicode(request.META),
                          log='',
                          )
        query_log.save()

    user_definitions = request.session.get('definitions')
    definitions.set_user_definitions(user_definitions)
    try:
        evaluation = Evaluation(
            input, definitions, timeout=settings.TIMEOUT, format='xml')
    except Exception, exc:
        if settings.DEBUG and settings.DISPLAY_EXCEPTIONS:
            evaluation = Evaluation()
            info = traceback.format_exception(*sys.exc_info())
            info = '\n'.join(info)
            msg = 'Exception raised: %s\n\n%s' % (exc, info)
            evaluation.results = [Result([Message(
                'System', 'exception', msg)], None, None)]
        else:
            raise
    result = {
        'results': [result.get_data() for result in evaluation.results],
    }
    request.session['definitions'] = definitions.get_user_definitions()

    if settings.LOG_QUERIES:
        query_log.timeout = evaluation.timeout
        query_log.result = unicode(result)  # evaluation.results
        query_log.error = False
        query_log.save()

    return JsonResponse(result)

# taken from http://code.activestate.com/recipes/410076/


def nicepass(alpha=6, numeric=2):
    """
    returns a human-readble password (say rol86din instead of
    a difficult to remember K8Yn9muL )
    """
    import string
    import random
    vowels = ['a', 'e', 'i', 'o', 'u']
    consonants = [a for a in string.ascii_lowercase if a not in vowels]
    digits = string.digits

    # utility functions
    def a_part(slen):
        ret = ''
        for i in range(slen):
            if i % 2 == 0:
                randid = random.randint(0, 20)  # number of consonants
                ret += consonants[randid]
            else:
                randid = random.randint(0, 4)  # number of vowels
                ret += vowels[randid]
        return ret

    def n_part(slen):
        ret = ''
        for i in range(slen):
            randid = random.randint(0, 9)  # number of digits
            ret += digits[randid]
        return ret

    fpl = alpha / 2
    if alpha % 2:
        fpl = int(alpha / 2) + 1
    lpl = alpha - fpl

    start = a_part(fpl)
    mid = n_part(numeric)
    end = a_part(lpl)

    return "%s%s%s" % (start, mid, end)


def email_user(user, subject, text):
    if settings.DEBUG_MAIL:
        print '\n'.join(['-' * 70,
                         'E-Mail to %s:\n%s\n%s' % (user.email, subject, text),
                         '-' * 70])
    else:
        user.email_user(subject, text)


def login(request):
    if settings.DEBUG and not request.POST:
        request.POST = request.GET
    form = LoginForm(request.POST)
    result = ''
    general_errors = []
    if form.is_valid():
        email = form.cleaned_data['email']
        password = form.cleaned_data['password']
        if password:
            user = auth.authenticate(username=email, password=password)
            if user is None:
                general_errors = [u"Invalid username and/or password."]
            else:
                result = 'ok'
                auth.login(request, user)
        else:
            password = nicepass()
            try:
                user = User.objects.get(username=email)
                result = 'reset'
                email_user(
                    user, "Your password at mathics.net",
                    (u"""You have reset your password at mathics.net.\n
Your password is: %s\n\nYours,\nThe Mathics team""") % password)
            except User.DoesNotExist:
                user = User(username=email, email=email)
                result = 'created'
                email_user(
                    user, "New account at mathics.net",
                    u"""Welcome to mathics.net!\n
Your password is: %s\n\nYours,\nThe Mathics team""" % password)
            user.set_password(password)
            user.save()

    return JsonResponse({
        'result': result,
        'form': form.as_json(general_errors=general_errors),
    })


def logout(request):
    # Remember user definitions
    user_definitions = request.session.get('definitions', {})
    auth.logout(request)
    request.session['definitions'] = user_definitions
    return JsonResponse()


@require_ajax_login
def save(request):
    if settings.DEBUG and not request.POST:
        request.POST = request.GET
    if settings.REQUIRE_LOGIN and not request.user.is_authenticated():
        raise Http404
    form = SaveForm(request.POST)
    overwrite = request.POST.get('overwrite', False)
    result = ''
    if form.is_valid():
        content = request.POST.get('content', '')
        name = form.cleaned_data['name']
        user = request.user
        if not user.is_authenticated():
            user = None
        try:
            worksheet = Worksheet.objects.get(user=user, name=name)
            if overwrite:
                worksheet.content = content
            else:
                result = 'overwrite'
        except Worksheet.DoesNotExist:
            worksheet = Worksheet(user=user, name=name, content=content)
        worksheet.save()

    return JsonResponse({
        'form': form.as_json(),
        'result': result,
    })


def open(request):
    if settings.REQUIRE_LOGIN and not request.user.is_authenticated():
        raise Http404
    user = request.user
    name = request.POST.get('name', '')
    try:
        if user.is_authenticated():
            worksheet = user.worksheets.get(name=name)
        else:
            worksheet = Worksheet.objects.get(user__isnull=True, name=name)
        content = worksheet.content
    except Worksheet.DoesNotExist:
        content = ''

    return JsonResponse({
        'content': content,
    })


def get_worksheets(request):
    if settings.REQUIRE_LOGIN and not request.user.is_authenticated():
        result = []
    else:
        if request.user.is_authenticated():
            result = list(request.user.worksheets.order_by(
                'name').values('name'))
        else:
            result = list(Worksheet.objects.filter(
                user__isnull=True).order_by('name').values('name'))
    return JsonResponse({
        'worksheets': result,
    })

# auxiliary function


def render_doc(request, template_name, context, data=None, ajax=False):
    object = context.get('object')
    context.update({
        'ajax': ajax,
        'help_base': ('doc/base_ajax.html' if ajax else
                      'doc/base_standalone.html'),
        'prev': object.get_prev() if object else None,
        'next': object.get_next() if object else None,
    })
    if ajax:
        template = loader.get_template('doc/%s' % template_name)
        result = template.render(RequestContext(request, context))
        result = {
            'content': result,
        }
        if data is not None:
            result['data'] = data
        return JsonResponse(result)
    else:
        context.update({
            'data': data,
        })
        return render_to_response(
            'doc/%s' % template_name, context,
            context_instance=RequestContext(request),
            content_type=get_content_type(request))


def doc(request, ajax=''):
    return render_doc(request, 'overview.html', {
        'title': u'Documentation',
        'doc': documentation,
    }, ajax=ajax)


def doc_part(request, part, ajax=''):
    part = documentation.get_part(part)
    if not part:
        raise Http404
    return render_doc(request, 'part.html', {
        'title': part.get_title_html(),
        'part': part,
        'object': part,
    }, ajax=ajax)


def doc_chapter(request, part, chapter, ajax=''):
    chapter = documentation.get_chapter(part, chapter)
    if not chapter:
        raise Http404
    return render_doc(request, 'chapter.html', {
        'title': chapter.get_title_html(),
        'chapter': chapter,
        'object': chapter,
    }, ajax=ajax)


def doc_section(request, part, chapter, section, ajax=''):
    section = documentation.get_section(part, chapter, section)
    if not section:
        raise Http404
    data = section.html_data()
    return render_doc(request, 'section.html', {
        'title': section.get_title_html(),
        'title_operator': section.operator,
        'section': section,
        'object': section,
    }, data=data, ajax=ajax)


def doc_search(request):
    query = request.GET.get('query', '')
    result = documentation.search(query)
    if len([item for exact, item in result if exact]) <= 1:
        for exact, item in result:
            if exact or len(result) == 1:
                if isinstance(item, DocPart):
                    return doc_part(request, item.slug, ajax=True)
                elif isinstance(item, DocChapter):
                    return doc_chapter(
                        request, item.part.slug, item.slug, ajax=True)
                else:
                    return doc_section(
                        request, item.chapter.part.slug, item.chapter.slug,
                        item.slug, ajax=True)
    result = [item for exact, item in result]

    return render_doc(request, 'search.html', {
        'title': u"Search documentation",
        'result': result,
    }, ajax=True)

########NEW FILE########
__FILENAME__ = test_console
import os
import sys
import pexpect

if sys.version_info[:2] == (2, 7):
    import unittest
else:
    import unittest2 as unittest


class ConsoleTest(unittest.TestCase):
    def setUp(self):
        os.environ["TERM"] = "dumb"
        self.console = pexpect.spawn('python2 mathics/main.py --color NOCOLOR')

    def testLaunch(self):
        cons = self.console

        self.assertRegexpMatches(cons.readline(), '.*\r\n')

        self.assertRegexpMatches(
            cons.readline(), 'Mathics \\d\\.\\d\\.\\d.*\r\n')
        self.assertRegexpMatches(
            cons.readline(), 'on (CPython|PyPy) \\d.\\d.\\d \\(.+\\) ?\r\n')
        self.assertRegexpMatches(
            cons.readline(), 'using ([a-zA-Z]+ [\\.\\d]+(, |\r\n$))+')

        self.assertRegexpMatches(cons.readline(), '\r\n')

        self.assertRegexpMatches(
            cons.readline(),
            'Copyright \\(C\\) 2011\-20\\d\\d The Mathics Team.\r\n')

        self.assertEqual(
            ''.join(cons.readline() for i in range(7)),
            'This program comes with ABSOLUTELY NO WARRANTY.\r\n'
            'This is free software, and you are welcome to redistribute it\r\n'
            'under certain conditions.\r\n'
            'See the documentation for the full license.\r\n'
            '\r\n'
            'Quit by pressing CONTROL-D\r\n'
            '\r\n')

    def testPrompt(self):
        cons = self.console
        cons.expect('Quit by pressing CONTROL-D\r\n\r\n')

        self.lineno = 1

        def check(query, result):
            inprompt = 'In[{0}]:= '.format(self.lineno)
            self.assertEqual(
                cons.read(len(inprompt)), inprompt)
            cons.sendline(query)
            self.assertEqual(

                cons.readline(), '{0}\r\n'.format(query))

            outprompt = 'Out[{0}]= {1}\r\n'.format(self.lineno, result)

            self.assertEqual(cons.readline(), outprompt)
            self.assertEqual(cons.readline(), '\r\n')
            self.lineno += 1

        check('1 + 1', '2')
        check('2 * 3', '6')

    def tearDown(self):
        self.console.close()


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
__FILENAME__ = test_convert
import sympy
import mathics
import random
import sys

if sys.version_info[:2] == (2, 7):
    import unittest
else:
    import unittest2 as unittest


class SympyConvert(unittest.TestCase):
    def compare(self, mathics_expr, sympy_expr):
        self.assertEqual(mathics_expr.to_sympy(), sympy_expr)
        self.assertEqual(mathics_expr, mathics.from_sympy(sympy_expr))

    def testSymbol(self):
        self.compare(
            mathics.Symbol('x'),
            sympy.Symbol('_Mathics_User_x'))
        self.compare(
            mathics.Symbol('_Mathics_User_x'),
            sympy.Symbol('_Mathics_User__Mathics_User_x'))

    def testReal(self):
        self.compare(mathics.Real('1.0'), sympy.Float('1.0'))
        self.compare(mathics.Real(1.0), sympy.Float(1.0))

    def testInteger(self):
        self.compare(mathics.Integer(0), sympy.Integer(0))
        self.compare(mathics.Integer(1), sympy.Integer(1))

        n = random.randint(-sys.maxint, sys.maxint)
        self.compare(mathics.Integer(n), sympy.Integer(n))

        n = random.randint(sys.maxint, sys.maxint * sys.maxint)
        self.compare(mathics.Integer(n), sympy.Integer(n))

    def testComplex(self):
        self.compare(
            mathics.Complex(mathics.Real('1.0'), mathics.Real('1.0')),
            sympy.Add(sympy.Float('1.0'), sympy.Float('1.0') * sympy.I))

        self.compare(
            mathics.Complex(mathics.Integer(0), mathics.Integer(1)),
            sympy.I)

        self.compare(
            mathics.Complex(mathics.Integer(-1), mathics.Integer(1)),
            sympy.Integer(-1) + sympy.I)

    def testString(self):
        self.compare(
            mathics.String('abcd'),
            "abcd")

    def testAdd(self):
        self.compare(
            mathics.Expression(
                'Plus', mathics.Integer(1), mathics.Symbol('x')),
            sympy.Add(
                sympy.Integer(1),
                sympy.Symbol('_Mathics_User_x')))

    def testIntegrate(self):
        self.compare(
            mathics.Expression(
                'Integrate', mathics.Symbol('x'), mathics.Symbol('y')),
            sympy.Integral(
                sympy.Symbol('_Mathics_User_x'),
                sympy.Symbol('_Mathics_User_y')))

    def testDerivative(self):
        self.compare(
            mathics.Expression(
                'D', mathics.Symbol('x'), mathics.Symbol('y')),
            sympy.Derivative(
                sympy.Symbol('_Mathics_User_x'),
                sympy.Symbol('_Mathics_User_y')))

    def testExpression(self):
        self.compare(
            mathics.Expression('Sin', mathics.Symbol('x')),
            sympy.sin(sympy.Symbol('_Mathics_User_x')))


class PythonConvert(unittest.TestCase):
    def compare(self, mathics_expr, python_expr):
        self.assertEqual(mathics_expr.to_python(), python_expr)
        self.assertEqual(mathics_expr, mathics.from_python(python_expr))

    def testReal(self):
        self.compare(mathics.Real('0.0'), 0.0)
        self.compare(mathics.Real('1.5'), 1.5)
        self.compare(mathics.Real('-1.5'), -1.5)

    def testInteger(self):
        self.compare(mathics.Integer(1), 1)

    @unittest.expectedFailure
    def testString(self):
        self.compare(mathics.String("abc"), '"abc"')

    @unittest.expectedFailure
    def testSymbol(self):
        self.compare(mathics.Symbol("abc"), "abc")

    def testComplex(self):
        self.compare(mathics.Complex(1, 1), 1 + 1j)
        self.compare(mathics.Complex(1.0, 1.0), 1.0 + 1.0j)
        self.compare(mathics.Complex(1, 1.0), 1 + 1.0j)
        self.compare(mathics.Complex(1.0, 1), 1.0 + 1j)

        self.compare(mathics.Complex(0, 1), 1j)
        self.compare(mathics.Complex(1, 0), 1)

    def testList(self):
        self.compare(mathics.Expression('List', mathics.Integer(1)), [1])


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_parser
import sys
import random
from mathics import *

if sys.version_info[:2] == (2, 7):
    import unittest
else:
    import unittest2 as unittest


class ParserTests(unittest.TestCase):
    def check(self, expr1, expr2):
        if isinstance(expr1, basestring):
            expr1 = parse(expr1)
        if isinstance(expr2, basestring):
            expr2 = parse(expr2)

        self.assertTrue(expr1.same(expr2))

    def lex_error(self, string):
        self.assertRaises(ScanError, parse, string)

    def parse_error(self, string):
        self.assertRaises(ParseError, parse, string)


class NumberTests(ParserTests):
    def testReal(self):
        self.check('1.5', Real('1.5'))
        self.check('1.5`', Real('1.5'))
        self.check('0.0', Real(0))
        self.check('-1.5`', Real('-1.5'))

        self.check('0.00000000000000000', '0.')
        self.check('0.000000000000000000`', '0.')
        self.check('0.000000000000000000', '0.``18')

    def testSymbol(self):
        self.check('xX', Symbol('xX'))
        self.check('context`name', Symbol('context`name'))
        self.check('`name', Symbol('Global`name'))
        self.check('`context`name', Symbol('Global`context`name'))

    def testAccuracy(self):
        self.lex_error('1.5``')

        self.check('1.0``20', Real('1.0', p=20))

    @unittest.expectedFailure
    def testLowAccuracy(self):
        self.check('1.4``0', Real(0))
        self.check('1.4``-20', Real(0))

    def testPrecision(self):
        self.check('1.`20', Real(1, p=20))
        self.check('1.00000000000000000000000`', Real(1))
        self.check('1.00000000000000000000000`30', Real(1, p=30))

    @unittest.expectedFailure
    def testLowPrecision(self):
        self.check('1.4`1', Real('1', p=1))
        self.check('1.4`0', Real(0, p=0))
        self.check('1.4`-5', Real(0, p=0))

    def testInteger(self):
        self.check('0', Integer(0))
        self.check('1', Integer(1))
        self.check('-1', Integer(-1))

        self.check('8^^23', Integer(19))
        self.check('10*^3', Integer(10000))
        self.check('10*^-3', Rational(1, 100))
        self.check('8^^23*^2', Integer(1216))

        n = random.randint(-sys.maxint, sys.maxint)
        self.check(str(n), Integer(n))

        n = random.randint(sys.maxint, sys.maxint * sys.maxint)
        self.check(str(n), Integer(n))

    def testPattern(self):
        self.check('Map[f_, expr_, ls_?LevelQ:{1}, OptionsPattern[Map]]', 'Map[Pattern[f, Blank[]], Pattern[expr, Blank[]], PatternTest[Pattern[ls, Blank[]], Pattern[LevelQ, List[1]]], OptionsPattern[Map]]')
        self.check('_^_?t', 'Power[Blank[], PatternTest[Blank[], t]]')
        self.check('-Sin[x]', 'Times[-1, Sin[x]]')
        self.check('a[x_] := x^2', 'SetDelayed[a[Pattern[x, Blank[]]], Power[x, 2]]')
        self.check('MakeBoxes[expr_, f:TraditionalForm|StandardForm|OutputForm|InputForm|FullForm]', 'MakeBoxes[Pattern[expr, Blank[]], Pattern[f, Alternatives[TraditionalForm, StandardForm, OutputForm, InputForm, FullForm]]]')

        self.check('1?2', Expression('PatternTest', Integer(1), Integer(2)))

        self.check('x:expr', Expression('Pattern', Symbol('x'), Symbol('expr')))
        self.check('x_:expr', Expression('Optional', Expression('Pattern', Symbol('x'), Expression('Blank')), Symbol('expr')))
        self.check('f:a|b', Expression('Pattern', Symbol('f'), Expression('Alternatives', Symbol('a'), Symbol('b'))))

    def testCompound(self):
        self.check('a ; {b}', Expression('CompoundExpression', Symbol('a'), Expression('List', Symbol('b'))))
        self.check('1 ;', Expression('CompoundExpression', Integer(1), Symbol('Null')))
        self.check('1 ; 5', Expression('CompoundExpression', Integer(1), Integer(5)))
        self.check('4; 1 ; 5', Expression('CompoundExpression', Integer(4), Integer(1), Integer(5)))
        self.check('4;1;', Expression('CompoundExpression', Integer(4), Integer(1), Symbol('Null')))

    def testComment(self):
        self.check('145 (* abf *) 345', Expression('Times', Integer(145), Integer(345)))

    def testNone(self):
        self.assertIs(parse(''), None)
        self.assertIs(parse('(*fdasf *)'), None)

    def testMessage(self):
        self.check('1 :: "abc"', Expression('MessageName', Integer(1), String("abc")))
        # self.check('1 :: "abc" :: "123"', Expression('MessageName', Integer(1), String("abc"), String("123")))

    def testGetPut(self):
        self.check('<<"filename"', Expression('Get', String('filename')))
        self.check('1 >> filename', Expression('Put', Integer(1), String('filename')))
        self.check('1 >>> filename', Expression('PutAppend', Integer(1), String('filename')))
        self.check('<< filename', Expression('Get', String('filename')))

    def testExpression(self):
        self.check('expr1[expr2]', Expression('expr1', Symbol('expr2')))
        self.check('expr1[expr2][expr3]', Expression(Expression('expr1', Symbol('expr2')), Symbol('expr3')))
        self.check('expr1[[expr2]]', Expression('Part', Symbol('expr1'), Symbol('expr2')))
        self.check('expr1[[expr2, expr3]]', Expression('Part', Symbol('expr1'), Symbol('expr2'), Symbol('expr3')))
        self.check('expr1[[expr2]][[expr3]]', Expression('Part', Expression('Part', Symbol('expr1'), Symbol('expr2')), Symbol('expr3')))

        self.check('expr1 ~ expr2 ~ expr3', Expression('expr2', Symbol('expr1'), Symbol('expr3')))
        self.check('x~f~y', 'f[x, y]')

    def testFunctional(self):
        self.check('expr1 @ expr2', Expression('expr1', Symbol('expr2')))
        self.check('f @@ expr', Expression('Apply', Symbol('f'), Symbol('expr')))
        self.check('f /@ expr', Expression('Map', Symbol('f'), Symbol('expr')))

        self.check('f @@@ expr', Expression('Apply', Symbol('f'), Symbol('expr'), Expression('List', 1)))
        self.check('f //@ expr', Expression('MapAll', Symbol('f'), Symbol('expr')))
        self.check('a @@ b @@ c', Expression('Apply', Symbol('a'), Expression('Apply', Symbol('b'), Symbol('c'))))

    def testIncDec(self):
        self.check('a++', Expression('Increment', Symbol('a')))
        self.check('a--', Expression('Decrement', Symbol('a')))
        self.check('++a', Expression('PreIncrement', Symbol('a')))
        self.check('--a', Expression('PreDecrement', Symbol('a')))

    def testBang(self):
        self.check('5!', Expression('Factorial', Integer(5)))
        self.check('5 !', Expression('Factorial', Integer(5)))
        self.check('5 ! !', Expression('Factorial', Expression('Factorial', Integer(5))))
        self.check('!1', Expression('Not', Integer(1)))
        self.check('5 !!', Expression('Factorial2', Integer(5)))
        self.check('x ! y', Expression('Times', Expression('Factorial', Symbol('x')), Symbol('y')))

    def testDerivative(self):
        self.check("f'", Expression(Expression('Derivative', Integer(1)), Symbol('f')))
        self.check("f''", Expression(Expression('Derivative', Integer(2)), Symbol('f')))
        self.check("f' '", Expression(Expression('Derivative', Integer(2)), Symbol('f')))

    def testPlus(self):
        self.check('+1', Integer(1))
        self.check('1 + 2', Expression('Plus', Integer(1), Integer(2)))
        self.check('1 + 2 + 3', Expression('Plus', Integer(1), Integer(2), Integer(3)))
        self.check('1 + 2 + 3 + 4', 'Plus[1, 2, 3, 4]')
        self.check('-a', Expression('Times', Integer(-1), Symbol('a')))
        self.check('1 - 2', Expression('Plus', Integer(1), Expression('Times', Integer(-1), Integer(2))))

        self.check('a*b+c', Expression('Plus', Expression('Times', Symbol('a'), Symbol('b')), Symbol('c')))
        self.check('a*+b+c', Expression('Plus', Expression('Times', Symbol('a'), Symbol('b')), Symbol('c')))
        self.check('a+b*c', 'a+(b*c)')
        self.check('a*b+c', '(a*b) + c')

    def testTimes(self):
        self.check('1 2', Expression('Times', Integer(1), Integer(2)))
        self.check('1*2', Expression('Times', Integer(1), Integer(2)))

        self.check('1 2 3', Expression('Times', Integer(1), Integer(2), Integer(3)))
        self.check('1*2*3', Expression('Times', Integer(1), Integer(2), Integer(3)))

        self.check('x ^ 2 y', Expression('Times', Expression('Power', Symbol('x'), Integer(2)), Symbol('y')))

    def testSpan(self):
        self.check('1;;2;;3', Expression('Span', Integer(1), Integer(2), Integer(3)))
        self.check('1;; ;;3', Expression('Span', Integer(1), Symbol('All'), Integer(3)))
        self.check('1;;;;3', Expression('Span', Integer(1), Symbol('All'), Integer(3)))
        self.check(' ;;2;;3', Expression('Span', Integer(1), Integer(2), Integer(3)))
        self.check(' ;;2', Expression('Span', Integer(1), Integer(2)))
        self.check('1;; ', Expression('Span', Integer(1), Symbol('All')))
        self.check(' ;; ', Expression('Span', Integer(1), Symbol('All')))

    def testBinOp(self):
        self.check('1 <> 2 ', Expression('StringJoin', Integer(1), Integer(2)))
        self.check('1 <> 2 <> 3', Expression('StringJoin', Integer(1), Integer(2), Integer(3)))

        self.check('1 ^ 2', Expression('Power', Integer(1), Integer(2)))
        self.check('1 . 2', Expression('Dot', Integer(1), Integer(2)))
        self.check('1 && 2', Expression('And', Integer(1), Integer(2)))
        self.check('1 || 2', Expression('Or', Integer(1), Integer(2)))

        self.check('x /; y', Expression('Condition', Symbol('x'), Symbol('y')))
        self.check('x -> y', Expression('Rule', Symbol('x'), Symbol('y')))
        self.check('x :> y', Expression('RuleDelayed', Symbol('x'), Symbol('y')))

        self.check('x /. y', Expression('ReplaceAll', Symbol('x'), Symbol('y')))
        self.check('x //. y', Expression('ReplaceRepeated', Symbol('x'), Symbol('y')))

        self.check('x += y', Expression('AddTo', Symbol('x'), Symbol('y')))
        self.check('x -= y', Expression('SubtractFrom', Symbol('x'), Symbol('y')))
        self.check('x *= y', Expression('TimesBy', Symbol('x'), Symbol('y')))
        self.check('x /= y', Expression('DivideBy', Symbol('x'), Symbol('y')))

        self.check('x &', Expression('Function', Symbol('x')))

        self.check('x // y', Expression('y', Symbol('x')))

        self.check('1 ^ 2 ^ 3', 'Power[1, Power[2, 3]]')
        self.check('3/2', Expression('Times', Integer(3), Expression('Power', Integer(2), Integer(-1))))

        self.check('x ~~ y', Expression('StringExpression', Symbol('x'), Symbol('y')))
        self.check('x ~~ y ~~ z', Expression('StringExpression', Symbol('x'), Symbol('y'), Symbol('z')))

    def testCompare(self):
        self.check('1 == 2', Expression('Equal', Integer(1), Integer(2)))
        self.check('1 != 2', Expression('Unequal', Integer(1), Integer(2)))
        self.check('1 == 2 == 3', Expression('Equal', Integer(1), Integer(2), Integer(3)))
        self.check('1 != 2 != 3', Expression('Unequal', Integer(1), Integer(2), Integer(3)))

        self.check('1 > 2', Expression('Greater', Integer(1), Integer(2)))
        self.check('1 >= 2', Expression('GreaterEqual', Integer(1), Integer(2)))
        self.check('1 < 2', Expression('Less', Integer(1), Integer(2)))
        self.check('1 <= 2', Expression('LessEqual', Integer(1), Integer(2)))

        self.check('1 > 2 > 3', Expression('Greater', Integer(1), Integer(2), Integer(3)))
        self.check('1 >= 2 >= 3', Expression('GreaterEqual', Integer(1), Integer(2), Integer(3)))
        self.check('1 < 2 < 3', Expression('Less', Integer(1), Integer(2), Integer(3)))
        self.check('1 <= 2 <= 3', Expression('LessEqual', Integer(1), Integer(2), Integer(3)))

        self.check('1 === 2', Expression('SameQ', Integer(1), Integer(2)))
        self.check('1 =!= 2', Expression('UnsameQ', Integer(1), Integer(2)))
        self.check('1 === 2 === 3', Expression('SameQ', Integer(1), Integer(2), Integer(3)))
        self.check('1 =!= 2 =!= 3', Expression('UnsameQ', Integer(1), Integer(2), Integer(3)))

    def testRepeated(self):
        self.check('1..', Expression('Repeated', Integer(1)))
        self.check('1...', Expression('RepeatedNull', Integer(1)))

    def testAlternatives(self):
        self.check('1 | 2', Expression('Alternatives', Integer(1), Integer(2)))
        self.check('1 | 2 | 3', Expression('Alternatives', Integer(1), Integer(2), Integer(3)))

    def testSet(self):
        self.check('x = y', Expression('Set', Symbol('x'), Symbol('y')))
        self.check('x := y', Expression('SetDelayed', Symbol('x'), Symbol('y')))
        self.check('x ^= y', Expression('UpSet', Symbol('x'), Symbol('y')))
        self.check('x ^:= y', Expression('UpSetDelayed', Symbol('x'), Symbol('y')))
        self.check('x =.', Expression('Unset', Symbol('x')))

        self.check('x/:1=1', Expression('TagSet', Symbol('x'), Integer(1), Integer(1)))
        self.check('x/:1:=1', Expression('TagSetDelayed', Symbol('x'), Integer(1), Integer(1)))
        # self.check('x/:1=.', Expression('TagUnset', Symbol('x'), Integer(1)))

    def testList(self):
        self.check('{x, y}', Expression('List', Symbol('x'), Symbol('y')))

        self.check('{}', Expression('List'))
        self.check('{a,}', Expression('List', Symbol('a'), Symbol('Null')))
        self.check('{,}', Expression('List', Symbol('Null'), Symbol('Null')))

        self.check('{a, b,}', Expression('List', Symbol('a'), Symbol('b'), Symbol('Null')))

        self.check('{,a}', Expression('List', Symbol('Null'), Symbol('a')))
        self.check('{, a, b}', Expression('List', Symbol('Null'), Symbol('a'), Symbol('b')))
        self.check('{,a,b,}', Expression('List', Symbol('Null'), Symbol('a'), Symbol('b'), Symbol('Null')))

    def testSequence(self):
        self.check('Sin[x, y]', Expression('Sin', Symbol('x'), Symbol('y')))

    def testPart(self):
        self.check('a[[1]]', Expression('Part', Symbol('a'), Integer(1)))

    def testBlank(self):
        self.check('f_', Expression('Pattern', Symbol('f'), Expression('Blank')))
        self.check('f__', Expression('Pattern', Symbol('f'), Expression('BlankSequence')))
        self.check('f___', Expression('Pattern', Symbol('f'), Expression('BlankNullSequence')))

        self.check('_', 'Blank[]')
        self.check('_expr', 'Blank[expr]')
        self.check('__', 'BlankSequence[]')
        self.check('__expr', 'BlankSequence[expr]')
        self.check('___', 'BlankNullSequence[]')
        self.check('___expr', 'BlankNullSequence[expr]')

        self.check('_.', 'Optional[Blank[]]')
        self.check('symb_', 'Pattern[symb, Blank[]]')
        self.check('symb_expr', 'Pattern[symb, Blank[expr]]')
        self.check('symb__', 'Pattern[symb, BlankSequence[]]')
        self.check('symb__expr', 'Pattern[symb, BlankSequence[expr]]')
        self.check('symb___', 'Pattern[symb, BlankNullSequence[]]')
        self.check('symb___expr', 'Pattern[symb, BlankNullSequence[expr]]')
        self.check('symb_.', 'Optional[Pattern[symb, Blank[]]]')

    def testSlot(self):
        self.check('#2', Expression('Slot', Integer(2)))
        self.check('#', Expression('Slot', Integer(1)))
        self.check('##2', Expression('SlotSequence', Integer(2)))
        self.check('##', Expression('SlotSequence', Integer(1)))
        self.check('%2', Expression('Out', Integer(2)))

    def testOut(self):
        self.check('%%', Expression('Out', Integer(-2)))
        self.check('%%%%', Expression('Out', Integer(-4)))
        self.check('%', Expression('Out'))

    def testNonAscii(self):
        self.check('z \\[Conjugate]', Expression('Conjugate', Symbol('z')))
        self.check('z \\[Transpose]', Expression('Transpose', Symbol('z')))
        self.check('z \\[ConjugateTranspose]', Expression('ConjugateTranspose', Symbol('z')))
        self.check(u'z \uf3c7 ', Expression('Transpose', Symbol('z')))
        self.check(u'z \uf3c8 ', Expression('Conjugate', Symbol('z')))
        self.check(u'z \uf3c9 ', Expression('ConjugateTranspose', Symbol('z')))
        self.check('\\[Integral] x \\[DifferentialD] x', Expression('Integrate', Symbol('x'), Symbol('x')))
        self.check('\\[Del] x', Expression('Del', Symbol('x')))
        self.check('\\[Square] x', Expression('Square', Symbol('x')))
        self.check('1 \\[SmallCircle] 2', Expression('SmallCircle', Integer(1), Integer(2)))
        self.check('1 \\[SmallCircle] 2 \\[SmallCircle] 3', Expression('SmallCircle', Integer(1), Integer(2), Integer(3)))
        self.check(u'1 \u2218 2', Expression('SmallCircle', Integer(1), Integer(2)))
        self.check('1 \\[CircleDot] 2', Expression('CircleDot', Integer(1), Integer(2)))
        self.check(u'1 \u2299 2', Expression('CircleDot', Integer(1), Integer(2)))
        self.check('1 \\[Diamond] 2', Expression('Diamond', Integer(1), Integer(2)))
        self.check('1 \\[Wedge] 2', Expression('Wedge', Integer(1), Integer(2)))
        self.check('1 \\[Vee] 2', Expression('Vee', Integer(1), Integer(2)))
        self.check('1 \\[CircleTimes] 2', Expression('CircleTimes', Integer(1), Integer(2)))
        self.check('1 \\[CenterDot] 2', Expression('CenterDot', Integer(1), Integer(2)))
        self.check('1 \\[Star] 2', Expression('Star', Integer(1), Integer(2)))
        self.check('a \\[Cap] b', 'Cap[a,b]')
        self.check('a \\[Cup] b \\[Cup] c', 'Cup[a,b,c]')
        self.check(u'a \u2322 b \u2322 c', 'Cap[a,b,c]')
        self.check(u'a \u2323 b', 'Cup[a, b]')
        self.check(u'1 \u22C4 2', Expression('Diamond', Integer(1), Integer(2)))
        self.check(u'1 \u22C0 2', Expression('Wedge', Integer(1), Integer(2)))
        self.check(u'1 \u22c1 2', Expression('Vee', Integer(1), Integer(2)))
        self.check(u'1 \u2297 2', Expression('CircleTimes', Integer(1), Integer(2)))
        self.check(u'1 \u00B7 2', Expression('CenterDot', Integer(1), Integer(2)))
        self.check(u'1 \u22C6 2', Expression('Star', Integer(1), Integer(2)))
        self.check('expr1 ** expr2', Expression('NonCommutativeMultiply', Symbol('expr1'), Symbol('expr2')))
        self.check('expr1 ** expr2 ** expr3', Expression('NonCommutativeMultiply', Symbol('expr1'), Symbol('expr2'), Symbol('expr3')))
        self.check('1 \\[Cross] 2', Expression('Cross', Integer(1), Integer(2)))
        self.check(u'1 \uf4a0 2', Expression('Cross', Integer(1), Integer(2)))
        self.check('3\\[Divide]2', Expression('Times', Integer(3), Expression('Power', Integer(2), Integer(-1))))
        self.check(u'3 \u00f7 2', Expression('Times', Integer(3), Expression('Power', Integer(2), Integer(-1))))
        self.check('3\\2', Expression('Backslash', Integer(3), Integer(2)))
        self.check('1 \\[Times] 2', Expression('Times', Integer(1), Integer(2)))
        self.check(u'1 \u00d7 2', Expression('Times', Integer(1), Integer(2)))
        self.check('1 \[PlusMinus] 2', Expression('PlusMinus', Integer(1), Integer(2)))
        self.check('1 \[MinusPlus] 2', Expression('MinusPlus', Integer(1), Integer(2)))
        self.check('\[PlusMinus] 1', Expression('PlusMinus', Integer(1)))
        self.check('\[MinusPlus] 1', Expression('MinusPlus', Integer(1)))
        self.check(u'\u00b1 1', Expression('PlusMinus', Integer(1)))
        self.check(u'\u2213 1', Expression('MinusPlus', Integer(1)))
        self.check('1 \\[And] 2', Expression('And', Integer(1), Integer(2)))
        self.check(u'1 \u2227 2', Expression('And', Integer(1), Integer(2)))
        self.check('1 \\[Or] 2', Expression('Or', Integer(1), Integer(2)))
        self.check(u'1 \u2228 2', Expression('Or', Integer(1), Integer(2)))

        self.check('a \\[Colon] b', Expression('Colon', Symbol('a'), Symbol('b')))
        self.check(u'a \u2236 b', Expression('Colon', Symbol('a'), Symbol('b')))
        self.check('x \\[Function] y', 'Function[{x}, y]')
        self.check(u'x \uf4a1 y', 'Function[{x}, y]')

        self.check('x1 \\[RightTee] x2', 'RightTee[x1, x2]')
        self.check('x1 \\[DoubleRightTee] x2', 'DoubleRightTee[x1, x2]')
        self.check('x1 \\[LeftTee] x2', 'LeftTee[x1, x2]')
        self.check('x1 \\[DoubleLeftTee] x2', 'DoubleLeftTee[x1, x2]')

    @unittest.expectedFailure
    def testBoxes(self):
        self.check('\\(1 \\^ 2\\)', 'SuperscriptBox["1", "2"]')
        self.check('\\(1 \\^ 2 \\% 3\\)', 'SubsuperscriptBox["1", "3", "2"]')
        self.check('\\(1 \\_ 2\\)', 'SubscriptBox["1", "2"]')
        self.check('\\(1 \\_ 2 \\% 3\\)', 'SubsuperscriptBox["1", "2", "3"]')

        self.check('\\( 1 \\& 2 \\)', 'OverscriptBox["1", "2"]')
        self.check('\\( 1 \\& 2 \\% 3 \\)', 'UnderoverscriptBox["1", "3", "2"]')
        self.check('\\( 1 \\+ 2 \\)', 'UnderscriptBox["1", "2"]')
        self.check('\\( 1 \\+ 2 \\% 3 \\)', 'UnderoverscriptBox["1", "2", "3"]')

        self.check('\\( 1 \\/ 2 \\)', 'FractionBox["1", "2"]')

        self.check('\\( \\@ 2 \\)', 'SqrtBox["2"]')
        self.check('\\( \\@ 2 \\% 3 \\)', 'RadicalBox["2", "3"]')

        self.check('\\( 1 \\` 2 \\)', 'FormBox["2", Removed["$$Failure"]]')
        self.check('\\( FullForm \\` 2 \\)', 'FormBox["2", FullForm]')

        self.check('\\( \\)', String(""))
        self.check('\\( a \\)', String("a"))
        self.check('\\( \\@ 1 \\_ 2 \\)', 'SqrtBox[SubscriptBox["1", "2"]]')
        self.check('\\( a + b \\)', 'RowBox[List["a", "+", "b"]]')
        self.check('\\(1 \\` 2\\)', Expression('FormBox', Integer(2), Integer(1)))

    def testParseError(self):
        self.assertRaises(ParseError, parse, '1+')

    def testBracketMatching(self):
        self.assertRaises(ParseError, parse, 'x)')      # bktmop
        self.assertRaises(ParseError, parse, 'x]')      # bktmop
        self.assertRaises(ParseError, parse, 'x}')      # bktmop
        self.assertRaises(ParseError, parse, 'x]]')     # bktmop
        self.assertRaises(ParseError, parse, '(x,')     # bktmcp
        self.assertRaises(ParseError, parse, '(x')      # bktmcp
        self.assertRaises(ParseError, parse, '[x')      # bktmcp
        self.assertRaises(ParseError, parse, '{x')      # bktmcp
        self.assertRaises(ParseError, parse, '[[x')     # bktmcp


if __name__ == "__main__":
    unittest.main()

########NEW FILE########
