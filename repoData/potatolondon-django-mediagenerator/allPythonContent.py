__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
try:
    import settings # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n(If the file settings.py does indeed exist, it's causing an ImportError somehow.)\n" % __file__)
    sys.exit(1)

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# -*- coding: utf-8 -*-
import os

DEBUG = True
TEMPLATE_DEBUG = DEBUG

MEDIA_BUNDLES = (
    ('main.css',
        'css/reset.css',
        'css/style.css',
        'css/icons/icon.css',
    ),
)

# Get project root folder
_project_root = os.path.dirname(__file__)

# Set global media search paths
GLOBAL_MEDIA_DIRS = (
    os.path.join(_project_root, 'static'),
)

# Set media URL (important: don't forget the trailing slash!).
# PRODUCTION_MEDIA_URL is used when running manage.py generatemedia
MEDIA_DEV_MODE = DEBUG
DEV_MEDIA_URL = '/devmedia/'
PRODUCTION_MEDIA_URL = '/media/'

# Configure yuicompressor if available
YUICOMPRESSOR_PATH = os.path.join(
    os.path.dirname(_project_root), 'yuicompressor.jar')
if os.path.exists(YUICOMPRESSOR_PATH):
    ROOT_MEDIA_FILTERS = {
        'js': 'mediagenerator.filters.yuicompressor.YUICompressor',
        'css': 'mediagenerator.filters.yuicompressor.YUICompressor',
    }

ADMIN_MEDIA_PREFIX = '/media/admin/'

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'sqlite.db',
    }
}

SECRET_KEY = '=r-$b*8hglm+858&9t043hlm6-&6-3d3vfc4((7yd0dbrakhvi'

SITE_ID = 1

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.sessions',
    'django.contrib.contenttypes',
    'django.contrib.sites',
    'mediagenerator',
)

MIDDLEWARE_CLASSES = (
    'mediagenerator.middleware.MediaMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
)

TEMPLATE_CONTEXT_PROCESSORS = (
    'django.core.context_processors.auth',
    'django.core.context_processors.request',
)

USE_I18N = False

TEMPLATE_DIRS = (os.path.join(_project_root, 'templates'),)

ROOT_URLCONF = 'urls'

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import *

urlpatterns = patterns('',
    (r'^$', 'django.views.generic.simple.direct_to_template', {'template': 'home.html'}),
)

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Django Mediagenerator documentation build configuration file, created by
# sphinx-quickstart on Mon Dec 12 11:47:17 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Django Mediagenerator'
copyright = u'2011, Potato London, AllButtonsPressed'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.11'
# The full version, including alpha/beta/rc tags.
release = '1.11'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'DjangoMediageneratordoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'DjangoMediagenerator.tex', u'Django Mediagenerator Documentation',
   u'Potato London, AllButtonsPressed', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'djangomediagenerator', u'Django Mediagenerator Documentation',
     [u'Potato London, AllButtonsPressed'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'DjangoMediagenerator', u'Django Mediagenerator Documentation', u'Potato London, All Buttons Pressed',
   'DjangoMediagenerator', 'One line description of project.', 'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = api
from . import settings, utils
from .settings import (GENERATED_MEDIA_DIR, GENERATED_MEDIA_NAMES_FILE,
                       MEDIA_GENERATORS)
from .utils import load_backend
from django.utils.http import urlquote
import os
import shutil

def generate_media():
    if os.path.exists(GENERATED_MEDIA_DIR):
        shutil.rmtree(GENERATED_MEDIA_DIR)

    # This will make media_url() generate production URLs
    was_dev_mode = settings.MEDIA_DEV_MODE
    settings.MEDIA_DEV_MODE = False

    utils.NAMES = {}

    for backend_name in MEDIA_GENERATORS:
        backend = load_backend(backend_name)()
        for key, url, content in backend.get_output():
            version = backend.generate_version(key, url, content)
            if version:
                base, ext = os.path.splitext(url)
                url = '%s-%s%s' % (base, version, ext)

            path = os.path.join(GENERATED_MEDIA_DIR, url)
            parent = os.path.dirname(path)
            if not os.path.exists(parent):
                os.makedirs(parent)

            fp = open(path, 'wb')
            if isinstance(content, unicode):
                content = content.encode('utf8')
            fp.write(content)
            fp.close()

            utils.NAMES[key] = urlquote(url)

    settings.MEDIA_DEV_MODE = was_dev_mode

    # Generate a module with media file name mappings
    fp = open(GENERATED_MEDIA_NAMES_FILE, 'w')
    fp.write('NAMES = %r' % utils.NAMES)
    fp.close()

########NEW FILE########
__FILENAME__ = base
from django.utils.encoding import smart_str
from hashlib import sha1

class Generator(object):
    def generate_version(self, key, url, content):
        return sha1(smart_str(content)).hexdigest()

    def get_output(self):
        """
        Generates content for production mode.

        Yields tuples of the form:
        key, url, content

        Here, key must be the same as for get_dev_output_names().
        """
        for key, url, hash in self.get_dev_output_names():
            yield key, url, self.get_dev_output(url)[0]

    def get_dev_output(self, name):
        """
        Generates content for dev mode.

        Yields tuples of the form:
        content, mimetype
        """
        raise NotImplementedError()

    def get_dev_output_names(self):
        """
        Generates file names for dev mode.

        Yields tuples of the form:
        key, url, version_hash

        Here, key must be the same as for get_output_names().
        """
        raise NotImplementedError()

########NEW FILE########
__FILENAME__ = jinja2ext
from jinja2 import nodes, TemplateAssertionError, Markup as mark_safe
from jinja2.ext import Extension
from mediagenerator.generators.bundles.utils import _render_include_media

class MediaExtension(Extension):
    tags = set(['include_media'])

    def __init__(self, environment):
        self.environment = environment

    def parse(self, parser):
        token = parser.stream.next()
        args = [parser.parse_expression()]
        kwargs = []
        while parser.stream.current.type != 'block_end':
            if kwargs:
                parser.stream.expect('comma')

            if parser.stream.skip_if('colon'):
                break

            name = parser.stream.expect('name')
            if name.value in kwargs:
                parser.fail('variable %r defined twice.' %
                            name.value, name.lineno,
                            exc=TemplateAssertionError)
            parser.stream.expect('assign')
            key = name.value
            value = parser.parse_expression()
            kwargs.append(nodes.Keyword(key, value,
                                        lineno=value.lineno))
        return nodes.Output([self.call_method('_render', args, kwargs)]).set_lineno(token.lineno)

    def _render(self, bundle, **variation):
        return mark_safe(_render_include_media(bundle, variation))

########NEW FILE########
__FILENAME__ = jinja2install
from jinja2 import Environment
from mediagenerator.contrib.jinja2ext import MediaExtension
from mediagenerator.utils import media_url
env = Environment(extensions=[MediaExtension])
env.globals['media_url'] = media_url

########NEW FILE########
__FILENAME__ = clever
from mediagenerator.generators.bundles.base import Filter
from clevercss import convert

class CleverCSS(Filter):
    def __init__(self, **kwargs):
        super(CleverCSS, self).__init__(**kwargs)
        assert self.filetype == 'css', (
            'CleverCSS only supports compilation to css. '
            'The parent filter expects "%s".' % self.filetype)
        self.input_filetype = 'clevercss'

    def should_use_default_filter(self, ext):
        if ext == 'ccss':
            return False
        return super(CleverCSS, self).should_use_default_filter(ext)

    def get_output(self, variation):
        for input in self.get_input(variation):
            yield convert(input)

    def get_dev_output(self, name, variation):
        content = super(CleverCSS, self).get_dev_output(name, variation)
        return convert(content)

########NEW FILE########
__FILENAME__ = closure
from django.conf import settings
from django.utils.encoding import smart_str
from mediagenerator.generators.bundles.base import Filter

COMPILATION_LEVEL = getattr(settings, 'CLOSURE_COMPILATION_LEVEL',
                            'SIMPLE_OPTIMIZATIONS')

class Closure(Filter):
    def __init__(self, **kwargs):
        self.config(kwargs, compilation_level=COMPILATION_LEVEL)
        super(Closure, self).__init__(**kwargs)
        assert self.filetype == 'js', (
            'Closure only supports compilation to js. '
            'The parent filter expects "%s".' % self.filetype)

    def get_output(self, variation):
        # We import this here, so App Engine Helper users don't get import
        # errors.
        from subprocess import Popen, PIPE
        for input in self.get_input(variation):
            try:
                compressor = settings.CLOSURE_COMPILER_PATH
                cmd = Popen(['java', '-jar', compressor,
                             '--charset', 'utf-8',
                             '--compilation_level', self.compilation_level],
                            stdin=PIPE, stdout=PIPE, stderr=PIPE,
                            universal_newlines=True)
                output, error = cmd.communicate(smart_str(input))
                assert cmd.wait() == 0, 'Command returned bad result:\n%s' % error
                yield output.decode('utf-8')
            except Exception, e:
                raise ValueError("Failed to execute Java VM or Closure. "
                    "Please make sure that you have installed Java "
                    "and that it's in your PATH and that you've configured "
                    "CLOSURE_COMPILER_PATH in your settings correctly.\n"
                    "Error was: %s" % e)

########NEW FILE########
__FILENAME__ = coffeescript
from django.utils.encoding import smart_str
from hashlib import sha1
from mediagenerator.generators.bundles.base import Filter
from mediagenerator.utils import find_file, read_text_file
from subprocess import Popen, PIPE
import os
import sys

class CoffeeScript(Filter):
    takes_input = False

    def __init__(self, **kwargs):
        self.config(kwargs, module=None)
        super(CoffeeScript, self).__init__(**kwargs)
        assert self.filetype == 'js', (
            'CoffeeScript only supports compilation to js. '
            'The parent filter expects "%s".' % self.filetype)
        self._compiled = None
        self._compiled_hash = None
        self._mtime = None

    @classmethod
    def from_default(cls, name):
        return {'module': name}

    def get_output(self, variation):
        self._regenerate(debug=False)
        yield self._compiled

    def get_dev_output(self, name, variation):
        assert name == self.module
        self._regenerate(debug=True)
        return self._compiled

    def get_dev_output_names(self, variation):
        self._regenerate(debug=True)
        yield self.module, self._compiled_hash

    def _regenerate(self, debug=False):
        path = find_file(self.module)
        mtime = os.path.getmtime(path)
        if mtime == self._mtime:
            return
        source = read_text_file(path)
        self._compiled = self._compile(source, debug=debug)
        self._compiled_hash = sha1(smart_str(self._compiled)).hexdigest()
        self._mtime = mtime

    def _compile(self, input, debug=False):
        try:
            shell = sys.platform == 'win32'
            cmd = Popen(['coffee', '--compile', '--print', '--stdio', '--bare'],
                        stdin=PIPE, stdout=PIPE, stderr=PIPE,
                        shell=shell, universal_newlines=True)
            output, error = cmd.communicate(smart_str(input))
            assert cmd.wait() == 0, ('CoffeeScript command returned bad '
                                     'result:\n%s' % error)
            return output.decode('utf-8')
        except Exception, e:
            raise ValueError("Failed to run CoffeeScript compiler for this "
                "file. Please confirm that the \"coffee\" application is "
                "on your path and that you can run it from your own command "
                "line.\n"
                "Error was: %s" % e)

########NEW FILE########
__FILENAME__ = concat
from django.utils.encoding import smart_str
from hashlib import sha1
from mediagenerator.generators.bundles.base import Filter

class Concat(Filter):
    """
    Simply concatenates multiple files into a single file.

    This is also the default root filter.
    """
    def __init__(self, **kwargs):
        self.config(kwargs, concat_dev_output=False, dev_output_name='concat')
        super(Concat, self).__init__(**kwargs)

    def get_output(self, variation):
        yield '\n\n'.join(input for input in self.get_input(variation))

    def get_dev_output(self, name, variation):
        if not self.concat_dev_output:
            return super(Concat, self).get_dev_output(name, variation)
        assert self.dev_output_name == name
        names = super(Concat, self).get_dev_output_names(variation)
        return '\n\n'.join(super(Concat, self).get_dev_output(name[0], variation)
                           for name in names)

    def get_dev_output_names(self, variation):
        if not self.concat_dev_output:
            for data in super(Concat, self).get_dev_output_names(variation):
                yield data
            return
        content = self.get_dev_output(self.dev_output_name, variation)
        yield self.dev_output_name, sha1(smart_str(content)).hexdigest()

########NEW FILE########
__FILENAME__ = cssurl
from base64 import b64encode
from django.conf import settings
from mediagenerator.generators.bundles.base import Filter, FileFilter
from mediagenerator.utils import media_url, prepare_patterns, find_file
from mimetypes import guess_type
import logging
import os
import posixpath
import re

url_re = re.compile(r'url\s*\(["\']?([\w\.][^:]*?)["\']?\)', re.UNICODE)

# Whether to rewrite CSS URLs, at all
REWRITE_CSS_URLS = getattr(settings, 'REWRITE_CSS_URLS', True)
# Whether to rewrite CSS URLs relative to the respective source file
# or whether to use "absolute" URL rewriting (i.e., relative URLs are
# considered absolute with regards to STATICFILES_URL)
REWRITE_CSS_URLS_RELATIVE_TO_SOURCE = getattr(settings,
    'REWRITE_CSS_URLS_RELATIVE_TO_SOURCE', True)

GENERATE_DATA_URIS = getattr(settings, 'GENERATE_DATA_URIS', False)
MAX_DATA_URI_FILE_SIZE = getattr(settings, 'MAX_DATA_URI_FILE_SIZE', 12 * 1024)
IGNORE_PATTERN = prepare_patterns(getattr(settings,
   'IGNORE_DATA_URI_PATTERNS', (r'.*\.htc',)), 'IGNORE_DATA_URI_PATTERNS')

class URLRewriter(object):
    def __init__(self, base_path='./'):
        if not base_path:
            base_path = './'
        self.base_path = base_path

    def rewrite_urls(self, content):
        if not REWRITE_CSS_URLS:
            return content
        return url_re.sub(self.fixurls, content)

    def fixurls(self, match):
        url = match.group(1)

        hashid = ''
        if '#' in url:
            url, hashid = url.split('#', 1)
            hashid = '#' + hashid

        url_query = None
        if '?' in url:
            url, url_query = url.split('?', 1)

        if ':' not in url and not url.startswith('/'):
            rebased_url = posixpath.join(self.base_path, url)
            rebased_url = posixpath.normpath(rebased_url)
            try:
                if GENERATE_DATA_URIS:
                    path = find_file(rebased_url)
                    if os.path.getsize(path) <= MAX_DATA_URI_FILE_SIZE and \
                            not IGNORE_PATTERN.match(rebased_url):
                        data = b64encode(open(path, 'rb').read())
                        mime = guess_type(path)[0] or 'application/octet-stream'
                        return 'url(data:%s;base64,%s)' % (mime, data)
                url = media_url(rebased_url)
            except:
                logging.error('URL not found: %s' % url)

        if url_query is None:
            url_query = ''
        elif '?' in url:
            url_query = '&' + url_query
        else:
            url_query = '?' + url_query

        return 'url(%s%s%s)' % (url, url_query, hashid)

class CSSURL(Filter):
    """Rewrites URLs relative to media folder ("absolute" rewriting)."""
    def __init__(self, **kwargs):
        super(CSSURL, self).__init__(**kwargs)
        assert self.filetype == 'css', (
            'CSSURL only supports CSS output. '
            'The parent filter expects "%s".' % self.filetype)

    def get_output(self, variation):
        rewriter = URLRewriter()
        for input in self.get_input(variation):
            yield rewriter.rewrite_urls(input)

    def get_dev_output(self, name, variation):
        rewriter = URLRewriter()
        content = super(CSSURL, self).get_dev_output(name, variation)
        return rewriter.rewrite_urls(content)

class CSSURLFileFilter(FileFilter):
    """Rewrites URLs relative to input file's location."""
    def get_dev_output(self, name, variation):
        content = super(CSSURLFileFilter, self).get_dev_output(name, variation)
        if not REWRITE_CSS_URLS_RELATIVE_TO_SOURCE:
            return content
        rewriter = URLRewriter(posixpath.dirname(name))
        return rewriter.rewrite_urls(content)

########NEW FILE########
__FILENAME__ = i18n
from django.conf import settings
from django.http import HttpRequest
from django.utils.encoding import smart_str
from django.views.i18n import javascript_catalog
from hashlib import sha1
from mediagenerator.generators.bundles.base import Filter

if settings.USE_I18N:
    LANGUAGES = [code for code, _ in settings.LANGUAGES]
else:
    LANGUAGES = (settings.LANGUAGE_CODE,)

class I18N(Filter):
    takes_input = False

    def __init__(self, **kwargs):
        super(I18N, self).__init__(**kwargs)
        assert self.filetype == 'js', (
            'I18N only supports compilation to js. '
            'The parent filter expects "%s".' % self.filetype)

    def get_variations(self):
        return {'language': LANGUAGES}

    def get_output(self, variation):
        language = variation['language']
        yield self._generate(language)

    def get_dev_output(self, name, variation):
        language = variation['language']
        assert language == name
        return self._generate(language)

    def get_dev_output_names(self, variation):
        language = variation['language']
        content = self._generate(language)
        hash = sha1(smart_str(content)).hexdigest()
        yield language, hash

    def _generate(self, language):
        language_bidi = language.split('-')[0] in settings.LANGUAGES_BIDI
        request = HttpRequest()
        request.GET['language'] = language
        # Add some JavaScript data
        content = 'var LANGUAGE_CODE = "%s";\n' % language
        content += 'var LANGUAGE_BIDI = ' + \
            (language_bidi and 'true' or 'false') + ';\n'
        content += javascript_catalog(request,
            packages=settings.INSTALLED_APPS).content
        # The hgettext() function just calls gettext() internally, but
        # it won't get indexed by makemessages.
        content += '\nwindow.hgettext = function(text) { return gettext(text); };\n'
        # Add a similar hngettext() function
        content += 'window.hngettext = function(singular, plural, count) { return ngettext(singular, plural, count); };\n'
        return content

########NEW FILE########
__FILENAME__ = less
from django.utils.encoding import smart_str
from django.conf import settings
from hashlib import sha1
from mediagenerator.generators.bundles.base import Filter
from mediagenerator.utils import find_file, read_text_file, get_media_dirs
from subprocess import Popen, PIPE
import os
import sys
import re
import posixpath


_RE_FLAGS = re.MULTILINE | re.UNICODE
multi_line_comment_re = re.compile(r'/\*.*?\*/', _RE_FLAGS | re.DOTALL)
one_line_comment_re = re.compile(r'//.*', _RE_FLAGS)
import_re = re.compile(r'''@import\s*  # import keyword
                           ["']        # opening quote
                           (.+?)       # the module name
                           ["']        # closing quote
                           \s*;        # statement terminator
                           ''',
                       _RE_FLAGS | re.VERBOSE)

if not hasattr(os.path, 'relpath'):
    # backport os.path.relpath from Python 2.6
    # Copyright (c) 2001-2010 Python Software Foundation; All Rights Reserved

    # Return the longest prefix of all list elements.
    def commonprefix(m):
        "Given a list of pathnames, returns the longest common leading component"
        if not m: return ''
        s1 = min(m)
        s2 = max(m)
        for i, c in enumerate(s1):
            if c != s2[i]:
                return s1[:i]
        return s1

    def relpath(path, start=os.path.curdir):
        """Return a relative version of a path"""

        if not path:
            raise ValueError("no path specified")

        start_list = [x for x in os.path.abspath(start).split(os.path.sep) if x]
        path_list = [x for x in os.path.abspath(path).split(os.path.sep) if x]

        # Work out how much of the filepath is shared by start and path.
        i = len(commonprefix([start_list, path_list]))

        rel_list = [os.path.pardir] * (len(start_list)-i) + path_list[i:]
        if not rel_list:
            return os.path.curdir
        return os.path.join(*rel_list)

    os.path.relpath = relpath


class Less(Filter):
    takes_input = False

    def __init__(self, **kwargs):
        self.config(kwargs, path=(), main_module=None)
        if isinstance(self.path, basestring):
            self.path = (self.path,)

        # we need to be able to mutate self.path,
        self.path = list(self.path)

        super(Less, self).__init__(**kwargs)

        assert self.filetype == 'css', (
            'Less only supports compilation to CSS. '
            'The parent filter expects "%s".' % self.filetype)
        assert self.main_module, \
            'You must provide a main module'

        # lessc can't cope with nonexistent directories, so filter them
        media_dirs = [directory for directory in get_media_dirs()
                      if os.path.exists(directory)]
        self.path += tuple(media_dirs)

        self._compiled = None
        self._compiled_hash = None
        self._dependencies = {}

    @classmethod
    def from_default(cls, name):
        return {'main_module': name}

    def get_output(self, variation):
        self._regenerate(debug=False)
        yield self._compiled

    def get_dev_output(self, name, variation):
        assert name == self.main_module + '.css'
        self._regenerate(debug=True)
        return self._compiled

    def get_dev_output_names(self, variation):
        self._regenerate(debug=True)
        yield self.main_module + '.css', self._compiled_hash

    def _regenerate(self, debug=False):
        if self._dependencies:
            for name, mtime in self._dependencies.items():
                path = self._find_file(name)
                if not path or os.path.getmtime(path) != mtime:
                    # Just recompile everything
                    self._dependencies = {}
                    break
            else:
                # No changes
                return

        modules = [self.main_module]
        # get all the transitive dependencies of this module
        while True:
            if not modules:
                break

            module_name = modules.pop()
            path = self._find_file(module_name)
            assert path, 'Could not find the Less module %s' % module_name
            mtime = os.path.getmtime(path)
            self._dependencies[module_name] = mtime

            source = read_text_file(path)
            dependencies = self._get_dependencies(source)

            for name in dependencies:
                # Try relative import, first
                transformed = posixpath.join(posixpath.dirname(module_name), name)
                path = self._find_file(transformed)
                if path:
                    name = transformed
                else:
                    path = self._find_file(name)
                assert path, ('The Less module %s could not find the '
                              'dependency %s' % (module_name, name))
                if name not in self._dependencies:
                    modules.append(name)

        main_module_path = self._find_file(self.main_module)
        self._compiled = self._compile(main_module_path, debug=debug)
        self._compiled_hash = sha1(smart_str(self._compiled)).hexdigest()

    def _compile(self, path, debug=False):
        try:
            relative_paths = [self._get_relative_path(directory)
                              for directory in self.path]

            shell = sys.platform == 'win32'

            cmd = Popen(['lessc',
                         '--include-path=%s' % ':'.join(relative_paths),
                         path],
                        stdin=PIPE, stdout=PIPE, stderr=PIPE,
                        shell=shell, universal_newlines=True,
                        cwd=settings.PROJECT_ROOT)
            output, error = cmd.communicate()

            # some lessc errors output to stdout, so we put both in the assertion message
            assert cmd.wait() == 0, ('Less command returned bad '
                                     'result:\n%s\n%s' % (error, output))
            return output.decode('utf-8')
        except Exception, e:
            raise ValueError("Failed to run Less compiler for this "
                "file. Please confirm that the \"lessc\" application is "
                "on your path and that you can run it from your own command "
                "line.\n"
                "Error was: %s" % e)

    def _get_dependencies(self, source):
        clean_source = multi_line_comment_re.sub('\n', source)
        clean_source = one_line_comment_re.sub('', clean_source)

        return [name for name in import_re.findall(clean_source)
                if not name.endswith('.css')]

    def _find_file(self, name):
        if not name.endswith('.less'):
            name = name + '.less'

        return find_file(name, media_dirs=self.path)

    def _get_relative_path(self, abs_path):
        """Given an absolute path, return a path relative to the
        project root.

        >>> self._get_relative_path('/home/bob/bobs_project/subdir/foo')
        'subdir/foo'

        """
        relative_path = os.path.relpath(abs_path, settings.PROJECT_ROOT)
        return relative_path

########NEW FILE########
__FILENAME__ = media_url
from django.utils.encoding import smart_str
from django.utils.simplejson import dumps
from hashlib import sha1
from mediagenerator.generators.bundles.base import Filter
from mediagenerator.utils import get_media_url_mapping

_CODE = """
_$MEDIA_URLS = %s;

media_urls = function(key) {
  var urls = _$MEDIA_URLS[key];
  if (!urls)
    throw 'Could not resolve media url ' + key;
  return urls;
};

media_url = function(key) {
  var urls = media_urls(key);
  if (urls.length == 1)
    return urls[0];
  throw 'media_url() only works with keys that point to a single entry (e.g. an image), but not bundles. Use media_urls() instead.';
};
""".lstrip()

class MediaURL(Filter):
    takes_input = False

    def __init__(self, **kwargs):
        super(MediaURL, self).__init__(**kwargs)
        assert self.filetype == 'js', (
            'MediaURL only supports JS output. '
            'The parent filter expects "%s".' % self.filetype)

    def get_output(self, variation):
        yield self._compile()

    def get_dev_output(self, name, variation):
        assert name == '.media_url.js'
        return self._compile()

    def get_dev_output_names(self, variation):
        content = self._compile()
        hash = sha1(smart_str(content)).hexdigest()
        yield '.media_url.js', hash

    def _compile(self):
        return _CODE % dumps(get_media_url_mapping())

########NEW FILE########
__FILENAME__ = dynamic
# This is here because pyjslib.py imports the dynamic module.
# However, we've turned off dynamic module loading, so this module is empty.

########NEW FILE########
__FILENAME__ = getopt
# Unused dependency of base64 module

########NEW FILE########
__FILENAME__ = pyjs_filter
from django.utils.encoding import smart_str
from hashlib import sha1
from mediagenerator.generators.bundles.base import Filter
from mediagenerator.utils import get_media_dirs, read_text_file
from pyjs.translator import import_compiler, Translator, LIBRARY_PATH
from textwrap import dedent
import os
import sys

try:
    from cStringIO import StringIO
except ImportError:
    from StringIO import StringIO

# Register PYVA() function
try:
    from pyvascript.grammar import compile
    from pyjs.translator import native_js_func

    @native_js_func
    def PYVA(content, unescape, is_statement, **kwargs):
        result = compile(dedent(unescape(content)))
        if not is_statement:
            return result.strip().rstrip('\r\n\t ;')
        return result
except ImportError:
    # No PyvaScript installed
    pass

_HANDLE_EXCEPTIONS = """
  } finally { $pyjs.in_try_except -= 1; }
} catch(err) {
  pyjslib['_handle_exception'](err);
}
"""

PYJS_INIT_LIB_PATH = os.path.join(LIBRARY_PATH, 'builtin', 'public', '_pyjs.js')
BUILTIN_PATH = os.path.join(LIBRARY_PATH, 'builtin')
STDLIB_PATH = os.path.join(LIBRARY_PATH, 'lib')
EXTRA_LIBS_PATH = os.path.join(os.path.dirname(__file__), 'pyjslibs')

_LOAD_PYJSLIB = """

$p = $pyjs.loaded_modules["pyjslib"];
$p('pyjslib');
$pyjs.__modules__.pyjslib = $p['pyjslib']
"""

INIT_CODE = """
var $wnd = window;
var $doc = window.document;
var $pyjs = new Object();
var $p = null;
$pyjs.platform = 'safari';
$pyjs.global_namespace = this;
$pyjs.__modules__ = {};
$pyjs.modules_hash = {};
$pyjs.loaded_modules = {};
$pyjs.options = new Object();
$pyjs.options.arg_ignore = true;
$pyjs.options.arg_count = true;
$pyjs.options.arg_is_instance = true;
$pyjs.options.arg_instance_type = false;
$pyjs.options.arg_kwarg_dup = true;
$pyjs.options.arg_kwarg_unexpected_keyword = true;
$pyjs.options.arg_kwarg_multiple_values = true;
$pyjs.options.dynamic_loading = false;
$pyjs.trackstack = [];
$pyjs.track = {module:'__main__', lineno: 1};
$pyjs.trackstack.push($pyjs.track);
$pyjs.__active_exception_stack__ = null;
$pyjs.__last_exception_stack__ = null;
$pyjs.__last_exception__ = null;
$pyjs.in_try_except = 0;
""".lstrip()

class Pyjs(Filter):
    takes_input = False

    def __init__(self, **kwargs):
        self.config(kwargs, exclude_main_libs=False, main_module=None,
                    debug=None, path=(), only_dependencies=None)
        if isinstance(self.path, basestring):
            self.path = (self.path,)
        self.path += tuple(get_media_dirs())
        if self.only_dependencies is None:
            self.only_dependencies = bool(self.main_module)
        if self.only_dependencies:
            self.path += (STDLIB_PATH, BUILTIN_PATH, EXTRA_LIBS_PATH)
        super(Pyjs, self).__init__(**kwargs)
        assert self.filetype == 'js', (
            'Pyjs only supports compilation to js. '
            'The parent filter expects "%s".' % self.filetype)

        if self.only_dependencies:
            assert self.main_module, \
                'You must provide a main module in only_dependencies mode'

        self._compiled = {}
        self._collected = {}

    @classmethod
    def from_default(cls, name):
        return {'main_module': name.rsplit('.', 1)[0].replace('/', '.')}

    def get_output(self, variation):
        self._collect_all_modules()

        if not self.exclude_main_libs:
            yield self._compile_init()

        if self.only_dependencies:
            self._regenerate(dev_mode=False)
            for name in sorted(self._compiled.keys()):
                yield self._compiled[name][1]
        else:
            for name in sorted(self._collected.keys()):
                source = read_text_file(self._collected[name])
                yield self._compile(name, source, dev_mode=False)[0]

        yield self._compile_main(dev_mode=False)

    def get_dev_output(self, name, variation):
        self._collect_all_modules()

        name = name.split('/', 1)[-1]

        if name == '._pyjs.js':
            return self._compile_init()
        elif name == '.main.js':
            return self._compile_main(dev_mode=True)

        if self.only_dependencies:
            self._regenerate(dev_mode=True)
            return self._compiled[name][1]
        else:
            source = read_text_file(self._collected[name])
            return self._compile(name, source, dev_mode=True)[0]

    def get_dev_output_names(self, variation):
        self._collect_all_modules()

        if not self.exclude_main_libs:
            content = self._compile_init()
            hash = sha1(smart_str(content)).hexdigest()
            yield '._pyjs.js', hash

        if self.only_dependencies:
            self._regenerate(dev_mode=True)
            for name in sorted(self._compiled.keys()):
                yield name, self._compiled[name][2]
        else:
            for name in sorted(self._collected.keys()):
                yield name, None

        if self.main_module is not None or not self.exclude_main_libs:
            content = self._compile_main(dev_mode=True)
            hash = sha1(smart_str(content)).hexdigest()
            yield '.main.js', hash

    def _regenerate(self, dev_mode=False):
        # This function is only called in only_dependencies mode
        if self._compiled:
            for module_name, (mtime, content, hash) in self._compiled.items():
                if module_name not in self._collected or \
                        not os.path.exists(self._collected[module_name]) or \
                        os.path.getmtime(self._collected[module_name]) != mtime:
                    # Just recompile everything
                    # TODO: track dependencies and changes and recompile only
                    # what's necessary
                    self._compiled = {}
                    break
            else:
                # No changes
                return

        modules = [self.main_module, 'pyjslib']
        while True:
            if not modules:
                break

            module_name = modules.pop()
            path = self._collected[module_name]
            mtime = os.path.getmtime(path)

            source = read_text_file(path)

            try:
                content, py_deps, js_deps = self._compile(module_name, source, dev_mode=dev_mode)
            except:
                self._compiled = {}
                raise
            hash = sha1(smart_str(content)).hexdigest()
            self._compiled[module_name] = (mtime, content, hash)

            for name in py_deps:
                if name not in self._collected:
                    if '.' in name and name.rsplit('.', 1)[0] in self._collected:
                        name = name.rsplit('.', 1)[0]
                    else:
                        raise ImportError('The pyjs module %s could not find '
                            'the dependency %s' % (module_name, name))
                if name not in self._compiled:
                    modules.append(name)

    def _compile(self, name, source, dev_mode=False):
        if self.debug is None:
            debug = dev_mode
        else:
            debug = self.debug
        compiler = import_compiler(False)
        tree = compiler.parse(source)
        output = StringIO()
        translator = Translator(compiler, name, name, source, tree, output,
            # Debug options
            debug=debug, source_tracking=debug, line_tracking=debug,
            store_source=debug,
            # Speed and size optimizations
            function_argument_checking=debug, attribute_checking=False,
            inline_code=False, number_classes=False,
            # Sufficient Python conformance
            operator_funcs=True, bound_methods=True, descriptors=True,
        )
        return output.getvalue(), translator.imported_modules, translator.imported_js

    def _compile_init(self):
        return INIT_CODE + read_text_file(PYJS_INIT_LIB_PATH)

    def _compile_main(self, dev_mode=False):
        if self.debug is None:
            debug = dev_mode
        else:
            debug = self.debug
        content = ''
        if not self.exclude_main_libs:
            content += _LOAD_PYJSLIB
        if self.main_module is not None:
            content += '\n\n'
            if debug:
                content += 'try {\n'
                content += '  try {\n'
                content += '    $pyjs.in_try_except += 1;\n    '
            content += 'pyjslib.___import___("%s", null, "__main__");' % self.main_module
            if debug:
                content += _HANDLE_EXCEPTIONS
        return content

    def _collect_all_modules(self):
        """Collect modules, so we can handle imports later"""
        for pkgroot in self.path:
            pkgroot = os.path.abspath(pkgroot)

            #python 2.5 does not have the followlinks keyword argument
            has_followlinks = sys.version_info >= (2, 6)
            if has_followlinks:
                allfiles = os.walk(pkgroot, followlinks=True)
            else:
                allfiles = os.walk(pkgroot)

            for root, dirs, files in allfiles:
                if '__init__.py' in files:
                    files.remove('__init__.py')
                    # The root __init__.py is ignored
                    if root != pkgroot:
                        files.insert(0, '__init__.py')
                elif root != pkgroot:
                    # Only add valid Python packages
                    dirs[:] = []
                    continue

                for filename in files:
                    if not filename.endswith('.py'):
                        continue

                    path = os.path.join(root, filename)
                    if not has_followlinks:
                        path = os.path.abspath(path)
                    module_path = path[len(pkgroot) + len(os.sep):]
                    if os.path.basename(module_path) == '__init__.py':
                        module_name = os.path.dirname(module_path)
                    else:
                        module_name = module_path[:-3]
                    assert '.' not in module_name, \
                        'Invalid module file name: %s' % module_path
                    module_name = module_name.replace(os.sep, '.')

                    self._collected.setdefault(module_name, path)

########NEW FILE########
__FILENAME__ = pyvascript_filter
from mediagenerator.generators.bundles.base import Filter, RawFileFilter
from pyvascript.grammar import compile
import os
import pyvascript

class PyvaScript(Filter):
    def __init__(self, **kwargs):
        super(PyvaScript, self).__init__(**kwargs)
        assert self.filetype == 'js', (
            'PyvaScript only supports compilation to js. '
            'The parent filter expects "%s".' % self.filetype)
        self.input_filetype = 'pyvascript'

    def should_use_default_filter(self, ext):
        if ext == 'pyva':
            return False
        return super(PyvaScript, self).should_use_default_filter(ext)

    def get_output(self, variation):
        for input in self.get_input(variation):
            yield compile(input)

    def get_dev_output(self, name, variation):
        content = super(PyvaScript, self).get_dev_output(name, variation)
        return compile(content)

    def get_item(self, name):
        if name == '.stdlib.pyva':
            path = os.path.join(os.path.dirname(pyvascript.__file__),
                                'stdlib.pyva')
            return RawFileFilter(name='.stdlib.pyva', path=path)
        return super(PyvaScript, self).get_item(name)

########NEW FILE########
__FILENAME__ = sass
from django.conf import settings
from django.utils.encoding import smart_str
from hashlib import sha1
from mediagenerator.generators.bundles.base import Filter
from mediagenerator.utils import get_media_dirs, find_file, read_text_file
from subprocess import Popen, PIPE
import os
import posixpath
import re
import sys

# Emits extra debug info that can be used by the FireSass Firebug plugin
SASS_DEBUG_INFO = getattr(settings, 'SASS_DEBUG_INFO', False)
SASS_FRAMEWORKS = getattr(settings, 'SASS_FRAMEWORKS',
                          ('compass', 'blueprint'))
if isinstance(SASS_FRAMEWORKS, basestring):
    SASS_FRAMEWORKS = (SASS_FRAMEWORKS,)

_RE_FLAGS = re.MULTILINE | re.UNICODE
multi_line_comment_re = re.compile(r'/\*.*?\*/', _RE_FLAGS | re.DOTALL)
one_line_comment_re = re.compile(r'//.*', _RE_FLAGS)
import_re = re.compile(r'^@import\s+["\']?(.+?)["\']?\s*;?\s*$', _RE_FLAGS)

class Sass(Filter):
    takes_input = False

    def __init__(self, **kwargs):
        self.config(kwargs, path=(), main_module=None)
        if isinstance(self.path, basestring):
            self.path = (self.path,)
        super(Sass, self).__init__(**kwargs)
        assert self.filetype == 'css', (
            'Sass only supports compilation to css. '
            'The parent filter expects "%s".' % self.filetype)
        assert self.main_module, \
            'You must provide a main module'

        self.path += tuple(get_media_dirs())
        self.path_args = []
        for path in self.path:
            self.path_args.extend(('-I', path.replace('\\', '/')))

        self._compiled = None
        self._compiled_hash = None
        self._dependencies = {}

    @classmethod
    def from_default(cls, name):
        return {'main_module': name}

    def get_output(self, variation):
        self._regenerate(debug=False)
        yield self._compiled

    def get_dev_output(self, name, variation):
        assert name == self.main_module
        self._regenerate(debug=True)
        return self._compiled

    def get_dev_output_names(self, variation):
        self._regenerate(debug=True)
        yield self.main_module, self._compiled_hash

    def _compile(self, debug=False):
        extensions = os.path.join(os.path.dirname(__file__), 'sass_compass.rb')
        extensions = extensions.replace('\\', '/')
        run = ['sass', '-C', '-t', 'expanded',
               '--require', extensions]
        for framework in SASS_FRAMEWORKS:
            # Some frameworks are loaded by default
            if framework in ('blueprint', 'compass'):
                continue
            run.extend(('--require', framework))
        if debug:
            run.append('--line-numbers')
            if SASS_DEBUG_INFO:
                run.append('--debug-info')
        run.extend(self.path_args)
        shell = sys.platform == 'win32'
        try:
            cmd = Popen(run, shell=shell, universal_newlines=True,
                        stdin=PIPE, stdout=PIPE, stderr=PIPE)
            module = self.main_module.rsplit('.', 1)[0]
            output, error = cmd.communicate('@import "%s"' % module)
            assert cmd.wait() == 0, 'Command returned bad result:\n%s' % error
            output = output.decode('utf-8')
            if output.startswith('@charset '):
                output = output.split(';', 1)[1]
            return output
        except Exception, e:
            raise ValueError("Failed to execute Sass. Please make sure that "
                "you have installed Sass (http://sass-lang.com) and "
                "Compass (http://compass-style.org).\n"
                "Error was: %s" % e)

    def _regenerate(self, debug=False):
        if self._dependencies:
            for name, mtime in self._dependencies.items():
                path = self._find_file(name)
                if not path or os.path.getmtime(path) != mtime:
                    # Just recompile everything
                    self._dependencies = {}
                    break
            else:
                # No changes
                return

        modules = [self.main_module]
        while True:
            if not modules:
                break

            module_name = modules.pop()
            path = self._find_file(module_name)
            assert path, 'Could not find the Sass module %s' % module_name
            mtime = os.path.getmtime(path)
            self._dependencies[module_name] = mtime

            source = read_text_file(path)
            dependencies = self._get_dependencies(source)

            for name in dependencies:
                # Try relative import, first
                transformed = posixpath.join(posixpath.dirname(module_name), name)
                path = self._find_file(transformed)
                if path:
                    name = transformed
                else:
                    path = self._find_file(name)
                assert path, ('The Sass module %s could not find the '
                              'dependency %s' % (module_name, name))
                if name not in self._dependencies:
                    modules.append(name)

        self._compiled = self._compile(debug=debug)
        self._compiled_hash = sha1(smart_str(self._compiled)).hexdigest()

    def _get_dependencies(self, source):
        clean_source = multi_line_comment_re.sub('\n', source)
        clean_source = one_line_comment_re.sub('', clean_source)
        return [name for name in import_re.findall(clean_source)
                if not name.endswith('.css')]

    def _find_file(self, name):
        parts = name.rsplit('/', 1)
        parts[-1] = '_' + parts[-1]
        partial = '/'.join(parts)
        if not name.endswith(('.sass', '.scss')):
            names = (name + '.sass', name + '.scss', partial + '.sass',
                     partial + '.scss')
        else:
            names = (name, partial)
        for name in names:
            path = find_file(name, media_dirs=self.path)
            if path:
                return path

########NEW FILE########
__FILENAME__ = template
from django.template import Context, Template as DjangoTemplate
from mediagenerator.generators.bundles.base import Filter

class Template(Filter):
    def __init__(self, **kwargs):
        super(Template, self).__init__(**kwargs)

    def get_output(self, variation):
        for input in self.get_input(variation):
            yield self._template(input)

    def get_dev_output(self, name, variation):
        content = super(Template, self).get_dev_output(name, variation)
        return self._template(content)

    def _template(self, content):
        context = Context({})
        context.autoescape = self.filetype == 'html'
        return DjangoTemplate(content).render(context)

########NEW FILE########
__FILENAME__ = yuicompressor
from django.conf import settings
from django.utils.encoding import smart_str
from mediagenerator.generators.bundles.base import Filter

class YUICompressor(Filter):
    def __init__(self, **kwargs):
        super(YUICompressor, self).__init__(**kwargs)
        assert self.filetype in ('css', 'js'), (
            'YUICompressor only supports compilation to css and js. '
            'The parent filter expects "%s".' % self.filetype)

    def get_output(self, variation):
        # We import this here, so App Engine Helper users don't get import
        # errors.
        from subprocess import Popen, PIPE
        for input in self.get_input(variation):
            try:
                compressor = settings.YUICOMPRESSOR_PATH
                cmd = Popen(['java', '-jar', compressor,
                             '--charset', 'utf-8', '--type', self.filetype],
                            stdin=PIPE, stdout=PIPE, stderr=PIPE,
                            universal_newlines=True)
                output, error = cmd.communicate(smart_str(input))
                assert cmd.wait() == 0, 'Command returned bad result:\n%s' % error
                yield output.decode('utf-8')
            except Exception, e:
                raise ValueError("Failed to execute Java VM or yuicompressor. "
                    "Please make sure that you have installed Java "
                    "and that it's in your PATH and that you've configured "
                    "YUICOMPRESSOR_PATH in your settings correctly.\n"
                    "Error was: %s" % e)

########NEW FILE########
__FILENAME__ = base
from .settings import DEFAULT_MEDIA_FILTERS
from django.utils.encoding import smart_str
from hashlib import sha1
from mediagenerator.utils import load_backend, find_file, read_text_file
import os

class Filter(object):
    takes_input = True

    def __init__(self, **kwargs):
        self.file_filter = FileFilter
        self.config(kwargs, filetype=None, filter=None,
                            bundle=None, _from_default=None)

        # We assume that if this is e.g. a 'js' backend then all input must
        # also be 'js'. Subclasses must override this if they expect a special
        # input file type. Also, subclasses have to check if their file type
        # is supported.
        self.input_filetype = self.filetype

        if self.takes_input:
            self.config(kwargs, input=())
            if not isinstance(self.input, (tuple, list)):
                self.input = (self.input,)
        self._input_filters = None
        assert not kwargs, 'Unknown parameters: %s' % ', '.join(kwargs.keys())

    @classmethod
    def from_default(cls, name):
        return {'input': name}

    def should_use_default_filter(self, ext):
        return ext != self._from_default

    def get_variations(self):
        """
        Returns all possible variations that get generated by this filter.

        The result must be a dict whose values are tuples.
        """
        return {}

    def get_output(self, variation):
        """
        Yields content for each output item for the given variation.
        """
        raise NotImplementedError()

    def get_dev_output(self, name, variation):
        """
        Returns content for the given file name and variation in development mode.
        """
        index, child = name.split('/', 1)
        index = int(index)
        filter = self.get_input_filters()[index]
        return filter.get_dev_output(child, variation)

    def get_dev_output_names(self, variation):
        """
        Yields file names for the given variation in development mode.
        """
        # By default we simply return our input filters' file names
        for index, filter in enumerate(self.get_input_filters()):
            for name, hash in filter.get_dev_output_names(variation):
                yield '%d/%s' % (index, name), hash

    def get_input(self, variation):
        """Yields contents for each input item."""
        for filter in self.get_input_filters():
            for input in filter.get_output(variation):
                yield input

    def get_input_filters(self):
        """Returns a Filter instance for each input item."""
        if not self.takes_input:
            raise ValueError("The %s media filter doesn't take any input" %
                             self.__class__.__name__)
        if self._input_filters is not None:
            return self._input_filters
        self._input_filters = []
        for input in self.input:
            if isinstance(input, dict):
                filter = self.get_filter(input)
            else:
                filter = self.get_item(input)
            self._input_filters.append(filter)
        return self._input_filters

    def get_filter(self, config):
        backend_class = load_backend(config.get('filter'))
        return backend_class(filetype=self.input_filetype, bundle=self.bundle,
                             **config)

    def get_item(self, name):
        ext = os.path.splitext(name)[1].lstrip('.')
        if ext in DEFAULT_MEDIA_FILTERS and self.should_use_default_filter(ext):
            backend_class = load_backend(DEFAULT_MEDIA_FILTERS[ext])
        else:
            backend_class = self.file_filter

        config = backend_class.from_default(name)
        config.setdefault('filter',
            '%s.%s' % (backend_class.__module__, backend_class.__name__))
        config.setdefault('filetype', self.input_filetype)
        config['bundle'] = self.bundle
        # This is added to make really sure we don't instantiate the same
        # filter in an endless loop. Normally, the child class should
        # take care of this in should_use_default_filter().
        config.setdefault('_from_default', ext)
        return backend_class(**config)

    def _get_variations_with_input(self):
        """Utility function to get variations including input variations"""
        variations = self.get_variations()
        if not self.takes_input:
            return variations

        for filter in self.get_input_filters():
            subvariations = filter._get_variations_with_input()
            for k, v in subvariations.items():
                if k in variations and v != variations[k]:
                    raise ValueError('Conflicting variations for "%s": %r != %r' % (
                        k, v, variations[k]))
            variations.update(subvariations)
        return variations

    def config(self, init, **defaults):
        for key in defaults:
            setattr(self, key, init.pop(key, defaults[key]))

class FileFilter(Filter):
    """A filter that just returns the given file."""
    takes_input = False

    def __init__(self, **kwargs):
        self.config(kwargs, name=None)
        self.mtime = self.hash = None
        super(FileFilter, self).__init__(**kwargs)

    @classmethod
    def from_default(cls, name):
        return {'name': name}

    def get_output(self, variation):
        yield self.get_dev_output(self.name, variation)

    def get_dev_output(self, name, variation):
        assert name == self.name, (
            '''File name "%s" doesn't match the one in GENERATE_MEDIA ("%s")'''
            % (name, self.name))
        return read_text_file(self._get_path())

    def get_dev_output_names(self, variation):
        path = self._get_path()
        mtime = os.path.getmtime(path)
        if mtime != self.mtime:
            output = self.get_dev_output(self.name, variation)
            hash = sha1(smart_str(output)).hexdigest()
        else:
            hash = self.hash
        yield self.name, hash

    def _get_path(self):
        path = find_file(self.name)
        assert path, """File name "%s" doesn't exist.""" % self.name
        return path

class RawFileFilter(FileFilter):
    takes_input = False

    def __init__(self, **kwargs):
        self.config(kwargs, path=None)
        super(RawFileFilter, self).__init__(**kwargs)

    def get_dev_output(self, name, variation):
        assert name == self.name, (
            '''File name "%s" doesn't match the one in GENERATE_MEDIA ("%s")'''
            % (name, self.name))
        return read_text_file(self.path)

    def get_dev_output_names(self, variation):
        mtime = os.path.getmtime(self.path)
        if mtime != self.mtime:
            output = self.get_dev_output(self.name, variation)
            hash = sha1(smart_str(output)).hexdigest()
        else:
            hash = self.hash
        yield self.name, hash

########NEW FILE########
__FILENAME__ = bundles
from .settings import MEDIA_BUNDLES
from .utils import _load_root_filter, _get_key
try:
    from itertools import product
except ImportError:
    try:
        from django.utils.itercompat import product
    except ImportError:
        # Needed for Django 1.0 and 1.1 support.
        # TODO/FIXME: Remove this when nobody uses Django 1.0/1.1, anymore.
        from .itercompat import product
from mediagenerator.base import Generator
from mimetypes import guess_type
import os

class Bundles(Generator):
    def get_output(self):
        for items in MEDIA_BUNDLES:
            bundle = items[0]
            backend = _load_root_filter(bundle)
            variations = backend._get_variations_with_input()
            if not variations:
                name, content = self.generate_file(backend, bundle, {})
                yield _get_key(bundle), name, content
            else:
                # Generate media files for all variation combinations
                combinations = product(*(variations[key]
                                         for key in sorted(variations.keys())))
                for combination in combinations:
                    variation_map = zip(sorted(variations.keys()), combination)
                    variation = dict(variation_map)
                    name, content = self.generate_file(backend, bundle,
                                                       variation, combination)

                    key = _get_key(bundle, variation_map)
                    yield key, name, content

    def get_dev_output(self, name):
        bundle_combination, path = name.split('|', 1)
        parts = bundle_combination.split('--')
        bundle = parts[0]
        combination = parts[1:]
        root = _load_root_filter(bundle)
        variations = root._get_variations_with_input()
        variation = dict(zip(sorted(variations.keys()), combination))
        content = root.get_dev_output(path, variation)
        mimetype = guess_type(bundle)[0]
        return content, mimetype

    def get_dev_output_names(self):
        for items in MEDIA_BUNDLES:
            bundle = items[0]
            backend = _load_root_filter(bundle)
            variations = backend._get_variations_with_input()
            if not variations:
                for name, hash in backend.get_dev_output_names({}):
                    url = '%s|%s' % (bundle, name)
                    yield _get_key(bundle), url, hash
            else:
                # Generate media files for all variation combinations
                combinations = product(*(variations[key]
                                         for key in sorted(variations.keys())))
                for combination in combinations:
                    variation_map = zip(sorted(variations.keys()), combination)
                    variation = dict(variation_map)
                    for name, hash in backend.get_dev_output_names(variation):
                        url = '%s--%s|%s' % (bundle, '--'.join(combination), name)
                        yield _get_key(bundle, variation_map), url, hash

    def generate_file(self, backend, bundle, variation, combination=()):
        print 'Generating %s with variation %r' % (bundle, variation)
        output = list(backend.get_output(variation))
        if len(output) == 0:
            output = ('',)
        assert len(output) == 1, \
            'Media bundle "%s" would result in multiple output files' % bundle
        content = output[0]

        combination = '--'.join(combination)
        if combination:
            combination = '--' + combination

        base, ext = os.path.splitext(bundle)
        filename = base + combination + ext
        return filename, content

########NEW FILE########
__FILENAME__ = itercompat
def product(*args, **kwds):
    """
    Taken from http://docs.python.org/library/itertools.html#itertools.product
    """
    # product('ABCD', 'xy') --> Ax Ay Bx By Cx Cy Dx Dy
    # product(range(2), repeat=3) --> 000 001 010 011 100 101 110 111
    pools = map(tuple, args) * kwds.get('repeat', 1)
    result = [[]]
    for pool in pools:
        result = [x + [y] for x in result for y in pool]
    for prod in result:
        yield tuple(prod)

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings

DEFAULT_MEDIA_FILTERS = getattr(settings, 'DEFAULT_MEDIA_FILTERS', {
    'ccss': 'mediagenerator.filters.clever.CleverCSS',
    'coffee': 'mediagenerator.filters.coffeescript.CoffeeScript',
    'css': 'mediagenerator.filters.cssurl.CSSURLFileFilter',
    'html': 'mediagenerator.filters.template.Template',
    'py': 'mediagenerator.filters.pyjs_filter.Pyjs',
    'pyva': 'mediagenerator.filters.pyvascript_filter.PyvaScript',
    'sass': 'mediagenerator.filters.sass.Sass',
    'scss': 'mediagenerator.filters.sass.Sass',
    'less': 'mediagenerator.filters.less.Less',
})

ROOT_MEDIA_FILTERS = getattr(settings, 'ROOT_MEDIA_FILTERS', {})

# These are applied in addition to ROOT_MEDIA_FILTERS.
# The separation is done because we don't want users to
# always specify the default filters when they merely want
# to configure YUICompressor or Closure.
BASE_ROOT_MEDIA_FILTERS = getattr(settings, 'BASE_ROOT_MEDIA_FILTERS', {
    '*': 'mediagenerator.filters.concat.Concat',
    'css': 'mediagenerator.filters.cssurl.CSSURL',
})

MEDIA_BUNDLES = getattr(settings, 'MEDIA_BUNDLES', ())

########NEW FILE########
__FILENAME__ = utils
from .settings import ROOT_MEDIA_FILTERS, MEDIA_BUNDLES, BASE_ROOT_MEDIA_FILTERS
from mediagenerator.settings import MEDIA_DEV_MODE
from mediagenerator.utils import load_backend, media_urls
import os

_cache = {}

def _load_root_filter(bundle):
    if bundle not in _cache:
        _cache[bundle] = _load_root_filter_uncached(bundle)
    return _cache[bundle]

def _get_root_filters_list(filetype):
    root_filters = ()
    filetypes = (filetype, '*')
    for filters_spec in (BASE_ROOT_MEDIA_FILTERS, ROOT_MEDIA_FILTERS):
        for filetype in filetypes:
            filters = filters_spec.get(filetype, ())
            if not isinstance(filters, (tuple, list)):
                filters = (filters, )
            root_filters += tuple(filters)
    return root_filters

def _load_root_filter_uncached(bundle):
    for items in MEDIA_BUNDLES:
        if items[0] == bundle:
            input = items[1:]
            break
    else:
        raise ValueError('Could not find media bundle "%s"' % bundle)
    filetype = os.path.splitext(bundle)[-1].lstrip('.')
    root_filters = _get_root_filters_list(filetype)
    backend_class = load_backend(root_filters[-1])
    for filter in reversed(root_filters[:-1]):
        input = [{'filter': filter, 'input': input}]

    return backend_class(filter=root_filters[-1], filetype=filetype,
                         bundle=bundle, input=input)

def _get_key(bundle, variation_map=None):
    if variation_map:
        bundle += '?' + '&'.join('='.join(item) for item in variation_map)
    return bundle

def _render_include_media(bundle, variation):
    variation = variation.copy()
    filetype = os.path.splitext(bundle)[-1].lstrip('.')

    # The "media" variation is special and defines CSS media types
    media_types = None
    if filetype == 'css':
        media_types = variation.pop('media', None)

    if MEDIA_DEV_MODE:
        root = _load_root_filter(bundle)
        variations = root._get_variations_with_input()
        variation_map = [(key, variation.pop(key))
                         for key in sorted(variations.keys())]
        if variation:
            raise ValueError('Bundle %s does not support the following variation(s): %s'
                             % (bundle, ', '.join(variation.keys())))
    else:
        variation_map = tuple((key, variation[key])
                              for key in sorted(variation.keys()))

    urls = media_urls(_get_key(bundle, variation_map))

    if filetype == 'css':
        if media_types:
            tag = u'<link rel="stylesheet" type="text/css" href="%%s" media="%s" />' % media_types
        else:
            tag = u'<link rel="stylesheet" type="text/css" href="%s" />'
    elif filetype == 'js':
        tag = u'<script type="text/javascript" src="%s"></script>'
    else:
        raise ValueError("""Don't know how to include file type "%s".""" % filetype)

    return '\n'.join(tag % url for url in urls)

########NEW FILE########
__FILENAME__ = copyfiles
from django.conf import settings
from hashlib import sha1
from mediagenerator.base import Generator
from mediagenerator.utils import get_media_dirs, find_file, prepare_patterns
from mimetypes import guess_type
import os
import sys

COPY_MEDIA_FILETYPES = getattr(settings, 'COPY_MEDIA_FILETYPES',
    ('gif', 'jpg', 'jpeg', 'png', 'svg', 'svgz', 'ico', 'swf', 'ttf', 'otf',
     'eot', 'woff'))

IGNORE_PATTERN = prepare_patterns(getattr(settings,
   'IGNORE_MEDIA_COPY_PATTERNS', ()), 'IGNORE_MEDIA_COPY_PATTERNS')


class CopyFiles(Generator):
    def get_dev_output(self, name):
        path = find_file(name)
        fp = open(path, 'rb')
        content = fp.read()
        fp.close()
        mimetype = guess_type(path)[0]
        return content, mimetype

    def get_dev_output_names(self):
        media_files = {}
        for root in get_media_dirs():
            self.collect_copyable_files(media_files, root)

        for name, source in media_files.items():
            fp = open(source, 'rb')
            hash = sha1(fp.read()).hexdigest()
            fp.close()
            yield name, name, hash

    def collect_copyable_files(self, media_files, root):
        #python 2.5 does not have the followlinks keyword argument
        has_followlinks = sys.version_info >= (2, 6)
        if has_followlinks:
            allfiles = os.walk(root, followlinks=True)
        else:
            allfiles = os.walk(root)

        for root_path, dirs, files in allfiles:
            for file in files:
                ext = os.path.splitext(file)[1].lstrip('.')
                path = os.path.join(root_path, file)
                if not has_followlinks:
                    path = os.path.abspath(path)
                media_path = path[len(root) + 1:].replace(os.sep, '/')
                if ext in COPY_MEDIA_FILETYPES and \
                        not IGNORE_PATTERN.match(media_path):
                    media_files[media_path] = path

########NEW FILE########
__FILENAME__ = manifest
from django.conf import settings
from django.template.loader import render_to_string
from mediagenerator.base import Generator
from mediagenerator.utils import get_media_mapping, prepare_patterns

OFFLINE_MANIFEST = getattr(settings, 'OFFLINE_MANIFEST', {})
if isinstance(OFFLINE_MANIFEST, basestring):
    OFFLINE_MANIFEST = {OFFLINE_MANIFEST: '.*'}

def get_tuple(data, name, default=()):
    result = data.get(name, default)
    if isinstance(result, basestring):
        return (result,)
    return result

class Manifest(Generator):
    def generate_version(self, key, url, content):
        return None

    def get_dev_output(self, name):
        config = OFFLINE_MANIFEST[name]
        if isinstance(config, (tuple, list)):
            config = {'cache': config}
        elif isinstance(config, basestring):
            config = {'cache': (config,)}

        cache_pattern = prepare_patterns(get_tuple(config, 'cache', '.*'),
                                         'OFFLINE_MANIFEST[%s]' % name)
        exclude = prepare_patterns(get_tuple(config, 'exclude'),
                                   "OFFLINE_MANIFEST[%s]['exclude']" % name)
        cache = set()
        for item in get_media_mapping().keys():
            if cache_pattern.match(item) and not exclude.match(item):
                cache.add(item)
        cache -= set(OFFLINE_MANIFEST.keys())

        network = get_tuple(config, 'network', ('*',))
        fallback = get_tuple(config, 'fallback')

        template = get_tuple(config, 'template') + (
            'mediagenerator/manifest/' + name,
            'mediagenerator/manifest/base.manifest'
        )

        content = render_to_string(template, {
            'cache': cache, 'network': network, 'fallback': fallback,
        })
        return content, 'text/cache-manifest'

    def get_dev_output_names(self):
        for name in OFFLINE_MANIFEST:
            yield name, name, None

########NEW FILE########
__FILENAME__ = generatemedia
from ...api import generate_media
from django.core.management.base import NoArgsCommand

class Command(NoArgsCommand):
    help = 'Combines and compresses your media files and saves them in _generated_media.'

    requires_model_validation = False

    def handle_noargs(self, **options):
        generate_media()

########NEW FILE########
__FILENAME__ = importsassframeworks
from ...filters import sass
from ...utils import get_media_dirs
from django.conf import settings
from django.core.management.base import NoArgsCommand
from subprocess import Popen, PIPE
import os
import shutil
import sys
import __main__

_frameworks_dir = 'imported-sass-frameworks'
if hasattr(__main__, '__file__'):
    _root = os.path.dirname(__main__.__file__)
    _frameworks_dir = os.path.join(_root, _frameworks_dir)
FRAMEWORKS_DIR = getattr(settings, 'IMPORTED_SASS_FRAMEWORKS_DIR',
                         _frameworks_dir)
FRAMEWORKS_DIR = os.path.normcase(os.path.abspath(FRAMEWORKS_DIR))

PATHS_SCRIPT = getattr(settings, 'SASS_PATHS_RB_SCRIPT',
                       os.path.join(os.path.dirname(sass.__file__),
                                    'sass_paths.rb'))


def copy_children(src, dst):
    for item in os.listdir(src):
        path = os.path.join(src, item)
        copy_fs_node(path, dst)

def copy_fs_node(src, dst):
    basename = os.path.basename(src)
    dst = os.path.join(dst, basename)
    if os.path.isfile(src):
        shutil.copy(src, dst)
    elif os.path.isdir(src):
        shutil.copytree(src, dst)
    else:
        raise ValueError("Don't know how to copy file system node: %s" % src)

class Command(NoArgsCommand):
    help = 'Copies Sass/Compass frameworks into the current project.'

    requires_model_validation = False

    def handle_noargs(self, **options):
        if os.path.exists(FRAMEWORKS_DIR):
            shutil.rmtree(FRAMEWORKS_DIR)
        os.mkdir(FRAMEWORKS_DIR)
        for path in self.get_framework_paths():
            copy_children(path, FRAMEWORKS_DIR)

        if FRAMEWORKS_DIR not in get_media_dirs():
            sys.stderr.write('Please add the "%(dir)s" '
                             'folder to your GLOBAL_MEDIA_DIRS setting '
                             'like this:\n\n'
                             'GLOBAL_MEDIA_DIRS = (\n'
                             '    ...\n'
                             "    os.path.join(os.path.dirname(__file__),\n"
                             "                 '%(dir)s'),\n"
                             "    ...\n"
                             ")\n" % {'dir': os.path.basename(FRAMEWORKS_DIR)})

    def get_framework_paths(self):
        run = ['ruby', PATHS_SCRIPT]
        run.extend(sass.SASS_FRAMEWORKS)
        try:
            cmd = Popen(run, universal_newlines=True,
                        stdin=PIPE, stdout=PIPE, stderr=PIPE)
            output, error = cmd.communicate()
            assert cmd.wait() == 0, 'Command returned bad result:\n%s' % error
            return map(os.path.abspath, filter(None, output.split('\n')))
        except Exception, e:
            raise ValueError("Failed to execute an internal Ruby script. "
                "Please make sure that you have installed Ruby "
                "(http://ruby-lang.org), Sass (http://sass-lang.com), and "
                "Compass (http://compass-style.org).\n"
                "Error was: %s" % e)

########NEW FILE########
__FILENAME__ = middleware
from .settings import DEV_MEDIA_URL, MEDIA_DEV_MODE
# Only load other dependencies if they're needed
if MEDIA_DEV_MODE:
    from .utils import _refresh_dev_names, _backend_mapping
    from django.http import HttpResponse, Http404
    from django.utils.cache import patch_cache_control
    from django.utils.http import http_date
    import time

TEXT_MIME_TYPES = (
    'application/x-javascript',
    'application/xhtml+xml',
    'application/xml',
)

class MediaMiddleware(object):
    """
    Middleware for serving and browser-side caching of media files.

    This MUST be your *first* entry in MIDDLEWARE_CLASSES. Otherwise, some
    other middleware might add ETags or otherwise manipulate the caching
    headers which would result in the browser doing unnecessary HTTP
    roundtrips for unchanged media.
    """

    MAX_AGE = 60 * 60 * 24 * 365

    def process_request(self, request):
        if not MEDIA_DEV_MODE:
            return

        # We refresh the dev names only once for the whole request, so all
        # media_url() calls are cached.
        _refresh_dev_names()

        if not request.path.startswith(DEV_MEDIA_URL):
            return

        filename = request.path[len(DEV_MEDIA_URL):]

        try:
            backend = _backend_mapping[filename]
        except KeyError:
            raise Http404('The mediagenerator could not find the media file "%s"'
                          % filename)
        content, mimetype = backend.get_dev_output(filename)
        if not mimetype:
            mimetype = 'application/octet-stream'
        if isinstance(content, unicode):
            content = content.encode('utf-8')
        if mimetype.startswith('text/') or mimetype in TEXT_MIME_TYPES:
            mimetype += '; charset=utf-8'
        response = HttpResponse(content, content_type=mimetype)
        response['Content-Length'] = len(content)

        # Cache manifest files MUST NEVER be cached or you'll be unable to update
        # your cached app!!!
        if response['Content-Type'] != 'text/cache-manifest' and \
                response.status_code == 200:
            patch_cache_control(response, public=True, max_age=self.MAX_AGE)
            response['Expires'] = http_date(time.time() + self.MAX_AGE)
        return response

########NEW FILE########
__FILENAME__ = settings
from django.conf import settings
from django.utils.encoding import force_unicode
import os
import sys

__main__ = sys.modules.get('__main__')

_map_file_path = '_generated_media_names.py'
_media_dir = '_generated_media'
# __main__ is not guaranteed to have the __file__ attribute
if hasattr(__main__, '__file__'):
    _root = os.path.dirname(__main__.__file__)
    _map_file_path = os.path.join(_root, _map_file_path)
    _media_dir = os.path.join(_root, _media_dir)
GENERATED_MEDIA_DIR = os.path.abspath(
    getattr(settings, 'GENERATED_MEDIA_DIR', _media_dir))
GENERATED_MEDIA_NAMES_MODULE = getattr(settings, 'GENERATED_MEDIA_NAMES_MODULE',
                                       '_generated_media_names')
GENERATED_MEDIA_NAMES_FILE = os.path.abspath(
    getattr(settings, 'GENERATED_MEDIA_NAMES_FILE', _map_file_path))

DEV_MEDIA_URL = getattr(settings, 'DEV_MEDIA_URL',
                        getattr(settings, 'STATIC_URL', settings.MEDIA_URL))
PRODUCTION_MEDIA_URL = getattr(settings, 'PRODUCTION_MEDIA_URL', DEV_MEDIA_URL)

MEDIA_GENERATORS = getattr(settings, 'MEDIA_GENERATORS', (
    'mediagenerator.generators.copyfiles.CopyFiles',
    'mediagenerator.generators.bundles.Bundles',
    'mediagenerator.generators.manifest.Manifest',
))

_global_media_dirs = getattr(settings, 'GLOBAL_MEDIA_DIRS',
                             getattr(settings, 'STATICFILES_DIRS', ()))
GLOBAL_MEDIA_DIRS = [os.path.normcase(os.path.normpath(force_unicode(path)))
                     for path in _global_media_dirs]

IGNORE_APP_MEDIA_DIRS = getattr(settings, 'IGNORE_APP_MEDIA_DIRS',
    ('django.contrib.admin',))

MEDIA_DEV_MODE = getattr(settings, 'MEDIA_DEV_MODE', settings.DEBUG)

########NEW FILE########
__FILENAME__ = media
from django import template
from mediagenerator.generators.bundles.utils import _render_include_media
from mediagenerator import utils

register = template.Library()

class MediaNode(template.Node):
    def __init__(self, bundle, variation):
        self.bundle = bundle
        self.variation = variation

    def render(self, context):
        bundle = template.Variable(self.bundle).resolve(context)
        variation = {}
        for key, value in self.variation.items():
            variation[key] = template.Variable(value).resolve(context)

        return _render_include_media(bundle, variation)

@register.tag
def include_media(parser, token):
    try:
        contents = token.split_contents()
        bundle = contents[1]
        variation_spec = contents[2:]
        variation = {}
        for item in variation_spec:
            key, value = item.split('=')
            variation[key] = value
    except (ValueError, AssertionError, IndexError):
        raise template.TemplateSyntaxError(
            '%r could not parse the arguments: the first argument must be the '
            'the name of a bundle in the MEDIA_BUNDLES setting, and the '
            'following arguments specify the media variation (if you have '
            'any) and must be of the form key="value"' % contents[0])

    return MediaNode(bundle, variation)

@register.simple_tag
def media_url(url):
    return utils.media_url(url)

@register.filter
def media_urls(url):
    return utils.media_urls(url)

########NEW FILE########
__FILENAME__ = utils
from . import settings as media_settings
from .settings import (GLOBAL_MEDIA_DIRS, PRODUCTION_MEDIA_URL,
    IGNORE_APP_MEDIA_DIRS, MEDIA_GENERATORS, DEV_MEDIA_URL,
    GENERATED_MEDIA_NAMES_MODULE)
from django.conf import settings
from django.core.exceptions import ImproperlyConfigured
from django.utils.importlib import import_module
from django.utils.http import urlquote
import os
import re

try:
    NAMES = import_module(GENERATED_MEDIA_NAMES_MODULE).NAMES
except (ImportError, AttributeError):
    NAMES = None

_backends_cache = {}
_media_dirs_cache = []

_generators_cache = []
_generated_names = {}
_backend_mapping = {}

def _load_generators():
    if not _generators_cache:
        for name in MEDIA_GENERATORS:
            backend = load_backend(name)()
            _generators_cache.append(backend)
    return _generators_cache

def _refresh_dev_names():
    _generated_names.clear()
    _backend_mapping.clear()
    for backend in _load_generators():
        for key, url, hash in backend.get_dev_output_names():
            versioned_url = urlquote(url)
            if hash:
                versioned_url += '?version=' + hash
            _generated_names.setdefault(key, [])
            _generated_names[key].append(versioned_url)
            _backend_mapping[url] = backend

class _MatchNothing(object):
    def match(self, content):
        return False

def prepare_patterns(patterns, setting_name):
    """Helper function for patter-matching settings."""
    if isinstance(patterns, basestring):
        patterns = (patterns,)
    if not patterns:
        return _MatchNothing()
    # First validate each pattern individually
    for pattern in patterns:
        try:
            re.compile(pattern, re.U)
        except re.error:
            raise ValueError("""Pattern "%s" can't be compiled """
                             "in %s" % (pattern, setting_name))
    # Now return a combined pattern
    return re.compile('^(' + ')$|^('.join(patterns) + ')$', re.U)

def get_production_mapping():
    if NAMES is None:
        raise ImportError('Could not import %s. This '
                          'file is needed for production mode. Please '
                          'run manage.py generatemedia to create it.'
                          % GENERATED_MEDIA_NAMES_MODULE)
    return NAMES

def get_media_mapping():
    if media_settings.MEDIA_DEV_MODE:
        return _generated_names
    return get_production_mapping()

def get_media_url_mapping():
    if media_settings.MEDIA_DEV_MODE:
        base_url = DEV_MEDIA_URL
    else:
        base_url = PRODUCTION_MEDIA_URL

    mapping = {}
    for key, value in get_media_mapping().items():
        if isinstance(value, basestring):
            value = (value,)
        mapping[key] = [base_url + url for url in value]

    return mapping

def media_urls(key, refresh=False):
    if media_settings.MEDIA_DEV_MODE:
        if refresh:
            _refresh_dev_names()
        return [DEV_MEDIA_URL + url for url in _generated_names[key]]
    return [PRODUCTION_MEDIA_URL + get_production_mapping()[key]]

def media_url(key, refresh=False):
    urls = media_urls(key, refresh=refresh)
    if len(urls) == 1:
        return urls[0]
    raise ValueError('media_url() only works with URLs that contain exactly '
        'one file. Use media_urls() (or {% include_media %} in templates) instead.')

def get_media_dirs():
    if not _media_dirs_cache:
        media_dirs = GLOBAL_MEDIA_DIRS[:]
        for app in settings.INSTALLED_APPS:
            if app in IGNORE_APP_MEDIA_DIRS:
                continue
            for name in (u'static', u'media'):
                app_root = os.path.dirname(import_module(app).__file__)
                media_dirs.append(os.path.join(app_root, name))
        _media_dirs_cache.extend(media_dirs)
    return _media_dirs_cache

def find_file(name, media_dirs=None):
    if media_dirs is None:
        media_dirs = get_media_dirs()
    for root in media_dirs:
        path = os.path.normpath(os.path.join(root, name))
        if os.path.isfile(path):
            return path

def read_text_file(path):
    fp = open(path, 'r')
    output = fp.read()
    fp.close()
    return output.decode('utf8')

def load_backend(backend):
    if backend not in _backends_cache:
        module_name, func_name = backend.rsplit('.', 1)
        _backends_cache[backend] = _load_backend(backend)
    return _backends_cache[backend]

def _load_backend(path):
    module_name, attr_name = path.rsplit('.', 1)
    try:
        mod = import_module(module_name)
    except (ImportError, ValueError), e:
        raise ImproperlyConfigured('Error importing backend module %s: "%s"' % (module_name, e))
    try:
        return getattr(mod, attr_name)
    except AttributeError:
        raise ImproperlyConfigured('Module "%s" does not define a "%s" backend' % (module_name, attr_name))

########NEW FILE########
