__FILENAME__ = conf
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# pagd documentation build configuration file, created by
# sphinx-quickstart on Tue Jun 11 16:20:09 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'pagd'
copyright = '2013, Pratap Chakravarthy'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.

# The default replacements for |version| and |release|, also used in various
# other places throughout the built documents.
#
# The short X.Y version.
import pkg_resources
try:
    release = pkg_resources.get_distribution('pagd').version
except ImportError:
    print 'To build the documentation, The distribution information of Jinja2'
    print 'Has to be available.  Either install the package into your'
    print 'development environment or run "setup.py develop" to setup the'
    print 'metadata.  A virtualenv is recommended!'
    sys.exit(1)
if 'dev' in release:
    release = release.split('dev')[0] + 'dev'
version = '.'.join(release.split('.')[:2])

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'pagd'
html_theme_path = ['_themes']

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index':    ['sidebarintro.html', 'sourcelink.html',
                 'searchbox.html'],
    '**':       ['localtoc.html', 'relations.html', 'sourcelink.html',
                 'searchbox.html']
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'pagddoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'pagd.tex', 'pagd Documentation',
   'Pratap Chakravarthy', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'pagd', 'pagd Documentation',
     ['Pratap Chakravarthy'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'pagd', 'pagd Documentation',
   'Pratap Chakravarthy', 'pagd', 'Static site generator',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = commands
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from   pluggdapps.plugin        import implements, Singleton
from   pluggdapps.interfaces    import ICommand
import pluggdapps.utils         as h

class Commands( Singleton ):
    """Subcommand plugin for pa-script to list all available sub-commands 
    along with a short description. Like,
    
    .. code-block:: bash
        :linenos:
        
        $ pagd commands

    """

    implements( ICommand )

    description = 'list of script commands and their short description.'
    cmd = 'commands'

    #---- ICommand API
    def subparser( self, parser, subparsers ):
        """:meth:`pluggdapps.interfaces.ICommand.subparser` interface method.
        """
        self.subparser = subparsers.add_parser( 
                                self.cmd, description=self.description )
        self.subparser.set_defaults( handler=self.handle )

    def handle( self, args ):
        """:meth:`pluggdapps.interfaces.ICommand.handle` interface method."""
        commands = self.qpr(ICommand, 'pagd.*')
        commands = sorted( commands, key=lambda x : x.caname )
        for command in commands :
            name = command.caname.split('.', 1)[1]
            rows = self._formatdescr( name, command.description )
            for r in rows : print(r)

    #---- Internal & local functions
    def _formatdescr( self, name, description ):
        fmtstr = '%-' + str(self['command_width']) + 's %s'
        l = self['description_width']

        rows, line = [], ''
        words = ' '.join( description.strip().splitlines() ).split(' ')
        while words :
            word = words.pop(0)
            if len(line) + len(word) >= l : 
                rows.append( fmtstr % (name, line) )
                line, name = word, ''
            else :
                line = ' '.join([ x for x in [line,word] if x ])
        rows.append( fmtstr % (name, line) ) if line else None
        return rows

    #---- ISettings interface methods

    @classmethod
    def default_settings( cls ):
        """:meth:`pluggdapps.plugin.ISettings.default_settings` interface 
        method."""
        return _default_settings

    @classmethod
    def normalize_settings( cls, settings ):
        """:meth:`pluggdapps.plugin.ISettings.normalize_settings` interface 
        method."""
        settings['description_width'] = h.asint(settings['description_width'])
        settings['command_width'] = h.asint(settings['command_width'])
        return settings


_default_settings = h.ConfigDict()
_default_settings.__doc__ = Commands.__doc__

_default_settings['command_width']  = {
    'default' : 15,
    'types'   : (int,),
    'help'    : "Maximum width of command name column."
}
_default_settings['description_width']  = {
    'default' : 60,
    'types'   : (int,),
    'help'    : "Maximum width of description column."
}

########NEW FILE########
__FILENAME__ = create
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from   os.path                  import join, isfile, abspath

from   pluggdapps.plugin        import Singleton, implements
from   pluggdapps.interfaces    import ICommand

from   pagd.interfaces          import ILayout

class Create( Singleton ):
    """Sub-command plugin to create a new layout at the given sitepath. For
    example,
     
    .. code-block:: bash

        pagd -l 'pagd.myblog' create

    uses ``pagd.myblog`` plugin to create a source layout.
    """
    implements( ICommand )

    cmd = 'create'
    description = 'Create a source layout.'

    #---- ICommand API
    def subparser( self, parser, subparsers ):
        """:meth:`pluggdapps.interfaces.ICommand.subparser` interface method.

        * -g switch can be used to supply a configuration file for layout.
        * -f switch will overwrite if ``sitepath`` already contains a layout.
        """
        self.subparser = subparsers.add_parser( 
                                self.cmd, description=self.description )
        self.subparser.set_defaults( handler=self.handle )
        self.subparser.add_argument(
                '-g', '--config-path',
                dest='configfile', default='config.json',
                help='The configuration used to generate the site')
        self.subparser.add_argument(
                '-f', '--force', dest='overwrite',
                action='store_true', default=False,
                help='Overwrite the source layout if it exists')
        return parser

    def handle( self, args ):
        """:meth:`pluggdapps.interfaces.ICommand.handle` interface method.
        
        Instantiate a layout plugin and apply create() method on the
        instantiated plugin. ``sitepath`` and ``siteconfig`` references willbe
        passed as settings dictionary.
        """
        siteconfig = join( args.sitepath, args.configfile )
        sett = { 'sitepath'   : args.sitepath,
                 'siteconfig' : siteconfig,
               }
        layout = self.qp( ILayout, args.layout, settings=sett )
        if not layout :
            raise Exception(
                "The given layout is invalid. Please check if you have the "
                "`layout` in the right place and the environment variable "
                "has been setup properly if you are using custom path for "
                "layouts")
        self.pa.loginfo(
            "Creating site at [%s] with layout [%s] ..." %
            (args.sitepath, args.layout))
        layout.create( overwrite=args.overwrite )
        self.pa.loginfo("... complete")


########NEW FILE########
__FILENAME__ = generate
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from   os.path               import join, isfile, abspath
from   pluggdapps.plugin     import Singleton, implements
from   pluggdapps.interfaces import ICommand

from   pagd.interfaces       import ILayout
from   pagd.lib              import json2dict

class Gen( Singleton ):
    """Sub-command plugin to generate static web site at the given target
    directory. If a target directory is not specified, it uses layout's
    default target directory. For more information refer to corresponding
    layout plugin's documentation.
    """
    implements( ICommand )

    cmd = 'gen'
    description = 'Generate a static site for the give layout and content'

    #---- ICommand API
    def subparser( self, parser, subparsers ):
        """:meth:`pluggdapps.interfaces.ICommand.subparser` interface method.
        """
        self.subparser = subparsers.add_parser( 
                                self.cmd, description=self.description )
        self.subparser.set_defaults( handler=self.handle )
        self.subparser.add_argument(
                '-g', '--config-path',
                dest='configfile', default='config.json',
                help='The configuration used to generate the site')
        self.subparser.add_argument(
                '-t', '--build-target', dest='buildtarget',
                default='.',
                help="Location of target site that contains generated html.")
        self.subparser.add_argument(
                '-r', '--regen', dest='regen',
                action='store_true', default=False,
                help='Regenerate all site pages.')
        return parser

    def handle( self, args ):
        """:meth:`pluggdapps.interfaces.ICommand.handle` interface method.

        Instantiate a layout plugin and apply generate() method on the
        instantiated plugin. ``sitepath`` and ``siteconfig`` references willbe
        passed as settings dictionary.
        """
        siteconfig = join( args.sitepath, args.configfile )
        siteconfig = json2dict( siteconfig )
        layoutname = siteconfig.get( 'layout', args.layout )
        sett = { 'sitepath'   : args.sitepath,
                 'siteconfig' : siteconfig
               }
        layout = self.qp( ILayout, layoutname, settings=sett )
        self.pa.loginfo(
            "Generating site at [%s] with layout [%s] ..." %
            (args.sitepath, layoutname))
        layout.generate( abspath(args.buildtarget), regen=args.regen )
        self.pa.loginfo("... complete")

########NEW FILE########
__FILENAME__ = newpage
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from   os.path               import join, isfile, abspath
from   pluggdapps.plugin     import Singleton, implements
from   pluggdapps.interfaces import ICommand

from   pagd.interfaces       import ILayout
from   pagd.lib              import json2dict

class NewPage( Singleton ):
    """Sub-command plugin to generate a new content page under
    layout-sitepath.
    """
    implements( ICommand )

    cmd = 'newpage'
    description = 'Create a new content page.'

    #---- ICommand API
    def subparser( self, parser, subparsers ):
        """:meth:`pluggdapps.interfaces.ICommand.subparser` interface method.
        """
        self.subparser = subparsers.add_parser( 
                                self.cmd, description=self.description )
        self.subparser.set_defaults( handler=self.handle )
        self.subparser.add_argument(
                '-g', '--config-path',
                dest='configfile', default='config.json',
                help='The configuration used to generate the site')
        self.subparser.add_argument(
                'pagename', nargs=1,
                help='File name, extension not provided defaults to rst' )
        return parser

    def handle( self, args ):
        """:meth:`pluggdapps.interfaces.ICommand.handle` interface method.
        
        Instantiate a layout plugin and apply newpage() method on the
        instantiated plugin. ``sitepath`` and ``siteconfig`` references willbe
        passed as settings dictionary.
        """
        siteconfig = join( args.sitepath, args.configfile )
        sett = { 'sitepath'   : args.sitepath,
                 'siteconfig' : siteconfig
               }
        layout = self.qp( ILayout, layoutname, settings=sett )
        layout.newpage( pagename )

########NEW FILE########
__FILENAME__ = publish

########NEW FILE########
__FILENAME__ = native
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from   os.path      import splitext, isfile

from   pluggdapps.plugin    import Plugin, implements
import pluggdapps.utils     as h
import pluggdapps.interfaces

from   pagd.interfaces      import IContent


class Native( Plugin ):
    """Plugin that can translate different content formats into html
    format using python native modules. Uses function APIs defined under
    :mod:`pagd.contents` module, except for ttl2html.

    Supports reStructuredText, Markdown, plain-text, plain-html,
    tayra-templates text.

    Note that in case of a TTL file, it is interpreted as page content and not
    as template for this or any other page-contents.
    """
    implements( IContent )

    def __init__(self) :
        setts = h.settingsfor( 'tayra.ttlcompiler.', self['siteconfig'] )
        setts.update( debug=True )
        self.ttlplugin = \
            self.qp( pluggdapps.interfaces.ITemplate, 'tayra.TTLCompiler',
                     settings=setts )

    #---- IContent interface methods.

    def articles( self, page ):
        """For ``page``, an instance of :class:`Page` class, using its
        ``contentfiles`` attribute, translate each file's text to html and
        return a corresponding list of articles. Where each element in the
        article is a tuple of, ::

            ( article's fpath, dictionary-of-metadata, html-text )
        """

        articles = []
        for fpath in page.contentfiles :
            if not isfile(fpath) : continue
            _, ext  = splitext(fpath)
            ftype = page.context.get('filetype', ext.lstrip('.'))
            metadata, html = self.parsers[ ftype ](self, fpath, page)
            articles.append( (fpath, metadata, html) )
        return articles

    def rst2html(self, fpath, page):
        from pagd.contents  import rst2html
        return rst2html(fpath, page)

    def md2html(self, fpath, page):
        from pagd.contents  import md2html
        return md2html(fpath, page)

    def html2html(self, fpath, page):
        from pagd.contents  import html2html
        return html2html(fpath, page)

    def text2html(self, fpath, page):
        from pagd.contents  import text2html
        return text2html(fpath, page)

    def ttl2html(self, fpath, page):
        """``fpath`` is identified as a file containing tayra template text. If
        generated html contains <meta> tag elements, it will be used as source
        of meta-data information.

        And return a tuple of (metadata, content). Content is HTML text."""
        from pagd.contents  import html2metadata
        html = self.ttlplugin.render(page.context, file=fpath)
        metadata = html2metadata(html)
        return metadata, html


    parsers = {
        'rst' : rst2html,
        'markdown' : md2html,
        'mdown' : md2html,
        'mkdn' : md2html,
        'md' : md2html,
        'mkd' : md2html,
        'mdwn' : md2html,
        'mdtxt' : md2html,
        'mdtext' : md2html,
        'txt' : text2html,
        'text' : text2html,
        'html' : html2html,
        'htm' : html2html,
        'ttl' : ttl2html,
    }


########NEW FILE########
__FILENAME__ = pandoc
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from   os.path      import splitext, isfile, join
import os, tempfile

from   pluggdapps.plugin    import Plugin, implements
from   pagd.interfaces      import IContent


class Pandoc( Plugin ):
    """Plugin that can translate different content formats into html
    format. Under development, contributions are welcome.

    Make sure that pandoc tool is installed and available through shell
    command line interface. Supports reStructuredText and Markdown content
    formats.
    """
    implements( IContent )

    def __init__(self) :
        self.cmd = join( os.environ['HOME'], '.cabal', 'bin', 'pandoc' )

    #---- IContent interface methods.

    def articles( self, page ):
        if not isfile(self.cmd) :
            raise Exception('Not found %r' % self.cmd)

        articles = []
        for fpath in page.contentfiles :
            if not isfile(fpath) : continue
            _, ext  = splitext(fpath)
            ftype = page.context.get('filetype', ext.lstrip('.'))
            metadata, content = self.parsers[ ftype ](self, fpath)
            articles.append( (fpath, metadata, content) )
        return articles

    def rst2html(self, fpath):
        return self.pandoc( self.cmd, fpath, 'rst', 'html' )

    def md2html(self, fpath):
        return self.pandoc( self.cmd, fpath, 'markdown', 'html' )

    def pandoc(self, cmd, fpath, fromm, to ):
        fd, tfile = tempfile.mkstemp()
        os.system(
                cmd + ' --highlight-style kate -f %s -t %s -o "%s" "%s"' % (
                      fromm, to, tfile, fpath) )
        return {}, open(fd).read()

    parsers = {
        'rst' : rst2html,
        'markdown' : md2html,
        'mdown' : md2html,
        'mkdn' : md2html,
        'md' : md2html,
        'mkd' : md2html,
        'mdwn' : md2html,
        'mdtxt' : md2html,
        'mdtext' : md2html,
    }



########NEW FILE########
__FILENAME__ = git
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from   sys          import stdout
import subprocess

from   pluggdapps.plugin        import Plugin, implements
import pluggdapps.interfaces

import pagd.interfaces
from   pagd.lib                 import age

class Git( Plugin ):
    """Plugin to fetch page's context from git, if available, and compose them
    into a dictionary of page's metadata."""

    implements( pagd.interfaces.IXContext )

    cmd = ["git", "log", '--pretty="%cn ; %ce ; %ct']
    def fetch( self, page ):
        """Provides the following context from git repository log for the
        file,

        .. code-block:: python

            { 'author' : <string>,
              'email' : <string>,
              'createdon' : <date-string>,
              'last_modified' : <date-string>
            }

        - `author` will be original author who created the file.
        - `email` will be email-id of the original author,
        - `date-string` will be of the format 'Mon Jun 10, 2013' and will
          refer to author's local-time.
        """
        scale = page.context.get( 'age_scale' )
        for fpath in page.contentfiles :
            try :
                logs = subprocess.check_output(self.cmd+[fpath], stderr=stdout)
                logs = logs.splitlines()
                _, _, last_modified = logs[0].decode('utf-8').split(" ; ")
                author, email, createdon = logs[-1].decode('utf-8').split(" ; ")
            except :
                author, email, createdon, last_modified = '', '', '', ''

        author, email = author.strip(' "\''), email.strip(' "\''),
        createdon, last_modified = createdon.strip(), last_modified.strip()
        createdon = age( int(createdon), scale=scale ) if createdon else ''
        last_modified = age( int(last_modified), scale=scale ) \
                                    if last_modified else ''
        return { 'author' : author, 'email' : email,
                 'createdon' : createdon, 'last_modified' : last_modified
               }

########NEW FILE########
__FILENAME__ = hg
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from   sys          import stdout
import subprocess

from   pluggdapps.plugin        import Plugin, implements
import pluggdapps.interfaces

import pagd.interfaces
from   pagd.lib                 import age

class Hg( Plugin ):
    """Plugin to fetch page's context from Hg, if available, and compose them
    into a dictionary of page's metadata.
    """
    implements( pagd.interfaces.IXContext )

    cmd = ["hg", "log",
           '--template "{author|person} ; {author|email} ; {date|age}\n"']
    def fetch( self, page ):
        """Provides the following context from git repository log for the
        file,

        .. code-block:: python

            { 'author' : <string>,
              'email' : <string>,
              'createdon' : <date-string>,
              'last_modified' : <date-string>
            }

        - `author` will be original author who created the file.
        - `email` will be email-id of the original author,
        - `date-string` will be of the format 'Mon Jun 10, 2013' and will
          refer to author's local-time.
        """
        scale = page.context.get( 'age_scale' )
        for fpath in page.contentfiles :
            try :
                logs = subprocess.check_output(self.cmd+[fpath], stderr=stdout)
                logs = logs.splitlines()
                _, _, last_modified = logs[0].decode('utf-8').split(" ; ")
                author, email, createdon = logs[-1].decode('utf-8').split(" ; ")
            except :
                author, email, createdon, last_modified = '', '', '', ''

        author, email = author.strip(' "\''), email.strip(' "\''),
        createdon, last_modified = createdon.strip(), last_modified.strip()
        createdon = age( int(createdon), scale=scale ) if createdon else ''
        last_modified = age( int(last_modified), scale=scale ) \
                                    if last_modified else ''
        return { 'author' : author, 'email' : email,
                 'createdon' : createdon, 'last_modified' : last_modified
               }

########NEW FILE########
__FILENAME__ = h
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

"""Helper functions for pagd's layout templates."""

import sys
from   os.path      import dirname, join, isfile

__all__ = [ 'readfile' ]

#---- Generic helper functions.

def readfile( relpath ):
    """Read file from path ``relpath`` relative to calling template."""
    frame = sys._getframe(1)
    filen = frame.f_globals.get('_ttlfile', None)
    if isfile( filen ) :
        f = join( dirname(filen), relpath )
        if isfile( f ) :
            return open(f).read()
    return ''

########NEW FILE########
__FILENAME__ = interfaces
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

"""Collection of interfaces that can be stitch together to do static 
site-generation. Note that these interfaces are loosely defined and does not
impose a strict design for users. Almost always the design is enforced by
:class:`ILayout` plugins.
"""


from   pluggdapps.plugin    import Interface

class ILayout(Interface):
    """Interface to define layout and manage a static site."""

    sitepath = None
    """Path to directory where a new layout is created."""

    siteconfig = {}
    """Configuration parameters for layout under `sitepath`. Normally site
    configuration is stored as `config.json` under ``sitepath``."""

    def is_exist( sitepath ):
        """Is there a valid layout under `sitepath`. Returns a boolean."""

    def create( overwrite=False ):
        """Create a new layout under ``sitepath``. Subsequently users will add
        content under ``sitepath`` which can then be translated to static
        web-site. Corresponds directly with `create` sub-command from pagd
        command line script.
        """

    def generate( buildtarget, regen=True, srcfile=None ):
        """Generate static web site from source layout, specified by
        ``sitepath``. Corresponds directly with `gen` sub-command from pagd
        command line script.

        ``buildtarget``,
            Absolute directory path or directory path relative to `sitepath`
            where generated html site-pages are saved. Your static web site is
            available under buildtarget.

        ``regen``,
            If True regenerate all source files, whether modified or
            unmodified. Default is True.
        """

    def pages( sitepath ):
        """To build the static site from a source layout, first individual
        pages must be identified. This interface method iterates over each and
        every site-page that is identified under source layout. Refer to
        corresponding layout-plugin to know how pages are idenfitied from
        source layout.

        This is normally called during :meth:`generate`.
        
        For each iteration returns ``page`` object, which is an instance of
        class :class:`Page`.
        """

    def pagecontext(page):
        """After a page is identified, corresponding context information must
        be gathered. Context can be saved in JSON files that have one-to-one
        mapping with content-pages, and/or it can be supplied by the content
        itself (many markups, like rst, markdown, allow authors to add 
        meta-data in their document). Refer to corresponding layout-plugin to
        know how pages are idenfitied from source layout.

        Returns back dictionary of ``context`` attributes.
        """

    def pagecontent(page):
        """Read the page content from one or more files, specified by
        ``contentfiles`` attribute, and convert them into html articles.
        Normally content files are authored in plain text or using rst,
        markdown, or even raw html. Refer to corresponding :class:`IContent`
        plugin to know supported formats.

        Retun back list of ``articles``. Refer to :class:`Page` class to know
        the structure of article element.
        """

    def pagetemplate(page):
        """Locate the template file from the layout's template sub-directory
        and return the template file.
        
        ``page``,
            An instance of class :class:`Page`.

        Return template file as absolute file path. If False or None is
        returned then, either template file couldn't be located or not located
        for other reasons.
        """

    def newpage( pagename ):
        """Create a new content page in layout's source tree. Corresponds
        directly with `newpage` sub-command from pagd command line script.
        
        ``pagename``,
            name of the new file, that shall be interpreted as a new web-page
            for static web-site. Along with filename, file extension and file
            path is to be supplied. If one or both left unspecified then it is
            updo the layout-plugin to take a default action.
        """



class IContent(Interface):
    """Interface specification to compile text friendly content to
    web-friendly content. These contents will be supplied to page-templates
    during page generation.
    
    All methods of this plugin are re-entrant.

    ``siteconfig`` dictionary will be made available as plugin's settings key,
    access them as self['siteconfig'].
    """

    def articles( page ):
        """
        ``page``,
            An instance of class :class:`Page`. Attribute `contentfiles` is
            significant for this function.

        Interpret each content file and translate them into web friendly
        format that can be used by page-templates.

        Return a tuple of,
            ( article's fpath, dictionary-of-metadata, html-text ).

        Note that meta-data for each article will finally include context
        attributes from page's context json, default-json and even external
        context if supplied.
        """


class IXContext(Interface):
    """Interface specification to fetch page context from external sources.

    All methods of this plugin are re-entrant.

    ``siteconfig`` dictionary will be made available as plugin's settings key,
    access them as self['siteconfig'].
    """

    def fetch( page=None, article=None ):
        """Fetch the context from external source for page. Some times, if
        more than one article is present for a page, then instead of using
        ``page`` keyword, supply the ``article`` keyword.

        ``page``,
            an instance of class :class:`Page`. Contains page description and
            its context gathered so far.

        ``article``,
            a tuple of article content and metadata, refer to :class:`Page`
            for exact detail.

        Return a python dictionary of context attributes. Context must contain
        basic python data-types like integers, float, string, list, tuple,
        dictionary.
        """


class ITemplate(Interface):
    """Interface specification to translate a page using a template file.

    All methods of this plugin are re-entrant.

    ``siteconfig`` dictionary will be made available as plugin's settings key,
    access them as self['siteconfig'].
    """

    extensions = []
    """List of template file extensions that this plugin can parse."""

    def render( page ):
        """Render the final html page in the target site-directory."""


class IPublish(Interface):
    """Interface specification to publish generated site on the net or else
    where."""

    def publish( site ):
        """Publish the generated site on the net."""


########NEW FILE########
__FILENAME__ = myblog
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from   os       import listdir
from   os.path  import join, splitext, isfile, isdir, relpath, abspath, \
                       dirname, split, getmtime
from   copy     import deepcopy
import os, time

from   pluggdapps.plugin    import Plugin, implements
import pluggdapps.utils     as h
from   pagd.interfaces      import ILayout, IContent, ITemplate, IXContext
from   pagd.lib             import json2dict, pagd, findtemplate, Site, Page

class MyBlog( Plugin ):
    """A layout plugin to generate personal blog sites. Support create, gen,
    newpage interfaces APIs for corresponding sub-commands.
    """

    implements(ILayout)
    layoutpath = join( dirname(__file__), 'myblog')

    def __init__( self ):
        self.sitepath = self['sitepath']
        if isinstance(self['siteconfig'], dict) :
            self.siteconfig = self['siteconfig']
        else :
            self.siteconfig = json2dict( join( self['siteconfig'] ))
        self.plugins = self._plugins( self.sitepath, self.siteconfig )

    #---- ILayout interface methods

    def is_exist(self):
        """:meth:`padg.interfaces.ILayout.is_exist` interface method."""

        xs = [ 'configfile', 'contentdir', 'templatedir' ]
        x, y, z = [join(self.sitepath, self[x]) for x in xs]
        return isfile(x) and isdir(y) and isdir(z)

    def create(self, **kwargs) :
        """Creates a new layout under ``sitepath``. Uses the directory tree
        under `pagd:layouts/myblog` as a template for the new layout. Accepts
        the following variable while creating,

        ``sitepath``,
            directory-path under which the new layout had to be created.
        """
        if not isdir( self['sitepath'] ) :
            os.makedirs( self['sitepath'], exist_ok=True )
        _vars = { 'sitepath' : self.sitepath, }
        overwrite = kwargs.get('overwrite', False)
        h.template_to_source( self.layoutpath, self.sitepath, _vars,
                              overwrite=overwrite, verbose=True )

    def generate(self, buildtarget, **kwargs) :
        """Generate a static, personal blog site from the layout under
        ``sitepath``. Note that previously a new-layout must have been created
        using this plugin and available under `sitepath`.
        
        This method,

        - iterates over each page availabe under the source-layout,
        - gathers page contexts.
        - translates page content into html.
        - locate a template for the page and generate the html for page.

        Refer to :meth:`pages` method to know how pages are located under
        layout's content-directory.
        """
        regen = kwargs.get('regen', True)
        srcfile = kwargs.get('srcfile', None)
        for page in self.pages() :
            path = abspath( join( buildtarget, page.relpath ))
            fname = page.pagename + '.html'
            self.pa.loginfo("    Generating `%r`" % join(page.relpath, fname) )

            # Gather page context
            page.context.update( self.pagecontext( page ))

            # Gather page content
            page.articles = self.pagecontent( page )

            # page content can also have context, in the form of metadata
            # IMPORTANT : myblog will always have one article only.
            for fpath, metadata, content in page.articles :
                page.context.update( metadata )
                page.context.update(
                    self._fetch_xc( metadata.get('_xcontext', ''), page ))

            # If skip_context is present then apply them,
            page = self._skip_context( page )

            # Find a template for this page.
            page.templatefile = self.pagetemplate(page) # Locate the templage
            if isinstance(page.templatefile, str) :
                _, ext = splitext(page.templatefile)
                ttype = page.context.get('templatetype', ext.lstrip('.'))
                # generate page's html
                html = self._tmpl2plugin( self.plugins, ttype ).render( page )
                os.makedirs(path, exist_ok=True) if not isdir(path) else None
                open( abspath( join( path, fname )), 'w' ).write(html)


    SPECIALPAGES = ['_context.json']
    def pages(self):
        """Individual pages are picked based on the relative directory path
        along with filenames. Note that file extensions are not used to
        differentite pages, they are only used to detect the file type and
        apply corresponding translation algorithm to get page's html.
        """
        contentdir = join( self.sitepath, *self['contentdir'].split('/') )
        site = Site()
        site.sitepath = self.sitepath
        site.siteconfig = self.siteconfig
        for dirpath, dirs, files in os.walk(contentdir):
            files = sorted(files)
            [ files.remove(f) for f in self.SPECIALPAGES if f in files ]
            while files :
                pagename, contentfiles, files = \
                        pagd( join(contentdir, dirpath), files )
                page = Page()
                page.site = site
                page.pagename = pagename
                page.relpath = relpath(dirpath, contentdir)
                page.urlpath = join( relpath(dirpath, contentdir), pagename)
                page.urlpath = '/'.join( page.urlpath.split( os.sep ))
                page.contentfiles = contentfiles
                page.context = self.config2context( self.siteconfig )
                page.context.update({
                    'site'    : page.site,
                    'page'    : page,
                    'title'   : page.pagename,
                    'summary' : '',
                    'layout'  : self.caname,
                    'author'  : None,
                    'email'   : None,
                    'createdon'     : None,
                    'last_modified' : None,
                    'date'  : None,
                })
                page.articles = []
                yield page

    def pagecontext( self, page ):
        """Gathers default context for page.

        Default context is specified by one or more JSON files by name
        `_context.json` that is located under every sub-directory that
        leads to the page-content under layout's content-directory.
        `_context.json` found one level deeper under content directory will
        override `_context.json` found in the upper levels.

        Also, if a pagename has a corresponding JSON file, for eg,
        ``<layout>/_contents/path/hello-world.rst`` file has a corresponding
        ``<layout>/_contents/path/hello-world.json``, it will be interepreted
        as the page's context. This context will override all the default
        context.

        If `_xcontext` attribute is found in a default context file, it
        will be interpreted as plugin name implementing :class:`IXContext`
        interface. The plugin will be queried, instantiated, to fetch context
        information from external sources like database.

        Finally ``last_modified`` time will be gathered from content-file's
        mtime statistics.
        """
        contentdir = join( self.sitepath, *self['contentdir'].split('/') )
        contexts = self.default_context(contentdir, page)

        # Page's context, if available.
        page_context_file = join(page.relpath, page.pagename) + '.json'
        c = json2dict(page_context_file) if isfile(page_context_file) else None
        contexts.append(c) if c else None

        context = {}
        # From the list of context dictionaries in `contexts` check for
        # `_xcontext` attribute and fetch the context from external source.
        for c in contexts :
            context.update(c)
            context.update( self._fetch_xc( c.get('_xcontext', ''), page ))
        return context

    def pagecontent( self, page ):
        """Pages are located based on filename, and the file extension is not
        used to differential pages. Hence there can be more than one file by
        same filename, like, ``_contents/hello-world.rst``,
        ``_contents/hello-world.md``. In such cases, all files will be
        considered as part of same page and translated to html based on the
        extension type.

        Return a single element list of articles, each article as tuple.
        Refer to :class:``Page`` class and its ``articles`` attribute to know
        its data-structure."""

        n = page.context.get('IContent', self['IContent'])
        name = n if n in self.plugins else _default_settings['IContent']
        icont = self.plugins.get( name, None )
        articles = icont.articles(page) if icont else []
        return articles

    def pagetemplate( self, page ):
        """For every page that :meth:`pages` method iterates, a corresponding
        template file should be located. It is located by following steps.

        - if page's context contain a ``template`` attribute, then its value
          is interpreted as the template file for page in asset specification
          format.
        - join the relative path of the page with ``_template`` sub-directory
          under the layout, and check whether a template file by pagename is
          available. For eg, if pagename is ``hello-world`` and its relative
          path is ``blog/2010``, then a template file
          ``_templates/blog/2010/hello-world`` will be lookup. Note that the
          extensio of the template file is immaterial.
        - If both above steps have failed then will lookup for a ``_default``
          template under each sub-directory leading to
          ``_templates/blog/2010/``.
        """
        tmplpath = join( self.sitepath, *self['templatedir'].split('/') )
        tmplfile = None
        dr = abspath( join( tmplpath, page.relpath ))
        if page.context.get('template', None) == False :
            tmplfile = False
        if tmplfile == None and 'template' in page.context :
            tmplfile = asset_spec_to_abspath( page.context['template'] )
            tmplfile = tmplfile if tmplfile and isfile(tmplfile) else None
        if tmplfile == None and isdir(dr) :
            tmplfile = findtemplate(dr, pagename=page.pagename)
            tmplfile = tmplfile if tmplfile and isfile(tmplfile) else None
        if tmplfile == None :
            path = page.relpath
            while tmplfile == None and path :
                d = join( tmplpath, path )
                if isdir(d) :
                    tmplfile = findtemplate(d, default=self['default_template'])
                    tmplfile = tmplfile \
                                    if tmplfile and isfile(tmplfile) else None
                path, _ = split( path )
        return tmplfile


    def newpage(self, pagename):
        contentdir = join( self.sitepath, *self['contentdir'].split('/') )
        try     : _, ext = splitext(pagename)
        except  : ext = '.rst'
        filepath = join( self.sitepath, contentdir, pagename+'.rst' )
        os.makedirs( dirname(filepath), exist_ok=True )
        open(filepath, 'w').write()
        self.pa.loginfo("New page create - %r", filepath)


    #---- Local functions
    def default_context( self, contentdir, page ):
        """Return a list of context dictionaries from default-context under each
        sub-directory of content-page's path."""
        path = page.relpath.strip(os.sep)
        contexts = []
        fname = self['default_context']
        while path :
            f = join(contentdir, path, fname)
            contexts.insert(0, json2dict(f)) if isfile(f) else None
            path, _ = split( path )
        return contexts

    def config2context( self, siteconfig ):
        xd = { x : siteconfig[x] 
               for x in [ 'disqus', 'show_email', 'social_sharing', 'copyright',
                          'google_webfonts', 'style', 'age_scale', ]
             }
        return xd

    def _plugins( self, sitepath, siteconfig ):
        """Instantiate plugins available for :class:`ITemplate`,
        :class:`IXContext` and :class:`IContent` interfaces.
        
        siteconfig and sitepath will be passed as plugin-settings for all
        instantiated plugins. 
        """
        sett = { 'sitepath'   : sitepath, 'siteconfig' : siteconfig }
        plugins = self.qps( ITemplate, settings=sett ) + \
                  self.qps( IXContext, settings=sett ) + \
                  self.qps( IContent, settings=sett )
        return { p.caname : p for p in plugins }

    def _tmpl2plugin( self, plugins, tmpl ):
        """For file type ``tmpl`` return the template plugin."""
        for p in plugins.values() :
            if tmpl in getattr(p, 'extensions', []) : return p
        else :
            return None

    def _skip_context(self, page):
        attrs = h.parsecsv( page.site.siteconfig.get( 'skip_context', '' )) + \
                h.parsecsv( page.context.get( 'skip_context', '' ))
        [ page.context.update(attr=None) for attr in attrs ]
        return page

    def _fetch_xc(self, _xc, page) :
        ps = h.parsecsv( _xc )
        context = {}
        for s in ps :
            p = self.plugins.get(s, None)
            context.update( p.fetch(page) ) if p else None
        return context

    #---- ISettings interface methods

    @classmethod
    def default_settings( cls ):
        """:meth:`pluggdapps.plugin.ISettings.default_settings` interface 
        method."""
        return _default_settings

    @classmethod
    def normalize_settings( cls, settings ):
        """:meth:`pluggdapps.plugin.ISettings.normalize_settings` interface 
        method."""
        return settings


_default_settings = h.ConfigDict()
_default_settings.__doc__ = MyBlog.__doc__

_default_settings['sitepath'] = {
    'default' : '',
    'types'   : (str,),
    'help'    : "Target directory to place layout files. If not specified "
                "uses the current working directory."
}
_default_settings['configfile'] = {
    'default' : 'config.json',
    'types'   : (str,),
    'help'    : "Configuration file name under sitepath, will be interpreted "
                "as site-configuration. Refer to corresponding layout "
                "documentation for information on available configuration "
                "settings."
}
_default_settings['contentdir'] = {
    'default' : '_contents',
    'types'   : (str,),
    'help'    : "Sub-direcory name under sitepath that contains all page "
                "contents for the site."
}
_default_settings['templatedir'] = {
    'default' : '_templates',
    'types'   : (str,),
    'help'    : "Sub-direcory name under sitepath that contains all page "
                "templates. Page templates are used to generate the final "
                "site-html files."
}
_default_settings['default_context'] = {
    'default' : '_context.json',
    'types'   : (str,),
    'help'    : "Context file name to look for in content sub-directories as "
                "default context."
}
_default_settings['IContent'] = {
    'default' : 'pagd.native',
    'types'   : (str,),
    'help'    : "Plugin to generate html content from page-content files."
}
_default_settings['default_template'] = {
    'default' : '_default',
    'types'   : (str,),
    'help'    : "Base name of a template file expected under a sub-directory "
                "of layout's template directory."
}


########NEW FILE########
__FILENAME__ = lib
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

"""A collection of library routines."""

from   os.path  import split, join, isfile, splitext, abspath
import os, json, time

import pluggdapps.utils as h

def json2dict( jsonfile ):
    """Convert ``jsonfile`` to python dictionary. Return ``None`` if jsonfile
    is not found."""
    if isfile( jsonfile ) :
        txt = open(jsonfile).read()
        d = h.json_decode(txt) if txt else {}
    else :
        return {}
    if not isinstance( d, dict ) :
        raise Exception( "Expected %r as property of settings" % jsonfile )
    return d


def pagd(path, files) :
    """This function implements the key concept in pagd, that is, to aggregate
    content and for target web-page.
    
    ``path``,
        Absolute directory path pointing a sub-directory under layout's
        content directory.
    ``files``,
        List of files under a sub-directory from layout's content directory.

    Return a tuple of, (pagename, page-contents, remaining-files)

    ``pagename``,
        name of the web-page that will appear in url-path as last path segment.
    ``page-contents``,
        List of files that can be translated to html content for page
        `pagename`.
    ``remaining-files``,
        List of files that remain after gathering contents.
    """
    pagename, ext = splitext( files[0] )
    contentfiles = []
    while files :
        x, y = splitext( files[0] )
        if x == pagename :
            contentfiles.append( join(path, files[0] ))
        else :
            break
        files.pop(0)
    return pagename, contentfiles, files


def findtemplate( subdir, pagename=None, default=None ):
    """Find a matching template under ``subdir``.

    ``subdir``,
        Directory path that shall contain one or more template files.
    ``pagename``,
        Page-name for which this function shall find a corresponding
        template-file.
    ``default``,
        Basename of default-template.
    """
    if pagename :
        expected_file = pagename
    elif default :
        expected_file = default

    for f in os.listdir(subdir) :
        if f.startswith(expected_file) :
            tmplfile = abspath( join( subdir, f ))
            break
    else :
        tmplfile = None
    return tmplfile


agescales = [("year", 3600 * 24 * 365),
             ("month", 3600 * 24 * 30),
             ("week", 3600 * 24 * 7),
             ("day", 3600 * 24),
             ("hour", 3600),
             ("minute", 60),
             ("second", 1)]
def age( then, format="%a %b %d, %Y", scale="year" ):
    """convert (timestamp, tzoff) tuple into an age string. both `timestamp` and
    `tzoff` are expected to be integers."""

    plural = lambda t, c : t if c == 1 else (t + "s")
    fmt = lambda t, c : "%d %s" % (c, plural(t, c))

    now = time.time()
    if then > now :
        return 'in the future'

    threshold = h.dropwhile( lambda x : x[0] != scale, agescales )[0][1]
    delta = max(1, int(now - then))
    if delta > threshold :
        return time.strftime(format, time.gmtime(then))

    for t, s in agescales:
        n = delta // s
        if n >= 2 or s == 1:
            return '%s ago' % fmt(t, n)

class Site(object):
    """Abstraction object to hold following attributes.

    ``sitepath``,
        Absolute path to where the source files for the site is present.

    ``siteconfig``,
        A python dictionary of configuration settings application to entire
        site.

    All the above attributes have site-wide scope.
    """
        
class Page(object):
    """Abstraction object to hold following attributes.

    ``site``,
        an instance of :class:`Site` class that contains this page.

    ``pagename``,
        name of the page that will appear in url-path as last path segment.

    ``relpath``,
        relative path from `sitepath`, where pagename is located.

    ``urlpath``,
        url path relative to script-path. Includes `pagename` as the last
        segment in the path.

    ``contentfiles``,
        List of files, in absolute path, that contains contents for this page.

    ``articles``,
        List of article tuples which each tuple is made up of,
        ``( article's fpath, article-context, html-text )``. Article's
        file-path is the absolute path of the content file which was
        translated to `html-text`. Article's context  is ``page.context``
        overrided with meta-data from file-content.

    ``context``,
        Dictionary of context attributes for page.

    ``templatefile``,
        Template file name with absolute path-name to be used for translating
        this content-page to html page.

    All the above attributes are unique for each page.
    """


########NEW FILE########
__FILENAME__ = gallery
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from docutils import nodes
from docutils.parsers.rst import directives

block = """
<div class="rst-gallery">
    <div class="gallery-title">%s</div>
    %s
</div>
"""
thumb = '<a href="%s" title="%s"><img src="%s"></img></a>'

def gallery( name, args, options, content, lineno,
             contentOffset, blockText, state, stateMachine ):
    """Restructured text extension for inserting youtube embedded videos."""
    s = ''
    title = content[0]
    for z in [ y.strip() for x in content[1:] for y in x.split(',') ] :
        try : src, imgtitle = z
        except : src, imgtitle = z, ''
        s += thumb % (src, imgtitle, src)
    return [ nodes.raw( '', block % (title, s), format='html')]

gallery.content = True
directives.register_directive('gallery', gallery)


########NEW FILE########
__FILENAME__ = gist
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from docutils import nodes
from docutils.parsers.rst import directives

CODE = """
    <script src="%s"></script>
"""

def gist( name, args, options, content, lineno,
             contentOffset, blockText, state, stateMachine ):
    """Restructured text extension for inserting github-gist embedded videos."""
    if content[0].startswith('http') :
        src = content[0]
    else : 
        src = 'https://gist.github.com/' + content[0].lstrip('/')
    return [ nodes.raw( '', CODE % (src), format='html')]

gist.content = True
directives.register_directive('gist', gist)

########NEW FILE########
__FILENAME__ = sourcecode
# -*- coding: utf-8 -*-

"""
The Pygments reStructuredText directive
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

This fragment is a Docutils_ 0.5 directive that renders source code
(to HTML only, currently) via Pygments.

To use it, adjust the options below and copy the code into a module
that you import on initialization.  The code then automatically
registers a ``sourcecode`` directive that you can use instead of
normal code blocks like this::

    .. sourcecode:: python

        My code goes here.

If you want to have different code styles, e.g. one with line numbers
and one without, add formatters with their names in the VARIANTS dict
below.  You can invoke them instead of the DEFAULT one by using a
directive option::

    .. sourcecode:: python
        :linenos:

        My code goes here.

Look at the `directive documentation`_ to get all the gory details.

.. _Docutils: http://docutils.sf.net/
.. _directive documentation:
   http://docutils.sourceforge.net/docs/howto/rst-directives.html

:copyright: Copyright 2006-2013 by the Pygments team, see AUTHORS.
:license: BSD, see LICENSE for details.
"""

# Options
# ~~~~~~~

# Set to True if you want inline CSS styles instead of classes
INLINESTYLES = False

from pygments.formatters import HtmlFormatter

# The default formatter
DEFAULT = HtmlFormatter(noclasses=INLINESTYLES)

# Add name -> formatter pairs for every variant you want to use
VARIANTS = {
    # 'linenos': HtmlFormatter(noclasses=INLINESTYLES, linenos=True),
}


from docutils import nodes
from docutils.parsers.rst import directives, Directive

from pygments import highlight
from pygments.lexers import get_lexer_by_name, TextLexer

class Pygments(Directive):
    """ Source code syntax hightlighting.
    """
    required_arguments = 1
    optional_arguments = 0
    final_argument_whitespace = True
    option_spec = dict([(key, directives.flag) for key in VARIANTS])
    has_content = True

    def run(self):
        self.assert_has_content()
        try:
            lexer = get_lexer_by_name(self.arguments[0])
        except ValueError:
            # no lexer found - use the text one instead of an exception
            lexer = TextLexer()
        # take an arbitrary option if more than one is given
        formatter = self.options and VARIANTS[self.options.keys()[0]] or DEFAULT
        parsed = highlight('\n'.join(self.content), lexer, formatter)
        return [nodes.raw('', parsed, format='html')]

directives.register_directive('sourcecode', Pygments)
directives.register_directive('code-block', Pygments)


########NEW FILE########
__FILENAME__ = youtube
# -*- coding: utf-8 -*-
# This code is from http://countergram.com/youtube-in-rst

from docutils import nodes
from docutils.parsers.rst import directives

CODE = """\
<object class="rst-youtube" type="application/x-shockwave-flash"
        %(attrs)s data="http://www.youtube.com/v/%(yid)s">
    <param name="movie" value="http://www.youtube.com/v/%(yid)s"></param>
    <param name="wmode" value="transparent"></param> %(extra)s
</object>
"""

PARAM = """\n<param name="%s" value="%s"></param>"""

def youtube( name, args, options, content, lineno,
             contentOffset, blockText, state, stateMachine ):
    """Restructured text extension for inserting youtube embedded videos."""
    if len(content) == 0 : return
    string_vars = { 'yid': content[0],
                    'attrs': '',
                    'extra': ''
                  }
    attrs = content[1:] # Because content[0] is ID
    attrs = [attr.strip() for attr in content[1:]] # key=value
    string_vars['attrs'] = " ".join(attrs)
    return [ nodes.raw( '', CODE % (string_vars), format='html')]

youtube.content = True
directives.register_directive('youtube', youtube)

########NEW FILE########
__FILENAME__ = script
#! /usr/bin/env python3.2

# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

"""Command line script. Almost all functions of command line script are
implemented as sub-commands. To get a quick summary of available sub-commads,

.. code-block:: bash
    :linenos:

    $ pagd commands

To learn more about available subcommand refer to :mod:`pagd.commands`
package. Since sub commands are implemented as plugins, there can be other
sub-commands implemented by different package. Refer to corresponding package
for their documentation.

You can also use `--help` on the sub-command for supported options.

.. code-block:: bash
    :linenos:

    $ pagd --help
"""

import sys
from   argparse     import ArgumentParser
from   os.path      import abspath

import pluggdapps
from   pluggdapps.platform   import Pluggdapps
from   pluggdapps.interfaces import ICommand
from   pluggdapps.plugin     import PluginMeta

import pagd

def mainoptions():
    # setup main script arguments
    description = "`pagd` command line script."
    mainparser = ArgumentParser( description=description )
    mainparser.add_argument( '-s', '--sitepath',
                             dest='sitepath', default='.',
                             help="Location of site's layout source." )
    mainparser.add_argument( '-c', dest='config', 
                             default=None,
                             help="Specify config file." )
    mainparser.add_argument( '-l', '--layout',
                             dest='layout', default='pagd.myblog',
                             help='Layout-type for the new site' )
    return mainparser

def main():
    from pluggdapps import loadpackages
    import pluggdapps.commands

    loadpackages()  # This is important, otherwise plugins in other packages 
                    # will not be detected.

    # Create command line parser.
    # Get a list of sub-commands supported in command line.
    # Take only the command-line parameters uptil a subcommand.
    mainparser = mainoptions()
    mainargs = pluggdapps.commands.mainargs(ICommand, 'pagd.*', sys.argv[1:])
    args = mainparser.parse_args( mainargs )

    pa = Pluggdapps.boot( args.config )
    subcommands = pa.qpr( pa, ICommand, 'pagd.*' )

    # setup sub-command arguments
    subparsers = mainparser.add_subparsers( help="Sub-commands" )
    [ subcmd.subparser( mainparser, subparsers ) for subcmd in subcommands ]

    # Do a full parsing of command line arguments.
    args = mainparser.parse_args()

    args.sitepath = abspath( args.sitepath )

    # Corresponding handler is expected to be registered during subparser()
    # call above.
    args.handler( args )

if __name__ == '__main__' :
    main()

########NEW FILE########
__FILENAME__ = jinja2
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from   pluggdapps.plugin        import Plugin, implements
import pluggdapps.interfaces

try    : from   jinja2 import Environment, FileSystemLoader
except : pass

import pagd.interfaces

class Jinja2( Plugin ):
    """Plugin to translate jinja2 templates to html files."""
    implements( pagd.interfaces.ITemplate )

    extensions = ['jinja2', 'j2']

    def __init__( self ):
        try :
            kwargs = {
                'loader'      : 
                    FileSystemLoader( self['sitepath'] ),
                'auto_reload' : 
                    self['siteconfig'].get('jinja2.auto_reload', False),
                'cache_size'  : 
                    self['siteconfig'].get('jinja2.cache_size', 50),
                'extensions'  :
                    self['siteconfig'].get('jinja2.extensions', ()),
            }
            self.env = Environment( **kwargs )
        except NameError:
            self.env = None

    def render( self, page ):
        tmpl = self._get_template( page.templatefile )
        return tmpl.render( page.context ) if tmpl != None else ''

    def _get_template( self, template_name, globals=None ):
        if self.env != None :
            return self.env.get_template( template_name, globals=globals )
        else :
            return None

########NEW FILE########
__FILENAME__ = mako
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

import io

from   pluggdapps.plugin        import Plugin, implements
import pluggdapps.interfaces

import pagd.interfaces

try:
    from   mako.template import Template
    from   mako.runtime import Context
except : pass

class Mako( Plugin ):
    """Plugin to translate mako templates to html files."""
    implements( pagd.interfaces.ITemplate )

    extensions = ['mako']

    def __init__( self ):
        self.kwargs = {
            'module_directory' : \
                    self['siteconfig'].get('mako.module_directory', None),
        }

    def render( self, page ):
        try :
            mytemplate = Template( page.templatefile, **self.kwargs )
            buf = io.StringIO()
            mytemplate.render_context( Context(buf, **page.context) )
            return buf.getvalue()
        except NameError :
            return ''


########NEW FILE########
__FILENAME__ = tayra
# -*- coding: utf-8 -*-

# This file is subject to the terms and conditions defined in
# file 'LICENSE', which is part of this source code package.
#       Copyright (c) 2013 R Pratap Chakravarthy

from   pluggdapps.plugin        import Plugin, implements
import pluggdapps.utils         as h
import pluggdapps.interfaces

import pagd.interfaces

class Tayra( Plugin ):
    """Plugin to translate tayra templates to html files."""
    implements( pagd.interfaces.ITemplate )

    extensions = ['ttl', 'tayra', 'tmpl']   # default template

    def __init__( self ):
        setts = h.settingsfor( 'tayra.ttlcompiler.', self['siteconfig'] )
        setts.update( helpers=['pagd.h'], debug=True )
        self.ttlplugin = self.qp(
                pluggdapps.interfaces.ITemplate, 'tayra.TTLCompiler',
                settings=setts )
        
    def render( self, page ):
        return self.ttlplugin.render( page.context, file=page.templatefile )

########NEW FILE########
