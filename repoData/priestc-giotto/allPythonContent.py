__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Giotto documentation build configuration file, created by
# sphinx-quickstart on Fri Oct 12 22:50:00 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.doctest', 'sphinx.ext.intersphinx', 'sphinx.ext.todo']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Giotto'
copyright = u'2013, Chris Priest'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.11.0'
# The full version, including alpha/beta/rc tags.
release = '0.11.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Giottodoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Giotto.tex', u'Giotto Documentation',
   u'Chris Priest', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'giotto', u'Giotto Documentation',
     [u'Chris Priest'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Giotto', u'Giotto Documentation',
   u'Chris Priest', 'Giotto', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = manifest
from giotto import get_config
from giotto.programs import Program, Manifest
from giotto.views import GiottoView, BasicView, jinja_template
from giotto.control import Redirection

from .middleware import NotAuthenticatedOrRedirect, AuthenticationMiddleware, NotAuthenticatedOrDie, LogoutMiddleware
from .models import create_session, basic_register, User

def create_auth_manifest(**kwargs):
    """
    Creates a basic authentication manifest for logging in, logging out and
    registering new accounts.
    """
    class AuthProgram(Program):
        pre_input_middleware = [AuthenticationMiddleware]

    def register(username, password, password2):
        """
        Decorated version of basic_register with a callback added.
        """
        result = basic_register(username, password, password2)
        callback = kwargs.get('post_register_callback', None)
        if callback:
            user = User.objects.get(username=username)
            callback(user)
        return result

    return Manifest({
        'login': [
            AuthProgram(
                """
                Prints out the HTML form for logging in.
                """,
                name="Login (form)",
                input_middleware=[NotAuthenticatedOrRedirect('/')],
                view=BasicView(
                    html=jinja_template('login.html'),
                ),
            ),
            AuthProgram(
                """
                Matches up the username/password against the database, and adds the auth cookies.
                """,
                name="Login (post)",
                input_middleware=[NotAuthenticatedOrDie],
                controllers=['http-post', 'cmd'],
                model=[create_session, {'username': 'mock_user', 'session_key': 'XXXXXXXXXXXXXXX'}],
                view=BasicView(
                    persist=lambda m: {'giotto_session': m['session_key']},
                    html=lambda m: Redirection('/'),
                ),
            ),
        ],
        'logout': AuthProgram(
            """
            Send the user here to log them out. Removes their cookies and deletes the auth session.
            """,
            name="Logout",
            view=BasicView(
                html=Redirection('/'),
            ),
            output_middleware=[LogoutMiddleware],
        ),
        'register': [
            AuthProgram(
                """
                This program returns the HTML page with the form for registering a new account.
                HTTP-get only.
                """,
                name="Register (form)",
                input_middleware=[NotAuthenticatedOrRedirect('/')],
                view=BasicView(
                    html=jinja_template('register.html'),
                ),
            ),
            AuthProgram(
                """
                When you POST the register form, this program handles creating the new user, then redirecting you to '/'
                """,
                name="Register (post)",
                controllers=['http-post'],
                model=[register],
                view=BasicView(
                    persist=lambda m: {'giotto_session': m['session_key']},
                    html=lambda m: Redirection('/'),
                ),
            ),
        ],
    })
########NEW FILE########
__FILENAME__ = middleware
from __future__ import print_function
import json
import getpass

from .models import User
from giotto.exceptions import NotAuthorized
from giotto.control import Redirection
from giotto import get_config
from giotto.middleware import GiottoOutputMiddleware, GiottoInputMiddleware

class AuthenticationMiddleware(GiottoInputMiddleware):
    """
    This input middleware class must preceed any other authentication middleware class.
    It is used to extract authentiction information from the request, and
    verify that the credientials are correct.
    """
    def http(self, request):
        user = None
        session_key = request.cookies.get('giotto_session', None)
        if not session_key and request.POST:
            session_key = request.POST.get('auth_session', None)
        if session_key:
            username = get_config('auth_session_engine').get(session_key)
            try:
                user = User.objects.get(username=username)
            except User.DoesNotExist:
                user = None
        
        setattr(request, 'user', user)
        return request

    def cmd(self, request):
        user = None
        session_key = request.enviornment.get('GIOTTO_SESSION', None)
        if session_key:
            user = get_config('auth_session').get(session_key)

        if not user:
            print("Username:")
            username = raw_input()
            password = getpass.getpass()
            user = User.objects.get_user_by_password(username, password)

        setattr(request, 'user', user)
        return request

class AuthenticatedOrDie(GiottoInputMiddleware):
    """
    Put this in the input middleware stream to fail any requests that aren't
    made by authenticated users
    """
    def http(self, request):
        if not request.user:
            raise NotAuthorized('Must be Logged in for this program')
        return request

    def cmd(self, request):
        user = getattr(request, 'user', None)
        if not user:
            raise SystemExit("Must be logged in")
        return request

class NotAuthenticatedOrDie(GiottoInputMiddleware):
    """
    Put this in the input middleware stream to fail any requests that aren't
    made by authenticated users
    """
    def http(self, request):
        if request.user:
            raise NotAuthorized('Must not be Logged in for this program')
        return request

    def cmd(self, request):
        user = getattr(request, 'user', None)
        if user:
            raise SystemExit("Must not be logged in for this program")
        return request

def AuthenticatedOrRedirect(invocation):
    """
    Middleware class factory that redirects if the user is not logged in.
    Otherwise, nothing is effected.
    """
    class AuthenticatedOrRedirect(GiottoInputMiddleware):
        def http(self, request):
            if request.user:
                return request
            return Redirection(invocation)

        def cmd(self, request):
            if request.user:
                return request
            return Redirection(invocation)

    return AuthenticatedOrRedirect


def NotAuthenticatedOrRedirect(invocation):
    """
    Middleware class factory that redirects if the user is not logged in.
    Otherwise, nothing is effected.
    """
    class NotAuthenticatedOrRedirect(GiottoInputMiddleware):
        def http(self, request):
            if not request.user:
                return request
            return Redirection(invocation)

        def cmd(self, request):
            if not request.user:
                return request
            return Redirection(invocation)

    return NotAuthenticatedOrRedirect


class LogoutMiddleware(GiottoOutputMiddleware):
    """
    Logout the user. This not only deletes the session key in persistence (the
    cookie), but also nukes the session in the database so it will never
    ve valid again.
    """
    def http(self, request, response):
        if request.method == 'POST' and 'auth_session' in request.POST:
            key = request.POST['auth_session']
            session_key = get_config('auth_session').set(key, None, 1) # nuke session
        response.delete_cookie('giotto_session')
        return response
########NEW FILE########
__FILENAME__ = models
import re
import bcrypt

from giotto.exceptions import InvalidInput
from giotto.utils import random_string
from giotto.primitives import LOGGED_IN_USER
from giotto import get_config
from giotto.models import User

def basic_register(username, password, password2):
    """
    Register a user and session, and then return the session_key and user.
    """
    if password != password2:
        raise InvalidInput(password={'message': "Passwords do not match"},
                           username={'value': username})
    user = User.objects.create_user(username, password)
    return create_session(user.username, password)

def create_session(username, password):
    """
    Create a session for the user, and then return the key.
    """
    user = User.objects.get_user_by_password(username, password)
    auth_session_engine = get_config('auth_session_engine')
    if not user:
        raise InvalidInput('Username or password incorrect')
    session_key = random_string(15)
    while auth_session_engine.get(session_key):
        session_key = random_string(15)
    auth_session_engine.set(session_key, user.username, get_config('auth_session_expire'))
    return {'session_key': session_key, 'user': user}
########NEW FILE########
__FILENAME__ = views
from giotto.views import GiottoView, renders
from giotto.control import Redirection

class BasicRegisterForm(GiottoView):
    @renders('text/html')
    def html(self, result):
        return """<!DOCTYPE html>
        <html>
            <body>
                <form method="post" action="">
                    username: <input name="username" type="text"><br>
                    password: <input name="password" type="password"><br>
                    <input type="submit">
                </form>
            </body>
        </html>
        """

def LoginView(http_redirect=None):
    """
    After logging in, redirect the user to the ``http_redirect`` program.
    This is a meta program, a function that returns a program.
    ``http_redirect`` can be either a string, or a three item tuple with M objects:
    http_redirect=('/blog', [m.id], {}) | http_redirect=('/blog', [], {'name': M['name']})
    """
    class LoginView(GiottoView):
        """
        ``result`` is the session that was newly created. consult the
        ``create_session`` model for reference.
        """
        @renders('text/html')
        def html(self, result):
            ty = type(http_redirect)
            if ty == list or ty == tuple:
                assert len(http_redirect) == 3, "http_redirect must be three items"
                return Redirection(http_redirect[0], args=http_redirect[1], kwargs=http_redirect[2])
            else:
                # assume a string was passed in.
                return Redirection(http_redirect)
    return LoginView
########NEW FILE########
__FILENAME__ = middleware
from giotto.middleware import GiottoOutputMiddleware

class AppendMessages(GiottoOutputMiddleware):
    def html(self, request, response):
        from .models import Message
        user = getattr(request, 'user', None)
        if not user:
            return response
        engine, template, context = response.data
        context['messages'] = Message.get(user=user)
        response.body = (engine, template, context)
        return response
########NEW FILE########
__FILENAME__ = models
from sqlalchemy import Column, String, Integer
from giotto import get_confg
Base = get_confg('Base')

class Message(Base):
    message = Column(String)
    level = Column(Integer)

    user_id = Column(Integer, ForeignKey('giotto_user.username'))
    user = relationship("User", backref=backref('messages', order_by=id))

    @classmethod
    def get(cls, user):
        return config.session.query(cls).filter(user=user).all()

    @classmethod
    def info(cls, user, message):
        return _make_message(user, message, level=1)

    @classmethod
    def debug(cls, user, message):
        return _make_message(user, message, level=2)

    @classmethod
    def error(cls, user, message):
        return _make_message(user, message, level=3)

    @classmethod
    def fatal(cls, user, message):
        return _make_message(user, message, level=4)

    @classmethod
    def _make_message(user, message, level):
        msg = cls(user=user, level=level)
        config.session.add(msg)
        config.session.commit()
########NEW FILE########
__FILENAME__ = manifest

########NEW FILE########
__FILENAME__ = programs
import os
import mimetypes

from giotto import get_config
from giotto.programs import Program
from giotto.views import GiottoView, renders
from giotto.utils import super_accept_to_mimetype
from giotto.exceptions import DataNotFound
from giotto.primitives import RAW_INVOCATION_ARGS

class FileView(GiottoView):

    def render(self, result, mimetype, errors):
        return super(FileView, self).render(result, "*/*", errors)

    @renders('*/*')
    def any(self, result):
        return {'body': result[0], 'mimetype': result[1]}

    @renders('text/x-cmd')
    def cmd(self, result):
        return {'body': result.read(), 'mimetype': ''}

def StaticServe(base_path='/views/static/'):
    """
    Meta program for serving any file based on the path
    """
    def get_file(path=RAW_INVOCATION_ARGS):
        fullpath = get_config('project_path') + os.path.join(base_path, path)
        try:
            mime, encoding = mimetypes.guess_type(fullpath)
            return open(fullpath, 'rb'), mime or 'application/octet-stream'
        except IOError:
            raise DataNotFound("File does not exist")

    class StaticServe(Program):
        controllers = ['http-get']
        model = [get_file]
        view = FileView()

    return StaticServe()

def SingleStaticServe(file_path):
    """
    Meta program for serving a single file. Useful for favicon.ico and robots.txt
    """
    def get_file():
        mime, encoding = mimetypes.guess_type(file_path)
        fullpath = os.path.join(get_config('project_path'), file_path)
        return open(fullpath, 'rb'), mime or 'application/octet-stream'

    class SingleStaticServe(Program):
        controllers = ['http-get']
        model = [get_file]
        view = FileView()

    return SingleStaticServe()
########NEW FILE########
__FILENAME__ = control
class GiottoControl(object):
    pass

class Redirection(GiottoControl):
    # because render functions have this defined, and this object can be used in lieu
    # of a render function.
    __name__ = '__Redirection'
    def __init__(self, path, persist={}):
        self.path = path
        self.persist = persist
########NEW FILE########
__FILENAME__ = cmd
import os

from giotto.utils import parse_kwargs
from giotto.controllers import GiottoController
from giotto.control import Redirection

cmd_execution_snippet = """
args = sys.argv
mock = '--model-mock' in args
if mock:
    # remove the mock argument so the controller doesn't get confused
    args.pop(args.index('--model-mock'))
from giotto.controllers.cmd import CMDController, CMDRequest
request = CMDRequest(sys.argv)
controller = CMDController(request=request, manifest=manifest, model_mock=mock)
controller.get_response()"""


def make_cmd_invocation(invocation, args, kwargs):
    """
    >>> make_cmd_invocation('path/program', ['arg1', 'arg2'], {'darg': 4})
    ['./giotto-cmd', '/path/program/arg1/arg2/', '--darg=4']
    """
    if not invocation.endswith('/'):
        invocation += '/'
    if not invocation.startswith('/'):
        invocation = '/' + invocation

    cmd = invocation

    for arg in args:
        cmd += str(arg) + "/"

    rendered_kwargs = []
    for k, v in kwargs.items():
        rendered_kwargs.append("--%s=%s" % (k,v))
    
    return ['./giotto-cmd', cmd] + rendered_kwargs

class CMDRequest(object):
    def __init__(self, argv):
        self.enviornment = os.environ
        self.argv = argv

class CMDController(GiottoController):
    """
    Basic command line cntroller class. self.request will be the value found
    in sys.argv; a list of commandline arguments with the first item being the 
    name of the script ('giotto'), the second being the name of th program
    and the rest being commandline arguments.
    """
    name = 'cmd'
    default_mimetype = 'text/x-cmd'

    def get_invocation(self):
        return self.request.argv[1]

    def get_controller_name(self):
        return 'cmd'

    def get_raw_data(self):
        """
        Parse the raw commandline arguments (from sys.argv) to a dictionary
        that is understandable to the rest of the framework.
        """
        arguments = self.request.argv[1:]
        if not arguments[0].startswith('--'):
            # first argument is the program name
            arguments = arguments[1:]
        return parse_kwargs(arguments)

    def get_concrete_response(self):
        result = self.get_data_response()
        
        if type(result) == Redirection:
            invocation, args, kwargs = result.rendered_invocation
            rendered_invocation = make_cmd_invocation(invocation, args, kwargs)
            req = CMDRequest(rendered_invocation)
            return CMDController(req, self.manifest, self.model_mock)
        else:
            response = {
                'stdout': [result['body']],
                'stderr': [],
            }

        # now do middleware
        stdout = response['stdout']

        if hasattr(stdout, 'write'):
            # returned is a file, print out the contents through stdout
            print(stdout.write())
        else:
            for line in stdout:
                print(line)

        for line in response['stderr']:
            sys.stderr.write(line)

    def persist(self, persist, response):
        print("persist\n================")
        for key, value in persist.iteritems():
            print("export %s=%s" % (key.upper(), value))

    def get_primitive(self, name):
        if name == 'ALL_DATA':
            return self.get_raw_data()
        elif name == 'LOGGED_IN_USER':
            return getattr(self.request, 'user', None)

########NEW FILE########
__FILENAME__ = http
import traceback
import base64

try:
    from urllib.parse import urlencode, unquote
except ImportError:
    from urllib import urlencode, unquote

try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

from giotto.exceptions import NoViewMethod, InvalidInput, NotAuthorized, DataNotFound, ProgramNotFound
from giotto.controllers import GiottoController
from giotto.control import Redirection
from giotto.utils import render_error_page
from webob import Request, Response
from webob.exc import (
    HTTPUnsupportedMediaType, HTTPMethodNotAllowed, HTTPFound,
    HTTPNotFound, HTTPForbidden
)

http_execution_snippet = """import sys
mock = '--model-mock' in sys.argv
from giotto import get_config
from giotto.controllers.http import make_app, fancy_error_template_middleware, serve

application = make_app(manifest, model_mock=mock)

if not get_config('debug'):
    application = fancy_error_template_middleware(application)

if '--run' in sys.argv:
    serve('127.0.0.1', 5000, application, ssl=None, use_debugger=True, use_reloader=True)

if '--run-ssl' in sys.argv:
    serve('127.0.0.1', 443, application, ssl='adhoc', use_debugger=True, use_reloader=True)
"""


def serve(ip, port, application, ssl=None, processes=1, **kwargs):
    """
    Serve a wsgi app (any wsgi app) through with either werkzeug's runserver
    or the one that comes with python. Setting `processes` to anything other than 1
    will prevent the debigger from working.
    """

    try:
        # use werkzeug if its there
        from werkzeug.serving import run_simple
        print("Using Werkzeug run_simple")
        run_simple(ip, port, application, ssl_context=ssl, processes=processes, **kwargs)
        return
    except ImportError:
        pass

    # otherwise just use python's built in wsgi webserver
    from wsgiref.simple_server import make_server
    server = make_server(ip, port, application)
    print("Serving on %s:%s, using built in Python server" % (ip, port))
    try:
        server.serve_forever()
    except KeyboardInterrupt:
        pass

def make_url(invocation, args=[], kwargs={}):
    """
    >>> make_url('some/path/program', ['arg1', 'arg2'], {'arg3': 4})
    '/some/path/program/arg1/arg2?arg3=4'
    """
    if not invocation.endswith('/'):
        invocation += '/'
    if not invocation.startswith('/'):
        invocation = '/' + invocation

    url = invocation

    for arg in args:
        url += str(arg) + "/"

    if kwargs:
        url = url[:-1]
        url += "?" + urlencode(kwargs)
    
    return url


class HTTPController(GiottoController):
    name = 'http'
    default_mimetype = 'text/html'

    def mimetype_override(self):
        accept = self.request.headers.get('Accept', '')
        has_json_in_view = self.program.view and self.program.view.can_render('json')
        if accept == '*/*' and self.request.is_xhr and has_json_in_view:
            # return json on ajax calls if no accept headers are present.
            # and only if the view has implemented a application/json method
            return "application/json"

        if accept != '*/*' and not accept.startswith('text/html'):
            return accept
        return None

    def get_invocation(self):
        return self.request.path

    def get_controller_name(self):
        return 'http-%s' % self.request.method.lower()

    def get_raw_data(self):
        data = {}
        if self.request.method == 'GET':
            data = self.request.GET
        elif self.request.method == 'POST':
            data = self.request.POST

        return data

    def get_concrete_response(self):
        try:
            result = self.get_data_response()
        except NoViewMethod as exc:
            return HTTPUnsupportedMediaType(
                body=render_error_page(415, exc, mimetype=self.mimetype),
                content_type="text/html"
            )
        except InvalidInput as exc:
            ## if the model raises a InvalidInput, retry the request as
            ## a GET request for the same program, and set the code to 400.
            request = make_duplicate_request(self.request)
            request.method = 'GET'
            c = HTTPController(request, self.manifest, self.model_mock, errors=exc)
            response = c.get_response()
            response.status_int = 400
            return response
        except NotAuthorized as exc:
            return HTTPForbidden(
                body=render_error_page(403, exc, mimetype=self.mimetype),
                content_type="text/html"
            )
        except (DataNotFound, ProgramNotFound) as exc:
            return HTTPNotFound(
                body=render_error_page(404, exc, mimetype=self.mimetype),
                content_type="text/html"
            )

        if type(result['body']) == Redirection:
            response = HTTPFound(location=result['body'].path)
        else:
            lazy = None
            body = result['body']

            if type(body) == tuple:
                lazy = body
                body = ''

            if hasattr(body, 'read'):
                body = body.read()

            response = Response(
                status=200,
                body=body,
                content_type=result['mimetype'],
            )

            response.lazy_data = lazy

        return response

    def persist(self, persist, response):
        for key, value in persist.items():
            response.set_cookie(key, value)
        return response

    def get_primitive(self, primitive):
        if primitive == 'USER':
            auth = self.request.authorization and self.request.authorization[1]
            userpass = (auth and base64.b64decode(auth)) or None
            return (userpass and userpass.split(":")[0]) or None
        if primitive == 'ALL_DATA':
            return self.get_raw_data()
        if primitive == 'LOGGED_IN_USER':
            return self.request.user
        if primitive == 'RAW_INVOCATION_ARGS':
            return unquote('/'.join(self.path_args))

        raise Exception("Primitive not supported")


def make_duplicate_request(request):
    """
    Since werkzeug request objects are immutable, this is needed to create an
    identical reuet object with immutable values so it can be retried after a
    POST failure.
    """
    class FakeRequest(object):
        method = 'GET'
        path = request.path
        headers = request.headers
        GET = request.GET
        POST = request.POST
        user = getattr(request, 'user', None)
        cookies = request.cookies
        is_xhr = request.is_xhr
    return FakeRequest()


def make_app(manifest, model_mock=False, cache=None):
    
    def application(environ, start_response):
        """
        WSGI app for serving giotto applications
        """
        request = Request(environ)
        controller = HTTPController(request, manifest, model_mock=model_mock)
        try:
            wsgi_response = controller.get_response()
        except:
            # TODO: switch to django
            #get_config('db_session').rollback()
            raise

        return wsgi_response(environ, start_response)

    return application


def fancy_error_template_middleware(app):
    """
    WGSI middleware for catching errors and rendering the error page.
    """
    def application(environ, start_response):
        try:
            return app(environ, start_response)
        except Exception as exc:
            sio = StringIO()
            traceback.print_exc(file=sio)
            sio.seek(0)
            response =  Response(
                status=500,
                body=render_error_page(500, exc, traceback=sio.read()),
                content_type="text/html"
            )
            return response(environ, start_response)

    return application






########NEW FILE########
__FILENAME__ = irc_
import sys 
import socket 
import string 
import os
import traceback

try:
  import irc.bot
except ImportError:
  raise ImportError("Requires irclib; pip install irc")

from giotto.controllers import GiottoController
from giotto.exceptions import ProgramNotFound
from giotto.utils import parse_kwargs

irc_execution_snippet = """
parser = argparse.ArgumentParser(description='Giotto IRC Controller')
parser.add_argument('--model-mock', action='store_true', help='Mock out the model')
args = parser.parse_args()

config = {
    'host': '',
    'port': 6667,
    'nick': '',
    'ident': 'giotto',
    'realname': 'Giotto IRC Bot',
    'owner': '',
    'channels': '', # comma seperated
    'magic_token': '!giotto ',
}
from giotto.controllers.irc_ import listen
listen(manifest, config, model_mock=args.model_mock)"""

class IRCController(GiottoController):
    name = 'irc'
    default_mimetype = 'text/x-irc'

    def get_invocation(self):
        return self.request.program

    def get_controller_name(self):
        return 'irc'

    def get_raw_data(self):
        kwargs = self.request.args
        return parse_kwargs(kwargs)

    def get_concrete_response(self):
        try:
            result = self.get_data_response()
        except ProgramNotFound:
            result = {'body': "Program not found"}

        # convert to a format appropriate to the IRC Response api.
        return dict(
            response=result['body'],
            say_to=self.request.sent_to,
        )

    def get_primitive(self, primitive):
        if primitive == 'RAW_PAYLOAD':
            return self.get_data()


class IRCRequest(object):

    # the program name requested
    program = ''
    
    # the usr/channel the message was sent to
    sent_to = ''

    # PRIVMSG or whatever else...
    msg_type = ''

    # The message after the magic token has been removed
    # eg: !giotto multiply --x=1 --y=2  --> multiply --x=1 --y=2
    # note, invocations given through private message have no magic token
    # so this value will be the same as `message`
    message_token_removed = ''

    # the raw message with the magic token still attached
    raw_message = ''

    # boolean, was this request sent to a channel (True) or through private msg?
    channel_msg = None

    # opposite of `channel_msg`
    private_msg = None

    # the username of the person who made the request
    username = ''

    # the ident of the user who made the request
    ident = ''

    def __init__(self, event, magic_token, nick):
        self.ident = event.source
        self.username = self.ident.split("!")[0]
        self.msg_type = event.type
        self.sent_to = event.target
        self.private_message = self.msg_type == "privmsg"
        self.raw_message = event.arguments[0]
        self.program, self.args = self.get_program_and_args(self.raw_message,magic_token)

    def get_program_and_args(self, message, magic_token):
        if self.private_message == True:
            program = message.split()[0]
            args = message.split()[1:]
        else:
            # channel invocationa
            l = len(magic_token)
            parsed_message = message[l:]
            args = parsed_message.split()[1:]
            program = parsed_message.split()[0]
      
        return program, args

    def __repr__(self):
        return "program: %s, args: %s" % (self.program, self.args)

class IrcBot(irc.bot.SingleServerIRCBot):
    def __init__(self, config):
        if not config['host']:
            raise SystemExit('Error: IRC controller needs to be configured with a hostname')

        if not config['nick']:
            raise SystemExit('Error: IRC controller needs to be configured with a nick')

        print("Connecting to %s:%s as %s" % (config['host'],config['port'], config['nick']))

        irc.bot.SingleServerIRCBot.__init__(
            self, 
            [(config['host'],config['port'])], 
            config['nick'], 
            config['realname']
        )

        channels = config['channels']
        if channels:
            self.channel = channels
            print("Joining Channels: %s" % channels)
        self.config = config
  
    def on_nicknameinuse(self, connection, event):
        connection.nick(connection.get_nickname + "_")

    def on_welcome(self, connection, event):
        connection.join(self.channel)

    def on_privmsg(self, connection, event):
        self.process_message(connection, event)

    def on_pubmsg(self, connection, event):
        if event.arguments[0].startswith(self.config['magic_token']) == False:
            return
        self.process_message(connection, event)
 
    def process_message(self, connection, event):
        request = IRCRequest(
            event,
            self.config['magic_token'],
            connection.get_nickname()
        )
        
        try:
            controller = IRCController(request, self.config['manifest'], self.config['model_mock'])
            result = controller.get_response()
        except Exception as exc:
            cls = exc.__class__.__name__
            connection.privmsg(request.sent_to, "\x0304%s - %s: %s" % (request.program, cls, exc))
            traceback.print_exc(file=sys.stdout)
        else:
            msg = "%s: %s" % (request.username, result['response'])
            if request.private_message:
                for m in msg.split('\n'):
                    connection.privmsg(request.username, m)
            else:
                for m in msg.split('\n'):
                    connection.privmsg(request.sent_to, m)

def listen(manifest, config, model_mock=False):
    """
    IRC listening process.
    """
    config['manifest'] = manifest
    config['model_mock'] = model_mock
    IRC = IrcBot(config)
    try:
        IRC.start()
    except KeyboardInterrupt:
        pass
########NEW FILE########
__FILENAME__ = demo
demo_application = '''from giotto.programs import Program, Manifest
from giotto.views import BasicView, renders

class ColoredMultiplyView(BasicView):
    @renders('text/plain')
    def plaintext(self, result):
        return "{{ obj.x }} * {{ obj.y }} == {{ obj.product }}"

    @renders('text/html')
    def html(self, result):
        return """<!DOCTYPE html>
        <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js"></script>
        <html>
            <body>
                <span style="color: blue">%(x)s * %(y)s</span> == 
                <span style="color: red">%(product)s</span>
            </body>
        </html>""" % result

    @renders('text/x-cmd')
    def cmd(self, result):
        from colorama import init, Fore
        init()
        return "{blue}{x} * {y}{reset} == {red}{product}{reset}".format(
            blue=Fore.BLUE,
            red=Fore.RED,
            reset=Fore.RESET,
            x=result['x'],
            y=result['y'],
            product=result['product'],
        )

    @renders('text/x-irc')
    def irc(self, result):
        return "{blue}{x} * {y}{reset} == {red}{product}{reset}".format(
            blue="\x0302",
            red="\x0304",
            reset="\x03",
            x=result['x'],
            y=result['y'],
            product=result['product'],
        )


def multiply(x, y):
    return {'x': int(x), 'y': int(y), 'product': int(x) * int(y)}

manifest = Manifest({
    'multiply': Program(
        controllers = ('http-get', 'cmd', 'irc'),
        model=[multiply, {'x': 3, 'y': 3, 'product': 9}],
        view=ColoredMultiplyView
    )
})'''
########NEW FILE########
__FILENAME__ = exceptions
from collections import defaultdict
from giotto.utils import Mock

class GiottoException(Exception):
    """
    Represents an exception that Giotto catches internally.
    """

class InvalidInput(GiottoException):
    def __init__(self, message='', **kwargs):
        self.message = message
        for k, v in kwargs.items():
            setattr(self, k, v)

    def __str__(self):
        return self.message

    def __setattr__(self, attr, value):
        """
        When setting values, make into a dictionary with 'message' and 'value'
        keys.
        """
        if attr == 'message':
            return super(InvalidInput, self).__setattr__(attr, value)
        if value is None:
            return super(InvalidInput, self).__setattr__(attr, None)
        if type(value) is not dict:
            value = {'value': value, 'message': ''}
            return super(InvalidInput, self).__setattr__(attr, value)
        if not 'message' in value:
            value['message'] = ''
        if not 'value' in value:
            value['value'] = ''

        super(InvalidInput, self).__setattr__(attr, value)

    def __getitem__(self, item):
        # be permissive of attribute errors because jinja templates
        # need to not blow up when there are no errors.
        if not item in self.__dict__:
            return Mock()

class InvalidInvocation(GiottoException):
    pass

class ProgramNotFound(GiottoException):
    pass

class DataNotFound(GiottoException):
    pass

class NoViewMethod(GiottoException):
    pass

class MockNotFound(GiottoException):
    pass

class NotAuthorized(GiottoException):
    pass

class ControlMiddlewareInterrupt(GiottoException):
    def __init__(self, message=None, control=None):
        self.control = control
        self.message = message

        # render the control object now because this object will never
        self.control.render(None, 'some_mimetype', None)
########NEW FILE########
__FILENAME__ = keyvalue
from collections import defaultdict
import datetime
import pickle

try:
    import pylibmc
except ImportError:
    pylibmc = None

try:
    import redis
except ImportError:
    redis = None

class GiottoKeyValue(object):
    """
    Baseclass for all KeyValue object. This exists to demonstrate the API for
    KeyValue subclasses.
    """
    def __init__(*a, **k):
        return
    
    def set(self, key, obj):
        raise NotImplementedError

    def get(self, key, obj):
        raise NotImplementedError

class DatabaseKeyValue(GiottoKeyValue):

    def get(self, key):
        from giotto.djangoapp.models import DBKeyValue
        return DBKeyValue.objects.cache_get(key)

    def set(self, key, obj, expire):
        from giotto.djangoapp.models import DBKeyValue
        return DBKeyValue.objects.cache_set(key, obj, expire)

locmem = {}
class LocMemKeyValue(GiottoKeyValue):
    """
    KeyValue backend that stores everything in a python dict.
    """
    def get(self, key):
        if key not in locmem:
            return None

        result = locmem[key]
        expire = result[1]
        obj = result[0]

        if datetime.datetime.now() < expire:
            return obj

        del locmem[key]
        return None # obj has expired.

    def set(self, key, obj, expire):
        when_expire = datetime.datetime.now() + datetime.timedelta(seconds=expire)
        locmem[key] = (obj, when_expire)


class MemcacheKeyValue(GiottoKeyValue):
    def __init__(self, host=['localhost'], behavior={}):
        if not pylibmc:
            msg = 'pylibmc not installed! install with: pip install pylibmc'
            raise ImportError(msg)
        if hasattr(host, 'lower'):
            host = [host]
        kwargs = {'servers': host, 'binary': True}
        if behavior:
            kwargs['behavior'] = behavior
        self.client = pylibmc.Client(**kwargs)

    def set(self, key, obj, expire):
        self.client.set(str(key), obj, time=expire)

    def get(self, key):
        return self.client.get(str(key))

class RedisKeyValue(GiottoKeyValue):
    def __init__(self, host='localhost', port=6379, db=0):
        if not redis:
            msg = 'redis python wrapper not installed! install with: pip install redis'
            raise ImportError(msg)
        self.redis = redis.StrictRedis(host=host, port=port, db=db)

    def set(self, key, obj, expire):
        self.redis.setex(key, expire, pickle.dumps(obj))

    def get(self, key):
        pickled_value = self.redis.get(key)
        if pickled_value is None:
            return None
        return pickle.loads(pickled_value)

class DummyKeyValue(GiottoKeyValue):
    """
    Cache that does not save nor return a hit ever. Used as a placeholder.
    """
    def set(self, key, obj, expire):
        return None

    def get(self, key):
        return None
########NEW FILE########
__FILENAME__ = middleware
class GiottoOutputMiddleware(object):
    def __init__(self, controller):
        self.controller = controller

class GiottoInputMiddleware(object):
    def __init__(self, controller):
        self.controller = controller

class RenderLazytemplate(GiottoOutputMiddleware):
    def http(self, request, response):
        engine, template, context = response.lazy_data
        if engine == 'jinja2':
            rendered = template.render(**context)
        response.text = rendered
        return response
########NEW FILE########
__FILENAME__ = primitives
class GiottoPrimitive(object): 
    def __init__(self, name):
        self.name = name

    def __repr__(self):
    	return "(Giotto Primitive: %s)" % self.name

LOGGED_IN_USER = GiottoPrimitive("LOGGED_IN_USER")
ALL_DATA = GiottoPrimitive("ALL_DATA")
USER_COUNTRY = GiottoPrimitive("USER_COUNTRY")
PREVIOUS_INPUT = GiottoPrimitive("PREVIOUS_INPUT")
PREVIOUS_ERRORS = GiottoPrimitive("PREVIOUS_ERRORS")
ALL_PROGRAMS = GiottoPrimitive('ALL_PROGRAMS')
USER = GiottoPrimitive("USER")
RAW_INVOCATION_ARGS = GiottoPrimitive("RAW_INVOCATION_ARGS")
########NEW FILE########
__FILENAME__ = management
from giotto.programs import Program, Manifest
from giotto.programs.shell import shell
from giotto.programs.tables import syncdb, flush
from giotto.views import BasicView

management_manifest = Manifest({
    'syncdb': Program(
        name="Make Tables",
        controllers=['cmd'],
        model=[syncdb],
        view=BasicView()
    ),
    'flush': Program(
        name="Blast Tables",
        controllers=['cmd'],
        model=[flush],
        view=BasicView(),
    ),
    'shell': Program(
        name="Giotto Shell",
        controllers=['cmd'],
        model=[shell],
        view=BasicView(),
    ),
})
########NEW FILE########
__FILENAME__ = shell
import os
import giotto

def shell(shell=''):
    
    if shell == "bpython" or shell == 'b':
        config = giotto._config
        import bpython
        bpython.embed()
        return

    elif shell == 'ipython' or shell == 'i':
        config = giotto._config
        from IPython import embed
        embed()
        return

    else:
        import code
        imported_objects = {'config': giotto._config}
        try:  # Try activating rlcompleter, because it's handy.
            import readline
        except ImportError:
            pass
        else:
            # We don't have to wrap the following import in a 'try', because
            # we already know 'readline' was imported successfully.
            import rlcompleter
            readline.set_completer(rlcompleter.Completer(imported_objects).complete)
            readline.parse_and_bind("tab:complete")

        # We want to honor both $PYTHONSTARTUP and .pythonrc.py, so follow system
        # conventions and get $PYTHONSTARTUP first then .pythonrc.py.
        for pythonrc in (os.environ.get("PYTHONSTARTUP"),
                         os.path.expanduser('~/.pythonrc.py')):
            if pythonrc and os.path.isfile(pythonrc):
                try:
                    with open(pythonrc) as handle:
                        exec(compile(handle.read(), pythonrc, 'exec'))
                except NameError:
                    pass
        code.interact(local=imported_objects)
########NEW FILE########
__FILENAME__ = tables
import six
from giotto import get_config
from django.core.management import call_command

def syncdb():
    """
    Create all the tables for the models that have been added to the manifest.
    """
    call_command('syncdb', traceback=True)

def flush():
    """
    Drop all existing tables in the database, and then recreate them.
    """
    return call_command('flush', traceback=True)
########NEW FILE########
__FILENAME__ = argspec_test
import unittest

from giotto.programs import Program
from giotto.views import GiottoView

class ArgspecTest(unittest.TestCase):

    def test_only_args(self):
        def model(var1, var2): return None
        args, kwargs = Program(model=[model]).get_model_args_kwargs()
        self.assertEquals(args, ['var1', 'var2'])
        self.assertEquals(kwargs, {})

    def test_only_kwargs(self):
        def model(var1=3, var2=9): return None
        args, kwargs = Program(model=[model]).get_model_args_kwargs()
        self.assertEquals(args, [])
        self.assertEquals(kwargs, {'var1': 3, 'var2': 9})

    def test_both(self):
        def model(var0, var1=3, var2=9): return None
        args, kwargs = Program(model=[model]).get_model_args_kwargs()
        self.assertEquals(args, ['var0'])
        self.assertEquals(kwargs, {'var1': 3, 'var2': 9})

    def test_cls_arg(self):
        """
        cls var gets ignored when getting args for a model callable
        """
        class Model(object):
            @classmethod
            def model(cls, var0, var1=3, var2=9):
                return None
        args, kwargs = Program(model=[Model.model]).get_model_args_kwargs()
        self.assertEquals(args, ['var0'])
        self.assertEquals(kwargs, {'var1': 3, 'var2': 9})

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = exception_tests
import unittest

from giotto.exceptions import InvalidInput

class InvalidInputTest(unittest.TestCase):

    def test_just_message(self):
        exc1 = InvalidInput("Message")
        exc2 = InvalidInput(message="Message")

        self.assertEquals(exc1.message, "Message")
        self.assertEquals(str(exc1), "Message")
        self.assertEquals(str(exc1), str(exc2))

    def test_basic_kwargs(self):
        exc = InvalidInput("Message", x=3, y=2)
        self.assertEquals(exc.x['message'], '')
        self.assertEquals(exc.x['value'], 3)

    def test_complex_kwargs(self):
        exc = InvalidInput("Message", x={'message': "too large", "value": 4})
        self.assertEquals(exc.x['message'], "too large")
        self.assertEquals(exc.x['value'], 4)
        self.assertEquals(str(exc), "Message")

    def test_empty_template_safe(self):
        """
        Undefined vars on the exception are treated as empty vars
        """
        exc = InvalidInput("Message", x={'message': "too large", "value": 4})
        self.assertEquals([], [x for x in exc['y']])
        
    def test_direct_value_set(self):
        """
        Directly setting exception values works
        """
        exc = InvalidInput()
        exc.x = 4
        self.assertEquals(exc.x['value'], 4)
        self.assertEquals(exc.x['message'], '')

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = http_controller_test
import unittest
import json

from giotto import initialize
from giotto.controllers.http import HTTPController
from giotto.programs import Program, Manifest
from giotto.exceptions import ProgramNotFound, InvalidInvocation
from giotto.primitives import LOGGED_IN_USER, RAW_INVOCATION_ARGS
from giotto.views import BasicView

from webob import Request

def make_request(path):
	r = Request.blank(path)
	r.user = "My User"
	return r

def no_defaults(x, y):
	"No defaults: x, y"
	return int(x) * int(y)

def defaults(x=4, y=2):
	"defaults: x=4, y=2"
	return int(x) * int(y)

def primitive(x=LOGGED_IN_USER):
	"primitive"
	return int(x) * int(y)

def raw(path=RAW_INVOCATION_ARGS, another=3):
	"raw"
	return path + str(another)

def none(x=None, y=None):
	"none"
	return "%s %s" % (x, y)

def order(a='a', b='b', c='c', d='d', e='e', f='f', g='g'):
	"order"
	return [a, b, c, d, e, f, g]

class FoldingBaseArgTest(unittest.TestCase):
	def setUp(self):
		initialize()
		self.manifest = Manifest({
			'': Program(
				model=[none],
				view=BasicView()
			),
			'named': Program(
				model=[defaults],
				view=BasicView()
			),
			"another": {
				'': Program(name='another root'),
				'name': Program(name='another name', view=BasicView())
			}
		})

	def test_404(self):
		"""
		Verify that an incorrect name invokes as a 404 instead of
		being passed into the root program.
		"""
		request = make_request("/invalid")
		cx = HTTPController(request, self.manifest)
		self.assertRaises(ProgramNotFound, cx.get_data_response)

	def test_nested_404(self):
		"""
		Verify that an incorrect name invokes as a 404 instead of
		being passed into the root program.
		"""
		request = make_request("/another/invalid")
		cx = HTTPController(request, self.manifest)
		self.assertRaises(ProgramNotFound, cx.get_data_response)

class NegotiationTest(unittest.TestCase):

	def setUp(self):
		initialize()
		self.manifest = Manifest({
			'no_defaults': Program(
				model=[no_defaults],
				view=BasicView()
			),
			'defaults': Program(
				model=[defaults],
				view=BasicView()
			),
			'primitives': Program(
				model=[primitive],
				view=BasicView()
			),
			'raw': Program(
				model=[raw],
				view=BasicView()
			),
			'none': Program(
				model=[none],
				view=BasicView
			),
			'order': Program(
				model=[order],
				view=BasicView
			)
		})

	def test_args(self):
		request = make_request("/no_defaults.json/3/5")
		c = HTTPController(request, self.manifest)
		data = c.get_data_response()
		self.assertEquals(json.loads(data['body']), 15)

	def test_kwargs(self):
		request = make_request("/no_defaults.json?x=3&y=4")
		c = HTTPController(request, self.manifest)
		data = c.get_data_response()
		self.assertEquals(json.loads(data['body']), 12)

	def test_mixed(self):
		request = make_request("/no_defaults.json/5?y=4")
		c = HTTPController(request, self.manifest)
		data = c.get_data_response()
		self.assertEquals(json.loads(data['body']), 20)

	def test_default(self):
		request = make_request("/defaults.json")
		c = HTTPController(request, self.manifest)
		data = c.get_data_response()
		self.assertEquals(json.loads(data['body']), 8)

	def test_order(self):
		request = make_request("/order.json/1/2/3/4/5/6/7")
		c = HTTPController(request, self.manifest)
		data = c.get_data_response()
		self.assertEquals(json.loads(data['body']), ['1', '2', '3', '4', '5', '6', '7'])

	def test_order_defaults(self):
		request = make_request("/order.json")
		c = HTTPController(request, self.manifest)
		data = c.get_data_response()
		self.assertEquals(json.loads(data['body']), ['a', 'b', 'c', 'd', 'e', 'f', 'g'])

	def test_none(self):
		request = make_request("/none.json/3")
		c = HTTPController(request, self.manifest)
		data = c.get_data_response()
		self.assertEquals(json.loads(data['body']), "3 None")

	def test_missing(self):
		"""
		Exception is raised when data arguments are missing when invoking a program.
		"""
		request = make_request("/no_defaults.json/5")
		c = HTTPController(request, self.manifest)
		self.assertRaises(Exception, c.get_data_response)

	def test_too_much_data(self):
		"""
		Exception is raised when too many data arguments are passed into a program.
		"""
		request = make_request("/no_defaults.json/5/12/2")
		c = HTTPController(request, self.manifest)
		self.assertRaises(Exception, c.get_data_response)

	def test_raw_primitive(self):
		request = make_request("/raw.json/raw/arg/to_some/program")
		c = HTTPController(request, self.manifest)
		data = c.get_data_response()
		self.assertEquals(json.loads(data['body']), "raw/arg/to_some/program3")
########NEW FILE########
__FILENAME__ = manifest_test
import unittest

from giotto.programs import Manifest, Program
from giotto.exceptions import ProgramNotFound

both = Program(name='both', controllers=['irc', 'http-get'])
blank = Program(name='optional_blank')
double_get = Program(name="getter", controllers=['http-get'])
double_post = Program(name="poster", controllers=['http-post'])

class StackedRootTest(unittest.TestCase):
    def setUp(self):
        self.manifest = Manifest({
            '': Manifest({
                '': Manifest({
                    '': Program(name='root'),
                    'deep': Program(name="deep")
                }),
            }),
            'sub': {
                'prog': Program(name="prog"),
                'another': {
                    '': blank,
                    'prog2': Program(name='prog2'),
                    'prog3': Program(name='prog3'),
                    'http_only': Program(name='http_only', controllers=['http-get']),
                    'irc_only': Program(name='irc_only', controllers=['irc']),
                    'both': both
                },
                'double': [double_get, double_post]
            },
            'string_redirect': '/redirect',
            'redirect': Program(name='redirect'),
        })

        self.all_urls = set([
            '/', '/deep',
            '/sub/another/irc_only', '/sub/another/http_only', '/sub/another/both',
            '/sub/prog', '/sub/another', '/sub/another/prog2', '/sub/another/prog3',
            '/redirect', '/string_redirect', '/sub/double'
        ])

        self.irc_only_urls = set(['/sub/another/irc_only'])
        self.http_only_urls = set(['/sub/another/http_only', '/sub/double'])

    def test_get_all_urls(self):
        self.assertEquals(self.manifest.get_urls(), self.all_urls)

    def test_controllertag_filtering(self):
        """
        When a controller tag is added to the call to get_urls, the returned set
        of urls should be filtered by the controler tag defined in the manifest.
        """
        irc_urls = sorted(list(self.all_urls - self.http_only_urls))
        generated = sorted(list(self.manifest.get_urls(controllers=['irc'])))
        self.assertEquals(generated, irc_urls)

        http_urls = self.all_urls - self.irc_only_urls
        self.assertEquals(self.manifest.get_urls(controllers=['http-get']), http_urls)

    def test_get_program(self):
        name = self.manifest.get_program('/').name
        self.assertEquals(name, 'root')

    def test_parse_invocation_simple(self):
        parsed = self.manifest.parse_invocation('/sub/another/both', 'http-get')
        correct = {
            'args': [],
            'program': both,
            'superformat': None,
            'superformat_mime': None,
            'raw_args': '',
            'invocation': '/sub/another/both',
            'path': '/sub/another/',
            'program_name': 'both'
        }
        self.assertEquals(parsed, correct)

    def test_parse_invocation_root_arg(self):
        parsed = self.manifest.parse_invocation('/sub/another/aaaa', 'http-get')
        correct = {
            'args': ['aaaa'],
            'raw_args': 'aaaa',
            'program': blank,
            'superformat': None,
            'superformat_mime': None,
            'invocation': '/sub/another/aaaa',
            'path': '/sub/',
            'program_name': 'another'
        }
        self.assertEquals(parsed, correct)

    def test_parse_invocation_superformat(self):
        parsed = self.manifest.parse_invocation('/sub/another/both.html', 'http-get')
        correct = {
            'args': [],
            'raw_args': '',
            'program': both,
            'superformat': 'html',
            'superformat_mime': 'text/html',
            'invocation': '/sub/another/both.html',
            'path': '/sub/another/',
            'program_name': 'both'
        }
        self.assertEquals(parsed, correct)


    def test_parse_invocation_superformat_with_args(self):
        parsed = self.manifest.parse_invocation('/sub/another/both.html/aaaa/bbbbbb', 'http-get')
        correct = {
            'args': ['aaaa', 'bbbbbb'],
            'raw_args': 'aaaa/bbbbbb',
            'program': both,
            'superformat': 'html',
            'superformat_mime': 'text/html',
            'invocation': '/sub/another/both.html/aaaa/bbbbbb',
            'path': '/sub/another/',
            'program_name': 'both'
        }
        self.assertEquals(parsed, correct)

    def test_parse_invocation_double_controller(self):
        for controller_tag, program in [['http-get', double_get], ['http-post', double_post]]:
            parsed = self.manifest.parse_invocation('/sub/double', controller_tag)
            correct = {
                'args': [],
                'raw_args': '',
                'program': program,
                'superformat': None,
                'superformat_mime': None,
                'invocation': '/sub/double',
                'path': '/sub/',
                'program_name': 'double'
            }
            self.assertEquals(parsed, correct)

    def xtest_parse_invocation_invalid(self):
        #print self.manifest.parse_invocation('/sub/double', 'irc')
        #print self.manifest.get_urls('irc')
        self.assertRaises(
            ProgramNotFound, 
            lambda: self.manifest.parse_invocation('/sub/double', 'irc')
        )

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = middleware_test
#import unittest
class T(object): pass
unittest = T()
setattr(unittest, 'TestCase', object)
## all tests in this module are disabled until I get a chance to fix all these tests

from giotto.programs import Program

class InOne(object):
    def test(self, request):
        request['one'] = True
        return request

class InTwo(object):
    def test(self, request):
        request['two'] = True
        return request

class InThree(object):
    def test(self, request):
        request['three'] = True
        return request

class OutOne(object):
    def test(self, request, response):
        response['one'] = False
        return response

class OutTwo(object):
    def test(self, request, response):
        response['two'] = False
        return response

class OutThree(object):
    def test(self, request, response):
        response['three'] = False
        return response

class ExampleProgram(Program):
    input_middleware = [InOne, InTwo, InThree]
    output_middleware = [OutOne, OutTwo, OutThree]

class NoMiddlewareProgram(Program):
    pass

class MiddlewareTest(unittest.TestCase):

    def test_input_middleware(self):
        request = {'start':True}
        request = ExampleProgram().execute_input_middleware_stream(request, mock_controller)
        self.assertEquals(request, {'start': True, 'three': True, 'two': True, 'one': True})

    def test_output_middleware(self):
        request = {'start': False}
        response = {'start': False}
        response = ExampleProgram().execute_output_middleware_stream(request, response, 'test')
        self.assertEquals(response, {'start': False, 'three': False, 'two': False, 'one': False})

    def test_empty_input_middleware(self):
        "Input middleware execution when program has no middleware specified"
        request = {'start': True}
        request = NoMiddlewareProgram().execute_input_middleware_stream(request, 'test')
        self.assertEquals(request, {'start': True})

    def test_empty_output_middleware(self):
        "Output middleware execution when program has no middleware specified"
        request = {'start': False}
        response = {'start': False}
        response = NoMiddlewareProgram().execute_output_middleware_stream(request, response, 'test')
        self.assertEquals(response, {'start': False})

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = program_tests
import unittest
try:
    from collections import OrderedDict
except ImportError:
    from ordereddict import OrderedDict # python2.6

from giotto.programs import Program
from giotto.views import BasicView
from giotto.exceptions import MockNotFound

def simple(x, y):
    return None

class ProgramTest(unittest.TestCase):

    def test_no_mock_found(self):
        """
        The program raises MockNotFound when the program has no mock defined
        """
        gp = Program(model=[simple])
        self.assertRaises(MockNotFound, lambda: gp.get_model_mock())

    def test_no_mock_needed(self):
        gp = Program(model=[])
        self.assertEquals({}, gp.get_model_mock())

    def test_mock_found(self):
        gp = Program(model=[simple, {'mock': True}])
        self.assertEquals({'mock': True}, gp.get_model_mock())


class ArgspecTest(unittest.TestCase):
    def test_get_args_kwargs(self):
        def test(a, b, c="what"): pass
        program = Program(model=[test], view=BasicView())
        ret = program.get_model_args_kwargs()
        self.assertEquals((['a', 'b'], {'c': "what"}), ret)

    def test_empty(self):
        def test(): pass
        program = Program(model=[test], view=BasicView())
        ret = program.get_model_args_kwargs()
        self.assertEquals(([], {}), ret)

    def test_ignore_cls(self):
        """
        If first argument is nammed 'cls', ignore that argument (to allow
        classmethods)
        """
        def test(cls, a, b, c="what"): pass
        program = Program(model=[test], view=BasicView())
        ret = program.get_model_args_kwargs()
        self.assertEquals((['a', 'b'], {'c': "what"}), ret)

    def test_no_model(self):
        program = Program(view=BasicView())
        ret = program.get_model_args_kwargs()
        self.assertEquals(([], {}), ret)

    def test_preserve_order(self):
        def test(a=1, b=2, c=3, d=4): pass
        program = Program(model=[test], view=BasicView())
        a, kw = program.get_model_args_kwargs()
        self.assertEquals(list(kw.keys()), ['a', 'b', 'c', 'd'])

if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = view_tests
import unittest
from giotto.exceptions import NoViewMethod
from giotto.views import GiottoView, BasicView, renders
from giotto.control import Redirection

class Blog(object):
    def __init__(self, id=None, title=None, body=None):
        self.id = id
        self.title = title
        self.body = body

    def __repr__(self):
        return "%s %s %s" % (self.id, self.title, self.body)

class RendererTests(unittest.TestCase):
    giotto_view = GiottoView()
    basic_view = BasicView()

    def test_mising_renderer(self):
        """
        Exception is raises when you try to render mimetype that is not
        supported by the view class
        """
        assert self.giotto_view.can_render('text/html') == False
        self.assertRaises(NoViewMethod, lambda: self.giotto_view.render({}, 'text/html'))

    def test_render_defined_mimetype(self):
        assert self.basic_view.can_render('text/html') == True
        result = self.basic_view.render({}, 'text/html')
        assert 'body' in result

    def test_kwarg_renderer(self):
        """
        Renderers passed into the constructor override renderers defined on the
        class.
        """
        view = BasicView(html=lambda m: "inherited")
        result = view.render({}, 'text/html')
        self.assertEquals(result['body'], "inherited")

    def test_redirection_lambda(self):
        view = BasicView(html=lambda m: Redirection(m))
        result = view.render('res', 'text/html')
        self.assertEquals(type(result['body']), Redirection)
        self.assertEquals(result['body'].path, 'res')

    def test_redirection(self):
        view = BasicView(html=Redirection('/'))
        result = view.render({}, 'text/html')
        self.assertEquals(type(result['body']), Redirection)
        self.assertEquals(result['body'].path, '/')

    def test_subclass_renderer(self):
        """
        A Renderer that is defined on a class takes precidence over the renderer
        defined in a base class. Regardless of the name of the render method function.
        """
        class InheritedBasicView1(BasicView):
            @renders('text/html')
            def a(self, result, errors):
                # show up earlier than 'generic_html' in dir()
                return 'inherited'

        class InheritedBasicView2(BasicView):
            @renders('text/html')
            def zzzzzzz(self, result, errors):
                # show up later than 'generic_html' in dir()
                return 'inherited'

        for view in [InheritedBasicView2(), InheritedBasicView1()]:
            result = view.render({}, 'text/html')
            self.assertEquals(result['body'], "inherited")

class TestGenericView(unittest.TestCase):
    def test_list_html(self):
        result = BasicView().render(['one', 'two'], 'text/html')['body']
        assert '<html>' in result
        assert 'one' in result

    def test_list_txt(self):
        result = BasicView().render(['one', 'two'], 'text/plain')['body']
        assert 'two' in result
        assert 'one' in result

    def test_dict_html(self):
        result = BasicView().render({'one': 'two'}, 'text/html')['body']
        assert '<html>' in result
        assert 'one' in result

    def test_dict_txt(self):
        result = BasicView().render({'one': 'two'}, 'text/plain')['body']
        assert 'one - two' in result

    def test_objects_txt(self):
        blogs = [Blog(title="title", body="This blog body"), Blog(title="title2", body="blog body two")]
        result = BasicView().render(blogs, 'text/plain')['body']
        assert 'blog body two' in result
        assert 'This blog body' in result

    def test_objects(self):
        blogs = [Blog(title="title", body="This blog body"), Blog(title="title2", body="blog body two")]
        result = BasicView().render(blogs, 'text/html')['body']
        assert 'blog body two' in result
        assert 'This blog body' in result
        assert '<!DOCTYPE html>' in result

    def test_string(self):
        result = BasicView().render("just a simple string", 'text/html')['body']
        assert "just a simple string" in result

    def test_nonetype(self):
        result = BasicView().render(None, 'text/html')['body']
        assert "None" in result


if __name__ == '__main__':
    unittest.main()
########NEW FILE########
__FILENAME__ = utils
import string
import random
import json
import traceback
import re
import unicodedata
import six

from giotto import get_config
from collections import defaultdict

def switchout_keyvalue(engine):
    from giotto import keyvalue
    if engine == 'dummy':
        return keyvalue.DummyKeyValue
    if engine == 'locmem':
        return keyvalue.LocMemKeyValue
    if engine == 'database':
        return keyvalue.DatabaseKeyValue
    if engine == 'memcached':
        return keyvalue.MemcacheKeyValue
    if engine == 'redis':
        return keyvalue.RedisKeyValue

class Mock(object):
    """
    This class creates an object that will replace the error object when no error
    object exists. It allows arbirtary attribute getting without raising an
    attribute error.
    >>> m = Mock()
    >>> m.nothing.empty.made_up.wut.lol
    ''
    >>> bool(m.wut)
    False
    """
    def __getattribute__(self, item):
        return Mock()

    def __str__(self):
        return ''

    def __bool__(self):
        return False

    def __nonzero__(self):
        return False

    def __iter__(self):
        return iter([])

def parse_kwargs(kwargs):
    """
    Convert a list of kwargs into a dictionary. Duplicates of the same keyword
    get added to an list within the dictionary.

    >>> parse_kwargs(['--var1=1', '--var2=2', '--var1=3']
    {'var1': [1, 3], 'var2': 2}
    """
    
    d = defaultdict(list)
    for k, v in ((k.lstrip('-'), v) for k,v in (a.split('=') for a in kwargs)):
        d[k].append(v)

    ret = {}
    for k, v in d.items():
        # replace single item lists with just the item.
        if len(v) == 1 and type(v) is list:
            ret[k] = v[0]
        else:
            ret[k] = v
    return ret

def super_accept_to_mimetype(ext):
    if not ext:
        return
    if ext.startswith('.'):
        ext = ext[1:]
    if ext in ('jpeg', 'jpg'):
        return 'image/jpeg'
    if ext == 'gif':
        return 'image/gif'
    if ext == 'txt':
        return 'text/plain'
    if ext in ('html', 'htm'):
        return 'text/html'
    if ext == 'json':
        return 'application/json'
    if ext == 'css':
        return "text/css"
    if ext == 'irc':
        return 'text/x-irc'
    if ext == 'xml':
        return 'application/xml'

def random_string(n):
    return ''.join(random.choice(string.ascii_uppercase + string.digits) for x in range(n))

def htmlize(value):
    """
    Turn any object into a html viewable entity.
    """
    return str(value).replace('<', '&lt;').replace('>', '&gt;')

def htmlize_list(items):
    """
    Turn a python list into an html list.
    """
    out = ["<ul>"]
    for item in items:
        out.append("<li>" + htmlize(item) + "</li>")
    out.append("</ul>")
    return "\n".join(out)

def pre_process_json(obj):
    """
    Preprocess items in a dictionary or list and prepare them to be json serialized.
    """
    if type(obj) is dict:
        new_dict = {}
        for key, value in obj.items():
            new_dict[key] = pre_process_json(value)
        return new_dict

    elif type(obj) is list:
        new_list = []
        for item in obj:
            new_list.append(pre_process_json(item))
        return new_list

    elif hasattr(obj, 'todict'):
        return dict(obj.todict())

    else:
        try:
            json.dumps(obj)
        except TypeError:
            try:
                json.dumps(obj.__dict__)
            except TypeError:
                return str(obj)
            else:
                return obj.__dict__
        else:
            return obj


def render_error_page(code, exc, mimetype='text/html', traceback=''):
    """
    Render the error page
    """
    from giotto.views import get_jinja_template

    if 'json' in mimetype:
        return json.dumps({
            'code': code,
            'exception': exc.__class__.__name__,
            'message': str(exc),
        })

    et = get_config('error_template')
    if not et:
        return "%s %s\n%s" % (code, str(exc), traceback)
    template = get_jinja_template(et)
    return template.render(
        code=code,
        exception=exc.__class__.__name__,
        message=str(exc),
        traceback=traceback
    )

to_remove = re.compile('[^\w\s-]')
remove_dup = re.compile('[-\s]+')
def slugify(value):
    """
    Converts to lowercase, removes non-word characters (alphanumerics and
    underscores) and converts spaces to hyphens. Also strips leading and
    trailing whitespace.
    """
    if six.PY3:
        value = str(value)
    else:
        value = unicode(value)

    value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore').decode('ascii')
    value = to_remove.sub('', value).strip().lower()
    return remove_dup.sub('-', value)

def jsonify(obj):
    def handler(obj):
        if hasattr(obj, 'isoformat'):
            return obj.isoformat()
        if hasattr(obj, 'todict'):
            return obj.todict()
        else:
            raise TypeError('Object of type %s with value of %s is not JSON serializable' % (type(obj), repr(obj)))
    return json.dumps(obj, default=handler)








########NEW FILE########
