__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# gevent-tools documentation build configuration file, created by
# sphinx-quickstart on Sun May  8 03:34:49 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os
sys.path.insert(0, os.path.abspath('..'))
from ginkgo import __version__

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.coverage', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Ginkgo'
copyright = u'2012, Jeff Lindsay'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = __version__
# The full version, including alpha/beta/rc tags.
release = __version__

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'gevent-toolsdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'gevent-tools.tex', u'gevent-tools Documentation',
   u'Jeff Lindsay', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'gevent-tools', u'gevent-tools Documentation',
     [u'Jeff Lindsay'], 1)
]

########NEW FILE########
__FILENAME__ = eventlet
from __future__ import absolute_import

import eventlet
import eventlet.greenpool
import eventlet.greenthread
import eventlet.event
import eventlet.queue
import eventlet.timeout
import eventlet.semaphore

from ..core import BasicService, Service
from ..util import defaultproperty

class AsyncManager(BasicService):
    """Async primitives from eventlet"""
    stop_timeout = defaultproperty(int, 1)

    def __init__(self):
        self._greenlets = eventlet.greenpool.GreenPool()

    def do_stop(self):
        if eventlet.greenthread.getcurrent() in self._greenlets.coroutines_running:
            return eventlet.spawn(self.do_stop).join()
        if self._greenlets.running():
            with eventlet.timeout.Timeout(self.stop_timeout, False):
                self._greenlets.waitall() # put in timeout for stop_timeout
            for g in list(self._greenlets.coroutines_running):
                with eventlet.timeout.Timeout(1, False):
                    g.kill() # timeout of 1 sec?

    def spawn(self, func, *args, **kwargs):
        """Spawn a greenlet under this service"""
        return self._greenlets.spawn(func, *args, **kwargs)

    def spawn_later(self, seconds, func, *args, **kwargs):
        """Spawn a greenlet in the future under this service"""
        def spawner():
            self.spawn(func, *args, **kwargs)
        return eventlet.spawn_after(seconds, spawner)

    def sleep(self, seconds):
        return eventlet.sleep(seconds)

    def queue(self, *args, **kwargs):
        return eventlet.queue.Queue(*args, **kwargs)

    def event(self, *args, **kwargs):
        return Event(*args, **kwargs)

    def lock(self, *args, **kwargs):
        return eventlet.semaphore.Semaphore(*args, **kwargs)

class Event(eventlet.event.Event):
    def clear(self):
        if not self.ready():
            return
        self.reset()

    def set(self):
        self.send()

    def wait(self, timeout=None):
        if timeout:
            with eventlet.timeout.Timeout(timeout, False):
                super(Event, self).wait()
        else:
            super(Event, self).wait()

########NEW FILE########
__FILENAME__ = gevent
"""Gevent async module

This module provides the `AsyncManager` for gevent, as well as other utilities
useful for building gevent based Ginkgo apps. Obviously, this is the only async
module at the moment.

Of note, this module provides wrapped versions of the gevent bundled servers
that should be used instead of the gevent classes. These wrapped classes adapt
gevent servers to be Ginkgo services. They currently include:

    * StreamServer
    * WSGIServer (based on the pywsgi.WSGIServer)
    * BackdoorServer

"""
from __future__ import absolute_import

import gevent
import gevent.event
import gevent.queue
import gevent.timeout
import gevent.pool
import gevent.baseserver
import gevent.socket

import gevent.backdoor
import gevent.server
import gevent.pywsgi

from ..core import BasicService, Service
from ..util import defaultproperty, ObjectWrapper
from ..async import AbstractAsyncManager

class AsyncManager(AbstractAsyncManager):
    """Async primitives from gevent"""
    stop_timeout = defaultproperty(int, 1)

    def __init__(self):
        self._greenlets = gevent.pool.Group()

    def do_stop(self):
        if gevent.getcurrent() in self._greenlets:
            return gevent.spawn(self.do_stop).join()
        if self._greenlets:
            self._greenlets.join(timeout=self.stop_timeout)
            self._greenlets.kill(block=True, timeout=1)

    def spawn(self, func, *args, **kwargs):
        """Spawn a greenlet under this service"""
        return self._greenlets.spawn(func, *args, **kwargs)

    def spawn_later(self, seconds, func, *args, **kwargs):
        """Spawn a greenlet in the future under this service"""
        group = self._greenlets
        g = group.greenlet_class(func, *args, **kwargs)
        g.start_later(seconds)
        group.add(g)
        return g

    def sleep(self, seconds):
        return gevent.sleep(seconds)

    def queue(self, *args, **kwargs):
        return gevent.queue.Queue(*args, **kwargs)

    def event(self, *args, **kwargs):
        return gevent.event.Event(*args, **kwargs)

    def lock(self, *args, **kwargs):
        return gevent.coros.Semaphore(*args, **kwargs)

    def signal(self, *args, **kwargs):
        gevent.signal(*args, **kwargs)

    def init(self):
        gevent.reinit()


class ServerWrapper(Service):
    """Wrapper for gevent servers that are based on gevent.baseserver.BaseServer

    DEPRECATED: Please use the pre-wrapped gevent servers in the same module.

    Although BaseServer objects mostly look like they have the Service interface,
    there are certain extra methods (like reload, service_name, etc) that are assumed
    to be available. This class allows us to wrap gevent servers so they actually
    behave as a Service. There is no automatic wrapping like 0.3.0 and earlier,
    so you have to explicitly wrap gevent servers:

        from ginkgo.core import Service
        from ginkgo.async.gevent import ServerWrapper
        from gevent.pywsgi import WSGIServer

        class MyService(Service):
            def __init__(self):
                self.server = WSGIServer(('0.0.0.0', 80), self.handle)
                self.add_service(ServerWrapper(self.server))

    """
    def __init__(self, server, *args, **kwargs):
        super(ServerWrapper, self).__init__()
        if isinstance(server, gevent.baseserver.BaseServer):
            self.wrapped = server
        else:
            raise RuntimeError(
                "Object being wrapped is not a BaseServer instance")

    def do_start(self):
        self.spawn(self.wrapped.start)

    def do_stop(self):
        self.wrapped.stop()

class StreamClient(Service):
    """StreamServer-like TCP client service"""

    def __init__(self, address, handler=None):
        self.address = address
        self.handler = handler

    def do_start(self):
        self.spawn(self.connect)

    def connect(self):
        self.handle(
            gevent.socket.create_connection(self.address))

    def handle(self, socket):
        if self.handler:
            self.handler(socket)

class _ServerWrapper(Service, ObjectWrapper):
    server = state = __subject__ = None
    _children = []

    def __init__(self, *args, **kwargs):
        self.server = self.server(*args, **kwargs)
        ObjectWrapper.__init__(self, self.server)

    def do_start(self):
        self.spawn(self.server.start)

    def do_stop(self):
        self.server.stop()

class StreamServer(_ServerWrapper):
    server = gevent.server.StreamServer

class WSGIServer(_ServerWrapper):
    server = gevent.pywsgi.WSGIServer

class BackdoorServer(_ServerWrapper):
    server = gevent.backdoor.BackdoorServer

########NEW FILE########
__FILENAME__ = threading
from __future__ import absolute_import

import threading
import Queue
import time

from ..util import defaultproperty
from ..async import AbstractAsyncManager

def _spin_wait(fn, timeout):
    """ Spin-wait blocking only 1 second at a time so we don't miss signals """
    elapsed = 0
    while True:
        if fn(timeout=1):
            return True
        elapsed += 1
        if timeout is not None and elapsed >= timeout:
            return False


class Event(threading._Event):
    def wait(self, timeout=None):
        return _spin_wait(super(Event, self).wait, timeout)


class Thread(threading.Thread):
    def join(self, timeout=None):
        return _spin_wait(super(Thread, self).join, timeout)


class Timer(threading._Timer):
    def join(self, timeout=None):
        return _spin_wait(super(Timer, self).join, timeout)


class AsyncManager(AbstractAsyncManager):
    """Async manager for threads"""
    stop_timeout = defaultproperty(int, 1)

    def __init__(self):
        # _lock protects the _threads structure
        print ("The ginkgo.async.threading manager should not be used in "
               "production environments due to the known limitations of the GIL")
        self._lock = threading.Lock()
        self._threads = []

    def do_stop(self):
        """
            Beware! This function has different behavior than the gevent
            async manager in the following respects:
                - The stop timeout is used for joining each thread instead of
                  for all of the threads collectively.
                - If the threads do not successfully join within their timeout,
                  they will not be killed since there is no safe way to do this.
        """
        with self._lock:
            reentrant_stop = threading.current_thread() in self._threads

        if reentrant_stop:
            t = Thread(target=self.do_stop)
            t.daemon=True
            t.start()
            return t.join()

        with self._lock:
            for t in self._threads:
                t.join(self.stop_timeout)

    def spawn(self, func, *args, **kwargs):
        """Spawn a greenlet under this service"""
        t = Thread(target=func, args=args, kwargs=kwargs)
        with self._lock:
            self._threads.append(t)
        t.daemon=True
        t.start()
        return t

    def spawn_later(self, seconds, func, *args, **kwargs):
        """Spawn a greenlet in the future under this service"""
        t = Timer(group=self, target=func, args=args, kwargs=kwargs)
        with self._lock:
            self._threads.append(t)
        t.daemon=True
        t.start()
        return t

    def sleep(self, seconds):
        return time.sleep(seconds)

    def queue(self, *args, **kwargs):
        return Queue.Queue(*args, **kwargs)

    def event(self, *args, **kwargs):
        return Event(*args, **kwargs)

    def lock(self, *args, **kwargs):
        return threading.Lock(*args, **kwargs)

########NEW FILE########
__FILENAME__ = config
"""Ginkgo config

This module provides the class for a `Config` object, which represents an
application configuration, often loaded by a configuration file. This is used
by the runner module's `Process` object, but can be used completely
independently.

Configuration is described and accessed by Setting descriptors in your
application. Configuration values can then be set by Python configuration
files. However, using configuration files is completely optional. You can
expose configuration to the end-user via command-line arguments, then load them
into the `Config` object via `load()`.

By default, Ginkgo creates a `Config` object singleton to use in your
applications that you can import with `from ginkgo import settings`. You should
only have to create a `Config` object in testing scenarios. Ginkgo also
provides a shortcut for creating Setting descriptors associated with this
singleton that you can import with `from ginkgo import Setting`. Often, this is
the only API you need to use Ginkgo config.

"""
import collections
import os.path
import re
import runpy

import util

class Config(util.GlobalContext):
    """Represents a collection of settings

    Provides access to a collection of settings that can be loaded from a
    Python module or file, or a dictionary. It allows classic-style classes to
    be used to indicate namespaces or groups, which can be nested.

    As a `GlobalContext`, you can specify the location of a singleton by setting
    `Config.singleton_attr` to a tuple of (object, attribute_name). Then any
    `Config` instance will be a context manager that will temporarily set that
    singleton to that instance.
    """
    _settings = {}
    _descriptors = []
    _forced_settings = set()
    _last_file = None

    def _normalize_path(self, path):
        return path.lower().lstrip(".")

    def get(self, path, default=None):
        """gets the current value of a setting"""
        return self._settings.get(self._normalize_path(path), default)

    def set(self, path, value, force=False):
        """sets the value of a setting"""
        path = self._normalize_path(path)
        if force or path not in self._forced_settings:
            self._settings[self._normalize_path(path)] = value
            if force:
                self._forced_settings.add(path)


    def group(self, path=''):
        """returns a Group object for the given path if exists"""
        if path not in self._settings:
            return Group(self, path)

    def setting(self, *args, **kwargs):
        """returns a _Setting descriptor attached to this configuration"""
        descriptor = _Setting(self, *args, **kwargs)
        self._descriptors.append(descriptor)
        return descriptor

    def load_module(self, module_path):
        """loads a module as configuration given a module path"""
        try:
            return self.load(runpy.run_module(module_path))
        except Exception, e:
            raise RuntimeError("Config error: {}".format(e))

    def load_file(self, file_path):
        """loads a module as configuration given a file path"""
        file_path = os.path.abspath(os.path.expanduser(file_path))
        try:
            config_dict = runpy.run_path(file_path)
        except Exception, e:
            raise RuntimeError("Config error: {}".format(e))
        self._last_file = file_path
        return self.load(config_dict)

    def reload_file(self):
        """reloads the last loaded configuration from load_file"""
        if self._last_file:
            return self.load_file(self._last_file)

    def load(self, config_dict):
        """loads a dictionary into settings"""
        def _load(d, prefix=''):
            """
            Recursively loads configuration from a dictionary, putting
            configuration under classic-style classes in a namespace.
            """
            items = (i for i in d.iteritems() if not i[0].startswith("_"))
            for key, value in items:
                path = ".".join((prefix, key))
                if type(value).__name__ == 'classobj':
                    _load(value.__dict__, path)
                else:
                    self.set(path, value)
        _load(config_dict)
        return self._settings

    def print_help(self, only_default=False):
        print "config settings:"
        for d in sorted(self._descriptors, key=lambda d: d.path):
            if d.help:
                value = d.default if only_default else self.get(d.path,
                                                                d.default)
                print "  %- 14s %s [%s]" % (
                    d.path, d.help.replace('\n', '\n'+' '*18), value)


class Group(collections.Mapping):
    """Provides read-only access to a group of config data

    These objects represent a 'view' into a particular scope of the entire
    config, whether the global group or a group created using classic-style
    classes in the config file. They're not created directly. Use the `group()`
    method on `Config`.

        c = Config()
        g1 = c.group() # global scope group
        g1.foo # gives you the setting named "foo"
        g2 = c.group("bar.baz") # bar.baz scoped group
        g2.qux # give you the setting named "bar.baz.qux"

    They are not intended to be the primary interface to settings. However, in
    some cases it is more convenient. You should usually use the `setting`
    function to embed config settings for particular values on relevant classes.
    """
    def __init__(self, config, name=''):
        self._config = config
        self._name = name

    def __getattr__(self, name):
        path = self._config._normalize_path(".".join((self._name, name)))
        try:
            return self._config._settings[path]
        except KeyError:
            group_path = path + "."
            keys = self._config._settings.keys()
            if any(1 for k in keys if k.startswith(group_path)):
                return Group(self._config, path)
            return None

    def __repr__(self):
        return 'Group[{}:{}]'.format(self._name, self._dict())

    def _dict(self):
        d = dict()
        group_path = self._name + "."
        for key in self._config._settings.keys():
            if not self._name or key.startswith(group_path):
                if self._name:
                    key = key.split(group_path, 1)[-1]
                name = key.split('.', 1)[0]
                if name not in d:
                    d[name] = getattr(self, name)
        return d

    # Mapping protocol

    def __contains__(self, item):
        return item in self._dict()

    def __iter__(self):
        return self._dict().__iter__()

    def __len__(self):
        return self._dict().__len__()

    def __getitem__(self, key):
        return getattr(self, key)



class _Setting(object):
    """Setting descriptor for embedding in component classes.

    Do not use this object directly, instead use `Config.setting()`.

    This is a descriptor for your component classes to define what settings
    your application uses and provides a way to access that setting. By
    accessing with a descriptor, if the configuration changes you
    will always have the current value. Example:

        class MyService(Service):
            foo = config.setting('foo', default='bar',
                    help="This lets us set foo for MyService")

            def do_start(self):
                print self.foo
    """
    _init = object()

    def __init__(self, config, path, default=None, monitored=False, help=''):
        self._last_value = self._init
        self.config = config
        self.path = path
        self.default = default
        self.monitored = monitored
        self.help = self.__doc__ = re.sub(r'\n\s+', '\n', help.strip())

    def __get__(self, instance, type):
        if self.monitored:
            return SettingProxy(self.value, self)
        else:
            return self.value

    @property
    def value(self):
        return self.config.get(self.path, self.default)

    @property
    def changed(self):
        """ True if the value has changed since the last time accessing
            this property. False on first access.
        """
        old, self._last_value = self._last_value, self.value
        return self.value != old and old is not self._init


class SettingProxy(util.ObjectWrapper):
    """Wraps an object returned by a `Setting` descriptor

    Primarily it gives any object that comes from `Setting` a `changed`
    property that will determine if the value has been changed, such as when
    configuration is reloaded.
    """
    descriptor = None

    def __init__(self, obj, descriptor):
        super(SettingProxy, self).__init__(obj)
        self.descriptor = descriptor

    @property
    def changed(self):
        return self.descriptor.changed

    @property
    def value(self):
        return self.__subject__



########NEW FILE########
__FILENAME__ = core
"""Ginkgo service core

This module implements the core service model and several convenience
decorators to use with your services. The primary export of this module is
`Service`, but much of the implementation is in `BasicService`. `BasicService`
uses a simple state machine defined by `ServiceStateMachine` and implements the
core service interface.

`BasicService` assumes no async model, whereas `Service` creates an
`AsyncManager` from a driver in the `async` module. It's assumed the common
case is to create async applications, but there are cases when you need a
`Service` with no async. For example, `AsyncManager` classes inherit from
`BasicService`, otherwise there would be a circular dependency.

"""
import functools
import runpy

from .util import AbstractStateMachine
from .util import defaultproperty
from . import Setting

def require_ready(func):
    """ Decorator that blocks the call until the service is ready """
    @functools.wraps(func)
    def wrapped(self, *args, **kwargs):
        try:
            self.state.wait("ready", self.ready_timeout)
        except Exception, e:
            pass
        if not self.ready:
            raise RuntimeWarning("Service must be ready to call this method.")
        return func(self, *args, **kwargs)
    return wrapped

def autospawn(func):
    """ Decorator that will spawn the call in a local greenlet """
    @functools.wraps(func)
    def wrapped(self, *args, **kwargs):
        self.spawn(func, self, *args, **kwargs)
    return wrapped

class ServiceStateMachine(AbstractStateMachine):
    """     +------+
            | init |
            +--+---+
               |
               v
      +-------------------+
 +--->|      start()      |
 |    |-------------------|        +-------------------+
 |    |     starting      +---+--->|      stop()       |
 |    +-------------------+   |    |-------------------|
 |             |              |    |     stopping      |
 |             v              |    +-------------------+
 |        +-----------+       |              |
 |        |  ready()  |       |              |
 |        |-----------|       |              v
 |        |   ready   +-------+       +-------------+
 |        +-----------+               |  stopped()  |
 |                                    |-------------|
 +------------------------------------+   stopped   |
                                      +-------------+

    http://www.asciiflow.com/#7278337222084818599/1920677602
    """
    initial_state = "init"
    allow_wait = ["ready", "stopped"]
    event_start = \
        ["init", "stopped"], "starting", "pre_start"
    event_ready = \
        ["starting"], "ready", "post_start"
    event_stop = \
        ["ready", "starting"], "stopping", "pre_stop"
    event_stopped = \
        ["stopping"], "stopped", "post_stop"

class BasicService(object):
    _statemachine_class = ServiceStateMachine
    _children = defaultproperty(list)

    start_timeout = defaultproperty(int, 2)
    start_before = defaultproperty(bool, False)

    def pre_init(self):
        pass

    def __new__(cls, *args, **kwargs):
        s = super(BasicService, cls).__new__(cls, *args, **kwargs)
        s.pre_init()
        s.state = cls._statemachine_class(s)
        return s

    @property
    def service_name(self):
        return self.__class__.__name__

    @property
    def ready(self):
        return self.state.current == 'ready'

    def add_service(self, service):
        """Add a child service to this service

        The service added will be started when this service starts, before
        its :meth:`_start` method is called. It will also be stopped when this
        service stops, before its :meth:`_stop` method is called.

        """
        self._children.append(service)

    def remove_service(self, service):
        """Remove a child service from this service"""
        self._children.remove(service)

    def start(self, block_until_ready=True):
        """Starts children and then this service. By default it blocks until ready."""
        self.state("start")
        if self.start_before:
            self.do_start()
        for child in self._children:
            if child.state.current not in ["ready", "starting"]:
                child.start(block_until_ready)
        if not self.start_before:
            ready = not self.do_start()
            if not ready and block_until_ready is True:
                self.state.wait("ready", self.start_timeout)
            elif ready:
                self.state("ready")
        else:
            self.state("ready")

    def pre_start(self):
        pass

    def do_start(self):
        """Empty implementation of service start. Implement me!

        Return `service.NOT_READY` to block until :meth:`set_ready` is
        called (or `ready_timeout` is reached).

        """
        return

    def post_start(self):
        pass

    def stop(self):
        """Stop child services in reverse order and then this service"""
        if self.state.current in ["init", "stopped"]:
            return
        ready_before_stop = self.ready
        self.state("stop")
        for child in reversed(self._children):
            child.stop()
        if ready_before_stop:
            self.do_stop()
        self.state("stopped")

    def pre_stop(self):
        pass

    def post_stop(self):
        pass

    def do_stop(self):
        """Empty implementation of service stop. Implement me!"""
        return

    def reload(self):
        def _reload_children():
            for child in self._children:
                child.reload()

        if self.start_before:
            self.do_reload()
            _reload_children()
        else:
            _reload_children()
            self.do_reload()

    def do_reload(self):
        """Empty implementation of service reload. Implement me!"""
        pass

    def serve_forever(self):
        """Start the service if it hasn't been already started and wait until it's stopped."""
        try:
            self.start()
        except RuntimeWarning, e:
            # If it can't start because it's
            # already started, just move on
            pass

        self.state.wait("stopped")

    def __enter__(self):
        self.start()
        return self

    def __exit__(self, type, value, traceback):
        self.stop()


class Service(BasicService):
    async_available = ["ginkgo.async." + m for m in ("gevent", "threading",
                                                     "eventlet")]
    async = Setting("async", default="ginkgo.async.threading", help="""\
        The async reactor to use. Available choices:
            ginkgo.async.gevent
            ginkgo.async.threading
            ginkgo.async.eventlet
        """)

    def pre_init(self):
        try:
            mod = runpy.run_module(self.async)
            self.async = mod['AsyncManager']()
            self.add_service(self.async)
        except (NotImplementedError, ImportError) as e:
            if self.async not in self.async_available:
                helptext = ("Please select a valid async module: \n\t"
                            + "\n\t".join(self.async_available))

            elif self.async.endswith("gevent"):
                helptext = ("Please make sure gevent is installed or use "
                            "a different async manager.")
            else:
                helptext = ""

            raise RuntimeError(
                "Unable to load async manager from {}.\n{}".format(self.async,
                                                                  helptext))

    def spawn(self, *args, **kwargs):
        return self.async.spawn(*args, **kwargs)

    def spawn_later(self, *args, **kwargs):
        return self.async.spawn_later(*args, **kwargs)



########NEW FILE########
__FILENAME__ = logger
"""Ginkgo logger

This module provides the class for a logger object used by the runner module's
`Process` object to manage, configure, and provide services around Python's
standard logging module. Most notably it allows you to easily configure the
Python logger using Ginkgo configuration.

"""
import logging
import logging.config
import os
import os.path
import sys

import ginkgo

DEFAULT_FORMAT = "%(asctime)s %(levelname) 7s %(module)s: %(message)s"

class Logger(object):
    logfile = ginkgo.Setting("logfile", default=None, help="""
        Path to primary log file. Ignored if logconfig is set.
        """)
    loglevel = ginkgo.Setting("loglevel", default='debug', help="""
        Log level to use. Valid options: debug, info, warning, critical
        Ignored if logconfig is set.
        """)
    config = ginkgo.Setting("logconfig", default=None, help="""
        Configuration of standard Python logger. Can be dict for basicConfig,
        dict with version key for dictConfig, or ini filepath for fileConfig.
        """)

    def __init__(self, process):
        self.process = process

        if self.logfile is None:
            process.config.set("logfile", os.path.expanduser(
                               "~/.{}.log".format(process.service_name)))

        self.load_config()

    def load_config(self):
        if self.config is None:
            self._load_default_config()
        else:
            if isinstance(self.config, str) and os.path.exists(self.config):
                logging.config.fileConfig(self.config)
            elif 'version' in self.config:
                logging.config.dictConfig(self.config)
            else:
                self._reset_basic_config(self.config)

    def _load_default_config(self):
        default_config = dict(
            format=DEFAULT_FORMAT,
            level=getattr(logging, self.loglevel.upper()))
        if hasattr(self.process, 'pidfile'):
            default_config['filename'] = self.logfile
        self._reset_basic_config(default_config)

    def _reset_basic_config(self, config):
        for h in logging.root.handlers[:]:
            logging.root.removeHandler(h)
        logging.basicConfig(**config)

    def capture_stdio(self):
        # TODO: something smarter than this?
        try:
            os.dup2(logging._handlerList[0]().stream.fileno(), sys.stdout.fileno())
            os.dup2(logging._handlerList[0]().stream.fileno(), sys.stderr.fileno())
        except:
            pass

    @property
    def file_descriptors(self):
        return [handler.stream.fileno() for handler in [wr() for wr in
            logging._handlerList] if isinstance(handler, logging.FileHandler)]

    def shutdown(self):
        logging.shutdown()

    def print_log(self):
        with open(self.logfile, "r") as f:
            print f.read()

    def tail_log(self):
        with open(self.logfile, "r") as f:
            lines = f.readlines()
            for line in lines[-20:]:
                print line.strip()
            while True:
                line = f.readline()
                if line:
                    print line.strip()

########NEW FILE########
__FILENAME__ = runner
"""Ginkgo runner

The runner module is responsible for creating a "container" to run services in,
and tools to manage that container. The container is itself a service based on
a class called `Process`, which is intended to model the running process that
contains the service. The process service takes an application service to run,
associates a configuration with this "container", and then initializes the
process to daemonize. This `Process` object is then assigned as a toplevel
singleton, which you can use as a reference to the top of the service tree.

The `ControlInterface` class models the commands you can use to start or
control a daemonized service. This is exposed via two command line utilities
`ginkgo` and `ginkgoctl`, both of which have their entry points defined in this
module.

The runner module and Ginkgo command line utilities are completely optional.
You can always just write your own Python script or console command that takes
your application service and calls `serve_forever()` on it.

"""
import argparse
import logging
import pwd
import grp
import os
import os.path
import runpy
import signal
import sys

import ginkgo.core
import ginkgo.logger
import ginkgo.util

STOP_SIGNAL = signal.SIGTERM
RELOAD_SIGNAL = signal.SIGHUP

sys.path.insert(0, os.getcwd())

logger = logging.getLogger(__name__)

def run_ginkgo():
    parser = argparse.ArgumentParser(prog="ginkgo", add_help=False)
    parser.add_argument("-v", "--version",
        action="version", version="%(prog)s {}".format(ginkgo.__version__))
    parser.add_argument("-h", "--help", action="store_true", help="""
        show program's help text and exit
        """.strip())
    parser.add_argument("-d", "--daemonize", action="store_true", help="""
        daemonize the service process
        """.strip())
    parser.add_argument("target", nargs='?', help="""
        service class path to run (modulename.ServiceClass) or
        configuration file path to use (/path/to/config.py)
        """.strip())
    args = parser.parse_args()
    if args.help:
        parser.print_help()
        if args.target:
            print # blank line
            try:
                app = setup_process(args.target)
                app.config.print_help()
            except RuntimeError, e:
                parser.error(e)
    else:
        if args.target:
            try:
                ControlInterface().start(args.target, args.daemonize)
            except RuntimeError, e:
                parser.error(e)
        else:
            parser.print_usage()

def run_ginkgoctl():
    parser = argparse.ArgumentParser(prog="ginkgoctl")
    parser.add_argument("-v", "--version",
        action="version", version="%(prog)s {}".format(ginkgo.__version__))
    parser.add_argument("-p", "--pid", help="""
        pid or pidfile to use instead of target
        """.strip())
    parser.add_argument("target", nargs='?', help="""
        service class path to use (modulename.ServiceClass) or
        configuration file path to use (/path/to/config.py)
        """.strip())
    parser.add_argument("action",
        choices="start stop restart reload status log logtail".split())
    args = parser.parse_args()
    if args.pid and args.target:
        parser.error("You cannot specify both a target and a pid")
    try:
        if args.action in "start restart log logtail".split():
            if not args.target:
                parser.error("You need to specify a target for {}".format(args.action))
            getattr(ControlInterface(), args.action)(args.target)
        else:
            getattr(ControlInterface(), args.action)(resolve_pid(args.pid, args.target))
    except RuntimeError, e:
        parser.error(e)

def resolve_pid(pid=None, target=None):
    if pid and not os.path.exists(pid):
        return int(pid)
    if target is not None:
        setup_process(target, daemonize=True)
        pid = ginkgo.settings.get("pidfile")
    if pid is not None:
        if os.path.exists(pid):
            with open(pid, "r") as f:
                pid = f.read().strip()
            return int(pid)
        else:
            return
    raise RuntimeError("Unable to resolve pid from {}".format(pid or target))

def load_class(class_path):
    if '.' not in class_path:
        raise RuntimeError("Invalid class path")
    module_name, class_name = class_path.rsplit('.', 1)
    try:
        try:
            module = runpy.run_module(module_name)
        except ImportError:
            module = runpy.run_module(module_name + ".__init__")
    except ImportError, e:
        import traceback, pkgutil
        tb_tups = traceback.extract_tb(sys.exc_info()[2])
        if pkgutil.__file__.startswith(tb_tups[-1][0]):
            # If the bottommost frame in our stack was in pkgutil,
            # then we can safely say that this ImportError occurred
            # because the top level class path was not found.
            raise RuntimeError("Unable to load class path: {}:\n{}".format(
                class_path, e))
        else:
            # If the ImportError occurred further down,
            # raise original exception.
            raise
    try:
        return module[class_name]
    except KeyError, e:
        raise RuntimeError("Unable to find class in module: {}".format(
            class_path))

def resolve_target(target):
    if target.endswith('.py'):
        if os.path.exists(target):
            config = ginkgo.settings.load_file(target)
            try:
                return config['service']
            except KeyError:
                raise RuntimeError(
                    "Configuration does not specify a service factory")
        else:
            raise RuntimeError(
                'Configuration file %s does not exist' % target)
    else:
        return target

def setup_process(target, daemonize=True):
    service_factory = resolve_target(target)
    if isinstance(service_factory, str):
        service_factory = load_class(service_factory)

    if callable(service_factory):
        if daemonize:
            return DaemonProcess(service_factory)
        else:
            return Process(service_factory)
    else:
        raise RuntimeError("Does not appear to be a valid service factory")

class ControlInterface(object):
    def start(self, target, daemonize=True):
        print "Starting process with {}...".format(target)
        app = setup_process(target, daemonize)
        try:
            app.serve_forever()
        except KeyboardInterrupt:
            pass
        finally:
            app.stop()

    def restart(self, target):
        self.stop(resolve_pid(target=target))
        self.start(target)

    def stop(self, pid):
        if self._validate(pid):
            print "Stopping process {}...".format(pid)
            os.kill(pid, STOP_SIGNAL)

    def reload(self, pid):
        if self._validate(pid):
            print "Reloading process {}...".format(pid)
            os.kill(pid, RELOAD_SIGNAL)

    def status(self, pid):
        if self._validate(pid):
            print "Process is running as {}.".format(pid)

    def _validate(self, pid):
        try:
            os.kill(pid, 0)
            return pid
        except (OSError, TypeError):
            print "Process is NOT running."

    def log(self, target):
        app = setup_process(target)
        app.logger.print_log()

    def logtail(self, target):
        try:
            app = setup_process(target)
            app.logger.tail_log()
        except KeyboardInterrupt:
            pass

class Process(ginkgo.core.Service, ginkgo.util.GlobalContext):
    singleton_attr = (ginkgo, 'process')
    start_before = True

    rundir = ginkgo.Setting("rundir", default=None, help="""
        Change to a directory before running
        """)
    user = ginkgo.Setting("user", default=None, help="""
        Change to a different user before running
        """)
    group = ginkgo.Setting("group", default=None, help="""
        Change to a different group before running
        """)
    umask = ginkgo.Setting("umask", default=None, help="""
        Change file mode creation mask before running
        """)

    def __init__(self, app_factory, config=None):
        self.app_factory = app_factory
        self.app = None

        self.config = config or ginkgo.settings
        self.logger = ginkgo.logger.Logger(self)

        self.pid = os.getpid()
        self.uid = os.geteuid()
        self.gid = os.getegid()
        self.environ = os.environ

        ginkgo.process = ginkgo.process or self

    @property
    def service_name(self):
        if self.app is None:
            # if the factory callable is called "service"
            # we need something better to name it, so we try
            # using first word of docstring if available
            if self.app_factory.__name__ == 'service':
                name = self.app_factory.__doc__ or self.app_factory.__name__
                return name.split(' ', 1)[0]
            else:
                return self.app_factory.__name__
        else:
            return self.app.service_name

    def do_start(self):
        if self.umask is not None:
            os.umask(self.umask)

        if self.rundir is not None:
            os.chdir(self.rundir)

        self.app = self.app_factory()
        self.add_service(self.app)

        self.async.init()
        self.async.signal(RELOAD_SIGNAL, self.reload)
        self.async.signal(STOP_SIGNAL, self.stop)

    def post_start(self):
        if self.group is not None:
            grp_record = grp.getgrnam(self.group)
            self.gid = grp_record.gr_gid
            os.setgid(self.gid)

        if self.user is not None:
            pw_record = pwd.getpwnam(self.user)
            self.uid = pw_record.pw_uid
            self.gid = pw_record.pw_gid
            os.setgid(self.gid)
            os.setuid(self.uid)

    def do_stop(self):
        logger.info("Stopping.")
        self.logger.shutdown()

    def do_reload(self):
        try:
            self.config.reload_file()
            self.logger.load_config()
        except RuntimeError, e:
            logger.warn(e)

    def trigger_hook(self, name, *args, **kwargs):
        """ Experimental """
        hook = self.config.get(name)
        if hook is not None and callable(hook):
            try:
                hook(*args, **kwargs)
            except Exception, e:
                raise RuntimeError("Hook Error: {}".format(e))

    def __enter__(self):
        self.__class__._push_context(self)
        Config._push_context(self.config)
        return self

    def __exit__(self, type, value, traceback):
        Config._pop_context()
        self.__class__._pop_context()


class DaemonProcess(Process):
    pidfile = ginkgo.Setting("pidfile", default=None, help="""
        Path to pidfile to use when daemonizing
        """)

    def __init__(self, app_factory, config=None):
        super(DaemonProcess, self).__init__(app_factory, config)

        if self.pidfile is None:
            self.config.set("pidfile", os.path.expanduser(
                            "~/.{}.pid".format(self.service_name)))
        self.pidfile = ginkgo.util.Pidfile(str(self.pidfile))


    def do_start(self):
        ginkgo.util.prevent_core_dump()
        ginkgo.util.daemonize(
            preserve_fds=self.logger.file_descriptors)
        self.logger.capture_stdio()
        self.pid = os.getpid()
        self.pidfile.create(self.pid)
        super(DaemonProcess, self).do_start()

    def do_stop(self):
        super(DaemonProcess, self).do_stop()
        self.pidfile.unlink()


########NEW FILE########
__FILENAME__ = util
"""Ginkgo utility functions and classes

This module contains functions and classes that are shared across modules or
are more general utilities that aren't specific to Ginkgo. This way we keep
Ginkgo modules very dense in readable domain specific code.
"""
import resource
import os
import errno
import tempfile


class defaultproperty(object):
    """
    Allow for default-valued properties to be added to classes.

    Example usage:

    class Foo(object):
        bar = defaultproperty(list)
    """
    def __init__(self, default_factory, *args, **kwargs):
        self.default_factory = default_factory
        self.args = args
        self.kwargs = kwargs

    def __get__(self, instance, owner):
        if instance is None:
            return None
        for kls in owner.__mro__:
            for key, value in kls.__dict__.iteritems():
                if value == self:
                    newval = self.default_factory(*self.args, **self.kwargs)
                    instance.__dict__[key] = newval
                    return newval


def daemonize(preserve_fds=None):
    """\
    Standard daemonization of a process.
    http://www.svbug.com/documentation/comp.unix.programmer-FAQ/faq_2.html#SEC16
    """
    def _maxfd(limit=1024):
        maxfd = resource.getrlimit(resource.RLIMIT_NOFILE)[1]
        if maxfd == resource.RLIM_INFINITY:
            return limit
        else:
            return maxfd

    def _devnull(default="/dev/null"):
        if hasattr(os, "devnull"):
            return os.devnull
        else:
            return default

    def _close_fds(preserve=None):
        preserve = preserve or []
        for fd in xrange(0, _maxfd()):
            if fd not in preserve:
                try:
                    os.close(fd)
                except OSError: # fd wasn't open to begin with (ignored)
                    pass

    if os.fork():
        os._exit(0)
    os.setsid()

    if os.fork():
        os._exit(0)

    os.umask(0)
    _close_fds(preserve_fds)

    os.open(_devnull(), os.O_RDWR)
    os.dup2(0, 1)
    os.dup2(0, 2)

def prevent_core_dump():
    """ Prevent this process from generating a core dump.

        Sets the soft and hard limits for core dump size to zero. On
        Unix, this prevents the process from creating core dump
        altogether.

        """
    core_resource = resource.RLIMIT_CORE

    try:
        # Ensure the resource limit exists on this platform, by requesting
        # its current value
        core_limit_prev = resource.getrlimit(core_resource)
    except ValueError, e:
        raise RuntimeWarning(
            "System does not support RLIMIT_CORE resource limit ({})".format(e))

    # Set hard and soft limits to zero, i.e. no core dump at all
    resource.setrlimit(core_resource, (0, 0))

class PassthroughEvent(object):
    def wait(self, timeout=None): return
    def set(self): return
    def clear(self): return

class AbstractStateMachine(object):
    event_class = PassthroughEvent

    def __init__(self, subject):
        self._state = self.initial_state
        self._subject = subject
        self._waitables = {}
        if hasattr(self._subject, 'async'):
            self.event_class = self._subject.async.event
        for state in self.allow_wait:
            self._waitables[state] = self.event_class()

    @property
    def current(self):
        return self._state

    def wait(self, state, timeout=None):
        if state in self._waitables:
            self._waitables[state].wait(timeout)
        else:
            raise RuntimeWarning("Unable to wait for state '{}'".format(state))

    def __call__(self, event):
        from_states, to_state, callback = self._lookup_event(event)
        if self._state in from_states:
            self._callback(callback)
            self._transition(to_state)
        else:
            raise RuntimeWarning("""
                Unable to enter '{}' from state '{}'
                """.format(to_state, self.current).strip())

    def _lookup_event(self, event):
        event_definition = "event_{}".format(event)
        if hasattr(self, event_definition):
            return getattr(self, event_definition)
        else:
            raise AttributeError("No event '{}' on {}".format(event, self))

    def _callback(self, name):
        if name is not None and hasattr(self._subject, name):
            getattr(self._subject, name)()

    def _transition(self, new_state):
        for state in self._waitables:
            self._waitables[state].clear()
        self._state = new_state
        if new_state in self._waitables:
            self._waitables[new_state].set()


class GlobalContext(object):
    """Context manager mixin for stackable singletons

    Use this mixin when a class has a global singleton set somewhere that can
    be temporarily set while in the context of an instance of that class::

        class Foo(GlobalContext):
            instance = None  # where we'll keep the singleton
            singleton_attr = (Foo, 'instance')  # tell mixin where it is

        Foo.instance = Foo()  # set an initial Foo singleton
        temporary_foo = Foo()  # create another Foo
        # now use it as a context
        with temporary_foo:
            # the singleton will be set to this instance
            assert Foo.instance is temporary_foo
        # then set back when you exit the context
        assert Foo.instance is not temporary_foo

    You can also nest global contexts if necessary. The main API is just
    setting where the singleton is with `singleton_attr`, which is a tuple of
    (object, attribute name). If `singleton_attr` is not set, there is no
    effect when you use the context manager. You can define `singleton_attr`
    outside the class definition to decouple your class definition from your
    use of a singleton. For example::

        class Foo(GlobalContext):
            pass

        singleton = Foo()  # module level singleton
        Foo.singleton_attr = (sys.modules[__name__], 'singleton')

    """
    singleton_attr = None
    _singleton_stacks = {}

    @classmethod
    def _get_singleton(cls):
        if cls.singleton_attr:
            return getattr(*cls.singleton_attr)

    @classmethod
    def _set_singleton(cls, value):
        if cls.singleton_attr:
            setattr(*list(cls.singleton_attr)+[value])

    @classmethod
    def _push_context(cls, obj):
        if cls.singleton_attr:
            klass = cls.__name__
            if klass not in cls._singleton_stacks:
                cls._singleton_stacks[klass] = []
            cls._singleton_stacks[klass].append(cls._get_singleton())
            cls._set_singleton(obj)

    @classmethod
    def _pop_context(cls):
        if cls.singleton_attr:
            klass = cls.__name__
            cls._set_singleton(
                    cls._singleton_stacks.get(klass, []).pop())

    def __enter__(self):
        self.__class__._push_context(self)
        return self

    def __exit__(self, type, value, traceback):
        self.__class__._pop_context()


class Pidfile(object):
    """\
    Manage a PID file. If a specific name is provided
    it and '"%s.oldpid" % name' will be used. Otherwise
    we create a temp file using os.mkstemp.
    """

    def __init__(self, fname):
        self.fname = fname
        self.pid = None

    def create(self, pid):
        oldpid = self.validate()
        if oldpid:
            if oldpid == os.getpid():
                return
            raise RuntimeError("Already running on PID %s " \
                "(or pid file '%s' is stale)" % (os.getpid(), self.fname))

        self.pid = pid

        # Write pidfile
        fdir = os.path.dirname(self.fname)
        if fdir and not os.path.isdir(fdir):
            raise RuntimeError("%s doesn't exist. Can't create pidfile." % fdir)
        fd, fname = tempfile.mkstemp(dir=fdir)
        os.write(fd, "%s\n" % self.pid)
        if self.fname:
            os.rename(fname, self.fname)
        else:
            self.fname = fname
        os.close(fd)

        # set permissions to -rw-r--r-- 
        os.chmod(self.fname, 420)

    def rename(self, path):
        self.unlink()
        self.fname = path
        self.create(self.pid)

    def unlink(self):
        """ delete pidfile"""
        try:
            with open(self.fname, "r") as f:
                pid1 =  int(f.read() or 0)

            if pid1 == self.pid:
                os.unlink(self.fname)
        except:
            pass

    def validate(self):
        """ Validate pidfile and make it stale if needed"""
        if not self.fname:
            return
        try:
            with open(self.fname, "r") as f:
                wpid = int(f.read() or 0)

                if wpid <= 0:
                    return

                try:
                    os.kill(wpid, 0)
                    return wpid
                except OSError, e:
                    if e[0] == errno.ESRCH:
                        return
                    raise
        except IOError, e:
            if e[0] == errno.ENOENT:
                return
            raise

## The following is extracted from ProxyTypes 0.9 package, licensed under ZPL:
## http://pypi.python.org/pypi/ProxyTypes

class AbstractProxy(object):
    """Delegates all operations (except ``.__subject__``) to another object"""
    __slots__ = ()

    def __call__(self,*args,**kw):
        return self.__subject__(*args,**kw)

    def __getattribute__(self, attr, oga=object.__getattribute__):
        subject = oga(self,'__subject__')
        if attr=='__subject__':
            return subject
        return getattr(subject,attr)

    def __setattr__(self,attr,val, osa=object.__setattr__):
        if attr=='__subject__':
            osa(self,attr,val)
        else:
            setattr(self.__subject__,attr,val)

    def __delattr__(self,attr, oda=object.__delattr__):
        if attr=='__subject__':
            oda(self,attr)
        else:
            delattr(self.__subject__,attr)

    def __nonzero__(self):
        return bool(self.__subject__)

    def __getitem__(self,arg):
        return self.__subject__[arg]

    def __setitem__(self,arg,val):
        self.__subject__[arg] = val

    def __delitem__(self,arg):
        del self.__subject__[arg]

    def __getslice__(self,i,j):
        return self.__subject__[i:j]


    def __setslice__(self,i,j,val):
        self.__subject__[i:j] = val

    def __delslice__(self,i,j):
        del self.__subject__[i:j]

    def __contains__(self,ob):
        return ob in self.__subject__

    for name in 'repr str hash len abs complex int long float iter oct hex'.split():
        exec "def __%s__(self): return %s(self.__subject__)" % (name,name)

    for name in 'cmp', 'coerce', 'divmod':
        exec "def __%s__(self,ob): return %s(self.__subject__,ob)" % (name,name)

    for name,op in [
        ('lt','<'), ('gt','>'), ('le','<='), ('ge','>='),
        ('eq','=='), ('ne','!=')
    ]:
        exec "def __%s__(self,ob): return self.__subject__ %s ob" % (name,op)

    for name,op in [('neg','-'), ('pos','+'), ('invert','~')]:
        exec "def __%s__(self): return %s self.__subject__" % (name,op)

    for name, op in [
        ('or','|'),  ('and','&'), ('xor','^'), ('lshift','<<'), ('rshift','>>'),
        ('add','+'), ('sub','-'), ('mul','*'), ('div','/'), ('mod','%'),
        ('truediv','/'), ('floordiv','//')
    ]:
        exec (
            "def __%(name)s__(self,ob):\n"
            "    return self.__subject__ %(op)s ob\n"
            "\n"
            "def __r%(name)s__(self,ob):\n"
            "    return ob %(op)s self.__subject__\n"
            "\n"
            "def __i%(name)s__(self,ob):\n"
            "    self.__subject__ %(op)s=ob\n"
            "    return self\n"
        )  % locals()

    del name, op

    # Oddball signatures

    def __rdivmod__(self,ob):
        return divmod(ob, self.__subject__)

    def __pow__(self,*args):
        return pow(self.__subject__,*args)

    def __ipow__(self,ob):
        self.__subject__ **= ob
        return self

    def __rpow__(self,ob):
        return pow(ob, self.__subject__)

class ObjectProxy(AbstractProxy):
    """Proxy for a specific object"""

    __slots__ = "__subject__"

    def __init__(self,subject):
        self.__subject__ = subject

class AbstractWrapper(AbstractProxy):
    """Mixin to allow extra behaviors and attributes on proxy instance"""
    __slots__ = ()

    def __getattribute__(self, attr, oga=object.__getattribute__):
        if attr.startswith('__'):
            subject = oga(self,'__subject__')
            if attr=='__subject__':
                return subject
            return getattr(subject,attr)
        return oga(self,attr)

    def __getattr__(self,attr, oga=object.__getattribute__):
        return getattr(oga(self,'__subject__'), attr)

    def __setattr__(self,attr,val, osa=object.__setattr__):
        if (
            attr=='__subject__'
            or hasattr(type(self),attr) and not attr.startswith('__')
        ):
            osa(self,attr,val)
        else:
            setattr(self.__subject__,attr,val)

    def __delattr__(self,attr, oda=object.__delattr__):
        if (
            attr=='__subject__'
            or hasattr(type(self),attr) and not attr.startswith('__')
        ):
            oda(self,attr)
        else:
            delattr(self.__subject__,attr)

class ObjectWrapper(ObjectProxy, AbstractWrapper):      __slots__ = ()


########NEW FILE########
__FILENAME__ = gevent.conf
##
## This is not actually a good example! It's being used for testing
## purposes since there are no tests yet...
##

import logging
from ginkgo import Service as _Service
from ginkgo import Setting


delay = 1

class flask:
    debug = False
    testing = True
    secret_key = "woifh28fhw93fh"

    class subgroup:
        foo = "bar"

class MyService(_Service):
    foo = Setting("foo", default=("foo", 12), help="This is foo")
    bar = Setting("bar", help="This is bar", monitored=True)
    delay = Setting("delay", default=1, help="Delay between hello printing")

    def __init__(self):
        import logging
        self.log = logging.getLogger(__name__)

    def do_start(self):
        self.log.info("Hello here")
        self.spawn(self.loop)

    def do_reload(self):
        self.log.info("reloaded!")
        self.log.info("changed: {}".format(self.bar.changed))

    def loop(self):
        while True:
            self.log.info("hello")
            self.async.sleep(self.delay)

async = 'ginkgo.async.gevent'
service = MyService

########NEW FILE########
__FILENAME__ = threading.conf
##
## This is not actually a good example! It's being used for testing
## purposes since there are no tests yet...
##

import logging
from ginkgo import Service as _Service
from ginkgo import Setting


delay = 1

class flask:
    debug = False
    testing = True
    secret_key = "woifh28fhw93fh"

    class subgroup:
        foo = "bar"

class MyService(_Service):
    foo = Setting("foo", default=("foo", 12), help="This is foo")
    bar = Setting("bar", help="This is bar", monitored=True)
    delay = Setting("delay", default=1, help="Delay between hello printing")

    def __init__(self):
        import logging
        self.log = logging.getLogger(__name__)

    def do_start(self):
        self.log.info("Hello here")
        self.spawn(self.loop)

    def do_reload(self):
        self.log.info("reloaded!")
        self.log.info("changed: {}".format(self.bar.changed))

    def loop(self):
        while True:
            self.log.info("hello")
            self.async.sleep(self.delay)

service = MyService

########NEW FILE########
__FILENAME__ = test_config
from ginkgo import config

def test_config():
    c = config.Config()
    c.load({
        "foo": "bar",
        "bar.foo": "qux",
        "bar.boo": "bar",
        "bar.baz.foo": "bar",
        "bar.baz.bar": "bar"})

    assert c.get("foo") == "bar"

    class MyClass(object):
        foo = c.setting("foo", help="This is foo.", monitored=True)

        def override(self):
            self.foo = "qux"

    o = MyClass()
    assert o.foo == "bar"
    assert o.foo.changed == False
    assert o.foo.changed == False
    c.set("foo", "BAZ")
    assert o.foo.changed == True
    assert o.foo.changed == False
    assert MyClass.foo == "BAZ"

    o.override()
    assert MyClass.foo == "BAZ"
    assert o.foo == "qux"

    g = c.group()
    assert g.foo == "BAZ"
    assert g.bar.__class__ == config.Group
    assert g.bar.boo == "bar"
    assert g.bar.tree == None

########NEW FILE########
__FILENAME__ = test_util
import unittest

from ginkgo import util

class GlobalContextTest(unittest.TestCase):
    singleton_a = None
    singleton_b = None

    def setUp(self):
        GlobalContextTest.singleton_a = object()
        GlobalContextTest.singleton_b = object()


    def test_push_pop_of_singleton(self):
        class TestContext(util.GlobalContext):
            singleton_attr = (GlobalContextTest, 'singleton_a')
        def _singleton_id():
            return id(GlobalContextTest.singleton_a)
        original_id = _singleton_id()
        new_object = object()
        TestContext._push_context(new_object)
        assert not _singleton_id() == original_id
        assert _singleton_id() == id(new_object)
        TestContext._pop_context()
        assert not _singleton_id() == id(new_object)
        assert _singleton_id() == original_id

    def test_nested_push_pop_of_two_singletons(self):
        class TestContext(util.GlobalContext):
            singleton_attr = (GlobalContextTest, 'singleton_a')
        def _singleton_id():
            return id(GlobalContextTest.singleton_a)
        original_id = _singleton_id()
        first_object = object()
        second_object = object()
        assert _singleton_id() == original_id
        TestContext._push_context(first_object)
        assert _singleton_id() == id(first_object)
        TestContext._push_context(second_object)
        assert _singleton_id() == id(second_object)
        TestContext._pop_context()
        assert _singleton_id() == id(first_object)
        TestContext._pop_context()
        assert _singleton_id() == original_id

    def test_multiple_global_contexts(self):
        class FirstContext(util.GlobalContext):
            singleton_attr = (GlobalContextTest, 'singleton_a')
        class SecondContext(util.GlobalContext):
            singleton_attr = (GlobalContextTest, 'singleton_b')
        def _first_singleton_id():
            return id(GlobalContextTest.singleton_a)
        def _second_singleton_id():
            return id(GlobalContextTest.singleton_b)
        first_original_id = _first_singleton_id()
        second_original_id = _second_singleton_id()
        assert not first_original_id == second_original_id
        first_object = object()
        second_object = object()
        FirstContext._push_context(first_object)
        assert _first_singleton_id() == id(first_object)
        assert not _second_singleton_id() == id(first_object)
        SecondContext._push_context(second_object)
        assert _second_singleton_id() == id(second_object)
        assert not _first_singleton_id() == id(second_object)
        assert _first_singleton_id() == id(first_object)
        FirstContext._pop_context()
        assert _first_singleton_id() == first_original_id
        SecondContext._pop_context()
        assert _second_singleton_id() == second_original_id

    def test_context_manager(self):
        class TestContext(util.GlobalContext): pass
        TestContext.singleton_attr = (GlobalContextTest, 'singleton_a')
        GlobalContextTest.singleton_a = TestContext()
        original_id = id(GlobalContextTest.singleton_a)
        new_context = TestContext()
        with new_context:
            assert not original_id == id(GlobalContextTest.singleton_a)
            assert id(new_context) == id(GlobalContextTest.singleton_a)
        assert original_id == id(GlobalContextTest.singleton_a)

    def test_nested_context_managers(self):
        class TestContext(util.GlobalContext): pass
        TestContext.singleton_attr = (GlobalContextTest, 'singleton_a')
        GlobalContextTest.singleton_a = TestContext()
        original_id = id(GlobalContextTest.singleton_a)
        first_context = TestContext()
        second_context = TestContext()
        with first_context:
            assert id(first_context) == id(GlobalContextTest.singleton_a)
            with second_context:
                assert id(second_context) == id(GlobalContextTest.singleton_a)
            assert id(first_context) == id(GlobalContextTest.singleton_a)
        assert original_id == id(GlobalContextTest.singleton_a)

########NEW FILE########
