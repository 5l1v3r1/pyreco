__FILENAME__ = generate_help
import codecs
import re
import string
import sys
import datetime

regexp = re.compile ('\{\{|\}\}')

def process_line (line, short_opts, long_opts):
    reassembled = []
    pieces = regexp.split (line)
    if pieces != None:
        for piece in pieces:
            if piece.startswith ('--'):
                long_opts.append (string.replace (piece, '-', ''))
                piece = string.replace (piece, '=', '')
            elif piece.startswith ('-'):
                short_opts.append(string.replace (piece, '-', ''))
                piece = string.replace (piece, ':', '')
            reassembled.append (piece)
    return ''.join (reassembled)

instream=codecs.open('templates/help-template.txt', 'r', 'utf-8')

short_opts = []
long_opts = []

print "# THIS FILE IS AUTOGENERATED"
print
print 'def print_help ():'
print "    print 'Version: " + sys.argv[1] + ' ' + datetime.date.strftime(datetime.date.today(), '%Y-%m-%d') + "'"
for line in instream:
    processed_line = process_line (line.rstrip (), short_opts, long_opts)
    if len (processed_line.strip()) > 0:
        print "    print '" + processed_line + "'"
    else:
        print "    print"

print
print "SHORT_OPTS = '" + ''.join(short_opts) + "'" 
print "LONG_OPTS = ['" + "','".join(long_opts) + "']" 
  
instream.close ()
########NEW FILE########
__FILENAME__ = pretty_json
#!/usr/local/bin/python
import fileinput
import json
if __name__ == "__main__":
  jsonStr = ''
  for a_line in fileinput.input():
    jsonStr = jsonStr + ' ' + a_line.strip()    
  jsonObj = json.loads(jsonStr)  
  print json.dumps(jsonObj, sort_keys=True, indent=4) 

########NEW FILE########
__FILENAME__ = attrib_convert
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

from string import Template

class Conversion:
    def __init__ (self, field, default, format_template, typ, evaluate = None):
        self.field = field
        self.evaluate = evaluate
        self.type = typ
        self.format_template = Template(format_template)
        self.default = default            
    def value (self, node, type_fns):
        # Does the attrib have the attribute at all?
        # If not use the template default 
        if not self.field in node.__dict__:
            return self.default
        
        value = node.__dict__[self.field]
        
        # If it's null use the demplate default
        if value == None:
            return self.default
        
        # Run optional custom code, for example loading
        # a sub attribute of the object
        if self.evaluate != None:
            value = eval (self.evaluate) 
        
        # If that yielded null use the template default
        if value == None:
            return self.default
        
        # Run a converter assocuated with it's type
        # Possibly loaded from a plugin
        value = type_fns[self.type] (value) 
        
        # If that yielded null use the template default
        if value == None:
            return self.default
        
        # Finally, having got a non-null string format it with the format associated with the field
        return self.format_template.safe_substitute (value=value)
        
class AttribMapBuilder:
    def __init__ (self):
        
        self.type_fns = {}
        self.type_fns['string'] = lambda x: x
        self.type_fns['date'] = lambda x: x.strftime(self.date_format)
        self.type_fns['boolean'] = lambda x: str (x)
        self.type_fns['int'] = lambda x: int (x)
        self.type_fns['note'] = lambda x: x.get_note ()
        
        self.attrib_conversions = {}
        self.set_conversion(Conversion("id", "", "$value", "string"))
        self.set_conversion(Conversion("type", "", "$value", "string"))
        self.set_conversion(Conversion("name", "", "$value", "string"))
        self.set_conversion(Conversion("link", "", "$value", "string"))
        self.set_conversion(Conversion("status", "", "$value", "string"))
        self.set_conversion(Conversion("flagged", "", "$value", "boolean"))
        self.set_conversion(Conversion("context", "", "$value", "string", "value.name"))
        self.set_conversion(Conversion("project", "", "$value", "string", "value.name"))
        self.set_conversion(Conversion("date_to_start", "", "$value", "date"))
        self.set_conversion(Conversion("date_due", "", "$value", "date"))
        self.set_conversion(Conversion("date_added", "", "$value", "date"))
        self.set_conversion(Conversion("estimated_minutes", "", "$value", "int"))
        self.set_conversion(Conversion("date_complete", "", "$value", "date"))
        self.set_conversion(Conversion("note", "", "$value", "note"))
        
        self.date_format = "%Y-%m-%d"
    def set_conversion (self, attrib):
        self.attrib_conversions[attrib.field] = attrib
    def get_values (self, x):
        result = {}
        for conversion in self.attrib_conversions.values():
            key = conversion.field
            value = conversion.value (x, self.type_fns)
            result[key] = value
        return result
    
########NEW FILE########
__FILENAME__ = cmd_parser
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import re
from treemodel import TASK, PROJECT, CONTEXT, FOLDER, Note
from datetime import datetime
from datematch import process_date_specifier, match_date_against_range, date_range_to_str
from visitors import Filter, Prune, Sort, Flatten
import logging

LOGGER = logging.getLogger(__name__)

the_time = None
NOW = datetime.now()
FAR_FUTURE = datetime.strptime("3000-01-01", "%Y-%m-%d")

def now ():
    # allows us to test with a fixed date
    if the_time != None:
        return the_time
    return NOW

# Primary/Real name is first
NAME_ALIASES = ['name', 'title', 'text', 'name']
START_ALIASES = ['date_to_start', 'start', 'started', 'begin', 'began']
COMPLETED_ALIASES = ['date_completed', 'done', 'end', 'ended', 'complete', 'completed', 'finish', 'finished', 'completion']
DUE_ALIASES = ['date_due', 'due', 'deadline']
FLAGGED_ALIASES = ['flagged', 'flag']
NEXT_ALIASES = ['next', 'next']
TYPE_ALIASES = ['type']
NOTE_ALIASES = ['note']
STATUS_ALIASES = ['status']

FLATTEN_ALIASES = ['flat', 'flatten']
PRUNE_ALIASES = ['prune']
SORT_ALIASES = ['sort']

def build_alias_lookups (): 
    mk_map = lambda x: {alias:x[0] for alias in x}
    result = {}
    result.update (mk_map (NAME_ALIASES))
    result.update (mk_map (START_ALIASES))
    result.update (mk_map (COMPLETED_ALIASES))
    result.update (mk_map (DUE_ALIASES))
    result.update (mk_map (FLAGGED_ALIASES))
    result.update (mk_map (NEXT_ALIASES))
    result.update (mk_map (TYPE_ALIASES))
    result.update (mk_map (NOTE_ALIASES))
    result.update (mk_map (STATUS_ALIASES))
    return result

def build_date_alias_lookups (): 
    mk_map = lambda x: {alias:x[0] for alias in x}
    result = {}
    result.update (mk_map (START_ALIASES))
    result.update (mk_map (COMPLETED_ALIASES))
    result.update (mk_map (DUE_ALIASES))
    return result

def build_string_alias_lookups (): 
    mk_map = lambda x: {alias:x[0] for alias in x}
    result = {}
    result.update (mk_map (NAME_ALIASES))
    result.update (mk_map (TYPE_ALIASES))
    result.update (mk_map (NOTE_ALIASES))
    result.update (mk_map (STATUS_ALIASES))
    return result
    
ALIAS_LOOKUPS = build_alias_lookups ()

DATE_ALIAS_LOOKUPS = build_date_alias_lookups ()

STRING_ALIAS_LOOKUPS = build_string_alias_lookups ()

# TOKENS
SPACE = 'SP'
TEXT = 'TXT'
QUOTED_TEXT = 'QTXT'
OPEN_BRACE = 'OB'
CLOSE_BRACE = 'CB'
NOT_EQUAL = 'NE'
EQUAL = 'EQ'
DOUBLE_QUOTE = 'DQ'
SINGLE_QUOTE = 'SQ'
AND = 'AND'
OR = 'OR'
NOT = 'NOT'
BACKSLASH = 'BS'

TOKEN_PATTERNS = [
          # tok name, pattern, text equivalent
          (OPEN_BRACE, re.compile('^(\()')),
          (CLOSE_BRACE, re.compile('^(\))')),
          (AND, re.compile('^(and)(\(| )')),
          (OR, re.compile('^(or)(\(| )')),
          (SPACE, re.compile('^( )')),
          (DOUBLE_QUOTE, re.compile('^(")')),
          (SINGLE_QUOTE, re.compile("^(')")),
          (EQUAL, re.compile('^(=)')),
          (NOT_EQUAL, re.compile('^(!=)')),
          (NOT, re.compile('^(!)')),
          (BACKSLASH, re.compile('^(\\\\)'))
          ]

ESCAPEABLE_CHARS = '"\\'


BOOL_TYPE = 'Boolean'
DATE_TYPE = 'Date'
STRING_TYPE = 'String'

def read_to_end_quote (quote_char,remainder):
    text = ""
    escaped = False
    while len (remainder) > 0:
        char = remainder[0]
        remainder = remainder[1:]
        if escaped:
            if char in ESCAPEABLE_CHARS:
                text += char
            else:
                text += '\\'
                text += char
            escaped = False
        else:
            if char == '\\':
                escaped = True
            elif char == quote_char:
                return (text, remainder)
            else:
                text += char 
    assert False, "unclosed quote"
            

def tokenise (characters):
    remainder = characters
    text = ""
    tokens = []
    while len (remainder) > 0:
        matched = False
        for tok_name, cpattern in TOKEN_PATTERNS:
            if len (remainder) > 0 and not matched:
                match = cpattern.match (remainder)
                if match != None:
                    tok_value = match.group(1)
                    LOGGER.debug ("remainder: %s", remainder)
                    matched = True
                    if len (text) > 0:
                        tok = (TEXT, text)
                        LOGGER.debug ("token: %s flushed", tok)
                        tokens.append (tok)
                        text = ''
                    if tok_name == DOUBLE_QUOTE or tok_name == SINGLE_QUOTE:
                        string, remainder = read_to_end_quote (tok_value, remainder[1:])
                        tok = (QUOTED_TEXT, string)
                        LOGGER.debug ("token: %s quoted", tok)
                        tokens.append (tok)
                    else:
                        remainder = remainder[len(tok_value):]
                        tok = (tok_name, tok_value)
                        LOGGER.debug ("token: %s matched", tok)
                        tokens.append (tok)
        if not matched:
            LOGGER.debug ("remainder: %s", remainder)
            text += remainder[0]
            remainder = remainder[1:]
        
    if len (text) > 0:
        tok = (TEXT, text)
        LOGGER.debug ("token: %s final flush", tok)
        tokens.append (tok)

    tokens = [token for token in tokens if token[0] != SPACE]                  
    LOGGER.debug ("tokens: %s", tokens)
    return tokens

def next_token (tokens, options):
    if len(tokens) == 0:
        assert False, 'end of tokens, expected ' + str(options)
    t,v = tokens[0]
    if not t in options:
        assert False, 'found "' + v + '" not: ' + str(options)
    return (t,v), tokens[1:]
    
def parse_string (tokens, stop_tokens):
    buf = []
    while len(tokens) > 0:
        t,v = tokens[0]
        tokens = tokens[1:]
        if t in stop_tokens:
            return unicode(''.join(buf)), [(t,v)] + tokens
        else:
            buf.append(v)
    return unicode(''.join(buf)), []

def and_fn (lhs_fn, rhs_fn, x):
    
    lhs = lhs_fn (x)
    LOGGER.debug ('eval and: lhs=(%s)', lhs)
    assert type(lhs) == bool
    if not lhs:
        return False;
    
    rhs = rhs_fn (x)
    LOGGER.debug ('eval and: rhs=(%s)', rhs)
    assert type(lhs) == bool
    return rhs

def or_fn (lhs_fn, rhs_fn, x):
    lhs = lhs_fn (x)
    LOGGER.debug ('eval or: lhs=(%s)', lhs)
    assert type(lhs) == bool, "expected " + BOOL_TYPE + ' but got ' + str(type(lhs))
    if lhs:
        return True;
    
    rhs = rhs_fn (x)
    LOGGER.debug ('eval or: rhs=(%s)', rhs)
    assert type(lhs) == bool
    return rhs

def reorder (lhs, rhs):
    if type (rhs) == datetime:
        return rhs,lhs
    if type (lhs) == tuple:
        return rhs, lhs
    return lhs, rhs
    
def eq_fn (lhs, rhs):
    lhs, rhs = reorder (lhs, rhs)
    LOGGER.debug ('eval =: (%s) = (%s)', lhs, rhs)
    
    if type(rhs) == tuple:
        LOGGER.debug ('eval 1 =: (%s) = (%s)', lhs, rhs)
        result = match_date_against_range (lhs, rhs)
    elif (lhs == None and rhs != None) or (lhs != None and rhs == None):
        LOGGER.debug ('eval 2 =: (%s) = (%s)', lhs, rhs)
        result= False
    elif type(lhs) == type(rhs):
        if type(lhs) == str or type(lhs) == unicode: 
            LOGGER.debug ('eval 3 =: (%s) = (%s)', lhs, rhs)
            result = re.search(rhs, lhs) != None
        else:
            LOGGER.debug ('eval 4 =: (%s) = (%s)', lhs, rhs)
            result = lhs == rhs
    elif type(rhs) == tuple:
        LOGGER.debug ('eval 5 =: (%s) = (%s)', lhs, rhs)
        result = match_date_against_range (lhs, rhs)
    else:
        assert False, 'unknown or incompatible types: ' + str(type(lhs)) + ' and ' + str(type(rhs))
    
    LOGGER.debug ('result =: (%s)', result)
    return result

def ne_fn (lhs, rhs):
    LOGGER.debug ('eval !=: (%s) != (%s)', lhs, rhs)
    result = not eq_fn (lhs, rhs)
    LOGGER.debug ('result !=: (%s)', result)
    return result

def adapt (x):
    if type (x) == str:
        return unicode (x)
    if isinstance (x,Note):
        return x.get_note()
    return x

def access_field (x, field):
    if not field in x.__dict__:
        LOGGER.debug ('accessing field %s.%s - not in dict, returning None', type(x), field)
        return None
    result = x.__dict__[field]
    result = adapt (result)
    LOGGER.debug ('accessing field %s.%s=\'%s\'', type(x), field, result)
    return adapt (result)

def parse_expr (tokens, type_required=BOOL_TYPE, now = now (), level = 0):
    LOGGER.debug ('parsing %s tokens: %s', level, tokens)
    tok, tokens = next_token (tokens, [TEXT, QUOTED_TEXT, NOT, OPEN_BRACE])
    (t,v) = tok
    
    # NOT
    if t == NOT:
        assert type_required == BOOL_TYPE, "expecting a ' + required_type' expression, not " + BOOL_TYPE
        expr, tokens, expr_type, expr_string = parse_expr (tokens, now=now, level=level+1)
        assert expr_type == BOOL_TYPE, "not must have a boolean argument"
        LOGGER.debug ('built %s:1 %s %s', level, expr_type, expr_string)
        return (lambda x: not expr (x)), tokens, BOOL_TYPE, 'not(' + expr_string + ')'
    
    # LHS
    if t == TEXT and v =='true':
        lhs = lambda x: True
        lhs_string = 'true'
        lhs_type = BOOL_TYPE
    elif t == TEXT and v =='false':
        lhs = lambda x: False
        lhs_string = 'true'
        lhs_type = BOOL_TYPE
    elif t == TEXT and v in ALIAS_LOOKUPS:
        field = ALIAS_LOOKUPS[v]
        lhs = lambda x: access_field(x, field)
        lhs_string = 'field:' + field
        if field in DATE_ALIAS_LOOKUPS:
            lhs_type = DATE_TYPE
        elif field in STRING_ALIAS_LOOKUPS:
            lhs_type = STRING_TYPE
        else:
            lhs_type = BOOL_TYPE
    elif t == OPEN_BRACE:
        lhs, tokens, lhs_type, lhs_string = parse_expr (tokens, now=now, level=level+1)
        tokens = next_token (tokens, [CLOSE_BRACE])[1]
    elif t == QUOTED_TEXT:
        text = v
        lhs = lambda x: unicode (text)
        lhs_string = '"' + v + '"'
        lhs_type = STRING_TYPE
        if type_required == DATE_TYPE:
            rng = process_date_specifier (now, text)
            lhs = lambda x: rng
            lhs_string = '[' + date_range_to_str(rng) + ']'
            lhs_type = DATE_TYPE
    elif t == TEXT:
        text = v
        lhs = lambda x: unicode (text)
        lhs_string = text
        lhs_type = STRING_TYPE
        if type_required == DATE_TYPE:
            rng = process_date_specifier (now, text)
            lhs = lambda x: rng
            lhs_string = '[' + date_range_to_str(rng) + ']'
            lhs_type = DATE_TYPE
    else:
        assert False, 'unexpected token: ' + v
    
    LOGGER.debug ('built %s:2 %s %s', level, lhs_type, lhs_string)
    
    # OPERATOR 
    if len(tokens) == 0:
        LOGGER.debug ('built %s:3 %s %s', level, lhs_type, lhs_string)
        assert type_required == lhs_type, "expecting a " + type_required + ' got a ' + lhs_type + ': ' + lhs_string
        return lhs, tokens, lhs_type, lhs_string
    
    tok, tokens = next_token (tokens,[AND, OR, EQUAL, NOT_EQUAL, CLOSE_BRACE])
    op,v = tok
    if op == CLOSE_BRACE:
        LOGGER.debug ('built %s:4 %s %s', level, lhs_type, lhs_string)
        assert type_required == lhs_type, "expecting a " + type_required + ' got a ' + lhs_type + ': ' + lhs_string
        return lhs, [tok] + tokens, lhs_type, lhs_string
        
    rhs, tokens, rhs_type, rhs_string = parse_expr (tokens, type_required = lhs_type, now=now, level=level+1)         
    assert lhs_type == rhs_type, "incompatible types, " + lhs_type + ' ' + rhs_type

    assert type_required == BOOL_TYPE, "expecting a " + type_required + ' but got ' + BOOL_TYPE

    if op == AND:
        expr_string = '(' + lhs_string + ')AND(' + rhs_string + ')' 
        LOGGER.debug ('built %s:5 %s %s', level, BOOL_TYPE, expr_string)
        return (lambda x: and_fn(lhs, rhs, x)), tokens, BOOL_TYPE, expr_string
    elif op == OR:
        expr_string = '(' + lhs_string + ')OR(' + rhs_string + ')' 
        LOGGER.debug ('built %s:6 %s %s', level, BOOL_TYPE, expr_string)
        return (lambda x: or_fn(lhs, rhs, x)), tokens, BOOL_TYPE, expr_string
    elif op == EQUAL:
        expr_string = '(' + lhs_string + ')=(' + rhs_string + ')' 
        LOGGER.debug ('built %s:7 %s %s', level, BOOL_TYPE, expr_string)
        return (lambda x: eq_fn (lhs (x), rhs (x))), tokens, BOOL_TYPE, expr_string 
    elif op == NOT_EQUAL:
        expr_string = '(' + lhs_string + ')!=(' + rhs_string + ')' 
        LOGGER.debug ('built %s:8 %s %s', level, BOOL_TYPE, expr_string)
        return (lambda x: ne_fn (lhs (x), rhs (x))), tokens, BOOL_TYPE, expr_string 

def get_date_attrib_or_now (item, attrib):
    if not attrib in item.__dict__:
        return FAR_FUTURE
    result = item.__dict__[attrib]
    if result == None:
        return FAR_FUTURE
    return result

def make_command_filter (expr_str):    
    # First look for sort/prune
    bits = re.split(' ', expr_str)
    if len (bits) >= 2:
        cmd = bits[0].strip()
        if cmd in PRUNE_ALIASES:
            assert len (bits) == 2, 'prune takes one node type argument, got: ' + expr_str
            typ = bits[1].strip ()
            if typ == 'any' or typ == 'all':
                return Prune ([PROJECT, CONTEXT, FOLDER]) # NOT TASKS!!!
            assert typ in [PROJECT, CONTEXT, FOLDER], 'no such node type in prune: ' + typ
            return Prune ([typ])
        if cmd in FLATTEN_ALIASES:
            assert len (bits) == 2, 'flatten takes one node type argument, got: ' + expr_str
            typ = bits[1].strip ()
            if typ == 'any' or typ == 'all':
                return Flatten ([TASK, PROJECT, CONTEXT, FOLDER])
            assert typ in [TASK, PROJECT, CONTEXT, FOLDER], 'no such node type in flatten: ' + typ
            return Flatten ([typ])
        elif cmd in SORT_ALIASES:
            assert len (bits) == 3, 'sort takes two arguments, node type and field, got: ' + expr_str
            typ = bits[1].strip()
            if typ == 'any' or typ == 'all':
                types = [TASK, PROJECT, CONTEXT, FOLDER]
            else:
                assert typ in [TASK, PROJECT, CONTEXT, FOLDER], 'no such node type in sort: ' + typ
                types = [typ]
            field = bits[2].strip()
            assert field in ALIAS_LOOKUPS, 'no such sortable field:' + field
            field = ALIAS_LOOKUPS.get(field)
            if field in DATE_ALIAS_LOOKUPS:
                get_date = lambda x: get_date_attrib_or_now (x, field)
                return Sort (types, get_date, field)
            else:
                get_field = lambda x: x.__dict__[field]
                return Sort (types, get_field, field)
    return None

def make_expr_filter (expr_str, include):
    match_fn, tokens_left, expr_type, expr_string = parse_expr (tokenise (expr_str), now=now())
    if len (tokens_left) > 0:
        assert False, 'don\'t know what to do with: ' + str (tokens_left)
    assert expr_type == BOOL_TYPE, "filter must have a boolean argument"
    return Filter ([TASK, PROJECT, CONTEXT, FOLDER], match_fn, include, expr_string)

def make_filter (expr_str, include):
    
    filtr = make_command_filter (expr_str)
    if filtr == None:
        filtr = make_expr_filter (expr_str, include)
    return filtr

            

########NEW FILE########
__FILENAME__ = of_to_tags
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

from treemodel import traverse_list, Visitor
from omnifocus import build_model, find_database
import os
import codecs

'''
Experimental (and broken)!!!!

A db directory must exist on your desktop first
 
Creates a bazillion little html files each of which links/redirects back to an OmniFocus project/folder/context.
I'm wondering if I can use openmeta on them to essentially get tags into OF via the back door.

If I extract #tags from the item text then I can put that in the file and autotag can find it

'''
class GenerateTagDBVisitor(Visitor):
    def begin_folder (self, folder):
        self.generate_entry ('folder',  folder)
    def begin_project (self, project):
        self.generate_entry ('task', project)
    def begin_context (self, context):
        self.generate_entry ('context', context)
    def generate_entry (self, link_type, item):
        if 'persistentIdentifier' in item.ofattribs:
            ident = item.ofattribs['persistentIdentifier']
            link = 'omnifocus:///' + link_type + '/' + ident
            base = item.name.replace('/','_').replace('\\','/').replace('\.', '_')
            
            file_name=os.environ['HOME'] + '/Desktop/db/' + base + ' ' + ident + '.html'
            out=codecs.open(file_name, 'w', 'utf-8')
            link = 'omnifocus:///' + link_type + '/' + ident
            print >>out, '<html>'
            print >>out, '<head>'
            print >>out, '<meta http-equiv="refresh" content="0; url=' + link + '">'
            print >>out, '</head>'
            print >>out, '<body>'
            print >>out, '<p><a href="' + link + '">' + self.escape(item.name) + '</a>'
            print >>out, '</body>'
            print >>out, '</html>'
            out.close ()
    def escape (self, val):
        return val.replace('"','&quot;').replace('&','&amp;').replace('<','&lt;').replace('>','&gt;')

if __name__ == "__main__":

    root_projects_and_folders, root_contexts = build_model (find_database ())
    
    traverse_list (GenerateTagDBVisitor (), root_projects_and_folders)
    traverse_list (GenerateTagDBVisitor (), root_contexts, project_mode=False)
########NEW FILE########
__FILENAME__ = datematch
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import re
from datetime import datetime, timedelta

def hunt_for_day (now, dow, forward, match_today = False):
    direction = -1
    start = 1
    if forward:
        direction = 1
    if match_today:
        start = 0
    for days in range (start, 8):
        next_date = now + timedelta(days=days*direction)
        next_dow = next_date.strftime ('%A').lower()
        if next_dow.startswith (dow):
            return next_date
    return None

DATE_FMT = '%Y-%m-%d'

def find_first_of_month (now):
    year = now.year
    month = now.month
    return datetime.strptime(str(year) + '-' + str(month) + '-01', DATE_FMT)

def find_next_month (now):
    in_next_month = find_first_of_month (now) + timedelta(days=33)
    return find_first_of_month (in_next_month)

def find_prev_month (now):
    in_last_month = find_first_of_month (now) + timedelta(days=-1)
    return find_first_of_month (in_last_month)

def find_end_of_month (now):
    first_of_this_month = find_first_of_month (now)
    first_of_next_month = find_next_month (first_of_this_month)
    return first_of_next_month - timedelta (days=1)
    
def hunt_for_month (now, month_to_find, forward, match_this_month = False):
    month = None
    if not match_this_month:
        if forward:
            month = find_next_month (now)
        else:
            month = find_prev_month (now)
    else:
        month = find_first_of_month (now)
        
    for i in range (0, 12):
        i = i # stop warning
        month_name = month.strftime ('%B').lower()
        if month_name.startswith (month_to_find):
            return month
        if forward:
            month = find_next_month (month)
        else:
            month = find_prev_month (month)
    return None

def find_monday_this_week (now):
    return hunt_for_day (now, 'mo', False, match_today=True)

def find_monday_next_week (now):
    return hunt_for_day (now, 'mo', True, match_today=False)

def find_january_this_year (now):
    year = now.year
    return datetime.strptime(str(year) + '-01-01', '%Y-%m-%d')

def date_from_string (now, date_str):
    if date_str == "today":
        return now
    elif date_str == 'yesterday':
        return now + timedelta(days=-1)
    elif date_str == 'tomorrow':
        return now + timedelta(days=1)
    elif re.match ('^next (mo|tu|we|th|fr|sa|su)', date_str) != None:
        dow = date_str[4:].strip ()
        next_monday = find_monday_next_week (now)
        return hunt_for_day (next_monday, dow, True, match_today=True)
    elif re.match ('^last (mo|tu|we|th|fr|sa|su)', date_str) != None:
        dow = date_str[4:].strip ()
        this_monday = find_monday_this_week (now)
        return hunt_for_day (this_monday, dow, False)
    elif re.match ('^(mo|tu|we|th|fr|sa|su)', date_str) != None:
        dow = date_str.strip ()
        monday = find_monday_this_week (now)
        return hunt_for_day (monday, dow, True, match_today=True)
    elif re.match ('^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)', date_str) != None:
        month = date_str.strip ()
        jan = find_january_this_year (now)
        return hunt_for_month (jan, month, True, match_this_month=True)
    elif re.match ('^next (jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)', date_str) != None:
        month_str = date_str[4:].strip ()
        jan = find_january_this_year (now)
        month = hunt_for_month (jan, month_str, True, match_this_month=True).month
        year = now.year
        return datetime.strptime(str(year + 1) + '-' + str(month) + '-01', '%Y-%m-%d')
    elif re.match ('^last (jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)', date_str) != None:
        month_str = date_str[4:].strip ()
        jan = find_january_this_year (now)
        return hunt_for_month (jan, month_str, False, match_this_month=False)
    elif re.match ('^[0-9][0-9][0-9][0-9]-[01][0-9]-[0-3][0-9]$', date_str) != None:
        return datetime.strptime(date_str, '%Y-%m-%d')
    else:
        return None
    
def tidy_space_separated_fields (string):
    # eliminate multiple spaces
    elements = string.split ()
    return ' '.join(elements)

def process_date_specifier (now, date_spec):
    date_spec = tidy_space_separated_fields (date_spec).lower()
    
    if date_spec == 'none':
        return (None, None, date_spec)
    if date_spec == 'any':
        return (None, None, date_spec)
    
    match_date = date_from_string (now, date_spec)
    if match_date != None:
        # We've found a single stand alone date, not a range.
        # But if it's a month we want to convert it into a range
        
        if re.match ('(next |last )?(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)', date_spec) != None:
            return (match_date, find_end_of_month (match_date), date_spec)
        else:    
            return (match_date, match_date, date_spec)
    
    if date_spec == 'this week':
        mon = find_monday_this_week (now)
        sun = hunt_for_day (now, 'sun', True, match_today=True)
        return (mon, sun, date_spec)
    elif date_spec == 'next week':
        mon = find_monday_this_week (now) + timedelta(days=7)
        sun = hunt_for_day (now, 'sun', True, match_today=True) + timedelta(days=7)
        return (mon, sun, date_spec)
    elif date_spec == 'last week':
        mon = find_monday_this_week (now) - timedelta(days=7)
        sun = hunt_for_day (now, 'sun', True, match_today=True) - timedelta(days=7)
        return (mon, sun, date_spec)
    elif date_spec.startswith ('from '):
        date_str = date_spec[4:].strip()
        start =  date_from_string (now, date_str)
        return (start, None, date_spec)
    elif date_spec.startswith ('to '):
        date_str = date_spec[2:].strip()
        end =  date_from_string (now, date_str)
        if re.match ('.*(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)', date_str) != None:
            end = find_end_of_month (end)
        return (None, end, date_spec)
    elif re.search (' to ', date_spec) != None:
        elements = str.split (date_spec, ' to ')
        elements = [x.strip() for x in elements if len (x) > 0]
        start = date_from_string(now, elements[0])
        end = date_from_string(now, elements[1])
        if re.match ('.*(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)', elements[1]) != None:
            end = find_end_of_month (end)
        return (start, end, date_spec)
    else:
        raise Exception ('I don\'t think "' + date_spec + '" is any kind of date specification I recognise')

def match_date_against_range (thedate, date_range):
    if date_range == None:
        return thedate != None
    start, end, spec = date_range
    if spec == 'none':
        return thedate == None
    elif spec == 'any':
        return thedate != None
    elif thedate == None:
        return False
    elif start != None and end != None:
        return thedate.date() >= start.date() and thedate.date() <= end.date ()
    elif start != None:
        return thedate.date() >= start.date()
    else:
        return thedate.date() <= end.date ()

def date_range_to_str (rng):
    start, end, spec = rng
    if spec == 'none' or spec == 'any':
        return spec
    elif start == None and end != None:
        return '..' + end.strftime (DATE_FMT)
    elif start != None and end == None:
        return start.strftime (DATE_FMT) + '..'
    elif start == end:
        return start.strftime (DATE_FMT)
    else:
        return start.strftime (DATE_FMT) + '..' + end.strftime (DATE_FMT)
########NEW FILE########
__FILENAME__ = fmt_template
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''
import os
from string import Template
from treemodel import Visitor, traverse_list
import codecs
import logging
from attrib_convert import AttribMapBuilder, Conversion

logger = logging.getLogger(__name__)

def load_resource (template_dir, name):
    instream=codecs.open(template_dir + name, 'r', 'utf-8')
    resource = instream.read()
    instream.close ()
    return resource

class FmtTemplate:
    def __init__(self, data):
        
        self.attrib_map_builder = AttribMapBuilder ()
        for attrib in data['attributes'].keys():
            attrib_cfg = data['attributes'][attrib]
            evaluate = None
            if 'eval' in attrib_cfg:
                evaluate = attrib_cfg['eval']
            conversion = Conversion (attrib, attrib_cfg['default'], attrib_cfg['format'], attrib_cfg['type'], evaluate=evaluate)
            self.attrib_map_builder.set_conversion(conversion)
        self.attrib_map_builder.date_format = data['dateFormat']
        
        self.preamble = None
        self.postamble = None
        self.indent_start = data['indent']
        self.depth_start = data['depth']
        self.indent = data['indentString']
        self.nodes = {k:Template(v) for (k,v) in data['nodes'].items()}
        self.date_format = data['dateFormat']
        template_dir = os.environ['OFEXPORT_HOME'] + '/templates/'
        if 'preambleFile' in data:
            self.preamble = load_resource (template_dir, data['preambleFile'])
        elif 'preamble' in data:
            self.preamble = data['preamble']
        if 'postambleFile' in data:
            self.postamble = load_resource (template_dir, data['postambleFile'])
        elif 'postamble' in data:
            self.postamble = data['postamble']
        
class Formatter(Visitor):
    def __init__ (self, out, template):
        self.template = template
        self.depth = self.template.indent_start
        self.traversal_depth = self.template.depth_start
        self.out = out
    def begin_folder (self, folder):
        self.update_attribs(folder, 'folder')
        line = format_item (self.template, 'FolderStart', folder.attribs['attrib_cache'])
        if line != None:
            print >>self.out, line
        self.depth+=1
        self.traversal_depth+=1
    def end_folder (self, folder):
        self.depth-=1
        self.traversal_depth-=1
        self.update_attribs(folder, 'folder')
        line = format_item (self.template, 'FolderEnd', folder.attribs['attrib_cache'])
        if line != None:
            print >>self.out, line
    def begin_project (self, project):
        self.update_attribs(project, 'task')
        line = format_item (self.template, 'ProjectStart', project.attribs['attrib_cache'])
        if line != None:
            print >>self.out, line
            self.handle_note (project)
        self.depth+=1
        self.traversal_depth+=1
    def end_project (self, project):
        self.depth-=1
        self.traversal_depth-=1
        self.update_attribs(project, 'task')
        line = format_item (self.template, 'ProjectEnd', project.attribs['attrib_cache'])
        if line != None:
            print >>self.out, line
    def begin_task (self, task):
        self.update_attribs(task, 'task')
        if self.is_empty (task) or self.project_mode == False:
            line = format_item (self.template, 'TaskStart', task.attribs['attrib_cache'])
            if line != None:
                print >>self.out, line
                self.handle_note (task)
        else:
            line = format_item (self.template, 'TaskGroupStart', task.attribs['attrib_cache'])
            if line != None:
                print >>self.out, line
                self.handle_note (task)
        self.depth+=1
        self.traversal_depth+=1
    def end_task (self, task):
        self.depth-=1
        self.traversal_depth-=1
        self.update_attribs(task, 'task')
        if self.is_empty (task) or self.project_mode == False:
            line = format_item (self.template, 'TaskEnd', task.attribs['attrib_cache'])
            if line != None:
                print >>self.out, line
        else:
            line = format_item (self.template, 'TaskGroupEnd', task.attribs['attrib_cache'])
            if line != None:
                print >>self.out, line
    def begin_context (self, context):
        self.update_attribs(context, 'context')
        line = format_item (self.template, 'ContextStart', context.attribs['attrib_cache'])
        if line != None:
            print >>self.out, line
        self.depth+=1
        self.traversal_depth+=1
    def end_context (self, context):
        self.depth-=1
        self.traversal_depth-=1
        self.update_attribs(context, 'context')
        line = format_item (self.template, 'ContextEnd', context.attribs['attrib_cache'])
        if line != None:
            print >>self.out, line
    def end_any (self, item):
        del item.attribs['attrib_cache']
    def is_empty (self, item):
        return len ([x for x in item.children if x.marked]) == 0
    def handle_note (self, item):
        if item.note != None and 'NoteLine' in self.template.nodes:
            for line in item.note.get_note_lines ():
                item.attribs['attrib_cache']['note_line'] = line
                print >>self.out, format_item (self.template, 'NoteLine', item.attribs['attrib_cache'])
    def update_attribs (self, item, link_type):
        if not 'attrib_cache' in item.attribs:
            attribs = self.template.attrib_map_builder.get_values (item)
            item.attribs['attrib_cache'] = attribs
            attribs['depth'] = str (self.traversal_depth)
            attribs['indent'] = self.template.indent * (self.depth)
            self.add_extra_template_attribs(item, attribs)
    def add_extra_template_attribs (self, item, attribs):
        pass

def build_entry (line_template, attributes):
    return line_template.safe_substitute(attributes)

def format_item (template, node_type, attributes):
    if node_type in template.nodes:
        return build_entry (template.nodes[node_type], attributes)
    return None

def format_document (root, formatter, project_mode):
    if formatter.template.preamble != None:
        print >>formatter.out, formatter.template.preamble
    traverse_list (formatter, root.children, project_mode=project_mode)
    if formatter.template.postamble != None:
        print >>formatter.out, formatter.template.postamble

########NEW FILE########
__FILENAME__ = help
# THIS FILE IS AUTOGENERATED

def print_help ():
    print 'Version: 3.0.5 2014-02-23'
    print
    print 'Usage:'
    print
    print 'ofexport [options...] -o file_name'
    print
    print 'options:'
    print '  -h,-?,--help       : print help'
    print '  -C                 : context mode (as opposed to project mode)'
    print '  -P                 : project mode - the default (as opposed to context mode)'
    print '  -I                 : include mode (as opposed to exclude mode)'
    print '  -E                 : exclude mode - the default (as opposed to include mode)'
    print '  -o file_name       : the output file name, must end in a recognised suffix - see documentation'
    print '  -i file_name       : read file_name instead of the OmniFocus database, must be in json format'
    print '  -T template_name   : use the specified template instead of one derived from the output file extension'
    print '  --open             : open the output file with the registered application (if one is installed)'
    print '  -v                 : verbose output'
    print '  -z                 : maximum diagnostics'
    print '  -V level           : set the global log level (ERROR, INFO, DEBUG, TRACE)'
    print '  --log name=level   : set a logger to a particular level'
    print '  --debug arg        : set test options'
    print
    print 'filters:'
    print '  -a,--any expr        : filter tasks, projects, contexts and folders against the expression'
    print '  -t,--task expr       : filter any task against task against the expression'
    print '  -p,--project expr    : filter any project against the expression'
    print '  -f,--folder expr     : filter any folder against the expression'
    print '  -c,--context expr    : filter any context type against the expression'
    print '  --tasks              : filter out everything except tasks'
    print
    print '  See DOCUMENTATION.md for more information'

SHORT_OPTS = 'h?CPIEo:i:T:vzV:a:t:p:f:c:'
LONG_OPTS = ['help','open','log=','debug=','any=','task=','project=','folder=','context=','tasks']

########NEW FILE########
__FILENAME__ = ofexport
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import os
import codecs
import getopt
import sys
import json
from treemodel import traverse, Visitor, FOLDER, CONTEXT, PROJECT, TASK
from omnifocus import build_model, find_database
from datetime import date, datetime
from plugin_json import read_json
from help import print_help, SHORT_OPTS, LONG_OPTS
from fmt_template import FmtTemplate
from cmd_parser import make_filter
import logging
import cmd_parser
from visitors import Tasks

logging.basicConfig(format='%(asctime)-15s %(name)s %(levelname)s %(message)s', stream=sys.stdout)
logger = logging.getLogger(__name__)
logger.setLevel(level=logging.ERROR)

LOGGER_NAMES = [
                __name__,
                'cmd_parser',
                'visitors',
                'datematch',
                'treemodel',
                'omnifocus',
                'fmt_template',
                'plugin_ics']

class SummaryVisitor (Visitor):
    def __init__ (self):
        self.counts = {}
    def end_any (self, item):
        if not 'counted' in item.attribs:
            item.attribs['counted'] = True
            if item.type in self.counts:
                self.counts[item.type] = self.counts[item.type] + 1
            else:
                self.counts[item.type] = 1
    def print_counts (self):
        # Subtract for the extra invisible roots that we've added.
        if CONTEXT in self.counts:
            self.counts[CONTEXT] = self.counts[CONTEXT]-1
        if FOLDER in self.counts:
            self.counts[FOLDER] = self.counts[FOLDER]-1
        
        logger.info ('Report Contents:')
        logger.info ('----------------')
        for k,v in [(k,self.counts[k]) for k in sorted(self.counts.keys())]:
            k = ' ' * (8 - len(k)) + k + 's:'
            logger.info (k + ' ' + str(v))
        logger.info ('----------------')

def load_config (home_dir):
    logger.info ('loading config')
    instream=codecs.open(home_dir + '/ofexport.json', 'r', 'utf-8')
    config = json.loads(instream.read())
    instream.close ()
    return config

def load_template (template_dir, name):
    logger.info ('loading template: %s', name)
    instream=codecs.open(template_dir + '/' + name + '.json', 'r', 'utf-8')
    template = FmtTemplate (json.loads(instream.read()))
    instream.close ()
    return template

def fix_abbrieviated_expr (typ, arg):
    if arg.startswith ('=') or arg.startswith ('!='):
        if typ == 'any' or typ == 'all':
            result = 'name' + arg + ''
        else:
            result = '(type=' + typ + ') and (name' + arg + ')'
    elif arg in ['prune', 'flatten']:
        result = arg + ' ' + typ
    elif arg.startswith ('sort'):
        if arg == 'sort':
            result = arg + ' ' + typ + ' text'
        else:
            bits = arg.split ()
            assert len (bits) == 2, 'sort can have one field type argument'
            result = 'sort' + ' ' + typ + ' ' + bits[1]
    else:
        if typ == 'any' or typ == 'all':
            result = arg
        else:
            result = '(type=' + typ + ') and (' + arg + ')'
    logger.debug ("adapted argument: '%s'", result)
    return result

def set_debug_opt (name, value):
    if name== 'now' : 
        the_time = datetime.strptime (value, "%Y-%m-%d")
        cmd_parser.the_time = the_time
 
if __name__ == "__main__":
    sys.stdout = codecs.getwriter('utf8')(sys.stdout)
    
    today = date.today ()
    time_fmt='%Y-%m-%d'
    opn=False
    project_mode=True
    file_name = None
    infile = None
    home_dir = os.environ['OFEXPORT_HOME']
    template_dir = home_dir + '/templates'
    include = True
    
    type_config_override_data = {}
    
    config = load_config (home_dir)
    
    opts, args = getopt.optlist, args = getopt.getopt(sys.argv[1:],SHORT_OPTS, LONG_OPTS)
    
    assert len (args) == 0, "unexpected arguments: " + str (args)
        
    for opt, arg in opts:
        if '--open' == opt:
            opn = True
        elif '-o' == opt:
            file_name = arg
        elif '-i' == opt:
            infile = arg
        elif '-T' == opt:
            type_config_override_data['template'] = arg
        elif '-v' == opt:
            for logname in LOGGER_NAMES:
                logging.getLogger(logname).setLevel (logging.INFO)
        elif '-V' == opt:
            level = arg
            for logname in LOGGER_NAMES:
                logging.getLogger(logname).setLevel (logging.__dict__[arg])
        elif '-z' == opt:
            for logname in LOGGER_NAMES:
                logging.getLogger(logname).setLevel (logging.DEBUG)
        elif '--log' == opt:
            bits = arg.split('=')
            assert len(bits) == 2
            name = bits[0]
            level = bits[1]
            if name=='ofexport':
                name = __name__
            logging.getLogger(name).setLevel (logging.__dict__[level])
        elif '--debug' == opt:
            bits = arg.split('=')
            assert len(bits) == 2
            name = bits[0]
            value = bits[1]
            set_debug_opt (name, value)
        elif opt in ('-?', '-h', '--help'):
            print_help ()
            sys.exit()
    
    if file_name == None:
        # This blank suffix is mapped to a plugin/template in the config
        fmt = ''
    else:
        assert file_name.find ('.') != -1, "filename has no suffix"
        dot = file_name.index ('.')
        fmt = file_name[dot+1:]
    
    if infile != None:
        root_project, root_context = read_json (infile)
    else:    
        root_project, root_context = build_model (find_database (config['db_search_path']))
    
    subject = root_project
        
    for opt, arg in opts:
        logger.debug ("executing option %s : %s", opt, arg)
        visitor = None
        if opt in ('--project', '-p'):
            fixed_arg = fix_abbrieviated_expr(PROJECT, arg)
            visitor = make_filter (fixed_arg, include)
        elif opt in ('--task', '-t'):
            fixed_arg = fix_abbrieviated_expr(TASK, arg)
            visitor = make_filter (fixed_arg, include)
        elif opt in ('--context', '-c'):
            fixed_arg = fix_abbrieviated_expr(CONTEXT, arg)
            visitor = make_filter (fixed_arg, include)
        elif opt in ('--folder', '-f'):
            fixed_arg = fix_abbrieviated_expr(FOLDER, arg)
            visitor = make_filter (fixed_arg, include)
        elif opt in ('--any', '-a'):
            visitor = make_filter (fix_abbrieviated_expr('any', arg), include)
        elif opt in ('--tasks'):
            visitor = Tasks (root_project, root_context)
        elif '-C' == opt:
            logger.info ('context mode')
            project_mode = False
            subject = root_context
        elif '-P' == opt:
            logger.info ('project mode')
            project_mode = True
            subject = root_project
        elif '-I' == opt:
            logger.info ('include mode')
            include = True
        elif '-E' == opt:
            include = False
            logger.info ('exclude mode')
        
        logger.debug ("created filter %s", visitor)
        if visitor != None:
            logger.info ('running filter %s', visitor)
            traverse (visitor, subject, project_mode=project_mode)
            
    logger.info ('Generating: %s', file_name)
    
    if file_name != None:
        out=codecs.open(file_name, 'w', 'utf-8')
    else: 
        out = sys.stdout
    
    generated = False
    file_types = config['file_types']
    for type_config in file_types.values():
        if not generated and fmt in type_config['suffixes']:
            plugin = 'plugin_' + type_config['plugin']
            m = __import__(plugin)
            type_config.update (type_config_override_data)
            m.generate(out, root_project, root_context, project_mode, template_dir, type_config)
            generated = True
    
    if not generated:
        raise Exception ('unknown format ' + fmt)
    
    if file_name != None:
        out.close()
        if opn:
            os.system("open '" + file_name + "'")
        
    visitor = SummaryVisitor ()
    traverse (visitor, root_project, project_mode=True)
    traverse (visitor, root_context, project_mode=False)
    visitor.print_counts()

########NEW FILE########
__FILENAME__ = omnifocus
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

from treemodel import PROJECT, Project, Node, Task, Context, Folder, Note, sort
import sqlite3
from os import environ, path
from datetime import datetime
from typeof import TypeOf
from xml.dom.minidom import parseString
import logging

logger = logging.getLogger(__name__)

'''
A library for loading a data model from the Omnifocus SQLite database.

---------
Notes on discovering what the Omni schema looks like

sqlite3 ~/Library/Caches/com.omnigroup.OmniFocus/OmniFocusDatabase2

.tables
Attachment   Folder       Perspective  Setting    
Context      ODOMetadata  ProjectInfo  Task       

sqlite> .schema Task
CREATE TABLE Task (persistentIdentifier text NOT NULL PRIMARY KEY, blocked integer NOT NULL, blockedByFutureStartDate integer NOT NULL, 
childrenCount integer NOT NULL, childrenCountAvailable integer NOT NULL, childrenCountCompleted integer NOT NULL, completeWhenChildrenComplete integer NOT NULL,
containingProjectContainsSingletons integer NOT NULL, containingProjectInfo text, containsNextTask integer NOT NULL, context text, creationOrdinal integer,
dateAdded timestamp NOT NULL, dateCompleted timestamp, dateDue timestamp, dateModified timestamp NOT NULL, dateToStart timestamp, effectiveContainingProjectInfoActive integer NOT NULL,
effectiveContainingProjectInfoRemaining integer NOT NULL, effectiveDateDue timestamp, effectiveDateToStart timestamp, effectiveFlagged integer NOT NULL,
effectiveInInbox integer NOT NULL, estimatedMinutes integer, flagged integer NOT NULL, hasCompletedDescendant integer NOT NULL, hasFlaggedTaskInTree integer NOT NULL,
hasUnestimatedLeafTaskInTree integer NOT NULL, inInbox integer NOT NULL, isDueSoon integer NOT NULL, isOverdue integer NOT NULL, maximumEstimateInTree integer,
minimumEstimateInTree integer, name text, nextTaskOfProjectInfo text, noteXMLData blob, parent text, projectInfo text, rank integer NOT NULL, repetitionMethodString text,
repetitionRuleString text, sequential integer NOT NULL);
CREATE INDEX Task_containingProjectInfo on Task (containingProjectInfo);
CREATE INDEX Task_context on Task (context);
CREATE INDEX Task_nextTaskOfProjectInfo on Task (nextTaskOfProjectInfo);
CREATE INDEX Task_parent on Task (parent);
CREATE INDEX Task_projectInfo on Task (projectInfo);

.schema ProjectInfo
CREATE TABLE ProjectInfo (pk text NOT NULL PRIMARY KEY, containsSingletonActions integer NOT NULL, folder text, folderEffectiveActive integer NOT NULL,
lastReviewDate timestamp, minimumDueDate timestamp, nextReviewDate timestamp, nextTask text, numberOfAvailableTasks integer NOT NULL, numberOfDueSoonTasks integer NOT NULL,
numberOfOverdueTasks integer NOT NULL, numberOfRemainingTasks integer NOT NULL, reviewRepetitionString text, status text NOT NULL, task text, taskBlocked integer NOT NULL,
taskBlockedByFutureStartDate integer NOT NULL, taskDateToStart timestamp);
CREATE INDEX ProjectInfo_folder on ProjectInfo (folder);
CREATE INDEX ProjectInfo_nextTask on ProjectInfo (nextTask);
CREATE INDEX ProjectInfo_task on ProjectInfo (task);


sqlite> .schema Folder
CREATE TABLE Folder (persistentIdentifier text NOT NULL PRIMARY KEY, active integer NOT NULL, childrenCount integer NOT NULL, creationOrdinal integer,
dateAdded timestamp NOT NULL, dateModified timestamp NOT NULL, effectiveActive integer NOT NULL, name text, noteXMLData blob, numberOfAvailableTasks integer NOT NULL,
numberOfDueSoonTasks integer NOT NULL, numberOfOverdueTasks integer NOT NULL, parent text, rank integer NOT NULL);
CREATE INDEX Folder_parent on Folder (parent);


.schema Context
CREATE TABLE Context (persistentIdentifier text NOT NULL PRIMARY KEY, active integer NOT NULL, allowsNextAction integer NOT NULL, altitude real,
availableTaskCount integer NOT NULL, childrenCount integer NOT NULL, creationOrdinal integer, dateAdded timestamp NOT NULL, dateModified timestamp NOT NULL,
effectiveActive integer NOT NULL, latitude real, localNumberOfDueSoonTasks integer NOT NULL, localNumberOfOverdueTasks integer NOT NULL, locationName text,
longitude real, name text, noteXMLData blob, notificationFlags integer, parent text, radius real, rank integer NOT NULL, remainingTaskCount integer NOT NULL,
totalNumberOfDueSoonTasks integer NOT NULL, totalNumberOfOverdueTasks integer NOT NULL);
CREATE INDEX Context_parent on Context (parent);

.schema Perspective (no name!!!)

CREATE TABLE Perspective (persistentIdentifier text NOT NULL PRIMARY KEY, creationOrdinal integer, dateAdded timestamp NOT NULL, dateModified timestamp NOT NULL, valueData blob);
'''

THIRTY_ONE_YEARS = 60 * 60 * 24 * 365 * 31 + 60 * 60 * 24 * 8

class OFNote (Note):
    def __init__ (self, item, noteXMLData):
        self.noteXMLData = noteXMLData
        self.item = item
        self.text = None
        self.lines = None
    def get_note_lines (self):
        if self.lines == None:
            # Currently getting this on demand because formatting it
            # for the whole DB is sloooooow
            logger.debug ('%s note: parsing xml', self.item.id)
            dom = parseString(self.noteXMLData)
            logger.debug ('%s note: collating lines', self.item.id)
            #print dom.toprettyxml ()
            self.lines = []
            for para in  dom.getElementsByTagName("p"):
                line = []
                for lit in  para.getElementsByTagName("lit"):
                    if lit.firstChild != None:
                        nodeValue = lit.firstChild.nodeValue
                        if nodeValue != None:
                            text = self.fix_dodgy_chars(nodeValue)
                            line.append(text)
                self.lines.append (u''.join(line))
            logger.debug ('%s note: processed', self.item.id)
        return self.lines
    def get_note (self):
        if self.text == None:
            self.text = '\n'.join (self.get_note_lines())
        return self.text
    def fix_dodgy_chars (self, text):
        try:
            return unicode (text)
        except:
            buf = []
            for c in text:
                try:
                    buf.append(unicode(c))
                except:
                    buf.append('?')
            return u''.join(buf)

def datetimeFromAttrib (ofattribs, name):
    val = ofattribs[name]
    if val == None:
        return None
    return datetime.fromtimestamp(THIRTY_ONE_YEARS + val)

def intFromAttrib (ofattribs, name):
    val = ofattribs[name]
    if val == None:
        return None
    return val
    
class OFContext(Context):
    TABLE='context'
    COLUMNS=['persistentIdentifier', 'name', 'parent', 'childrenCount', 'rank', 'allowsNextAction']
    ofattribs = TypeOf ('ofattribs', dict)
    def __init__(self, ofattribs):
        Context.__init__(self,
                         name=ofattribs['name'])
        self.ofattribs = ofattribs
        self.order = ofattribs['rank']
        if 'persistentIdentifier' in ofattribs:
            self.id = ofattribs['persistentIdentifier']
            self.link = 'omnifocus:///context/' + ofattribs['persistentIdentifier']
        self.status = u'inactive' if 'allowsNextAction' in ofattribs and ofattribs['allowsNextAction'] == 0 else u'active'
        logger.debug ('loaded context: %s %s', self.id, self.name)

class OFTask(Task):
    TABLE='task'
    COLUMNS=['persistentIdentifier', 'name', 'inInbox', 'dateDue', 'dateCompleted', 'dateToStart', 'dateDue', 'dateAdded', 'estimatedMinutes',
             'projectInfo', 'context', 'containingProjectInfo', 'childrenCount', 'parent', 'rank',
             'flagged', 'noteXMLData']    
    ofattribs = TypeOf ('ofattribs', dict)
    def __init__(self, ofattribs):
        Task.__init__(self,
                      name=ofattribs['name'],
                      date_completed = datetimeFromAttrib (ofattribs,'dateCompleted'),
                      date_to_start = datetimeFromAttrib (ofattribs,'dateToStart'),
                      date_due = datetimeFromAttrib (ofattribs,'dateDue'),
                      date_added = datetimeFromAttrib (ofattribs,'dateAdded'),
                      estimated_minutes = intFromAttrib (ofattribs,'estimatedMinutes'),
                      flagged = bool (ofattribs['flagged']),
                      context=None)
        self.ofattribs = ofattribs
        self.order = ofattribs['rank']
        if 'persistentIdentifier' in ofattribs:
            self.id = ofattribs['persistentIdentifier']
            self.link = 'omnifocus:///task/' + ofattribs['persistentIdentifier']
        noteXMLData = ofattribs['noteXMLData']
        if noteXMLData != None:
            self.note = OFNote (self, noteXMLData)
        logger.debug ('loaded task: %s %s', self.id, self.name)
    
class OFFolder(Folder):
    TABLE='folder'
    COLUMNS=['persistentIdentifier', 'name', 'childrenCount', 'parent', 'rank', 'noteXMLData']
    ofattribs = TypeOf ('ofattribs', dict)
    def __init__(self, ofattribs):
        Folder.__init__(self,
                        name=ofattribs['name'])
        self.ofattribs = ofattribs
        self.order = ofattribs['rank']
        if 'persistentIdentifier' in ofattribs:
            self.id = ofattribs['persistentIdentifier']
            self.link = 'omnifocus:///folder/' + ofattribs['persistentIdentifier']
        logger.debug ('loaded folder: %s %s', self.id, self.name)
        
class ProjectInfo(Node):
    TABLE='projectinfo'
    COLUMNS=['pk', 'folder', 'status', 'nextTask']
    status = TypeOf ('status', unicode)
    nextTask = TypeOf ('nextTask', str)
    def __init__(self, ofattribs):
        Node.__init__(self,"ProjectInfo")
        self.ofattribs = ofattribs
        self.status = ofattribs['status']
        self.next_task = None if ofattribs['nextTask'] == None else str(ofattribs['nextTask'])

class OFProject(Project):
    ofattribs = TypeOf ('ofattribs', dict)
    folder = TypeOf ('folder', Folder)
    project_info = TypeOf ('project_info', ProjectInfo)
    def __init__(self):
        # UNUSUAL - don't call super constructor
        # We convert these from tasks rather than construct them
        pass

def query (conn, clazz):
    c = conn.cursor()
    columns = clazz.COLUMNS
    results = {}
    for row in c.execute('SELECT ' + (','.join(columns)) + ' from ' + clazz.TABLE):
        rowData = {}
        for i in range(0,len(columns)):
            key = columns[i]
            val = row[i]
            rowData[key] = val
        node = clazz (rowData)
        results[rowData[columns[0]]] = node
    c.close()
    return results

def transmute_projects (project_infos, tasks):
    '''
    Some tasks are actually projects, convert them
    '''
    logger.debug ('transmuting projects')
    projects = {}
    for project in tasks.values():        
        if project.ofattribs['projectInfo'] != None:
            logger.debug ('transmuting: %s %s', project.id, project.name)
            projects[project.ofattribs['persistentIdentifier']] = project
            project_info = project_infos[project.ofattribs['projectInfo']]
            project.__class__ = OFProject
            project.__init__()
            project_info.project = project
            project.type = PROJECT
            project.project_info = project_info
            project.status = project_info.status
    return projects

def wire_projects_and_folders (projects, folders, tasks):
    logger.debug ('wiring projects and folders')
    for project in projects.values():
        project_info = project.project_info
        if project.project_info != None:
            folder_ref = project_info.ofattribs['folder']
            if folder_ref != None:
                logger.debug ('wiring: %s %s', project.id, project.name)
                folder = folders[folder_ref]
                project.folder = folder
                folder.add_child (project)    
        if project_info.next_task != None:
            task = tasks[project_info.next_task]
            task.next = True

def wire_task_hierarchy (tasks):
    logger.debug ('wiring type hierarchy')
    for task in tasks.values():  
        if task.ofattribs['parent'] != None:
            logger.debug ('wiring: %s %s', task.id, task.name)
            parent = tasks[task.ofattribs['parent']]
            parent.add_child (task)
            
def wire_tasks_to_enclosing_projects (project_infos, tasks, inbox):
    logger.debug ('wiring tasks to enclosing projects')
    for task in tasks.values():  
        if task.ofattribs['containingProjectInfo'] != None:
            logger.debug ('wiring: %s %s', task.id, task.name)
            project_info = project_infos[task.ofattribs['containingProjectInfo']]
            project = project_info.project
            task.project = project
        elif task.ofattribs['inInbox']:
            inbox.add_child (task)
            
       
def wire_tasks_and_contexts (contexts, tasks, no_context):
    logger.debug ('wiring tasks and contexts')
    for task in tasks.values():
        logger.debug ('wiring: %s %s', task.id, task.name)
        if task.ofattribs['context'] != None:
            context = contexts[task.ofattribs['context']]
            task.context = context
            context.children.append(task)
        else:
            task.context = no_context
            no_context.children.append(task)
            
def wire_folder_hierarchy (folders):
    logger.debug ('wiring folder hierarchy')
    for folder in folders.values():
        if folder.ofattribs['parent'] != None:
            logger.debug ('wiring: %s %s', folder.id, folder.name)
            parent = folders[folder.ofattribs['parent']]
            parent.add_child (folder)
                
def wire_context_hierarchy (contexts):
    logger.debug ('wiring context hierarchy')
    for context in contexts.values():
        if context.ofattribs['parent'] != None:
            logger.debug ('wiring: %s %s', context.id, context.name)
            parent = contexts[context.ofattribs['parent']]
            parent.add_child (context)

def only_roots (items):
    roots = []
    for item in items:
        if item.parent == None:
            roots.append(item)
    return roots

def build_model (db):
    conn = sqlite3.connect(db)
    contexts = query (conn, clazz=OFContext)
    no_context = Context(name = 'No Context')
    inbox = Project (name='Inbox')
    project_infos = query (conn, clazz=ProjectInfo)
    folders = query (conn, clazz=OFFolder)
    tasks = query (conn, clazz=OFTask)
    
    projects = transmute_projects (project_infos, tasks)
    wire_projects_and_folders(projects, folders, tasks)
    wire_task_hierarchy(tasks)
    wire_tasks_to_enclosing_projects (project_infos, tasks, inbox)
    wire_tasks_and_contexts(contexts, tasks, no_context)
    wire_folder_hierarchy (folders)
    wire_context_hierarchy (contexts)
    
    conn.close ()
    
    # Find top level items
    project_roots = only_roots (projects.values())
    folder_roots = only_roots (folders.values())
    root_projects_and_folders = project_roots + folder_roots
    root_contexts = only_roots (contexts.values())
    root_contexts.insert(0, no_context)
    root_projects_and_folders.insert(0, inbox)
    sort(root_projects_and_folders)
    sort(root_contexts)
    
    root_folder = Folder (name='')
    for child in root_projects_and_folders:
        root_folder.add_child(child)
        
    root_context = Context (name='', status='active')
    for child in root_contexts:
        root_context.add_child(child)
        
    return root_folder, root_context
        
def find_database (databases):
    home = environ['HOME']
    databases = [home + x for x in databases]
    for db in databases:
        logger.debug ("testing for db %s", db)
        if (path.exists (db)):
            logger.info ("found db %s", db)
            return db
    raise IOError ('cannot find OmnifocusDatabase in ' + databases)

########NEW FILE########
__FILENAME__ = plugin_html
from fmt_template import Formatter, format_document
from ofexport import load_template

def escape (val):
    return val.replace('"','&quot;').replace('&','&amp;').replace('<','&lt;').replace('>','&gt;')

def generate (out, root_project, root_context, project_mode, template_dir, type_config):
    subject = root_project if project_mode else root_context
    template = load_template (template_dir, type_config['template'])
    
    template.attrib_map_builder.type_fns['html.string'] = lambda x:  escape (x)
    template.attrib_map_builder.type_fns['html.note'] = lambda x: ''.join([line+'<br>' for line in x.get_note_lines ()])

    visitor = Formatter (out, template)
    format_document (subject, visitor, project_mode)
########NEW FILE########
__FILENAME__ = plugin_ics
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

from datetime import datetime, timedelta
from fmt_template import Formatter, format_document
import time
import logging
from ofexport import load_template


logger = logging.getLogger(__name__)

DATE_FORMAT_LONG = "%Y%m%dT%H%M00Z"
DATE_FORMAT_SHORT = "%Y%m%d"

def generate (out, root_project, root_context, project_mode, template_dir, type_config):
    subject = root_project if project_mode else root_context
    template = load_template (template_dir, type_config['template'])
    time_control_default = type_config["time_control_default"]
    logger.debug ("time_control_default: %s", time_control_default)
    visitor = PrintCalendarVisitor (out, template, time_control_default)
    format_document (subject, visitor, project_mode)

class PrintCalendarVisitor(Formatter):
    def __init__ (self, out, template, time_control_default):
        Formatter.__init__(self, out, template)
        self.current_item = None
        self.time_control_default = time_control_default

        # Start and due dates are formated differently for all day tasks, need different types
        template.attrib_map_builder.type_fns['ics.date_due'] = lambda x: format_date(self.current_item, x, True)
        template.attrib_map_builder.type_fns['ics.date_to_start'] = lambda x: format_date(self.current_item, x, False)
        template.attrib_map_builder.type_fns['ics.note'] = lambda x: '\\r'.join(x.get_note_lines ())
         
    def begin_any (self, item):
        Formatter.begin_any(self, item)
        self.current_item = item
    def end_any (self, item):
        pass
    def begin_folder (self, folder):
        pass
    def end_folder (self, folder):
        pass
    def begin_project (self, project):
        if project.date_due != None or project.date_to_start != None:
            fix_dates(project)
            load_note_attribs (project, self.time_control_default)
            Formatter.begin_project(self, project)
    def end_project (self, project):
        if project.date_due != None or project.date_to_start != None:
            Formatter.end_project(self, project)
    def begin_task (self, task):
        if task.date_due != None or task.date_to_start != None:
            fix_dates(task)
            load_note_attribs (task, self.time_control_default)
            Formatter.begin_task(self, task)
    def end_task (self, task):
        if task.date_due != None or task.date_to_start != None:
            Formatter.end_task(self, task)
    def begin_context (self, context):
        pass
    def end_context (self, context):
        pass
    def add_extra_template_attribs (self, item, attribs):
        item.attribs['attrib_cache']['alarm'] = format_alarm (item)
    
def fix_dates (item):
    if item.date_to_start == None and item.date_due == None:
        return
    if item.date_to_start == None and item.date_due != None:
        item.date_to_start = item.date_due
    elif item.date_to_start != None and item.date_due == None:
        item.date_due = item.date_to_start

def load_note_attribs (item, time_control_default):
    logger.debug ("loading note attributes %s %s", item.id, item.name)
    found_directive = False
    if item.note != None:
        for line in item.note.get_note_lines ():
            found_directive = process_line_for_directives (item, line, found_directive)
    if not found_directive and len (time_control_default.strip()) > 0:
        found_directive = process_line_for_directives (item, time_control_default, found_directive)
    
    if found_directive:
        logger.debug ("attributes for %s are %s", item.id, item.attribs)
        
        if 'onstart' in item.attribs:
            item.date_due = item.date_to_start
        if 'ondue' in item.attribs:
            item.date_to_start = item.date_due
        try:
            if 'start' in item.attribs:
                bits = item.attribs['start'].split(':')
                the_date = item.date_to_start
                if len(bits) == 2:
                    item.date_to_start = datetime (the_date.year, the_date.month, the_date.day, int(bits[0]), int(bits[1]), 0, 0, the_date.tzinfo)
                else:
                    logger.error ("problem parsing cal directives, start malformed: %s %s", item.id, item.name)
            if 'due' in item.attribs:
                bits = item.attribs['due'].split(':')
                the_date = item.date_due
                if len(bits) == 2:
                    item.date_due = datetime (the_date.year, the_date.month, the_date.day, int(bits[0]), int(bits[1]), 0, 0, the_date.tzinfo)
                else:
                    logger.error ("problem parsing cal directives, due malformed: %s %s", item.id, item.name)
        except Exception as e:
            logger.error (e.message)
            logger.error ("problem parsing cal directives: %s %s", item.id, item.name)
        if item.date_to_start > item.date_due:
            logger.error ("problem parsing cal directives, the start date is after the due date: %s %s", item.id, item.name)
            item.date_to_start = item.date_due
        logger.debug ("final dates for %s are start:%s due:%s", item.id, item.date_to_start, item.date_due)

def process_line_for_directives (item, line, found_directive):
    if line.strip().startswith('%of'):
        bits = line.split()
        if len(bits) >= 3 and bits[1] == 'cal':
            found_directive = True
            logger.debug ("found directive in %s %s", item.id, line)
            for flag in bits[2:]:
                bits2 = flag.split('=')
                if len(bits2) == 2:
                    item.attribs[bits2[0]] = bits2[1]
                else:
                    item.attribs[flag] = True
    return found_directive
    
def format_date (item, the_date, is_due_date):
    if 'allday' in item.attribs:
        # Make all day - must have no hms in format
        #DTSTART;VALUE=DATE:20020923
        #DTEND;VALUE=DATE:20020924
        the_date = datetime (the_date.year, the_date.month, the_date.day, 0, 0, 0)
        if is_due_date:
            the_date = the_date + timedelta (days=1)
        # NO UTC CONVERSION - it happens on the day we asked for - no adjustment required
        result = the_date.strftime(DATE_FORMAT_SHORT) 
    else:
        the_date = utc (the_date)   
        result = the_date.strftime(DATE_FORMAT_LONG)
    typ = 'due' if is_due_date else 'start'
    logger.debug ("formatted date for %s is %s:%s", item.id, typ, result)
    return result

def utc (the_date):
    epoch_second = time.mktime(the_date.timetuple())
    return datetime.utcfromtimestamp(epoch_second)

def format_alarm (item):
    if "noalarm" in item.attribs:
        return ""
    return "BEGIN:VALARM\nACTION:DISPLAY\nDESCRIPTION:OmniFocus Reminder\nTRIGGER:-PT0M\nEND:VALARM\n"
########NEW FILE########
__FILENAME__ = plugin_json
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import json
import codecs
from datetime import datetime
from treemodel import Context, Project, Task, Folder, Note, CONTEXT, PROJECT, TASK, FOLDER
from treemodel import traverse, Visitor

TIME_FMT = "%Y-%m-%d %H:%M:%S"

def generate (out, root_project, root_context, project_mode, template_dir, type_config):
    # json has intrinsic formatting - no template required
    root_project.marked = True
    root_context.marked = True
    visitor = ConvertStructureToJsonVisitor ()
    traverse (visitor, root_project, project_mode=True)
    visitor = ConvertStructureToJsonVisitor ()
    traverse (visitor, root_context, project_mode=False)
    print >> out, json.dumps([root_project.attribs['json_data'], root_context.attribs['json_data']], sort_keys=True, indent=2)

def save_attrib (item, attrib, attribs, convert):
    if not attrib in item.__dict__:
        return
    value = item.__dict__[attrib]
    if value == None:
        return
    attribs[attrib] = convert (value)

def load_attrib (item, attrib, attribs, convert):
    if not attrib in attribs:
        return
    value = attribs[attrib]
    item.__dict__[attrib] = convert (value)

def get_note_lines (x):
    if x == None:
        return None
    return x.get_note_lines()

class ConvertStructureToJsonVisitor(Visitor):
    def begin_any (self, item):
        if self.is_in_applicable_mode (item) and not 'json_data' in item.attribs:
            node_json_data =  {}
            save_attrib (item, 'id', node_json_data, lambda x : x)
            save_attrib (item, 'link', node_json_data, lambda x : x)
            save_attrib (item, 'status', node_json_data, lambda x : x)
            save_attrib (item, 'name', node_json_data, lambda x : x)
            save_attrib (item, 'type', node_json_data, lambda x : x)
            save_attrib (item, 'date_completed', node_json_data, lambda x: x.strftime (TIME_FMT))
            save_attrib (item, 'date_to_start', node_json_data, lambda x: x.strftime (TIME_FMT))
            save_attrib (item, 'date_due', node_json_data, lambda x: x.strftime (TIME_FMT))
            save_attrib (item, 'flagged', node_json_data, lambda x : x)
            save_attrib (item, 'next', node_json_data, lambda x : x)
            save_attrib (item, 'note', node_json_data, lambda x : get_note_lines (x))
            save_attrib (item, 'order', node_json_data, lambda x : x)
            item.attribs['json_data'] = node_json_data
    def end_task (self, item):
        self.add_children(item)
    def end_project (self, item):
        self.add_children(item)
    def end_folder (self, item):
        self.add_children(item)
    def end_context (self, item):
        children_json_data = []
        for child in item.children:
            if child.marked and 'json_data' in child.attribs:
                child_json_data = child.attribs['json_data']
                if child.type == CONTEXT:
                    children_json_data.append(child_json_data)
                else:
                    # The name is just a debugging aid
                    children_json_data.append({'ref' : child.id, 'name' : child.name })
        item.attribs['json_data']['children'] = children_json_data
    def is_in_applicable_mode (self, item):
        # Project ,ode items are written first,
        # Contexts second with refs to tasks/projects
        if self.project_mode:
            return item.type in (FOLDER, PROJECT, TASK)
        else:
            return item.type == CONTEXT
    def add_children (self, item):
        if self.is_in_applicable_mode (item):
            children_json_data = []
            for child in item.children:
                if child.marked:
                    child_json_data = child.attribs['json_data']
                    children_json_data.append(child_json_data)
            item.attribs['json_data']['children'] = children_json_data

class JSONNote (Note):
    def __init__ (self, lines):
        self.lines = lines
        self.note = '\n'.join(lines)
    def get_note_lines (self):
        return self.lines
    def get_note (self):
        return self.note
    
def load_from_json (json_data, item_db):
    if 'ref' in json_data:
        item = item_db[json_data['ref']]
        return item
    
    item_type = json_data['type']
    item_id = json_data['id']
    if item_type == FOLDER:
        item = Folder ()
    elif item_type == CONTEXT:
        item = Context ()
    elif item_type == TASK:
        item = Task ()
    elif item_type == PROJECT:
        item = Project ()
    load_attrib (item, 'id', json_data, lambda x: x)
    load_attrib (item, 'link', json_data, lambda x: x)
    load_attrib (item, 'status', json_data, lambda x: x)
    load_attrib (item, 'name', json_data, lambda x: x)
    load_attrib (item, 'date_completed', json_data, lambda x: datetime.strptime (x, TIME_FMT))
    load_attrib (item, 'date_to_start', json_data, lambda x: datetime.strptime (x, TIME_FMT))
    load_attrib (item, 'date_due', json_data, lambda x: datetime.strptime (x, TIME_FMT))
    load_attrib (item, 'flagged', json_data, lambda x: x)
    load_attrib (item, 'next', json_data, lambda x: x)
    load_attrib (item, 'note', json_data, lambda x: JSONNote (x))
    load_attrib (item, 'order', json_data, lambda x: x)
    
    for child_data in json_data['children']:
        child = load_from_json (child_data, item_db)
        item.add_child(child)

    item_db[item_id] = item
    return item

def read_json (file_name):
    instream=codecs.open(file_name, 'r', 'utf-8')
    json_data = json.loads(instream.read())
    instream.close ()
    
    item_db = {}
    root_project = load_from_json (json_data[0], item_db)
    root_context = load_from_json (json_data[1], item_db)

    return root_project, root_context
    
    
########NEW FILE########
__FILENAME__ = plugin_markdown
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

from fmt_template import Formatter, format_document
from treemodel import PROJECT
from ofexport import load_template

def generate (out, root_project, root_context, project_mode, template_dir, type_config):
    subject = root_project if project_mode else root_context
    template = load_template (template_dir, type_config['template'])
    visitor = PrintMarkdownVisitor (out, template)
    format_document (subject, visitor, project_mode)

class PrintMarkdownVisitor(Formatter):
    # All this nonsense is just to get the right number of 
    # blank lines in the right places
    def __init__ (self, out, template):
        Formatter.__init__(self, out, template)
        self.header_depth = 0
        self.depth = 0
        self.out = out
        self.last_line_was_text = False
    def begin_folder (self, folder):
        is_output = 'FolderStart' in self.template.nodes
        if self.last_line_was_text and is_output:
            print >> self.out
            self.last_line_was_text = False
        Formatter.begin_folder(self, folder)
        if is_output:
            print >>self.out
        self.depth = 0
        self.header_depth+=1
    def begin_project (self, project):
        is_output = 'ProjectStart' in self.template.nodes
        if self.last_line_was_text and is_output:
            print >> self.out
            self.last_line_was_text = False
        Formatter.begin_project(self, project)
        if is_output:
            print >>self.out
        self.depth = 0
        self.header_depth+=1
    def begin_context (self, context):
        is_output = 'ContextStart' in self.template.nodes
        if self.last_line_was_text and is_output:
            print >> self.out
            self.last_line_was_text = False
        Formatter.begin_context(self, context)
        if is_output:
            print >>self.out
        self.depth = 0
        self.header_depth+=1
    def end_task (self,task):
        Formatter.end_task(self, task)
        self.last_line_was_text = True
    def end_context (self, context):
        self.header_depth-=1
        Formatter.end_context(self, context)
    def end_project (self, project):
        self.header_depth-=1
        Formatter.end_project(self, project)
    def end_folder (self, folder):
        self.header_depth-=1
        Formatter.end_folder(self, folder)
    def handle_note (self, item):
        if item.note != None and 'NoteLine' in self.template.nodes:
            if item.type == PROJECT:
                print >>self.out
            Formatter.handle_note (self, item)
    def add_extra_template_attribs (self, item, attribs):
        attribs['hashes'] = '#' * (self.header_depth+1) + ' '

########NEW FILE########
__FILENAME__ = plugin_opml
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

from fmt_template import Formatter, format_document
from ofexport import load_template

def escape (val):
    return val.replace('"','&quot;').replace('&','&amp;').replace('<','&lt;').replace('>','&gt;')

def generate (out, root_project, root_context, project_mode, template_dir, type_config):
    subject = root_project if project_mode else root_context
    template = load_template (template_dir, type_config['template'])
    
    template.attrib_map_builder.type_fns['opml.string'] = lambda x:  escape (x)
    template.attrib_map_builder.type_fns['opml.note'] = lambda x: '&#10;'.join([escape (line) for line in x.get_note_lines ()])
    
    visitor = Formatter (out, template)
    format_document (subject, visitor, project_mode)
########NEW FILE########
__FILENAME__ = plugin_taskpaper
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

from string import replace
from ofexport import load_template
from fmt_template import Formatter, format_document

def remove_trailing_colon (x):
    if x.endswith(':'):
        return x[:-1]
    return x
    
def strip_brackets (x):
    return replace(replace(x, ')', ''), '(','')

def generate (out, root_project, root_context, project_mode, template_dir, type_config):
    subject = root_project if project_mode else root_context
    template = load_template (template_dir, type_config['template'])
    
    template.attrib_map_builder.type_fns['taskpaper.tag'] = lambda x:  strip_brackets(''.join (x.split ()))
    template.attrib_map_builder.type_fns['taskpaper.title'] = lambda x: remove_trailing_colon(x)
    
    visitor = Formatter (out, template)
    format_document (subject, visitor, project_mode)
########NEW FILE########
__FILENAME__ = plugin_text
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

from fmt_template import Formatter, format_document
from ofexport import load_template

def generate (out, root_project, root_context, project_mode, template_dir, type_config):
    subject = root_project if project_mode else root_context
    template = load_template (template_dir, type_config['template'])
    visitor = Formatter (out, template)
    format_document (subject, visitor, project_mode)
########NEW FILE########
__FILENAME__ = treemodel
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

from datetime import datetime
from typeof import TypeOf
from util import strip_tabs_newlines
import uuid
import logging

logger = logging.getLogger(__name__)

TASK = 'Task'
PROJECT = 'Project'
CONTEXT = 'Context'
FOLDER = 'Folder'

class Note:
    def get_note_lines (self):
        assert False, "not implemented"
    def get_note (self):
        assert False, "not implemented"

class NodeFwdDecl (object):
    # How to do forward class declarations in python?
    pass

class ProjectFwdDecl (object):
    # How to do forward class declarations in python?
    pass

class Node (NodeFwdDecl):
    id = TypeOf ('id', unicode)
    name = TypeOf ('name', unicode)
    parent = TypeOf ('parent', NodeFwdDecl)
    marked = TypeOf ('marked', bool)
    children = TypeOf ('children', list)
    attribs = TypeOf ('attribs', dict)
    type = TypeOf ('type', str)
    link = TypeOf ('link', unicode)
    order = TypeOf ('order', int)
    
    def __init__ (self, nType,
                  name=None,
                  parent=None,
                  marked=True,
                  link=None,
                  order=0,
                  children=[],
                  attribs = {}):
        self.name = strip_tabs_newlines (name)
        self.parent = parent
        self.children = list(children)
        self.marked = marked
        self.attribs = dict(attribs)
        self.type = nType
        self.link = link
        self.id = unicode(uuid.uuid1())
        self.order = order
        if parent != None:
            parent.add_child (self)
    def add_child (self, child):
        self.children.append(child)
        child.parent = self
    def __str__ (self):
        return self.name
    def recursive_set_project (self, task, project):
        task.project = project
        for child in task.children:
            self.recursive_set_project(child, project)

class Context(Node):
    status = TypeOf ('status', unicode)
    
    def __init__ (self,
                  name=None,
                  parent=None,
                  marked=True,
                  link=None,
                  status=None,
                  order=0,
                  children=[],
                  attribs = {}):
        Node.__init__ (self, CONTEXT,
                       name=name,
                       parent=parent,
                       marked=marked,
                       link=link,
                       order=order,
                       children=children,
                       attribs=attribs)
        status = unicode (status)
    def add_child (self, child):
        self.children.append(child)
        if child.type != CONTEXT:
            child.context = self
        else:
            child.parent = self
        
class Task(Node):
    flagged = TypeOf ('flagged', bool)
    next = TypeOf ('next', bool)
    project = TypeOf ('project', Node) # :-(
    context = TypeOf ('context', Context)
    date_completed = TypeOf ('date_completed', datetime)
    date_to_start = TypeOf ('date_to_start', datetime)
    date_due = TypeOf ('date_due', datetime)
    date_added = TypeOf ('date_added', datetime)
    estimated_minutes = TypeOf ('estimated_minutes', int)
    note = TypeOf ('note', Note)
    
    def __init__ (self,
                  name=None,
                  parent=None,
                  marked=True,
                  flagged=False,
                  nxt=False,
                  link=None,
                  order=0,
                  children=[],
                  context=None,
                  attribs={},
                  date_completed=None,
                  date_to_start=None,
                  date_due=None,
                  date_added=None,
                  estimated_minutes=None,
                  note=None):
        Node.__init__ (self, TASK,
                       name=name,
                       parent=parent,
                       marked=marked,
                       children=children,
                       link=link,
                       order=order,
                       attribs=attribs)
        self.flagged = flagged
        self.next = nxt
        self.context = context
        self.date_completed = date_completed
        self.date_to_start = date_to_start
        self.date_due = date_due
        self.date_added = date_added
        self.estimated_minutes = estimated_minutes
        self.note=note
    def add_child (self, child):
        self.children.append(child)
        child.parent = self
        self.recursive_set_project (child, self.project)

class Folder(Node, ProjectFwdDecl):
    def __init__ (self,
                  name=None,
                  parent=None,
                  marked=True,
                  link=None,
                  order=0,
                  children=[],
                  attribs = {}):
        Node.__init__ (self, FOLDER,
                       name=name,
                       parent=parent,
                       marked=marked,
                       children=children,
                       link=link,
                       order=order,
                       attribs=attribs)

class Project(Node):
    flagged = TypeOf ('flagged', bool)
    context = TypeOf ('context', Context)
    date_completed = TypeOf ('date_completed', datetime)
    date_to_start = TypeOf ('date_to_start', datetime)
    date_due = TypeOf ('date_due', datetime)
    date_added = TypeOf ('date_added', datetime)
    note = TypeOf ('note', Note)
    status = TypeOf ('status', unicode)
    def __init__ (self,
                  name=None,
                  parent=None,
                  marked=True,
                  link=None,
                  order=0,
                  children=[],
                  attribs = {},
                  flagged = False,
                  date_completed=None,
                  date_to_start=None,
                  date_due=None,
                  date_added=None,
                  context=None,
                  note=None,
                  status=None):
        Node.__init__ (self, PROJECT,
                       name=name,
                       parent=parent,
                       marked=marked,
                       link=link,
                       order=order,
                       children=children,
                       attribs=attribs)
        self.flagged = flagged
        self.context = context
        self.date_completed = date_completed
        self.date_to_start = date_to_start
        self.date_due = date_due
        self.date_added = date_added
        self.note = note
        self.status = unicode(status)
    def add_child (self, child):
        self.children.append(child)
        child.parent = self
        self.recursive_set_project (child, self)

class Visitor(object):
    project_mode = TypeOf ('flagged', bool)
    def __init__(self):
        self.project_mode = False # set during visitation
    def begin_any (self, item):
        pass
    def end_any (self, item):
        pass
    def begin_folder (self, folder):
        pass
    def end_folder (self, folder):
        pass
    def begin_project (self, project):
        pass
    def end_project (self, project):
        pass
    def begin_task (self, task):
        pass
    def end_task (self, task):
        pass
    def begin_context (self, context):
        pass
    def end_context (self, context):
        pass

def sort (items): # A default sort on the underlying key
    for child in items:
        child.children.sort(key=lambda item:item.order)
        sort(child.children)

def traverse_list (visitor, lst, ignore_marked=False, project_mode=True):
    visitor.project_mode = project_mode
    for item in lst:
        traverse (visitor, item, ignore_marked=ignore_marked, project_mode=project_mode)

def traverse (visitor, item, ignore_marked=False, project_mode=True):
    visitor.project_mode = project_mode
    if item.type == FOLDER:
        traverse_folder (visitor, item, ignore_marked=ignore_marked)
    elif item.type == CONTEXT:
        traverse_context (visitor, item, ignore_marked=ignore_marked)
    elif item.type == PROJECT:
        if project_mode or len (item.children) == 0:
            traverse_project (visitor, item, ignore_marked=ignore_marked, project_mode=project_mode)
    elif item.type == TASK:
        traverse_task (visitor, item, ignore_marked=ignore_marked, project_mode=project_mode)

def traverse_context (visitor, context, ignore_marked=False):
    logger.debug ('start traversing context: %s %s', context.id, context.name)
    visitor.project_mode = False
    if context.marked or ignore_marked:
        visitor.begin_any (context)
        visitor.begin_context (context)
        if context.marked or ignore_marked: # it might have been unmarked in begin_...
            traverse_list (visitor, context.children, ignore_marked=ignore_marked, project_mode=False)
        visitor.end_context (context) # must match calls to begin_...
        visitor.end_any (context)
    logger.debug ('end traversing context: %s %s', context.id, context.name)

def traverse_task (visitor, task, ignore_marked=False, project_mode=True):
    logger.debug ('start traversing task: %s %s', task.id, task.name)
    visitor.project_mode = project_mode
    if task.marked or ignore_marked:
        visitor.begin_any (task)
        visitor.begin_task (task)
        if project_mode:
            if task.marked or ignore_marked: # it might have been unmarked in begin_...
                traverse_list (visitor, task.children, ignore_marked=ignore_marked, project_mode=project_mode)
        visitor.end_task (task) # must match calls to begin_...
        visitor.end_any (task)
    logger.debug ('end traversing task: %s %s', task.id, task.name)
    
def traverse_project (visitor, project,ignore_marked=False, project_mode=True):
    logger.debug ('start traversing project: %s %s', project.id, project.name)
    visitor.project_mode = project_mode
    if project.marked or ignore_marked:
        visitor.begin_any (project)
        visitor.begin_project (project)
        if project_mode:
            if project.marked or ignore_marked: # it might have been unmarked in begin_...
                traverse_list (visitor, project.children, ignore_marked=ignore_marked, project_mode=project_mode)
        visitor.end_project (project) # must match calls to begin_...
        visitor.end_any (project)
    logger.debug ('end traversing project: %s %s', project.id, project.name)
    
def traverse_folder (visitor, folder, ignore_marked=False):
    logger.debug ('start traversing folder: %s %s', folder.id, folder.name)
    visitor.project_mode = True
    if folder.marked or ignore_marked:
        visitor.begin_any (folder)
        visitor.begin_folder(folder)
        if folder.marked or ignore_marked: # it might have been unmarked in begin_...
            traverse_list (visitor, folder.children, ignore_marked=ignore_marked)
        visitor.end_folder (folder) # must match calls to begin_...
        visitor.end_any (folder)
    logger.debug ('end traversing folder: %s %s', folder.id, folder.name)

########NEW FILE########
__FILENAME__ = typeof
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

class TypeOf(object):
    def __init__(self, name, thetype):
        self.thetype = thetype
        self.name = name
    def __get__(self, instance, owner):
        if self.name in instance.__dict__:
            return instance.__dict__[self.name]
        return None
    def __set__(self, instance, value):
        if value != None:
            assert isinstance (value, self.thetype), self.name + ': expected type ' + str(self.thetype) + ' got ' + str (value.__class__)
        instance.__dict__[self.name] = value
########NEW FILE########
__FILENAME__ = util
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

def strip_tabs_newlines (string):
    if string != None:
        words = string.split ()
        string = u' '.join(words)
    return string
########NEW FILE########
__FILENAME__ = visitors
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

from treemodel import Visitor, Project, Context, TASK, PROJECT, FOLDER
import logging

logger = logging.getLogger(__name__)

INCLUDED='INCLUDED'
EXCLUDED='EXCLUDED'
PATH_TO_INCLUDED='PATH_TO_INCLUDED'

def set_attrib_to_root (path_to_root, name, value):
    for item in path_to_root:
        item.attribs[name] = value

def mark_branch_not_marked (item, project_mode):
    if item.marked:
        item.marked = False
        if (item.type == TASK or item.type == PROJECT) and not project_mode:
            # We only got here because we recursed from a context
            # Tasks/Projects are not a tree in context mode, they're flat so we don't want
            # to un-mark all the children since they might be in a different context
            return
        for child in item.children:
            mark_branch_not_marked (child, project_mode)
            
class BaseFilterVisitor(Visitor):
    def __init__(self, include=True):
        self.filter = None
        self.include = include
        self.traversal_path = []
    def begin_any (self, item):
        # Can't use the item parent since this only has meaning
        # in project mode - have to track our own traversal path
        parent = None
        if len(self.traversal_path) > 0:
            parent = self.traversal_path[-1]
        item.attribs[PATH_TO_INCLUDED] = False
        if parent != None:
            # Inherit these attribute
            item.attribs[INCLUDED] = parent.attribs[INCLUDED]
            item.attribs[EXCLUDED] = parent.attribs[EXCLUDED]
            assert parent.attribs[INCLUDED] != None, "missing attribute in " + parent.name
            assert parent.attribs[EXCLUDED] != None, "missing attribute in " + parent.name
        else:
            item.attribs[INCLUDED] = False
            item.attribs[EXCLUDED] = False
        self.traversal_path.append(item)
    def end_any (self, item):
        assert item.attribs[PATH_TO_INCLUDED] != None, "missing attribute in " + item.name
        assert item.attribs[INCLUDED] != None, "missing attribute in " + item.name
        assert item.attribs[EXCLUDED] != None, "missing attribute in " + item.name
        self.traversal_path.pop()
        if self.include and not (item.attribs[INCLUDED] or item.attribs[PATH_TO_INCLUDED]):
            mark_branch_not_marked (item, self.project_mode)
        # We've finished processing the node, tidy up
        # and avoid confusing the next filter.
        del (item.attribs[INCLUDED])
        del (item.attribs[EXCLUDED])
        del (item.attribs[PATH_TO_INCLUDED])
    def match_required (self, item):
        if item.attribs[INCLUDED] or item.attribs[EXCLUDED]:
            # The decision has already been made
            return False
        return True
    def set_item_matched (self, item, matched):
        # invoked from begin_XXX
        if self.include:
            if matched:
                # Then we want this node in the output and want to stop
                # this filter testing removing any parents or children of this node
                item.attribs[INCLUDED] = True
                set_attrib_to_root (self.traversal_path, PATH_TO_INCLUDED, True)
        else: # In exclude mode
            if matched:
                # This node is toast
                mark_branch_not_marked (item, self.project_mode)
            else:
                # We haven't excluded it so it stays
                pass

def includes (include):
    if include:
        return 'include'
    else:
        return 'exclude'
    
class Filter(BaseFilterVisitor):
    def __init__(self, types, match_fn, include, nice_string):
        BaseFilterVisitor.__init__(self, include)
        self.types = types
        self.match_fn = match_fn
        self.nice_string = nice_string
    def begin_any (self, item):
        BaseFilterVisitor.begin_any (self, item)
        if item.type in self.types and self.match_required(item):
            matched = self.match_fn(item)
            if matched:
                logger.debug ("matched id:%s %s %s", item.id, item.type, item.name)
            self.set_item_matched(item, matched);
    def __str__(self):
        return includes (self.include) + ' ' + str(self.types) + ' where ' + self.nice_string


class Sort(Visitor):
    def __init__(self, types, get_key_fn, nice_string):
        Visitor.__init__(self)
        self.types = types
        self.get_key_fn = get_key_fn
        self.nice_string = nice_string
    def begin_any (self, item):
        if item.type in self.types:
            logger.debug ("sorting id:%s %s %s", item.id, item.type, item.name)
            item.children = self.sort_list(item.children)
    def sort_list (self, items):
        return sorted(items, cmp=self.compare)
    def compare (self, x, y):
        # Use the key we've been asked to use but
        # try other comparators to get at least a deterministic
        # ordering
        diff = self.cmp (self.get_key_fn (x), self.get_key_fn (y))
        if diff == 0:
            diff = self.cmp (x.order, y.order);
        if diff == 0:
            diff = self.cmp (x.id, y.id)
        return diff;
    def cmp (self, l, r):
        if l < r:
            return -1
        if l > r:
            return 1
        return 0
    def __str__(self):
        return 'Sort ' + str(self.types) + ' by ' + self.nice_string

class Prune (Visitor):
    def __init__(self, types):
        Visitor.__init__(self)
        self.types = types
    def end_any (self, item):
        if item.type in self.types:
            logger.debug ("pruning candidate id:%s %s", item.id, item.name)
            self.prune_if_empty(item)
    def prune_if_empty (self, item):
        if item.marked:
            empty = len ([x for x in item.children if x.marked]) == 0
            if empty:
                logger.debug ("pruning id:%s %s", item.id, item.name)
                item.marked = False
    def __str__ (self):
        return 'Prune ' + str(self.types)

class Flatten (Visitor):
    def __init__(self, types):
        Visitor.__init__(self)
        self.types = types
    def end_any (self, item):
        self.flatten (item)
    def flatten (self, item):
        logger.debug ("flattening candidate L1 id:%s %s %s", item.id, item.type, item.name)
        new_children = []
        for child in item.children:
            if child.type in self.types:
                logger.debug ("flattening candidate L2 id:%s %s %s", child.id, child.type, child.name)
                for grandchild in list(child.children):
                    logger.debug ("flattening candidate L3 id:%s %s %s", grandchild.id, grandchild.type, grandchild.name)
                    if grandchild.type == child.type or child.type == FOLDER:
                        logger.debug ("flattening id:%s %s %s", grandchild.id, grandchild.type, grandchild.name)
                        new_children.append(grandchild)
                        child.children.remove (grandchild)
            new_children.append(child)
        item.children = []
        for child in new_children:
            item.add_child (child)
    def __str__ (self):
        return 'Flatten' + str(self.types)
    
class Tasks (Visitor):
    def __init__(self, root_folder, root_context):
        Visitor.__init__(self)
        self.root_folder = root_folder
        self.root_context = root_context
        self.project = Project (name='Tasks')
        self.context = Context (name='Tasks')
    def end_project (self, item):
        for child in item.children:
            self.project.add_child(child)
        item.children = []
    def end_folder (self, item):
        if item == self.root_folder:
            self.root_folder.children = []
            self.root_folder.add_child(self.project)
    def end_context (self, item):
        if item != self.root_context:
            for child in item.children:
                if child.type == TASK:
                    self.context.add_child(child)
            item.children = []
        else:
            self.root_context.children = []
            self.root_context.add_child(self.context)
    def __str__ (self):
        return 'Tasks'
########NEW FILE########
__FILENAME__ = word_cloud
'''
size-0{
   font-size: 11px;
}

size-1{
   font-size: 12px;
}
'''

CSS_SIZES = range(0, 6) # 1,2...6 for use in your css-file size-1, size-2, etc.

TAGS = {
    'python' : 28059,
    'html' : 19160,
    'tag-cloud' : 40,
}

MAX = max(TAGS.values()) # Needed to calculate the steps for the font-size

STEP = MAX / len(CSS_SIZES)


print '<html>'
print '  <head>'
print '    <title>OmniFocus</title>'
print '    <style type="text/css">'
print '        size-0{'
print '           font-size: 6px;'
print '        }'
print '        size-1{'
print '           font-size: 8px;'
print '        }'
print '        size-2{'
print '           font-size: 10px;'
print '        }'
print '        size-3{'
print '           font-size: 12px;'
print '        }'
print '        size-4{'
print '           font-size: 14px;'
print '        }'
print '        size-5{'
print '           font-size: 16px;'
print '        }'
print '        size-6{'
print '           font-size: 18px;'
print '        }'
print '    </style>'
print '  </head>'
print '  <body>'



for tag, count in TAGS.items():
    css = count / STEP        
    print '<font size="%s">%s</font>' % (css, tag)
    
print '  </body>'
print '</html>'
########NEW FILE########
__FILENAME__ = attrib_convert_test
import unittest

from treemodel import Task
from attrib_convert import Conversion, AttribMapBuilder

class Test_conversion_convert(unittest.TestCase):
    
    def test_convert_attribute (self):
        type_fns = {}
        type_fns['string'] = lambda x: x
        
        conversion = Conversion ("nosuchconversion", "default value", "($value)", "string")
        self.assertEquals("default value", conversion.value(Task (), type_fns))
        
        conversion = Conversion ("name", "default value", "($value)", "string")
        self.assertEquals("default value", conversion.value(Task (), type_fns))
        
        conversion = Conversion ("name", "default value", "($value)", "string")
        self.assertEquals("(123)", conversion.value(Task (name="123"), type_fns))
        
    def test_build_attribute_map (self):
        builder = AttribMapBuilder ()
        values = builder.get_values(Task (name="123"))
        self.assertEqual("123", values["name"])
    
########NEW FILE########
__FILENAME__ = cmd_parser_test
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import unittest
from datetime import datetime
from treemodel import Task, Project, Folder
from cmd_parser import DATE_TYPE, STRING_TYPE, Note, tokenise, read_to_end_quote, parse_string, parse_expr, make_command_filter, make_expr_filter, ALIAS_LOOKUPS
from datematch import date_range_to_str
from visitors import Sort, Prune, Flatten, Filter
from test_helper import catch_exception

class TestNote (Note):
    def __init__ (self, text):
        self.text = text
        self.lines = text.split('\n')
    def get_note (self):
        return self.text
    def get_note_lines (self):
        return self.lines

def pretty_tokens (tokens):
    result = []
    for typ, val in tokens:
        if typ == 'TXT':
            result.append (val)
        elif typ == 'QTXT':
            result.append ('"' + val + '"')
        else:
            result.append (typ)
    return ','.join(result)
    
class Test_cmd_parser(unittest.TestCase):
    
    def test_alias_lookup (self):
        self.assertEquals ('date_due', ALIAS_LOOKUPS['due'])
        self.assertEquals ('flagged', ALIAS_LOOKUPS['flagged'])
    
    def test_read_to_end_quote (self):
        string, remainder = read_to_end_quote ('"', '"')
        self.assertEquals('', string)
        self.assertEquals ('', remainder)
        
        string, remainder = read_to_end_quote ('"', 'a"')
        self.assertEquals('a', string)
        self.assertEquals ('', remainder)
        
        string, remainder = read_to_end_quote ('"', 'abc"')
        self.assertEquals('abc', string)
        self.assertEquals ('', remainder)
        
        string, remainder = read_to_end_quote ('"', 'abc"stuff')
        self.assertEquals('abc', string)
        self.assertEquals ('stuff', remainder)
        
        string, remainder = read_to_end_quote ('"', 'abc"stuff')
        self.assertEquals('abc', string)
        self.assertEquals ('stuff', remainder)
        
        string, remainder = read_to_end_quote ('"', 'abc\\"def"stuff')
        self.assertEquals('abc"def', string)
        self.assertEquals ('stuff', remainder)  
        
        string, remainder = read_to_end_quote ('"', 'abc\\def"stuff')
        self.assertEquals('abc\\def', string)
        self.assertEquals ('stuff', remainder)
        
        string, remainder = read_to_end_quote ('"', 'abc\\\\def"stuff')
        self.assertEquals('abc\\def', string)
        self.assertEquals ('stuff', remainder)  
        
    def test_tokenisation(self):
        self.assertEquals('aa,OB,bb,CB,cc', pretty_tokens(tokenise ('aa(bb)cc')))
        self.assertEquals('aa,"bb",cc,EQ', pretty_tokens(tokenise ('aa"bb"cc=')))
        self.assertEquals('aa,"bb",cc,EQ', pretty_tokens(tokenise ("aa'bb'cc=")))
        self.assertEquals('a,NE,b', pretty_tokens(tokenise ("a != b")))
        self.assertEquals('a,AND,b', pretty_tokens(tokenise ("a and b")))
        self.assertEquals('a,OR,b', pretty_tokens(tokenise ("a or b")))
        self.assertEquals('a,CB,OR,OB,b', pretty_tokens(tokenise ("a)or(b")))
        self.assertEquals('NOT,a', pretty_tokens(tokenise ("! a")))
        self.assertEquals('ab,BS,cd', pretty_tokens(tokenise ("ab\\cd")))
        self.assertEquals('work', pretty_tokens(tokenise ('work'))) # Contains an or
        
        self.assertEquals("unclosed quote", catch_exception(lambda: tokenise ('a"b')))
        
    def test_parse_string (self):
        string, tokens = parse_string ([('SP', ' '),('TXT','x'),('TXT','y'),('CB', ')')], 'CB')
        self.assertEquals(' xy', string)
        self.assertEquals('CB', pretty_tokens (tokens))
        
        string, tokens = parse_string ([('SP', ' '),('TXT','x'),('TXT','y')], 'CB')
        self.assertEquals(' xy', string)
        self.assertEquals('', pretty_tokens (tokens))
    
    def test_parse_expr_true (self):
        expr  = parse_expr(tokenise ('true'))[0]
        self.assertTrue(expr (None))
    
    def test_parse_expr_false (self):
        expr = parse_expr(tokenise ('false'))[0]
        self.assertFalse(expr (None))
  
    def test_parse_expr_not (self):
        expr = parse_expr(tokenise ('!true'))[0]
        self.assertFalse(expr (None))
        
        expr = parse_expr(tokenise ('!(true)'))[0]
        self.assertFalse(expr (None))
        
        expr = parse_expr(tokenise ('(!(true))'))[0]
        self.assertFalse(expr (None))
    
    def test_parse_expr_and (self):
        expr = parse_expr(tokenise ('true and true'))[0]
        self.assertTrue(expr (None))

        expr = parse_expr(tokenise ('true and false'))[0]
        self.assertFalse(expr (None))

        expr = parse_expr(tokenise ('false and true'))[0]
        self.assertFalse(expr (None))
        
        expr = parse_expr(tokenise ('false and false'))[0]
        self.assertFalse(expr (None))
        
        expr = parse_expr(tokenise ('true and true and true'))[0]
        self.assertTrue(expr (None))
        
        expr = parse_expr(tokenise ('true and true and false'))[0]
        self.assertFalse(expr (None))
        
        expr = parse_expr(tokenise ('true and false and true'))[0]
        self.assertFalse(expr (None))
        
        expr = parse_expr(tokenise ('false and true and true'))[0]
        self.assertFalse(expr (None))

    def test_parse_expr_or (self):
        expr = parse_expr(tokenise ('true or true'))[0]
        self.assertTrue(expr (None))

        expr = parse_expr(tokenise ('true or false'))[0]
        self.assertTrue(expr (None))

        expr = parse_expr(tokenise ('false or true'))[0]
        self.assertTrue(expr (None))
        
        expr = parse_expr(tokenise ('false or false'))[0]
        self.assertFalse(expr (None))
        
        expr = parse_expr(tokenise ('false or false or false'))[0]
        self.assertFalse(expr (None))
        
        expr = parse_expr(tokenise ('false or false or true'))[0]
        self.assertTrue(expr (None))
        
        expr = parse_expr(tokenise ('false or true or false'))[0]
        self.assertTrue(expr (None))
        
        expr = parse_expr(tokenise ('true or false or false'))[0]
        self.assertTrue(expr (None))
        
    def test_parse_expr_equals (self):
        expr = parse_expr(tokenise ('true = true'))[0]
        self.assertTrue(expr (None))

        expr = parse_expr(tokenise ('true = false'))[0]
        self.assertFalse(expr (None))

        expr = parse_expr(tokenise ('false = true'))[0]
        self.assertFalse(expr (None))
        
        expr = parse_expr(tokenise ('false = false'))[0]
        self.assertTrue(expr (None))
        
    def test_parse_expr_string (self):
        expr = parse_expr(tokenise ('"xxx" = "xxx"'))[0]
        self.assertTrue(expr (None))
        expr = parse_expr(tokenise ('"xxx" = "yyy"'))[0]
        self.assertFalse(expr (None))

    def test_parse_expr_not_equals (self):
        expr = parse_expr(tokenise ('true != true'))[0]
        self.assertFalse(expr (None))

        expr = parse_expr(tokenise ('true != false'))[0]
        self.assertTrue(expr (None))

        expr = parse_expr(tokenise ('false != true'))[0]
        self.assertTrue(expr (None))
        
        expr = parse_expr(tokenise ('false != false'))[0]
        self.assertFalse(expr (None))
        
    def test_parse_expr_flagged (self):
        expr = parse_expr(tokenise ('flagged'))[0]
        self.assertTrue(expr (Task(flagged=True)))
        self.assertFalse(expr (Task(flagged=False)))
        
        expr = parse_expr(tokenise ('flagged = true'))[0]
        self.assertTrue(expr (Task(flagged=True)))
        self.assertFalse(expr (Task(flagged=False)))
        
        expr = parse_expr(tokenise ('true = flagged'))[0]
        self.assertTrue(expr (Task(flagged=True)))
        self.assertFalse(expr (Task(flagged=False)))
        
        expr = parse_expr(tokenise ('!flagged'))[0]
        self.assertFalse(expr (Task(flagged=True)))
        self.assertTrue(expr (Task(flagged=False)))
        
    def test_parse_expr_brackets (self):
        expr = parse_expr(tokenise ('(true)'))[0]
        self.assertTrue(expr (None))
        expr  = parse_expr(tokenise ('(false)'))[0]
        self.assertFalse(expr (None))
        expr  = parse_expr(tokenise (' ( false ) '))[0]
        self.assertFalse(expr (None))
        expr = parse_expr(tokenise ('(false or true)'))[0]
        self.assertTrue(expr (None))
        expr = parse_expr(tokenise ('(false) or (true)'))[0]
        self.assertTrue(expr (None))
        expr = parse_expr(tokenise ('((false) or (true))'))[0]
        self.assertTrue(expr (None))
    
    def test_parse_expr_missing_brackets (self):
        expr = parse_expr(tokenise ('true=false or true=true))'))[0]
        self.assertTrue(expr (None))
        expr = parse_expr(tokenise ('true=false or true=false))'))[0]
        self.assertFalse(expr (None))
        expr = parse_expr(tokenise ('true=true or true=false))'))[0]
        self.assertTrue(expr (None))
        
    def test_parse_expr_date(self):
        tue = datetime.strptime('Apr 9 2013 11:33PM', '%b %d %Y %I:%M%p')
        wed = datetime.strptime('Apr 10 2013 11:33PM', '%b %d %Y %I:%M%p')
        expr = parse_expr(tokenise ('today'), type_required=STRING_TYPE, now=tue)[0]
        self.assertEquals ("today", expr(None))
        expr = parse_expr(tokenise ('today'), type_required = DATE_TYPE, now=tue)[0]
        self.assertEquals ("2013-04-09", date_range_to_str (expr(None)))
        expr = parse_expr(tokenise ('"last tues"'), type_required = DATE_TYPE, now=tue)[0]
        self.assertEquals ("2013-04-02", date_range_to_str (expr(None)))
        expr = parse_expr(tokenise ('due = today'), now=tue)[0]
        self.assertTrue (expr(Task(name="", date_due=tue)))
        expr = parse_expr(tokenise ('due = start'), now=tue)[0]
        self.assertTrue (expr(Task(name="", date_due=tue, date_to_start=tue)))
        self.assertFalse (expr(Task(name="", date_due=tue, date_to_start=wed)))
        self.assertFalse (expr(Task(name="", date_due=tue)))
        
    def test_parse_expr_type(self):
        expr = parse_expr(tokenise ('type="Task"'))[0]
        self.assertTrue(expr (Task(flagged=True)))
        self.assertFalse(expr (Project(flagged=True)))
        
    def test_parse_expr_status(self):
        expr = parse_expr(tokenise ('status="done"'))[0]
        self.assertTrue(expr (Project(status="done")))
        self.assertFalse(expr (Project(status="active")))
        
    def test_parse_expr_quoted_string_literal(self):
        expr = parse_expr(tokenise ('name="aabbccdd"'))[0]
        self.assertTrue(expr (Task(name="aabbccdd")))
        self.assertFalse(expr (Task(name="zzz")))
        
    def test_parse_expr_unquoted_string_literal(self):
        expr = parse_expr(tokenise ('name=aabbccdd'))[0]
        self.assertTrue(expr (Task(name="aabbccdd")))
        self.assertFalse(expr (Task(name="zzz")))
        
    def test_parse_expr_string_regexp(self):
        expr = parse_expr(tokenise ('name="bb"'))[0]
        self.assertTrue(expr (Task(name="aabbccdd")))
        self.assertFalse(expr (Task(name="zzz")))

    def test_parse_expr_accessing_missing_params (self):
        tue = datetime.strptime('Apr 9 2013 11:33PM', '%b %d %Y %I:%M%p')
        expr = parse_expr(tokenise ('flagged'))[0]
        self.assertFalse(expr (Folder(name="aabbccdd")))
        
        expr = parse_expr(tokenise ('due=today'),now=tue)[0]
        self.assertFalse(expr (Folder(name="aabbccdd")))
        
    def test_bug_2013_04_24 (self):
        expr = parse_expr(tokenise ('(type="Folder") and (name!="^Misc")'))[0]
        self.assertFalse(expr (Folder(name="Miscellaneous")))
        expr = parse_expr(tokenise ('(type="Project") and (name="Misc")'))[0]
        self.assertTrue(expr (Project(name="Miscellaneous")))
        self.assertFalse(expr (Project(name="xxx")))
        expr = parse_expr(tokenise ('((type="Project") and (name="Misc"))'))[0]
        self.assertTrue(expr (Project(name="Miscellaneous")))
        self.assertFalse(expr (Project(name="xxx")))
        self.assertFalse(expr (Folder(name="Misc")))
        
    def test_bug_2013_04_26 (self):
        expr = parse_expr(tokenise ('text=^Work$|^Miscellaneous$'))[0]
        self.assertFalse(expr (Folder(name="Misc")))
        self.assertTrue(expr (Folder(name="Miscellaneous")))
        
        expr = parse_expr(tokenise ('(type=Folder)'))[0]
        self.assertTrue(expr (Folder(name="Miscellaneous")))
        
        expr = parse_expr(tokenise ('(type=Folder)and(text=^Work$|^Miscellaneous$)'))[0]
        self.assertFalse(expr (Folder(name="Misc")))
        self.assertTrue(expr (Folder(name="Miscellaneous")))
    
    def test_bug_2013_04_27 (self):
        expr = parse_expr(tokenise ('(type=Folder) and !name=".*Folder 2"'))[0]
        self.assertTrue(expr (Folder(name="Miscellaneous")))
        self.assertFalse(expr (Folder(name="xxx Folder 2")))
        
        expr = parse_expr(tokenise ('(type=Folder) and name!=".*Folder 2"'))[0]
        self.assertTrue(expr (Folder(name="Miscellaneous")))
        self.assertFalse(expr (Folder(name="xxx Folder 2")))
    
    def test_bug_2013_04_28 (self):
        tue = datetime.strptime('Apr 9 2013 11:33PM', '%b %d %Y %I:%M%p')
        expr = parse_expr(tokenise ("flagged or true"), now=tue)[0]
        self.assertTrue(expr (Project()))
        
        expr = parse_expr(tokenise ("flagged or due=today"), now=tue)[0]
        self.assertFalse(expr (Project()))
        self.assertTrue(expr (Project(flagged=True)))
        self.assertTrue(expr (Project(date_due=tue)))
        
    def test_bug_2013_04_28_2 (self):
        tue = datetime.strptime('Apr 9 2013 11:33PM', '%b %d %Y %I:%M%p')
        expr = parse_expr(tokenise ("flagged or (due='to tomorrow')"), now=tue)[0]
        self.assertFalse(expr (Task()))
        self.assertTrue(expr (Task(flagged=True)))
        self.assertTrue(expr (Task(date_due=tue)))
            
    def test_parse_expr_none(self):
        tue = datetime.strptime('Apr 9 2013 11:33PM', '%b %d %Y %I:%M%p')
        expr = parse_expr(tokenise ('due = none'))[0]
        self.assertTrue (expr(Task(name="")))
        self.assertFalse (expr(Task(name="", date_due=tue)))
        
    def test_parse_expr_any(self):
        tue = datetime.strptime('Apr 9 2013 11:33PM', '%b %d %Y %I:%M%p')
        expr = parse_expr(tokenise ('due = any'))[0]
        self.assertFalse (expr(Task(name="")))
        self.assertTrue (expr(Task(name="", date_due=tue)))
        
    def test_parse_expr_note_filter(self):
        expr = parse_expr(tokenise ('note=123'))[0]
        self.assertTrue(expr (Task(note=TestNote("aaaa123bbb\nccc456ddd"))))
        self.assertTrue(expr (Task(note=TestNote("aaaazzzbbb\nccc123ddd"))))
        self.assertFalse(expr (Task(note=TestNote("z\y\z"))))
        self.assertFalse(expr (Task()))
        
    def test_make_command_filter (self):
        self.assertEquals (None, make_command_filter ("nonsense"))
        self.assertEquals (Sort, type(make_command_filter ("sort Task name")))
        self.assertEquals (Flatten, type(make_command_filter ("flatten Project")))
        self.assertEquals (Prune, type(make_command_filter ("prune Folder")))
        
        self.assertEquals("prune takes one node type argument, got: prune x y", catch_exception(lambda: make_command_filter ("prune x y")))
        self.assertEquals("no such node type in prune: Floder", catch_exception(lambda: make_command_filter ("prune Floder")))
        self.assertEquals("flatten takes one node type argument, got: flatten x y", catch_exception(lambda: make_command_filter ("flatten x y")))
        self.assertEquals("no such node type in flatten: Floder", catch_exception(lambda: make_command_filter ("flatten Floder")))
        self.assertEquals("no such node type in sort: Kangaroo", catch_exception(lambda: make_command_filter ("sort Kangaroo ")))
        self.assertEquals("sort takes two arguments, node type and field, got: sort x y z", catch_exception(lambda: make_command_filter ("sort x y z")))
        self.assertEquals("no such sortable field:weight", catch_exception(lambda: make_command_filter ("sort Task weight")))

    def test_make_expr_filter (self):
        self.assertEquals (Filter, type(make_expr_filter ('type="Context"', True))) 
        
        self.assertEquals("expecting a Boolean got a String: field:name", catch_exception(lambda: make_expr_filter ('name', True)))
        self.assertEquals("expecting a Boolean got a Date: field:date_due", catch_exception(lambda: make_expr_filter ('due', True)))
        self.assertEquals("expecting a Date got a String: field:name", catch_exception(lambda: make_expr_filter ('due = name', True)))
        self.assertEquals('found "name" not: [\'AND\', \'OR\', \'EQ\', \'NE\', \'CB\']', catch_exception(lambda: make_expr_filter ('not name', True)))


########NEW FILE########
__FILENAME__ = datematch_test
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import unittest
from datematch import date_range_to_str, tidy_space_separated_fields, process_date_specifier, hunt_for_day, find_first_of_month, find_next_month, find_prev_month, find_end_of_month, find_january_this_year, hunt_for_month, find_monday_this_week, find_monday_next_week
from datetime import datetime

def process_date_specifier_to_datestr (now, spec):
        rng = process_date_specifier (now, spec)
        return date_range_to_str (rng)
    
class Test_datematch(unittest.TestCase):
    
    def test_tidy_space_separated_fields(self):
        self.assertEquals ("a bb ccc dddd", tidy_space_separated_fields (" a   bb ccc   dddd  "))
    
    def test_hunt_for_day (self):
        tue = datetime.strptime('Apr 9 2013 11:33PM', '%b %d %Y %I:%M%p')
        
        self.assertEquals("2013-04-15", hunt_for_day (tue,"monday", True, match_today = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-09", hunt_for_day (tue,"tue", True, match_today = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-10", hunt_for_day (tue,"we", True, match_today = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-11", hunt_for_day (tue,"th", True, match_today = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-12", hunt_for_day (tue,"fr", True, match_today = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-13", hunt_for_day (tue,"sa", True, match_today = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-14", hunt_for_day (tue,"su", True, match_today = True).date().strftime ("%Y-%m-%d"))
        
        self.assertEquals("2013-04-15", hunt_for_day (tue,"monday", True, match_today = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-16", hunt_for_day (tue,"tue", True, match_today = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-10", hunt_for_day (tue,"we", True, match_today = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-11", hunt_for_day (tue,"th", True, match_today = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-12", hunt_for_day (tue,"fr", True, match_today = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-13", hunt_for_day (tue,"sa", True, match_today = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-14", hunt_for_day (tue,"su", True, match_today = False).date().strftime ("%Y-%m-%d"))
        
        self.assertEquals("2013-04-08", hunt_for_day (tue,"monday", False, match_today = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-09", hunt_for_day (tue,"tue", False, match_today = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-03", hunt_for_day (tue,"we", False, match_today = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-04", hunt_for_day (tue,"th", False, match_today = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-05", hunt_for_day (tue,"fr", False, match_today = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-06", hunt_for_day (tue,"sa", False, match_today = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-07", hunt_for_day (tue,"su", False, match_today = True).date().strftime ("%Y-%m-%d"))
        
        self.assertEquals("2013-04-08", hunt_for_day (tue,"monday", False, match_today = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-02", hunt_for_day (tue,"tue", False, match_today = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-03", hunt_for_day (tue,"we", False, match_today = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-04", hunt_for_day (tue,"th", False, match_today = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-05", hunt_for_day (tue,"fr", False, match_today = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-06", hunt_for_day (tue,"sa", False, match_today = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-07", hunt_for_day (tue,"su", False, match_today = False).date().strftime ("%Y-%m-%d"))
    
    def test_find_monday_this_week (self):
        mon = datetime.strptime('Apr 8 2013 11:33PM', '%b %d %Y %I:%M%p')
        sun = datetime.strptime('Apr 14 2013 11:33PM', '%b %d %Y %I:%M%p')
        
        self.assertEquals("2013-04-08", find_monday_this_week (mon).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-08", find_monday_this_week (sun).date().strftime ("%Y-%m-%d"))
        
    def test_find_monday_next_week (self):
        mon = datetime.strptime('Apr 8 2013 11:33PM', '%b %d %Y %I:%M%p')
        sun = datetime.strptime('Apr 14 2013 11:33PM', '%b %d %Y %I:%M%p')
        
        self.assertEquals("2013-04-15", find_monday_next_week (mon).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-15", find_monday_next_week (sun).date().strftime ("%Y-%m-%d"))
    
    def test_find_first_of_month (self):
        first = datetime.strptime('Apr 1 2013 11:33PM', '%b %d %Y %I:%M%p')
        last = datetime.strptime('Apr 30 2013 11:33PM', '%b %d %Y %I:%M%p')
        
        self.assertEquals("2013-04-01", find_first_of_month (first).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-01", find_first_of_month (last).date().strftime ("%Y-%m-%d"))
        
    def test_find_january_this_year (self):
        first = datetime.strptime('Jan 1 2013 11:33PM', '%b %d %Y %I:%M%p')
        last = datetime.strptime('Dec 30 2013 11:33PM', '%b %d %Y %I:%M%p')
        
        self.assertEquals("2013-01-01", find_january_this_year (first).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-01-01", find_january_this_year (last).date().strftime ("%Y-%m-%d"))
        
    def test_find_next_month (self):
        first = datetime.strptime('Apr 1 2013 11:33PM', '%b %d %Y %I:%M%p')
        last = datetime.strptime('Apr 30 2013 11:33PM', '%b %d %Y %I:%M%p')
        
        self.assertEquals("2013-05-01", find_next_month (first).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-05-01", find_next_month (last).date().strftime ("%Y-%m-%d"))
        
    def test_find_prev_month (self):
        first = datetime.strptime('Apr 1 2013 11:33PM', '%b %d %Y %I:%M%p')
        last = datetime.strptime('Apr 30 2013 11:33PM', '%b %d %Y %I:%M%p')
        
        self.assertEquals("2013-03-01", find_prev_month (first).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-03-01", find_prev_month (last).date().strftime ("%Y-%m-%d"))
        
    def test_find_end_of_month (self):
        first = datetime.strptime('Apr 1 2013 11:33PM', '%b %d %Y %I:%M%p')
        last = datetime.strptime('Apr 30 2013 11:33PM', '%b %d %Y %I:%M%p')
        
        self.assertEquals("2013-04-30", find_end_of_month (first).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-30", find_end_of_month (last).date().strftime ("%Y-%m-%d"))
    
    def test_hunt_for_month (self):
        apr = datetime.strptime('Apr 9 2013 11:33PM', '%b %d %Y %I:%M%p')
        
        self.assertEquals("2014-01-01", hunt_for_month (apr,"january", True, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2014-02-01", hunt_for_month (apr,"feb", True, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2014-03-01", hunt_for_month (apr,"mar", True, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-01", hunt_for_month (apr,"apr", True, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-05-01", hunt_for_month (apr,"may", True, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-06-01", hunt_for_month (apr,"jun", True, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-07-01", hunt_for_month (apr,"jul", True, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-08-01", hunt_for_month (apr,"aug", True, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-09-01", hunt_for_month (apr,"sep", True, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-10-01", hunt_for_month (apr,"oct", True, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-11-01", hunt_for_month (apr,"nov", True, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-12-01", hunt_for_month (apr,"dec", True, match_this_month = True).date().strftime ("%Y-%m-%d"))
        
        self.assertEquals("2014-01-01", hunt_for_month (apr,"january", True, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2014-02-01", hunt_for_month (apr,"feb", True, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2014-03-01", hunt_for_month (apr,"mar", True, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2014-04-01", hunt_for_month (apr,"apr", True, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-05-01", hunt_for_month (apr,"may", True, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-06-01", hunt_for_month (apr,"jun", True, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-07-01", hunt_for_month (apr,"jul", True, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-08-01", hunt_for_month (apr,"aug", True, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-09-01", hunt_for_month (apr,"sep", True, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-10-01", hunt_for_month (apr,"oct", True, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-11-01", hunt_for_month (apr,"nov", True, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-12-01", hunt_for_month (apr,"dec", True, match_this_month = False).date().strftime ("%Y-%m-%d"))
        
        self.assertEquals("2013-01-01", hunt_for_month (apr,"january", False, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-02-01", hunt_for_month (apr,"feb", False, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-03-01", hunt_for_month (apr,"mar", False, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-04-01", hunt_for_month (apr,"apr", False, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-05-01", hunt_for_month (apr,"may", False, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-06-01", hunt_for_month (apr,"jun", False, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-07-01", hunt_for_month (apr,"jul", False, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-08-01", hunt_for_month (apr,"aug", False, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-09-01", hunt_for_month (apr,"sep", False, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-10-01", hunt_for_month (apr,"oct", False, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-11-01", hunt_for_month (apr,"nov", False, match_this_month = True).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-12-01", hunt_for_month (apr,"dec", False, match_this_month = True).date().strftime ("%Y-%m-%d"))
        
        self.assertEquals("2013-01-01", hunt_for_month (apr,"january", False, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-02-01", hunt_for_month (apr,"feb", False, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2013-03-01", hunt_for_month (apr,"mar", False, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-04-01", hunt_for_month (apr,"apr", False, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-05-01", hunt_for_month (apr,"may", False, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-06-01", hunt_for_month (apr,"jun", False, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-07-01", hunt_for_month (apr,"jul", False, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-08-01", hunt_for_month (apr,"aug", False, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-09-01", hunt_for_month (apr,"sep", False, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-10-01", hunt_for_month (apr,"oct", False, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-11-01", hunt_for_month (apr,"nov", False, match_this_month = False).date().strftime ("%Y-%m-%d"))
        self.assertEquals("2012-12-01", hunt_for_month (apr,"dec", False, match_this_month = False).date().strftime ("%Y-%m-%d"))
    
    def test_date_from_string (self):
        tue = datetime.strptime('Apr 9 2013 11:33PM', '%b %d %Y %I:%M%p')
                
        self.assertEquals("2013-04-08", process_date_specifier_to_datestr (tue,"monday"))
        self.assertEquals("2013-04-09", process_date_specifier_to_datestr (tue,"tues"))
        self.assertEquals("2013-04-10", process_date_specifier_to_datestr (tue,"wed"))
        self.assertEquals("2013-04-11", process_date_specifier_to_datestr (tue,"th"))
        self.assertEquals("2013-04-12", process_date_specifier_to_datestr (tue,"fr"))
        self.assertEquals("2013-04-13", process_date_specifier_to_datestr (tue,"sa"))
        self.assertEquals("2013-04-14", process_date_specifier_to_datestr (tue,"su"))

        self.assertEquals("2013-04-15", process_date_specifier_to_datestr (tue,"next monday"))
        self.assertEquals("2013-04-16", process_date_specifier_to_datestr (tue,"next tuesday"))
        self.assertEquals("2013-04-17", process_date_specifier_to_datestr (tue,"next wednesday"))
        self.assertEquals("2013-04-18", process_date_specifier_to_datestr (tue,"next thurs"))
        self.assertEquals("2013-04-19", process_date_specifier_to_datestr (tue,"next fr"))
        self.assertEquals("2013-04-20", process_date_specifier_to_datestr (tue,"next sa"))
        self.assertEquals("2013-04-21", process_date_specifier_to_datestr (tue,"next su"))
        try:
            self.assertEquals("2013-04-14", process_date_specifier_to_datestr (tue,"next monkey"))
            self.fail('Exception expected')
        except Exception as e:
            self.assertEquals ('I don\'t think "next monkey" is any kind of date specification I recognise', e.message)
        self.assertEquals("2013-04-01", process_date_specifier_to_datestr (tue,"last mo"))
        self.assertEquals("2013-04-02", process_date_specifier_to_datestr (tue,"last tu"))
        self.assertEquals("2013-04-03", process_date_specifier_to_datestr (tue,"last we"))
        self.assertEquals("2013-04-04", process_date_specifier_to_datestr (tue,"last th"))
        self.assertEquals("2013-04-05", process_date_specifier_to_datestr (tue,"last fr"))
        self.assertEquals("2013-04-06", process_date_specifier_to_datestr (tue,"last sa"))
        self.assertEquals("2013-04-07", process_date_specifier_to_datestr (tue,"last su"))
        
        try:
            self.assertEquals("2013-04-14", process_date_specifier_to_datestr (tue,"last monkey"))
            self.fail('Exception expected')
        except Exception as e:
            self.assertEquals ('I don\'t think "last monkey" is any kind of date specification I recognise', e.message)
        self.assertEquals("2013-04-08", process_date_specifier_to_datestr (tue,"mo"))
        self.assertEquals("2013-04-09", process_date_specifier_to_datestr (tue,"tu"))
        self.assertEquals("2013-04-10", process_date_specifier_to_datestr (tue,"we"))
        self.assertEquals("2013-04-11", process_date_specifier_to_datestr (tue,"th"))
        self.assertEquals("2013-04-12", process_date_specifier_to_datestr (tue,"fri"))
        self.assertEquals("2013-04-13", process_date_specifier_to_datestr (tue,"sat"))
        self.assertEquals("2013-04-14", process_date_specifier_to_datestr (tue,"sun"))
        
        self.assertEquals("2013-01-01..2013-01-31", process_date_specifier_to_datestr (tue,"january"))
        self.assertEquals("2013-02-01..2013-02-28", process_date_specifier_to_datestr (tue,"feb"))
        self.assertEquals("2013-03-01..2013-03-31", process_date_specifier_to_datestr (tue,"mar"))
        self.assertEquals("2013-04-01..2013-04-30", process_date_specifier_to_datestr (tue,"apr"))
        self.assertEquals("2013-05-01..2013-05-31", process_date_specifier_to_datestr (tue,"may"))
        self.assertEquals("2013-06-01..2013-06-30", process_date_specifier_to_datestr (tue,"jun"))
        self.assertEquals("2013-07-01..2013-07-31", process_date_specifier_to_datestr (tue,"jul"))
        self.assertEquals("2013-08-01..2013-08-31", process_date_specifier_to_datestr (tue,"aug"))
        self.assertEquals("2013-09-01..2013-09-30", process_date_specifier_to_datestr (tue,"sep"))
        self.assertEquals("2013-10-01..2013-10-31", process_date_specifier_to_datestr (tue,"oct"))
        self.assertEquals("2013-11-01..2013-11-30", process_date_specifier_to_datestr (tue,"nov"))
        self.assertEquals("2013-12-01..2013-12-31", process_date_specifier_to_datestr (tue,"dec"))
        
        self.assertEquals("2014-01-01..2014-01-31", process_date_specifier_to_datestr (tue,"next january"))
        self.assertEquals("2014-02-01..2014-02-28", process_date_specifier_to_datestr (tue,"next feb"))
        self.assertEquals("2014-03-01..2014-03-31", process_date_specifier_to_datestr (tue,"next mar"))
        self.assertEquals("2014-04-01..2014-04-30", process_date_specifier_to_datestr (tue,"next apr"))
        self.assertEquals("2014-05-01..2014-05-31", process_date_specifier_to_datestr (tue,"next may"))
        self.assertEquals("2014-06-01..2014-06-30", process_date_specifier_to_datestr (tue,"next jun"))
        self.assertEquals("2014-07-01..2014-07-31", process_date_specifier_to_datestr (tue,"next jul"))
        self.assertEquals("2014-08-01..2014-08-31", process_date_specifier_to_datestr (tue,"next aug"))
        self.assertEquals("2014-09-01..2014-09-30", process_date_specifier_to_datestr (tue,"next sep"))
        self.assertEquals("2014-10-01..2014-10-31", process_date_specifier_to_datestr (tue,"next oct"))
        self.assertEquals("2014-11-01..2014-11-30", process_date_specifier_to_datestr (tue,"next nov"))
        self.assertEquals("2014-12-01..2014-12-31", process_date_specifier_to_datestr (tue,"next dec"))
        
        self.assertEquals("2012-01-01..2012-01-31", process_date_specifier_to_datestr (tue,"last january"))
        self.assertEquals("2012-02-01..2012-02-29", process_date_specifier_to_datestr (tue,"last feb"))
        self.assertEquals("2012-03-01..2012-03-31", process_date_specifier_to_datestr (tue,"last mar"))
        self.assertEquals("2012-04-01..2012-04-30", process_date_specifier_to_datestr (tue,"last apr"))
        self.assertEquals("2012-05-01..2012-05-31", process_date_specifier_to_datestr (tue,"last may"))
        self.assertEquals("2012-06-01..2012-06-30", process_date_specifier_to_datestr (tue,"last jun"))
        self.assertEquals("2012-07-01..2012-07-31", process_date_specifier_to_datestr (tue,"last jul"))
        self.assertEquals("2012-08-01..2012-08-31", process_date_specifier_to_datestr (tue,"last aug"))
        self.assertEquals("2012-09-01..2012-09-30", process_date_specifier_to_datestr (tue,"last sep"))
        self.assertEquals("2012-10-01..2012-10-31", process_date_specifier_to_datestr (tue,"last oct"))
        self.assertEquals("2012-11-01..2012-11-30", process_date_specifier_to_datestr (tue,"last nov"))
        self.assertEquals("2012-12-01..2012-12-31", process_date_specifier_to_datestr (tue,"last dec"))
        
        self.assertEquals("any", process_date_specifier_to_datestr (tue,"any"))
        self.assertEquals("none", process_date_specifier_to_datestr (tue,"none"))
        
        self.assertEquals("2013-04-09", process_date_specifier_to_datestr (tue,"today"))
        self.assertEquals("2013-04-08", process_date_specifier_to_datestr (tue,"yesterday"))
        self.assertEquals("2013-04-10", process_date_specifier_to_datestr (tue,"tomorrow"))
        
        self.assertEquals("2013-04-07..", process_date_specifier_to_datestr (tue,"from last sun"))
        self.assertEquals("2013-02-01..", process_date_specifier_to_datestr (tue,"from feb"))
        self.assertEquals("2012-02-01..", process_date_specifier_to_datestr (tue,"from last feb"))
        
        self.assertEquals("..2013-04-10", process_date_specifier_to_datestr (tue,"to tomorrow"))
        self.assertEquals("..2013-08-31", process_date_specifier_to_datestr (tue,"to aug"))
        self.assertEquals("..2014-08-31", process_date_specifier_to_datestr (tue,"to next aug"))
        
        self.assertEquals("2013-04-07..2013-04-10", process_date_specifier_to_datestr (tue,"last sun to tomorrow"))
        self.assertEquals("2013-04-08..2013-04-09", process_date_specifier_to_datestr (tue,"yesterday to today"))
        self.assertEquals("2013-04-09..2013-04-15", process_date_specifier_to_datestr (tue,"today to next mon"))
        self.assertEquals("2012-01-01..2014-12-31", process_date_specifier_to_datestr (tue,"last jan to next dec"))
        self.assertEquals("2012-01-01..2014-12-31", process_date_specifier_to_datestr (tue,"2012-01-01 to 2014-12-31"))

        

########NEW FILE########
__FILENAME__ = ofexport_test
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import unittest

from ofexport import fix_abbrieviated_expr

class Test_fmt_datematch(unittest.TestCase):
    
    def test_fix_abbrieviated_expr (self):
        self.assertEquals ('(type=Project) and (name=x)', fix_abbrieviated_expr ('Project', '=x'))
        self.assertEquals ('(type=Project) and (name!=x)', fix_abbrieviated_expr ('Project', '!=x'))
        self.assertEquals ('name=x', fix_abbrieviated_expr ('any', '=x'))
        self.assertEquals ('name!=x', fix_abbrieviated_expr ('all', '!=x'))
        self.assertEquals ('prune Task', fix_abbrieviated_expr ('Task', 'prune'))
        self.assertEquals ('prune any', fix_abbrieviated_expr ('any', 'prune'))
        self.assertEquals ('prune all', fix_abbrieviated_expr ('all', 'prune'))
        self.assertEquals ('sort Folder text', fix_abbrieviated_expr ('Folder', 'sort'))
        self.assertEquals ('sort Folder due', fix_abbrieviated_expr ('Folder', 'sort due'))
########NEW FILE########
__FILENAME__ = plugin_ics_test
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import unittest
from plugin_ics import fix_dates, load_note_attribs, utc, format_date, format_alarm
from treemodel import Task, Note
from datetime import datetime
import dateutil.parser

class TestNote (Note):
    def __init__ (self, text):
        self.text = text
        self.lines = text.split('\n')
    def get_note (self):
        return self.text
    def get_note_lines (self):
        return self.lines
    
class Test_fmt_datematch(unittest.TestCase):
    
    def test_fix_dates (self):
        tue = datetime.strptime('Apr 9 2013 11:33PM', '%b %d %Y %I:%M%p')
        wed = datetime.strptime('Apr 10 2013 11:33PM', '%b %d %Y %I:%M%p')
        
        task = Task ()
        fix_dates (task)
        self.assertEquals(None, task.date_to_start)
        self.assertEquals(None, task.date_due)
        
        task = Task (date_to_start=tue)
        fix_dates (task)
        self.assertEquals(tue, task.date_to_start)
        self.assertEquals(tue, task.date_due)
        
        task = Task (date_due=tue)
        fix_dates (task)
        self.assertEquals(tue, task.date_to_start)
        self.assertEquals(tue, task.date_due)
        
        task = Task (date_to_start=tue, date_due=wed)
        fix_dates (task)
        self.assertEquals(tue, task.date_to_start)
        self.assertEquals(wed, task.date_due)
        
    def test_load_note_attribs (self):
        task = Task ()
        n_attribs_before = len (task.attribs)
        load_note_attribs (task, "")
        self.assertEqual (n_attribs_before, len (task.attribs))
        
        n_attribs_before = len (task.attribs)
        task = Task (note=TestNote("xyz"))
        self.assertEqual (n_attribs_before, len (task.attribs))
        
        task = Task (note=TestNote("%of cal xxx"))
        load_note_attribs (task, "")
        self.assertEquals (True, task.attribs['xxx'])
        
        task = Task (note=TestNote("%of cal xxx\n%of cal yyy"))
        load_note_attribs (task, "")
        self.assertEquals (True, task.attribs['xxx'])
        self.assertEquals (True, task.attribs['yyy'])
        
        task = Task (note=TestNote("%of cal xxx   yyy zzz   "))
        n_attribs_before = len (task.attribs)
        load_note_attribs (task, "")
        self.assertEquals (True, task.attribs['xxx'])
        self.assertEquals (True, task.attribs['yyy'])
        self.assertEquals (True, task.attribs['zzz'])
        self.assertEqual (n_attribs_before + 3, len (task.attribs))
     
    def test_load_note_attribs_with_default (self):
        task = Task ()
        n_attribs_before = len (task.attribs)
        load_note_attribs (task, "%of cal in_default")
        self.assertEquals (True, task.attribs['in_default'])
        self.assertEqual (n_attribs_before + 1, len (task.attribs))
        
        task = Task (note=TestNote("%of cal in_note"))
        n_attribs_before = len (task.attribs)
        load_note_attribs (task, "%of cal in_default")
        self.assertEquals (True, task.attribs['in_note'])
        self.assertEqual (n_attribs_before + 1, len (task.attribs))
        
    def test_load_note_start_attrib (self):
        the_date = dateutil.parser.parse('Wed, 27 Oct 2010 22:17:00 BST')
        task = Task (date_to_start=the_date, date_due=the_date, note=TestNote("%of cal start=18:12"))
        load_note_attribs (task, "")
        self.assertEqual ("2010.10.27 18:12", task.date_to_start.strftime ('%Y.%m.%d %H:%M'))
        self.assertEqual ("2010.10.27 22:17", task.date_due.strftime ('%Y.%m.%d %H:%M'))
        
    def test_load_note_due_attrib (self):
        the_date = dateutil.parser.parse('Wed, 27 Oct 2010 22:17:00 BST')
        task = Task (date_to_start=the_date, date_due=the_date, note=TestNote("%of cal due=23:12"))
        load_note_attribs (task, "")
        self.assertEqual ("2010.10.27 22:17", task.date_to_start.strftime ('%Y.%m.%d %H:%M'))
        self.assertEqual ("2010.10.27 23:12", task.date_due.strftime ('%Y.%m.%d %H:%M'))
        
    def test_utc (self):
        the_date = dateutil.parser.parse('Wed, 27 Oct 2010 22:17:00 BST')
        self.assertEquals ("2010.10.27 22:17 BST", the_date.strftime ('%Y.%m.%d %H:%M %Z'))
        self.assertEquals ("2010.10.27 21:17", utc(the_date).strftime ('%Y.%m.%d %H:%M'))
        
        the_date = dateutil.parser.parse('Wed, 27 Oct 2010 22:17:00 UTC')
        self.assertEquals ("2010.10.27 22:17 UTC", the_date.strftime ('%Y.%m.%d %H:%M %Z'))
        self.assertEquals ("2010.10.27 22:17", utc(the_date).strftime ('%Y.%m.%d %H:%M'))
        
    def test_format_date (self):
        wed = dateutil.parser.parse('Wed, 27 Oct 2010 22:17:00 BST')
        thu = dateutil.parser.parse('Thu, 28 Oct 2010 22:17:00 BST')
        
        task = Task (date_to_start=wed, date_due=thu)
        self.assertEquals ("20101027T211700Z", format_date (task, task.date_to_start, False))
        self.assertEquals ("20101028T211700Z", format_date (task, task.date_due, True))
        
        task = Task (date_to_start=wed, date_due=thu)
        task.attribs["allday"] = True
        self.assertEquals ("20101027", format_date (task, task.date_to_start, False))
        self.assertEquals ("20101029", format_date (task, task.date_due, True))
        
        wed1 = dateutil.parser.parse('Wed, 27 Oct 2010 00:00:00 BST')
        wed2 = dateutil.parser.parse('Wed, 27 Oct 2010 23:59:59 BST')
        task = Task (date_to_start=wed1, date_due=wed2)
        task.attribs["allday"] = True
        self.assertEquals ("20101027", format_date (task, task.date_to_start, False))
        self.assertEquals ("20101028", format_date (task, task.date_due, True))
        
        wed1 = dateutil.parser.parse('Wed, 27 Oct 2010 00:00:00 BST')
        wed2 = dateutil.parser.parse('Wed, 28 Oct 2010 00:00:00 BST')
        task = Task (date_to_start=wed1, date_due=wed2)
        task.attribs["allday"] = True
        self.assertEquals ("20101027", format_date (task, task.date_to_start, False))
        self.assertEquals ("20101029", format_date (task, task.date_due, True))
        
    def test_format_alarm (self):
        task = Task ()
        self.assertEquals ("BEGIN:VALARM\nACTION:DISPLAY\nDESCRIPTION:OmniFocus Reminder\nTRIGGER:-PT0M\nEND:VALARM\n", format_alarm (task))
        
        task.attribs['noalarm'] = True
        self.assertEquals ("", format_alarm (task))

        
########NEW FILE########
__FILENAME__ = test_helper
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

def catch_exception (fn):
    try:
        fn()
    except Exception as e:
        return e.message
    assert False, "Exception expected, none raised"
        
########NEW FILE########
__FILENAME__ = treemodel_test
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

from treemodel import Task, Project, Folder, Context, Visitor, traverse, traverse_list, sort
import unittest

class DemoVisitor(Visitor):
    def __init__(self):
        self.tasks_started = []
        self.tasks_ended = []
        self.projects_started = []
        self.projects_ended = []
        self.folders_started = []
        self.folders_ended = []
        self.contexts_started = []
        self.contexts_ended = []
    def begin_task (self, task):
        self.tasks_started.append(task)
    def end_task (self, task):
        self.tasks_ended.append(task)
    def begin_project (self, project):
        self.projects_started.append(project)
    def end_project (self, project):
        self.projects_ended.append(project)
    def begin_folder (self, folder):
        self.folders_started.append(folder)
    def end_folder (self, folder):
        self.folders_ended.append(folder)
    def begin_context (self, context):
        self.contexts_started.append(context)
    def end_context (self, context):
        self.contexts_ended.append(context)

class SortableTask(Task):
    def get_sort_key(self):
        return self.name

class Test_treemodel(unittest.TestCase):
    
    def test_project_add_child (self):
        project = Project ()
        child = Task ()
        project.add_child (child)
        self.assertEquals(project, child.parent)
        self.assertEquals(project, child.project)
        
        project = Project ()
        child = Task ()
        grandchild = Task ()
        child.add_child (grandchild)
        project.add_child (child)
        self.assertEquals(project, child.parent)
        self.assertEquals(project, child.project)
        self.assertEquals(project, grandchild.project)
        
    def test_task_add_child (self):
        project = Project ()
        task = Task ()
        child = Task ()
        project.add_child (task)
        task.add_child (child)
        self.assertEquals(task, child.parent)
        self.assertEquals(project, child.project)
        
        project = Project ()
        task = Task ()
        child = Task ()
        grandchild = Task ()
        project.add_child (task)
        task.add_child (child)
        child.add_child (grandchild)
        task.add_child (child)
        self.assertEquals(task, child.parent)
        self.assertEquals(project, child.project)
        self.assertEquals(child, grandchild.parent)
        self.assertEquals(project, grandchild.project)
        
    def test_context_add_child (self):
        context = Context ()
        child = Context ()
        context.add_child (child)
        self.assertEquals(context, child.parent)
        
        context = Context ()
        child = Task ()
        context.add_child (child)
        self.assertEquals(context, child.context)
        self.assertEquals(None, child.parent)
    
    def test_traverse_list_tasks (self):
        n1 = Task (name=u'n1')
        n2 = Task (name=u'n2')
        nodes = [n1,n2]
        visitor = DemoVisitor ()
        traverse_list (visitor, nodes)
        self.assertEqual(2, len(visitor.tasks_started))
        self.assertTrue(n1 in visitor.tasks_started)
        self.assertTrue(n2 in visitor.tasks_started)
        
        self.assertEqual(2, len(visitor.tasks_ended))
        self.assertTrue(n1 in visitor.tasks_ended)
        self.assertTrue(n2 in visitor.tasks_ended)
        
        self.assertEqual(0, len(visitor.projects_started))
        self.assertEqual(0, len(visitor.folders_started))
        self.assertEqual(0, len(visitor.contexts_started))
        
    def test_traverse_list_projects (self):
        n1 = Project (name=u'n1')
        n2 = Project (name=u'n2')
        nodes = [n1,n2]
        visitor = DemoVisitor ()
        traverse_list (visitor, nodes)
        self.assertEqual(2, len(visitor.projects_started))
        self.assertTrue(n1 in visitor.projects_started)
        self.assertTrue(n2 in visitor.projects_started)
        
        self.assertEqual(2, len(visitor.projects_ended))
        self.assertTrue(n1 in visitor.projects_ended)
        self.assertTrue(n2 in visitor.projects_ended)
        
        self.assertEqual(0, len(visitor.tasks_started))
        self.assertEqual(0, len(visitor.folders_started))
        self.assertEqual(0, len(visitor.contexts_started))
        
    def test_traverse_list_folders (self):
        n1 = Folder (name=u'n1')
        n2 = Folder (name=u'n2')
        nodes = [n1,n2]
        visitor = DemoVisitor ()
        traverse_list (visitor, nodes)
        self.assertEqual(2, len(visitor.folders_started))
        self.assertTrue(n1 in visitor.folders_started)
        self.assertTrue(n2 in visitor.folders_started)
        
        self.assertEqual(2, len(visitor.folders_ended))
        self.assertTrue(n1 in visitor.folders_ended)
        self.assertTrue(n2 in visitor.folders_ended)
        
        self.assertEqual(0, len(visitor.tasks_started))
        self.assertEqual(0, len(visitor.projects_started))
        self.assertEqual(0, len(visitor.contexts_started))
        
    def test_traverse_list_contexts (self):
        n1 = Context (name=u'n1')
        n2 = Context (name=u'n2')
        nodes = [n1,n2]
        visitor = DemoVisitor ()
        traverse_list (visitor, nodes)
        self.assertEqual(2, len(visitor.contexts_started))
        self.assertTrue(n1 in visitor.contexts_started)
        self.assertTrue(n2 in visitor.contexts_started)
        
        self.assertEqual(2, len(visitor.contexts_ended))
        self.assertTrue(n1 in visitor.contexts_ended)
        self.assertTrue(n2 in visitor.contexts_ended)
        
        self.assertEqual(0, len(visitor.tasks_started))
        self.assertEqual(0, len(visitor.projects_started))
        self.assertEqual(0, len(visitor.folders_started))
        
    def test_traverse_task (self):
        parent = Task (name=u'p')
        n1 = Task (name=u'n1')
        n2 = Task (name=u'n2')
        parent.children.append (n1)
        parent.children.append (n2)
        
        visitor = DemoVisitor ()
        traverse (visitor, parent)
        self.assertEqual(3, len(visitor.tasks_started))
        self.assertTrue(parent in visitor.tasks_started)
        self.assertTrue(n1 in visitor.tasks_started)
        self.assertTrue(n2 in visitor.tasks_started)
        
        self.assertEqual(3, len(visitor.tasks_ended))
        self.assertTrue(parent in visitor.tasks_ended)
        self.assertTrue(n1 in visitor.tasks_ended)
        self.assertTrue(n2 in visitor.tasks_ended)
        
    def test_traverse_task_when_not_marked (self):
        parent = Task (name=u'p')
        n1 = Task (name=u'n1')
        n2 = Task (name=u'n2')
        parent.children.append (n1)
        parent.children.append (n2)
        parent.marked = False
        
        visitor = DemoVisitor ()
        traverse (visitor, parent)
        self.assertEqual(0, len(visitor.tasks_started))
        self.assertEqual(0, len(visitor.tasks_ended))
        
    def test_traverse_project (self):
        parent = Project (name=u'p')
        n1 = Task (name=u'n1')
        n2 = Task (name=u'n2')
        parent.children.append (n1)
        parent.children.append (n2)
        
        visitor = DemoVisitor ()
        traverse (visitor, parent)
        self.assertEqual(2, len(visitor.tasks_started))
        self.assertEqual(1, len(visitor.projects_started))
        self.assertTrue(parent in visitor.projects_started)
        self.assertTrue(n1 in visitor.tasks_started)
        self.assertTrue(n2 in visitor.tasks_started)
        
        self.assertEqual(2, len(visitor.tasks_ended))
        self.assertEqual(1, len(visitor.projects_ended))
        self.assertTrue(parent in visitor.projects_ended)
        self.assertTrue(n1 in visitor.tasks_ended)
        self.assertTrue(n2 in visitor.tasks_ended)
        
    def test_traverse_project_when_not_marked (self):
        parent = Project (name=u'p')
        n1 = Task (name=u'n1')
        n2 = Task (name=u'n2')
        parent.children.append (n1)
        parent.children.append (n2)
        parent.marked = False
        
        visitor = DemoVisitor ()
        traverse (visitor, parent)
        self.assertEqual(0, len(visitor.tasks_started))
        self.assertEqual(0, len(visitor.projects_started))
        self.assertEqual(0, len(visitor.tasks_ended))
        self.assertEqual(0, len(visitor.projects_ended))
        
    def test_traverse_context (self):
        parent = Context (name=u'p')
        n1 = Task (name=u'n1')
        n2 = Task (name=u'n2')
        parent.children.append (n1)
        parent.children.append (n2)
        
        visitor = DemoVisitor ()
        traverse (visitor, parent)
        self.assertEqual(2, len(visitor.tasks_started))
        self.assertEqual(1, len(visitor.contexts_started))
        self.assertTrue(parent in visitor.contexts_started)
        self.assertTrue(n1 in visitor.tasks_started)
        self.assertTrue(n2 in visitor.tasks_started)
        
        self.assertEqual(2, len(visitor.tasks_ended))
        self.assertEqual(1, len(visitor.contexts_ended))
        self.assertTrue(parent in visitor.contexts_ended)
        self.assertTrue(n1 in visitor.tasks_ended)
        self.assertTrue(n2 in visitor.tasks_ended)
        
    def test_traverse_context_when_not_marked (self):
        parent = Context (name=u'p')
        n1 = Task (name=u'n1')
        n2 = Task (name=u'n2')
        parent.children.append (n1)
        parent.children.append (n2)
        parent.marked = False
        
        visitor = DemoVisitor ()
        traverse (visitor, parent)
        self.assertEqual(0, len(visitor.tasks_started))
        self.assertEqual(0, len(visitor.contexts_started))
        self.assertEqual(0, len(visitor.tasks_ended))
        self.assertEqual(0, len(visitor.contexts_ended))
        
    def test_traverse_folder (self):
        parent = Folder (name=u'p')
        n1 = Project (name=u'n1')
        n2 = Folder (name=u'n2')
        parent.children.append (n1)
        parent.children.append (n2)
        
        visitor = DemoVisitor ()
        traverse (visitor, parent)
        self.assertEqual(2, len(visitor.folders_started))
        self.assertEqual(1, len(visitor.projects_started))
        self.assertTrue(parent in visitor.folders_started)
        self.assertTrue(n1 in visitor.projects_started)
        self.assertTrue(n2 in visitor.folders_started)
        
        self.assertEqual(2, len(visitor.folders_ended))
        self.assertEqual(1, len(visitor.projects_ended))
        self.assertTrue(parent in visitor.folders_ended)
        self.assertTrue(n1 in visitor.projects_ended)
        self.assertTrue(n2 in visitor.folders_ended)
        
    def test_sort_order_when_sorted (self):
        parent = SortableTask (name=u'p')
        n1 = SortableTask (name=u'n1')
        n2 = SortableTask (name=u'n2')
        parent.children.append (n1)
        parent.children.append (n2)
        
        sort ([parent])
        
        self.assertEqual(n1, parent.children[0])
        self.assertEqual(n2, parent.children[1])
        
    def test_sort_order_when_unsorted (self):
        parent = SortableTask (name=u'p')
        n2 = SortableTask (name=u'n2')
        n1 = SortableTask (name=u'n1')
        parent.children.append (n1)
        parent.children.append (n2)
        
        sort ([parent])
        
        self.assertEqual(n1, parent.children[0])
        self.assertEqual(n2, parent.children[1])
        
        
########NEW FILE########
__FILENAME__ = types_test
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import unittest
from typeof import TypeOf

class Parent(object):
    pass

class Child (Parent):
    pass

class DemoClass(object):
    string = TypeOf ("string", str)
    child = TypeOf ("child", Child)
    parent = TypeOf ("parent", Parent)

class Test_typeof(unittest.TestCase):
    
    def test_field_access_when_not_set (self):
        demo = DemoClass ()
        self.assertEqual (None, demo.string)
        
    def test_field_access_when_set (self):
        demo = DemoClass ()
        demo.string = 'xxx'
        self.assertEqual ('xxx', demo.string)
        
    def test_set_to_null (self):
        demo = DemoClass ()
        demo.string = None
        self.assertEqual (None, demo.string)
        
    def test_set_to_bad_type (self):
        demo = DemoClass ()
        try:
            demo.string = 42
            self.fail('expected error')
        except AssertionError as e:
            self.assertEqual("string: expected type <type 'str'> got <type 'int'>", e.message)
            
    def test_type_hierarchy_ok (self):
        demo = DemoClass ()
        demo.child = Child ()
        demo.parent = Parent ()
        demo.parent = Child ()
       
    def test_type_hierarchy_bad (self):
        demo = DemoClass ()
        try:
            demo.child = Parent ()
            self.fail('expected error')
        except AssertionError as e:
            self.assertEqual("child: expected type <class 'types_test.Child'> got <class 'types_test.Parent'>", e.message)
        
########NEW FILE########
__FILENAME__ = util_test
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import unittest
from util import strip_tabs_newlines

class Test_util(unittest.TestCase):
    
    def test_strip_tabs_newlines (self):
        self.assertEquals ('aa bb cc dd ee', strip_tabs_newlines (' aa\nbb cc\ndd\tee'))
########NEW FILE########
__FILENAME__ = visitors_test
'''
Copyright 2013 Paul Sidnell

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
'''

import unittest
import re
from treemodel import Folder, Task, Project, Context, traverse_list, traverse, PROJECT, CONTEXT, TASK, FOLDER
from visitors import Filter, Sort

def match_name (item, regexp):
    return re.search (regexp, item.name) != None
    
class Test_visitors(unittest.TestCase):
    
    def test_include (self):
        n1 = Folder (name=u'n1')
        n2 = Folder (name=u'n2 xxx')
        nodes = [n1, n2]
        visitor = Filter ([PROJECT, CONTEXT, TASK, FOLDER], lambda x: match_name(x, 'xxx'), True, "pretty")
        traverse_list (visitor, nodes)
        self.assertFalse(n1.marked)
        self.assertTrue(n2.marked)
    
    def test_exclude (self):
        n1 = Folder (name=u'n1')
        n2 = Folder (name=u'n2 xxx')
        nodes = [n1, n2]
        visitor = Filter ([PROJECT, CONTEXT, TASK, FOLDER], lambda x: match_name(x, 'xxx'), False, 'pretty')
        traverse_list (visitor, nodes)
        self.assertTrue(n1.marked)
        self.assertFalse(n2.marked)
        
    def test__include_ignores_children (self):
        n1 = Folder (name=u'n1 xxx')
        n2 = Folder (name=u'n2')
        n1.add_child(n2)
        
        visitor = Filter ([PROJECT, CONTEXT, TASK, FOLDER], lambda x: match_name(x, 'xxx'), True, 'pretty')
        traverse (visitor, n1)
        self.assertTrue(n1.marked)
        self.assertTrue(n2.marked)
        
    def test_TaskNameFilterVisitor_include (self):
        n1 = Task (name=u'n1')
        n2 = Task (name=u'n2 xxx')
        nodes = [n1, n2]
        visitor = Filter ([PROJECT, CONTEXT, TASK, FOLDER], lambda x: match_name(x, 'xxx'), True, 'pretty')
        traverse_list (visitor, nodes)
        self.assertFalse(n1.marked)
        self.assertTrue(n2.marked)
        
    def test_TaskNameFilterVisitor_exclude (self):
        n1 = Task (name=u'n1')
        n2 = Task (name=u'n2 xxx')
        nodes = [n1, n2]
        visitor = Filter ([PROJECT, CONTEXT, TASK, FOLDER], lambda x: match_name(x, 'xxx'), False, 'pretty')
        traverse_list (visitor, nodes)
        self.assertTrue(n1.marked)
        self.assertFalse(n2.marked)
        
    def test_TaskNameFilterVisitor_include_ignores_children (self):
        n1 = Task (name=u'n1 xxx')
        n2 = Task (name=u'n2')
        n1.add_child(n2)
        
        visitor = Filter ([PROJECT, CONTEXT, TASK, FOLDER], lambda x: match_name(x, 'xxx'), True, 'pretty')
        traverse (visitor, n1)
        self.assertTrue(n1.marked)
        self.assertTrue(n2.marked)
    
    def test_Sort_in_order (self):
        n1 = Task (name=u'a n1')
        n2 = Task (name=u'b n2')
        root = Project (name=u'r')
        root.add_child(n1)
        root.add_child(n2)
        
        visitor = Sort ([PROJECT], lambda x: x.name, 'pretty')
        traverse (visitor, root)
        self.assertIs(root.children[0], n1)
        self.assertIs(root.children[1], n2)
        
    def test_Sort_out_of__order (self):
        n1 = Task (name=u'b n1')
        n2 = Task (name=u'a n2')
        root = Project (name=u'r')
        root.add_child(n1)
        root.add_child(n2)
        
        visitor = Sort ([PROJECT], lambda x: x.name, 'pretty')
        traverse (visitor, root)
        self.assertIs(root.children[0], n2)
        self.assertIs(root.children[1], n1)
        
    def test_Sort_same_use_underlying_order_in_order (self):
        n1 = Task (name=u'aaa', order=1)
        n2 = Task (name=u'aaa', order=2)
        root = Project (name=u'r')
        root.add_child(n1)
        root.add_child(n2)
        
        visitor = Sort ([PROJECT], lambda x: x.name, 'pretty')
        traverse (visitor, root)
        self.assertIs(root.children[0], n1)
        self.assertIs(root.children[1], n2)
        
    def test_Sort_same_use_underlying_order_out_of_order (self):
        n1 = Task (name=u'aaa', order=2)
        n2 = Task (name=u'aaa', order=1)
        root = Project (name=u'r')
        root.add_child(n1)
        root.add_child(n2)
        
        visitor = Sort ([PROJECT], lambda x: x.name, 'pretty')
        traverse (visitor, root)
        self.assertIs(root.children[0], n2)
        self.assertIs(root.children[1], n1)
    
    def test_Scenario_1 (self):
        '''
        In project mode select a single deeply nested task for inclusion
        '''
        f_on_path = Folder (name='1')
        p_on_path = Project (name='2', parent=f_on_path)
        t1_on_path = Task (name='3', parent=p_on_path)
        t2_selected = Task (name='xxx', parent=t1_on_path)
        t3_on_path = Task (name='5', parent=t2_selected)
        t4 = Task (name='3', parent=t1_on_path)
        
        f = Folder (name='1', parent=f_on_path)
        p = Project (name='2', parent=f)
        t1 = Task (name='3', parent=p)
        t2 = Task (name='3', parent=t1)
        t3 = Task (name='5', parent=t2)
        
        c1 = Context (name='6')
        c1.add_child(t2_selected)
        
        c2 = Context (name='7')
        c2.add_child(t3)
        
        traverse_list (Filter ([PROJECT, CONTEXT, TASK, FOLDER], lambda x: match_name(x, 'xxx'), True, 'pretty'), [f_on_path])
        
        self.assertTrue(f_on_path.marked)
        self.assertTrue(p_on_path.marked)
        self.assertTrue(t1_on_path.marked)
        self.assertTrue(t2_selected.marked)
        self.assertTrue(t3_on_path.marked)
        
        self.assertTrue(c1.marked)
        self.assertTrue(c2.marked)
        
        self.assertFalse(f.marked)
        self.assertFalse(p.marked)
        self.assertFalse(t1.marked)
        self.assertFalse(t2.marked)
        self.assertFalse(t3.marked)
        self.assertFalse(t4.marked)
        
    def test_Scenario_2 (self):
        '''
        In project mode select a single deeply nested task for exclusion
        '''
        f_on_path = Folder (name='1')
        p_on_path = Project (name='2', parent=f_on_path)
        t1_on_path = Task (name='3', parent=p_on_path)
        t2_selected = Task (name='xxx', parent=t1_on_path)
        t3_on_path = Task (name='5', parent=t2_selected)
        t4 = Task (name='3', parent=t1_on_path)
        
        f = Folder (name='1', parent=f_on_path)
        p = Project (name='2', parent=f)
        t1 = Task (name='3', parent=p)
        t2 = Task (name='3', parent=t1)
        t3 = Task (name='5', parent=t2)
        
        c1 = Context (name='6')
        c1.add_child(t2_selected)
        
        c2 = Context (name='7')
        c2.add_child(t3)
        
        traverse_list (Filter ([PROJECT, CONTEXT, TASK, FOLDER], lambda x: match_name(x, 'xxx'), False, 'pretty'), [f_on_path])
        
        self.assertTrue(f_on_path.marked)
        self.assertTrue(p_on_path.marked)
        self.assertTrue(t1_on_path.marked)
        self.assertFalse(t2_selected.marked)
        self.assertFalse(t3_on_path.marked)
        
        self.assertTrue(c1.marked)
        self.assertTrue(c2.marked)
        
        self.assertTrue(f.marked)
        self.assertTrue(p.marked)
        self.assertTrue(t1.marked)
        self.assertTrue(t2.marked)
        self.assertTrue(t3.marked)
        self.assertTrue(t4.marked)
        
    def test_Scenario_3 (self):
        '''
        In context mode select a single deeply nested task for inclusion
        '''
        f1 = Folder (name='1')
        p1 = Project (name='2', parent=f1)
        t1 = Task (name='3', parent=p1)
        t2_selected = Task (name='xxx', parent=t1)
        t3 = Task (name='5', parent=t2_selected)
        t4 = Task (name='3', parent=t1)
        
        f2 = Folder (name='1', parent=f1)
        p2 = Project (name='2', parent=f2)
        t5 = Task (name='3', parent=p2)
        t6 = Task (name='3', parent=t5)
        t7 = Task (name='5', parent=t6)
        
        
        c1_on_path = Context (name='6')
        c2_on_path = Context (name='6', parent=c1_on_path)
        c2_on_path.add_child(t2_selected)
        
        c3 = Context (name='7', parent=c2_on_path)
        
        traverse_list (Filter ([PROJECT, CONTEXT, TASK, FOLDER], lambda x: match_name(x, 'xxx'), True, 'pretty'), [c1_on_path], project_mode=False)
        
        self.assertTrue(f1.marked)
        self.assertTrue(p1.marked)
        self.assertTrue(t1.marked)
        self.assertTrue(t2_selected.marked)
        self.assertTrue(t3.marked)
        self.assertTrue(t4.marked)
        self.assertTrue(t5.marked)
        self.assertTrue(t6.marked)
        self.assertTrue(t7.marked)
        self.assertTrue(f2.marked)
        self.assertTrue(p2.marked)
        self.assertTrue(t5.marked)
        self.assertTrue(t6.marked)
        self.assertTrue(t7.marked)
        
        self.assertTrue(c1_on_path.marked)
        self.assertTrue(c2_on_path.marked)
        self.assertFalse(c3.marked)
        
    def test_Scenario_4 (self):
        '''
        In context mode select a single deeply nested task for exclusion
        '''
        f1 = Folder (name='1')
        p1 = Project (name='2', parent=f1)
        t1 = Task (name='3', parent=p1)
        t2_selected = Task (name='xxx', parent=t1)
        t3 = Task (name='5', parent=t2_selected)
        t4 = Task (name='3', parent=t1)
        
        f2 = Folder (name='1', parent=f1)
        p2 = Project (name='2', parent=f2)
        t5 = Task (name='3', parent=p2)
        t6 = Task (name='3', parent=t5)
        t7 = Task (name='5', parent=t6)
        
        
        c1_on_path = Context (name='6')
        c2_on_path = Context (name='6', parent=c1_on_path)
        c2_on_path.add_child(t2_selected)
        
        c3 = Context (name='7', parent=c2_on_path)
        
        traverse_list (Filter ([PROJECT, CONTEXT, TASK, FOLDER], lambda x: match_name(x, 'xxx'), False, 'pretty'), [c1_on_path], project_mode=False)
        
        self.assertTrue(f1.marked)
        self.assertTrue(p1.marked)
        self.assertTrue(t1.marked)
        self.assertFalse(t2_selected.marked)
        self.assertTrue(t3.marked)
        self.assertTrue(t4.marked)
        self.assertTrue(t5.marked)
        self.assertTrue(t6.marked)
        self.assertTrue(t7.marked)
        self.assertTrue(f2.marked)
        self.assertTrue(p2.marked)
        self.assertTrue(t5.marked)
        self.assertTrue(t6.marked)
        self.assertTrue(t7.marked)
        
        self.assertTrue(c1_on_path.marked)
        self.assertTrue(c2_on_path.marked)
        self.assertTrue(c3.marked)
########NEW FILE########
