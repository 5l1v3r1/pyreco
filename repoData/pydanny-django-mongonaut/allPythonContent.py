__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# django-mongonaut documentation build configuration file, created by
# sphinx-quickstart on Mon Jan  2 09:26:02 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'django-mongonaut'
copyright = u'2012, Daniel Greenfeld'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.2'
# The full version, including alpha/beta/rc tags.
release = '0.2.20'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'django-mongonautdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'django-mongonaut.tex', u'django-mongonaut Documentation',
   u'Daniel Greenfeld', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'django-mongonaut', u'django-mongonaut Documentation',
     [u'Daniel Greenfeld'], 1)
]

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

"""
The main purpose of these models is to do manual testing of
the mongonaut front end.  Do not use this code as an actual blog
backend.
"""

from mongoengine import BooleanField
from mongoengine import DateTimeField
from mongoengine import Document
from mongoengine import EmbeddedDocument
from mongoengine import EmbeddedDocumentField
from mongoengine import ListField
from mongoengine import ReferenceField
from mongoengine import StringField

from datetime import datetime


class User(Document):
    email = StringField(required=True, max_length=50)
    first_name = StringField(max_length=50)
    last_name = StringField(max_length=50)

    def __unicode__(self):
        return self.email


class Comment(EmbeddedDocument):
    message = StringField(default="DEFAULT EMBEDDED COMMENT")
    author = ReferenceField(User)

    # ListField(EmbeddedDocumentField(ListField(Something)) is not currenlty supported.
    # UI, and lists with list inside them need to be fixed.  The extra numbers appened to
    # the end of the key and class need to happen correctly.
    # Files to fix: list_add.js, forms.py, and mixins.py need to be updated to work.
    # likes = ListField(ReferenceField(User))


class EmbeddedUser(EmbeddedDocument):
    email = StringField(max_length=50, default="default-test@test.com")
    first_name = StringField(max_length=50)
    last_name = StringField(max_length=50)
    created_date = DateTimeField()  # Used for testing
    is_admin = BooleanField()  # Used for testing
    # embedded_user_bio = EmbeddedDocumentField(Comment)
    friends_list = ListField(ReferenceField(User))

    # Not supportted see above comment on Comment
    # user_comments = ListField(EmbeddedDocumentField(Comment))


class Post(Document):
    # See Post.title.max_length to make validation better!
    title = StringField(max_length=120, required=True, unique=True)
    content = StringField(default="I am default content")
    author = ReferenceField(User, required=True)
    created_date = DateTimeField()
    published = BooleanField()
    creator = EmbeddedDocumentField(EmbeddedUser)
    published_dates = ListField(DateTimeField())
    tags = ListField(StringField(max_length=30))
    past_authors = ListField(ReferenceField(User))
    comments = ListField(EmbeddedDocumentField(Comment))

    def save(self, *args, **kwargs):
        if not self.created_date:
            self.created_date = datetime.utcnow()
            if not self.creator:
                self.creator = EmbeddedUser()
                self.creator.email = self.author.email
                self.creator.first_name = self.author.first_name
                self.creator.last_name = self.author.last_name
        if self.published:
            self.published_dates.append(datetime.utcnow())
        super(Post, self).save(*args, **kwargs)

########NEW FILE########
__FILENAME__ = mongoadmin
from mongonaut.sites import MongoAdmin

from articles.models import Post, User


class PostAdmin(MongoAdmin):

    def has_view_permission(self, request):
        return True

    def has_edit_permission(self, request):
        return True

    def has_add_permission(self, request):
        return True

    def has_delete_permission(self, request):
        return True

    search_fields = ('title', 'id')
    list_fields = ('title', "published", "pub_date", "update_times")


class UserAdmin(MongoAdmin):
    def has_view_permission(self, request):
        return True

    def has_edit_permission(self, request):
        return True

    def has_add_permission(self, request):
        return True

    list_fields = ('first_name', "last_name", "email")


Post.mongoadmin = PostAdmin()
User.mongoadmin = UserAdmin()

########NEW FILE########
__FILENAME__ = test_models
from mongonaut.tests import MongoTestCase


class TestModels(MongoTestCase):

    pass

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from django.views.generic import ListView

from articles.models import Post

urlpatterns = patterns('',
    url(
        regex=r'^$',
        view=ListView.as_view(
            queryset=Post.objects.all(),
            template_name="articles/post_list.html"
        ),
        name="article_list"
    ),
)

########NEW FILE########
__FILENAME__ = views
from django.views.generic import ListView

from articles.models import Post


class PostListView(ListView):

    template_name = "articles/post_list.html"

    def get_queryset(self):
        return Post.objects.all()

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
from django.core.management import execute_manager
import imp

# lamo cheat to make work a little easier. Don't do this in other places
import sys
import os
sys.path.insert(0, os.path.abspath('../..'))
try:
    imp.find_module('settings') # Assumed to be in the same directory.
except ImportError:
    import sys
    sys.stderr.write("Error: Can't find the file 'settings.py' in the directory containing %r. It appears you've customized things.\nYou'll have to run django-admin.py, passing it your settings module.\n" % __file__)
    sys.exit(1)

import settings

if __name__ == "__main__":
    execute_manager(settings)

########NEW FILE########
__FILENAME__ = settings
# Django settings for blog project.

import os

PROJECT_ROOT = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))

DEBUG = True
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3', # Add 'postgresql_psycopg2', 'postgresql', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'dev',                      # Or path to database file if using sqlite3.
        'USER': '',                      # Not used with sqlite3.
        'PASSWORD': '',                  # Not used with sqlite3.
        'HOST': '',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# On Unix systems, a value of None will cause Django to use the same
# timezone as the operating system.
# If running in a Windows environment this must be set to the same as your
# system time zone.
TIME_ZONE = 'America/Chicago'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-us'

SITE_ID = 1

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale
USE_L10N = True

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = ''

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = ''

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = ''

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '/static/'

# URL prefix for admin static files -- CSS, JavaScript and images.
# Make sure to use a trailing slash.
# Examples: "http://foo.com/static/admin/", "/static/admin/".
ADMIN_MEDIA_PREFIX = '/static/admin/'

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# Make this unique, and don't share it with anybody.
SECRET_KEY = '7=_4bgp$qrt-1(32h27dhqv#c33cef)0yu1s()yq0=whg3kym4'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
)

ROOT_URLCONF = 'blog.urls'

TEMPLATE_DIRS = (
    os.path.join(PROJECT_ROOT.replace("examples", "examples/blog"), 'templates'),
)

INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'articles',
    'mongonaut',
)

LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'class': 'django.utils.log.AdminEmailHandler'
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['mail_admins'],
            'level': 'ERROR',
            'propagate': True,
        },
    }
}

#AUTHENTICATION_BACKENDS = (
#    'mongoengine.django.auth.MongoEngineBackend',
#)
#SESSION_ENGINE = 'mongoengine.django.sessions'

from mongoengine import connect
MONGO_DATABASE_NAME = 'example_blog'
connect(MONGO_DATABASE_NAME)


########## LOGGING CONFIGURATION
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console': {
          'level':'DEBUG',
          'class':'logging.StreamHandler',
        }
    },
    'loggers': {
        'django.request': {
            'handlers': ['console'],
            'level': 'DEBUG',
            'propagate': True,
        },
        'cn_project': {
            'handlers': ['console'],
            'level': 'DEBUG',
#            'filters': ['special']
        }
    }
}
########## END LOGGING CONFIGURATION

########## DJANGO-DEBUG CONFIGURATION
try:
    import debug_toolbar
    MIDDLEWARE_CLASSES += ('debug_toolbar.middleware.DebugToolbarMiddleware',)
    INSTALLED_APPS += ('debug_toolbar',)
    INTERNAL_IPS = ('127.0.0.1',)

    DEBUG_TOOLBAR_CONFIG = {
        'INTERCEPT_REDIRECTS': False,
        'SHOW_TEMPLATE_CONTEXT': True,
    }
except:
    pass

########## END DJANGO-DEBUG CONFIGURATION

########## DJANGO_EXTENSIONS CONFIGURATION
try:
    import django_extensions    
    INSTALLED_APPS += ('django_extensions',)
except:
    pass

########## END DJANGO_EXTENSIONS CONFIGURATION

########NEW FILE########
__FILENAME__ = testrunner
# Make our own testrunner that by default only tests our own apps

from django.conf import settings
from django.test.simple import DjangoTestSuiteRunner
from django_coverage.coverage_runner import CoverageRunner


class OurTestRunner(DjangoTestSuiteRunner):
    def build_suite(self, test_labels, *args, **kwargs):
        return super(OurTestRunner, self).build_suite(test_labels or settings.PROJECT_APPS, *args, **kwargs)


class OurCoverageRunner(OurTestRunner, CoverageRunner):
    pass

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url


urlpatterns = patterns('',
    url(r'^mongonaut/', include('mongonaut.urls')),
    url(r'^', include('articles.urls')),
)

########NEW FILE########
__FILENAME__ = exceptions
class NoMongoAdminSpecified(Exception):
    """ Called when no MongoAdmin is specified. Unlike to ever be called."""
    pass

########NEW FILE########
__FILENAME__ = forms
# -*- coding: utf-8 -*-

from django.forms import Form
from mongoengine.base import TopLevelDocumentMetaclass
from mongoengine.fields import EmbeddedDocumentField
from mongoengine.fields import ListField

from .form_mixins import MongoModelFormBaseMixin
from .form_utils import has_digit
from .form_utils import make_key
from .widgets import get_widget


class MongoModelForm(MongoModelFormBaseMixin, Form):
    """
    This class will take a model and generate a form for the model.
    Recommended use for this project only.

    Example:

    my_form = MongoModelForm(request.POST, model=self.document_type, instance=self.document).get_form()

    if self.form.is_valid():
        # Do your processing
    """

    def __init__(self, form_post_data=None, *args, **kwargs):
        """
        Overriding init so we can set the post vars like a normal form and generate
        the form the same way Django does.
        """
        kwargs.update({'form_post_data': form_post_data})
        super(MongoModelForm, self).__init__(*args, **kwargs)

    def set_fields(self):

        # Get dictionary map of current model
        if self.is_initialized:
            self.model_map_dict = self.create_document_dictionary(self.model_instance)
        else:
            self.model_map_dict = self.create_document_dictionary(self.model)

        form_field_dict = self.get_form_field_dict(self.model_map_dict)
        self.set_form_fields(form_field_dict)

    def set_post_data(self):
        # Need to set form data so that validation on all post data occurs and
        # places newly entered form data on the form object.
        self.form.data = self.post_data_dict

        # Specifically adding list field keys to the form so they are included
        # in form.cleaned_data after the call to is_valid
        for field_key, field in self.form.fields.iteritems():
            if has_digit(field_key):
                # We have a list field.
                base_key = make_key(field_key, exclude_last_string=True)

                # Add new key value with field to form fields so validation
                # will work correctly
                for key in self.post_data_dict.keys():
                    if base_key in key:
                        self.form.fields.update({key: field})

    def get_form(self):
        self.set_fields()
        if self.post_data_dict is not None:
            self.set_post_data()
        return self.form

    def create_doc_dict(self, document, doc_key=None, owner_document=None):
        """
        Generate a dictionary representation of the document.  (no recursion)

        DO NOT CALL DIRECTLY
        """
        # Get doc field for top level documents
        if owner_document:
            doc_field = owner_document._fields.get(doc_key, None) if doc_key else None
        else:
            doc_field = document._fields.get(doc_key, None) if doc_key else None

        # Generate the base fields for the document
        doc_dict = {"_document": document if owner_document is None else owner_document,
                    "_key": document.__class__.__name__.lower() if doc_key is None else doc_key,
                    "_document_field": doc_field}

        if not isinstance(document, TopLevelDocumentMetaclass) and doc_key:
            doc_dict.update({"_field_type": EmbeddedDocumentField})

        for key, field in document._fields.iteritems():
            doc_dict[key] = field

        return doc_dict

    def create_list_dict(self, document, list_field, doc_key):
        """
        Genereates a dictionary representation of the list field. Document
        should be the document the list_field comes from.

        DO NOT CALL DIRECTLY
        """
        list_dict = {"_document": document}

        if isinstance(list_field.field, EmbeddedDocumentField):
            list_dict.update(self.create_document_dictionary(document=list_field.field.document_type_obj,
                                                             owner_document=document))

        # Set the list_dict after it may have been updated
        list_dict.update({"_document_field": list_field.field,
                          "_key": doc_key,
                          "_field_type": ListField,
                          "_widget": get_widget(list_field.field),
                          "_value": getattr(document, doc_key, None)})

        return list_dict

    def create_document_dictionary(self, document, document_key=None, owner_document=None):
        """
        Given document generates a dictionary representation of the document.
        Includes the widget for each for each field in the document.
        """
        doc_dict = self.create_doc_dict(document, document_key, owner_document)

        for doc_key, doc_field in doc_dict.iteritems():
            # Base fields should not be evaluated
            if doc_key.startswith("_"):
                continue

            if isinstance(doc_field, ListField):
                doc_dict[doc_key] = self.create_list_dict(document, doc_field, doc_key)

            elif isinstance(doc_field, EmbeddedDocumentField):
                doc_dict[doc_key] = self.create_document_dictionary(doc_dict[doc_key].document_type_obj,
                                                                    doc_key)
            else:
                doc_dict[doc_key] = {"_document": document,
                                     "_key": doc_key,
                                     "_document_field": doc_field,
                                     "_widget": get_widget(doc_dict[doc_key], getattr(doc_field, 'disabled', False))}

        return doc_dict

########NEW FILE########
__FILENAME__ = form_mixins
# -*- coding: utf-8 -*-

from copy import deepcopy

from django import forms
from mongoengine.base import BaseList
from mongoengine.base import TopLevelDocumentMetaclass
from mongoengine.fields import Document
from mongoengine.fields import EmbeddedDocumentField
from mongoengine.fields import ListField
from mongoengine.fields import ReferenceField

from .form_utils import FieldTuple
from .form_utils import has_digit
from .form_utils import make_key
from .widgets import get_form_field_class
from mongonaut.utils import trim_field_key


CHECK_ATTRS = {'required': 'required',
               'help_text': 'help_text',
               'name': 'name'}


def get_document_unicode(document):
    try:
        return document.__unicode__()
    except AttributeError:
        return unicode(document)


class MongoModelFormBaseMixin(object):
    """
    For use with mongoengine.

    This mixin should not be used alone it should be used to inherit from.

    This mixin provides functionality for generating a form.  Provides 4 methods
    useful for putting data on a form:

    get_form_field_dict -- creates a keyed tuple representation of a model field used
                           to create form fields
    set_form_fields -- takes the form field dictionary and sets all values on a form
    set_form_field -- sets an individual form field
    get_field_value -- returns the value for the field

    If you inherit from this class you will need to call the above methods
    with the correct values, see forms.py for an example.
    """

    def __init__(self, model, instance=None, form_post_data=None):
        """
        Params:
            model          -- The model class to create the form with
            instance       -- An instance of the model class can be used to
                              initialize data.
            form_post_data -- Values given by request.POST
        """
        self.model = model
        self.model_instance = instance
        self.post_data_dict = form_post_data
        # Preferred for symantic checks of model_instance
        self.is_initialized = False if instance is None else True
        self.form = forms.Form()

        if not isinstance(self.model, TopLevelDocumentMetaclass):
            raise TypeError(u"The model supplied must be a mongoengine Document")

        if self.is_initialized and not isinstance(self.model_instance, self.model):
            raise TypeError(u"The provided instance must be an instance of the given model")

        if self.post_data_dict is not None and not isinstance(self.post_data_dict, dict):
            raise TypeError(u"You must pass in a dictionary for form_post_data")

    def get_form_field_dict(self, model_dict):
        """
        Takes a model dictionary representation and creates a dictionary
        keyed by form field.  Each value is a  keyed 4 tuple of:
        (widget, mode_field_instance, model_field_type, field_key)
        """
        return_dict = {}
        for field_key, field_dict in model_dict.iteritems():
            if not field_key.startswith("_"):
                widget = field_dict.get('_widget', None)
                if widget is None:
                    return_dict[field_key] = self.get_form_field_dict(field_dict)
                    return_dict[field_key].update({'_field_type': field_dict.get('_field_type', None)})
                else:
                    return_dict[field_key] = FieldTuple(widget,
                                             field_dict.get('_document_field', None),
                                             field_dict.get('_field_type', None),
                                             field_dict.get('_key', None))
        return return_dict

    def set_form_fields(self, form_field_dict, parent_key=None, field_type=None):
        """
        Set the form fields for every key in the form_field_dict.

        Params:
          form_field_dict -- a dictionary created by get_form_field_dict
          parent_key -- the key for the previous key in the recursive call
          field_type -- used to determine what kind of field we are setting
        """
        for form_key, field_value in form_field_dict.iteritems():
            form_key = make_key(parent_key, form_key) if parent_key is not None else form_key
            if isinstance(field_value, tuple):

                set_list_class = False
                base_key = form_key

                # Style list fields
                if ListField in (field_value.field_type, field_type):

                    # Nested lists/embedded docs need special care to get
                    # styles to work out nicely.
                    if parent_key is None or ListField == field_value.field_type:
                        if field_type != EmbeddedDocumentField:
                            field_value.widget.attrs['class'] += ' listField {0}'.format(form_key)
                        set_list_class = True
                    else:
                        field_value.widget.attrs['class'] += ' listField'

                    # Compute number value for list key
                    list_keys = [field_key for field_key in self.form.fields.keys()
                                           if has_digit(field_key)]

                    key_int = 0
                    while form_key in list_keys:
                        key_int += 1
                    form_key = make_key(form_key, key_int)

                if parent_key is not None:

                    # Get the base key for our embedded field class
                    valid_base_keys = [model_key for model_key in self.model_map_dict.keys()
                                                 if not model_key.startswith("_")]
                    while base_key not in valid_base_keys and base_key:
                        base_key = make_key(base_key, exclude_last_string=True)

                    # We need to remove the trailing number from the key
                    # so that grouping will occur on the front end when we have a list.
                    embedded_key_class = None
                    if set_list_class:
                        field_value.widget.attrs['class'] += " listField".format(base_key)
                        embedded_key_class = make_key(field_key, exclude_last_string=True)

                    field_value.widget.attrs['class'] += " embeddedField"

                    # Setting the embedded key correctly allows to visually nest the
                    # embedded documents on the front end.
                    if base_key == parent_key:
                        field_value.widget.attrs['class'] += ' {0}'.format(base_key)
                    else:
                        field_value.widget.attrs['class'] += ' {0} {1}'.format(base_key, parent_key)

                    if embedded_key_class is not None:
                        field_value.widget.attrs['class'] += ' {0}'.format(embedded_key_class)

                default_value = self.get_field_value(form_key)

                # Style embedded documents
                if isinstance(default_value, list) and len(default_value) > 0:
                    key_index = int(form_key.split("_")[-1])
                    new_base_key = make_key(form_key, exclude_last_string=True)

                    for list_value in default_value:
                        # Note, this is copied every time so each widget gets a different class
                        list_widget = deepcopy(field_value.widget)
                        new_key = make_key(new_base_key, unicode(key_index))
                        list_widget.attrs['class'] += " {0}".format(make_key(base_key, key_index))
                        self.set_form_field(list_widget, field_value.document_field, new_key, list_value)
                        key_index += 1
                else:
                    self.set_form_field(field_value.widget, field_value.document_field,
                                        form_key, default_value)

            elif isinstance(field_value, dict):
                self.set_form_fields(field_value, form_key, field_value.get("_field_type", None))

    def set_form_field(self, widget, model_field, field_key, default_value):
        """
        Parmams:
            widget -- the widget to use for displyaing the model_field
            model_field -- the field on the model to create a form field with
            field_key -- the name for the field on the form
            default_value -- the value to give for the field
                             Default: None
        """
        # Empty lists cause issues on form validation
        if default_value == []:
            default_value = None

        if widget and isinstance(widget, forms.widgets.Select):
            self.form.fields[field_key] = forms.ChoiceField(label=model_field.name,
                                                            required=model_field.required,
                                                            widget=widget)
        else:
            field_class = get_form_field_class(model_field)
            self.form.fields[field_key] = field_class(label=model_field.name,
                                                      required=model_field.required,
                                                      widget=widget)

        if default_value is not None:
            if isinstance(default_value, Document):
                # Probably a reference field, therefore, add id
                self.form.fields[field_key].initial = getattr(default_value, 'id', None)
            else:
                self.form.fields[field_key].initial = default_value
        else:
            self.form.fields[field_key].initial = getattr(model_field, 'default', None)

        if isinstance(model_field, ReferenceField):
            self.form.fields[field_key].choices = [(unicode(x.id), get_document_unicode(x))
                                                    for x in model_field.document_type.objects.all()]
            # Adding in blank choice so a reference field can be deleted by selecting blank
            self.form.fields[field_key].choices.insert(0, ("", ""))

        elif model_field.choices:
            self.form.fields[field_key].choices = model_field.choices

        for key, form_attr in CHECK_ATTRS.items():
            if hasattr(model_field, key):
                value = getattr(model_field, key)
                setattr(self.form.fields[field_key], key, value)

    def get_field_value(self, field_key):
        """
        Given field_key will return value held at self.model_instance.  If
        model_instance has not been provided will return None.
        """

        def get_value(document, field_key):
            # Short circuit the function if we do not have a document
            if document is None:
                return None

            current_key, new_key_array = trim_field_key(document, field_key)
            key_array_digit = int(new_key_array[-1]) if new_key_array and has_digit(new_key_array) else None
            new_key = make_key(new_key_array)

            if key_array_digit is not None and len(new_key_array) > 0:
                # Handleing list fields
                if len(new_key_array) == 1:
                    return_data = document._data.get(current_key, [])
                elif isinstance(document, BaseList):
                    return_list = []
                    if len(document) > 0:
                        return_list = [get_value(doc, new_key) for doc in document]
                    return_data = return_list
                else:
                    return_data = get_value(getattr(document, current_key), new_key)

            elif len(new_key_array) > 0:
                return_data = get_value(document._data.get(current_key), new_key)
            else:
                # Handeling all other fields and id
                return_data = (document._data.get(None, None) if current_key == "id" else
                              document._data.get(current_key, None))
            return return_data

        if self.is_initialized:
            return get_value(self.model_instance, field_key)
        else:
            return None

########NEW FILE########
__FILENAME__ = form_utils
# -*- coding: utf-8 -*-

"""
Used as a utility class for functions related to
form manipulation.
"""

from collections import namedtuple


# Used by form_mixin processing to allow named access to
# field elements in the tuple.
FieldTuple = namedtuple('FieldTuple', 'widget document_field field_type key')


def has_digit(string_or_list, sep="_"):
    """
    Given a string or a list will return true if the last word or
    element is a digit.  sep is used when a string is given to know
    what separates one word from another.
    """
    if isinstance(string_or_list, list):
        list_length = len(string_or_list)
        return unicode(string_or_list[-1]).isdigit() if list_length > 0 else False
    else:
        return has_digit(string_or_list.split(sep))


def make_key(*args, **kwargs):
    """
    Given any number of lists and strings will join them in order as one
    string separated by the sep kwarg.  sep defaults to u"_".

    Add exclude_last_string=True as a kwarg to exclude the last item in a
    given string after being split by sep.  Note if you only have one word
    in your string you can end up getting an empty string.

    Example uses:

    >>> from mongonaut.forms.form_utils import make_key
    >>> make_key('hi', 'my', 'firend')
    >>> u'hi_my_firend'

    >>> make_key('hi', 'my', 'firend', sep='i')
    >>> 'hiimyifirend'

    >>> make_key('hi', 'my', 'firend',['this', 'be', 'what'], sep='i')
    >>> 'hiimyifirendithisibeiwhat'

    >>> make_key('hi', 'my', 'firend',['this', 'be', 'what'])
    >>> u'hi_my_firend_this_be_what'

    """
    sep = kwargs.get('sep', u"_")
    exclude_last_string = kwargs.get('exclude_last_string', False)
    string_array = []

    for arg in args:
        if isinstance(arg, list):
            string_array.append(unicode(sep.join(arg)))
        else:
            if exclude_last_string:
                new_key_array = arg.split(sep)[:-1]
                if len(new_key_array) > 0:
                    string_array.append(make_key(new_key_array))
            else:
                string_array.append(unicode(arg))
    return sep.join(string_array)

########NEW FILE########
__FILENAME__ = widgets
# -*- coding: utf-8 -*-

""" Widgets for mongonaut forms"""

from django import forms

from mongoengine.base import ObjectIdField
from mongoengine.fields import BooleanField
from mongoengine.fields import DateTimeField
from mongoengine.fields import EmbeddedDocumentField
from mongoengine.fields import ListField
from mongoengine.fields import ReferenceField
from mongoengine.fields import FloatField
from mongoengine.fields import EmailField
from mongoengine.fields import DecimalField
from mongoengine.fields import URLField
from mongoengine.fields import IntField
from mongoengine.fields import StringField


def get_widget(model_field, disabled=False):

    attrs = get_attrs(model_field, disabled)

    if hasattr(model_field, "max_length") and not model_field.max_length:
        return forms.Textarea(attrs=attrs)

    elif isinstance(model_field, DateTimeField):
        return forms.DateTimeInput(attrs=attrs)

    elif isinstance(model_field, BooleanField):
        return forms.CheckboxInput(attrs=attrs)

    elif isinstance(model_field, ReferenceField) or model_field.choices:
        return forms.Select(attrs=attrs)

    elif isinstance(model_field, ListField) or isinstance(model_field, EmbeddedDocumentField):
        return None

    else:
        return forms.TextInput(attrs=attrs)


def get_attrs(model_field, disabled=False):
    attrs = {}
    attrs['class'] = 'span6 xlarge'
    if disabled or isinstance(model_field, ObjectIdField):
        attrs['class'] += ' disabled'
        attrs['readonly'] = 'readonly'
    return attrs


def get_form_field_class(model_field):
    """Gets the default form field  for a mongoenigne field."""

    FIELD_MAPPING = {
        IntField: forms.IntegerField,
        StringField: forms.CharField,
        FloatField: forms.FloatField,
        BooleanField: forms.BooleanField,
        DateTimeField: forms.DateTimeField,
        DecimalField: forms.DecimalField,
        URLField: forms.URLField,
        EmailField: forms.EmailField
    }

    return FIELD_MAPPING.get(model_field.__class__, forms.CharField)

########NEW FILE########
__FILENAME__ = mixins
# -*- coding: utf-8 -*-

from django.conf import settings
from django.contrib import messages
from django.http import HttpResponseForbidden
from django.utils.importlib import import_module
from mongoengine.fields import EmbeddedDocumentField

from mongonaut.exceptions import NoMongoAdminSpecified
from mongonaut.forms import MongoModelForm
from mongonaut.forms.form_utils import has_digit
from mongonaut.forms.form_utils import make_key
from mongonaut.utils import translate_value
from mongonaut.utils import trim_field_key


class AppStore(object):

    def __init__(self, module):
        self.models = []
        for key in module.__dict__.keys():
            model_candidate = getattr(module, key)
            if hasattr(model_candidate, 'mongoadmin'):
                self.add_model(model_candidate)

    def add_model(self, model):
        model.name = model.__name__
        self.models.append(model)


class MongonautViewMixin(object):

    def render_to_response(self, context, **response_kwargs):
        if hasattr(self, 'permission') and not self.request.user.has_perm(self.permission):
            return HttpResponseForbidden("You do not have permissions to access this content.")

        return self.response_class(
            request=self.request,
            template=self.get_template_names(),
            context=context,
            **response_kwargs
        )

    def get_context_data(self, **kwargs):
        context = super(MongonautViewMixin, self).get_context_data(**kwargs)
        context['MONGONAUT_JQUERY'] = getattr(settings, "MONGONAUT_JQUERY",
                                      "http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js")
        context['MONGONAUT_TWITTER_BOOTSTRAP'] = getattr(settings, "MONGONAUT_TWITTER_BOOTSTRAP",
                                                 "//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css")
        context['MONGONAUT_TWITTER_BOOTSTRAP_ALERT'] = getattr(settings,
                                                               "MONGONAUT_TWITTER_BOOTSTRAP_ALERT",
                                                       "//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min")
        return context

    def get_mongoadmins(self):
        """ Returns a list of all mongoadmin implementations for the site """
        apps = []
        for app_name in settings.INSTALLED_APPS:
            mongoadmin = "{0}.mongoadmin".format(app_name)
            try:
                module = import_module(mongoadmin)
            except ImportError as e:
                if str(e).startswith("No module named"):
                    continue
                raise e

            app_store = AppStore(module)
            apps.append(dict(
                app_name=app_name,
                obj=app_store
            ))
        return apps

    def set_mongonaut_base(self):
        """ Sets a number of commonly used attributes """
        if hasattr(self, "app_label"):
            # prevents us from calling this multiple times
            return None
        self.app_label = self.kwargs.get('app_label')
        self.document_name = self.kwargs.get('document_name')

        # TODO Allow this to be assigned via url variable
        self.models_name = self.kwargs.get('models_name', 'models')

        # import the models file
        self.model_name = "{0}.{1}".format(self.app_label, self.models_name)
        self.models = import_module(self.model_name)

    def set_mongoadmin(self):
        """ Returns the MongoAdmin object for an app_label/document_name style view
        """
        if hasattr(self, "mongoadmin"):
            return None

        if not hasattr(self, "document_name"):
            self.set_mongonaut_base()

        for mongoadmin in self.get_mongoadmins():
            for model in mongoadmin['obj'].models:
                if model.name == self.document_name:
                    self.mongoadmin = model.mongoadmin
                    break
        # TODO change this to use 'finally' or 'else' or something
        if not hasattr(self, "mongoadmin"):
            raise NoMongoAdminSpecified("No MongoAdmin for {0}.{1}".format(self.app_label, self.document_name))

    def set_permissions_in_context(self, context={}):
        """ Provides permissions for mongoadmin for use in the context"""

        context['has_view_permission'] = self.mongoadmin.has_view_permission(self.request)
        context['has_edit_permission'] = self.mongoadmin.has_edit_permission(self.request)
        context['has_add_permission'] = self.mongoadmin.has_add_permission(self.request)
        context['has_delete_permission'] = self.mongoadmin.has_delete_permission(self.request)
        return context


class MongonautFormViewMixin(object):
    """
    View used to help with processing of posted forms.
    Must define self.document_type for process_post_form to work.
    """

    def process_post_form(self, success_message=None):
        """
        As long as the form is set on the view this method will validate the form
        and save the submitted data.  Only call this if you are posting data.
        The given success_message will be used with the djanog messages framework
        if the posted data sucessfully submits.
        """

        # When on initial args are given we need to set the base document.
        if not hasattr(self, 'document') or self.document is None:
            self.document = self.document_type()
        self.form = MongoModelForm(model=self.document_type, instance=self.document,
                                   form_post_data=self.request.POST).get_form()
        self.form.is_bound = True
        if self.form.is_valid():

            self.document_map_dict = MongoModelForm(model=self.document_type).create_document_dictionary(self.document_type)
            self.new_document = self.document_type

            # Used to keep track of embedded documents in lists.  Keyed by the list and the number of the
            # document.
            self.embedded_list_docs = {}

            if self.new_document is None:
                messages.error(self.request, u"Failed to save document")
            else:
                self.new_document = self.new_document()

                for form_key in self.form.cleaned_data.keys():
                    if form_key == 'id' and hasattr(self, 'document'):
                        self.new_document.id = self.document.id
                        continue
                    self.process_document(self.new_document, form_key, None)

                self.new_document.save()
                if success_message:
                    messages.success(self.request, success_message)

        return self.form

    def process_document(self, document, form_key, passed_key):
        """
        Given the form_key will evaluate the document and set values correctly for
        the document given.
        """
        if passed_key is not None:
            current_key, remaining_key_array = trim_field_key(document, passed_key)
        else:
            current_key, remaining_key_array = trim_field_key(document, form_key)

        key_array_digit = remaining_key_array[-1] if remaining_key_array and has_digit(remaining_key_array) else None
        remaining_key = make_key(remaining_key_array)

        if current_key.lower() == 'id':
            raise KeyError(u"Mongonaut does not work with models which have fields beginning with id_")

        # Create boolean checks to make processing document easier
        is_embedded_doc = (isinstance(document._fields.get(current_key, None), EmbeddedDocumentField)
                          if hasattr(document, '_fields') else False)
        is_list = not key_array_digit is None
        key_in_fields = current_key in document._fields.keys() if hasattr(document, '_fields') else False

        # This ensures you only go through each documents keys once, and do not duplicate data
        if key_in_fields:
            if is_embedded_doc:
                self.set_embedded_doc(document, form_key, current_key, remaining_key)
            elif is_list:
                self.set_list_field(document, form_key, current_key, remaining_key, key_array_digit)
            else:
                value = translate_value(document._fields[current_key],
                                        self.form.cleaned_data[form_key])
                setattr(document, current_key, value)

    def set_embedded_doc(self, document, form_key, current_key, remaining_key):

        # Get the existing embedded document if it exists, else created it.
        embedded_doc = getattr(document, current_key, False)
        if not embedded_doc:
            embedded_doc = document._fields[current_key].document_type_obj()

        new_key, new_remaining_key_array = trim_field_key(embedded_doc, remaining_key)
        self.process_document(embedded_doc, form_key, make_key(new_key, new_remaining_key_array))
        setattr(document, current_key, embedded_doc)

    def set_list_field(self, document, form_key, current_key, remaining_key, key_array_digit):

        document_field = document._fields.get(current_key)

        # Figure out what value the list ought to have
        # None value for ListFields make mongoengine very un-happy
        list_value = translate_value(document_field.field, self.form.cleaned_data[form_key])
        if list_value is None or (not list_value and not bool(list_value)):
            return None

        current_list = getattr(document, current_key, None)

        if isinstance(document_field.field, EmbeddedDocumentField):
            embedded_list_key = u"{0}_{1}".format(current_key, key_array_digit)

            # Get the embedded document if it exists, else create it.
            embedded_list_document = self.embedded_list_docs.get(embedded_list_key, None)
            if embedded_list_document is None:
                embedded_list_document = document_field.field.document_type_obj()

            new_key, new_remaining_key_array = trim_field_key(embedded_list_document, remaining_key)
            self.process_document(embedded_list_document, form_key, new_key)

            list_value = embedded_list_document
            self.embedded_list_docs[embedded_list_key] = embedded_list_document

            if isinstance(current_list, list):
                # Do not add the same document twice
                if embedded_list_document not in current_list:
                    current_list.append(embedded_list_document)
            else:
                setattr(document, current_key, [embedded_list_document])

        elif isinstance(current_list, list):
            current_list.append(list_value)
        else:
            setattr(document, current_key, [list_value])

########NEW FILE########
__FILENAME__ = models
""" Here because Django requires this as boilerplate. """

########NEW FILE########
__FILENAME__ = sites
try:
    import floppyforms as forms
except ImportError:
    from django import forms


class BaseMongoAdmin(object):

    search_fields = []

    # Show the fields to be displayed as columns
    # TODO: Confirm that this is what the Django admin uses
    list_fields = []

    #This shows up on the DocumentListView of the Posts
    list_actions = []

    # This shows up in the DocumentDetailView of the Posts.
    document_actions = []

    # shows up on a particular field
    field_actions = {}

    fields = None
    exclude = None
    fieldsets = None
    form = forms.ModelForm
    filter_vertical = ()
    filter_horizontal = ()
    radio_fields = {}
    prepopulated_fields = {}
    formfield_overrides = {}
    readonly_fields = ()
    ordering = None

    def has_view_permission(self, request):
        """
        Returns True if the given HttpRequest has permission to view
        *at least one* page in the mongonaut site.
        """
        return request.user.is_authenticated() and request.user.is_active

    def has_edit_permission(self, request):
        """ Can edit this object """
        return request.user.is_authenticated() and request.user.is_active and request.user.is_staff

    def has_add_permission(self, request):
        """ Can add this object """
        return request.user.is_authenticated() and request.user.is_active and request.user.is_staff

    def has_delete_permission(self, request):
        """ Can delete this object """
        return request.user.is_authenticated() and request.user.is_active and request.user.is_superuser


class MongoAdmin(BaseMongoAdmin):

    list_display = ('__str__',)
    list_display_links = ()
    list_filter = ()
    list_select_related = False
    list_per_page = 100
    list_max_show_all = 200
    list_editable = ()
    search_fields = ()
    save_as = False
    save_on_top = False
########NEW FILE########
__FILENAME__ = mongonaut_tags
# -*- coding: utf-8 -*-

from django import template
from django.core.urlresolvers import reverse

from django.utils.safestring import mark_safe

from bson.objectid import ObjectId
from mongoengine import Document
from mongoengine.fields import URLField

register = template.Library()


@register.simple_tag()
def get_document_value(document, key):
    value = getattr(document, key)
    if isinstance(value, ObjectId):
        return value

    if isinstance(document._fields.get(key), URLField):
        return mark_safe("""<a href="{0}">{1}</a>""".format(value, value))

    if isinstance(value, Document):
        app_label = value.__module__.replace(".models", "")
        document_name = value._class_name
        url = reverse("document_detail", kwargs={'app_label': app_label, 'document_name': document_name, 'id': value.id})
        return mark_safe("""<a href="{0}">{1}</a>""".format(url, value.__unicode__()))

    return value

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


from mongonaut import views

urlpatterns = patterns('',
    url(
        regex=r'^$',
        view=views.IndexView.as_view(),
        name="index"
    ),
    url(
        regex=r'^(?P<app_label>[_\-\w]+)/(?P<document_name>[_\-\w]+)/$',
        view=views.DocumentListView.as_view(),
        name="document_list"
    ),
    url(
        regex=r'^(?P<app_label>[_\-\w]+)/(?P<document_name>[_\-\w]+)/add/$',
        view=views.DocumentAddFormView.as_view(),
        name="document_detail_add_form"
    ),
    url(
        regex=r'^(?P<app_label>[_\-\w]+)/(?P<document_name>[_\-\w]+)/(?P<id>[\w]+)/$',
        view=views.DocumentDetailView.as_view(),
        name="document_detail"
    ),
    url(
        regex=r'^(?P<app_label>[_\-\w]+)/(?P<document_name>[_\-\w]+)/(?P<id>[\w]+)/edit/$',
        view=views.DocumentEditFormView.as_view(),
        name="document_detail_edit_form"
    ),
    url(
        regex=r'^(?P<app_label>[_\-\w]+)/(?P<document_name>[_\-\w]+)/(?P<id>[\w]+)/delete/$',
        view=views.DocumentDeleteView.as_view(),
        name="document_delete"
    )
)

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-

from mongoengine.base import ObjectIdField, ValidationError
from mongoengine.fields import ReferenceField

# Used to validate object_ids.
# Called by is_valid_object_id
OBJECT_ID = ObjectIdField()


def is_valid_object_id(value):
    try:
        OBJECT_ID.validate(value)
        return True
    except ValidationError:
        return False


def translate_value(document_field, form_value):
    """
    Given a document_field and a form_value this will translate the value
    to the correct result for mongo to use.
    """
    value = form_value
    if isinstance(document_field, ReferenceField):
        value = document_field.document_type.objects.get(id=form_value) if form_value else None
    return value


def trim_field_key(document, field_key):
    """
    Returns the smallest delimited version of field_key that
    is an attribute on document.

    return (key, left_over_array)
    """
    trimming = True
    left_over_key_values = []
    current_key = field_key
    while trimming and current_key:
        if hasattr(document, current_key):
            trimming = False
        else:
            key_array = current_key.split("_")
            left_over_key_values.append(key_array.pop())
            current_key = u"_".join(key_array)

    left_over_key_values.reverse()
    return current_key, left_over_key_values

########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-
"""
TODO move permission checks to the dispatch view thingee
"""

from django.contrib import messages
from django.core.urlresolvers import reverse
from django.forms import Form
from django.http import HttpResponseForbidden
from django.http import Http404
from django.views.generic.edit import DeletionMixin
from django.views.generic import ListView
from django.views.generic import TemplateView
from django.views.generic.edit import FormView
from mongoengine.fields import EmbeddedDocumentField, ListField

from mongonaut.forms import MongoModelForm
from mongonaut.mixins import MongonautFormViewMixin
from mongonaut.mixins import MongonautViewMixin
from mongonaut.utils import is_valid_object_id


class IndexView(MongonautViewMixin, ListView):

    template_name = "mongonaut/index.html"
    queryset = []
    permission = 'has_view_permission'

    def get_queryset(self):
        return self.get_mongoadmins()


class AppListView(MongonautViewMixin, ListView):
    """ :args: <app_label> """

    template_name = "mongonaut/app_list.html"


class DocumentListView(MongonautViewMixin, FormView):
    """ :args: <app_label> <document_name>

        TODO - Make a generic document fetcher method
    """
    form_class = Form
    success_url = '/'
    template_name = "mongonaut/document_list.html"
    permission = 'has_view_permission'

    documents_per_page = 25

    #def dispatch(self, *args, **kwargs):
    #    self.set_mongoadmin()
    #    self.set_permissions()
    #    return super(DocumentListView, self).dispatch(*args, **kwargs)

    def get_qset(self, queryset, q):
        if self.mongoadmin.search_fields and q:
            params = {}
            for field in self.mongoadmin.search_fields:
                if field == 'id':
                    # check to make sure this is a valid ID, otherwise we just continue
                    if is_valid_object_id(q):
                        return queryset.filter(pk=q)
                    continue
                search_key = "{field}__icontains".format(field=field)
                params[search_key] = q

            queryset = queryset.filter(**params)
        return queryset

    def get_queryset(self):
        if hasattr(self, "queryset") and self.queryset:
            return self.queryset

        self.set_mongonaut_base()
        self.set_mongoadmin()
        self.document = getattr(self.models, self.document_name)
        queryset = self.document.objects.all()

        if self.mongoadmin.ordering:
            queryset = queryset.order_by(*self.mongoadmin.ordering)

        # search. move this to get_queryset
        # search. move this to get_queryset
        q = self.request.GET.get('q')
        queryset = self.get_qset(queryset, q)

        ### Start pagination
        ### Note:
        ###    Didn't use the Paginator in Django cause mongoengine querysets are
        ###    not the same as Django ORM querysets and it broke.
        # Make sure page request is an int. If not, deliver first page.
        try:
            self.page = int(self.request.GET.get('page', '1'))
        except ValueError:
            self.page = 1

        obj_count = queryset.count()
        self.total_pages = obj_count / self.documents_per_page + (1 if obj_count % self.documents_per_page else 0)

        if self.page < 1:
            self.page = 1

        if self.page > self.total_pages:
            self.page = self.total_pages

        start = (self.page - 1) * self.documents_per_page
        end = self.page * self.documents_per_page

        queryset = queryset[start:end] if obj_count else queryset

        self.queryset = queryset
        return queryset

    def get_initial(self):
        self.query = self.get_queryset()
        mongo_ids = {'mongo_id': [unicode(x.id) for x in self.query]}
        return mongo_ids

    def get_context_data(self, **kwargs):
        context = super(DocumentListView, self).get_context_data(**kwargs)
        context = self.set_permissions_in_context(context)

        if not context['has_view_permission']:
            return HttpResponseForbidden("You do not have permissions to view this content.")

        context['object_list'] = self.get_queryset()

        context['document'] = self.document
        context['app_label'] = self.app_label
        context['document_name'] = self.document_name

        # pagination bits
        context['page'] = self.page
        context['documents_per_page'] = self.documents_per_page

        if self.page > 1:
            previous_page_number = self.page - 1
        else:
            previous_page_number = None

        if self.page < self.total_pages:
            next_page_number = self.page + 1
        else:
            next_page_number = None

        context['previous_page_number'] = previous_page_number
        context['has_previous_page'] = previous_page_number is not None
        context['next_page_number'] = next_page_number
        context['has_next_page'] = next_page_number is not None
        context['total_pages'] = self.total_pages

        # Part of upcoming list view form functionality
        if self.queryset.count():
            context['keys'] = ['id', ]

            # Show those items for which we've got list_fields on the mongoadmin
            for key in [x for x in self.mongoadmin.list_fields if x != 'id' and x in self.document._fields.keys()]:

                # TODO - Figure out why this EmbeddedDocumentField and ListField breaks this view
                # Note - This is the challenge part, right? :)
                if isinstance(self.document._fields[key], EmbeddedDocumentField):
                    continue
                if isinstance(self.document._fields[key], ListField):
                    continue
                context['keys'].append(key)

        if self.mongoadmin.search_fields:
            context['search_field'] = True

        return context

    def post(self, request, *args, **kwargs):
        # TODO - make sure to check the rights of the poster
        #self.get_queryset() # TODO - write something that grabs the document class better
        form_class = self.get_form_class()
        form = self.get_form(form_class)
        mongo_ids = self.get_initial()['mongo_id']
        for form_mongo_id in form.data.getlist('mongo_id'):
            for mongo_id in mongo_ids:
                if form_mongo_id == mongo_id:
                    self.document.objects.get(pk=mongo_id).delete()

        return self.form_invalid(form)


class DocumentDetailView(MongonautViewMixin, TemplateView):
    """ :args: <app_label> <document_name> <id> """
    template_name = "mongonaut/document_detail.html"
    permission = 'has_view_permission'

    def get_context_data(self, **kwargs):
        context = super(DocumentDetailView, self).get_context_data(**kwargs)
        self.set_mongoadmin()
        context = self.set_permissions_in_context(context)
        self.document_type = getattr(self.models, self.document_name)
        self.ident = self.kwargs.get('id')
        self.document = self.document_type.objects.get(pk=self.ident)

        context['document'] = self.document
        context['app_label'] = self.app_label
        context['document_name'] = self.document_name
        context['keys'] = ['id', ]
        context['embedded_documents'] = []
        context['list_fields'] = []
        for key in sorted([x for x in self.document._fields.keys() if x != 'id']):
            # TODO - Figure out why this EmbeddedDocumentField and ListField breaks this view
            # Note - This is the challenge part, right? :)
            if isinstance(self.document._fields[key], EmbeddedDocumentField):
                context['embedded_documents'].append(key)
                continue
            if isinstance(self.document._fields[key], ListField):
                context['list_fields'].append(key)
                continue
            context['keys'].append(key)
        return context


class DocumentEditFormView(MongonautViewMixin, FormView, MongonautFormViewMixin):
    """ :args: <app_label> <document_name> <id> """

    template_name = "mongonaut/document_edit_form.html"
    form_class = Form
    success_url = '/'
    permission = 'has_edit_permission'

    def get_success_url(self):
        self.set_mongonaut_base()
        return reverse('document_detail_edit_form', kwargs={'app_label': self.app_label, 'document_name': self.document_name, 'id': self.kwargs.get('id')})

    def get_context_data(self, **kwargs):
        context = super(DocumentEditFormView, self).get_context_data(**kwargs)
        self.set_mongoadmin()
        context = self.set_permissions_in_context(context)
        self.document_type = getattr(self.models, self.document_name)
        self.ident = self.kwargs.get('id')
        self.document = self.document_type.objects.get(pk=self.ident)

        context['document'] = self.document
        context['app_label'] = self.app_label
        context['document_name'] = self.document_name
        context['form_action'] = reverse('document_detail_edit_form', args=[self.kwargs.get('app_label'),
                                                                            self.kwargs.get('document_name'),
                                                                            self.kwargs.get('id')])

        return context

    def get_form(self, Form):
        self.set_mongoadmin()
        context = self.set_permissions_in_context({})

        if not context['has_edit_permission']:
            return HttpResponseForbidden("You do not have permissions to edit this content.")

        self.document_type = getattr(self.models, self.document_name)
        self.ident = self.kwargs.get('id')
        try:
            self.document = self.document_type.objects.get(pk=self.ident)
        except self.document_type.DoesNotExist:
            raise Http404
        self.form = Form()

        if self.request.method == 'POST':
            self.form = self.process_post_form('Your changes have been saved.')
        else:
            self.form = MongoModelForm(model=self.document_type, instance=self.document).get_form()
        return self.form


class DocumentAddFormView(MongonautViewMixin, FormView, MongonautFormViewMixin):
    """ :args: <app_label> <document_name> <id> """

    template_name = "mongonaut/document_add_form.html"
    form_class = Form
    success_url = '/'
    permission = 'has_add_permission'

    def get_success_url(self):
        self.set_mongonaut_base()
        return reverse('document_detail', kwargs={'app_label': self.app_label, 'document_name': self.document_name, 'id': str(self.new_document.id)})

    def get_context_data(self, **kwargs):
        """ TODO - possibly inherit this from DocumentEditFormView. This is same thing minus:
            self.ident = self.kwargs.get('id')
            self.document = self.document_type.objects.get(pk=self.ident)
        """
        context = super(DocumentAddFormView, self).get_context_data(**kwargs)
        self.set_mongoadmin()
        context = self.set_permissions_in_context(context)
        self.document_type = getattr(self.models, self.document_name)

        context['app_label'] = self.app_label
        context['document_name'] = self.document_name
        context['form_action'] = reverse('document_detail_add_form', args=[self.kwargs.get('app_label'),
                                                                           self.kwargs.get('document_name')])

        return context

    def get_form(self, Form):
        self.set_mongonaut_base()
        self.document_type = getattr(self.models, self.document_name)
        self.form = Form()

        if self.request.method == 'POST':
            self.form = self.process_post_form('Your new document has been added and saved.')
        else:
            self.form = MongoModelForm(model=self.document_type).get_form()
        return self.form


class DocumentDeleteView(DeletionMixin, MongonautViewMixin, TemplateView):
    """ :args: <app_label> <document_name> <id>

        TODO - implement a GET view for confirmation
    """

    success_url = "/"
    template_name = "mongonaut/document_delete.html"

    def get_success_url(self):
        self.set_mongonaut_base()
        messages.add_message(self.request, messages.INFO, 'Your document has been deleted.')
        return reverse('document_list', kwargs={'app_label': self.app_label, 'document_name': self.document_name})

    def get_object(self):
        self.set_mongoadmin()
        self.document_type = getattr(self.models, self.document_name)
        self.ident = self.kwargs.get('id')
        self.document = self.document_type.objects.get(pk=self.ident)
        return self.document

########NEW FILE########
__FILENAME__ = utils
#coding: utf-8
"""
 Copied exactly from https://github.com/hmarr/mongoengine/blob/master/mongoengine/django/tests.py

"""
import os
os.environ['DJANGO_SETTINGS_MODULE'] = 'examples.blog.settings'

import unittest
from django.test import TestCase, RequestFactory
from django.conf import settings

from mongoengine import connect

class MongoTestCase(TestCase):
    """
    TestCase class that clear the collection between the tests
    """
    db_name = 'test_%s' % settings.MONGO_DATABASE_NAME

    def __init__(self, methodName='runtest'):
        self.db = connect(self.db_name)
        super(MongoTestCase, self).__init__(methodName)

    def _post_teardown(self):
        super(MongoTestCase, self)._post_teardown()
        self.db.drop_database(self.db_name)

class DummyUser(object):

    def __init__(self, is_authenticated = True, is_active=True,
                    can_view=True, is_staff=True, is_superuser=False,
                 has_perm=['has_view_permission']):
        self._is_authenticated = is_authenticated
        self._is_active = is_active
        self._is_staff = is_staff
        self._is_superuser = is_superuser
        self._has_perm = has_perm

    def is_authenticated(self):
        return self._is_authenticated

    def has_perm(self, perm):
        return perm in self._has_perm

    @property
    def is_active(self):
        return self._is_active

    @property
    def is_staff(self):
        return self._is_staff

    @property
    def is_superuser(self):
        return self._is_superuser

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python

import sys
import os

if sys.hexversion < 0x02070000:
     import unittest2 as unittest 
else: 
    import unittest 


#set path
TEST_ROOT = os.path.dirname(__file__)
PROJECT_ROOT = os.path.join(TEST_ROOT, '..')
BLOG_ROOT = os.path.join(PROJECT_ROOT, 'examples','blog')

sys.path.append(PROJECT_ROOT)
sys.path.append(BLOG_ROOT) #we are using settings.py from the example

#Ensure Django is configured to use our example site
os.environ['DJANGO_SETTINGS_MODULE'] = 'examples.blog.settings'


#run the tests
tests = unittest.defaultTestLoader.discover(TEST_ROOT, pattern='*_tests.py')
runner = unittest.TextTestRunner(verbosity=2)
result = runner.run(unittest.TestSuite(tests))

########NEW FILE########
__FILENAME__ = sites_tests
#coding: utf-8
import unittest
from django.test import RequestFactory
from mongonaut.sites import BaseMongoAdmin  
from common.utils import DummyUser 

class BaseMongoAdminTests(unittest.TestCase):

    def setUp(self):
        self.req = RequestFactory().get('/')

    def testHasViewPermissions(self):
        self.req.user = DummyUser(is_authenticated=True, is_active=True)
        self.assertTrue(BaseMongoAdmin().has_view_permission(self.req))

    def testHasViewPermissionsInvalid(self):
        self.req.user = DummyUser(is_authenticated=False, is_active=True)
        self.assertFalse(BaseMongoAdmin().has_view_permission(self.req))

        self.req.user = DummyUser(is_authenticated=True, is_active=False)
        self.assertFalse(BaseMongoAdmin().has_view_permission(self.req))
        
        self.req.user = DummyUser(is_authenticated=False, is_active=False)
        self.assertFalse(BaseMongoAdmin().has_view_permission(self.req))

    def testHasEditPerms(self):
        self.req.user = DummyUser(is_authenticated=True, is_active=True,
                                  is_staff=True)

        self.assertTrue(BaseMongoAdmin().has_edit_permission(self.req))

    def testHasEditPermsInvalid(self):
        self.req.user = DummyUser(is_staff=False)
        self.assertFalse(BaseMongoAdmin().has_edit_permission(self.req))

        self.req.user = DummyUser(is_active=False)
        self.assertFalse(BaseMongoAdmin().has_edit_permission(self.req))
        
        self.req.user = DummyUser(is_authenticated=False)
        self.assertFalse(BaseMongoAdmin().has_edit_permission(self.req))

    
    def testHasAddPerms(self):
        self.req.user = DummyUser(is_authenticated=True, is_active=True,
                                  is_staff=True)
        
        self.assertTrue(BaseMongoAdmin().has_add_permission(self.req))

    def testHasAddPermsInvalid(self):
        self.req.user = DummyUser(is_staff=False)
        self.assertFalse(BaseMongoAdmin().has_add_permission(self.req))

        self.req.user = DummyUser(is_active=False)
        self.assertFalse(BaseMongoAdmin().has_add_permission(self.req))
        
        self.req.user = DummyUser(is_authenticated=False)
        self.assertFalse(BaseMongoAdmin().has_add_permission(self.req))


    def testHasDeletPerms(self):
        self.req.user = DummyUser(is_authenticated=True, is_active=True,
                                  is_superuser=True)
        
        self.assertTrue(BaseMongoAdmin().has_delete_permission(self.req))

    def testHasDeletePermsInvalid(self):
        self.req.user = DummyUser(is_superuser=False)
        self.assertFalse(BaseMongoAdmin().has_delete_permission(self.req))

        self.req.user = DummyUser(is_active=False, is_superuser=True)
        self.assertFalse(BaseMongoAdmin().has_delete_permission(self.req))
        
        self.req.user = DummyUser(is_authenticated=False, is_superuser=True)
        self.assertFalse(BaseMongoAdmin().has_delete_permission(self.req))


if __name__ == "__main__":
    unittest.main()

        

########NEW FILE########
__FILENAME__ = view_tests
#coding: utf-8

import unittest
from django.test import RequestFactory
from mongonaut.views import IndexView 
from common.utils import DummyUser 

class IndexViewTests(unittest.TestCase):

    def setUp(self):
        self.req = RequestFactory().get('/')
        self.view = IndexView.as_view(template_name = "mongonaut/index.html")

    def testIndexViewReturnsValidPageWithProperPermissions(self):
        self.req.user = DummyUser()
    
        resp = self.view(self.req)
        
        self.assertEquals(resp.status_code, 200)
        self.assertEquals(resp.template_name[0], 'mongonaut/index.html')

    def testIndexViewRequiresViewPermissions(self):
        self.req.user = DummyUser(has_perm=['no_view_permissions'])
        
        
        resp = self.view(self.req)
        
        self.assertEquals(resp.status_code, 403)




if __name__ == "__main__":
    unittest.main()

        

########NEW FILE########
