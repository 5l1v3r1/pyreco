__FILENAME__ = get-pip
#!/usr/bin/env python
#
# Hi There!
# You may be wondering what this giant blob of binary data here is, you might
# even be worried that we're up to something nefarious (good for you for being
# paranoid!). This is a base64 encoding of a zip file, this zip file contains
# an entire copy of pip.
#
# Pip is a thing that installs packages, pip itself is a package that someone
# might want to install, especially if they're looking to run this get-pip.py
# script. Pip has a lot of code to deal with the security of installing
# packages, various edge cases on various platforms, and other such sort of
# "tribal knowledge" that has been encoded in its code base. Because of this
# we basically include an entire copy of pip inside this blob. We do this
# because the alternatives are attempt to implement a "minipip" that probably
# doesn't do things correctly and has weird edge cases, or compress pip itself
# down into a single file.
#
# If you're wondering how this is created, the secret is
# "contrib/build-installer" from the pip repository.

ZIPFILE = b"""
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
dCAXlSIAAM+PAAAfAAAAcGlwL192ZW5kb3IvZGlzdGxpYi9tZXRhZGF0YS5wee09/XfbxpG/66/Y
WvUD6JCspaZ3V7a6VrHpVBdb9pPkxKmiwhCxklCRAAOAktXE//vNzH5/gJTs9rXXd3ptLAG7s7Oz
s7PzudhmoycjNquLsrqcsFV3MfovfLK1vbXNntXLu6a8vOpY+mzAdp/u7LKTK87e3HVXdcWO64vu
Nm84e1GvqiLvyroaQ6djztnLg2fTw+PpuPvQsbwq2LPXhydHB1+9PXl9dIwPod3Wo0ePDhbLOV/w
qqPOrL5gHYB/xbscwOXsom7UWMt8dp1f8pa9mb5px1tbx6vlsm66luXzOVtYHRY5PEx3xk+HbGe8
g//ZHRIKu+OnjH9Y8qakAeeDMWKwddHUC5ZlF6tu1fAsY+UC4bJVVQJJeDYvO97k83ZrS77Ap7NW
dOOLvJyrHgvetoBhhm+yi3LOVY+/tnWlfp/Xl5dAZ/Vnw7e2BKixAvO8bLt5eT79MONLJMoQkLvh
TQu/ZplsO6sXy7xTPY67BkAevB6yln7Lurslb4es4x86+l32WuTNNQBS3coKZrZseCdfrzozF+jZ
5LMuO7/LrvndkF3yLqNncuJjiZFqj+/b2RUs5RAX6Mvd/8i+nR4dH7w+zI6mW1s4a96wPTX9MbR/
Sc/SLKvyBdB9AISYzfO21av/qmxbaDttmrpJfaoMJlsMfmAB94GIP67KhheGDcqWLURvXGEf8LO6
upiXs24j5K7ji2XHuhqGyAsGzHjbADtY7FbyedECz8Ji4D6YScirfD6Ojfy2avisvqzKv/HiW0HB
TUi8ra6r+rYyYyrKV6vFOW+iwxxUN/m8LDZTzgDN5yuOZCtFV4K6zZarc5gO239zILYm0rUuVsDa
WQb7DnbLHjtN1LDJkCVvvvk6Ozh88TqbHj57/fzg8Gvn4Zuj6Yvp0dH0ueKO5AyHmVZC+rBVC6uI
mx6lAPQaYS+Ge6ndCiDD2AlJq4RQbfgFb5ALJIHG7E/1kl+s5vM7dluCkDiH9bnKq0teQHNYUxAM
rK5mHBmW/frL3+D0WyFVAAoHMHe3Vxx2aD/6iAIIGUAge3lwOKUGB+/gacNpjwLiafJDxcTPDz8n
g61s98ud7MXB9OXzY2iXauKNJD8gvQ5hR+C/1qM387xD4ZYMt5j7kxyvFrCz77DVc97OmpKWOdLw
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
zYw8o+cY40evs5Gi9CtTxTr6js/Dti44QS1LzaOi8TLyYNInrH2AxWhIbphK6NKOFMJZKv9ynZ6W
llV908tYpxTjLu4GeXl6xoL6lr6WXH6ufVjaWUsCzr4qlWqYmi8EVlhHbrd8KHi/X8I2lovCC+ri
QXtKrw9hWzbs//+8u6GwTG72zPKiVv0D9OWbiilu3BoWutM7zPqgSiHGGP4AUEsDBBQAAAAIAFGe
okSvii9lzgEAAMsDAAAlAAAAcGlwL192ZW5kb3IvZGlzdGxpYi9fYmFja3BvcnQvbWlzYy5weX1T
wW7bMAy96yuIBIWdLTG2noYCOaxBBgQY0qFJT8MgyDKdaFMkQ6K3+O8n2VHrpth0EU3yPT0+yVNY
vFuAtJUyhztoqV58ihk2ZVNY2aZz6nAkyFczuP3w8Rb2R4RvHR2tgZ2t6Y9wCF9saypBypoigHaI
8HWzWm9364LOBMJUsHrY7h8390/7h8ddTIY+NplM7oX81VhHHmrrQJlK/VZVKzRILbxH32Pr1sjI
7YuAYEydIgKsT5HvPGOcC605hyV8z6SQR+S1syfubeskZnMISa1Fqfu49mjCwJj9YIyR6+4YhBUB
EDjhwvuGhuFZYkOw6etr56wbkBXWb7vzpuO10jgP5bI9LDnvd85nAyguDPYsh3o/aiYzCEZkNntu
cUitM3Ahg/cRM1ad5go8KUw6t+KEI5X9fNJqjYOdac5Vgo1mGTK5LX+O1F6kKK+MJ2FkX58/42ev
zLxYHGRZX6SvpOwzkVNlS3hlYurL46wmyB+drurxyalhDmVH6Ed9I6Wp6cVv/S8WT+7/HMVFWXht
xQEppkNIeOrz4d/JZ7PROR6v2ITyCPuuGUbOJ3huwj0M6uOdBwFzMJbgxk/g5hX2elFgeXGo4Dzu
4V2xv1BLAwQUAAAACABRnqJENKnRykgcAAAyZAAAJwAAAHBpcC9fdmVuZG9yL2Rpc3RsaWIvX2Jh
Y2twb3J0L3NodXRpbC5wedU8a28byZHf9Ss6FAwON/TE1h0Wd17oDo7XRowka8OP7F4EgRqSTWqi
4QwzD8v03v73q2c/ZoaS1glwiD7YJKe7uqq63l09p+bxN4/Nqlrn5faZ6drN4//AX05OT07Ni2p/
qPPtdWuSFzNz9uTpmflwbc3bQ3tdleZ9tWlvs9qaV1VXrrM2r8oUJr231vzp9YuXP7x/mbafW5OV
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
fPhw/sE/X2/evp67rvsarrz+FcGotxbqbYI0YGf6dTEdvGQa32CoMIf1+Ng1VZPM9pe6XOLQ+7SF
/gV2xw0w2m1lTEcS5sk9twcmXg1Pzs4mCjNl6/B3AHuAm409wt2sVwOXyrx9J+NaDdJKfys+mkKI
SQqok0V+mFdHyhf1IsrRr6K20FGCB2iYrfw8IE+eALsB4y2mwmKjXhlP4VqzflAvl+WNmE9ms48C
9K14HPbB+e6VTOj8Y5gcxQPTSkScLTxeOH+R+b1x5H1+ppLcvib/FMhwcB1HS3X/Qu/kyI+d373o
N4KHZcR5t1i1fLmc7tk7mj/SB/XWUDn//ZdfOPfK1Md3p6ki1OtGtaJvhSwoDNcs6JTeN+7juhMV
dfZeV25NMXtqPx1cDOoU3rKoYJhOXk5m6nce7rM4kP5envSw7/yXmuBTsuW5qKQbp88jpRw9usnI
ks0beyLZw2xrlbd/Uqba+scteuxrYYe8Czt2h9/pHP/yavyhlDG9syR3vyzDlJGPoWkmMpA+C90R
vw4vi0ObhnNyANCOjGJsLYwtfOHXMD3yhtxsQa2/tbTbm3fb2v89jL9pnz4Jxafv1zGJ95F/tWfK
pvZT3lGiw8edy8T8KmK/3NuvEw5w2BbG73Gun0mdI/r0KxHl4R50+kc7VsWGp35Z8eze3f7Zjsqs
bVftM9tOcu3fgeOPVlGM6iVSJsfT52G15Tl+q3d0uazPW+JHV2EXm8l3n7nh9+rXOOq3gLvIPIG7
fSAAWJ+C404Q1iv106nDKg6/HFrR7wiVhDr08Huf2cn/AlBLAwQUAAAACADFE6NEmHA1aI8dAACs
dwAAIwAAAHBpcC9fdmVuZG9yL2h0bWw1bGliL2lucHV0c3RyZWFtLnB57T1rc9vIkd/1K2CqtkTG
JEPJb5XplPVgznXetWtt3+VK1qlAcChhBQIMHnpskv9+3T0P9DxA0d5N3VVdWFlHHMz09PT0e3rA
ZVmsoouLZVM3pbi4iNLVuijrKJ5XRdbU4kJ+H0aL9Cat0iIfRk2eJsVCXGRpLco4q3aWCGKdrscX
NyJfFOW4Su80nFrc1Rf1/Vrs7KgWHJtU+lsJD2j8OCnyqo7zutJDTz/MhlG1jhNxfBWXcQKzVcMo
rpI0fS9q9u3Lei3KJK5EFySRw6RpfgkDfhbruKzE6V0i1jUsRw3RPZs6hQXJxrTQrZ/qEka/+7Cz
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
ZXJzL19faW5pdF9fLnB5AwBQSwMEFAAAAAgAk56iRCKA+8SVAAAAHgEAACUAAABwaXAvX3ZlbmRv
ci9odG1sNWxpYi9maWx0ZXJzL19iYXNlLnB5ZY5BCsMwDATvfoWOCYQ+oNBrvyEcRw4qjlUsue+v
Q0wxdG/a1Y4UixyAGKvVQojAx1uKgV9VUjXCa15g4w8rS16gZg6yESY2Kj6pcy4krwpPTs2ZZH1R
sPnuoGmj2Oic2RAnpRQXUKklUM9PnfbtcuHRYze2G7W3h1ah9nGGM5wGwjw2dzJvVn6nsz/oH9G3
RkpfdV9QSwMEFAAAAAgAk56iRH8OkE4gAQAAcAIAADYAAABwaXAvX3ZlbmRvci9odG1sNWxpYi9m
aWx0ZXJzL2FscGhhYmV0aWNhbGF0dHJpYnV0ZXMucHl1j01rwzAMhu/+FSKnBELYudDbOthph+5W
glFiZZg6cZCV0vz72Uk72rXVyR/vIz3q2PegdTfJxKQ12H70LIBN8G4S0uu9BGNPNlg/lDANtvWG
tLNCjC4o1aUe1RXVDQZSSnjeKIi1/LbeOWolNgjX3BcbYjLvthVF55ZGgc/lZ8fs+Yb1a9DE4DNW
qdZhCPBhXRTKl/HVeinWLoa6uGLS1ToP5LrL+zLBM4g/0gB2gFu2ekWkst0KHTKZR8rqBOfZXpDl
G3+yErJdP8qczv/IVCjCAba3W+TFQyqZDdhTCSd0E6URIe5OJr+MNiiY1VW07ENelA8NXteR5q3D
vjEI5w2cD2/1E8s/00OyqKPv4vGQu7OJqYW5S82WnFlz6hdQSwMEFAAAAAgAk56iRBV3eTq4AgAA
ugoAADMAAABwaXAvX3ZlbmRvci9odG1sNWxpYi9maWx0ZXJzL2luamVjdF9tZXRhX2NoYXJzZXQu
cHmlVk1vnDAQvfMrLKpoQSK0561yTI69NLdoZTkwBCvGJrZJuory3+sxXhayLCHJnPiYefPxngcq
rRpCadXZTgOlhDet0pawe6NEZ4H29xkp+TM3XMmMdJIXqgQquAXNhImiCjHyQyi9ZwaiKCoEM4bc
cOHcEv8w72/SbUSclVC5xFxyS2liQFQZMarTBWQEpMvA5UPwRBsD5LNh6eCLT/MDBrka4KJxXocT
AEZZjGUWXETcumHUwMp4eNWAZbRSnSzd+2SaghvyR8lRBS3IkPtuFw1PK6WJVY8gCZcnDc3Wg2b3
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
vlKZv2E2ryu/urqaVSEM3HSTVCvn2H06RW60ilksEFBSuc5K4meQcYEhRR+LTnKmWYrhWWUNGWcF
egc23qrdTScJHd17Q0+NLKEH0NZx+6R1NSfO8TInjgrHecNKrb1q97XdVNb+diKHipX2tenDtanm
N1Ey4yl5I5nacA0VnFdK/Od1fuv/zXDE0/5WlYrC4OUapKrDHG4Hux7KumurRHD/qInyd15qBnY5
T+jtYj/cBFArmgfTKaDMZMox0+ia7FycbLiuxx3TClhdrKl6Hv1k9N5jv+8dwF6XUKqgkJ5Yo9ZY
XuE+lPtnc7uDe3Pcp9bIVO3Mu97N3c1Zn7rh3auQQ6I+/bkmnJ8F0HPmvWLh14eN6e/bgzZd+U6b
zvi11z/Rz4ZmyfoXJ69zcPobUEsDBBQAAAAIABakUERnTzIbbQAAAIkAAAAxAAAAcGlwL192ZW5k
b3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmFkZS9fX21haW5fXy5weVNXV+cqLi0oyC8qUVC3Lqgs
ycjPU9DNVUjOSCxKTElVsEnLzEk1tFOIBtFGsQp6enrqCgWJydmJ6akKqRWpyaUlmUAdxZV5JYkV
ChpGeubamlzqQEO50oryEcZk5oJtgHLjk3MyubiQOBqaXABQSwMEFAAAAAgAFqRQRHGcvzF3kQAA
okIBADEAAABwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFyYWRlL2JpZzVmcmVxLnB5
lL1dr2W3kWD5fn/FAYzBuIC0fPYmGRG7a6oB2WVXC+OyDVlGo+alkJbS5UTLmepUqgz3r59Yizun
Bmg3MOOH9NW9h9zcZDA+VgR5fvSjv/2/x89+8U9f/Prxqy9+/otf/+4Xj5/96jc//z8f/4vP/ujl
R4+v/vTm8ZsPb//t7bvX3z5+/v6bN4+33z/++f3/ePvtt6/7v//85x/evf369cf3Hx5ff/v2zbuP
j6/7M5+9fGr6xbu3H992y3988+9vvn3/3ZsPj/d/fHz8G33253/95uP3X7/+7s3/q9u379993//5
4bv3H/yP7vjx2/cf9u+//vDm9cc33zz+8Fd7/J8f9foDfX33137Unz4+fvzzv3sc11Xdxd/8+GeP
z7/99vEln/3+8eWb7998+Pc33+w3+fn7dx8/vP3DD/2aP/7+7/5T/+bx+OfXH/7b47dvv/23D2//
/PjJo0f48fHx/eO3f/34p/fv7vfvqfr27R8+vP7wV2btjx/evHl8//6PH//SA/v7x1/f//D4+vW7
x4c337z9fnffE/Hx8frdNz99/6Hb//n9N2//+Fd+9cO7b/p1GPXHNx/+/P2nOfynX//+8as33/dI
H//05t2bD/02v/3hD9++/bob/+rt12/eff/m8fr7x3f87vs//cdM/ZKB/O4eyOOX77t7Z/fvH2/e
9t959r+/+fB9/+ZxfnZ8etrd46tHr/WPX39k/L2a39Hw73rQf31826vx4VPLz/7mFPzHm37zePvO
bv/Uc98/dIf9on9psXr84c3jh+/f/PGHb191D/3Zx3/94qv/8pvff/X4/Nf/8vivn3/55ee//upf
/r4/2zPdf+312z29/fN3LYLfPPqtPrx+9/GvPfDu4J9/8eXP/0u3+PxnX/zqi6/+hdH/8ouvfv2L
3/3u8cvffPn4/PHbz7/86ouf//5Xn3/5+O3vv/ztb373i88ej9+9efNpipnMvzXJ/88U/7G7/PP7
nslv3nx8/fbb7/er/0sv7/c9wG+/efzp9b+/6WX++s3blqjH694i3/31/9cafvv+3b/5vt3kPyb0
7x9v//h49/7jq8dfPrxt2Wnp+59Wt3v5j/V91UL/9WevHuvoD71+99++7SX4XTf/5ds/dte//Pb9
+w+vHj97//1HPvrPn3fb53kcz58c43k8Hr//Xf/mf/W/xy9+/Y//H5XKj16645+9/bfFhvjvP7x5
93VL5es/fMtYW0C/ev32L6/f/e+tZHojvP7QQ/zth/d/fs/4ex/+8O7rt9/2B/+PP338+N1/+ulP
//KXv3z25psfPvv4l/9Ux0//3E0+/PQ/O//HWY/HT37ynx/Pz+Z5xtG/Old8+tXKWvxqHeenX+Xc
vzqe57x/VdeoScPnrPtXV64aPuCLb96gPj5JNOP7kml+/MOnzn764+Mn949/9/iH8zN1z5c9xvd/
/hvt3nXDHs5Pf7zm8/hJ//R3//D87HiuvZH++l3rw7/5uNd/YBec639DpPag3r/rbfr9RzbTn3/4
+k+PP7VSU4G0uvnyH798efnZF/+0/vWrf/ntFz///Ff/+o9f/O6rL7/42e+/+uI3v/7XLz/v/9uv
sHqhfv6n1x8QrBaq//6bD2ohl2p38PnPfvWLf/3dF//XLxj6yOiOe11p89X7/2jxD48fv7TCPF4d
9ex/1jNe9XDXq2OO41Wr5HrVf736nzr5KV6t57N/d2T2557nqxHVzXrxXp110uJ4vnqggo94GXXM
bjTGq3Fm/9QL3f+Z/YTHnK9aevnr0S2v2f8cla+Og7/Gul6NK/nwGa/GXMerM9bY/Y7z5WBY/YF+
+ljPV5NxPGY/+DyP9eox+M919ThGP/C4gsc8ivHy06pX3eOTF7n6r+Pc/c7qeYjRv/ZvRz99HD2i
cJTZ/Z5nf/TosfUDx6tz8tdZfrhHsnrSxvM6+NxkMu5+Y770HDl5g9d9MvLRLff7Xa/O9MXH6kYR
PaLZI6/+yKO3NjPXi3Gcg+GcPOueh3q+9Gv0zDwXr/tkPfiJZ/WnetDHPLs3ZuQ4mf2nM52syGS8
PbV7Rpig4Cf6veKlm/dgFvJw9Tr3P6w4QnHxfjEX//Rf44k8HK5RP3oMOk8WY/+B/6wtD/0KLz29
/R/nKB68ELYLoegXukYvxfM6WeceR/bYjtnz0L+bdN4fmRMpjJ6vq+er1/fY/Z69bkf2r59Xi46z
ejD8Z0/oUdP3e7LsT1ryIv32Pap+QnVvj+z/7A/7Dkzap/HO+fK4rsVLJm/fnfcu6j74z+iO+v2K
RemRj36bRzKIg7lZPfvnSF7uUtiYm5Yb+43nS08t8tASemZP3jF6Rh4RikcP/2Jsz6t7W7x4L1wL
2+S9EKPVAnvQrJ/v8Lec9cZ5OXqXI5yzu+yOev2RH3Z0i0aPCIF98iIHQjT6CY9RyMhiWVpaegr6
c5O9us57vNf50jLo1KIVWn5anNkm3Xl3xBKz74N+q6X7OK+epfHsQY8tZ8mHGf7p6Jb9ns9et2Rs
0xExhOhh9Wzxzr2Mx9Hz2yuTNOIj0w3GzFX3Ub2+vWlRHL3cLeGx+z3nS784/Z49q3n2O5/9+QOZ
7mVn0PQW7qjex/3XgwG27PWPPWgWavCadbjpt5yd8/nS79Kiy07tzw/mrRfq6DXqASrqgxXndz21
PVS2MOMNtl/LOM2QvX7WUWhW+l3x0spi0G8PKy9EN/rBbLXec72Wi328fPGTx8yBpuifiqEebB3n
sFrOJ7Jnv9n7bbIhE+10saZHIJe9PP0shPji/VpQBpPc+wc579/1JxT7YvH6RVb322t+91v10h/A
SriP0EBXuf3Uyd1RrzuCctASJcFuHGyrCBYUjRJIvLvmPPc8jGevW/QA+w1YWN5vHs40n4qTJ1zM
A5M8ePGnfSC6TzRFPxUTjSjwNnn3ez5bn51sl568E/syWK1+oR6WitkuayIj/ZgWdteyepf1srQA
+l7FcqPcj73fxoiXHpaii1lAO81+v15YDYT7np1Hb5i2fn4x0xhU9eSjn39dmI9Tc7f321hnj3fw
awxw79JWA6fTovJRdzqNqMOFcp90mX6kf1rTfaGFaeF53vu435f5dcV7ASp7ylY/oUWhB320zmjV
uxg5/SKmB/Z19Yy0QsJo9Qr2fw7+8Vl3v+2DMcv9OIZVp8oHhceDZ6ELAsuMEU/URRbPYq+0KDMj
F2ZcddUDy9r9zuez9br6mhHNntWeEf2NQP/xUUx8sVC8UgsQ4n86c44S4UED9ZT2u55br0/8kuhh
9Qvp4KBrkeRMP+8/vW5XD/8oVvB0aZG4fln+ihbVUWAt89r7YrZf0l0yD1jydsrZqYhHsmTJkgVS
yIIOVQ52vg1Gv0i/YY/8QD/pMGFN0Cj0i18yelYHNqd35YFZ0Lo/0Z0Imw7LtMt+/gi1I9YHU4zo
nu6fxQqqKei3/ZKWZYwXaxqFFkEnhmqAFcf24hchXeh15HGiH1A5JzPXD0SB9uf6p3se2i9pAWVs
iM5itRhWT8GFxmL3MoRtikvVoOFBK6AT50Bqyy4Xf9j7eLZf0sYW0cGWZbHBUNrD6WbJFs4Bur79
DEScDbPQHknnR6B1exCtkDT2W84WfsmJB7bQXQcrnmHn/WrRdqh1LZqwF697w1r3Qg0l4+p1azcQ
oZiYNo332P7Zar9kMISJxmirN9gIuMo96MmO7sdgbPUfcBazp2oy3u4Np6sF9mAOexDu/Hu8Ez3p
bpiOEk8Jh3MyyQjFCByLYAVHP/VAsNup7EHPcB9jr3QAnq7+3W/7JQcOZ29hfGhMBRr+wPHuJUZF
FeY83DpYCWyvZp9B95Jhnqf+Cy/83HZz4ZfgOjwu1QYWrB+Pa4Y7gel+LoxGMaG4fDy6XwT/O50R
X5OhsmFbFne/7Zec9sYLtRDxQkPVwNv3UPsJgRryxbsltqzfEHPXU9VuNfLw9HfsmtuvDvySfi1c
e0a5XF1cAj6v418EJSci3kvDi6MfTmcO9ZaacZy00/na8ts+wMtkt/dCEQ+pAQxeNHKYlsl4T9Tm
aCHqAeIYPxU2dBxGDmeqvWHecO15iPZLWlaYLVyHXCrXRSNVA24um+NgVa9D63exiZja4SCIF/pZ
vQ/RI2vv417YtkPLsflRpQv9i19yMEAinoO9NRRTYqrWEYUl0GtARlnag/ea456H9ktOtdjl50sF
zZZnoi4cLJTKwyXDiz3x0k+0/tRy7Xc4nDmM8m03Wzu2fkAKEk8/cWTjdPupCXFphw4vziLmnA3T
A8T68fwLtclwHngtj/OOY/OJfbtYAObXqGmlE3UhbD3A6U5Vi6FKCU/65YyKUaUn88DOMz6Ouf2H
bL/kgY45sXhnumcVNp6O+Pf2W8QGGMow5GYa2ReVKh9eDqsWCGU8737xS9gD/XklfxKN8VbGTwcO
LA7k4JWImXtB0THaJtyf1c16uQfvgKYaWx5SvyT4NZFXGww+rx1il+EIPQgoiqdGe1Q9qSwG5qOe
qFcsAQofHx2LtPdb69pet17EgVs80KEL/3foaK2nuou48GSxGSr24iTsWhjUB55la9aTJcMef5qH
9kuOvXF6CD0Paic25MYGPMFIOVitS8GeqG9CpnI3YOKZ+NY1/LTlrPBLlkamhXgaHszLPcD7HaoS
FJ3h55MnaDxPHTKCjMQXJEzNiYsx9j5ug9LxcUvBobelH5WpOLFQrj1KUIubl+Jh7IMG1MxgQwjP
WiH1SOL2+2qwbjgCiG7/xFslIS9K2GibILmdLCMjoldCsYu3yaVH18+H+bQjg3tQ23+o9ku6Efqh
lfuJBW2th8nc7+w2US6J6Qa7F2G/JiHWU8EixFIrsYLtGO1+2y/ByKFwcehPFR6qAfcy9t7yHZK1
hwwxLRfTMiZCyd4e0+3HW8fex9V+ybjHe7Fa3VG5j3m6Wg8s05/rWX3qGk5HztqrrEv6o/XTIb3n
of2SeRrgsdsLr2xNuhw4dfqk2/YWq6Xe4Z0TnzhY5Ilgh089maUdH/fme2lBmvhdioI2R7B0IasC
BywzVAe7fTztQwuKgSK0OHIYxuDXn3u8F7wEX2yIKh443kz3KQDCA+x3ZKgDtEQU1p3wDlhLYZfB
P/Z1Ge/G1g8XvCS2PsFeoGMmy7gN5cKfK2a/kEL8rVQdM0A24hDfoDhOVEirpu0/XPglCOzA7J5M
XjfHJZh2yfLwpicTfy1Ug87RpYVhlEO5gbCUVn3LWYewrFuCO6SdqFRDeSAAhm8aSekBTqLMFm/+
iss3XQx1ABEXshR33HLBS2bw0YGNGuwyNSabAwJ64Bx0l8jUxUaYzIh0QEdaGSUswZq1h6E+Ywe2
P9njHfhuh3od/7dVzkVkjVEW4+CYRjp8ZBVrPYd6XcqnUDIj13P3235JD4Y9e6GYLraQISyNnsrI
o5ediOBUDQ2xCOKBtnkQ6bQ+dc0Nbdbut/2SboQlHcwqIRmhxaFfgo7pfw76FYWhbQADQ3SHiB1P
Q4XkJ5y54x7vIn7rUXYwiemGfuC4zFOO54zgDss60JPdL6+LDke9DTEHMc8RGoHNS1rETsYLIr18
ug8u/sH1xfBs1xdYwKMfDHAInAtFjlv3QO/0ZKCk5rX7bb+kha4XFjJ+AGPaJSD+Z2+N4UwTB/C6
QXgy+Qi+QrfwH/7TCFVostwXROwvPVTedKp3JDJIspOMApv6R5e2zPkCmmiFWUuwwZnbnYHFzr1u
rVBeDszjCRXsvYhBQ9ey2wcPnBqeheqFjy5g4gHoHIQlB/r3xE8dKQPcdr4/1PbtQSysAitJcAjn
CCb56PMp5/IJzA2uA+HJgffWbpz4BsIy2P5r74sO7NvOn/iJmO7Es8wdULCPtT7EXpf8gWASpdpr
hF+CwiWYHtf2nTEMueXsaL9kLufh8CUdltrUqIItcRAFtegOwr8HIenJfy6CyB6OsgcOObU19zy0
X9KN+E1vsIX9bu3N7iGF8nyKA3AACFQ6eGIG0c6YMRIFJ+TxYZoGH2Hc/g7hQdtNxGScvjOOwH5T
4BzuBLHEg1TLgJIvjRHQuvXGE0WDsBON3tNSu1/8kkNupD1kjhKHk7jsYV4ijCjR5mmIJ24fmiCe
wIZZLDKe+8PAmX4H+QCi1wjhjeBQNMiICC0Ch5BZ6o7Yvezy51OhZFa3W4WI4yLXzgfg7cEfJo9T
O7Fuk9XCUztRvc5+wsYJ+R9o5/PQmZtSZ3SnTvghlr/nt/2S7gOae6hreReCrcGOGq54qixhXzhJ
cMweBLOKK4lWGka58ITzHPf8tl9yTH9tyMKDEyyCIh/E+OswvCay93fLhcLE78BqfwQPG3ZwnHe/
7ZecrNsE4a1jbzrGoVnCpS4x2XYF2OBoIDzmSew+0A+H0atZvMi9bqP9kkPDjtQe+LDLoBoV1bpL
nIbFRw2J4OtJZou/klGaIMR1KPt7OFv/9tR0HIsBhK9PGOOCiC9Q9bnzkAfREq56giuRrgF3PU49
wAONDawlM3AeOy/S3bNuqlnlV+byJA7AmYGXnIaVpNIOswWHexucRrzbAVvQpb6HwDl3v4F9m7wB
Ttq6tCUMAQ+FlVnMag+V9B0qUhupjiMYOUEaJ6H8EuDePJUUDv2iqk/dMMI/pBY9eVwOerkR8NQE
rYIflPXhNlHR4Uft+Lj2vhj4JZDYnge8Mnwm4M0xNpMldDuFtQx/ufNwvUOwJsk7eCrLYjpu8x2o
b+tJPCDd7celBkAkCarxxc50Vc0pEz8C9Cd0YOwBTv+qPpNEbzs05SUwIthld+SniHMQ+njSRzoZ
RiY4xsmco+1MDeFnnHoX+rPgE/ttv+TET1wdqSCSRE1Df87OcbBQ5Kx4v65bWLNAeE/wdATzi8HZ
RuDWDxNecvB+w2SKgaOa2IykKYZTSWJVNfZYy9i7EeqBiA+d9kscsvdFP/hlMPcLj+Zwu+KfDUzm
gWO63OXnDibpcqoiEcXAriTafKeTecN1zwO8ZLmFzPOGUmAMaCjEBlu+LollkikkNtohc+2dVeNz
ggY8WzwZ+u3fMA9qkcB0u1AThwEEDeE4QhuievNFkG6DvRB44LihaMuM6NxytsjjHK64gAJaT4bi
AISdZlAfhzkYlIRyjqdkhpoI5sSGDDfRUzN6+6kdmra/Q2iKph9PJxT7EnruxEMppiO0wFT0X9Fn
KftXFGzrwjNBt95p/6T9ar04QjdUau9q3h6aG9p09CSg6gCfDIj/YF8Ot/BT2wj11ShjSOy3/ZJh
hrbYF09zqi5UOucE1UaeqfziKZmTY2oNj6aSgdkXCYKo7bfYbwtrSexjbQSp2B69YSXDd4fgMQIu
e6g6XTxwOmj2lPqpLCTZ/caTdSsnD8itPiNIDairDjdQvrUYQrxDaFIcw8iBKAGfUbVZbs5rz2+Q
x5lKQRlYAUtL34YVL/1l3s80PLrInGfxBByLg8zhwXjbZmjp7n7bL5mUgMynqU3BAOot2fehhKKd
yceeh4AciwTaH+pkXMl+EXI1BIzP4+4XXiIZJ6m1BGFEwL3s+OH4Z6aOEYB1SDtRZSf+LPUtx3Ua
gohUBJF7v7Uktf9LkJpbftGTwBjSUMsE2oCNmC1dxNgPc2fLTcQThupNU4X5qLtf60tQCKR3hrv3
0itDlfH5h+gVkH2a4BEHBHE/jGpsDj80Rrgzsf2HaL/kILXZ8RomayfLcEQKy1GyRcICgklcyTaM
eGqwg94EfAQOTzAyTArf9iLN4yBYzgNhx2REk34faPMDhDe28UpmyRX0MezZ0ywPdAJlPc7bHid+
Cbm54zSIu0yJIDCmfPYAFy2Tf1jayz8QCLrLhWKFUJhLja3P0jyOhIyn85InGvMkxTDYA5N3nveI
8M9STIbPb3GHgmJ9Cfosdt6p3/750pvE6gTsNwKwpDV4ccN05xSqOqFoCh0LfFJKbBaGcp16ape7
4O434ZOHH9DfwJuFmJ5G7E92yEVcyIuDpScVOgM+Oq1dSFaEbdovh0W67n7bL1m887Ju5dKcy2RR
NHgjg5j5QCc/qDI6kL1JmDhUmzgW69w+Jixp14n1xu44YDAzhzpfYsoLCaxmj2hZVRKmv0OKoNso
9zx5cbxeXLMLTfzcdSD9qYm9QFZhcGu/KfDoUncRdqH6SrRzqR3xxcKkO74rXuzEK0zXd9eBtMIi
j7MjVQo0hAunWaRi0EzydO19NDGdTFZXHT8OmkIZBc+yxd5vhV9CwcNJ/cM0LciKr1OFAIUiITQZ
4MNZneI/+K9EHino35HR2Qt6zy/1JYTyp+aGZy5yJigORsQWljuSBrLIhPzJ3NA8/QgkGDcb0j/v
/EUrrPYnz/TXg1XAGFHtZKa8xMf4Zxj2gaZYCOAEMz8GRRBWnQUrSPq7/9njvcjjDGvpIIV5OV77
tQ/6xV0Cg54M+sEGP2KX2GCCMMoTVwD9uz7ph6v9khP70ptDG3XB430C3t6U8GJkcAMRsUHic8Br
FtvkJM97GqOZS4jbvl3wEuKs8dTz2EVrB09HvaDAFI9pxaEEnxzeU4SJ02XNFjp2sWTzefsPF7wE
cz7UnGqKQ2cVJgu6WtDsw2TZBTVjGU/xau4B4iOkgo1r+GkeqC9BdHrPGAgmy8NCIUlTZokPNExq
lZbRzp0HCMBT1oHsL3fjlt+L+pKEb1sXdOjpM5jHXi3Hi7GlyATt8SBAGKa1h2k+LP5pHSnWjNqm
B0XD7ZfMpwvA49AKQz0VctLLYbH2hKs4Ioc5uWmdmM7ygdHCVEAipiSYftsvmSiLBSJdp15OaXaR
GkqjSEAcZIWWaH+Z9zJXrD5NtI05zF27cPdr3etpdSxKIvTAGKUWlEi1yk3KhqFLHPmhLrosc9ui
y8RTbTZ3XEjxdMcX4mYQv9W84k38vkEt30No8ZDgoNxzv4ipducG64PfiYiP56d5gJcAOboR/j1B
lJJkEgGnY5ItOJfODMbr0PYjhWSUpqVyiaOgAzA2B6e0pPsVhhgwsdXI3Y9pWvBpJQ9qPs3cuX8s
6/SBKMun2w9nGV5yznse8Etc57A+ijDJLCE6fJIwmWzwHgdDPdBiKLpdv4k7TDg5yC4MkwfnPb/U
vZ7H9pddHvSO9Qf0q/v+3OIPPzv1aNgXU0Fxb6NKUeDDnMqua6NWkXrPYli4XMxDESFS83egLKeV
y4x3CKihGedOGAeWwDI7R4JTuTanPal7HSVhkK2ZySA/o7/szjNlSSh2HEoXQmzpRcHt0UWLwP08
rECou1/qXnFrHsmrWR3ATp1U48zTvLsraCESaWqhuW9fugfSF+wKhQ5tFq/db/slI9U2T/ennaPD
NS07wEQTk+jCSZquLzz3fOpmkxXCA1yGxoiR/VJfQuV5f54lI1dx6n5c8nhzMGw/diNMeCzjeZQE
Ds4y5rA859xmf68bda/zNENrIRtOBNTsZNCHO5WY46ASbBGK9ciVFsAWpTgSjqGCsej+ljPqXif+
2cG2IpxDEKFWZENSpwe3nNzrgVIbgIxlgoVoZVIouE7ryfCaJMz0S90rZRwz5K9DUUcJ4q6F5cDC
e3xSIPcEn6zTCNxEKXBw4r5b/n/zh5O6V7JwaBY2E96spAeX63C1RNBsK5LN/BWGglujQcUOrdOV
fmoTtpxR9zpOo2KihTjVWEwLQZE5DZyZxy4RlkKx/cTB2Lf5VG2H47Vi4V43eMkUo18yXMocdGYI
/yTBOqFWEWBQDxTzwK2ZGNmFg3Wa+MTCzNjnA9BYLwPHZQwTXtsbAPiqBsJlNw9JRZ7abliIhIrW
dXEn8VfrQOa6+z2xb0ONxbugSpb6Om2O4+a2hk4gD1PW8VQ7p59jfndbxHNzWirter9hX0wYUyN9
EIBMii4nlZRL5wAnacC1e/jsgeU7mw3RmSJJb3wxtj2m7rU9JRfARnbJ+6Hwzv07YpSlEPsYXlwl
jEErzbjaDtmL8+63/ZKlMh5k81Blk7TDAxU1qRA63GBTEoCaNY6dspnDiIAcMflrVdm580Onda/E
Tydab1ILutBiA//sFCRbwJVmfD3UAMY3UWt0R0HLAKkMgv91bh5FqpnxQl0R2MehZFgorZ1FCSq6
lC04GEofTmoJhycVTo9oLJS1CrRy99t+yUGy6LAS4DDX5mEQwuVZVli4RuAAlDC8cVrbuXd0Sdqt
R4dY7PjipO61w0qrYPC2FPVLqqLfxxpdnlJhMxG6ib3qsNaCsgUAAp7iY7nf5j0P7ZdM8QHND/kZ
snJaiIkfc2JGH4Dhg/lapzEd4PvplrB61UHwEVxI+22/ZFKb8ZgW2PPiyTOLrNCljlFPMlSSLqfR
aFmnZsbDOjUS0Pjr5/OWB+peH8Pcq0kEbBRFHoNlH2jHMZRkFwVigAo5wWTnIRM+rf3xrzgFt18y
zeNgh4Ask5bHPq2ya4XwibFlIPhJS1wZDA9b5/IffTBVpNBxzy91r+fwCAqCyGL3ooBojeTwVdgN
a+yyQ0+amFgmINeq6XHsei7rCe5+qXv17AB8co2tIo2KWYViaw7/YOqC806lXyIhxB8YbmHII+uL
m2S/8hKmwAoonY6nyWkiAmvwa8+bC1WMElzI2Bw0IrOGmUui/WvzMxATckZdpuWMSJLqhU23zMw+
RZOXZVAEL7tzYmyzGyeuITmrwAdaO/92Uvd6hnV41mbgqTmXlKs+qBGcVimbeLRaHGGfZJIPq4x2
pckpb8R9v+WButeDgPjERTyBQg99Y4h/u4iIwlOkQSGSZ7aGlZ927oICB91q6ej2PFD3ehjjUkx6
Uqox0iEUXr0IhoV6KiNpeRWfG86XWwLvzZJtN9bc+4K619P4TZT53OU0LDv7DW9rUYc8PRGydDkB
6od94A2Z7JV9EdONkfd48UuGa3r4psYNg/9Ew6pcGRG1QifWbxyWAC4dQuI3Q03h6+Xz734XfJJl
t0rNZIpiqv2Gm4+0RlADIXMne2M9DNHKQbxw4mGvIde4142617UDlctRImJEUqSOxxCWqkARf96B
VCv5NM/JwTWmAcJgYHpvW/9S93qUhbmHygpVAnsyhHyaQ8QUM7Y1PCchV8HBgnosKnYHRZSDWHU+
b/+ButfJRjgFqHjfB9tkEGRQnUZLrN+0c9CzNa5UClhV+CApQYpsPH3Xzc/Iu/c+poDLSliKfoYK
+rmfjl9NXGZJPFLwoLrnPKzwIPXHudAJZu7AA6q0uedp3Ss0+UFu5ZGWcHqckjAxqbyUoF/m9ZYv
wh5kwyBxw+NMuAenR+rill/qXo9h9u/yICZe5On5lsW8Maunb8pTPY85Hb7/+CzwCTJdbv9d78lC
tR2ScW79hwOpux9WSNrcAfo7bC+10crUU/2ws9xG5YTLNyeg7nUi5QtH67Sc0Ja4UDM8kfL0GAIS
irEfZnmgqINtii0fWzyH2mD7fdS9nk/zM8qvOnz4E0Ene4VBn0MdM+wNgEB+iLh7kRZd5unKCs3b
Pyv9EnyATbdkSstqf4y9aRKAElmeU6JHgLAsnELizqUOYLUs+n9+Gi95HNT3gjE+zN8awE8P6KEL
hmwxUIzhghLVLP0SWuxkB2tO2DdueaDu9RFbuWp48JkIr1mAid811bC1SzKVEfabHjabjgldspY0
2Nv87KTudY0t1siDmOFkkidPYFd6dpfDIEs1S/XqiQ15aF89NXrJ6owvNgcHt7Sdx19H0SxU2WKN
pu4wNVZzeOSL9Iuq1IIzalzXTnSJtJfTjYjvvP9J3esAPRxyPM9hD9d5Ee9htS/LJ3S1zNHiGHv8
iJq0k5LXx3SqPPywz1FRdN72mP1pLf6lmHr0Qvkh2iZ0G9YZktaenjYL2d6pwFrgD0L00PbtV1v3
SpX9MS24NUFoiQD+DicQFrhnegju6Y5Ce7C0a8jXESOLV8a2NXsfU/e6hluTYAdxGnjCj+XByi1i
uJJEcmmM5GZml+9S9HIzKzzs0HX3S32JZ1GtJMfIHKLBQxBHLaznBj2CwuGKA9JzwmRP8pXHYT0k
EZ9VH/f5lpO610MuR2ZpUN14nKoLK49I/phXIyE0jj1oJYMJCqdbhg7uYTjX8x7v5brhCepqpPVq
EhloETEraQdAJiV4FhWoE62FVa1YyIGRdQlSOYMntj5LNgKI1kynPMhClY3sEU625BIfwxYXAcWB
VzbKQ3D7wwjFzhcO614tweCY5oCVHRiZgyrs41aMrJtn9cFIVvA9QiOAU0kUhHj2qngu9bn7xS/B
Z1lg4SX2f+AzhZB9135bP4n7EY7c0JzI05V2T6E2LVu7ueew7rUsPVAkDXRJdcsOPB5JoH+Gu+GQ
UwiK/BzP0j0YJhyR+F3PNah7PYmCJvrhIcQSKRAAHRzvHak2JytkZSLw80Gt5IH+fRgrltmY0kDV
7he/hH2x8NjWPqWBUyfhNWmIajg9DGguc9tS4vOxM9QMfzuV9LI5IlS75YyYVTPCqYDpeQYM9lHW
UBhee1LVQ3Ds8tSBnB5QYW3Kf8C7W58N6l77TRFrNt3D+vFT8cdn2g90tWzJ1gEze/ghnC8TwAbY
1ng97/HCSwh0T1DquYwRXGxqDKgnGMugRN2pXwRWHB4KwlDXDmGJTQwQ7nWj7vXcmQd9TfPHVJMx
yWvoARIR7JDfc6xDuHExv7gY5DCfFuSW87XXzbpXXujEPA0o8dhVPvISZVoHADAAiV3klHt+kXNt
6XaRgXjmnfZ9CoO610V8/PAMhxWzOzLBEZiiM3UGRtHydzDOqfKhBn8+PY5njbjlGPu+ikHd62C2
HlTInIchegl0PBGIITml+uztCyts4ZKHDAkL1vaO2e+XNGXrB+peT2nuNuyGFpfhCfgvFVOWXaov
86GjY1fkMckSRc5/eK7DtBL9ck7YCltPJkK8zsPKwHJsTjLRx2kjYiSPe0/rs1jV8kQXhRlQgbHz
sYO61wPAtqwJszxPEGcUfe5tzUxrQ/Dx4FYnLsZUFHDIDs9awzHX3PnYQd3riXI7LL01NA1PFYKP
kfJFOeViBac1xER3k9qXc1edPY3z9JXYq3XPL+dxoB+DKq41PSLmEX5KjQyI+fwDiDZxpE82wgDe
L2aEQhIiXwkS2uvM3S/nccxBh6fhrS3y0Ok02sW3sgBSCLDtJqk3Q1jM3dOqMysjyeAe227ieL+c
h2ku1s1dNr1AxmsFNEE7Uu7du8/VIR4cY1lU9A/SHjO2ZDK/n/ptv+QU9s/D0hJ2NHmUqYo8/Mku
MUYeuU2fT0A+lVp3GflYXLjn5tXDuldPADz3hTsOxpwuURMB4/YKkZ9pqb/nvqhp9ECjMMjaXWzY
HOfdL+dxrn1sFi2CC1NbkfKE0859U0zQYd7U8lrYLdBkH04Fs0xFfJ8ng0PDozBPh8tjISQRBPkk
0joL+t4tXQI9UYSNKIzMxJHOIa4hzP+4z0kwUb0vjHEpbnia3DMVMBV6Z7BFl9hn4OEOln0S+6xp
ZmB6LsobhgiU9nmRQd3rMIhZpj+0VjrBwyX2/TyJ5jxQeb8cIKkIXE4I85qqdHT93Oe7h3Wvw9My
lr8r21B1DvGchBaH6pvS3+ENSpQID6+8KalSWeHmdQX4Svc8WPdq0WWZCkVM9opP/xP/HhsCszyI
gM+npmIfKdEssgQ6sBLmfZ8C9wm8jFO3xougpqJO2HN5eRLGwEIKoSr72Jprz/sTyh844cOzw3hD
a457fs3jEK1YyGaJrvqXmpO1k5zSZFTT2uUxzqp+n1LgtNgBZj/u+S32mxclGW2TW+bswDjcYCRz
KJUY5VFT9zHa0cpPVMjiBO6axm+qqx13YyNb71ic7qmo4ZkainXDU9LKFFWeRh+UKFhxbpgo4fam
GE6fnGlk/7z7pb4E9+px6RgSb3pYbJohJjzaVSJ4whwgmxboCVXD+MJiYdxFRYaEqv0O183BwLef
dmRMhTeAdZ86+W4E03zElksudxqFsQ44wR4dvfb9MIO610nYPDzeSp3C0n2mivbhxF8bhlBuBw+j
FPFx6UOrn6xt8igZFilvf5261zVNtHss4zCZ4pFM3GeT6Zf3KeDoWbE1PfiNWUKPWNTlDVXLqGbH
x5Qddhzr0UJ2D4BipDvVeh/rqVIPhVShWtTrREKL5DtAHZ5WuMHD7n7D+0s4n/VUujAyuVEQknz6
LE7uoSSWFtcNRu7XhDylqYPYenoycm1+hu19OaxBX94xIN40sj5cN+eBnUfxFdBibv6BX/LwpMCu
kvYNsTD7PPqw7hUCOfAfKCOEuqJArCrxQrBdWWBVKuZGZQ2EtjKGiGQSUE2jhE/2wrrXkAlQqhYK
LCeRp54EkdTc0+jvnH1/Yqa9OIZoyWufprIU9zyQx8FBXtO619NDy55T4CTaaWkqS4ZpsyTJqz0e
VCl7TJ+o/CC7sPZkxJYz6l6XeJwjwot/Doo2jsOiVtKSwhuuwDjSLATh/XazvWDFEwUABF3Zdcdv
1L0+vHbOW4Iu4RyFmGTCDgY4QosQzqDSgj7D4ea41okHeiz/0Rzc/VL3ujiY8DC0KIsCgRAEGb1G
urmuMyKWtvSn4DHY7cM41hJzLf7Wk9S9LsuCsZGHJ58ICYeVEFahDNeD6I5k5DRN4bVhHuycFgbD
hI0V89a/1L2eU6ViSfGwJWbXyoLT3YtHRYaPXPzEaB1eYWBxptNnCh/1dhw3J9h1r57/RXNu4k98
TBxwpj4mTujTi8YMZod5fGthi8ew3EBHePV87rrMQd3riaFa3jVGNHjCTg/v0dpUB76CNzKpoD5U
37LpaQS139XF0Fu454H6EssGpqfstx1yvCx7qbT1jun3cJbcg/4n+00fDEF97gTIlgfqXh9WcZUd
EVlPg1kReGq/CQa88mbHWWgF/WRsmZftOTeHem/XGw3rXvdtA55o8uYTdw9qqCx2UX4pKGTJ1vRw
aimK6Axto5JJZBTjHm/7JRMqeRqciY+9ZIgVPyjFPqeOyLSWz+wGJBg5N0tY++YifGJ59ad+8UtA
bSdpq6H6pDbu9DAeHs08DJT2O+BlYa+QgjP2RSzsd88emf28/SjqXodnCSHSg+K9NS0DwFewShg3
+xyWEeIhuJnNLg/r+/Af8BmXxbfrjrOoe32UhaanEyXuJtBNqzoAUIafQBOyN1OMjxSMwws1zByW
XVImNLZfTd3rSUp4lDxoX+KHN7K8rgXRJZlDjL+wQ9O7uMxa7BIxMt/UDy2i3Hnc46Xu9bGNzJJX
azl0FlktojZqmBch3qRWaA5Lxpfv5UVNVCKffqT4Z+8L6l7P9HyLFz4A5yxumPvpPpBAGyfCItVl
bScWiZsz5pAwk85YliPffip1r9OT2aQYKFvgA946hnMi65UPIj+XV4GcDAufiWU8LPW3ggaLv6xG
pV/qXvGhz9OT4VMZRKWfTrKKBiNnHZNgFk9pWHXxtArGkQT/OFX3upHHGWrO7ZETCqEuyHxPKi9n
Svm8QZSwYHq/0XLQiFFqjJBMfLb73AwHaHu8uDW8y0lt0SAVelz7fhavzjPPqwBg7vaLG8+TDqTa
4LCywTMDm3tSo93xkLMq+NCMkd9k563lwVmVFTrR2xOV8xAuhx/xlVBIh7mw3P1SX8KDB8eXD+u8
LYJY+5Y0jmCbfPIGGJhPqcXgBNyytTgVOzzTRLnUvOvwpnWvT/PYRrsSDtSQB1rwMuZhsOVVNhx9
I0Y6OXf2ENMBw9fScTRL+bznlzzO8sQ37JSCvpOkwCHiOl2eUx3OtQJPr8Hl0TvH5FAhhOXMEbfs
fTGte1XDemuTR1YYzCm68j6xax8D8ICp9Z6cTlaIob6acQ7UnDpMdx0IziV2U8nTr2YKNDcSMsDl
Tr0REeB5HJ4iZvYHUzupnFv6HsNgb9fDTOpeRzq/zIO1ERYeezTKMp1S75DWwaotNvOwoCWsdt3T
53Vs+CW3/Fr3SkQ3h2extL2np9NI72PnvXSFErWDqqw5dObMhtNRmPJC4gHTMzc/m9S9npRzr6WC
nsoU+9MJ9UZXdg3M8jj2Y/ywkqnyYVW9tsc8/rYXk7rXxeUKy3s+yKYtC6hMROPlTMm8xQpCCx35
Y//jQuGDGeMTiObOm07ve12eSaNAgqBk7mPG6bPaK/Min4cJIfSp+b/lRYt4VEungM630Vj3/Fpf
4lEYowV2j/fOor7PtP4XP4rCmklG5Zz7oiYcIXxSa2Gt5qBQ8pw7P8+NmB1neUnA6di8gZaM6+Xw
sReH74fCh7aSX13ewKC/biUGIOcIsyDH3e/JPb1a3KWDA7DyyrpUChBsVPVjd+kUAEhcB/Pinhim
Uta089r1qdwZ8HLgl5Ap4qOkpIdV9pp9OlIxqrsodfJuzH161SWgnvfcl3dgqHfczfnJ1ut7bPCz
oZRjeNhvZJse1qJeWmZqiyw3gSAtMMeExi3Cz2XJF0kB+6W+xNoty5usabEsI02OHP6n04gWnWI9
QgBiCatrrn0JMYbsUKq2nFH3es79KaJBd4jin+pwZtB5IOkMDTynNtJLoQgiWYzFadTFQdSZt96x
7hXN8sBaLU55TmkNxHYSTB6XU6sGgijiUS1PQi/vC/JKY29gwIZd+5wl2J04S3KhYE36NWGAwIID
sKWn5VWCw8swwluVqNteO15gJN4isfMtwBvuFVbrYmwtxz0t+CL/RmC3lXZ52R3aw3O/wmWCXk/p
rS3sOPLHPQ/kcTx34K3gh6LDgVTPplgQC/AY22ioLE0NOVRPi3vzlcdPU5287QV1ryfZ62kZ/thz
T9B5Wexo5sUlw6UmiNJ99gC8xNjQIjyakPr6225S97qkQJQLnQSY52mwg8byTidT2FMnFA2wb4+R
CzJA1AWngnk0lmvXZU7rXkEaMy26NNQ0M5revO3FkP6Vx3BswVu2yJUQo/Vraof2Vb5cGXLrB+pe
F9N+6lZQZXQY4O37QLxSAu9YHu/9uODjSb5yealDevsmXrcgcu17vyZ1r+emktZ5QwemCkxZxYnA
kEwTmml4D4QIMz+qELXCfgy5nV23Mql7PSlDesS+lcUPYIekL/BX8SpHgU743drnDk6npaWWZo8w
NUSSM3Z+c1L3epAcnhbW8PlFcfpJpfWydDy9FxCbQ1pwWd+NQ0bNLL/jNBS2BmfqzONeN84JH7py
0sNpbY91RF6/zbbel4o5GIDHpp0IFtgAq7Y8zfc0f7LPX0zqXgf1dcMLOLin5gFZXRY5W29JFnbe
v3O8bVdC14Xrli068oVBritueaDudZBbmfDJ0xuysdWLtMNIr6JDup6WlkDX0kQBMSjGcEkevegG
orli32fDNaWt1/3SAbIAhIvn6c2kUknU5vamOZVwLx6B61AUGQROJZDyQZQ7x+3vUPeK08PYyLun
Z+hMpnPDjqW/lvCbYdO989Yz4qwQIHDKdOzn669vOVuex7kUBU+Zehk9UuMZUA7lgEhX6Pgr0yR7
wyvl2Yh32peptQ760zzAS5DQZb9e+0HSZZC8HN6lJJkHhp8WpZxmuTVt3hmDjytz9+bMu46fM8Qv
i5hqiRABhwvKN00KIKvLwnLf3lMiGMrT43Dw3Jke5jKxwXCOnS/k3N7L9PsGcqcAkR8vsiwvGAQg
YCD0cMOyZLeOyhI17525BJ2nt9eune/mrEOPl3jI6FEh8l6qtX9ysXk/wzksKDJ9Pt0muIaiEs/X
EMtQb7X7hZeY4sUxnEDVk6ThINd3emW9p8oJ6k+hpuqNEGB6T4/+rxe+7aPPc+t16l4fwghGtPDU
liUVnK6Znqm3zG1pQb2GQEBCqhKfYnAHy/D2ocuC2H2ejGz7y8PCGtUWd0AdOLzLWm4JGZnv0yoc
jygfei1l4Z1XaOEh7e/aQJnc/qR1r5cb3WNxkBPBKGp26eB4nR7aY3rhz+VloPsgquGZdoWyXcK+
+/4z0OvL8GJGTzQRnsz0Ljn8kmmO33s4cU5cHkrGh9/hUZ4UuBwTeRFvidv8gTCJdXMw3g+DL+ax
wPCrGRwgLokgxRs/jFnZF8d+L5fRWjDcmVufUfd6cFJpeeaDkGV6ZYdhsI38Goh9zJg3RWMex1b9
PpCVVgMuTx/e4+W+V+9+PozfrAyn9jBkln5NwOkf6GgfmcS6W9QAeSS9tihpG56Znbe/Q93rCcka
wxonTpmGisbNsZ+A1l+abFfcm4PMHvmaeGp2jrbzVhr6Le7DUx0RFO0r64FzJInmNLZl8wNZHtRR
jcsLvrFDl8W3wFc2+PJbCGAi9Evd6/AopDecsb2n94NPzY3f1HB4cSwI0/PlHGsSVXvX+7ZvLhAJ
hbvOZlL3unC3x9xXw/Lg1F/up1tAcBleizDTbYJOHN73Sn6V2Fany/KC+/6dSd3rse0s7orXV3oJ
7/CGPvKQuDqDMpZ5eKOgRffCoHDkhOES7mHn216UvATn8lLvqMgtqpUdEHIf3nO6L1/EGxFAmSE3
XT/98hLI1P46jm3frHuN/fbsARNCzlZaSe6VUB6Mc8mY8/Sv7EtCoRCQE5EgyeP8tG7cq0Ylwgq9
jGkVICBD8+wDy68kwDXzez3I2fvtOaFC0ndVgTPxmfc88P041DCs2J+n6mtfHoqqPlUlbPDhKRVE
0XPjfl9HelBS+SVGczfe9oK613MXTOprEsmRpB+X9pB8QJoU8JZDr0QZPhANRHLaRLjnE7xiNfZ9
eJO61yHW87DwlKdeus++s19ooozg4DhfgHprF7yScG226X0v3kN/9wsveeq9eEmtx/1cHhMAElsz
OlrQXZOL/2KRC86UwYDgh2TzOW69Tt3rYN4emizvEXCji00t/wk9Kg+DTOeB4F95dAv7/SakPchm
rrj1A3Wvg+TA4TcPWBw0PVJHbpJYYpiVsgLWwjsvVWBWV6osCaMwstPgMJ/3eLlXTU+fQGF5M93p
fSv7O3NQ8+E+YqsLl5FVwSWqae2LsMq2/qN+WNa95pbti18jAGRIOCA3vV9u3/INOVGI8EGWV8OU
txxCRb2W/rCC5VO/8BIKaE/vethfDgPREyl7M39oD73G09elPHB7b9ghNwwUbKLXV269zrdZvJxK
l8QHR3b5LUV+VcflnTyycd/GCwaEK8MDuWzJ8vn4FJc3MNzjhZek1/lffoDt6oF197Enu8IR+Sx2
CPl2iUVKdj10ymQc227e4yWPgyo7gGPTMyee/7WEyGIM6heP+yuC1P9YVRNY094w1EJoFde4x9t+
yRI+rj1vgFEPKIcziOS72NZQeAWS93gREnpxy9QHYjd6e+LY36vBJbgvB3bg4fV0FutaLGCxmEdI
PWAqufbbMbwSkNhywdSWKMx7/i6/Pum6++VeNY8AGsySXFu5s8HQD8N2zzJyIAAUdeIPHHC2ZUEq
TtqyYGh5qdinfr2/xFk1ZvVeM89qemCI/JvqQgCV+8vPePTwTh7838uvXyDI8e6RfY/32ve9ukm1
QxZogBSW/BWA4HmN8qImSSVqAPSx0tlXjDRtHrTYfhRX1vV4FU6qfNJ79tH+6WJ77gD1YpDsjeXe
+u7xxMuX89SQ54lNnWyeyk1k7fdhDKBWE7k8Df+EuwZW3o9omZnUDpkanB9deMzT27Mku7sSefM+
rmniHKBf+ON+Q4jFEV7jIdu7/AdxMgASS7uMlh9Nn4oGxGRfW59xJ07Hm8unM2XTL1xjiYl208V2
b3MO+9hP6EGXxaHWRKgVzPV5un7nA7gIhXNqqkM+tVOL3vblSVkrzJBVH008prU2M8vJoGXwRNQ2
wptJ8p4HzuM4v7W/OgvIo4LW/336TR+OnBcnziKwWqnqtQ4Em7APY0PXct+7yM0CbTeZvFJ3GOAR
CtWu1rY372HDeJa98dSwD9xblra8qJTqnrv+gQPrL7P8Dd4A1HdS3jX9kgSPFFO7NQ/dYZiWXo4O
jhe+l+UjmiVixdyclkPDvY+dRsVUY5ROnl9KpRR4YQqrur8vD0OylDg+DIqSMVifmpvDcIjx5XH5
HVgegJEreE+kyt1LoT196Iv7DTHTL9ZyWoBiw8nw5nqfsMc7PCdMBpHz69PLOJXGyxN5KrXyCX7R
pJ37Nkw8/kN5ewyxuLrluf0Hjku1feM3Otd0vrYqIbDyGg0crKUPhMt3enjHLxsMBVsN6JYUku7z
mxyieTlPr8C0co2w0jIsK48gMnPuWXLFTQtqsp1fx+tQeSV18m3fRsbj8aNvX3//0a8i+tEv/v3N
h79+/NPbd//2+MObb9//hS/mfc83yT7evvv45sOb/hxfafvNm49vvvZ7Rr/74cN3779/w5fhIMhY
cRNr6RFuY24LR8i0s0sn9mb5ZZ8SBO8spcJolnEBnsWdzOQYAV9W6PRSxIDa9fCNco2OmlDVZZmw
NyUhystiQuRuuVys1PL1azv9FHC/LB63dnOcN+LxRSC5iPoW7tZSYrwKnavIll/JgT1fXKS1uCJq
cdp+1S42o0K4+8WsUFe5rF1UiZuzJCGwjIq4DnBxjc2i4mJxg9niapvFzQzL61tQVatu40vx7OKk
6/LeLg5ZLe8k8SwOZbSLOttFeeOyUJaCmEVEvAxaVW1+lxAx96rbmHlprIX0HpbXAqIRFjhsQbEW
TGGx5xcVrMuvrOAQ1OIIwuJM0vJECyHtqp2soDis+0UFIPWLgyvLe5c46rE4fbC8q8cbIqjeXhZk
g7yWZUMU1Sx20YLWrjv5Sm1S98sGwbwuNO5S3Qg9iOoX8fgi+l5ECgsvdGFbllcbqArZHYuc6bpu
p9RLY8mCLdJey2SXR4z9qg88kSU5hB4tL3r2Xm2AybJiHRSxDPeJ6td9aHV5aSxh9CLcXR4mtKzD
QNLIilBjERcsvWBdXLzbpUOJg7jQfgvPbV37ECjp7u4XWUH3LZWM9xh7q6JbiKraBQlbFIcsLp5Z
lN4v7x72al0Lwq1UufaXspGE7X6RFW4yW16/ZgWtqTCc6IVVXFznsDzTxinKxXm/xeGFRRntooR7
WbJ27SLBZfEs+aWFs7t03jC5S6IjNdEv93pprT02aKmFKexduIyLCpElcrvqXjeSQXqGGiS+bGJx
D8DyOxS8zduvCPBWfA78L05jL0p8A9AUXOsRFM8GdSHx3Id6yGG8BJctBCfxg0vMgovFgktxgnq3
gM4FECE4MBekdIKalQBEB4g38I6CcDueG8IB67vfk5YnLU9anrQ8aXnS8qTlScuTloNnDVoMWgxa
DFoMWuwiKzhv9ztoOWg5aDlpOWk5aTlpOWk5aTl51qTFpMWkxaLFosXtPFI8G5yJD+q+g6Ks4Mx4
cBA7OJgUHDwIyiwDIhmUOARwMfCEguLzoDQ8qFKN54ZPEK7uN2iZtExaJi2TlknLpGXSMmmZPCtp
UbQoWhQtihZ1r1uxbkXLomXRsmhZtLxoedHyouVFy4tnXbS4aHHR4qIFMnI873Vr5yaodwu4ZQCE
gpqyoB4sKJkKinWCEpagpiJAzEGkEvjZgf8c1BcExQBx7GQF0W/3i6yQYw0ypQGwDYB1kNUKklcB
wwsgRuC6B15ogLoDFBwgmQCixH3pPPFU94usgG4DghkQwQDfBdQtwGwBNguwWcCnAvwSROtBkB8E
+UHQGjekJ0jofpEVgrsg9AqinSA+Cbz8wHUPvNXAgwx8vsDJCzyswGMJHIDAWsdxO7sUzwZn4oOs
b1DcGZz9DY5kBMVeQYo4yIQEQWiQCAyS1UGRbVCqGpSqBgQq7i9Rxh/tfpEVSkiCdH/AcYJIIfC+
AjQVYKiAFAXgJojggxA8CEeDsDFwNuK47nW7WDdkhQtwg2uYgntrg1xScP4yOGcc5C4CNBWUyAdu
ZOC+BQWRQZlTUOwQ95e64rO8BBFhcIFecEo1ODsZXBIaXJcR1L8HJWOBrx7cWxOWigJvg2scAlQZ
lPnHuZNM+CzdLwJD2UGQ7g+S5kEGKUjqBtdPBHc6BJwhOKwZHNMOsHNwFDioHA0O2MS5LzvDZ+l+
ERii6qAENMjgB4nhIMEY4M6gZjsojg7qL4M6wiCLGxSbBdVfQVlWnPtSHHyW7heBIQUf5PuChE6Q
GAkyFgG4D2BrQC2CWC9OpwBB4aKG4IB3cBlBnHeQQvFsUNAflLYGRaNBMWhQDBpU3gWp7yBxGlC0
4Pj+LNcBaaFqOQAgQXF/nLv4EJ+l+0VqKHOErfMTfSA6VDwEeD/AmAEPCDz54D6e4KhhwIcC1BOw
mhj70Ak+y0twb0Fw8CqoLA8qboO62aBCbfoVn3isQeY8yGgG2ZyASAaYJjjOHMRds/ZlD/gs3S+S
RKo8OFEYnMYLTuMFp9uCwy/BOZagHD6A9EEJXxBqBGg+gNMBN42xD03hs3S/CBHp1SDDMssnIEmk
CAJkGpC4ABQEUWoQnQWhQlDwFJQqBfXWMeY93vZLgrx2UKEWVFoFdT1BsiKovwnoY4AUg3gqqFwN
ivOC0pSgdCOomAzKCmPEPb/tlwT1eUFBXpC8CmrKggKpIIEblBQF5UBB/U9QwBNU1gRlJQHTDupI
gkqKGPsyRHyW7hdJotQiKIQIyh6CkoGgPCBI7Qfp3SBpH6Tlg5x7kCoPkuBBwjtIc8fYl1Dhs3S/
yA8p4iANG2Rgg3xqkMwMUo1BmjBI9gXJvoC9BvmiMK/DCbIgcxNz6x18lpcgLROkW4LkSsBSA/wd
QOeAHwc4N2C0AXsNaGlARAPQNolhA3wZ87zHi18CRgxYWwDLAvQVoK+AmgRAKkBOAT0KUEAQyAZB
a+wuHS/SMrfewWfpfpEajowF9eTBGbHgPFhw3CsouAwKK4LSxKDALyzGKoePyHAMKDgGFPeX/OKz
dL+IDvm+gGUG1apBBWBQhhKktIMEUZBSCfIkQS4ggMhBHBscjQnIe8ydtMFn6X4RHc69hMdaLr8e
zfGm/9AHQuSFV940s18cMeIQSVAJH8CROee9bvglnAsJDngECeqAsAVV0UFdcFDXGZR/BJUXQeI0
PH1QriAKCcYV0IJY29/BZ3kJjgcEGfmgoD8o0A8K9IM6/KCuPmCeQeV8UOse1LMHFetBbXdQqR3U
mcXa/g4+S/eLTEH2A4oVMKaAowQAIeAEQcIuqO4NCh2D+rWgAC2oLguKsYLMeazt7+CzdL+IEyn4
IEsdJMWCHFWQ5AmyNEGaJUiWBAg9IJcBhwyYUcBUguRZrO3v4LN0v4gTtD9gbUGhaoChggLRoEA0
TFQBn8IvyC3fATVE2WZQpxnUacb9JQ/4LN0vMkWVZlBXGZRUBiWVQRVlrE2PaI5gUfwYfpVKOTdI
FyVNQT1ErLznF7+EHHaQPgmAeJAxDnIBAQAOv5OgnFrHW/4E5fbK5/2fdIAsrf1lDPgs3S8yReVd
UCYXlLoFhW1BjUuQrgxof1AtFhSFBaVgQQFYwEGDIq+gUiZi2zfclZeg9iqoqgrKqIIyqqCMKqig
CiuoIC0BWgqqpIISqAl4CaqfgqRckFCLOO7x4pdQKhTUBgWVQEG5SICaw1MjuJ4R9mtHSBf1PEEV
T1BeE+Trg+qZiG3fcFdItvH54RBohJxBsoJ6lqBwJShcCapSIqwFtHiB6aZWJKgQCSpEwoM+9Itf
EvaLQthlkwiFx/HLYSF7XitfDhABpEYhKEUI8upBJjxIJUesex7wS8heBjnAsBShfDVkL5wCH4Ps
QVADIhqQy9Cf9OYLffJQ9u79ZvEsICHInAeZ8yBfHnL/csqQQnLj4deQ6NLDbQMyG6S5h74z6aOI
Hb/hjfR4kUGS20FyO0hCBxnbIBca5JWDFHGQ6A1yt0FCNki+hudP4WwRdr6Tr3gjL0FmNcisBvnU
IIEapEuDXGiQBg0yoEEGNMh3BgnOIKMZpCmDDGWQfow7iYcj0v0ig2QZg7RikAMMMn9BOi9IRwTJ
tiBHFuTIgnxYkA8LEl9BuitIbcVdTI0j0v0ifiSvwktIsH1BoirIUQXJmCCrFGSVgqRRkDQK8kWR
fhg5M4cz5z2/+CVkXwLUHWRYggxLkKIIkitBciVIrgQ5lCAdEqRDgvxHkNQIUhlBKiNyH4bFEel+
MZSkNIIcRpCdCHISQU4iyEkESYgg7xAkFYKkQpBUCFIJQSohSCFE7sut8EG6X4SIjEGQIgjTwQaH
pAhiM37fmQ2mAgPcB+A+YPYBrg8gfeR1j5fDxsaWYPgAuQfIPUDuASQPIHkAyQOQHaDnAFoHbDqA
0AGEDtBz1D40hfvxEtDngD4H9Dmgz1G66iweCDpAzwF6nvovxhcEDVNPBpc+dOlvfx3Po/tFpvRe
NN0aGY2B2lwVqU5UK6kz1BTudzZuuC/dHLWL4PE30Gd8HpmCSAdEOiDSAZEOiHRApAMiHRDpKAc9
3eo0Q5bKXuY9XvwSsHSApQMsHWDpKL/scv9EHwgWbDpg0wGbDth0wKQDJh0w6ajNCfAtul8ECzYd
sOmATQdsOmDTAZsO2HTApgM2HbDpgE3HvonKBUWqal/miW/R/SJdAOrwehz9SSh1QKkDSh1Q6oBS
B5Q6oNQBpQ4odUCpAzodd3Ib36L7Raag1AGlDih1QKkDSh1Q6oBSB5Q6TPEJPEDVAaoOUHWAquN6
3uPFLwFVB6g6QNUBqg5QdYCqA1QdoOoAVQeoOkDVAaoOUHWAqgNUHdcucsWP6H6RJFD1VB7g1QGv
Dnh1wKsDXh3w6oBXB7w6rp38pa3NKA+rXZSAw9D9IlMQ7IBcT1118HWArwN8HeDruKyYnH6Yjvbn
+E8EClsa1+aTOAzdL+IEyw5YdsCyA4YdMOyAYQcMO2DYAcMOGHbAsAOGHTDsgGHHtfkkbkL3i0xd
LgUyBcsOGHbAsAOGHTDsgGEHDDtg2AHDDhh2wLADhh335RT4Bd0vkgTLDlh2wLIDhh0w7IBhBww7
YNgBwx7h8xEjQHYAsuMyMb2L7jD/3W/LVEK1E6qdUO2B75qg7QRtJ0g7QdoJ0k6QdoK0E6SdIO0E
aef9pUsY/ZcEbSdoO0HbCdpO0HaCthO0nSDtBGknSDtB2gnSTpB2grQTpJ3P8x5v+yUJ2p7omIRv
J3w74dsJ3074dsK3E66dnqRDFyVwO5828z8nze64kOLZBHInkDuB3AnkTiB3Pp2MRctFy0XLxQMX
LRYtFi0WLRYtbj+K4tkEcieQO4HcCeROIHcCuRPInUDuBHIncDufnmsq/po0S5olze64kOLZhHQn
pDsh3QnpTkh3ejyhfL+iefkTzYun2m/RrGhWNLv9dYpnE9yd4O4Edye4O8HdCe5OcHeCuxPcneDu
BHcnmDvB3AnmTjB33l+KiRF/SXB3grsT3J3g7gR3J7g7wd0J7k5wd4K7E9ydYO4Ec09C84R1512c
jOnufhEimHfCvBPmnTDvhHknzDth3gnzTph3wrwT5p2w7oR1J6w778PnWO3uF/mBeSfMO2HeCfNO
mHd6tAvTloDvBHwn4DsB3wn4ToB3Hg56H6rEVne/yA/gOwHfCfhOwHcCvhPwnYDvBHwn4DsB3wn4
TqKPxMNPnOs8dtEoZrr7RX5wThI7kIDvBHwn4DsB3wn4TsB3Ar4T8J2A7wR8J8A7Ad557EsLMc7d
L1ID+E7AdwK+87BQSyffJxR9IDcg8ASBJwg8QeAJAk8QeB43j6J4NnHjE5uaIPAEgScIPEHgCQJP
EHiCwBMEniDwBIEnCDxB4AkCz7sYClP8kiDwBIEnCDxB4AkCTxB4gsATBJ4g8ASBJ/Q7od8J/U7o
d0K987z1DsWzCf1O6HdCvxP6ndDvhH4n9Duh3wn9Tuh3Qr8T+p3Q74R+J9Q7z120jwHufpEa6HdC
vxP6ndDvhH4n9Duh3wn9Tuh3Qr8T+p3Q74R+J9Q7z9uvpng2od8J/U7od0K/E/qd0O+Efif0O6Hf
Cf1O4FFCvxP6ndDvhHrnefvVFM8m9Duh3wn9Tuh3Qr8T+p3Q74R+J+A7Ad8J+E7AdwK+E+CdAO88
95fpYWe7X2QF5p1+kUA5USgawHcCvhPwnYDvBHwn4DsB3wn4ToB3Arxz7Pw8dvYlAd8J+E7Ad4K7
E9yd4O4Ed+fQh17+leZIC5g7wdwJ5k4wd96XFmJnu1+kBtyd4O4Edye4O8HdCe5OcHeCuxPcneDu
BHMnmDvB3AnhzrsIHsPa/SI1kO6EdCekOyHdCelOPKWEdCekOyHdCeHO4fCRln2JBcsI5rbf9kvS
a4LLPpAfmHfCvBPmnTDvhHknzDth3gnzTph3wroT1p2w7hxxj7f9koR5J8w7Yd45fDDyA/NOmHfC
vBPmnTDvhHknzDth3QnrTlh3jl1khTntfpEfmHd6b0H54ggR4DsB3wn4TsB3Ar4T8J2A7wR8J8A7
Ad45N5/Ekr4k4DsB3wn4TsB3ej4GVJHQ74R+J/Q7od8J/U7AdwK+E+CdAO+8D4dgRLtftA3gOwHf
CfhOwHcCvhPwnYDvBHwn4Dth3gnzTlh3wroT1p1zx/MY0e4X+YF5J8w7Yd4J806Yd8K8E+adMO8E
/SZhbRL3JwF8EismEWLOfZgb+9n9Ij/4y6lhVfxh3umh9vsnyiGf/pU+kBvAdwK+E+CdAO+8L7fC
fna/yA/gOwHfCfhOwHcCvhPwnYDvBHwn4DunE4/cAL4ncWFCvXNuPonJ7H6NwZwHJAnwnYDvBHwn
uDvB3QnuTnB3QrgTwp0Q7oRwJ4Q753WPF78E0p2Q7oR0J6Q7Id0J5E4gdwK5E8idwO0Ebg/3IIQ7
IdwJ4c77y6cwmS8J6U5Id0K6E9KdkO6EdCekOyHdCelOSHdCuBPCnRDuhHAnhJtDLPZL8WyCuxPc
neDuBHcnuDvB3QnuTnB3grsT3J3g7gRzJ5g7wdwJ5s61L/XHUHa/SBK4O8HdCe5OcHeCuxPcneDu
BHfn8u2RIC8L9A58ovgEeOfa/g6GsvtFkgDfCfhOwHcCvhPmneDuBHcnuDvB3QnuTjB3grkTzJ1g
7lxxjxe/BNyd4m59fnB3grsT3J2Q7oR0J6Q7Id0J4U4Id0K4E8KdEO5cu2gUQ9n9IkRA7gRyJ5A7
QdsJ2k7QdoK0E6SdIO0EaSdIO0HaCdJOkHbeX5KKoex+ESLQdoK2E7SdoO0EbSdoO0HaCdJOkHaC
tBOknSDtBGknNDtjH27CUL4kVDv9NjrISUK104tDyycgSSDtBGknSDtB2gnSTpB2QrMTmp2x6xGx
kd0vQgTVTqh2QrUnWCZB2wnaTmh2ArITkJ2A7ARkJyA7AdkJyM7YcRbmsftFksDYCcZO8HWCrxN8
neE7+BjkBl6d8OqEVye8OuHVCa/Om1djHrtf5AdenfDqBFUnqDpB1QmqTlB1gqoTVJ2g6jl9AnKj
/gdM533pMUax+0V+ANQJm07YdMKmEyydYOkESydEOiHSCYlOSHRCohMSnZDojJ33xyh2v8gPRDoh
0gmRToh0QqTT40DqcIh0QqQTEp2Q6EwPyTAt4Oi8L5XGHr4kWDrB0gmWTrB0gqUTLJ1g6QRL5/5C
3/QnOkKMYNIJk06YdObmiJjC7hchgk0nbDph0wmbTth0wqYTNp2w6YRNJ2w605tCHCpqCDCdufMi
mMLuFyGCTSdsOmHTCZtO2HTCphM2nbDphE0nbDrB0QmOTnB0gqMz9yUomMKXYVgHm06v0AQmJoA6
08HoDe3/pCNkCkqdUOr0ajxDJlB15s6/YQB7vAgWqDpB1QmqTlB1gqoTVJ2g6gRVZzq/yFTaG7IE
qk5Qdea+pA4D2P0iU6DqBFUnlDqh1AmgTgB1AqgTQJ0A6gRQJ4A6AdQJk06YdOZ1zy9+CWw6YdMJ
m07YdMKmEzadaO5UU8CmEzadsOkJck0AdQKmEzCd96VOWLyXBFAngDph0wmbTth0gqUTLJ0Q6YRI
J0Q6IdEJiU5IdEKiExKdtTkiFu9lQngTLJ1g6QRLJ1g6wdIJlk6wdIKlEyydYOkEKSfkMaGHCeLK
2nWvGLseL5IkFjFsN77QHdazLNPqPhpx0papT1V5Co/Ssqdl3ePFLwFGJzA6gdEJjM7yS1V9AvID
kU6IdEKkExKdkOiERCckOiHRWXmPF78EIp0Q6YRIJ0Q6IdIJkU6IdAKjExidQOgEQicQOuHPCX9O
+HPWvqwaq9b9Ij9w6IRDJxw6y9sd7BwhAkYnMDqB0OkXlPGac7/m5T90sPNkWLWXBEufWLyETSds
OmHTCZtOsHSCpRMsnd46pVMJm06YdMKkEyad9yUoWLXu99AJ9W98HsECUCeAOgHUCaDOS0+JJYBS
J5Q6odQJpU7odF67vgRb1v2efpTmCBaAOgHUCaBOAHUCqBNAnbDphE0nODrB0QmOTkh0Xrd9o+41
IdIJkU6IdAKjExidwOgERicwOoHRCYROtaOyB4ROIHRevsht36h7TWB0AqMTGJ3A6ARGJzA6gdEJ
jE5gdAKhEwidQOgEQicQOoHQeX+ZNBas+0WcgNEJjE5gdAKjExg9FWeIdEKkEyKdoklIdEKiExKd
kOi8bvtG3WtCpBMinRDphEgnMDovxcm3QZIuRaYlqYDQBYQuIHTBnwv+XM/NEbFbLwWHLjh0waEL
Dl1w6IJDFxy64NAFfy74c8GfuXiMn2h20Oyg2eaImKzu96T5SXOu9GPjFkS6INIFkS6IdEGkCyJd
kOgCQhcQuoDQBYSu+8tBsVbd7/B1Ndj0Mehj0MegD06goxoKLF1g6QJLFzi6wNEFji5wdD3vOIC6
1wJLF1i6wNIFli6wdIGlCyxdTx+4aLl44KJF0MKXC1r46J0nwzJ1v0HLoGXQMmgZtExaJi2TlknL
5FlJC+c3aZG0SFrUPb8X61a0LFoWLYuWRcuiZdGyaFm0vHjWRYuLFhctLlpctNj1tBil7vei5UVL
T/SFmbD+HVi6wNIFli6wdIGlCyxd4OgCRxc4usDRdezLgTBKLwWWLrB0gaULLF1g6QJLF1i6wNIF
kS6I9ISnFji6wNEFji5wdB23faPutcDSBZYusHSBpQssXWDpAksXUW7hvxRYusDSBY4ucHSBowsc
Xcc+5IUJ6n4RHbB0QaTL89ZeT4OlKdh0waYLNl2w6YJNF2y6YNIFky6YdB23faPutWDTBZsu2HTB
pgs2XbDpgk0XbLpg03V470f6EZohQYDpAkzXcds36l4LfFzg44JVFd5WYYLKnbpX0Am1t+KBKKTp
SBAjKHVBp+u4uRF1rwWlLih1QakLNl2w6YJNF2y6YNMFmy7YdMGmCzZdMOmCSRfUo859aQD25aVg
0wWbLth0waYLNl2w6YJNF2y6YNMFmy7YdMGmCyZdMOmCSRdM2n7bLynYdMGmCzZdsOmCTRdsumDT
BZsu2HTBpgs2XbDpgkkXTLpg0nV/qSCmpftFfmDTBZsu2HTBpgs2XbDpgk0XbLpg0wWbLth0waQL
Jl0w6Tp3fh7T0v0iNbDpgk0XbLpg0wWbrtObU+yDhQJQF4C6ANQFoK5z60L+EPd42y8pKHVBqQtK
XVDqglIXlLqg1AWlrl3iaJfIDai6QNUFqh7L0W1ejUHpfhEieHXBqwteXfDqglcXvLrg1QWvLnh1
wasLXj2ng778h2b7PBkGpftFiIDWBbQuoHXBqwteXfDqglcXvLrg1QWvLnh1wasLXl3w6llxj7f9
kgJeF9C6gNYFtC5vN4OqFOS6INcFuS7IdQGtC2hdQOsCWhfQusZ5j7f9kgJeF9C6gNbllzziehbk
uiDXBbkuyHVBrgtyXZDrglwX5Log1zXGPd72SwqCXRDsglwX5Log1wW5Lsh1Qa4Lcl1Qs4JcF+S6
INc1fC9kaewvIcBudL/IFNC64NUFry54dcGrC15d8OqCV5df8YYPPef+HW2RJch1jU/z235JDd8Z
mfI6S3zuAl8X+LrA1wW+LvB1ga8LfF3g6wJfF/i6wNc1NjfCSnS/iBMYu8DYBb4u8HWBrwtyXZDr
glwX5Log1wW5Lsh1Qa4Lcl1jcyMMRPeLJEGwC3JdkOuCXBfkuiDXBbQuoHUBrQtoXUDrSQxRkOuC
XNf95T0YiJeCYBcEuyDXBbkuyHVBrgtyXZDr8utugLoFvi7wdYGvC3xd4Oua5z1e/BIwdoGxC4xd
4OsCX594jAXDLhh2wbALhl0w7IJhFwy7YNgFw667bhuL0P0iSWoWWHbBsguGXTDsgmEXDLsg1wXV
KQBJEWSUnpeWQ70zt1+NMeh+kSSlZr8ktgxyXZDrglwX5Log1wW5Lsh1TacWkYFcF+S65varMQbd
L6IDtK7pJaFlI5r7E/IDtC6gdQGtC2hd01lCboDWBbSu+7JqjEH3i/wArQtoXUDrAloX0LqA1gW0
LqB1Aa0LaF1A64JXF7y64NV182qMwUvBqwteXfDqglcXvLrg1QWvLnh1wasLXl3w6oJXF7y64NUF
r6516x3qXgtUXaDqAlUXqLpA1QWqLlB1gaoLVF2g6gJVF6i6QNUFqi5Qda1dF4QJ6H4RGFB1gaoL
VF2g6gJVF6i6QNUFqi5QdYGqSwOhKgVMF2C61s6Tofi7XwQGQF0A6gJQF4C6ANQFoC4AdQGoa3kP
QvqfNENaoNQFna6182To/O4XqQFQ1/LzXNRIZF9Q6oJSF5S6oNQFpS4odUGpC0pdUOqCTtfadUFo
+u4XqYFSF5S6oNQFpS4odUGpC0pdUOqCUheUuqDUBaUuYvaCTlfsPBlK/qWg1AWlLih1QakLSj1q
/2fwT/JP8Q/NERlQdYGqa5/pTw/g3+PFLwFeF9C6gNYFry54dYGqC1RdoOpBLFzw6oJXF7y64NUF
ry54dd28GpXe/SJJ8OqCVxe8ukDVBaouUHWBqgtUXaDqE++44NUFry54dcGr6+bVaPPuF3GCVxe8
uuDVBa8ueHXBqwteXfDqglcXvLrg1bXvLQt/R7N9XgRt3v1yhQVAZwJ0Cnxd4OsCX1fYCDUUjjL8
CH0gWODrAl8X5Lpin5dGkXe/yBQEuyDXFXaOTEGuC3JdkOsKvWmfgGCBrwt8XeDrAl+X38lFv/gl
YOwCYxcYu8DXBb4u8HWBrwt8XeDrAl8X5Log1wW5Lsh1Qa7rvoQK9f1SwOsCWhfQuoDWBbQuoPWp
xwi5Lsh1Qa4Lcl1A6wJaF9C6gNZ1X5KP+u5+ESegdQGtC2hdQOsCWhfQuoDWBbQuoHUBrQtoXUDr
gleXtwAd+3wWmrv7RZyA1gW0LqB1Aa0LaF1A6wJaF9C6gNYFtC6gdQGtC2hdQOvK7VejubtfJAle
XfDqAlUXqLpA1QWlLih1QakLSl1Q6konCJFJfSBW+r4MBs3d/SI/UOqCUheUuqDUBaUuKHVBqQtK
XVDqglIXlLrS3pAb6HTdl76hubtfdBKUuqDUBaUuKHVBqQtKXfvqE5t79Yl9IDzw6vLSI8Bl5a4D
QXN3v0gS0LqA1gW0LqB1Aa0LaF073cjzIdelQkLHFOS6gNYFtK7adSBo7pcCXhfQuoDWBbQuoHUB
rQtoPSBvBbkuyHVBrgtyXZDrglwX5LrqvMeLXwLBLgh2Aa0LaF1A6wJaF9C6gNYFtC6gdQGtC2hd
QOsCWhfQuu66TPR194skAa0LaF1A6wJaF9C6gNYFtJ4A3wJaF9C6gNYFtC6gdQGtq277Rt1rAa8L
mlvl6yJOUL4CyZXYC1pVQiloSqknpQgEKmXQgK9dN69GN3e/SJKmUKuG4i/UW6nelEtFQSlw2fcK
OnwkCF49jLJrx/Oo5e4XcQJaF9C6gNYFtC6gdcGrC15d8OqCVxe8uqDUBaUuKHVBp+u+BBC1/FIA
6gJQF4C6ANQFoC4AdQGoCzZdsOmCTRdsumDTBZMucHSBo+va8Tx6uPtFasDSBZYusHRBpAsiXV5e
rmcJli6wdIGlCxxd4OgCRxc4uu4vBUL1vkznCDZdsOmCTRdsumDTBZsu2HTBpgs2XbDpgk2f8gfA
dAGm69rnh1C9PV7UEYC6ANQFoC4AdQGoC0BdAOoCUJdG2W0CoC4AdQGmCzBd186ToXW7X+QHQF2X
FKr8ieYIEZS6oNQFpS4odUGpC0pdUOqCUhd0uq47nqfutaDUBaUuKHVBqQtAXZcT5GNQQ4YbAOoC
UBeAugDUBZiuayufLWfUvRaUuqDUBaUuKHUBqAtAXQDqC0B9AagvAPUFoL4A1BeA+gJMX4Dp63nr
HepeLwD1BaC+ANQXgPoCUF8A6gtAfQGoL9j0BZu+YNMXbPqCSU9g1wWYvp633qHu9YJNX7DpCzZ9
waYv2PQFm75g0xds+oJNX7DpCzZ9waYvmPQFib4g0dfz1jvUvV4Q6QsYfQGjL2D0BYy+gNEXMPoC
Rl/A6AsIfQGhLyD0BYS+gNAXEPp6bo6ISu1+Fy0XLRctFy2DlkHLoKUWrPhc0Dx4YPifNAuaEePX
7ZdQ93qBpS+w9AWWvsDSF1j6AktfYOkLLH2BpS+w9AWWvsDR19OpLVoULW55oO71ejqOomXRsv7v
mu4d2ZEl2s2w36O4EdeSxwVkPaDZyJAcKaTQ/B1t/Kvk8Jzu3sziAztZxMdk9prpNdNrptdMr5le
Mz1Weo30Guk1GpmW0Jlv3unnXtMyOi2j0zI6LaPTMjoto9MyOi2j0zI6LaHTEjotodMSOi2h0xI6
8807/dxrWkanZXRaRqc9dNpDpz102kOnPXTaP6f9c9o/p/1z2j+n/XPaP+f7supOpH/jNjXtodMe
Ou2h0x467aHTHjp8g24nhLSETkvotIROS+i0ek6r53zfB9KJ9G/cRqcVdFpBn07uaQ+d9tBpD532
0Gn/nPbPGY7Q3LR/TvvntH/ObI/YOfRv3EanPXRaQacVdFpBpxV0WkGn1XNaPafVc1o9ZzgTf/mR
Xq2Rmee7vafPW6PTd/Hp6WD4rWwFnVbQaQWdVs9p9Zzh3jBaI9PqOa2e0+o535dNdub8G7fRaQWd
VtBpBZ1W0GkFnVbQ6YtiWj2fvvCl/XPaP6f9c9o/p/1ztD7fSfNf2kOnPXTaQ6c9dPo6kPbQaQ+d
9tBp/5z2z2n/nPbP0XY+/ZGGR/pu7995SVpGp2V0WkanZXRaRqdldFpGp2V0WkanJXRaQqcldFpC
pyV0WkJH6/OdL//G7ZTTMjoto9MyOgIxwj/06g1RG+m0kU6b6LSJTpvotIlOm+ho551OkX/jNj/s
FNVzhbSRThvptJFO318cvqK15w9pN53W0mkdndbREY9DY6Rd59Mp8m/cxqm1dFpLp7V02kifw482
U62l01o6baTTJjptotMmOm2i0yY62s/bd4r8G7dxEl8Q23C2lk5r6bSWTmvpiBTwsHCXmilx85ul
NtFpEx3lu71Pn7dmqo102kinjXTaSKeNdNpIp4102kinJXRaQqcldFpCpyV02j/H+/mzToz/0h46
7aHTHjrtodMeOu2h0x46bArfU7O0hE5L6LSETkvotH9O++d4P2/fifFv3MapPXTaQ6c9dNpDpz10
2kOnPXTaP6f9c9o/p/1z2j+n/XPaP8f7eftOjH/jNkntoU8bvbSMTsvotIxOy+i0jE7L6LSETkvo
tIROS+i0hE5L6Hi/D68T49+4nY5aRqdldFpBpxV0WkGnFXTMAZubVs9p65y2zmET2p62xnyr7/09
Dn/nJWkPnfbQaQ+d9tBhC7Ce4aZldFpGp2V0WkKnJXRaQqcldFpCpyV0/H7j9rykZXRaRqdldFpG
p2V0zBPFjeEInZBaQqcldFpCpyV0WkKnJXTO73t8e16ymwU8/Gi/uPji599e9BvE2Vioj28L6rSb
TrvptJtOO+m0k0476Zx9fetM+Ddug9VuOu2mc/i4R29bC+q0m0676bSbTrvptJtOu+mwWWJPVtNi
Ot/nqzsJ/o3bdLWgTrvptJtOu+nThjctqNOCOi2o04I6LajTgjotqNNiOi2mc/a8uvPf37idrFpQ
pwV12AOasB0eER6CRqwtddpSpy112lKnLXUOt7eT1Pf56k59f+M2Yu2U0vImfS8RpmrmHTLd/GSf
Au4Da/B5BjujtKpOq+p8n6/uXPc3br+aPjzFjVir6rSqTqvqtKpOq+q0qk6r6rSqTqvqsBUyv0Tt
q/P11Z3m/sZtxNpXp3112lenfXXaV6d9dQ5PY29g++q0r0776rSvTvvqtK/O11d3hvuX9tVpX532
1WlfnfbVaV+d9tVpX5321WlfnfbVaV+d9tVpX33CsXaT6s5wf+M2Ti2t09I6La3T0vqEW9RMtblO
m+u0uU6b67S5TpvrtLlOm+tcu56sk9vfuE1SG+y0uU6b67S5TpvrtLlOm+u0uU6b67S5TpvrtLlO
m+u0uc636V0nt79xG6I22GlznTbXaXOdNtdpc50212lznTbXaXOdNtdpaZ2W1mlpnet7fevnXtPy
Oi2t09I6La3T0jrtq9O+Ou2r07467avTvjrtq9O+Ou2r0746X1/dWeyfX57Jl4tevflpaZ2W1mlp
nZbWaWmdltZpaZ2W1mlpnZbWaWmdaz9/1gnsX1pep6V1WlqfvrPPvRenF1cv7l6Qc/7u7cXfUdtc
p8112lzn23Sp09bfuF1vH64+XHSMJqmldVpap6V1WlqnfXXaV6d9ddpXp3112lfn66s7T/2N2/y0
r0776vD56nADG6KW1mlpnZbWaWmdltZpX5321WlfnfbV+frqzk7/TuuLtLROS+u0tE5L67S0Tkvr
tLROS+u0tE5L67S0TkvrtLRO++p8fXUnpr/b2yS1pU5b6rSlTlvqtKVOW+q0pU5b6rSlTlvqtKVO
W+rwVSCcMffEhnF7XtJXhLSqTqvq3DsN9eoPFx2jmaKvDs9Wg3UzUOei9tVpX52vr+509DduM9W+
Ou2rT3iKG6yW1mlp7T1q09XmOm2uFR60Rqz1dVpf51kX6Uz0L62x0xo7rbHT+jqtr087orTDTjvs
tMNOO+y0vs7DvzZdra/T+jrf94F0Jvobt8FqjZ3W2Gl9ndbXaX2d1tdpfZ3W12l9ndbXaX2d1tdp
fZ3W1/m+D6Tzz9+4nZhaY6fNddpcd9eO/l+v3mC1vk7r67S+PuEGNl3tsNMOO+2w83znUf3ca9pl
p1122mWnXXbaYYdX/HbYaYeddthph5122GmHHfaRCg9BU/V9SX7nn79xm64W2mmhnXbZaYeddthp
h5122GmHnXbYaYeddthph5122GmHned7fevnXtMuO+2y0y477bLTDjvtsE/LvLTITovstMhOi+y0
yE6L7LTDTuvrfN8H0innb9zGiW/nD89g49T6Oq2v0/o6ra/T+jqtr9P6Om2u0+Y6ba7DrPh9H0jn
mH9pg5022GlznTbXaXOdNtdpc50212lznZbWaWmdltZpaZ2W1mlpnXc9tnPM37gNUUvrtLROS+u0
tE5L67S0TkvrtLROS+u0tE5L67S0TkvrtLTO9z0NnVn+xm1+WlqnpXVaWqeldVpap6V1WlqnpXXa
V6d9ddpXp3112lenfXW+vrozy9+4jU776rSvTvvqtK9O++q0r0776rSvTvvqtK9O++q0r0776hMe
m++8up97TcvrtLROS+u0tE5L67S0TkvrtLROS+u0tE5L67S0TkvrtJBNa818PWInkL9xm5o2VKHS
oFLgbTvvY/se9BwO2Jc23nTyzoiz/57SuykIZ7bf56s7bfwLp2acrnAiwusbL2O8NvHKwdTP3Mk8
yZTHrMTvO7/W4dVsnazTxt+4zQ/R7WN02lynP5D9v4YoW0P2WJ2GWmSnRXbaYacddtphJ9/rWz/3
mnbZaZeddtlpl53W12l9ndbXaX2d1tdpfZ3W12l9ndbXaX2d1tfJfg9R54m/cZskvuxjb1vj1Po6
ra/T+jqtr9P6Oq2v0/o6bEtGS9MOO+2wk+/1rZ97DW8P2mWnXXbaZacddtphhw67j0PaYacddsK+
Jw8/0us2UC2y831/daeGv3H5gQarhXZaaKeF9jn7d73lTVfb7LTNTtvstM1OeMy50U1Vvte3fu41
bbXTVjtttdNWO2210yI7LbLTIjststMiOy2y0yJ7fm2yezlcist9Te5nX/unw99dXLL/efd5+LXZ
7iVjsAE428392mr30lxy3eG6w3WH6w7X3TVFnSl6HDFG8xV2vm7Pfdji7Pf7LhlNjCZGE6OJ0djT
rmV3L7kl7JT6bavQeaNHMWOwCd3Pu5s7Y5gxzBiHMQ5jHMY4HP9w3cN1D9c9XLf7EX5f2N4ZpIc5
DHQx0MVAFwNdDHQxEBtLtgvvJQNd3IiL695c9+a67K/TSryX33G6e+CvvXgvGeNmjJsxbsZ4GONh
jIcx2PK4nXgvue7Dddkgt714L7nuAm/nlR7nZYyXMV7GeBmDjdDaj/eSJO9fMNDLQOxL36a8lwwQ
BggDZOfLfq62f2KgMND+LwMR1CGoQ1CHoLY67yVbHRLQIaBse/8bAjoE9Ps4d6eZ7jnT7aHZCPY3
pJXNaX4z+zcMRFqHtA5pbZ/ePd+4EeJGEFP2hv0N2fw+3d0Jp4cho0NGh4zuvotDRoeMzu7ma8Yg
m2wW+Nvd94ZsDtkcstmS3T0f4DB/J0mnTfMJvxRDZOfsBsEMSWTn7L8yJHVXJ5220/0zg5PXIa/s
Wfmb741lP5DbP/HZB36U8H67ohLeIbxz7b8yEOFlD73sg0CChwTPbk1JctvL/8d/Mgn1KCR4SPCQ
4CHBQ4LZxPQ3JPh78p7dmpUjkOAhwUOCW9D3kuvy8UwmIfYcYgwSPLuVHwn+HpG9m4R3CO8Q3pb2
1kYue8kAYQCSu99qwszTwxDeIbxt8M95dlfs4VJcsgV5v7LrPPtzF5c3lw+XeyX+lXm2TT5HOZ0C
2Drqx66gP5FgkWCRYJFgkWCRYJFgkWCRYJFgkWARJPGk7Xd/M+X0OCRYJJjdvn8iwSLBIsHt+A87
L/5EjEWM5f0bBiDGYooVedX5npvud/gTuWXnup/IrcitmGpFWtl3+CfSKtIqZlcxu4qAioCKgIqA
ipd4Jpkeh6Cyv/tPzLIioyKju32qyKiYXUU2RTZFNkU2RTZFNrfzZ+JkZvnXvQv7gOyPMySRFZEV
kdWGYp99IisiKyZbvbtHPdclqiKqeve56eeC+yfGILIisiKyYr4VaRVpFWkVaS0M9JLrklIzxZqA
moCacwEmkn/90+HvLi7ZH5SMmoyajJqMmnMBk02TTZNNk02TTZNNk01zLsDM0eOQUZNRk1GTUZNR
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
8dfvHx++ffz9x//7w9dff3n//Lvf/eGbD199+d3HT4+vvv7w/pvvHl/dn/n+uz8n/fybD999uFP+
7ft/fv/1x9+///T4+JvHd/9Bnvfnf/L+u2+/+vL37/9f2X74+M2394+ffv/x0/xwZ/z42cdPr99/
9en9l9+9//XjV3+cHP/9pb78JK/f//G+1G+/e/zFD//ycT2f587iP/z49x8/+Prrxxc+++3ji/ff
vv/0z+9//XqSH3785rtPH371h/sx/+Lbv/zf7t88Hn//5af/8fjZh6//6dOH3z3+6nHf4XeP7z4+
fvbH73778Zs/Pf9dVF9/+NWnLz/9Uan95tP7949vP/7mu3+5b+yvH3/8+IfHV19+8/j0/tcfvn1l
fxfEd48vv/n1f/r46U7/u4+//vCbP/rVH7759f047vq7959+9+2fy/C//OSXjx+///a+08d/ef/N
+0/30/zsD7/6+sNXd+Iff/jq/Tffvn98+e3j93737W//raT+zo38/E838vi7j3f2U7p//Xj/4X7f
tf/5/adv79881vevP1/tTzl+9rjr+i++/M7937X5ewn/8r7pPz6+vmvj059Tqqn/oAz+7VF//fjw
zeT727vw7/+4c7yf9F/uuHr86v3jD9++/80fvv7szuH+7OO/f/6L//rTX/7i8YOf/MPjv//giy9+
8JNf/MNf35+9i/p+967AV04ffvf7OwZ//bgf69OX33z3x/vO7wz+/kdf/PC/3il+8Def//jzX/yD
2/+7z3/xkx/9/OePv/vpF48fPH72gy9+8fkPf/njH3zx+Nkvv/jZT3/+o+8/Hj9///7PZaw0/6NS
/tcy/s2d5e8+3kX56/ffffnh62//9Oz/cFfwt/cdfv3rx2+//Of3d0V/9f7DHVOPL+9G8vs//v+q
xa8/fvNP88B3kn8r0b9+fPjN45uP3332+JdPH+7ouePv39Xvncu/1fBnd9h/9f3PHnndH/rym//x
9V0HP7+T/92H39xZ/93XHz9++uzxNx+//c5H//4Hd9q3dV1vf3Xtt+vx+OXP79/8r/73+NFP/vb/
Y7fyvXd3xj//Um3dT/WbTx9/9/jyV2pyvf39HeH/87vH74TS3Tq/vYPkq6//cPcQX9/Pd/cBf7hL
+W4gdwH+7vd/EG7fvf/qt998/PrjP/1Rptc6j8df/dX//nj7fj/vn1fWn39+rvvnvNa//nxKgrcV
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
97a03xZq2zp6c7I9242bcO0XG8x9iQknNq495SUwLOG2Yxob526asS3AtsMTG4BsxwL2nJbYlqDb
QYnNVjZL2/a+t/MQ23mIbTm7bfVtO2LbWYcNVTd33zaot83n7ZjDnaFIwGPbMYcNoLddme2Yw3bM
Yds82o45bMcctsMN29bitkm6HW7YNm72HG7Ya1ZENT9LJxws47fN6I34t+25bedp28DYqHZjug2R
NsDZWGVbKd8ZCgeL3205uA0Be9qf0wDbLsO2z7bt/m/4vu1Vbpv12+7gXnMzosEG352hcLDhvu21
b9vs2zb7to++baFvfrRtkm/b4xs5bLtRe7bCc/ISDbbC7wyFg23wbQN8c6FtR3rbAN/0cmOCbcd7
2/Hedrw3Ud72tbcN6m1req/pHGxGb7vP2+7ztrO87SxvO8vbtsW2gbxtG28bxtuG8bbttu26bntv
2x7Upm/vtq2abaNl2z/Zdk223Yltk2AD7c2oN3/ewHmz5s1EN0TY+HATs01j7gwFgXnrNtPaphN7
Bp9pLhPddk63PdNta3Tb7Nz2dbbNzm3HZdvs3DY77wzVv43ObaNz2+jcNjq3jc5to3Pb4tw2MbdN
zI1lN23fIGaD121bctuRvDNU/3xq86ptf3Ez9ut1XzUv0okBW4Tb7uAm2NvG4LYxuG0JbhuBd4aC
wN7Ptqmy7fVte33bBt/GPdsG37att23rbTt6247etqN3vcpCDMxm3raZt3n3tpm37eNt+3jbPt62
j7ft423yve3ebbt32+7dJuTblt22Zbdt2b3byGbbqdt4bNuK27biNgHe9sa2vbFtb+yaSrH5tW10
bXtc2x7Xnn1htXVnKByA0X5RdE3TlkRg2NnaNrU2cdy2ebatrG0ra9vE2vOHNtNO7WTdGYoOuwDX
RIL9rG0/a8fcjRCxJXXhyW1fauPQbV9q25fa9qU2RtuI7M5QnNiT2jaitu2nbftp22radpl2vCRJ
kteLrAULGtxs6wKhl375znDWJHbvcOi2b7TtG+3ZsaCj277RjimGuU0BFJOi58OSzed6MhRGc/oq
X/8lsVCyc7Pt2Wx7NtuezbZns+3UbPsz2/7Mtj+z7crs2ZW5pvnYldn2Yra9mG0vZttw2LNZ/zZV
Jp7su2xbLBu+b9sie7Y7SO622yHD+9P2PLb9jW1rY9vV2Mh926zYNiu2zYpts2LbrNi2I3bO3oLq
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
47/Gfw3+Gvw1+Gvw1+CvwV+DvwZ/Df4a/DX4a/DX4K/PDPTkr8lfg78Gfw3+Gvw1+Gvw1+CvwV+D
vwZ/Df6a+TXz6zMDPfRr5tfMr5lfM79mfs38mvk182vm18yvmV8zv2Z+zfz6zEAP/Zr5NfNr5tfM
r5lfM79mfs38mvk182vm18yvmV8zvz4z0EO/Zn7N/Jr5NfNr5tfMr5lfM79mfs38mvk182vm18yv
zwz00K+ZXzO/Zn7N/Jr5NfNr5tfMr5lfM79mfs38mvk18+vhvsZ9jfsa9zXua9zXuK9xX5O+Jn1N
+pr0Nelr0tekr0lfP2egJ31N+pr0Nelr0tekr0lfk74mfU36mvQ16WvS16SvSV8/Z6AnfU36mvQ1
6WvS16SvSV+TviZ9Tfqa9DXpa9LXpK9JX88xxCZ9Tfqa9DXpa9LXpK9JX5O+Jn1N+pr0Nelr0tek
r0lfP2egJ31N+pr0Nelr0tekr0lfQ76GfA35GvI15GvI15CvGV8/Z6CHfA35GvI15GvI13yv+V7z
veZ7zfea7zXfa77XeK/xXs9fbh++d9DeQXsH7R20d9DeQXsH7R20d9DeQXsH7R2yd8jeIXuH7N0Z
XpJcklySXJIsSZYkS5IlyZJkuciSYkmxpFhSbCkM9IfqHap3qN6heofqHap3qN6heofqHap3qN6B
egfqHah3oN6BeneGIUlIkpKkJClJSpKSpCQpSbpISpFSlBQlRUlhoD9U71C9Q/UO1TtU71C9Q/UO
1TtU71C9Q/UO1DtQ70C9A/UO1LszPJIcSY4kR5IjyZHkSHIkOZIcF3lK8ZTiKcVTiqcUz6mUpyRP
SZ6S3FV/qN6heofqHap3qN6heofqHah3oN6BegfqHaj37lC9Q/UO1TtU71C9Q/UO1TtU71C9Q/UO
1TtQ70C9A/UO1DtQ785Q1VO9Q/UO1TtU71C9Q/UO1TtU71C9Q/UO1DtQ70C9A/UO1LszVPVU71C9
Q/UO1TtU71C9Q/UO1TtU71C9A/UO1DtQ70C9A/XuDFU91TtU71C9Q/UO1TtU71C9Q/UO1TtU70C9
A/UO1DtQ70C9O0NVT/UO1TtU71C9Q/UO1TtU71C9Q/UO1TtQ70C9A/UO1Dvzr00cqneo3qF6h+od
qneo3qF6h+odqneo3qF6B+odqHeg3oF6B+q9O0DvAL0D9A7QO0DvAL3D8g7LOyzvoLyD8g7KOyjv
oLyD8g7KuzNU9SzvsLzD8g7LOyzvsLzD8g7LOyjvoLyD8g7KOyjvoLyD8u4MVT3LOyzvsLzD8g7L
OyzvsLzD8g7KOyjvoLyD8g7KOyjvoLw7Q1XP8g7LOyzvsLzD8g7LOyzvsLyD8g7KOyjvoLyD8g7K
OyjvzlDVs7zD8g7LOyzvsLzD8g7LOyzvoLyD8g7KOyjvoLyD8s4cFzws77C8w/IOyzss77C8w/IO
yzss76C8g/IOyjso76C8g/IOynt3WN5heYflHZZ3WN5heYflHZZ3WN5BeYfiHYp3KN6heIfiHYp3
Z6jqMd7BeAfjHYx3MN7BeAfjHYp3KN6heIfiHYp3KN6heIfi3Rmqeox3MN7BeAfjHYx3MN7BeIfi
HYp3KN6heIfiHYp3KN6heHeGqh7jHYx3MN7BeAfjHYx3MN6heIfiHYp3KN6heIfiHYp3KN6doarH
eAfjHYx3MN7BeAfjHYx3KN6heIfiHYp3KN6heIfiHYp3Z6jqMd7BeAfjHYx3MN7BeAfjHYp3KN6h
eIfiHYp3KN6heGfPQI/xDsY7GO9gvIPxDsY7GO9gvEPxDsU7FO9QvEPxDsU7FO/M30UfjHcw3sF4
B+MdjHcw3sF4B+Mdinco3qF4h+Idinco3qF4Z/5B7IPxDsY7GO9gvIPxDsY7GO9gvEPxDsU7FO9Q
vEPxDsU7FO/EDPQY72C8g/EOxjsY72C8g/EOxjsU71C8Q/EOxTsU71C8Q/FOzECP8Q7GOxjvYLyD
8Q7GOxjvYLxD8Q7FOxTvULxD8Q7FOxTvxAz0GO9gvIPxDsY7GO9gvIPxDsY7FO9QvEPxDsU7FO9Q
vEPxTsxAj/EOxjsY72C8g/EOxjsY72C8Q/EOxTsU71C8Q/EOxTsU7+QM9BjvYLyD8Q7GOxjvYLyD
8Q7GOxTvULxD8Q7FOxTvULxD8U7OQI/xDsY7GO9gvIPxDsY7GO9gvEPxDsU7FO9QvEPxDsU7FO/k
DPQY72C8g/EOxjsY72C8g/EOxjsU71C8Q/EOxTsU71C8Q/FOzkCP8Q7GOxjvYLyD8Q7GOxjvYLxD
8Q7FOxTvULxD8Q7FOxTv5Az0GO9gvIPxDsY7GO9gvIPxDsY7FO9QvEPxDsU7FO9QvEPxzvxrEwfj
HYx3MN7BeAfjHYx3MN7BeIfiHYp3KN6heIfiHYp3KN6pGegx3sF4B+MdjHcw3sF4B+MdjHco3qF4
h+Idinco3qF4h+Kd+cLQg/EOxjsY72C8g/EOxjsY72C8Q/EOxTsU71C8Q/EOxTsU79QM9BjvYLyD
8Q7GOxjvYLyD8Q7GOxTvULxD8Q7FOxTvULxD8U7NQI/xDsY7GO9gvIPxDsY7GO9gvEPxDsU7FO9Q
vEPxDsU7FO/UDPQY72C8g/EOxjsY72C8g/EOxjsU71C8Q/EOxTsU71C8Q/HO/JXdwXgH4/0/Hdux
CcNAAATB/KsQKHLoSIO6UWAnFhLuP7H3k2thYeDEeGI8MZ4YT4wnxpPiSfGkeFI8KZ4UT4pn3pjF
eGI8MZ4YT4wnxhPjifGkeFI8KZ4UT4onxZPi2WboYzwxnhhPjCfGE+OJ8cR4UjwpnhRPiifFk+JJ
8Wwz9DGeGE+MJ8YT4/3n+RhjXd7n8XnZl+v+HuMHUEsDBBQAAAAIABakUEQFs8bkGQMAAIsGAAA0
AAAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmFkZS9ldWNrcnByb2Jlci5weZVU
TW/bOhC8+1cs6osDOGrchwe0L+hBVuzUiL8g2ShyMmhpZROlSIOkEii/vkN/pW0c4FUnabk7nJld
bbt9+aH+4H40pfEoGUyzAfXHs+SB3sltt9q02DLNrNxILRQlpmCSjirzIpUSkbEbyhGLWqfUkZZe
IvOOn1iZHVsyJfkLGMifsne52DFCVVVrmQsvjXb4tDtj9x8Aprmxh3huWXguaN3sEd9eJWzA2jW4
auupk1xR78uXz4C4mB5RrBSlIddRyo7tExcHJYnR3sp17Y3tuKv/ECGaCPuD5lJtrKzomsDQkzc0
b/zW6KN+WKPk2grbBJdKy0zOlP4ZxG6pMTXlQpPlQroDPIzwJHTx0VjUV6aQZRNCtS4gJ7D2bCt3
8vB+uqQxOzCle9ZsoWZer5XMUTyWOWvHJBztQsxtX50aBiLZkQgNDeD37t4SS5yHu5/YOkToU9Q7
3XZE7JKx1BE+8Ec3d6HwCqQbUuiGPVVGFy14VVqQ1HvYLbzHCwAh9BljRGum2nFZqy4QkEvfR4tv
s+WC4ukjfY/TNJ4uHm+RC6dxiv4dkGS1UxLAUGWF9g2IA2AySJNvqIj7o/Fo8RjYD0eL6SDLaDhL
KaZ5nC5GyXIcpzRfpvNZNoiIMuaTxcHMSyafLS4BWRk4WbAXUrmD9Ee014GgKmgrnhhtzlliokjg
F9k1f9VDZfRmrxclr4bekixJG9+lZysxO5i+N90Fymt/uxj6POrSvz0kCf1DoQUZyoeyBPRQGWO7
1DfOh9RJjNqbT73ezXXvn5se0TJD5L2HBtO7/7lE2q1WaU1FUbXOt8I69jtr1tCP/oWfaFIrL/uN
5wSnGfv5/vRYg+0i9cZ5jFol8q3UfCpL9idZOJkcTk4lgDnPXZjpY8FgmTykd78cxFhHjcMqOtNz
rvotO5tMsK1Uq9XKlXDuEDzw61ymjWWBXYHJKGm1klg5q1XHsSqP8fBcLox+Tz9nh69oVR3VTujr
BeGdX8m+KX0j+QXef33fjs4fCBar0SN4FrZhvzp2cqVFxX8KtOxrq+kDbrh+SD+0fgJQSwMEFAAA
AAgAFqRQRCVPoxTfQAAAOIgAADIAAABwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFy
YWRlL2V1Y3R3ZnJlcS5weZWdb68lxZHm399PUZK1Wltq48o/VRllr0fCGM+gtTECrJH3jdXAxbSm
6WZuN0bsp9/4/aJ6vNJ4pF1eHPqecyorKzMy4oknnszzk5/84/+233z4zx99vP3+ow8+/PizD7ff
/P6PH/zP7b/47k8efrJ9/s3j9senF3998er5y+2D1189bi/ebH94/b9fvHz5PP/+9tvvX7348vnb
10/bly9fPL56u32Z33nv4d2lH7168fZFXvnbx789vnz93ePT9vrr7e0/aDO///Hj2zdfPv/u8f9q
9sXrV2/yz6fvXj/5Rza8ffL6qd7/8unx+dvHr7YvfrTF/3yr50+09d2Peatv3m4//eBnW7uuyCb+
4dff295/+XL7lO++2T59fPP49LfHr+pJPnj96u3Tiy++z8f86Zuf/TLf2bY/PH/6t+2TFy//+vTi
2+3nW/bw7fb29fbJj2+/ef3qfv4cqpcvvnh6/vQjo/b10+Pj9ub1129/yI79avvx9ffbl89fbU+P
X714U83nQLzdnr/66hevn/L6b19/9eLrH3nr+1df5ePQ67ePT9++eTeG//zxn7bfP77Jnm7//Pjq
8Smf5pPvv3j54su8+Pcvvnx89eZxe/5m+4733nzz95H6HR357O7I9rvX2byj+6vt8UV+zr3/9vj0
Jt/Z+nvt3d3uFp9tOdc/ff6W/udsfseFP8tO/7i9zNl4enfle/9wCP7+pF9tL17Z7Dc59vmPbDAf
9Ic0q+2Lx+37N49ff//yWbaQ393+9aPP/+WPf/p8e//jP2//+v6nn77/8ed//lV+N0c6P835q5Ze
fPtdmuBXWz7V0/NXb3/MjmcDf/jw0w/+Ja94/zcf/f6jz/9M73/30ecff/jZZ9vv/vjp9v72yfuf
fv7RB3/6/fufbp/86dNP/vjZh+9t22ePj++GmMH8R4P8H0P8dTb57escya8e3z5/8fJNPfqfc3rf
ZAdffrV98/xvjznNXz6+SIvanucS+e7H/685fPn61V993rzk7wP6q+3F19ur12+fbT88vUjbSev7
T7Obrfx9fp+l0X/53rPtaPml56/+7WVOwWd5+e9efJ1N/+7l69dPz7bfvH7zlq/+4f28du+t7T9v
Y2/b9qfP8p3/6r/tw49/+//oVH7ykA1/+KcPPv9XVsS/f//46ss0y+dfvHyslZYGhHl8/fT62+2L
F389th9eP/0blvDj9vnzFz88f/Xf0wHlInn+lN3/JL/1mmfLK79/9eWLl/nF//HN27ff/fInP/zw
w3uPX33/3tsffhntF9/mFU+/+Cfu3Xps289//k/b/t7s/Wz5Vj/Od28dKw7eOlp/99aa9Vbb+7zf
imvE5MJ9xv3WtY4YTv1HXz0+3377ztTp3KeM//brd2394qft5/c/f7b9ur+nU/o0e5iP/J+ve5UX
Zm9+8dNj7u3n+a+f/Xp/r+1HrbAfv0tH+fIf3e75FyyPfvw3bI0+vdxev8r1++Ytq+zb77/8Zvsm
vZ2eJf3Qp7/99OHBefnL53/+5KMP3v/9X3770Weff/rRb/70+Ud//Pgvn76f/6tnOBjGD755/oTN
pb39+x+fdFBM4vbsXSPv/+b3H/7ls4/+14d5UeTY3a1z3eev/37Vr7efPqQ/bc9a7Puzduzns+z0
8azN0Z6lx45n+emVL9H51/lsjbbnB2vl9/b+bJwtv5wz+KzHnl9ufJozs2Z/GGscedEYz0af2VrO
dv658g7bnM/SuEf+q+WVV96rt5jPWuPT87iejTi5dT+fjbnnl885qt0jHhrdyi/kt0a2Mfcz7znz
xj3bfLaN7NZ2XPledu5Zu05uswX9nfmvI57NfvkgfMpj0u6aOQ751Xy785IXjbaetbNx0coH6T3b
bdm3vGH2d+b32oydL89n48jhGzud7n0yGFe1e+0P2Q2eefNx81uxcqTnYjD69Yxb54PnUPU4Oj3K
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
8vTw/farrUb4bnv3uH3507vvHt+8n38t1euHb55ePP3Eqn37dH+/vX389t3famC/2X56/HF7+eLN
9nT/6uHtenwtxLvtxZtXv358qs9///jq4duf+NGPb17VdBj1u/un79/+vIa///yP22f3b2uk2+/v
39w/1Wy+/PGb1w8v68OfPby8f/P2fnvxdvuBn7397u8r9TsG8tX7gWy/e6zHu7q/2e4f6nW++6/3
T2/rJ1v/sP38be+feLfVXv/ixTvGX7v5Ax/8ZQ36p+117cbTz5/88B8uwd9n+mp7eONjv6u1r7/U
A2uifyuz2r653358e//tj6/v6gn13u3fnn39L1/88evto8//tP3bR8+ff/T513/6Tb23Vrperf1b
T3r4/ocywVdbzerpxZt3P9XA6wF/+PT5J/9Sn/jo42efPfv6T4z+d8++/vzTr77afvfF8+2j7cuP
nn/97JM/fvbR8+3LPz7/8ouvPv1w2766v/95iVnMf7TI/2eJv61Hfv9YK/nq/t2Lh9dv19T/VNv7
tgb4+tX23Yu/3tc2v7x/KIvaXpSL/PDT/9cevn588xfnWx/5+4L+Znv4dnvz+O5u+9vTQ9lOWd9/
2d16yt/3966M/uWHd1u2etOLN//+urbgq/r47x6+rUf/7vXj49Pd9vHj23e89Q8f1Wf33tr+qzb2
tm1//Kp+8t/9t336+W//H4PKB7d68O8/7qP1Wra37/CL//ixQsfrn9j3V9vL7148vXiJLb178c3r
++WB9TMmWJP7jy+eXv382nZXn378fvvuP+cxBw/Oeur2q1/9z23/8Lj4m3+pF9re4/0LV3//Qhv1
Qt/j/PmF8/0L+6wX6pHrhfbhvv/8Qnc4z17dEzp+tmY85TlLvP2zX9dG/voX7Vfv//rL+ulYg3he
zl3D/a8ffFPvYei/3n4xjswKKPWvX/q4lsfypZ9+qJD4D7/1xTc4Qs//gVWtsT2+KU99+w5/+v7H
l99t31VcM4aUoz3/7fPbbe3An7/+05fPPvnosz//9tlXXz9/9vEfv372xed/fv5R/c8vv/7+xo8+
/uzTP3/17H99ynSOuf/8Clvz9ePfN+aft1/c2jza3XbEddcixl0fM+7G1euPcz/qn2Pnn+2uHXv9
LGa9ZV71z2z+kWWjR78brX7W+553t3pCPbDXE3rmebfFUY8+6t3bVR8ebfb6Wex3sc/9rl31kX7N
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
h1ruizzd9LiytevJDlHNrkFvuuxCMnr3igF891VjDmoy+QLVA7Shh1H/ri0nNxPv7PQq67QJf3ji
GDkqh08Mq2LY9Ew0k3WwVQ6GFcOuxLvdE/R82mFe967xTHYQvqPe38+mkGav76G+fho+f0k8MH+f
Pw1PXoYh9fkTlPtS3j1J7avd5x9fqZO9O9HLtcx3m4FvF+D5PgG2a+TnT1+ho36HgGHXvCOfSa3Z
54dXxCM5Iqf6xhf3+V2vt6dBZc/r8yczT/HZe9oXeKPqUaiID/ef0K7X7A+i2a+5Rav1vZS+S2v7
OvKA/31r3SpwchDkywvsp2l37D/WRB9A3/k6PEYZvEauSpFEd7Kc5KuAmGQu1QMGiFOPU9pBj89v
7YehDU6nROsGpvc0Rt2e2DxTUz8d9mj8pbt03Kk1Pwe73ORt7zRRZmlS7dwHYyanqjyQSRxNlYOa
xTRsPWs1vT+Ch1+zZFhhGoL/eKWeGDq+3Fcf9ozv9pL9+ys1/B66u4PD0FEmvpztKKtCZeXbt3bE
GowtCWXwRUmrSX4rmuztG+Jw2W2vZnr9vfEy3DfT2dnaD1XTHPwPtTtA/T26bgj+XVT9DRS/ruVb
Dr684JnAgKGp+6IpmN04zx2oTG9mdGN1hD2WvmPvYslYb0b7PYNGxb+Du17rsuq4/QS5z//Xgcyw
6Tsm+caKviMr+hTduk7pz0737L6Z+gZ1d3KEgLGd5HBj+CNTulN95P+tgj/K9/fG8313bgzIaXlH
RU/74w4MlBLxr1CLvac8cnfzXu075Lf9tM2X/wVQSwMEFAAAAAgAFqRQRJevmg6+VgAA07gAADAA
AABwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFyYWRlL2ppc2ZyZXEucHmVvV2vJbeV
pnl/fkUAwgA2Kq3e/FqL7EI3IKvkatX4C5KMhvumkJaOyolKZaoyU67W/Prh8zA0HqDcQLcuQnn2
3mQwyJeLa73rJeOjj/72f9cvP/vHz397/frzTz/77ZefXb/89e8+/b+v/8VvP3r66Prqz8/X7969
+pdXb16+vj59+83z9er99Zu3/8+r169f7r+/++6HN6++fvnh7bvr69evnt98uL7ev/n46aein795
9eHVLvkPz395fv32++d319tvrw9/o879+98+f3j/9cvvn/9/1b56++b9/vPd92/f+ceu+Pr923fn
86/fPb/88PzN9acfrfE/3urlO+r6/sd9qz9/uH726c+vstbcVfzNn398ffL69fUFv31/ffH8/vnd
X56/OU/y6ds3H969+tMP+zF/9v7n/3l/cl2/efnuX6/fv3r9L+9efXf94tot/HB9eHv9/scPf377
5n7+3VWvX/3p3ct3P9Jr3757fr7ev/32w7/vhv399ePbH66vX7653j1/8+r9qX53xIfr5Ztv/tPb
d7v8d2+/efXtj3z0w5tv9uPQ6g/P7757/1Mf/uNv/3D9+vn9bun1j89vnt/tp/n9D396/errXfjX
r75+fvP++Xr5/vqez97/+a899Ssa8uXdkOtXb3f19u7fX8+v9vfc+y/P797vT676cfnpbneNL649
1j97+YH279H8noI/343+8Xq9R+PdTyU//ptd8Ncn/eZ69cZq/7z7fv9jV7gf9N83rK4/PV8/vH/+
9ofXL3YN+7fXf//8q//2uz98dX3y2z9e//2TL7745Ldf/fHv9293T+9v9/idml599/2G4DfXfqp3
L998+HE3fFfwm8+++PS/7RKf/PLzX3/+1R9p/a8+/+q3n3355fWr331xfXL9/pMvvvr80z/8+pMv
rt//4Yvf/+7Lzz6+ri+fn3/qYjrzb3Xy/9fF3+4qv3u7e/Kb5w8vX71+fx79j3t43+8Gvv7m+vPL
vzzvYf76+dVG1PVyT5Hvf/w/GsPXb9/8i8+7i/y1Q//+evXt9ebthxfXv797tbGz0fcfRnfX8tfx
fbFB//XHL65R9o9evvnX13sIvtzFf/Xq2131r16/ffvuxfXLt+8/8NPffLLLPmopj1+U9ijX9Ycv
9yf/q/+uz377D/+bRuWjp13xly8ZrP1U3757+9318k8MZH38ZuP7f364vgNIe26+3xj5+vUP2z68
3s+3LcAPu5P39Ngd+N33PwC2D89f//nN29dv/+VH+/yfXn7/8s0zQ/Lu+d9+eH7z9cb7yz+93ph9
+f3Bxu6jP73dD/vlL/7p8y+t67M/fPqLf/r9MVc/ajLe76l88Pn23Z53H9PeUud1/eIX//V6fJz5
WH1/VEf89NEcWR77o1HqTx+tGm1Q8FH7Tx/l7kgKPvr86aPVW7Hpn3/zjDH6aX4w975g0K7/8lNl
13+6flZ+cf/x8/15qR8PrNkX+zF2J/7Hsm/2j2jSLlhXjL+L+nez/d2MX+wPf27FZZ27f/Xj99vc
/q37v9jP+X8B1s//4Yunp91p//zVH3//+aef/Pqf/+HzL7/64vNf/uGrz3/323/+4pP9v11l+/hB
d33655fv6OuNxX/73TuNF+NwvTg1fPLLX3/2z19+/j8+2yV6i2nFlPnq7V9L/JfrZ0/X1R8vtrEt
XOLFVWbdl8Fl7i/qGi9qqbn/NceLq83yovFZb4/+oj1ivujxiBetxHjRRtklsNwlnvYf5cWurL6o
uUvuX+WLUlZ7UWuNF+ORDz6b+zZZXtS14kWpfd9m35bPFj/ZbZpjfxFRTr2tPpUale92A6Os/dPd
traHmLvX3bb22Hdd60XJB81v+3e1zl356lwmD9K57JY8+l1vn0/7j/qiPPad9mUX2p9xWVw6l/30
vTUuu6LH7rRicVp+5UyeYT9hHfbNOPVGf6rlYR/tFsW+cYld725+49K5DC72SHKZL/Zo+a+1i+0O
HY89Dm3xmGs/iPXOx9P+2KEInp6HXI/dtbunS6dDi3XssaxjF6+z7i/aYz9zoeXZdnP6fqQaa9fS
8m7viqfiJ3U/y36M4JK0Yz9p36DYP93jAUbqnmo0dYKCxe94rslzTZ5r8lwzrLeUSnttkb9idBeP
tu+1LwzoouSi5KLkokcWJRYl9oBucD24FC711Fvn0/6j8UnnMrgEl+QyuVCSbiyFkhsj3XpLoVih
WKFYoVjJU2/vu95C8ULxSvFK8Q3nfaFkpWSlJHAGhftCiUqJRolGiUYJcEO9scetNEo2SjZKNko2
SjZKdkp2SnZKdu7VKdEp0SnRKQGMCvCk3oxd76DkoOQeqD1kFB8UHxQfFB8UHxQfFB/cMCgWFGNi
laBE9FPv2uPGzN4XSgYlg5JByaRkUjIpCaYLmC4pCvcYDeZbMKPn7sPdjwdn9TGfdheBwd3KMndj
Cjjb1VoR92I2lORe2AJs0b5wr429Qt8U8LjHYs8p7m+9tT9t4A9mtlDHDGxg7e7dgF27gdfaQ1b7
gykcTFen8O6CPQxM4UbLF5/tgd9DfvCwC+x6g3oxL31DbP9q7Tmw79BFaAH5BeQXkL9/zYVn2Ijf
61jhd2vbyV3lfpjTv/tz7M5iHjmFFlasYfCsjd8HxnX3YMN27WHbxamtYYtG2ZOogdE9dgMLdOxD
zfq0f68B2bUldQT2IXez9me0kplX7O5lRX33F2b22nBudMY2BxWTgwWsx67XOZ8a9mGbw20VmJDX
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
/3j77bev+7///Ocf3r39+vXH9x8eX3/79s27j4+v+zOfvXxq+sW7tx/fdst/fPPvb759/92bD4/3
f3x8/Bt99ud//ebj91+//u7N/6vbt+/ffd//+eG79x/8j+748dv3H/bvv/7w5vXHN988/vBXe/yf
H/X6A31999d+1J8+Pn788797HNdV3cXf/Phnj8+//fbxJZ/9/vHlm+/ffPj3N9/sN/n5+3cfP7z9
ww/9mj/+/u/+U//m8fjn1x/+2+O3b7/9tw9v//z4yaNH+PHx8f3jt3/9+Kf37+7376n69u0fPrz+
8Fdm7Y8f3rx5fP/+jx//0gP7+8df3//w+Pr1u8eHN9+8/X533xPx8fH63Tc/ff+h2//5/Tdv//hX
fvXDu2/6dRj1xzcf/vz9pzn8p1///vGrN9/3SB//9Obdmw/9Nr/94Q/fvv26G//q7ddv3n3/5vH6
+8d3/O77P/3HTP2SgfzuHsjjl++7e2f37x9v3vbfefa/v/nwff/mcX52fHra3eOrR6/1j19/ZPy9
mt/R8O960H99fNur8eFTy8/+5hT8x5t+83j7zm7/1HPfP3SH/aJ/abF6/OHN44fv3/zxh29fdQ/9
2cd//eKr//Kb33/1+PzX//L4r59/+eXnv/7qX/6+P9sz3X/t9ds9vf3zdy2C3zz6rT68fvfxrz3w
7uCff/Hlz/9Lt/j8Z1/86ouv/oXR//KLr379i9/97vHL33z5+Pzx28+//OqLn//+V59/+fjt77/8
7W9+94vPHo/fvXnzaYqZzL81yf/PFP+xu/zz+57Jb958fP322+/3q/9LL+/3PcBvv3n86fW/v+ll
/vrN25aox+veIt/99f/XGn77/t2/+b7d5D8m9O8fb//4ePf+46vHXz68bdlp6fufVrd7+Y/1fdVC
//Vnrx7r6A+9fvffvu0l+F03/+XbP3bXv/z2/fsPrx4/e//9Rz76z5932+d5HM+fHON5PB6//13/
5n/1v8cvfv2P/x+Vyo9euuOfvf23xYb47z+8efd1S+XrP3zLWFtAv3r99i+v3/3vrWR6I7z+0EP8
7Yf3f37P+Hsf/vDu67ff9gf/jz99/Pjdf/rpT//yl7989uabHz77+Jf/VMdP/9xNPvz0Pzv/x1mP
x09+8p8fz8/mecbRvzpXfPrVylr8ah3np1/l3L86nue8f1XXqEnD56z7V1euGj7gi2/eoD4+STTj
+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
cRJfENtwtpZOa+m0lk5r6YgU8LBwl5opcfObpTbRaRMd5bu9T5+3ZqqNdNpIp4102kinjXTaSKeN
dNpIpyV0WkKnJXRaQqcldNo/x/v5s06M/9IeOu2h0x467aHTHjrtodMeOmwK31OztIROS+i0hE5L
6LR/TvvneD9v34nxb9zGqT102kOnPXTaQ6c9dNpDpz102j+n/XPaP6f9c9o/p/1z2j/H+3n7Tox/
4zZJ7aFPG720jE7L6LSMTsvotIxOy+i0hE5L6LSETkvotIROS+h4vw+vE+PfuJ2OWkanZXRaQacV
dFpBpxV0zAGbm1bPaeucts5hE9qetsZ8q+/9PQ5/5yVpD5320GkPnfbQYQuwnuGmZXRaRqdldFpC
pyV0WkKnJXRaQqcldPx+4/a8pGV0WkanZXRaRqdldMwTxY3hCJ2QWkKnJXRaQqcldFpCpyV0zu97
fHtespsFPPxov7j44uffXvQbxNlYqI9vC+q0m0676bSbTjvptJNOO+mcfX3rTPg3boPVbjrtpnP4
uEdvWwvqtJtOu+m0m0676bSbTrvpsFliT1bTYjrf56s7Cf6N23S1oE676bSbTrvp04Y3LajTgjot
qNOCOi2o04I6LajTYjotpnP2vLrz39+4naxaUKcFddgDmrAdHhEegkasLXXaUqctddpSpy11Dre3
k9T3+epOfX/jNmLtlNLyJn0vEaZq5h0y3fxknwLuA2vweQY7o7SqTqvqfJ+v7lz3N26/mj48xY1Y
q+q0qk6r6rSqTqvqtKpOq+q0qk6r6rAVMr9E7avz9dWd5v7GbcTaV6d9ddpXp3112lenfXUOT2Nv
YPvqtK9O++q0r0776rSvztdXd4b7l/bVaV+d9tVpX5321WlfnfbVaV+d9tVpX5321WlfnfbVaV99
wrF2k+rOcH/jNk4trdPSOi2t09L6hFvUTLW5TpvrtLlOm+u0uU6b67S5TpvrXLuerJPb37hNUhvs
tLlOm+u0uU6b67S5TpvrtLlOm+u0uU6b67S5TpvrtLnOt+ldJ7e/cRuiNthpc50212lznTbXaXOd
Ntdpc50212lznTbXaWmdltZpaZ3re33r517T8jotrdPSOi2t09I67avTvjrtq9O+Ou2r07467avT
vjrtq9O+Ol9f3Vnsn1+eyZeLXr35aWmdltZpaZ2W1mlpnZbWaWmdltZpaZ2W1mlpnWs/f9YJ7F9a
XqeldVpan76zz70XpxdXL+5ekHP+7u3F31HbXKfNddpc59t0qdPW37hdbx+uPlx0jCappXVaWqel
dVpap3112lenfXXaV6d9ddpX5+urO0/9jdv8tK9O++rw+epwAxuiltZpaZ2W1mlpnZbWaV+d9tVp
X5321fn66s5O/07ri7S0TkvrtLROS+u0tE5L67S0TkvrtLROS+u0tE5L67S0TvvqfH11J6a/29sk
taVOW+q0pU5b6rSlTlvqtKVOW+q0pU5b6rSlTlvq8FUgnDH3xIZxe17SV4S0qk6r6tw7DfXqDxcd
o5mirw7PVoN1M1DnovbVaV+dr6/udPQ3bjPVvjrtq094ihusltZpae09atPV5jptrhUetEas9XVa
X+dZF+lM9C+tsdMaO62x0/o6ra9PO6K0w0477LTDTjvstL7Ow782Xa2v0/o63/eBdCb6G7fBao2d
1thpfZ3W12l9ndbXaX2d1tdpfZ3W12l9ndbXaX2d1tf5vg+k88/fuJ2YWmOnzXXaXHfXjv5fr95g
tb5O6+u0vj7hBjZd7bDTDjvtsPN851H93GvaZadddtplp1122mGHV/x22GmHnXbYaYeddthphx32
kQoPQVP1fUl+55+/cZuuFtppoZ122WmHnXbYaYeddthph5122GmHnXbYaYeddthph53ne33r517T
LjvtstMuO+2y0w477bBPy7y0yE6L7LTITovstMhOi+y0w07r63zfB9Ip52/cxolv5w/PYOPU+jqt
r9P6Oq2v0/o6ra/T+jptrtPmOm2uw6z4fR9I55h/aYOdNthpc50212lznTbXaXOdNtdpc52W1mlp
nZbWaWmdltZpaZ13PbZzzN+4DVFL67S0TkvrtLROS+u0tE5L67S0TkvrtLROS+u0tE5L67S0zvc9
DZ1Z/sZtflpap6V1WlqnpXVaWqeldVpap6V12lenfXXaV6d9ddpXp311vr66M8vfuI1O++q0r077
6rSvTvvqtK9O++q0r0776rSvTvvqtK9O++oTHpvvvLqfe03L67S0TkvrtLROS+u0tE5L67S0Tkvr
tLROS+u0tE5L67SQTWvNfD1iJ5C/cZuaNlSh0qBS4G0772P7HvQcDtiXNt508s6Is/+e0rspCGe2
3+erO238C6dmnK5wIsLrGy9jvDbxysHUz9zJPMmUx6zE7zu/1uHVbJ2s08bfuM0P0e1jdNpcpz+Q
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
JZoX6f279YR5PrK2qwKfTcmQ6tA6OjKcjUa0+cJGo+GFTOtMmBXi1NdHi4f2Dk1ZAMslp/W1XDoa
wyCX21Pv6B6b76ztP3cZ5bSM4LKGIecw2YprhZvv1KTL07w5NcH3fB04l2gs+ylaz4aEO0IywcvY
OLD9STbVOGs0y3wkl4JFWA6p0MRKwCsq4s2nyau9Y4Dop8YtYFfxoQsb0v66hBCFk2p2CrtXuF2T
dFfX6LRbqemBpz30Ht6/+3yegtoNy2jJ0y6wKzBp0WuTKr7yh1RHgy3ovtPOyO2OoLx98ymf0nC4
gnhZprfKySGbR960i44ALveX2cW+UlIdJ77zKYyWPq7iddUobU+iXW3oEVRuuutSJt1KM5q1zpXz
B7yGfKFs6NFBmxzQA5Qy95rUNLgOfznYP+J11Tjnr6DzgIyxNCOs2K/oa+bbkRTDH3I6MHqEVbpO
x00fgoH5/cgkU6Ya2bYim+Xy7KSNipVCkTXMznqVMYrJbaT2iRnIQIdMG3ufv3YeKFI6iu2HHzmU
7/TuJh6AtYrk65v+g233q3AY6pqm/Szd7MbRZ2bnnNPEdR5+N+Eq4MumvXx2WZQ36a5N7V2b0kVH
ER/2xtTy3U3OdkuzNGvXaNAzNEbn5W3jnCBsLc0ShYzXmyV99jDHfpz65eoOFogUAfdReDb23weh
Z7d303lvMV/Ob6d9+jO8bjb/z3Urvw3lgkuPyz6d0tNCGvNsesHh/SpVXipn55p/2xz61o7GSYA8
9Yg9O0UarT1qs/EfUEsDBBQAAAAIABakUEQq5C6Rr1MAAJqzAAAyAAAAcGlwL192ZW5kb3IvcmVx
dWVzdHMvcGFja2FnZXMvY2hhcmRldC9ldWNrcmZyZXEucHmU3W2vbEl1IOjv91ekxBdbKtNnR6yX
yLF6JIxxd6kxoALU8mgkqygu5qqLusytwm7m189+VoI9kt3SDJLTdU5mxN47YsXbE3Hyfu97//H/
Hn/zo//y+U8eP/78hz/6yc9/9PibH//0h//t8b/47Pfefe/xi9++f/z004d/+vDNl18/fvjx1+8f
H759/P3H//vD119/ef/8u9/94ZsPX3353cdPj6++/vD+m+8eX92f+f67Pyf9/JsP3324U/7t+39+
//XH37//9Pj4m8d3/0Ge9+d/8v67b7/68vfv/1/Zfvj4zbf3j59+//HT/HBn/PjZx0+v33/16f2X
373/9eNXf5wc//2lvvwkr9//8b7Ub797/MUP//JxPZ/nzuI//Pj3Hz/4+uvHFz777eOL99++//TP
73/9epIffvzmu08ffvWH+zH/4tu//N/u3zwef//lp//x+NmHr//p04ffPf7qcd/hd4/vPj5+9sfv
fvvxmz89/11UX3/41acvP/1Rqf3m0/v3j28//ua7f7lv7K8ff/z4h8dXX37z+PT+1x++fWV/F8R3
jy+/+fV/+vjpTv+7j7/+8Js/+tUfvvn1/Tju+rv3n3737Z/L8L/85JePH7//9r7Tx395/837T/fT
/OwPv/r6w1d34h9/+Or9N9++f3z57eP3fvftb/+tpP7Ojfz8Tzfy+LuPd/ZTun/9eP/hft+1//n9
p2/v3zzW968/X+1POX72uOv6L778zv3ftfl7Cf/yvuk/Pr6+a+PTn1Oqqf+gDP7tUX/9+PDN5Pvb
u/Dv/7hzvJ/0X+64evzq/eMP377/zR++/uzO4f7s479//ov/+tNf/uLxg5/8w+O//+CLL37wk1/8
w1/fn72L+n73rsBXTh9+9/s7Bn/9uB/r05fffPfH+87vDP7+R1/88L/eKX7wN5//+PNf/IPb/7vP
f/GTH/3854+/++kXjx88fvaDL37x+Q9/+eMffPH42S+/+NlPf/6j7z8eP3///s9lrDT/o1L+1zL+
zZ3l7z7eRfnr9999+eHrb//07P9wV/C39x1+/evHb7/85/d3RX/1/sMdU48v70by+z/+/6rFrz9+
80/zwHeSfyvRv358+M3jm4/fffb4l08f7ui54+/f1e+dy7/V8Gd32H/1/c8eed0f+vKb//H1XQc/
v5P/3Yff3Fn/3dcfP3767PE3H7/9zkf//gd32rd1XW9/de236/H45c/v3/yv/vf40U/+9v9jt/K9
d3fGP/9Sbd1P9ZtPH3/3+PJXanK9/f0d4f/zu8fvhNLdOr+9g+Srr/9w9xBf38939wF/uEv5biB3
Af7u938Qbt+9/+q333z8+uM//VGm1zqPx1/91f/+ePt+P++fV9aff36u++e81r/+fEqCtxV//sXz
GSHNW5x/+9XzOW3581+///Lxt38OXi3jCwX6+M+vnHI//tPjL66/+tMPf3n/vvf3l+y+uG/3fsB/
n/ab+0Pu5064dr791f3ffzn5rX7+ufX88fd3L/j1f3Thx7t3P/rlD//bF//4i3/42ec//MGP//Fv
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
jjlsxxy2ww3b1uK2Sbodbtg2bvYcbthrVkQ1P0snHCzjt83ojfi37blt52nbwNiodmO6DZE2wNlY
ZVsp3xkKB4vfbTm4DQF72p/TANsuw7bPtu3+b/i+7VVum/Xb7uBeczOiwQbfnaFwsOG+7bVv2+zb
Nvu2j75toW9+tG2Sb9vjGzlsu1F7tsJz8hINtsLvDIWDbfBtA3xzoW1HetsA3/RyY4Jtx3vb8d52
vDdR3va1tw3qbWt6r+kcbEZvu8/b7vO2s7ztLG87y9u2xbaBvG0bbxvG24bxtu227bpue2/bHtSm
b++2rZpto2XbP9l2TbbdiW2TYAPtzag3f97AebPmzUQ3RNj4cBOzTWPuDAWBees209qmE3sGn2ku
E912Trc9021rdNvs3PZ1ts3Obcdl2+zcNjvvDNW/jc5to3Pb6Nw2OreNzm2jc9vi3DYxt03MjWU3
bd8gZoPXbVty25G8M1T/fGrzqm1/cTP263VfNS/SiQFbhNvu4CbY28bgtjG4bQluG4F3hoLA3s+2
qbLt9W17fdsG38Y92wbftq23bettO3rbjt62o3e9ykIMzGbetpm3efe2mbft4237eNs+3raPt+3j
bfK97d5tu3fb7t0m5NuW3bZlt23ZvdvIZtup23hs24rbtuI2Ad72xra9sW1v7JpKsfm1bXRte1zb
HteefWG1dWcoHIDRflF0TdOWRGDY2do2tTZx3LZ5tq2sbStr28Ta84c2007tZN0Zig67ANdEgv2s
bT9rx9yNELEldeHJbV9q49BtX2rbl9r2pTZG24jszlCc2JPaNqK27adt+2nbatp2mXa8JEmS14us
BQsa3GzrAqGXfvnOcNYkdu9w6LZvtO0b7dmxoKPbvtGOKYa5TQEUk6Lnw5LN53oyFEZz+ipf/yWx
ULJzs+3ZbHs2257Ntmez7dRs+zPb/sy2P7PtyuzZlbmm+diV2fZitr2YbS9m23DYs1n/NlUmnuy7
bFssG75v2yJ7tjtI7rbbIcP70/Y8tv2NbWtj29XYyH3brNg2K7bNim2zYtus2LYjds7egupBUttu
xLtNobediJ2z32RVppVv2xHbJsSenS1SvGdnCxdvexDbHsS2B7HtQWzbD3eGa96WWHwh+A2lN03e
zHjD3w1sN5vd4HXzws0CN/LbmG7PQaWdc8dzSwKKX2wEsenDpgPbgnVbnG5L0m2ls2caPrPtmcGa
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
v2Z+zfya+TXza+bXzK+ZXzO/PjPQQ79mfs38mvk182vm18yvmV8zv2Z+zfya+TXza+bXzK/PDPTQ
r5lfM79mfs38mvk182vm18yvmV8zv2Z+zfya+TXz6+G+xn2N+xr3Ne5r3Ne4r3Ffk74mfU36mvQ1
6WvS16SvSV8/Z6AnfU36mvQ16WvS16SvSV+TviZ9Tfqa9DXpa9LXpK9JXz9noCd9Tfqa9DXpa9LX
pK9JX5O+Jn1N+pr0Nelr0tekr0lfzzHEJn1N+pr0Nelr0tekr0lfk74mfU36mvQ16WvS16SvSV8/
Z6AnfU36mvQ16WvS16SvSV9DvoZ8Dfka8jXka8jXkK8ZXz9noId8Dfka8jXka8jXfK/5XvO95nvN
95rvNd9rvtd4r/Fez19uH7530N5BewftHbR30N5BewftHbR30N5BewftHbJ3yN4he4fs3RleklyS
XJJckixJliRLkiXJkmS5yJJiSbGkWFJsKQz0h+odqneo3qF6h+odqneo3qF6h+odqneo3oF6B+od
qHeg3oF6d4YhSUiSkqQkKUlKkpKkJClJukhKkVKUFCVFSWGgP1TvUL1D9Q7VO1TvUL1D9Q7VO1Tv
UL1D9Q7UO1DvQL0D9Q7UuzM8khxJjiRHkiPJkeRIciQ5khwXeUrxlOIpxVOKpxTPqZSnJE9JnpLc
VX+o3qF6h+odqneo3qF6h+odqHeg3oF6B+odqPfuUL1D9Q7VO1TvUL1D9Q7VO1TvUL1D9Q7VO1Dv
QL0D9Q7UO1DvzlDVU71D9Q7VO1TvUL1D9Q7VO1TvUL1D9Q7UO1DvQL0D9Q7UuzNU9VTvUL1D9Q7V
O1TvUL1D9Q7VO1TvUL0D9Q7UO1DvQL0D9e4MVT3VO1TvUL1D9Q7VO1TvUL1D9Q7VO1TvQL0D9Q7U
O1DvQL07Q1VP9Q7VO1TvUL1D9Q7VO1TvUL1D9Q7VO1DvQL0D9Q7UO/OvTRyqd6jeoXqH6h2qd6je
oXqH6h2qd6jeoXoH6h2od6DegXoH6r07QO8AvQP0DtA7QO8AvcPyDss7LO+gvIPyDso7KO+gvIPy
Dsq7M1T1LO+wvMPyDss7LO+wvMPyDss7KO+gvIPyDso7KO+gvIPy7gxVPcs7LO+wvMPyDss7LO+w
vMPyDso7KO+gvIPyDso7KO+gvDtDVc/yDss7LO+wvMPyDss7LO+wvIPyDso7KO+gvIPyDso7KO/O
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
+/n+9FiD7SL1xnmMWiXyrdR8Kkv2J1k4mRxOTiWAOc9dmOljwWCZPKR3vxzEWEeNwyo603Ou+i07
m0ywrVSr1cqVcO4QPPDrXKaNZYFdgckoabWSWDmrVcexKo/x8FwujH5PP2eHr2hVHdVO6OsF4Z1f
yb4pfSP5Bd5/fd+Ozh8IFqvRI3gWtmG/OnZypUXFfwq07Gur6QNuuH5IP7R+AlBLAwQUAAAACAAW
pFBEJU+jFN9AAAA4iAAAMgAAAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJkZXQv
ZXVjdHdmcmVxLnB5lZ1vryXFkebf309RkrVaW2rjyj9VGWWvR8IYz6C1MQKskfeN1cDFtKbpZm43
Ruyn3/j9onq80nikXV4c+p5zKisrMzLiiSeezPOTn/zj/7bffPjPH328/f6jDz78+LMPt9/8/o8f
/M/tv/juTx5+sn3+zeP2x6cXf33x6vnL7YPXXz1uL95sf3j9v1+8fPk8//722+9fvfjy+dvXT9uX
L188vnq7fZnfee/h3aUfvXrx9kVe+dvHvz2+fP3d49P2+uvt7T9oM7//8ePbN18+/+7x/2r2xetX
b/LPp+9eP/lHNrx98vqp3v/y6fH528evti9+tMX/fKvnT7T13Y95q2/ebj/94Gdbu67IJv7h19/b
3n/5cvuU777ZPn188/j0t8ev6kk+eP3q7dOLL77Px/zpm5/9Mt/Ztj88f/q37ZMXL//69OLb7edb
9vDt9vb19smPb795/ep+/hyqly++eHr+9COj9vXT4+P25vXXb3/Ijv1q+/H199uXz19tT49fvXhT
zedAvN2ev/rqF6+f8vpvX3/14usfeev7V1/l49Drt49P3755N4b//PGftt8/vsmebv/8+OrxKZ/m
k++/ePniy7z49y++fHz15nF7/mb7jvfefPP3kfodHfns7sj2u9fZvKP7q+3xRX7Ovf/2+PQm39n6
e+3d3e4Wn2051z99/pb+52x+x4U/y07/uL3M2Xh6d+V7/3AI/v6kX20vXtnsNzn2+Y9sMB/0hzSr
7YvH7fs3j19///JZtpDf3f71o8//5Y9/+nx7/+M/b//6/qefvv/x53/+VX43Rzo/zfmrll58+12a
4FdbPtXT81dvf8yOZwN/+PDTD/4lr3j/Nx/9/qPP/0zvf/fR5x9/+Nln2+/++On2/vbJ+59+/tEH
f/r9+59un/zp00/++NmH723bZ4+P74aYwfxHg/wfQ/x1Nvnt6xzJrx7fPn/x8k09+p9zet9kB19+
tX3z/G+POc1fPr5Ii9qe5xL57sf/rzl8+frVX33evOTvA/qr7cXX26vXb59tPzy9SNtJ6/tPs5ut
/H1+n6XRf/nes+1o+aXnr/7tZU7BZ3n57158nU3/7uXr10/Ptt+8fvOWr/7h/bx2763tP29jb9v2
p8/ynf/qv+3Dj3/7/+hUfvKQDX/4pw8+/1dWxL9///jqyzTL51+8fKyVlgaEeXz99Prb7YsXfz22
H14//RuW8OP2+fMXPzx/9d/TAeUief6U3f8kv/WaZ8srv3/15YuX+cX/8c3bt9/98ic//PDDe49f
ff/e2x9+Ge0X3+YVT7/4J+7demzbz3/+T9v+3uz9bPlWP853bx0rDt46Wn/31pr1Vtv7vN+Ka8Tk
wn3G/da1jhhO/UdfPT7ffvvO1Oncp4z/9ut3bf3ip+3n9z9/tv26v6dT+jR7mI/8n697lRdmb37x
02Pu7ef5r5/9en+v7UetsB+/S0f58h/d7vkXLI9+/DdsjT693F6/yvX75i2r7Nvvv/xm+ya9nZ4l
/dCnv/304cF5+cvnf/7kow/e//1ffvvRZ59/+tFv/vT5R3/8+C+fvp//q2c4GMYPvnn+hM2lvf37
H590UEzi9uxdI+//5vcf/uWzj/7Xh3lR5NjdrXPd56//ftWvt58+pD9tz1rs+7N27Oez7PTxrM3R
nqXHjmf56ZUv0fnX+WyNtucHa+X39v5snC2/nDP4rMeeX258mjOzZn8Yaxx50RjPRp/ZWs52/rny
Dtucz9K4R/6r5ZVX3qu3mM9a49PzuJ6NOLl1P5+NueeXzzmq3SMeGt3KL+S3RrYx9zPvOfPGPdt8
to3s1nZc+V527lm7Tm6zBf2d+a8jns1++SB8ymPS7po5DvnVfLvzkheNtp61s3HRygfpPdtt2be8
YfZ35vfajJ0vz2fjyOEbO53ufTIYV7V77Q/ZDZ5583HzW7FypOdiMPr1jFvng+dQ9Tg6PcorY+WX
c+Uzcvle63bHjh22G/v5kI+xnvX9yIaOnfnIy7cz/FbesHHlRfdb9iif3pFmGof9bc/yAenTmZ+e
jA3t9v6wePA+r+zWlfORL4sHz3m+GNVzHrzk4J27wxjMUb43xmKo8g6zPtBuyh5ixEMOb/7RR3Dj
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
jJbfZqslxdNHeogXi3i6fLxFLqzGKRp4RJJlpSSAIcsK7WswB8BksEi+oSLuj8aj5WOgPxwtp4M0
peFsQTHN48VylKzG8YLmq8V8lg4iopT55HFw85LLZ48LQJYGVubshVSu0f6IBjswVDntxBOj0RlL
zBQJ/CRV/U9dVEZvD4JR8uLoLcmCtPFderYS04P5e9VfoLx0uIuxz6Iu/ddDktDfFXqQonwoC0AP
lTG2S33jfEidxKi9+dDr3Vz3Pt70iFYpIm89NJje/eUaabdahTUlReUm2wnr2FfWbKAfDQy/0WSv
vOzXnhOcpuznh9OmBvtF6q3zGLZSZDup+VSWHE7ScDI5npxKAHMevDDVTcFglSwf7n45iLGQaodl
dKbnXPlbdjqZYF+pVitTwrlj7Eivc5k1tgWWBSajoPVaYues1x3Hqmji4blcGP2efs4OX9G6bMRO
6OsF3Z1fub4qfaX4B6z/+rYbnT8QLHajR/AsbMt+3TRyrUXJfwq07PdW0zvccL18eNf6CVBLAwQU
AAAACAAWpFBEOY30DetCAACrjAAAMwAAAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2No
YXJkZXQvZ2IyMzEyZnJlcS5weZWdXY8dx5Gm78+vKEBYwAbacmVmRFbVGLOAJMseYmRJoGQMvDcG
RbasxlBsTZOyofn1G8+T1HqB8QC7uqDIPufUyY/4eOONN7M/+OAf/7d9/Onvn32+ffbsk08//+rT
7ePPvvjkX7f/5r0f3D7Yvv7ufvvi6eEvD29evN4+eXx1vz283f7w+J8Pr1+/qH9///2Pbx5evnj3
+LS9fP1w/+bd9rLe8+Ht548+e/Pw7qE++dv7v96/fvzh/ml7/HZ79w+eWe///P7d25cvfrj/vx77
8Pjmbf3z6YfHJ/9RD96+fHxaP3/5dP/i3f2r7ZuffOJ//aoXTzzrh5/qq757t/3ik19u7brOesQ/
fPuH20evX2/Pee/b7fn92/unv96/WjP55PHNu6eHb36saf7i7S//qX6ybX948fTv25cPr//y9PD9
9qutRvhue/e4ffnTu+8e37yffy3V64dvnl48/cSqfft0f7+9ffz23d9qYL/Zfnr8cXv54s32dP/q
4e16fC3Eu+3Fm1e/fnyqz3//+Orh25/40Y9vXtV0GPW7+6fv3/68hr///I/bZ/dva6Tb7+/f3D/V
bL788ZvXDy/rw589vLx/8/Z+e/F2+4Gfvf3u7yv1Owby1fuBbL97rMe7ur/Z7h/qdb77r/dPb+sn
W/+w/fxt7594t9Ve/+LFO8Zfu/kDH/xlDfqn7XXtxtPPn/zwHy7B32f6ant442O/q7Wvv9QDa6J/
K7Pavrnffnx7/+2Pr+/qCfXe7d+eff0vX/zx6+2jz/+0/dtHz59/9PnXf/pNvbdWul6t/VtPevj+
hzLBV1vN6unFm3c/1cDrAX/49Pkn/1Kf+OjjZ589+/pPjP53z77+/NOvvtp+98Xz7aPty4+ef/3s
kz9+9tHz7cs/Pv/yi68+/XDbvrq//3mJWcx/tMj/Z4m/rUd+/1gr+er+3YuH12/X1P9U2/u2Bvj6
1fbdi7/e1za/vH8oi9pelIv88NP/1x6+fnzzF+dbH/n7gv5me/h2e/P47m7729ND2U5Z33/Z3XrK
3/f3roz+5Yd3W7Z604s3//66tuCr+vjvHr6tR//u9ePj09328ePbd7z1Dx/VZ/fe2v6rNva2bX/8
qn7y3/23ffr5b/8fg8oHt3rw7z/uo/Vatrfv8Iv/+LFCx+uf2PdX28vvXjy9eIktvXvxzev75YH1
MyZYk/uPL55e/fzadleffvx+++4/5zEHD8566varX/3Pbf/wuPibf6kX2t7j/QtXf/9CG/VC3+P8
+YXz/Qv7rBfqkeuF9uG+//xCdzjPXt0TOn62ZjzlOUu8/bNf10b++hftV+//+sv66ViDeF7OXcP9
rx98U+9h6L/efjGOzAoo9a9f+riWx/Kln36okPgPv/XFNzhCz/+BVa2xPb4pT337Dn/6/seX323f
VVwzhpSjPf/t89tt7cCfv/7Tl88++eizP//22VdfP3/28R+/fvbF539+/lH9zy+//v7Gjz7+7NM/
f/Xsf33KdI65//wKW/P149835p+3X9zaPNrddsR11yLGXR8z7sbV649zP+qfY+ef7a4de/0sZr1l
XvXPbP6RZaNHvxutftb7nne3ekI9sNcTeuZ5t8VRjz7q3dtVHx5t9vpZ7Hexz/2uXfWRfs1Zf8Rx
N/Lc6/n87aqnjDN6PbC2/W4753UXvYa0XQfvOc67nN3P1TddOWv89U1RJoLb1FjzYnDneddq2Hf9
7DWT2K+729aDN/LKUa+086hJ7fWl7TiCj9TMzjbuthrOXav38Kwa615PbVnjipPv7FHPnzWYWsMx
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
+xj7POrT7wMkCf1doQcZyseyBPRYGWP7NDTOh9RZjNrbu8Hg9uPg0+2AaJ0h8quHRvOH/7hGup1O
aU1FUbXN98I69gdrttCPBobfaFYrL4eN5wSnGfvl8bStwX6Reuc8hq0S+V5qPpclx5MsnMxOJ+cS
wFwGL0x1W/A4vPs0uHv4x0mMjdQ4bKMLP+eqt+nZbIaNpTqdXAnn2uCJYe86cSwM7AsMR0mbjcTa
2Wx6jlXZxsNzvTB6m37JDl/Rpmr1zujLFem9N2zf1b4T/QP2f/kXR3o/QVgsSI/gRdqO/abt5kaL
in+WaNnXVtOH0xUfOn8DUEsDBBQAAAAIABakUETjkq0maxIAAC80AAA1AAAAcGlwL192ZW5kb3Iv
cmVxdWVzdHMvcGFja2FnZXMvY2hhcmRldC9oZWJyZXdwcm9iZXIucHm9W21z28YR/q5fcZU/iJyS
rOTUberUzVCyZHMiyhpJrsfjejRH4EiiwguDA0Szv77P7t4BB5Jy7HSmmkkiAXd7+77P7iHPnu3/
UafnbyZX6nJydn51e65OL9+d/aKeWPvs4Jm6Wxr1rkwWSa5TdVbERiVWTYv/JGmq1fs8eTSlxZto
qUtrKhWbykRVUaoIS0cHnsIkT6oEy16bR5MWK1OqYq6qPaSxvvm5XW7wj06LDE+vi7JKityqqDS6
MrGabZjALmVdGlBbbUB5WaneWV89Pz5+ARJ7l4/UOE3VDa216sZYUz6aWBg/K/KqTGY1xOnZ/ktm
barLB3WdpIsyydRQrcCVqgp1vamWRe7EhYLSZFbqckO6mpfGKFvMqzUY+0ltilpFOleliRMr5CF3
pXQe/6kosT8r4mS+oUd1HkMc4royZWa9yt5cvVeXxoJT9cbkpoQ01/UsTSJsvkwik1ujtFUremaX
raYuiJFbx4i6KEBek0p/UibBezqbjIkn6vnoxJ/mKA4UbNrTFfEP461oYx9Mb1QKa5R+52ivClpJ
Y5XkTHYJ3eMXEISgaziTmhlVWzOv0wEoYK36MLl7++79nRpffVQfxjc346u7jz9hLTSNt7CfUEqy
VZqAMKQqdV5twDgITM9vzt5ix/h0cjm5+0jcX0zurs5vb9XFuxs1Vtfjm7vJ2fvL8Y26fn9z/e72
fASPM8armJS5T8mNiucgmRXQJFxeJ6kV0T/CvBYMprFa6kcDM0cGMRIrjYhYbb7LhmmRL1hebGkV
+pNK5iovqoFalwl8B963Y11Qae07gNNHo4F6cYJFOn9IYYJbbL9I5iB9kRZFOVCnha1o6XSMvcfP
T06Ohyc/HJ8o9f4WT576UedXr78xlTw7OJiXRaZGLlOsymIG6WE9CqEzPLw11TU/9AsR7RUsav0i
c1VUU3iiec1JJskXzcpsRZ4ky9alXt0XZXzgPdEdFRfG5keItKiqdZpuyDbFIk/+A1XDi/NFrReG
HEX7bAaTqklFHqzV0qSUXBwtMj5pHR7rTfrWzEqzpvA1qVtmD0h1jYWT2Gi7tdznTccL2Utx4hUT
wsU0zOVWWWW+IJQohmQ75aTDye274Y8/vvjb8MdDZKR/JhbSuff0ep3kcbG2w5PnL17QgstikUSd
FS2B4WT/ii/DTEfDJf9NK37+eWsRnjDLpwVciggetjyTjsj7EaewG/QOPeQVbybJoQ+qFUilCWwN
r0Yqgp52WUeG3OaEElm1LpBg5nPsyitSPJnJ1vg3n87ZAAoHE8ExIxXSRgjPk9zAzHHMJnAFDZ4C
Kj5lIXYWFFnHX348Hh5/+dsFZVlbZEZliY2Qb3NyLLZghiph6fXaILP5ZaKqoV2ZKJlzqMeJjhDE
SWRZuuD4o48J/rDLI4T9Qlc1BIX2dtgBMxExE/+FfDVUTiOTTbIk1WVHtlYRnGk5x+hWi1SF9GqF
AJOkNkYVIwrEpUJWKylQnOEr88URyItQHgQNAjgyZW7iAXJZipipqcY0fkHGa12BSZSGlMMVtWOs
qdE5uJGC4WKPmWwiASeslnpmqvYskoE1ZTWU/6jTGtoAZXr//K9+n9MqqPWSPErrmM6ZMyRxr/ot
jImLDG/gZl5VkUHdqtZGahH5mJcO8uNJgrSTlJSsSPFJtSEzHUqMHm69UhmktCKjFP0vnHuQynBU
TOpPJHfgYHpUCl5CLVCaazpCSavTyeuJW0Gi6HRRwCTLbMQSNFutMbY9Bt5H7ljqtaWCzGk1NXO2
BOMo2S0sVdakc4rTvOEtJxflpAqGEb5EbaajB7AVw35juBkpjDjsJCi1kNyIjahDD1TkHggtcWL7
lGokuzXOoH3zpMRfKF54v0JYEbDxJ3xWn9bLIjXy2jPVvAYxCq9924TqN50BKp+gPVpHK7C5w59F
BsdbeTUajZSpoiN1SGfH7FQ7CWKg8jqjMsHcnecLwmuiY6j9UfTkvIDs3OhYp7ZQh4/Oi2jzHoOx
0x66NP2kr+262WFzDkhHER5z5BUOQPMy8hFn6JGrkOKXdoWincwSPqPY8taKEoRdpXrjaPHRzLpg
dSwgGchf2Isb36UDUEZiWoH9iDrnNyD0PWp1qZN+d0GN3zijdlInxZJOs8IKprCQKGWghbwAW+eu
k6gouYHbi5I7lDUFLgSvsNY8UmYDnxMkMgKDtHNAakPcZdYjX+vl2DIPqEFiZzvHaYGilql6xfnL
qVbPikcAogBPEPAge2UGmShPbKYecpQ5WolEj1oZZGAKsm40DrfRROP9or+h+lDQHxxNyNwkIidy
adva1etl0olGEsf5FfRF7eEe3LOqSyjbuB6QhOoSqHNBeJSAe5McNSlCupdykDBKTE0GrhzqpQ5B
SEmI7iFDqX0byQx3IVNelJlOB0EE+mBpPWkLRTFmtPXMIZwO2iDteTCaG/HqmVOhBweSS7k6zhNu
SLexD51AeaBdxIAjOIjiyLt9uNfrFy6IlFVREeVjoYNdEFOUW1XdhTB1XAhNxzXBG2wtcoAD6vIC
9IRuaM2FyKpfUYFb0qMWncNuAFFIAc6PCKuVFBAgVVvejSoHYNiB12z6ULCRel03DRF5RyBpJ8Ar
DnsKcygQTZWRZurJgxKyVeNL3JAhxudzajfImgCbc/IRivhlIh5ByJ9qpvQ06plH9fSsIQttUqaI
WxQBNHt72mmHHDZ0/inPqEd2eQChFi1ZFpwPYIY040YkiA1QRhOokXnyX+uEUQQ5nyEk7gcDIIUT
b9+URb0S6q7Y72PFedtmF6YkFGykdPGGh0RKpXA9aKIMJpOcI4cI0orhfTx4kDTFIoFakfO0SYpN
pgEI3SgjVAU9Q3OBrNcgt6EgN2XhRZxOXBNt3BOfPvdKSCWmLOI6oq5F2EOpXEMrjfm21CWl0JW+
VCYDNPBgBO2KpptysbJIK3fTSyqCeoFy5UtUGzRNCRsAFq2H49uzyaQTm+FSu0JB9BgnJ0hLuJ/r
Mgxec4bON8jXCD9yUMIqdRQex6hYUZylRsiNnKQOts0lSRmNbd53pQqSKtSCdBE49YraFZd5QGiJ
yBYZPNm9iu91Wuc+Ege3dx7ANx06L6Pa9SHJKc1N6W9PWRDcFm3CDoJQ5AjJ5wSkRDWFG39tb6Mk
PWBE1UwKwvw6QDWGLSQAuQQJ+TV3r7M6SR1sdtBwmzyhpiJlzWb6QURd6aQcFnPnwSBDsBjKderu
KiGE2JxLsWpFNk1gZvMFv0BG9H81zejYQzyq7AwrJMMS+U6ZSrt1MXNqdoruhCBVd3QhPlVvtviU
GSvCmBRKi0koChPKGGHANrDJ1osF1QrHl88xMqjc5gzhJmKB3FtfCBL7b2oejcPGrfGdfw08Yq3T
amso46ZQz3gCZyS1SgOaGgtVd0TX6VpvKP4BDYCoj0fHx+RWMPhcZAEdqCXiIW8OTFK2Fdu2oybK
YtJYIXBzWwFZC4fcAgt4lly9rfiVtg4Z78jI/u0nV4dXFEWy75DC5cPSTVDfhOHrBpa0EWAMNfHR
NAxHknxYoWTlVVOLaIBtgRb8XCyns5xSvYQBmlETeeXORGIqCb8QpGkk7Igy2BGOjnLIlM6gYrhf
RWF0dasNaXrH7ANHoylJvvSEvVBLbOinMq6y0EiCEJWrtDQPk5l+YBVZKqlBSotUEPKgdkJOgMKr
MFBni98DhQ58ZGxBV1gjBPSjA66FQYz/SbWvO2MhHMZ+hyA8uJhcjS/vfxlfqFfq+IvRB1fvbqbh
k5lbMj2fyoPYL2meGLfk6v2VPJj7Jf7J/NgtuT6Xv3/wK/yDP7sFd7djNIf86IVfEzz7C0k5BRzI
0C+5/uax6aY6sx0xRTDN4Ymv6DwY8cA6M4NCzEl+gCxGyL2kUaYtUvqPawl3SfOMj6bYRHo6uboX
Cc7ejm/uX09u78ZXZyTci6+zLO7zv/IKvMaQMQ9iaT+T03evzy9D/pDVTg4O/jm5fQ/m356f3px/
uL8aT+lV6F8Hl+/eTM52l3Sc8uDgIEqRszpR1+tUxv7LA4LasZmr+3topbq/71FqdM/pp7N+1F3V
LOJ0ep85Nbp88EpdIatvrxGlf2UJIsFUvf5Bw5k82GLLUbsgRyAW3dG3bDro8cmFcv7uuhYv8bAp
7KuoXXC5YlWicha1dXhtEGzPrvGOc1F2apBTjPxNs1e5CgWq4erBuI8ISqNMTxxyCKhp6aXhOkmW
kJe7JmBmgG8ZgLuMRV3HtrB88it1pI623wScdd+z+Na0BY2mnOu8vdQMoeeoNQ5Mc88efu92sqEG
Hjn4VP8YWH3Xitt+09n8Gw4UUm7ZSuw95wjHTRScKem/ubzqRX2yxacm9w5Uk2P9r8ic/tfr89bm
T/wEufNzh6O8yJ/kStxP8LK6szpOPNbTalEUMQXK8CJMe7F04GueE9E0N6B1lJpoWVSmOlI9GvGj
hez7EYQgR6UBOqqyWFFpnFf++psOFogb+mK7VC4b3OxBmhnvzRdA4ab8ILfGrtO6dDP/llakWxDc
isTnMr3Vymh2drDoZsAuFHjK1BKiYxauG3CaEnxijQ/WTjM42lK1hxPXhmP2Fz3n+QTSt5u74Fz8
KV9AmKVG2PNUnQ6aGboSDYN1r4lGbojHo/aj62J1NFBH6KV0tjriQ4+m9Qxp5iEMQwJ26ChoxAYy
C+6eSBHu6qg945qvUME3cHKxJrwriKolNTO5mSeVyxS2lRlodZtXAJG6Whs0kNallQxdRUBMoLXQ
EZ+jFPFrTTfjpLjRbwVYi2UGqgUtze8cYw0OCQJnbkzsAkaf1vNOzHQCQuP3jU0EG7sUMnRtWINE
g82Xrjdqm6Fm1NJ8TODa8qc6ooBa0xv5zmjL3+ZFmsp8jlxUtBctTfRg4lCik74ai7/TRwkcloiE
EyfjgFwh8R8r6A4O8p1pGG340VS7Yt9R7AyTUp3EZPrObURj6y6pDuoqjTT2HLDWlyewN1J/PAlN
INAnVMfz75JxN6omeZcvlzX9AEy8MySCIBmoqcngYHU+cJHDSXbQpeQ+KKEYb2Kum6naZoHuIBxD
518iwx/qbOme+xfqOOrUd7c5LaOehS4UKC4SC+JMu9dvTAirdSl9kwmDIYUzgevWuzIyEm0f/fAb
1gBeLasnfY457x7QNGqtMtu0voNhJLv//yQPHHErQl34Cvqn9NxxYLmriqJaoBqq37KkCsS3PZ1I
8fe8vIO1hThxoa70AiUY+JInfDIAhxO8MZXD2TQ7gCME5K4K2cxDV0jWuTL3pS5L4jjlzlW8nwbe
NFLhSO5UTbqL4Brp0EUnPXA2lES3M0berqIB1Q/QTF0Vma7cfcqcsQCbhjqhvw5nSQdS90ojt4s4
KpPrjZaajFn7dGPAozJyzRl/ZFVu3GePxCueP1j3GUq6GalP0/G1KxvsN3MBjAsAVLhwBa2qV6/c
p01txpUj+WuardmBpjnRUYMsshFZgj6YIU8sGE0leR34E/242ientMxQ4QJWZYZEN/c0q72HWu6L
PN30uLK168kOUc2uQW+67EIyeveKAXz3VWMOajL5AtUDtKGHUf+uLSc3E+/s9CrrtAl/eOIYOSqH
TwyrYtj0TDSTdbBVDoYVw67Eu90T9HzaYV73rvFMdhC+o97fz6aQZq/vob5+Gj5/STwwf58/DU9e
hiH1+ROU+1LePUntq93nH1+pk7070cu1zHebgW8X4Pk+AbZr5OdPX6GjfoeAYde8I59Jrdnnh1fE
Izkip/rGF/f5Xa+3p0Flz+vzJzNP8dl72hd4o+pRqIgP95/QrtfsD6LZr7lFq/W9lL5La/s68oD/
fWvdKnByEOTLC+ynaXfsP9ZEH0Df+To8Rhm8Rq5KkUR3spzkq4CYZC7VAwaIU49T2kGPz2/th6EN
TqdE6wam9zRG3Z7YPFNTPx32aPylu3TcqTU/B7vc5G3vNFFmaVLt3AdjJqeqPJBJHE2Vg5rFNGw9
azW9P4KHX7NkWGEagv94pZ4YOr7cVx/2jO/2kv37KzX8Hrq7g8PQUSa+nO0oq0Jl5du3dsQajC0J
ZfBFSatJfiua7O0b4nDZba9mev298TLcN9PZ2doPVdMc/A+1O0D9PbpuCP5dVP0NFL+u5VsOvrzg
mcCAoan7oimY3TjPHahMb2Z0Y3WEPZa+Y+9iyVhvRvs9g0bFv4O7Xuuy6rj9BLnP/9eBzLDpOyb5
xoq+Iyv6FN26TunPTvfsvpn6BnV3coSAsZ3kcGP4I1O6U33k/62CP8r398bzfXduDMhpeUdFT/vj
DgyUEvGvUIu9pzxyd/Ne7Tvkt/20zZf/BVBLAwQUAAAACAAWpFBEl6+aDr5WAADTuAAAMAAAAHBp
cC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJkZXQvamlzZnJlcS5weZW9Xa8lt5WmeX9+
RQDCADYqrd78WovsQjcgq+Rq1fgLkoyG+6aQlo7KiUplqjJTrtb8+uHzMDQeoNxAty5CefbeZDDI
l4trvesl46OP/vZ/1y8/+8fPf3v9+vNPP/vtl59dv/z17z79v6//xW8/evro+urPz9fv3r36l1dv
Xr6+Pn37zfP16v31m7f/z6vXr1/uv7/77oc3r75++eHtu+vr16+e33y4vt6/+fjpp6Kfv3n14dUu
+Q/Pf3l+/fb753fX22+vD3+jzv373z5/eP/1y++f/3/Vvnr75v3+8933b9/5x674+v3bd+fzr989
v/zw/M31px+t8T/e6uU76vr+x32rP3+4fvbpz6+y1txV/M2ff3x98vr19QW/fX998fz++d1fnr85
T/Lp2zcf3r360w/7MX/2/uf/eX9yXb95+e5fr9+/ev0v7159d/3i2i38cH14e/3+xw9/fvvmfv7d
Va9f/endy3c/0mvfvnt+vt6//fbDv++G/f3149sfrq9fvrnePX/z6v2pfnfEh+vlm2/+09t3u/x3
b7959e2PfPTDm2/249DqD8/vvnv/Ux/+42//cP36+f1u6fWPz2+e3+2n+f0Pf3r96utd+Nevvn5+
8/75evn++p7P3v/5rz31Kxry5d2Q61dvd/X27t9fz6/299z7L8/v3u9Prvpx+elud40vrj3WP3v5
gfbv0fyegj/fjf7xer1H491PJT/+m13w1yf95nr1xmr/vPt+/2NXuB/03zesrj89Xz+8f/72h9cv
dg37t9d///yr//a7P3x1ffLbP17//ZMvvvjkt1/98e/3b3dP72/3+J2aXn33/YbgN9d+qncv33z4
cTd8V/Cbz7749L/tEp/88vNff/7VH2n9rz7/6refffnl9avffXF9cv3+ky+++vzTP/z6ky+u3//h
i9//7svPPr6uL5+ff+piOvNvdfL/18Xf7iq/e7t78pvnDy9fvX5/Hv2Pe3jf7wa+/ub688u/PO9h
/vr51UbU9XJPke9//D8aw9dv3/yLz7uL/LVD//569e315u2HF9e/v3u1sbPR9x9Gd9fy1/F9sUH/
9ccvrlH2j16++dfXewi+3MV/9erbXfWvXr99++7F9cu37z/w0998sss+aimPX5T2KNf1hy/3J/+r
/67PfvsP/5tG5aOnXfGXLxms/VTfvnv73fXyTwxkffxm4/t/fri+A0h7br7fGPn69Q/bPrzez7ct
wA+7k/f02B343fc/ALYPz1//+c3b12//5Uf7/J9efv/yzTND8u753354fvP1xvvLP73emH35/cHG
7qM/vd0P++Uv/unzL63rsz98+ot/+v0xVz9qMt7vqXzw+fbdnncf095S53X94hf/9Xp8nPlYfX9U
R/z00RxZHvujUepPH60abVDwUftPH+XuSAo++vzpo9Vbsemff/OMMfppfjD3vmDQrv/yU2XXf7p+
Vn5x//Hz/XmpHw+s2Rf7MXYn/seyb/aPaNIuWFeMv4v6d7P93Yxf7A9/bsVlnbt/9eP329z+rfu/
2M/5fwHWz//hi6en3Wn//NUff//5p5/8+p//4fMvv/ri81/+4avPf/fbf/7ik/2/XWX7+EF3ffrn
l+/o643Ff/vdO40X43C9ODV88stff/bPX37+Pz7bJXqLacWU+ertX0v8l+tnT9fVHy+2sS1c4sVV
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
dmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJkZXQvanBjbnR4LnB53Vxtb9tIkv6uX9GHfDh7
j/Gy+XKYyWwWcBw78axjB7aDuSAIDFpqWdzIpJak4vH9+uu3p6uaorOZm13g9qJYlpr9WvXUU9VF
tp89m/4nXh2/OT0XZ6dHx+dXx+LV2cXRX8QTdZ/NnonrlRIXXX1XN9VaHLULJepevGv/u16vK/39
/n7b1PNqaDsxX9eqGcRc1zmYoelpUw+1bvlafVXrdqM60S7FMNGnrn+uhn5ebRTrtm6bXn/tNm1n
v+iOxfu2c+XzTlWDWojbR9vj7lBVZ/raPOqhVoPYO9oX8scff9BdTFY/EIfrtbg0dXtxqXrVfVUL
t5Kjthm6+narl7nX77/QJUK8q7ov4n29vuvqe/Fc6BkOYmjF+8dh1TZ+/VpU6/q2q7pHI7Vlp5To
2+XwoCf2k3hst2JeNaJTi7p33WtBDKJqFn9sO93+vl3Uy0dTtG0Wejlm1oPq7nvI8M35B3Gmej1T
8UY1qtOreb+9Xddz3fisnqumV6LqxcaU9SuS1ImZyJWfiDhpdfdWuj8JVevrZuyvqut1icgOJEbz
PSZC63qvGsz8tTY3puG+nvSjWGttdGh5MCkCWulC1I3tdqVlrz/oDvVCHzSsxK0S214tt+tE96Dr
il9Or99efLgWh+cfxS+Hl5eH59cff9J1taT1Va0/11N9v9EQXAi9qq5qhkc9cd3Bu+PLo7e6xeGr
07PT649m9ien1+fHV1fi5OJSHIr3h5fXp0cfzg4vxfsPl+8vro4PhLhSCiI2wpwSchDxUnd532pJ
LtRQ1eveLf2jVm+vJ7heiFX1VWk1z1WtESUqbSKbx9+kw3Xb3Nn16iYk0J9EvRRNOyTioas1djT6
drSreyH9Jhr084NElFJXqpova62CK938pF7qrk/Wbdsl4lXbD6bqu0PdNs2kTJ/LPJVCfLjSJU/9
E8fnr7+TVJ7NZsuuvRcH8/Z+Y9R+b23noas2N223mM3OP7y7uTi5OTq8Pn5zcflRvBT/OXt9cX59
85fzi1/0t+dydnx+8eHN25vL47Ob67eXx1dvL85e6ysyTWfvDv9rqlxfOD0/fae7fn14fRhdLWZA
qv6/qrvqrmoqkT2fr6pO9OpvW9XMtXSr27UGv5Fws72/1frS0lPVfCXmSoO2U5tOc0ajuaMerK3b
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
5s4IntTWWLcLZj9WHWX+XbE1hkA5qkFLyMXQg4AnkA9T7tX+b8s18hKnNMM87zHrQzZhuV1patbj
8blV37c7u5WwRsCrvk1n/3DtqQOXLjd9/FtPFrpVvt3LmPE4XTznruiWWehTsJT2IWhN5Toxdry3
iet2o6wnkm0R25VWeDgwB0E7ZZJ52bgzcciB87vNt/vq7M5215ctn+1KbGVBdhB06334kCftf7K6
LzfqRxCELd7bHLhnFs4E60Y3Wum7wQwicCdQe/a5c9gt+TUH3Rrg2ehOxB4O6pth63Yf5L615//V
xs/ELuMcdn8lBnUd2LOvS1W37jfUAW9fvq1yVP2seIE/XAfd1Q0cqJZC/+dBBN1s9w22AQQWrls8
bm7c1rYGW5XYx8MWdSAdX+0oH+WgT2H7avzhnakx8Dx11o3D/wbtD6bJgrv/2FvtUhoy5/Hh2T9a
eY8qx0GVBV6BbZ99Sd1I4lNS6JwPePlyIb7lDnWJN8z+lml8njqrg+EX32S6G9/z/5v3xjxp2jyf
YJ5N+LcnxM9z5/mun/fE5sdSfdJZ0mPOC3r+4WNU5vF3aHUffqgk768elvE8Ss6zIqYHJy7oMV2I
BzuzCT2SUQl90Xp5mN7S4+snuix1DoGjKCm0bwAWujyN7jXWfzq+PHs7nY5nb8c/ef/xvN9bj6tt
ju2Rx3b/37EB3iL7VrwljFV09MBKEn3R0z2RZn9E3n8BUEsDBBQAAAAIABakUEScnrdj/QsAAD1F
AAA6AAAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmRldC9sYW5nY3lyaWxsaWNt
b2RlbC5wee1bbU/cOhb+nl9hXbRqK6Ws7ZB5abUfKBd6UXnTQFX10yrMBIg6JHOT0F52tf99n5PE
sZ14BqbMVasKIkPiHB+fl+c8dobJ1pb7h73bf394wo4O9/ZPzvfZu6PTvQ9sieyWt8UubmJ2mifX
SRrN2V42i1lSsOPsP8l8HuH69vYuTaZRmeVsOk/itGRTyGx7auhhmpQJRv4ef43n2SLOWXbFSodO
yJ/EZTGNFrGhNsnSApf5IsurCyhmZ1le90/zOCrjGbu8rzT2p4py0rW4x1Q3JXu594qJ8XgEFU7x
bbY7n7MJyRZsEhdx/jWe1Z7sZWmZJ5d3cPNl8eoNehg7jvIv7CyZX+fJLXvNYGHJyoyd3Zc3Wdr4
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
SGPLbHdNozvaDnHZebq51fRS2zHzelq32Qr3XrcZ7jOb/JzvN5tK6DVmoxxm5zYfLtMufbjckzyV
7ObvPiHG4dRuWJzYDYdTu2FxYjccTu2GxYndcDi1GxYndsPJFbUbFid2w+HUblic2I3Z2G74CbHv
bzdM/vcN7Uaf/en51G44nNpNEZVZYNlvUBG0U2K1YqudEts/+8XpNWRuk0elTw7yGnXirHRurzj3
G4hzOkCNxLkY9B5x/nC5E+f5p7RL80+FVIA7t1SbC2eW0WaOT7U5ZxZwos0cn2ozixNt5nCqzSz+
0y5WdJ+lzcPvos29SqpCtbk4HWhVtJnzHqrNLE60WR7rpf/9JIsVFW1GQWC0mZNopujvX65onBfQ
5YrGaxzFH/gkEWgyecTnEsU8YFCfBnBJQZYH0CgeOU0G7a5tdHdniPEpk8xdyZwir1pnWEr79xrW
qIFhpd+aRoZVjL7GsL4aYu0ayYOyrHdH3Z7VbbVU2XT5/f8in+CuWepZvVSR9PnEz+VZ3PSVbs1H
8dk1IeJZ+iUgPZ96FodTz2Jx4lkcTj2LxYlncTj1LBYnnsXh1LNYnHgWh1PPYnHiWRxOPauIVjwr
U4R9a+z80oC6vn60aRXipbNX8tHX2EUz02LmuHQWVtwsQEzraWtExLTaMA/lfjrHddcRGkcn3SHm
i+A6uZE70FK/gWG6DxGrqe1/0JWb5Ppyr+XROt2W58VynxkEwhVxLLfyJaHcyudG3q0XyOXBhUge
RLYNL3kIIfYCV+49U9x1LJbpLrlVJP5ci8DdgBM4/iZGLAz8TUfueYQHkW7YvHd8b+kF18gWjnuT
7ieFyAmu0w15Ubqj8UH4/gHMwqz92Fmlu99ikUabyC4jvQuy/kH2PdVumti+utvvtNa7dyZY9c8m
9l028O0lxDdX9PBqP1hWbuOqujLx2Y23Sv54fzprtWb479/KxTn81zY5nYtXZwW5X0HUxVmcuDiH
UxdnceLibfMrmjZexp6vdmh6AcT/xPcoFKFUgk66CTgObwXcOdcihmUoYkV1wyBxZP01KsVik4gD
+CRQp1BvUhVQ+3KF1E8pQNfevQgOtKP2My19Nc93d/MB9LcDt7RJfzvskHS+AUq/HZQMfdfteU9Z
+Wo8gVl23O3+PNmv2v15ak5TVtO6TC7R+7boVVebiu6SjfHeLXrlmPVb9LY+omzl6njWNY4mrZb8
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
v3FoiNVwwtTwRrxW/dcgtwV2Oqt3UlrFPQbs38cqaDRS7ERRmdpkAkfGGvfpXV0jWPUMMPBCZ4HS
VS6Qy60HXeCB5k6fbrf1D+uaFgSnvVb/ygBXaf0+g69l8reVd6XkuposYmC5iFNAqnX/X1BLAwQU
AAAACAAWpFBEv9QNID8AAABKAAAAOgAAAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL3Vy
bGxpYjMvcGFja2FnZXMvX19pbml0X18ucHlLK8rPVYiPTystKS1KjY9XyMwtyC8qUUhMKs7PKS1J
jYfwubjSQOr0YNLFxTnxuYklyRnxGfnFJXmJualcXABQSwMEFAAAAAgAFqRQRIKG6QbxCgAA6CIA
AD4AAABwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy91cmxsaWIzL3BhY2thZ2VzL29yZGVy
ZWRfZGljdC5webVabW/bOBL+nl9BNChsLxQn6d222OC8uN1tigt2tynaXnEHIzBoibZ5lkQtKdn1
Lfa/38yQlKi3tFng8iGRyOFw3vjMDJVz9iOP94XSJVMbdq8ToUXyWsbldMbilBvDyh0vma5yw1TO
3p3KHfx5Mf9rBL++xV8v8dcrxvOEFafiND87Z+9gnTCOGCYnwEWYkplKloIoZR4rDbtyGGc8TWEX
wVJOVFWR4AMy+kkVJy23u5K9uLr6jr3np0zB6n+IspT5VuiIaZEKbkTCqhxEJza/3n1kv8hY5EYg
j11ZFjeXl7FKxJzHpTzAHsB/HqvsUotYFsJcfvvq5cvv/nJ5dlbq080Zg5+NVhlw04KDsBnZZyvK
lUxEXjJu2Kp+OxOfY1GU7I6obrVWOmCRVFl2Wn0do87uK76OFZjGrfpZnMwnKY4R+8TTSrjnu1Jk
9DgqRgHOODs7s84MHZzAr5mlmeCAVDnXJ+dvkYlsLbQBTxmhcY4pXDsh+nP2Qw4zO6HBoQlDTizj
hWF7EJKVih1IxLkj/ghe6VAXWh1Aa9AfDQDj2WoVwUsqcvsQq7zksDm+YcQAVcgOBIRZCAKWCYiy
BKJICyviBT/Csyf+UW4v7jF+ibiUGey5UZqCLlyKkWN4JtAnOK/Ftkq5JmnJMhL1aSlUCp3zlBmR
buarFejfEJ/a5khlvkdTMs4SVa3TE42ALVJpWmrFUsd22x4Zg7DVpSFjiBykPspyBwwNhI7MRcrg
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
uYYBABwAAAAAAAAAAAAAAKSBoAkBAHBpcC9fdmVuZG9yL3BrZ19yZXNvdXJjZXMucHlQSwECFAMU
AAAACAAWpFBEYB4HjWYBAAAFAwAAGAAAAAAAAAAAAAAApIGrdQEAcGlwL192ZW5kb3IvcmUtdmVu
ZG9yLnB5UEsBAhQDFAAAAAgAJwmjRJgOcrx2FgAAplsAABIAAAAAAAAAAAAAAKSBR3cBAHBpcC9f
dmVuZG9yL3NpeC5weVBLAQIUAxQAAAAIAEmwokR3BoLGAgEAADQCAAAiAAAAAAAAAAAAAACkge2N
AQBwaXAvX3ZlbmRvci9fbWFya2VybGliL19faW5pdF9fLnB5UEsBAhQDFAAAAAgACrCiRC4T3KTG
BQAAiw8AACEAAAAAAAAAAAAAAKSBL48BAHBpcC9fdmVuZG9yL19tYXJrZXJsaWIvbWFya2Vycy5w
eVBLAQIUAxQAAAAIACcJo0TgxgeBogAAANkAAAAgAAAAAAAAAAAAAACkgTSVAQBwaXAvX3ZlbmRv
ci9jb2xvcmFtYS9fX2luaXRfXy5weVBLAQIUAxQAAAAIACcJo0Qfxzrk9gEAAA8EAAAcAAAAAAAA
AAAAAACkgRSWAQBwaXAvX3ZlbmRvci9jb2xvcmFtYS9hbnNpLnB5UEsBAhQDFAAAAAgAJwmjRCuv
R9TWBwAACBoAACMAAAAAAAAAAAAAAKSBRJgBAHBpcC9fdmVuZG9yL2NvbG9yYW1hL2Fuc2l0b3dp
bjMyLnB5UEsBAhQDFAAAAAgAJwmjRPVTs3vdAQAAEQUAACIAAAAAAAAAAAAAAKSBW6ABAHBpcC9f
dmVuZG9yL2NvbG9yYW1hL2luaXRpYWxpc2UucHlQSwECFAMUAAAACAAnCaNE0reXrfwEAAAvEwAA
HQAAAAAAAAAAAAAApIF4ogEAcGlwL192ZW5kb3IvY29sb3JhbWEvd2luMzIucHlQSwECFAMUAAAA
CAAnCaNE7C+3vvYEAABuEAAAHwAAAAAAAAAAAAAApIGvpwEAcGlwL192ZW5kb3IvY29sb3JhbWEv
d2ludGVybS5weVBLAQIUAxQAAAAIACcJo0QtvfPNXQEAAEUCAAAfAAAAAAAAAAAAAACkgeKsAQBw
aXAvX3ZlbmRvci9kaXN0bGliL19faW5pdF9fLnB5UEsBAhQDFAAAAAgAUZ6iRCv6TAcMKAAA25cA
AB0AAAAAAAAAAAAAAKSBfK4BAHBpcC9fdmVuZG9yL2Rpc3RsaWIvY29tcGF0LnB5UEsBAhQDFAAA
AAgAUZ6iRHSHoENXLgAA8r8AAB8AAAAAAAAAAAAAAKSBw9YBAHBpcC9fdmVuZG9yL2Rpc3RsaWIv
ZGF0YWJhc2UucHlQSwECFAMUAAAACAAnCaNEHJr6YpcUAAAUTAAAHAAAAAAAAAAAAAAApIFXBQIA
cGlwL192ZW5kb3IvZGlzdGxpYi9pbmRleC5weVBLAQIUAxQAAAAIACcJo0QO8GL8hi8AAGK3AAAf
AAAAAAAAAAAAAACkgSgaAgBwaXAvX3ZlbmRvci9kaXN0bGliL2xvY2F0b3JzLnB5UEsBAhQDFAAA
AAgAUZ6iRM5E624wDwAAuTQAAB8AAAAAAAAAAAAAAKSB60kCAHBpcC9fdmVuZG9yL2Rpc3RsaWIv
bWFuaWZlc3QucHlQSwECFAMUAAAACABRnqJEPRGuAo0HAACKGAAAHgAAAAAAAAAAAAAApIFYWQIA
cGlwL192ZW5kb3IvZGlzdGxpYi9tYXJrZXJzLnB5UEsBAhQDFAAAAAgAJwmjRJJ0IBeVIgAAz48A
AB8AAAAAAAAAAAAAAKSBIWECAHBpcC9fdmVuZG9yL2Rpc3RsaWIvbWV0YWRhdGEucHlQSwECFAMU
AAAACAAnCaNEQhyqAUQKAADYJAAAIAAAAAAAAAAAAAAApIHzgwIAcGlwL192ZW5kb3IvZGlzdGxp
Yi9yZXNvdXJjZXMucHlQSwECFAMUAAAACAAnCaNEyJHVyDEPAAATMAAAHgAAAAAAAAAAAAAApIF1
jgIAcGlwL192ZW5kb3IvZGlzdGxpYi9zY3JpcHRzLnB5UEsBAhQDFAAAAAgAUZ6iRCiDDXduswAA
AGQBABsAAAAAAAAAAAAAAKSB4p0CAHBpcC9fdmVuZG9yL2Rpc3RsaWIvdDMyLmV4ZVBLAQIUAxQA
AAAIAFGeokQEl95K5LMAAAByAQAbAAAAAAAAAAAAAACkgYlRAwBwaXAvX3ZlbmRvci9kaXN0bGli
L3Q2NC5leGVQSwECFAMUAAAACAAnCaNE3x+jfbY4AAAeyAAAGwAAAAAAAAAAAAAApIGmBQQAcGlw
L192ZW5kb3IvZGlzdGxpYi91dGlsLnB5UEsBAhQDFAAAAAgAJwmjRPgbPS7SGAAA1FkAAB4AAAAA
AAAAAAAAAKSBlT4EAHBpcC9fdmVuZG9yL2Rpc3RsaWIvdmVyc2lvbi5weVBLAQIUAxQAAAAIAFGe
okRDyN/tfK4AAABUAQAbAAAAAAAAAAAAAACkgaNXBABwaXAvX3ZlbmRvci9kaXN0bGliL3czMi5l
eGVQSwECFAMUAAAACABRnqJEkOZ1LHiwAAAAZgEAGwAAAAAAAAAAAAAApIFYBgUAcGlwL192ZW5k
b3IvZGlzdGxpYi93NjQuZXhlUEsBAhQDFAAAAAgAJwmjRB4RPwciJAAAc5UAABwAAAAAAAAAAAAA
AKSBCbcFAHBpcC9fdmVuZG9yL2Rpc3RsaWIvd2hlZWwucHlQSwECFAMUAAAACABRnqJEI+9n/MMA
AAASAQAAKQAAAAAAAAAAAAAApIFl2wUAcGlwL192ZW5kb3IvZGlzdGxpYi9fYmFja3BvcnQvX19p
bml0X18ucHlQSwECFAMUAAAACABRnqJEr4ovZc4BAADLAwAAJQAAAAAAAAAAAAAApIFv3AUAcGlw
L192ZW5kb3IvZGlzdGxpYi9fYmFja3BvcnQvbWlzYy5weVBLAQIUAxQAAAAIAFGeokQ0qdHKSBwA
ADJkAAAnAAAAAAAAAAAAAACkgYDeBQBwaXAvX3ZlbmRvci9kaXN0bGliL19iYWNrcG9ydC9zaHV0
aWwucHlQSwECFAMUAAAACABRnqJEbxYArfYBAAA5CgAAKwAAAAAAAAAAAAAApIEN+wUAcGlwL192
ZW5kb3IvZGlzdGxpYi9fYmFja3BvcnQvc3lzY29uZmlnLmNmZ1BLAQIUAxQAAAAIACcJo0QRP0gg
6B4AAE5pAAAqAAAAAAAAAAAAAACkgUz9BQBwaXAvX3ZlbmRvci9kaXN0bGliL19iYWNrcG9ydC9z
eXNjb25maWcucHlQSwECFAMUAAAACABRnqJEoUM4W2NZAADTaQEAKAAAAAAAAAAAAAAApIF8HAYA
cGlwL192ZW5kb3IvZGlzdGxpYi9fYmFja3BvcnQvdGFyZmlsZS5weVBLAQIUAxQAAAAIAMUTo0QU
5nYoigEAAMoCAAAgAAAAAAAAAAAAAACkgSV2BgBwaXAvX3ZlbmRvci9odG1sNWxpYi9fX2luaXRf
Xy5weVBLAQIUAxQAAAAIAMUTo0TAHCfE/UkAADJVAQAhAAAAAAAAAAAAAACkge13BgBwaXAvX3Zl
bmRvci9odG1sNWxpYi9jb25zdGFudHMucHlQSwECFAMUAAAACADFE6NEq4Z81o9EAAAlyQEAIwAA
AAAAAAAAAAAApIEpwgYAcGlwL192ZW5kb3IvaHRtbDVsaWIvaHRtbDVwYXJzZXIucHlQSwECFAMU
AAAACACTnqJEOs8pDAUUAADFQAAAIAAAAAAAAAAAAAAApIH5BgcAcGlwL192ZW5kb3IvaHRtbDVs
aWIvaWhhdGV4bWwucHlQSwECFAMUAAAACADFE6NEmHA1aI8dAACsdwAAIwAAAAAAAAAAAAAApIE8
GwcAcGlwL192ZW5kb3IvaHRtbDVsaWIvaW5wdXRzdHJlYW0ucHlQSwECFAMUAAAACACTnqJEPf38
qyUTAAAsQAAAIQAAAAAAAAAAAAAApIEMOQcAcGlwL192ZW5kb3IvaHRtbDVsaWIvc2FuaXRpemVy
LnB5UEsBAhQDFAAAAAgAk56iRFInc+wLHQAAgSwBACEAAAAAAAAAAAAAAKSBcEwHAHBpcC9fdmVu
ZG9yL2h0bWw1bGliL3Rva2VuaXplci5weVBLAQIUAxQAAAAIAMUTo0QQZFA6NAQAAPEJAAAdAAAA
AAAAAAAAAACkgbppBwBwaXAvX3ZlbmRvci9odG1sNWxpYi91dGlscy5weVBLAQIUAxQAAAAIAJOe
okQAAAAAAgAAAAAAAAAoAAAAAAAAAAAAAACkgSluBwBwaXAvX3ZlbmRvci9odG1sNWxpYi9maWx0
ZXJzL19faW5pdF9fLnB5UEsBAhQDFAAAAAgAk56iRCKA+8SVAAAAHgEAACUAAAAAAAAAAAAAAKSB
cW4HAHBpcC9fdmVuZG9yL2h0bWw1bGliL2ZpbHRlcnMvX2Jhc2UucHlQSwECFAMUAAAACACTnqJE
fw6QTiABAABwAgAANgAAAAAAAAAAAAAApIFJbwcAcGlwL192ZW5kb3IvaHRtbDVsaWIvZmlsdGVy
cy9hbHBoYWJldGljYWxhdHRyaWJ1dGVzLnB5UEsBAhQDFAAAAAgAk56iRBV3eTq4AgAAugoAADMA
AAAAAAAAAAAAAKSBvXAHAHBpcC9fdmVuZG9yL2h0bWw1bGliL2ZpbHRlcnMvaW5qZWN0X21ldGFf
Y2hhcnNldC5weVBLAQIUAxQAAAAIAMUTo0TppPIssgMAANIQAAAkAAAAAAAAAAAAAACkgcZzBwBw
aXAvX3ZlbmRvci9odG1sNWxpYi9maWx0ZXJzL2xpbnQucHlQSwECFAMUAAAACACTnqJE0ZNvCMkG
AAAEKQAALAAAAAAAAAAAAAAApIG6dwcAcGlwL192ZW5kb3IvaHRtbDVsaWIvZmlsdGVycy9vcHRp
b25hbHRhZ3MucHlQSwECFAMUAAAACACTnqJEOK/kobEAAABgAQAAKQAAAAAAAAAAAAAApIHNfgcA
cGlwL192ZW5kb3IvaHRtbDVsaWIvZmlsdGVycy9zYW5pdGl6ZXIucHlQSwECFAMUAAAACACTnqJE
Y7VaFdABAAB2BAAAKgAAAAAAAAAAAAAApIHFfwcAcGlwL192ZW5kb3IvaHRtbDVsaWIvZmlsdGVy
cy93aGl0ZXNwYWNlLnB5UEsBAhQDFAAAAAgAk56iRAIxw+QQAQAA6gEAACsAAAAAAAAAAAAAAKSB
3YEHAHBpcC9fdmVuZG9yL2h0bWw1bGliL3NlcmlhbGl6ZXIvX19pbml0X18ucHlQSwECFAMUAAAA
CADFE6NELvfLQI4NAABtMgAAMQAAAAAAAAAAAAAApIE2gwcAcGlwL192ZW5kb3IvaHRtbDVsaWIv
c2VyaWFsaXplci9odG1sc2VyaWFsaXplci5weVBLAQIUAxQAAAAIAMUTo0QAAAAAAgAAAAAAAAAt
AAAAAAAAAAAAAACkgRORBwBwaXAvX3ZlbmRvci9odG1sNWxpYi90cmVlYWRhcHRlcnMvX19pbml0
X18ucHlQSwECFAMUAAAACADFE6NE5FxfEBoCAAB9BgAAKAAAAAAAAAAAAAAApIFgkQcAcGlwL192
ZW5kb3IvaHRtbDVsaWIvdHJlZWFkYXB0ZXJzL3NheC5weVBLAQIUAxQAAAAIAJOeokSgTIfl4gQA
AE0NAAAtAAAAAAAAAAAAAACkgcCTBwBwaXAvX3ZlbmRvci9odG1sNWxpYi90cmVlYnVpbGRlcnMv
X19pbml0X18ucHlQSwECFAMUAAAACAC1nqJEuwypskMOAACPNQAAKgAAAAAAAAAAAAAApIHtmAcA
cGlwL192ZW5kb3IvaHRtbDVsaWIvdHJlZWJ1aWxkZXJzL19iYXNlLnB5UEsBAhQDFAAAAAgAxROj
RPxNX++aBwAAFSEAACgAAAAAAAAAAAAAAKSBeKcHAHBpcC9fdmVuZG9yL2h0bWw1bGliL3RyZWVi
dWlsZGVycy9kb20ucHlQSwECFAMUAAAACAC5nqJEYM97JwQKAABNMQAAKgAAAAAAAAAAAAAApIFY
rwcAcGlwL192ZW5kb3IvaHRtbDVsaWIvdHJlZWJ1aWxkZXJzL2V0cmVlLnB5UEsBAhQDFAAAAAgA
k56iRJOfJfslDQAAzzYAAC8AAAAAAAAAAAAAAKSBpLkHAHBpcC9fdmVuZG9yL2h0bWw1bGliL3Ry
ZWVidWlsZGVycy9ldHJlZV9seG1sLnB5UEsBAhQDFAAAAAgAk56iRNv0sZF4AwAAEwkAACwAAAAA
AAAAAAAAAKSBFscHAHBpcC9fdmVuZG9yL2h0bWw1bGliL3RyZWV3YWxrZXJzL19faW5pdF9fLnB5
UEsBAhQDFAAAAAgAxROjRPufyXLiBQAABxsAACkAAAAAAAAAAAAAAKSB2MoHAHBpcC9fdmVuZG9y
L2h0bWw1bGliL3RyZWV3YWxrZXJzL19iYXNlLnB5UEsBAhQDFAAAAAgAk56iRJwr7IwHAgAAsQUA
ACcAAAAAAAAAAAAAAKSBAdEHAHBpcC9fdmVuZG9yL2h0bWw1bGliL3RyZWV3YWxrZXJzL2RvbS5w
eVBLAQIUAxQAAAAIAMUTo0QByhtU8QQAABESAAApAAAAAAAAAAAAAACkgU3TBwBwaXAvX3ZlbmRv
ci9odG1sNWxpYi90cmVld2Fsa2Vycy9ldHJlZS5weVBLAQIUAxQAAAAIAJOeokQtGLDXwQIAAOYI
AAAwAAAAAAAAAAAAAACkgYXYBwBwaXAvX3ZlbmRvci9odG1sNWxpYi90cmVld2Fsa2Vycy9nZW5z
aGlzdHJlYW0ucHlQSwECFAMUAAAACADGnqJE03WsOmcGAABHGAAALQAAAAAAAAAAAAAApIGU2wcA
cGlwL192ZW5kb3IvaHRtbDVsaWIvdHJlZXdhbGtlcnMvbHhtbGV0cmVlLnB5UEsBAhQDFAAAAAgA
k56iRHU5R1C8AgAA/ggAACsAAAAAAAAAAAAAAKSBRuIHAHBpcC9fdmVuZG9yL2h0bWw1bGliL3Ry
ZWV3YWxrZXJzL3B1bGxkb20ucHlQSwECFAMUAAAACACTnqJEqVXdqIYAAADUAAAAJQAAAAAAAAAA
AAAApIFL5QcAcGlwL192ZW5kb3IvaHRtbDVsaWIvdHJpZS9fX2luaXRfXy5weVBLAQIUAxQAAAAI
AJOeokT0YoWTfQEAAJ8DAAAiAAAAAAAAAAAAAACkgRTmBwBwaXAvX3ZlbmRvci9odG1sNWxpYi90
cmllL19iYXNlLnB5UEsBAhQDFAAAAAgAzZ6iRCRVnammAQAAmgQAACMAAAAAAAAAAAAAAKSB0ecH
AHBpcC9fdmVuZG9yL2h0bWw1bGliL3RyaWUvZGF0cmllLnB5UEsBAhQDFAAAAAgAz56iREtPbs4d
AgAA7wYAAB8AAAAAAAAAAAAAAKSBuOkHAHBpcC9fdmVuZG9yL2h0bWw1bGliL3RyaWUvcHkucHlQ
SwECFAMUAAAACAAWpFBEUK7Iw50DAABABwAAIAAAAAAAAAAAAAAApIES7AcAcGlwL192ZW5kb3Iv
cmVxdWVzdHMvX19pbml0X18ucHlQSwECFAMUAAAACAAWpFBE122f7TIPAABSOQAAIAAAAAAAAAAA
AAAApIHt7wcAcGlwL192ZW5kb3IvcmVxdWVzdHMvYWRhcHRlcnMucHlQSwECFAMUAAAACAAWpFBE
TdW1IjEEAADtEAAAGwAAAAAAAAAAAAAApIFd/wcAcGlwL192ZW5kb3IvcmVxdWVzdHMvYXBpLnB5
UEsBAhQDFAAAAAgAFqRQRC2GvKu8BwAAHRgAABwAAAAAAAAAAAAAAKSBxwMIAHBpcC9fdmVuZG9y
L3JlcXVlc3RzL2F1dGgucHlQSwECFAMUAAAACAAWpFBE01Bafkx5AgDStAQAHwAAAAAAAAAAAAAA
pIG9CwgAcGlwL192ZW5kb3IvcmVxdWVzdHMvY2FjZXJ0LnBlbVBLAQIUAxQAAAAIABakUERHf5uS
SgEAACACAAAdAAAAAAAAAAAAAACkgUaFCgBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9jZXJ0cy5weVBL
AQIUAxQAAAAIABakUES1sonYSwMAAPwJAAAeAAAAAAAAAAAAAACkgcuGCgBwaXAvX3ZlbmRvci9y
ZXF1ZXN0cy9jb21wYXQucHlQSwECFAMUAAAACAAWpFBEko5fVSYSAAAuQQAAHwAAAAAAAAAAAAAA
pIFSigoAcGlwL192ZW5kb3IvcmVxdWVzdHMvY29va2llcy5weVBLAQIUAxQAAAAIABakUERk5YHd
YwIAAEkGAAAiAAAAAAAAAAAAAACkgbWcCgBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9leGNlcHRpb25z
LnB5UEsBAhQDFAAAAAgAFqRQRBd2/byLAQAANAMAAB0AAAAAAAAAAAAAAKSBWJ8KAHBpcC9fdmVu
ZG9yL3JlcXVlc3RzL2hvb2tzLnB5UEsBAhQDFAAAAAgA7IyVRGp7C/A7HAAAHGMAAB4AAAAAAAAA
AAAAAKSBHqEKAHBpcC9fdmVuZG9yL3JlcXVlc3RzL21vZGVscy5weVBLAQIUAxQAAAAIAOyMlUTu
LNkXMBUAAOZLAAAgAAAAAAAAAAAAAACkgZW9CgBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9zZXNzaW9u
cy5weVBLAQIUAxQAAAAIABakUESzNRuGwwQAAEAMAAAkAAAAAAAAAAAAAACkgQPTCgBwaXAvX3Zl
bmRvci9yZXF1ZXN0cy9zdGF0dXNfY29kZXMucHlQSwECFAMUAAAACAAWpFBEdxXLUxgFAAD3DQAA
IgAAAAAAAAAAAAAApIEI2AoAcGlwL192ZW5kb3IvcmVxdWVzdHMvc3RydWN0dXJlcy5weVBLAQIU
AxQAAAAIABakUERR7FWJzRkAAMVMAAAdAAAAAAAAAAAAAACkgWDdCgBwaXAvX3ZlbmRvci9yZXF1
ZXN0cy91dGlscy5weVBLAQIUAxQAAAAIABakUESPKerlMwAAAD4AAAApAAAAAAAAAAAAAACkgWj3
CgBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9fX2luaXRfXy5weVBLAQIUAxQAAAAIABak
UERlncVuzgMAAK0IAAAxAAAAAAAAAAAAAACkgeL3CgBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNr
YWdlcy9jaGFyYWRlL19faW5pdF9fLnB5UEsBAhQDFAAAAAgAFqRQRGdPMhttAAAAiQAAADEAAAAA
AAAAAAAAAKSB//sKAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJhZGUvX19tYWlu
X18ucHlQSwECFAMUAAAACAAWpFBEcZy/MXeRAACiQgEAMQAAAAAAAAAAAAAApIG7/AoAcGlwL192
ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmFkZS9iaWc1ZnJlcS5weVBLAQIUAxQAAAAIABak
UET+gBkEGwMAAJQGAAAzAAAAAAAAAAAAAACkgYGOCwBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNr
YWdlcy9jaGFyYWRlL2JpZzVwcm9iZXIucHlQSwECFAMUAAAACAAWpFBE+JDCAA4JAAAKJAAAOQAA
AAAAAAAAAAAApIHtkQsAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmFkZS9jaGFy
ZGlzdHJpYnV0aW9uLnB5UEsBAhQDFAAAAAgAFqRQRDmJpZ90BAAAzw4AADsAAAAAAAAAAAAAAKSB
UpsLAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJhZGUvY2hhcnNldGdyb3VwcHJv
YmVyLnB5UEsBAhQDFAAAAAgAFqRQRPgZ6INbAwAAbgcAADYAAAAAAAAAAAAAAKSBH6ALAHBpcC9f
dmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJhZGUvY2hhcnNldHByb2Jlci5weVBLAQIUAxQA
AAAIABakUETA2RA04AMAAA4JAAA7AAAAAAAAAAAAAACkgc6jCwBwaXAvX3ZlbmRvci9yZXF1ZXN0
cy9wYWNrYWdlcy9jaGFyYWRlL2NvZGluZ3N0YXRlbWFjaGluZS5weVBLAQIUAxQAAAAIABakUEQg
+905UQIAAIUEAAAvAAAAAAAAAAAAAACkgQeoCwBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdl
cy9jaGFyYWRlL2NvbXBhdC5weVBLAQIUAxQAAAAIABakUET8VcDPtgIAADcFAAAyAAAAAAAAAAAA
AACkgaWqCwBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFyYWRlL2NvbnN0YW50cy5w
eVBLAQIUAxQAAAAIABakUESrBibGTAMAAPYGAAA0AAAAAAAAAAAAAACkgautCwBwaXAvX3ZlbmRv
ci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFyYWRlL2NwOTQ5cHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQ
RKYt0jlxBAAAcwwAADIAAAAAAAAAAAAAAKSBSbELAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2th
Z2VzL2NoYXJhZGUvZXNjcHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQRNZI/czJBQAAnx4AAC4AAAAA
AAAAAAAAAKSBCrYLAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJhZGUvZXNjc20u
cHlQSwECFAMUAAAACAAWpFBErHy8RQsFAABeDgAANAAAAAAAAAAAAAAApIEfvAsAcGlwL192ZW5k
b3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmFkZS9ldWNqcHByb2Jlci5weVBLAQIUAxQAAAAIABak
UEQq5C6Rr1MAAJqzAAAyAAAAAAAAAAAAAACkgXzBCwBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNr
YWdlcy9jaGFyYWRlL2V1Y2tyZnJlcS5weVBLAQIUAxQAAAAIABakUEQFs8bkGQMAAIsGAAA0AAAA
AAAAAAAAAACkgXsVDABwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFyYWRlL2V1Y2ty
cHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQRCVPoxTfQAAAOIgAADIAAAAAAAAAAAAAAKSB5hgMAHBp
cC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJhZGUvZXVjdHdmcmVxLnB5UEsBAhQDFAAA
AAgAFqRQRC2iOFQZAwAAjAYAADQAAAAAAAAAAAAAAKSBFVoMAHBpcC9fdmVuZG9yL3JlcXVlc3Rz
L3BhY2thZ2VzL2NoYXJhZGUvZXVjdHdwcm9iZXIucHlQSwECFAMUAAAACAAWpFBEOY30DetCAACr
jAAAMwAAAAAAAAAAAAAApIGAXQwAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmFk
ZS9nYjIzMTJmcmVxLnB5UEsBAhQDFAAAAAgAFqRQRB+12/YaAwAAkQYAADUAAAAAAAAAAAAAAKSB
vKAMAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJhZGUvZ2IyMzEycHJvYmVyLnB5
UEsBAhQDFAAAAAgAFqRQROOSrSZrEgAALzQAADUAAAAAAAAAAAAAAKSBKaQMAHBpcC9fdmVuZG9y
L3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJhZGUvaGVicmV3cHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQ
RJevmg6+VgAA07gAADAAAAAAAAAAAAAAAKSB57YMAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2th
Z2VzL2NoYXJhZGUvamlzZnJlcS5weVBLAQIUAxQAAAAIABakUESEnvWRFxMAAKVKAAAvAAAAAAAA
AAAAAACkgfMNDQBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFyYWRlL2pwY250eC5w
eVBLAQIUAxQAAAAIABakUERIUgmMDAsAAPAxAAA7AAAAAAAAAAAAAACkgVchDQBwaXAvX3ZlbmRv
ci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFyYWRlL2xhbmdidWxnYXJpYW5tb2RlbC5weVBLAQIUAxQA
AAAIABakUEScnrdj/QsAAD1FAAA6AAAAAAAAAAAAAACkgbwsDQBwaXAvX3ZlbmRvci9yZXF1ZXN0
cy9wYWNrYWdlcy9jaGFyYWRlL2xhbmdjeXJpbGxpY21vZGVsLnB5UEsBAhQDFAAAAAgAFqRQRBEh
Qx1lCQAAVDEAADcAAAAAAAAAAAAAAKSBETkNAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2Vz
L2NoYXJhZGUvbGFuZ2dyZWVrbW9kZWwucHlQSwECFAMUAAAACAAWpFBEH6J7Cp4JAAA2LAAAOAAA
AAAAAAAAAAAApIHLQg0AcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmFkZS9sYW5n
aGVicmV3bW9kZWwucHlQSwECFAMUAAAACAAWpFBEULeafscKAAD4MAAAOwAAAAAAAAAAAAAApIG/
TA0AcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmFkZS9sYW5naHVuZ2FyaWFubW9k
ZWwucHlQSwECFAMUAAAACAAWpFBESz1/XeUKAAALLAAANgAAAAAAAAAAAAAApIHfVw0AcGlwL192
ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmFkZS9sYW5ndGhhaW1vZGVsLnB5UEsBAhQDFAAA
AAgAFqRQRKKGmCCCBgAAgBQAADUAAAAAAAAAAAAAAKSBGGMNAHBpcC9fdmVuZG9yL3JlcXVlc3Rz
L3BhY2thZ2VzL2NoYXJhZGUvbGF0aW4xcHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQRKWccXOdBAAA
xAwAADgAAAAAAAAAAAAAAKSB7WkNAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJh
ZGUvbWJjaGFyc2V0cHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQRM6MjztZAwAArwcAADgAAAAAAAAA
AAAAAKSB4G4NAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJhZGUvbWJjc2dyb3Vw
cHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQRI9bUpdYDAAAmEwAAC8AAAAAAAAAAAAAAKSBj3INAHBp
cC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJhZGUvbWJjc3NtLnB5UEsBAhQDFAAAAAgA
FqRQRPoaFbh6BgAAuRIAADgAAAAAAAAAAAAAAKSBNH8NAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3Bh
Y2thZ2VzL2NoYXJhZGUvc2JjaGFyc2V0cHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQRKTc5b8kBAAA
2wwAADgAAAAAAAAAAAAAAKSBBIYNAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJh
ZGUvc2Jjc2dyb3VwcHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQRPZdThUEBQAAlg4AADMAAAAAAAAA
AAAAAKSBfooNAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJhZGUvc2ppc3Byb2Jl
ci5weVBLAQIUAxQAAAAIABakUESarNkcXAcAAAgaAAA6AAAAAAAAAAAAAACkgdOPDQBwaXAvX3Zl
bmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFyYWRlL3VuaXZlcnNhbGRldGVjdG9yLnB5UEsBAhQD
FAAAAAgAFqRQRF/7IGseBAAAXAoAADMAAAAAAAAAAAAAAKSBh5cNAHBpcC9fdmVuZG9yL3JlcXVl
c3RzL3BhY2thZ2VzL2NoYXJhZGUvdXRmOHByb2Jlci5weVBLAQIUAxQAAAAIABakUERM1NYTjQIA
AA8FAAAxAAAAAAAAAAAAAACkgfabDQBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFy
ZGV0L19faW5pdF9fLnB5UEsBAhQDFAAAAAgAFqRQRHGcvzF3kQAAokIBADEAAAAAAAAAAAAAAKSB
0p4NAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJkZXQvYmlnNWZyZXEucHlQSwEC
FAMUAAAACAAWpFBE/oAZBBsDAACUBgAAMwAAAAAAAAAAAAAApIGYMA4AcGlwL192ZW5kb3IvcmVx
dWVzdHMvcGFja2FnZXMvY2hhcmRldC9iaWc1cHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQRJWuRhcC
AgAAdQQAADMAAAAAAAAAAAAAAKSBBDQOAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2No
YXJkZXQvY2hhcmRldGVjdC5weVBLAQIUAxQAAAAIABakUET4kMIADgkAAAokAAA5AAAAAAAAAAAA
AACkgVc2DgBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFyZGV0L2NoYXJkaXN0cmli
dXRpb24ucHlQSwECFAMUAAAACAAWpFBEOYmln3QEAADPDgAAOwAAAAAAAAAAAAAApIG8Pw4AcGlw
L192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmRldC9jaGFyc2V0Z3JvdXBwcm9iZXIucHlQ
SwECFAMUAAAACAAWpFBE+Bnog1sDAABuBwAANgAAAAAAAAAAAAAApIGJRA4AcGlwL192ZW5kb3Iv
cmVxdWVzdHMvcGFja2FnZXMvY2hhcmRldC9jaGFyc2V0cHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQ
RMDZEDTgAwAADgkAADsAAAAAAAAAAAAAAKSBOEgOAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2th
Z2VzL2NoYXJkZXQvY29kaW5nc3RhdGVtYWNoaW5lLnB5UEsBAhQDFAAAAAgAFqRQRCD73TlRAgAA
hQQAAC8AAAAAAAAAAAAAAKSBcUwOAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJk
ZXQvY29tcGF0LnB5UEsBAhQDFAAAAAgAFqRQRPxVwM+2AgAANwUAADIAAAAAAAAAAAAAAKSBD08O
AHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJkZXQvY29uc3RhbnRzLnB5UEsBAhQD
FAAAAAgAFqRQRKsGJsZMAwAA9gYAADQAAAAAAAAAAAAAAKSBFVIOAHBpcC9fdmVuZG9yL3JlcXVl
c3RzL3BhY2thZ2VzL2NoYXJkZXQvY3A5NDlwcm9iZXIucHlQSwECFAMUAAAACAAWpFBEpi3SOXEE
AABzDAAAMgAAAAAAAAAAAAAApIGzVQ4AcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hh
cmRldC9lc2Nwcm9iZXIucHlQSwECFAMUAAAACAAWpFBE1kj9zMkFAACfHgAALgAAAAAAAAAAAAAA
pIF0Wg4AcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmRldC9lc2NzbS5weVBLAQIU
AxQAAAAIABakUESsfLxFCwUAAF4OAAA0AAAAAAAAAAAAAACkgYlgDgBwaXAvX3ZlbmRvci9yZXF1
ZXN0cy9wYWNrYWdlcy9jaGFyZGV0L2V1Y2pwcHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQRCrkLpGv
UwAAmrMAADIAAAAAAAAAAAAAAKSB5mUOAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2No
YXJkZXQvZXVja3JmcmVxLnB5UEsBAhQDFAAAAAgAFqRQRAWzxuQZAwAAiwYAADQAAAAAAAAAAAAA
AKSB5bkOAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJkZXQvZXVja3Jwcm9iZXIu
cHlQSwECFAMUAAAACAAWpFBEJU+jFN9AAAA4iAAAMgAAAAAAAAAAAAAApIFQvQ4AcGlwL192ZW5k
b3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmRldC9ldWN0d2ZyZXEucHlQSwECFAMUAAAACAAWpFBE
LaI4VBkDAACMBgAANAAAAAAAAAAAAAAApIF//g4AcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2Fn
ZXMvY2hhcmRldC9ldWN0d3Byb2Jlci5weVBLAQIUAxQAAAAIABakUEQ5jfQN60IAAKuMAAAzAAAA
AAAAAAAAAACkgeoBDwBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFyZGV0L2diMjMx
MmZyZXEucHlQSwECFAMUAAAACAAWpFBEH7Xb9hoDAACRBgAANQAAAAAAAAAAAAAApIEmRQ8AcGlw
L192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmRldC9nYjIzMTJwcm9iZXIucHlQSwECFAMU
AAAACAAWpFBE45KtJmsSAAAvNAAANQAAAAAAAAAAAAAApIGTSA8AcGlwL192ZW5kb3IvcmVxdWVz
dHMvcGFja2FnZXMvY2hhcmRldC9oZWJyZXdwcm9iZXIucHlQSwECFAMUAAAACAAWpFBEl6+aDr5W
AADTuAAAMAAAAAAAAAAAAAAApIFRWw8AcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hh
cmRldC9qaXNmcmVxLnB5UEsBAhQDFAAAAAgAFqRQRP55Ud0TEwAAoEoAAC8AAAAAAAAAAAAAAKSB
XbIPAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL2NoYXJkZXQvanBjbnR4LnB5UEsBAhQD
FAAAAAgAFqRQREhSCYwMCwAA8DEAADsAAAAAAAAAAAAAAKSBvcUPAHBpcC9fdmVuZG9yL3JlcXVl
c3RzL3BhY2thZ2VzL2NoYXJkZXQvbGFuZ2J1bGdhcmlhbm1vZGVsLnB5UEsBAhQDFAAAAAgAFqRQ
RJyet2P9CwAAPUUAADoAAAAAAAAAAAAAAKSBItEPAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2th
Z2VzL2NoYXJkZXQvbGFuZ2N5cmlsbGljbW9kZWwucHlQSwECFAMUAAAACAAWpFBEESFDHWUJAABU
MQAANwAAAAAAAAAAAAAApIF33Q8AcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmRl
dC9sYW5nZ3JlZWttb2RlbC5weVBLAQIUAxQAAAAIABakUEQfonsKngkAADYsAAA4AAAAAAAAAAAA
AACkgTHnDwBwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFyZGV0L2xhbmdoZWJyZXdt
b2RlbC5weVBLAQIUAxQAAAAIABakUERQt5p+xwoAAPgwAAA7AAAAAAAAAAAAAACkgSXxDwBwaXAv
X3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy9jaGFyZGV0L2xhbmdodW5nYXJpYW5tb2RlbC5weVBL
AQIUAxQAAAAIABakUERLPX9d5QoAAAssAAA2AAAAAAAAAAAAAACkgUX8DwBwaXAvX3ZlbmRvci9y
ZXF1ZXN0cy9wYWNrYWdlcy9jaGFyZGV0L2xhbmd0aGFpbW9kZWwucHlQSwECFAMUAAAACAAWpFBE
FgpXeXwGAAB5FAAANQAAAAAAAAAAAAAApIF+BxAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2Fn
ZXMvY2hhcmRldC9sYXRpbjFwcm9iZXIucHlQSwECFAMUAAAACAAWpFBEpZxxc50EAADEDAAAOAAA
AAAAAAAAAAAApIFNDhAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmRldC9tYmNo
YXJzZXRwcm9iZXIucHlQSwECFAMUAAAACAAWpFBEzoyPO1kDAACvBwAAOAAAAAAAAAAAAAAApIFA
ExAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmRldC9tYmNzZ3JvdXBwcm9iZXIu
cHlQSwECFAMUAAAACAAWpFBEj1tSl1gMAACYTAAALwAAAAAAAAAAAAAApIHvFhAAcGlwL192ZW5k
b3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmRldC9tYmNzc20ucHlQSwECFAMUAAAACAAWpFBE+hoV
uHoGAAC5EgAAOAAAAAAAAAAAAAAApIGUIxAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMv
Y2hhcmRldC9zYmNoYXJzZXRwcm9iZXIucHlQSwECFAMUAAAACAAWpFBEpNzlvyQEAADbDAAAOAAA
AAAAAAAAAAAApIFkKhAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmRldC9zYmNz
Z3JvdXBwcm9iZXIucHlQSwECFAMUAAAACAAWpFBE9l1OFQQFAACWDgAAMwAAAAAAAAAAAAAApIHe
LhAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvY2hhcmRldC9zamlzcHJvYmVyLnB5UEsB
AhQDFAAAAAgAFqRQRJ29rO9UBwAArxoAADoAAAAAAAAAAAAAAKSBMzQQAHBpcC9fdmVuZG9yL3Jl
cXVlc3RzL3BhY2thZ2VzL2NoYXJkZXQvdW5pdmVyc2FsZGV0ZWN0b3IucHlQSwECFAMUAAAACAAW
pFBEX/sgax4EAABcCgAAMwAAAAAAAAAAAAAApIHfOxAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFj
a2FnZXMvY2hhcmRldC91dGY4cHJvYmVyLnB5UEsBAhQDFAAAAAgAFqRQRAZTbFRAAwAApQYAADEA
AAAAAAAAAAAAAKSBTkAQAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL3VybGxpYjMvX19p
bml0X18ucHlQSwECFAMUAAAACAAWpFBEAr9gaYIEAAAnDAAANQAAAAAAAAAAAAAApIHdQxAAcGlw
L192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvdXJsbGliMy9fY29sbGVjdGlvbnMucHlQSwECFAMU
AAAACAAWpFBEElRL3pgGAAAbFgAAMwAAAAAAAAAAAAAApIGySBAAcGlwL192ZW5kb3IvcmVxdWVz
dHMvcGFja2FnZXMvdXJsbGliMy9jb25uZWN0aW9uLnB5UEsBAhQDFAAAAAgAFqRQRIv/gA6pHAAA
p2QAADcAAAAAAAAAAAAAAKSBm08QAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL3VybGxp
YjMvY29ubmVjdGlvbnBvb2wucHlQSwECFAMUAAAACAAWpFBE+bL82FcEAADKDAAAMwAAAAAAAAAA
AAAApIGZbBAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvdXJsbGliMy9leGNlcHRpb25z
LnB5UEsBAhQDFAAAAAgAFqRQRHqa+oaQBwAAWBcAAC8AAAAAAAAAAAAAAKSBQXEQAHBpcC9fdmVu
ZG9yL3JlcXVlc3RzL3BhY2thZ2VzL3VybGxpYjMvZmllbGRzLnB5UEsBAhQDFAAAAAgAFqRQRP67
GODXAwAA0AkAADEAAAAAAAAAAAAAAKSBHnkQAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2Vz
L3VybGxpYjMvZmlsZXBvc3QucHlQSwECFAMUAAAACAAWpFBEw2sSggoLAAARIwAANAAAAAAAAAAA
AAAApIFEfRAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvdXJsbGliMy9wb29sbWFuYWdl
ci5weVBLAQIUAxQAAAAIABakUESw0wWDwAcAALAWAAAwAAAAAAAAAAAAAACkgaCIEABwaXAvX3Zl
bmRvci9yZXF1ZXN0cy9wYWNrYWdlcy91cmxsaWIzL3JlcXVlc3QucHlQSwECFAMUAAAACAAWpFBE
xtOssP0MAAApKQAAMQAAAAAAAAAAAAAApIGukBAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2Fn
ZXMvdXJsbGliMy9yZXNwb25zZS5weVBLAQIUAxQAAAAIABakUESp0WI1lBoAAJ9TAAAtAAAAAAAA
AAAAAACkgfqdEABwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy91cmxsaWIzL3V0aWwucHlQ
SwECFAMUAAAACAAWpFBEAAAAAAIAAAAAAAAAOQAAAAAAAAAAAAAApIHZuBAAcGlwL192ZW5kb3Iv
cmVxdWVzdHMvcGFja2FnZXMvdXJsbGliMy9jb250cmliL19faW5pdF9fLnB5UEsBAhQDFAAAAAgA
FqRQRFNnm6shBgAAhRIAADkAAAAAAAAAAAAAAKSBMrkQAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3Bh
Y2thZ2VzL3VybGxpYjMvY29udHJpYi9udGxtcG9vbC5weVBLAQIUAxQAAAAIABakUEQxf/PP6w8A
AC82AAA6AAAAAAAAAAAAAACkgaq/EABwaXAvX3ZlbmRvci9yZXF1ZXN0cy9wYWNrYWdlcy91cmxs
aWIzL2NvbnRyaWIvcHlvcGVuc3NsLnB5UEsBAhQDFAAAAAgAFqRQRL/UDSA/AAAASgAAADoAAAAA
AAAAAAAAAKSB7c8QAHBpcC9fdmVuZG9yL3JlcXVlc3RzL3BhY2thZ2VzL3VybGxpYjMvcGFja2Fn
ZXMvX19pbml0X18ucHlQSwECFAMUAAAACAAWpFBEgobpBvEKAADoIgAAPgAAAAAAAAAAAAAApIGE
0BAAcGlwL192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvdXJsbGliMy9wYWNrYWdlcy9vcmRlcmVk
X2RpY3QucHlQSwECFAMUAAAACAAWpFBE01gesVwOAABsLQAANQAAAAAAAAAAAAAApIHR2xAAcGlw
L192ZW5kb3IvcmVxdWVzdHMvcGFja2FnZXMvdXJsbGliMy9wYWNrYWdlcy9zaXgucHlQSwECFAMU
AAAACAAWpFBEXQdRpNwAAADLAQAATQAAAAAAAAAAAAAApIGA6hAAcGlwL192ZW5kb3IvcmVxdWVz
dHMvcGFja2FnZXMvdXJsbGliMy9wYWNrYWdlcy9zc2xfbWF0Y2hfaG9zdG5hbWUvX19pbml0X18u
cHlQSwECFAMUAAAACAAWpFBErdScGwQGAADCDgAAVAAAAAAAAAAAAAAApIHH6xAAcGlwL192ZW5k
b3IvcmVxdWVzdHMvcGFja2FnZXMvdXJsbGliMy9wYWNrYWdlcy9zc2xfbWF0Y2hfaG9zdG5hbWUv
X2ltcGxlbWVudGF0aW9uLnB5UEsBAhQDFAAAAAgAfBWjRNk+Inu3BQAArA4AAB4AAAAAAAAAAAAA
AKSBPfIQAHBpcC9iYWNrd2FyZGNvbXBhdC9fX2luaXRfXy5weVBLAQIUAxQAAAAIAHwVo0QjzwqQ
owIAALwIAAAYAAAAAAAAAAAAAACkgTD4EABwaXAvY29tbWFuZHMvX19pbml0X18ucHlQSwECFAMU
AAAACAB8FaNEk3rw9+ECAAD7BgAAFgAAAAAAAAAAAAAApIEJ+xAAcGlwL2NvbW1hbmRzL2J1bmRs
ZS5weVBLAQIUAxQAAAAIAHwVo0SRycP1vgIAAC4HAAAaAAAAAAAAAAAAAACkgR7+EABwaXAvY29t
bWFuZHMvY29tcGxldGlvbi5weVBLAQIUAxQAAAAIAHwVo0TimcFmdAUAADgSAAAWAAAAAAAAAAAA
AACkgRQBEQBwaXAvY29tbWFuZHMvZnJlZXplLnB5UEsBAhQDFAAAAAgAFqRQRBtsf/2SAQAAnwMA
ABQAAAAAAAAAAAAAAKSBvAYRAHBpcC9jb21tYW5kcy9oZWxwLnB5UEsBAhQDFAAAAAgAfBWjRMmA
PgOiDAAAljEAABcAAAAAAAAAAAAAAKSBgAgRAHBpcC9jb21tYW5kcy9pbnN0YWxsLnB5UEsBAhQD
FAAAAAgAfBWjRFctxxq/BgAAnhoAABQAAAAAAAAAAAAAAKSBVxURAHBpcC9jb21tYW5kcy9saXN0
LnB5UEsBAhQDFAAAAAgAfBWjRBsbOBWeBgAAgBIAABYAAAAAAAAAAAAAAKSBSBwRAHBpcC9jb21t
YW5kcy9zZWFyY2gucHlQSwECFAMUAAAACAB8FaNEW08q89ADAADPCgAAFAAAAAAAAAAAAAAApIEa
IxEAcGlwL2NvbW1hbmRzL3Nob3cucHlQSwECFAMUAAAACAB8FaNEogwhvjUDAACbCAAAGQAAAAAA
AAAAAAAApIEcJxEAcGlwL2NvbW1hbmRzL3VuaW5zdGFsbC5weVBLAQIUAxQAAAAIABakUESjtduD
fgAAALkAAAAVAAAAAAAAAAAAAACkgYgqEQBwaXAvY29tbWFuZHMvdW56aXAucHlQSwECFAMUAAAA
CAB8FaNEuuJvNh0IAACYHAAAFQAAAAAAAAAAAAAApIE5KxEAcGlwL2NvbW1hbmRzL3doZWVsLnB5
UEsBAhQDFAAAAAgAfBWjRBIX/XRBDQAA5TkAABMAAAAAAAAAAAAAAKSBiTMRAHBpcC9jb21tYW5k
cy96aXAucHlQSwECFAMUAAAACAB8FaNEqv9Lj0gKAAAsIgAAEwAAAAAAAAAAAAAApIH7QBEAcGlw
L3Zjcy9fX2luaXRfXy5weVBLAQIUAxQAAAAIAHwVo0SlfkBBUwYAAE8TAAARAAAAAAAAAAAAAACk
gXRLEQBwaXAvdmNzL2JhemFhci5weVBLAQIUAxQAAAAIAHwVo0QvmnkNvQkAANoeAAAOAAAAAAAA
AAAAAACkgfZREQBwaXAvdmNzL2dpdC5weVBLAQIUAxQAAAAIAHwVo0TeUkdQXwYAALwWAAAUAAAA
AAAAAAAAAACkgd9bEQBwaXAvdmNzL21lcmN1cmlhbC5weVBLAQIUAxQAAAAIAHwVo0TxEow0lgwA
AJApAAAVAAAAAAAAAAAAAACkgXBiEQBwaXAvdmNzL3N1YnZlcnNpb24ucHlQSwUGAAAAANkA2QAg
SQAAOW8RAAAA

"""

import base64
import os.path
import pkgutil
import shutil
import sys
import tempfile


def bootstrap(tmpdir=None):
    # Import pip so we can use it to install pip and maybe setuptools too
    import pip

    # We always want to install pip
    packages = ["pip"]

    # Check if the user has requested us not to install setuptools
    if "--no-setuptools" in sys.argv or os.environ.get("PIP_NO_SETUPTOOLS"):
        args = [x for x in sys.argv[1:] if x != "--no-setuptools"]
    else:
        args = sys.argv[1:]

        # We want to see if setuptools is available before attempting to
        # install it
        try:
            import setuptools  # noqa
        except ImportError:
            packages += ["setuptools"]

    delete_tmpdir = False
    try:
        # Create a temporary directory to act as a working directory if we were
        # not given one.
        if tmpdir is None:
            tmpdir = tempfile.mkdtemp()
            delete_tmpdir = True

        # We need to extract the SSL certificates from requests so that they
        # can be passed to --cert
        cert_path = os.path.join(tmpdir, "cacert.pem")
        with open(cert_path, "wb") as cert:
            cert.write(pkgutil.get_data("pip._vendor.requests", "cacert.pem"))

        # Use an environment variable here so that users can still pass
        # --cert via sys.argv
        os.environ.setdefault("PIP_CERT", cert_path)

        # Execute the included pip and use it to install the latest pip and
        # setuptools from PyPI
        sys.exit(pip.main(["install", "--upgrade"] + packages + args))
    finally:
        # Remove our temporary directory
        if delete_tmpdir and tmpdir:
            shutil.rmtree(tmpdir, ignore_errors=True)


def main():
    tmpdir = None
    try:
        # Create a temporary working directory
        tmpdir = tempfile.mkdtemp()

        # Unpack the zipfile into the temporary directory
        pip_zip = os.path.join(tmpdir, "pip.zip")
        with open(pip_zip, "wb") as fp:
            fp.write(base64.decodestring(ZIPFILE))

        # Add the zipfile to sys.path so that we can import it
        sys.path.insert(0, pip_zip)

        # Run the bootstrap
        bootstrap(tmpdir=tmpdir)
    finally:
        # Clean up our temporary working directory
        if tmpdir:
            shutil.rmtree(tmpdir, ignore_errors=True)


if __name__ == "__main__":
    main()

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# pip documentation build configuration file, created by
# sphinx-quickstart on Tue Apr 22 22:08:49 2008
#
# This file is execfile()d with the current directory set to its containing dir
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys

on_rtd = os.environ.get('READTHEDOCS', None) == 'True'

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath(os.pardir))
# sys.path.append(os.path.join(os.path.dirname(__file__), '../'))

# -- General configuration ----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
# extensions = ['sphinx.ext.autodoc']
extensions = ['sphinx.ext.extlinks', 'docs.pipext']

# Add any paths that contain templates here, relative to this directory.
templates_path = []

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
# source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = 'pip'
copyright = '2008-2014, PyPA'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
try:
    from pip import __version__
    # The short X.Y version.
    version = '.'.join(__version__.split('.')[:2])
    # The full version, including alpha/beta/rc tags.
    release = __version__
except ImportError:
    version = release = 'dev'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
# language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
# today = ''
# Else, today_fmt is used as the format for a strftime call.
today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
# unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['build']

# The reST default role (used for this markup: `text`) to use for all documents
# default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
# add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
# add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
# show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
# modindex_common_prefix = []

extlinks = {
    'issue': ('https://github.com/pypa/pip/issues/%s', '#'),
    'pull': ('https://github.com/pypa/pip/pull/%s', 'PR #'),
}

# -- Options for HTML output --------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'
if not on_rtd:
    try:
        import sphinx_rtd_theme
        html_theme = 'sphinx_rtd_theme'
        html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]
    except ImportError:
        pass

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
# html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
# html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
# html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
# html_logo = '_static/piplogo.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
# html_favicon = 'favicon.png'

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
# html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
# html_additional_pages = {}

# If false, no module index is generated.
html_use_modindex = False

# If false, no index is generated.
html_use_index = False

# If true, the index is split into individual pages for each letter.
# html_split_index = False

# If true, links to the reST sources are added to the pages.
html_show_sourcelink = False

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
# html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
# html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'pipdocs'


# -- Options for LaTeX output -------------------------------------------------

# The paper size ('letter' or 'a4').
# latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
# latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual])
latex_documents = [
    (
        'index',
        'pip.tex',
        u'pip Documentation',
        u'The pip developers',
        'manual',
    ),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
# latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
# latex_use_parts = False

# Additional stuff for the LaTeX preamble.
# latex_preamble = ''

# Documents to append as an appendix to all manuals.
# latex_appendices = []

# If false, no module index is generated.
# latex_use_modindex = True

########NEW FILE########
__FILENAME__ = pipext
"""pip sphinx extensions"""

import optparse
import sys
from docutils import nodes
from docutils.parsers import rst
from docutils.statemachine import ViewList
from textwrap import dedent
from pip import commands
from pip import cmdoptions
from pip.locations import default_log_file
from pip.util import get_prog


class PipCommandUsage(rst.Directive):
    required_arguments = 1

    def run(self):
        cmd = commands[self.arguments[0]]
        prog = '%s %s' % (get_prog(), cmd.name)
        usage = dedent(cmd.usage.replace('%prog', prog))
        node = nodes.literal_block(usage, usage)
        return [node]


class PipCommandDescription(rst.Directive):
    required_arguments = 1

    def run(self):
        node = nodes.paragraph()
        node.document = self.state.document
        desc = ViewList()
        description = dedent(commands[self.arguments[0]].__doc__)
        for line in description.split('\n'):
            desc.append(line, "")
        self.state.nested_parse(desc, 0, node)
        return [node]


class PipOptions(rst.Directive):

    def _format_option(self, option, cmd_name=None):
        if cmd_name:
            bookmark_line = ".. _`%s_%s`:" % (cmd_name, option._long_opts[0])
        else:
            bookmark_line = ".. _`%s`:" % option._long_opts[0]
        line = ".. option:: "
        if option._short_opts:
            line += option._short_opts[0]
        if option._short_opts and option._long_opts:
            line += ", %s" % option._long_opts[0]
        elif option._long_opts:
            line += option._long_opts[0]
        if option.takes_value():
            metavar = option.metavar or option.dest.lower()
            line += " <%s>" % metavar.lower()
        # fix defaults
        opt_help = option.help.replace('%default', str(option.default))
        # fix paths with sys.prefix
        opt_help = opt_help.replace(sys.prefix, "<sys.prefix>")
        opt_help = opt_help.replace(
            default_log_file,
            "<see :ref:`FileLogging`>",
        )
        return [bookmark_line, "", line, "", "    %s" % opt_help, ""]

    def _format_options(self, options, cmd_name=None):
        for option in options:
            if option.help == optparse.SUPPRESS_HELP:
                continue
            for line in self._format_option(option, cmd_name):
                self.view_list.append(line, "")

    def run(self):
        node = nodes.paragraph()
        node.document = self.state.document
        self.view_list = ViewList()
        self.process_options()
        self.state.nested_parse(self.view_list, 0, node)
        return [node]


class PipGeneralOptions(PipOptions):
    def process_options(self):
        self._format_options(
            [o.make() for o in cmdoptions.general_group['options']]
        )


class PipIndexOptions(PipOptions):
    def process_options(self):
        self._format_options(
            [o.make() for o in cmdoptions.index_group['options']]
        )


class PipCommandOptions(PipOptions):
    required_arguments = 1

    def process_options(self):
        cmd = commands[self.arguments[0]]()
        self._format_options(
            cmd.parser.option_groups[0].option_list,
            cmd_name=cmd.name,
        )


def setup(app):
    app.add_directive('pip-command-usage', PipCommandUsage)
    app.add_directive('pip-command-description', PipCommandDescription)
    app.add_directive('pip-command-options', PipCommandOptions)
    app.add_directive('pip-general-options', PipGeneralOptions)
    app.add_directive('pip-index-options', PipIndexOptions)

########NEW FILE########
__FILENAME__ = appdirs
"""
This code was taken from https://github.com/ActiveState/appdirs and modified
to suite our purposes.
"""
import os
import sys

from pip._vendor import six


def user_cache_dir(appname):
    r"""
    Return full path to the user-specific cache dir for this application.

        "appname" is the name of application.

    Typical user cache directories are:
        Mac OS X:   ~/Library/Caches/<AppName>
        Unix:       ~/.cache/<AppName> (XDG default)
        Windows:      C:\Users\<username>\AppData\Local\<AppName>\Cache

    On Windows the only suggestion in the MSDN docs is that local settings go
    in the `CSIDL_LOCAL_APPDATA` directory. This is identical to the
    non-roaming app data dir (the default returned by `user_data_dir`). Apps
    typically put cache data somewhere *under* the given dir here. Some
    examples:
        ...\Mozilla\Firefox\Profiles\<ProfileName>\Cache
        ...\Acme\SuperApp\Cache\1.0

    OPINION: This function appends "Cache" to the `CSIDL_LOCAL_APPDATA` value.
    """
    if sys.platform == "win32":
        # Get the base path
        path = os.path.normpath(_get_win_folder("CSIDL_LOCAL_APPDATA"))

        # Add our app name and Cache directory to it
        path = os.path.join(path, appname, "Cache")
    elif sys.platform == "darwin":
        # Get the base path
        path = os.path.expanduser("~/Library/Caches")

        # Add our app name to it
        path = os.path.join(path, appname)
    else:
        # Get the base path
        path = os.getenv("XDG_CACHE_HOME", os.path.expanduser("~/.cache"))

        # Add our app name to it
        path = os.path.join(path, appname)

    return path


# -- Windows support functions --

def _get_win_folder_from_registry(csidl_name):
    """
    This is a fallback technique at best. I'm not sure if using the
    registry for this guarantees us the correct answer for all CSIDL_*
    names.
    """
    import _winreg

    shell_folder_name = {
        "CSIDL_APPDATA": "AppData",
        "CSIDL_COMMON_APPDATA": "Common AppData",
        "CSIDL_LOCAL_APPDATA": "Local AppData",
    }[csidl_name]

    key = _winreg.OpenKey(
        _winreg.HKEY_CURRENT_USER,
        r"Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders"
    )
    directory, _type = _winreg.QueryValueEx(key, shell_folder_name)
    return directory


def _get_win_folder_with_pywin32(csidl_name):
    from win32com.shell import shellcon, shell
    directory = shell.SHGetFolderPath(0, getattr(shellcon, csidl_name), 0, 0)
    # Try to make this a unicode path because SHGetFolderPath does
    # not return unicode strings when there is unicode data in the
    # path.
    try:
        directory = six.text_type(directory)

        # Downgrade to short path name if have highbit chars. See
        # <http://bugs.activestate.com/show_bug.cgi?id=85099>.
        has_high_char = False
        for c in directory:
            if ord(c) > 255:
                has_high_char = True
                break
        if has_high_char:
            try:
                import win32api
                directory = win32api.GetShortPathName(directory)
            except ImportError:
                pass
    except UnicodeError:
        pass
    return directory


def _get_win_folder_with_ctypes(csidl_name):
    csidl_const = {
        "CSIDL_APPDATA": 26,
        "CSIDL_COMMON_APPDATA": 35,
        "CSIDL_LOCAL_APPDATA": 28,
    }[csidl_name]

    buf = ctypes.create_unicode_buffer(1024)
    ctypes.windll.shell32.SHGetFolderPathW(None, csidl_const, None, 0, buf)

    # Downgrade to short path name if have highbit chars. See
    # <http://bugs.activestate.com/show_bug.cgi?id=85099>.
    has_high_char = False
    for c in buf:
        if ord(c) > 255:
            has_high_char = True
            break
    if has_high_char:
        buf2 = ctypes.create_unicode_buffer(1024)
        if ctypes.windll.kernel32.GetShortPathNameW(buf.value, buf2, 1024):
            buf = buf2

    return buf.value

if sys.platform == "win32":
    try:
        import win32com.shell  # noqa
        _get_win_folder = _get_win_folder_with_pywin32
    except ImportError:
        try:
            import ctypes
            _get_win_folder = _get_win_folder_with_ctypes
        except ImportError:
            _get_win_folder = _get_win_folder_from_registry

########NEW FILE########
__FILENAME__ = basecommand
"""Base Command class, and related routines"""

import os
import sys
import tempfile
import traceback
import time
import optparse

from pip import cmdoptions
from pip.locations import running_under_virtualenv
from pip.log import logger
from pip.download import PipSession
from pip.exceptions import (BadCommand, InstallationError, UninstallationError,
                            CommandError, PreviousBuildDirError)
from pip.compat import StringIO
from pip.baseparser import ConfigOptionParser, UpdatingDefaultsHelpFormatter
from pip.status_codes import (
    SUCCESS, ERROR, UNKNOWN_ERROR, VIRTUALENV_NOT_FOUND,
    PREVIOUS_BUILD_DIR_ERROR,
)
from pip.util import get_prog, normalize_path


__all__ = ['Command']


class Command(object):
    name = None
    usage = None
    hidden = False

    def __init__(self):
        parser_kw = {
            'usage': self.usage,
            'prog': '%s %s' % (get_prog(), self.name),
            'formatter': UpdatingDefaultsHelpFormatter(),
            'add_help_option': False,
            'name': self.name,
            'description': self.__doc__,
        }

        self.parser = ConfigOptionParser(**parser_kw)

        # Commands should add options to this option group
        optgroup_name = '%s Options' % self.name.capitalize()
        self.cmd_opts = optparse.OptionGroup(self.parser, optgroup_name)

        # Add the general options
        gen_opts = cmdoptions.make_option_group(
            cmdoptions.general_group,
            self.parser,
        )
        self.parser.add_option_group(gen_opts)

    def _build_session(self, options):
        session = PipSession(
            cache=normalize_path(os.path.join(options.cache_dir, "http")),
            retries=options.retries,
        )

        # Handle custom ca-bundles from the user
        if options.cert:
            session.verify = options.cert
        elif options.no_check_certificate:
            session.verify = False

        # Handle SSL client certificate
        if options.client_cert:
            session.cert = options.client_cert

        # Handle timeouts
        if options.timeout:
            session.timeout = options.timeout

        # Handle configured proxies
        if options.proxy:
            session.proxies = {
                "http": options.proxy,
                "https": options.proxy,
            }

        # Determine if we can prompt the user for authentication or not
        session.auth.prompting = not options.no_input

        return session

    def setup_logging(self):
        pass

    def parse_args(self, args):
        # factored out for testability
        return self.parser.parse_args(args)

    def main(self, args):
        options, args = self.parse_args(args)

        level = 1  # Notify
        level += options.verbose
        level -= options.quiet
        level = logger.level_for_integer(4 - level)
        complete_log = []
        logger.add_consumers(
            (level, sys.stdout),
            (logger.DEBUG, complete_log.append),
        )
        if options.log_explicit_levels:
            logger.explicit_levels = True

        self.setup_logging()

        # TODO: try to get these passing down from the command?
        #      without resorting to os.environ to hold these.

        if options.no_input:
            os.environ['PIP_NO_INPUT'] = '1'

        if options.exists_action:
            os.environ['PIP_EXISTS_ACTION'] = ' '.join(options.exists_action)

        if options.require_venv:
            # If a venv is required check if it can really be found
            if not running_under_virtualenv():
                logger.fatal(
                    'Could not find an activated virtualenv (required).'
                )
                sys.exit(VIRTUALENV_NOT_FOUND)

        if options.log:
            log_fp = open_logfile(options.log, 'a')
            logger.add_consumers((logger.DEBUG, log_fp))
        else:
            log_fp = None

        exit = SUCCESS
        store_log = False
        try:
            status = self.run(options, args)
            # FIXME: all commands should return an exit status
            # and when it is done, isinstance is not needed anymore
            if isinstance(status, int):
                exit = status
        except PreviousBuildDirError as exc:
            logger.fatal(str(exc))
            logger.info('Exception information:\n%s' % format_exc())
            store_log = True
            exit = PREVIOUS_BUILD_DIR_ERROR
        except (InstallationError, UninstallationError) as exc:
            logger.fatal(str(exc))
            logger.info('Exception information:\n%s' % format_exc())
            store_log = True
            exit = ERROR
        except BadCommand as exc:
            logger.fatal(str(exc))
            logger.info('Exception information:\n%s' % format_exc())
            store_log = True
            exit = ERROR
        except CommandError as exc:
            logger.fatal('ERROR: %s' % exc)
            logger.info('Exception information:\n%s' % format_exc())
            exit = ERROR
        except KeyboardInterrupt:
            logger.fatal('Operation cancelled by user')
            logger.info('Exception information:\n%s' % format_exc())
            store_log = True
            exit = ERROR
        except:
            logger.fatal('Exception:\n%s' % format_exc())
            store_log = True
            exit = UNKNOWN_ERROR
        if store_log:
            log_file_fn = options.log_file
            text = '\n'.join(complete_log)
            try:
                log_file_fp = open_logfile(log_file_fn, 'w')
            except IOError:
                temp = tempfile.NamedTemporaryFile(delete=False)
                log_file_fn = temp.name
                log_file_fp = open_logfile(log_file_fn, 'w')
            logger.fatal('Storing debug log for failure in %s' % log_file_fn)
            log_file_fp.write(text)
            log_file_fp.close()
        if log_fp is not None:
            log_fp.close()
        return exit


def format_exc(exc_info=None):
    if exc_info is None:
        exc_info = sys.exc_info()
    out = StringIO()
    traceback.print_exception(*exc_info, **dict(file=out))
    return out.getvalue()


def open_logfile(filename, mode='a'):
    """Open the named log file in append mode.

    If the file already exists, a separator will also be printed to
    the file to separate past activity from current activity.
    """
    filename = os.path.expanduser(filename)
    filename = os.path.abspath(filename)
    dirname = os.path.dirname(filename)
    if not os.path.exists(dirname):
        os.makedirs(dirname)
    exists = os.path.exists(filename)

    log_fp = open(filename, mode)
    if exists:
        log_fp.write('%s\n' % ('-' * 60))
        log_fp.write('%s run on %s\n' % (sys.argv[0], time.strftime('%c')))
    return log_fp

########NEW FILE########
__FILENAME__ = baseparser
"""Base option parser setup"""

import sys
import optparse
import os
import textwrap
from distutils.util import strtobool

from pip.compat import ConfigParser, string_types
from pip.locations import (
    default_config_file, default_config_basename, running_under_virtualenv,
)
from pip.util import get_terminal_size


class PrettyHelpFormatter(optparse.IndentedHelpFormatter):
    """A prettier/less verbose help formatter for optparse."""

    def __init__(self, *args, **kwargs):
        # help position must be aligned with __init__.parseopts.description
        kwargs['max_help_position'] = 30
        kwargs['indent_increment'] = 1
        kwargs['width'] = get_terminal_size()[0] - 2
        optparse.IndentedHelpFormatter.__init__(self, *args, **kwargs)

    def format_option_strings(self, option):
        return self._format_option_strings(option, ' <%s>', ', ')

    def _format_option_strings(self, option, mvarfmt=' <%s>', optsep=', '):
        """
        Return a comma-separated list of option strings and metavars.

        :param option:  tuple of (short opt, long opt), e.g: ('-f', '--format')
        :param mvarfmt: metavar format string - evaluated as mvarfmt % metavar
        :param optsep:  separator
        """
        opts = []

        if option._short_opts:
            opts.append(option._short_opts[0])
        if option._long_opts:
            opts.append(option._long_opts[0])
        if len(opts) > 1:
            opts.insert(1, optsep)

        if option.takes_value():
            metavar = option.metavar or option.dest.lower()
            opts.append(mvarfmt % metavar.lower())

        return ''.join(opts)

    def format_heading(self, heading):
        if heading == 'Options':
            return ''
        return heading + ':\n'

    def format_usage(self, usage):
        """
        Ensure there is only one newline between usage and the first heading
        if there is no description.
        """
        msg = '\nUsage: %s\n' % self.indent_lines(textwrap.dedent(usage), "  ")
        return msg

    def format_description(self, description):
        # leave full control over description to us
        if description:
            if hasattr(self.parser, 'main'):
                label = 'Commands'
            else:
                label = 'Description'
            # some doc strings have initial newlines, some don't
            description = description.lstrip('\n')
            # some doc strings have final newlines and spaces, some don't
            description = description.rstrip()
            # dedent, then reindent
            description = self.indent_lines(textwrap.dedent(description), "  ")
            description = '%s:\n%s\n' % (label, description)
            return description
        else:
            return ''

    def format_epilog(self, epilog):
        # leave full control over epilog to us
        if epilog:
            return epilog
        else:
            return ''

    def indent_lines(self, text, indent):
        new_lines = [indent + line for line in text.split('\n')]
        return "\n".join(new_lines)


class UpdatingDefaultsHelpFormatter(PrettyHelpFormatter):
    """Custom help formatter for use in ConfigOptionParser that updates
    the defaults before expanding them, allowing them to show up correctly
    in the help listing"""

    def expand_default(self, option):
        if self.parser is not None:
            self.parser.update_defaults(self.parser.defaults)
        return optparse.IndentedHelpFormatter.expand_default(self, option)


class CustomOptionParser(optparse.OptionParser):
    def insert_option_group(self, idx, *args, **kwargs):
        """Insert an OptionGroup at a given position."""
        group = self.add_option_group(*args, **kwargs)

        self.option_groups.pop()
        self.option_groups.insert(idx, group)

        return group

    @property
    def option_list_all(self):
        """Get a list of all options, including those in option groups."""
        res = self.option_list[:]
        for i in self.option_groups:
            res.extend(i.option_list)

        return res


class ConfigOptionParser(CustomOptionParser):
    """Custom option parser which updates its defaults by checking the
    configuration files and environmental variables"""

    def __init__(self, *args, **kwargs):
        self.config = ConfigParser.RawConfigParser()
        self.name = kwargs.pop('name')
        self.files = self.get_config_files()
        if self.files:
            self.config.read(self.files)
        assert self.name
        optparse.OptionParser.__init__(self, *args, **kwargs)

    def get_config_files(self):
        config_file = os.environ.get('PIP_CONFIG_FILE', False)
        if config_file == os.devnull:
            return []
        if config_file and os.path.exists(config_file):
            files = [config_file]
        else:
            files = [default_config_file]
        if running_under_virtualenv():
            venv_config_file = os.path.join(
                sys.prefix,
                default_config_basename,
            )
            if os.path.exists(venv_config_file):
                files.append(venv_config_file)
        return files

    def check_default(self, option, key, val):
        try:
            return option.check_value(key, val)
        except optparse.OptionValueError as exc:
            print("An error occurred during configuration: %s" % exc)
            sys.exit(3)

    def update_defaults(self, defaults):
        """Updates the given defaults with values from the config files and
        the environ. Does a little special handling for certain types of
        options (lists)."""
        # Then go and look for the other sources of configuration:
        config = {}
        # 1. config files
        for section in ('global', self.name):
            config.update(
                self.normalize_keys(self.get_config_section(section))
            )
        # 2. environmental variables
        config.update(self.normalize_keys(self.get_environ_vars()))
        # Then set the options with those values
        for key, val in config.items():
            option = self.get_option(key)
            if option is not None:
                # ignore empty values
                if not val:
                    continue
                if option.action in ('store_true', 'store_false', 'count'):
                    val = strtobool(val)
                if option.action == 'append':
                    val = val.split()
                    val = [self.check_default(option, key, v) for v in val]
                else:
                    val = self.check_default(option, key, val)

                defaults[option.dest] = val
        return defaults

    def normalize_keys(self, items):
        """Return a config dictionary with normalized keys regardless of
        whether the keys were specified in environment variables or in config
        files"""
        normalized = {}
        for key, val in items:
            key = key.replace('_', '-')
            if not key.startswith('--'):
                key = '--%s' % key  # only prefer long opts
            normalized[key] = val
        return normalized

    def get_config_section(self, name):
        """Get a section of a configuration"""
        if self.config.has_section(name):
            return self.config.items(name)
        return []

    def get_environ_vars(self, prefix='PIP_'):
        """Returns a generator with all environmental vars with prefix PIP_"""
        for key, val in os.environ.items():
            if key.startswith(prefix):
                yield (key.replace(prefix, '').lower(), val)

    def get_default_values(self):
        """Overridding to make updating the defaults after instantiation of
        the option parser possible, update_defaults() does the dirty work."""
        if not self.process_default_values:
            # Old, pre-Optik 1.5 behaviour.
            return optparse.Values(self.defaults)

        defaults = self.update_defaults(self.defaults.copy())  # ours
        for option in self._get_all_options():
            default = defaults.get(option.dest)
            if isinstance(default, string_types):
                opt_str = option.get_opt_string()
                defaults[option.dest] = option.check_value(opt_str, default)
        return optparse.Values(defaults)

    def error(self, msg):
        self.print_usage(sys.stderr)
        self.exit(2, "%s\n" % msg)

########NEW FILE########
__FILENAME__ = cmdoptions
"""
shared options and groups

The principle here is to define options once, but *not* instantiate them
globally. One reason being that options with action='append' can carry state
between parses. pip parse's general options twice internally, and shouldn't
pass on state. To be consistent, all options will follow this design.

"""
import copy
from optparse import OptionGroup, SUPPRESS_HELP, Option
from pip.locations import (
    USER_CACHE_DIR, build_prefix, default_log_file, src_prefix,
)


def make_option_group(group, parser):
    """
    Return an OptionGroup object
    group  -- assumed to be dict with 'name' and 'options' keys
    parser -- an optparse Parser
    """
    option_group = OptionGroup(parser, group['name'])
    for option in group['options']:
        option_group.add_option(option.make())
    return option_group


class OptionMaker(object):
    """Class that stores the args/kwargs that would be used to make an Option,
    for making them later, and uses deepcopy's to reset state."""

    def __init__(self, *args, **kwargs):
        self.args = args
        self.kwargs = kwargs

    def make(self):
        args_copy = copy.deepcopy(self.args)
        kwargs_copy = copy.deepcopy(self.kwargs)
        return Option(*args_copy, **kwargs_copy)

###########
# options #
###########

help_ = OptionMaker(
    '-h', '--help',
    dest='help',
    action='help',
    help='Show help.')

require_virtualenv = OptionMaker(
    # Run only if inside a virtualenv, bail if not.
    '--require-virtualenv', '--require-venv',
    dest='require_venv',
    action='store_true',
    default=False,
    help=SUPPRESS_HELP)

verbose = OptionMaker(
    '-v', '--verbose',
    dest='verbose',
    action='count',
    default=0,
    help='Give more output. Option is additive, and can be used up to 3 times.'
)

version = OptionMaker(
    '-V', '--version',
    dest='version',
    action='store_true',
    help='Show version and exit.')

quiet = OptionMaker(
    '-q', '--quiet',
    dest='quiet',
    action='count',
    default=0,
    help='Give less output.')

log = OptionMaker(
    '--log',
    dest='log',
    metavar='path',
    help='Path to a verbose appending log. This log is inactive by default.')

log_explicit_levels = OptionMaker(
    # Writes the log levels explicitely to the log'
    '--log-explicit-levels',
    dest='log_explicit_levels',
    action='store_true',
    default=False,
    help=SUPPRESS_HELP)

log_file = OptionMaker(
    # The default log file
    '--log-file', '--local-log',
    dest='log_file',
    metavar='path',
    default=default_log_file,
    help='Path to a verbose non-appending log, that only logs failures. This '
         'log is active by default at %default.')

no_input = OptionMaker(
    # Don't ask for input
    '--no-input',
    dest='no_input',
    action='store_true',
    default=False,
    help=SUPPRESS_HELP)

proxy = OptionMaker(
    '--proxy',
    dest='proxy',
    type='str',
    default='',
    help="Specify a proxy in the form [user:passwd@]proxy.server:port.")

retries = OptionMaker(
    '--retries',
    dest='retries',
    type='int',
    default=3,
    help="Maximum number of retries each connection should attempt "
         "(default %default times).")

timeout = OptionMaker(
    '--timeout', '--default-timeout',
    metavar='sec',
    dest='timeout',
    type='float',
    default=15,
    help='Set the socket timeout (default %default seconds).')

default_vcs = OptionMaker(
    # The default version control system for editables, e.g. 'svn'
    '--default-vcs',
    dest='default_vcs',
    type='str',
    default='',
    help=SUPPRESS_HELP)

skip_requirements_regex = OptionMaker(
    # A regex to be used to skip requirements
    '--skip-requirements-regex',
    dest='skip_requirements_regex',
    type='str',
    default='',
    help=SUPPRESS_HELP)

exists_action = OptionMaker(
    # Option when path already exist
    '--exists-action',
    dest='exists_action',
    type='choice',
    choices=['s', 'i', 'w', 'b'],
    default=[],
    action='append',
    metavar='action',
    help="Default action when a path already exists: "
    "(s)witch, (i)gnore, (w)ipe, (b)ackup.")

cert = OptionMaker(
    '--cert',
    dest='cert',
    type='str',
    default='',
    metavar='path',
    help="Path to alternate CA bundle.")

client_cert = OptionMaker(
    '--client-cert',
    dest='client_cert',
    type='str',
    default=None,
    metavar='path',
    help="Path to SSL client certificate, a single file containing the "
         "private key and the certificate in PEM format.")

no_check_certificate = OptionMaker(
    "--no-check-certificate",
    dest="no_check_certificate",
    action="store_true",
    default=False,
    help="Don't validate SSL certificates.",
)

index_url = OptionMaker(
    '-i', '--index-url', '--pypi-url',
    dest='index_url',
    metavar='URL',
    default='https://pypi.python.org/simple/',
    help='Base URL of Python Package Index (default %default).')

extra_index_url = OptionMaker(
    '--extra-index-url',
    dest='extra_index_urls',
    metavar='URL',
    action='append',
    default=[],
    help='Extra URLs of package indexes to use in addition to --index-url.')

no_index = OptionMaker(
    '--no-index',
    dest='no_index',
    action='store_true',
    default=False,
    help='Ignore package index (only looking at --find-links URLs instead).')

find_links = OptionMaker(
    '-f', '--find-links',
    dest='find_links',
    action='append',
    default=[],
    metavar='url',
    help="If a url or path to an html file, then parse for links to archives. "
         "If a local path or file:// url that's a directory, then look for "
         "archives in the directory listing.")

# TODO: Remove after 1.6
use_mirrors = OptionMaker(
    '-M', '--use-mirrors',
    dest='use_mirrors',
    action='store_true',
    default=False,
    help=SUPPRESS_HELP)

# TODO: Remove after 1.6
mirrors = OptionMaker(
    '--mirrors',
    dest='mirrors',
    metavar='URL',
    action='append',
    default=[],
    help=SUPPRESS_HELP)

allow_external = OptionMaker(
    "--allow-external",
    dest="allow_external",
    action="append",
    default=[],
    metavar="PACKAGE",
    help="Allow the installation of externally hosted files",
)

allow_all_external = OptionMaker(
    "--allow-all-external",
    dest="allow_all_external",
    action="store_true",
    default=False,
    help="Allow the installation of all externally hosted files",
)

# Remove after 1.7
no_allow_external = OptionMaker(
    "--no-allow-external",
    dest="allow_all_external",
    action="store_false",
    default=False,
    help=SUPPRESS_HELP,
)

# Remove --allow-insecure after 1.7
allow_unsafe = OptionMaker(
    "--allow-unverified", "--allow-insecure",
    dest="allow_unverified",
    action="append",
    default=[],
    metavar="PACKAGE",
    help="Allow the installation of insecure and unverifiable files",
)

# Remove after 1.7
no_allow_unsafe = OptionMaker(
    "--no-allow-insecure",
    dest="allow_all_insecure",
    action="store_false",
    default=False,
    help=SUPPRESS_HELP
)

requirements = OptionMaker(
    '-r', '--requirement',
    dest='requirements',
    action='append',
    default=[],
    metavar='file',
    help='Install from the given requirements file. '
    'This option can be used multiple times.')

editable = OptionMaker(
    '-e', '--editable',
    dest='editables',
    action='append',
    default=[],
    metavar='path/url',
    help=('Install a project in editable mode (i.e. setuptools '
          '"develop mode") from a local project path or a VCS url.'),
)

src = OptionMaker(
    '--src', '--source', '--source-dir', '--source-directory',
    dest='src_dir',
    metavar='dir',
    default=src_prefix,
    help='Directory to check out editable projects into. '
    'The default in a virtualenv is "<venv path>/src". '
    'The default for global installs is "<current dir>/src".'
)

use_wheel = OptionMaker(
    '--use-wheel',
    dest='use_wheel',
    action='store_true',
    help=SUPPRESS_HELP,
)

no_use_wheel = OptionMaker(
    '--no-use-wheel',
    dest='use_wheel',
    action='store_false',
    default=True,
    help=('Do not Find and prefer wheel archives when searching indexes and '
          'find-links locations.'),
)

cache_dir = OptionMaker(
    "--cache-dir",
    dest="cache_dir",
    default=USER_CACHE_DIR,
    metavar="dir",
    help="Store the cache data in <dir>."
)

no_cache = OptionMaker(
    "--no-cache-dir",
    dest="cache_dir",
    action="store_false",
    help="Disable the cache.",
)

download_cache = OptionMaker(
    '--download-cache',
    dest='download_cache',
    default=None,
    help=SUPPRESS_HELP)

no_deps = OptionMaker(
    '--no-deps', '--no-dependencies',
    dest='ignore_dependencies',
    action='store_true',
    default=False,
    help="Don't install package dependencies.")

build_dir = OptionMaker(
    '-b', '--build', '--build-dir', '--build-directory',
    dest='build_dir',
    metavar='dir',
    default=build_prefix,
    help='Directory to unpack packages into and build in. '
    'The default in a virtualenv is "<venv path>/build". '
    'The default for global installs is "<OS temp dir>/pip_build_<username>".')

install_options = OptionMaker(
    '--install-option',
    dest='install_options',
    action='append',
    metavar='options',
    help="Extra arguments to be supplied to the setup.py install "
         "command (use like --install-option=\"--install-scripts=/usr/local/"
         "bin\"). Use multiple --install-option options to pass multiple "
         "options to setup.py install. If you are using an option with a "
         "directory path, be sure to use absolute path.")

global_options = OptionMaker(
    '--global-option',
    dest='global_options',
    action='append',
    metavar='options',
    help="Extra global options to be supplied to the setup.py "
         "call before the install command.")

no_clean = OptionMaker(
    '--no-clean',
    action='store_true',
    default=False,
    help="Don't clean up build directories.")


##########
# groups #
##########

general_group = {
    'name': 'General Options',
    'options': [
        help_,
        require_virtualenv,
        verbose,
        version,
        quiet,
        log_file,
        log,
        log_explicit_levels,
        no_input,
        proxy,
        retries,
        timeout,
        default_vcs,
        skip_requirements_regex,
        exists_action,
        cert,
        client_cert,
        no_check_certificate,
        cache_dir,
        no_cache,
    ]
}

index_group = {
    'name': 'Package Index Options',
    'options': [
        index_url,
        extra_index_url,
        no_index,
        find_links,
        use_mirrors,
        mirrors,
        allow_external,
        allow_all_external,
        no_allow_external,
        allow_unsafe,
        no_allow_unsafe,
    ]
}

########NEW FILE########
__FILENAME__ = completion
import sys
from pip.basecommand import Command

BASE_COMPLETION = """
# pip %(shell)s completion start%(script)s# pip %(shell)s completion end
"""

COMPLETION_SCRIPTS = {
    'bash': """
_pip_completion()
{
    COMPREPLY=( $( COMP_WORDS="${COMP_WORDS[*]}" \\
                   COMP_CWORD=$COMP_CWORD \\
                   PIP_AUTO_COMPLETE=1 $1 ) )
}
complete -o default -F _pip_completion pip
""", 'zsh': """
function _pip_completion {
  local words cword
  read -Ac words
  read -cn cword
  reply=( $( COMP_WORDS="$words[*]" \\
             COMP_CWORD=$(( cword-1 )) \\
             PIP_AUTO_COMPLETE=1 $words[1] ) )
}
compctl -K _pip_completion pip
"""}


class CompletionCommand(Command):
    """A helper command to be used for command completion."""
    name = 'completion'
    summary = 'A helper command to be used for command completion'
    hidden = True

    def __init__(self, *args, **kw):
        super(CompletionCommand, self).__init__(*args, **kw)

        cmd_opts = self.cmd_opts

        cmd_opts.add_option(
            '--bash', '-b',
            action='store_const',
            const='bash',
            dest='shell',
            help='Emit completion code for bash')
        cmd_opts.add_option(
            '--zsh', '-z',
            action='store_const',
            const='zsh',
            dest='shell',
            help='Emit completion code for zsh')

        self.parser.insert_option_group(0, cmd_opts)

    def run(self, options, args):
        """Prints the completion code of the given shell"""
        shells = COMPLETION_SCRIPTS.keys()
        shell_options = ['--' + shell for shell in sorted(shells)]
        if options.shell in shells:
            script = COMPLETION_SCRIPTS.get(options.shell, '')
            print(BASE_COMPLETION % {'script': script, 'shell': options.shell})
        else:
            sys.stderr.write(
                'ERROR: You must pass %s\n' % ' or '.join(shell_options)
            )

########NEW FILE########
__FILENAME__ = freeze
import re
import sys
import pip

from pip.compat import stdlib_pkgs
from pip.req import InstallRequirement
from pip.log import logger
from pip.basecommand import Command
from pip.util import get_installed_distributions

# packages to exclude from freeze output
freeze_excludes = stdlib_pkgs + ['setuptools', 'pip', 'distribute']


class FreezeCommand(Command):
    """
    Output installed packages in requirements format.

    packages are listed in a case-insensitive sorted order.
    """
    name = 'freeze'
    usage = """
      %prog [options]"""
    summary = 'Output installed packages in requirements format.'

    def __init__(self, *args, **kw):
        super(FreezeCommand, self).__init__(*args, **kw)

        self.cmd_opts.add_option(
            '-r', '--requirement',
            dest='requirement',
            action='store',
            default=None,
            metavar='file',
            help="Use the order in the given requirements file and its "
                 "comments when generating output.")
        self.cmd_opts.add_option(
            '-f', '--find-links',
            dest='find_links',
            action='append',
            default=[],
            metavar='URL',
            help='URL for finding packages, which will be added to the '
                 'output.')
        self.cmd_opts.add_option(
            '-l', '--local',
            dest='local',
            action='store_true',
            default=False,
            help='If in a virtualenv that has global access, do not output '
                 'globally-installed packages.')

        self.parser.insert_option_group(0, self.cmd_opts)

    def setup_logging(self):
        logger.move_stdout_to_stderr()

    def run(self, options, args):
        requirement = options.requirement
        find_links = options.find_links or []
        local_only = options.local
        # FIXME: Obviously this should be settable:
        find_tags = False
        skip_match = None

        skip_regex = options.skip_requirements_regex
        if skip_regex:
            skip_match = re.compile(skip_regex)

        f = sys.stdout

        for link in find_links:
            f.write('-f %s\n' % link)
        installations = {}
        for dist in get_installed_distributions(local_only=local_only,
                                                skip=freeze_excludes):
            req = pip.FrozenRequirement.from_dist(dist, find_tags=find_tags)
            installations[req.name] = req
        if requirement:
            req_f = open(requirement)
            for line in req_f:
                if not line.strip() or line.strip().startswith('#'):
                    f.write(line)
                    continue
                if skip_match and skip_match.search(line):
                    f.write(line)
                    continue
                elif line.startswith('-e') or line.startswith('--editable'):
                    if line.startswith('-e'):
                        line = line[2:].strip()
                    else:
                        line = line[len('--editable'):].strip().lstrip('=')
                    line_req = InstallRequirement.from_editable(
                        line,
                        default_vcs=options.default_vcs
                    )
                elif (line.startswith('-r')
                        or line.startswith('--requirement')
                        or line.startswith('-Z')
                        or line.startswith('--always-unzip')
                        or line.startswith('-f')
                        or line.startswith('-i')
                        or line.startswith('--extra-index-url')
                        or line.startswith('--find-links')
                        or line.startswith('--index-url')):
                    f.write(line)
                    continue
                else:
                    line_req = InstallRequirement.from_line(line)
                if not line_req.name:
                    logger.notify(
                        "Skipping line because it's not clear what it would "
                        "install: %s" % line.strip()
                    )
                    logger.notify(
                        "  (add #egg=PackageName to the URL to avoid"
                        " this warning)"
                    )
                    continue
                if line_req.name not in installations:
                    logger.warn(
                        "Requirement file contains %s, but that package is not"
                        " installed" % line.strip()
                    )
                    continue
                f.write(str(installations[line_req.name]))
                del installations[line_req.name]
            f.write(
                '## The following requirements were added by pip --freeze:\n'
            )
        for installation in sorted(
                installations.values(), key=lambda x: x.name.lower()):
            f.write(str(installation))

########NEW FILE########
__FILENAME__ = help
from pip.basecommand import Command, SUCCESS
from pip.exceptions import CommandError


class HelpCommand(Command):
    """Show help for commands"""
    name = 'help'
    usage = """
      %prog <command>"""
    summary = 'Show help for commands.'

    def run(self, options, args):
        from pip.commands import commands, get_similar_commands

        try:
            # 'pip help' with no args is handled by pip.__init__.parseopt()
            cmd_name = args[0]  # the command we need help for
        except IndexError:
            return SUCCESS

        if cmd_name not in commands:
            guess = get_similar_commands(cmd_name)

            msg = ['unknown command "%s"' % cmd_name]
            if guess:
                msg.append('maybe you meant "%s"' % guess)

            raise CommandError(' - '.join(msg))

        command = commands[cmd_name]()
        command.parser.print_help()

        return SUCCESS

########NEW FILE########
__FILENAME__ = install
import os
import tempfile
import shutil

from pip.req import InstallRequirement, RequirementSet, parse_requirements
from pip.log import logger
from pip.locations import (virtualenv_no_global, distutils_scheme,
                           build_prefix)
from pip.basecommand import Command
from pip.index import PackageFinder
from pip.exceptions import (
    InstallationError, CommandError, PreviousBuildDirError,
)
from pip import cmdoptions


class InstallCommand(Command):
    """
    Install packages from:

    - PyPI (and other indexes) using requirement specifiers.
    - VCS project urls.
    - Local project directories.
    - Local or remote source archives.

    pip also supports installing from "requirements files", which provide
    an easy way to specify a whole environment to be installed.
    """
    name = 'install'

    usage = """
      %prog [options] <requirement specifier> ...
      %prog [options] -r <requirements file> ...
      %prog [options] [-e] <vcs project url> ...
      %prog [options] [-e] <local project path> ...
      %prog [options] <archive url/path> ..."""

    summary = 'Install packages.'

    def __init__(self, *args, **kw):
        super(InstallCommand, self).__init__(*args, **kw)

        cmd_opts = self.cmd_opts

        cmd_opts.add_option(cmdoptions.editable.make())
        cmd_opts.add_option(cmdoptions.requirements.make())
        cmd_opts.add_option(cmdoptions.build_dir.make())

        cmd_opts.add_option(
            '-t', '--target',
            dest='target_dir',
            metavar='dir',
            default=None,
            help='Install packages into <dir>.')

        cmd_opts.add_option(
            '-d', '--download', '--download-dir', '--download-directory',
            dest='download_dir',
            metavar='dir',
            default=None,
            help=("Download packages into <dir> instead of installing them, "
                  "regardless of what's already installed."),
        )

        cmd_opts.add_option(cmdoptions.download_cache.make())
        cmd_opts.add_option(cmdoptions.src.make())

        cmd_opts.add_option(
            '-U', '--upgrade',
            dest='upgrade',
            action='store_true',
            help='Upgrade all packages to the newest available version. '
                 'This process is recursive regardless of whether a dependency'
                 ' is already satisfied.'
        )

        cmd_opts.add_option(
            '--force-reinstall',
            dest='force_reinstall',
            action='store_true',
            help='When upgrading, reinstall all packages even if they are '
                 'already up-to-date.')

        cmd_opts.add_option(
            '-I', '--ignore-installed',
            dest='ignore_installed',
            action='store_true',
            help='Ignore the installed packages (reinstalling instead).')

        cmd_opts.add_option(cmdoptions.no_deps.make())

        cmd_opts.add_option(
            '--no-install',
            dest='no_install',
            action='store_true',
            help="DEPRECATED. Download and unpack all packages, but don't "
                 "actually install them."
        )

        cmd_opts.add_option(
            '--no-download',
            dest='no_download',
            action="store_true",
            help="DEPRECATED. Don't download any packages, just install the "
                 "ones already downloaded (completes an install run with "
                 "--no-install).")

        cmd_opts.add_option(cmdoptions.install_options.make())
        cmd_opts.add_option(cmdoptions.global_options.make())

        cmd_opts.add_option(
            '--user',
            dest='use_user_site',
            action='store_true',
            help='Install using the user scheme.')

        cmd_opts.add_option(
            '--egg',
            dest='as_egg',
            action='store_true',
            help="Install packages as eggs, not 'flat', like pip normally "
                 "does. This option is not about installing *from* eggs. "
                 "(WARNING: Because this option overrides pip's normal install"
                 " logic, requirements files may not behave as expected.)")

        cmd_opts.add_option(
            '--root',
            dest='root_path',
            metavar='dir',
            default=None,
            help="Install everything relative to this alternate root "
                 "directory.")

        cmd_opts.add_option(
            "--compile",
            action="store_true",
            dest="compile",
            default=True,
            help="Compile py files to pyc",
        )

        cmd_opts.add_option(
            "--no-compile",
            action="store_false",
            dest="compile",
            help="Do not compile py files to pyc",
        )

        cmd_opts.add_option(cmdoptions.use_wheel.make())
        cmd_opts.add_option(cmdoptions.no_use_wheel.make())

        cmd_opts.add_option(
            '--pre',
            action='store_true',
            default=False,
            help="Include pre-release and development versions. By default, "
                 "pip only finds stable versions.")

        cmd_opts.add_option(cmdoptions.no_clean.make())

        index_opts = cmdoptions.make_option_group(
            cmdoptions.index_group,
            self.parser,
        )

        self.parser.insert_option_group(0, index_opts)
        self.parser.insert_option_group(0, cmd_opts)

    def _build_package_finder(self, options, index_urls, session):
        """
        Create a package finder appropriate to this install command.
        This method is meant to be overridden by subclasses, not
        called directly.
        """
        return PackageFinder(
            find_links=options.find_links,
            index_urls=index_urls,
            use_wheel=options.use_wheel,
            allow_external=options.allow_external,
            allow_unverified=options.allow_unverified,
            allow_all_external=options.allow_all_external,
            allow_all_prereleases=options.pre,
            session=session,
        )

    def run(self, options, args):

        if (
            options.no_install or
            options.no_download or
            (options.build_dir != build_prefix) or
            options.no_clean
        ):
            logger.deprecated(
                '1.7',
                'DEPRECATION: --no-install, --no-download, --build, '
                'and --no-clean are deprecated.  See '
                'https://github.com/pypa/pip/issues/906.',
            )

        if options.download_dir:
            options.no_install = True
            options.ignore_installed = True
        options.build_dir = os.path.abspath(options.build_dir)
        options.src_dir = os.path.abspath(options.src_dir)
        install_options = options.install_options or []
        if options.use_user_site:
            if virtualenv_no_global():
                raise InstallationError(
                    "Can not perform a '--user' install. User site-packages "
                    "are not visible in this virtualenv."
                )
            install_options.append('--user')

        temp_target_dir = None
        if options.target_dir:
            options.ignore_installed = True
            temp_target_dir = tempfile.mkdtemp()
            options.target_dir = os.path.abspath(options.target_dir)
            if (os.path.exists(options.target_dir)
                    and not os.path.isdir(options.target_dir)):
                raise CommandError(
                    "Target path exists but is not a directory, will not "
                    "continue."
                )
            install_options.append('--home=' + temp_target_dir)

        global_options = options.global_options or []
        index_urls = [options.index_url] + options.extra_index_urls
        if options.no_index:
            logger.notify('Ignoring indexes: %s' % ','.join(index_urls))
            index_urls = []

        if options.use_mirrors:
            logger.deprecated(
                "1.7",
                "--use-mirrors has been deprecated and will be removed"
                " in the future. Explicit uses of --index-url and/or "
                "--extra-index-url is suggested."
            )

        if options.mirrors:
            logger.deprecated(
                "1.7",
                "--mirrors has been deprecated and will be removed in "
                " the future. Explicit uses of --index-url and/or "
                "--extra-index-url is suggested."
            )
            index_urls += options.mirrors

        if options.download_cache:
            logger.deprecated(
                "1.8",
                "--download-cache has been deprecated and will be removed in "
                " the future. Pip now automatically uses and configures its "
                "cache."
            )

        session = self._build_session(options)

        finder = self._build_package_finder(options, index_urls, session)

        requirement_set = RequirementSet(
            build_dir=options.build_dir,
            src_dir=options.src_dir,
            download_dir=options.download_dir,
            upgrade=options.upgrade,
            as_egg=options.as_egg,
            ignore_installed=options.ignore_installed,
            ignore_dependencies=options.ignore_dependencies,
            force_reinstall=options.force_reinstall,
            use_user_site=options.use_user_site,
            target_dir=temp_target_dir,
            session=session,
            pycompile=options.compile,
        )
        for name in args:
            requirement_set.add_requirement(
                InstallRequirement.from_line(name, None))
        for name in options.editables:
            requirement_set.add_requirement(
                InstallRequirement.from_editable(
                    name,
                    default_vcs=options.default_vcs
                )
            )
        for filename in options.requirements:
            for req in parse_requirements(
                    filename, finder=finder, options=options, session=session):
                requirement_set.add_requirement(req)
        if not requirement_set.has_requirements:
            opts = {'name': self.name}
            if options.find_links:
                msg = ('You must give at least one requirement to %(name)s '
                       '(maybe you meant "pip %(name)s %(links)s"?)' %
                       dict(opts, links=' '.join(options.find_links)))
            else:
                msg = ('You must give at least one requirement '
                       'to %(name)s (see "pip help %(name)s")' % opts)
            logger.warn(msg)
            return

        try:
            if not options.no_download:
                requirement_set.prepare_files(finder)
            else:
                requirement_set.locate_files()

            if not options.no_install:
                requirement_set.install(
                    install_options,
                    global_options,
                    root=options.root_path,
                )
                installed = ' '.join([req.name for req in
                                      requirement_set.successfully_installed])
                if installed:
                    logger.notify('Successfully installed %s' % installed)
            else:
                downloaded = ' '.join([
                    req.name for req in requirement_set.successfully_downloaded
                ])
                if downloaded:
                    logger.notify('Successfully downloaded %s' % downloaded)
        except PreviousBuildDirError:
            options.no_clean = True
            raise
        finally:
            # Clean up
            if ((not options.no_clean)
                    and ((not options.no_install) or options.download_dir)):
                requirement_set.cleanup_files()

        if options.target_dir:
            if not os.path.exists(options.target_dir):
                os.makedirs(options.target_dir)
            lib_dir = distutils_scheme('', home=temp_target_dir)['purelib']
            for item in os.listdir(lib_dir):
                shutil.move(
                    os.path.join(lib_dir, item),
                    os.path.join(options.target_dir, item),
                )
            shutil.rmtree(temp_target_dir)
        return requirement_set

########NEW FILE########
__FILENAME__ = list
from pip.basecommand import Command
from pip.exceptions import DistributionNotFound, BestVersionAlreadyInstalled
from pip.index import PackageFinder
from pip.log import logger
from pip.req import InstallRequirement
from pip.util import get_installed_distributions, dist_is_editable
from pip.cmdoptions import make_option_group, index_group


class ListCommand(Command):
    """
    List installed packages, including editables.

    Packages are listed in a case-insensitive sorted order.
    """
    name = 'list'
    usage = """
      %prog [options]"""
    summary = 'List installed packages.'

    def __init__(self, *args, **kw):
        super(ListCommand, self).__init__(*args, **kw)

        cmd_opts = self.cmd_opts

        cmd_opts.add_option(
            '-o', '--outdated',
            action='store_true',
            default=False,
            help='List outdated packages (excluding editables)')
        cmd_opts.add_option(
            '-u', '--uptodate',
            action='store_true',
            default=False,
            help='List uptodate packages (excluding editables)')
        cmd_opts.add_option(
            '-e', '--editable',
            action='store_true',
            default=False,
            help='List editable projects.')
        cmd_opts.add_option(
            '-l', '--local',
            action='store_true',
            default=False,
            help=('If in a virtualenv that has global access, do not list '
                  'globally-installed packages.'),
        )

        cmd_opts.add_option(
            '--pre',
            action='store_true',
            default=False,
            help=("Include pre-release and development versions. By default, "
                  "pip only finds stable versions."),
        )

        index_opts = make_option_group(index_group, self.parser)

        self.parser.insert_option_group(0, index_opts)
        self.parser.insert_option_group(0, cmd_opts)

    def _build_package_finder(self, options, index_urls, session):
        """
        Create a package finder appropriate to this list command.
        """
        return PackageFinder(
            find_links=options.find_links,
            index_urls=index_urls,
            allow_external=options.allow_external,
            allow_unverified=options.allow_unverified,
            allow_all_external=options.allow_all_external,
            allow_all_prereleases=options.pre,
            session=session,
        )

    def run(self, options, args):
        if options.outdated:
            self.run_outdated(options)
        elif options.uptodate:
            self.run_uptodate(options)
        elif options.editable:
            self.run_editables(options)
        else:
            self.run_listing(options)

    def run_outdated(self, options):
        for dist, remote_version_raw, remote_version_parsed in \
                self.find_packages_latests_versions(options):
            if remote_version_parsed > dist.parsed_version:
                logger.notify(
                    '%s (Current: %s Latest: %s)' %
                    (dist.project_name, dist.version, remote_version_raw)
                )

    def find_packages_latests_versions(self, options):
        index_urls = [options.index_url] + options.extra_index_urls
        if options.no_index:
            logger.notify('Ignoring indexes: %s' % ','.join(index_urls))
            index_urls = []

        if options.use_mirrors:
            logger.deprecated(
                "1.7",
                "--use-mirrors has been deprecated and will be removed"
                " in the future. Explicit uses of --index-url and/or "
                "--extra-index-url is suggested."
            )

        if options.mirrors:
            logger.deprecated(
                "1.7",
                "--mirrors has been deprecated and will be removed in "
                " the future. Explicit uses of --index-url and/or "
                "--extra-index-url is suggested."
            )
            index_urls += options.mirrors

        session = self._build_session(options)

        finder = self._build_package_finder(options, index_urls, session)

        installed_packages = get_installed_distributions(
            local_only=options.local,
            include_editables=False,
        )
        for dist in installed_packages:
            req = InstallRequirement.from_line(dist.key, None)
            try:
                link = finder.find_requirement(req, True)

                # If link is None, means installed version is most up-to-date
                if link is None:
                    continue
            except DistributionNotFound:
                continue
            except BestVersionAlreadyInstalled:
                remote_version = req.installed_version
            else:
                # It might be a good idea that link or finder had a public
                # method that returned version
                remote_version = finder._link_package_versions(
                    link, req.name
                )[0]
                remote_version_raw = remote_version[2]
                remote_version_parsed = remote_version[0]
            yield dist, remote_version_raw, remote_version_parsed

    def run_listing(self, options):
        installed_packages = get_installed_distributions(
            local_only=options.local,
        )
        self.output_package_listing(installed_packages)

    def run_editables(self, options):
        installed_packages = get_installed_distributions(
            local_only=options.local,
            editables_only=True,
        )
        self.output_package_listing(installed_packages)

    def output_package_listing(self, installed_packages):
        installed_packages = sorted(
            installed_packages,
            key=lambda dist: dist.project_name.lower(),
        )
        for dist in installed_packages:
            if dist_is_editable(dist):
                line = '%s (%s, %s)' % (
                    dist.project_name,
                    dist.version,
                    dist.location,
                )
            else:
                line = '%s (%s)' % (dist.project_name, dist.version)
            logger.notify(line)

    def run_uptodate(self, options):
        uptodate = []
        for dist, remote_version_raw, remote_version_parsed in \
                self.find_packages_latests_versions(options):
            if dist.parsed_version == remote_version_parsed:
                uptodate.append(dist)
        self.output_package_listing(uptodate)

########NEW FILE########
__FILENAME__ = search
import sys
import textwrap

from pip.basecommand import Command, SUCCESS
from pip.util import get_terminal_size
from pip.log import logger
from pip.compat import xmlrpclib, reduce, cmp
from pip.exceptions import CommandError
from pip.status_codes import NO_MATCHES_FOUND
from pip._vendor import pkg_resources
from distutils.version import StrictVersion, LooseVersion


class SearchCommand(Command):
    """Search for PyPI packages whose name or summary contains <query>."""
    name = 'search'
    usage = """
      %prog [options] <query>"""
    summary = 'Search PyPI for packages.'

    def __init__(self, *args, **kw):
        super(SearchCommand, self).__init__(*args, **kw)
        self.cmd_opts.add_option(
            '--index',
            dest='index',
            metavar='URL',
            default='https://pypi.python.org/pypi',
            help='Base URL of Python Package Index (default %default)')

        self.parser.insert_option_group(0, self.cmd_opts)

    def run(self, options, args):
        if not args:
            raise CommandError('Missing required argument (search query).')
        query = args
        index_url = options.index

        pypi_hits = self.search(query, index_url)
        hits = transform_hits(pypi_hits)

        terminal_width = None
        if sys.stdout.isatty():
            terminal_width = get_terminal_size()[0]

        print_results(hits, terminal_width=terminal_width)
        if pypi_hits:
            return SUCCESS
        return NO_MATCHES_FOUND

    def search(self, query, index_url):
        pypi = xmlrpclib.ServerProxy(index_url)
        hits = pypi.search({'name': query, 'summary': query}, 'or')
        return hits


def transform_hits(hits):
    """
    The list from pypi is really a list of versions. We want a list of
    packages with the list of versions stored inline. This converts the
    list from pypi into one we can use.
    """
    packages = {}
    for hit in hits:
        name = hit['name']
        summary = hit['summary']
        version = hit['version']
        score = hit['_pypi_ordering']
        if score is None:
            score = 0

        if name not in packages.keys():
            packages[name] = {
                'name': name,
                'summary': summary,
                'versions': [version],
                'score': score,
            }
        else:
            packages[name]['versions'].append(version)

            # if this is the highest version, replace summary and score
            if version == highest_version(packages[name]['versions']):
                packages[name]['summary'] = summary
                packages[name]['score'] = score

    # each record has a unique name now, so we will convert the dict into a
    # list sorted by score
    package_list = sorted(
        packages.values(),
        key=lambda x: x['score'],
        reverse=True,
    )
    return package_list


def print_results(hits, name_column_width=25, terminal_width=None):
    installed_packages = [p.project_name for p in pkg_resources.working_set]
    for hit in hits:
        name = hit['name']
        summary = hit['summary'] or ''
        if terminal_width is not None:
            # wrap and indent summary to fit terminal
            summary = textwrap.wrap(
                summary,
                terminal_width - name_column_width - 5,
            )
            summary = ('\n' + ' ' * (name_column_width + 3)).join(summary)
        line = '%s - %s' % (name.ljust(name_column_width), summary)
        try:
            logger.notify(line)
            if name in installed_packages:
                dist = pkg_resources.get_distribution(name)
                logger.indent += 2
                try:
                    latest = highest_version(hit['versions'])
                    if dist.version == latest:
                        logger.notify('INSTALLED: %s (latest)' % dist.version)
                    else:
                        logger.notify('INSTALLED: %s' % dist.version)
                        logger.notify('LATEST:    %s' % latest)
                finally:
                    logger.indent -= 2
        except UnicodeEncodeError:
            pass


def compare_versions(version1, version2):
    try:
        return cmp(StrictVersion(version1), StrictVersion(version2))
    # in case of abnormal version number, fall back to LooseVersion
    except ValueError:
        pass
    try:
        return cmp(LooseVersion(version1), LooseVersion(version2))
    except TypeError:
        # certain LooseVersion comparions raise due to unorderable types,
        # fallback to string comparison
        return cmp([str(v) for v in LooseVersion(version1).version],
                   [str(v) for v in LooseVersion(version2).version])


def highest_version(versions):
    return reduce(
        (lambda v1, v2: compare_versions(v1, v2) == 1 and v1 or v2),
        versions,
    )

########NEW FILE########
__FILENAME__ = show
import os

from pip.basecommand import Command
from pip.log import logger
from pip._vendor import pkg_resources


class ShowCommand(Command):
    """Show information about one or more installed packages."""
    name = 'show'
    usage = """
      %prog [options] <package> ..."""
    summary = 'Show information about installed packages.'

    def __init__(self, *args, **kw):
        super(ShowCommand, self).__init__(*args, **kw)
        self.cmd_opts.add_option(
            '-f', '--files',
            dest='files',
            action='store_true',
            default=False,
            help='Show the full list of installed files for each package.')

        self.parser.insert_option_group(0, self.cmd_opts)

    def run(self, options, args):
        if not args:
            logger.warn('ERROR: Please provide a package name or names.')
            return
        query = args

        results = search_packages_info(query)
        print_results(results, options.files)


def search_packages_info(query):
    """
    Gather details from installed distributions. Print distribution name,
    version, location, and installed files. Installed files requires a
    pip generated 'installed-files.txt' in the distributions '.egg-info'
    directory.
    """
    installed = dict(
        [(p.project_name.lower(), p) for p in pkg_resources.working_set])
    query_names = [name.lower() for name in query]
    for dist in [installed[pkg] for pkg in query_names if pkg in installed]:
        package = {
            'name': dist.project_name,
            'version': dist.version,
            'location': dist.location,
            'requires': [dep.project_name for dep in dist.requires()],
        }
        file_list = None
        if isinstance(dist, pkg_resources.DistInfoDistribution):
            # RECORDs should be part of .dist-info metadatas
            if dist.has_metadata('RECORD'):
                lines = dist.get_metadata_lines('RECORD')
                paths = [l.split(',')[0] for l in lines]
                paths = [os.path.join(dist.location, p) for p in paths]
                file_list = [os.path.relpath(p, dist.egg_info)
                             for p in paths]
        else:
            # Otherwise use pip's log for .egg-info's
            if dist.has_metadata('installed-files.txt'):
                file_list = dist.get_metadata_lines('installed-files.txt')
        # use and short-circuit to check for None
        package['files'] = file_list and sorted(file_list)
        yield package


def print_results(distributions, list_all_files):
    """
    Print the informations from installed distributions found.
    """
    for dist in distributions:
        logger.notify("---")
        logger.notify("Name: %s" % dist['name'])
        logger.notify("Version: %s" % dist['version'])
        logger.notify("Location: %s" % dist['location'])
        logger.notify("Requires: %s" % ', '.join(dist['requires']))
        if list_all_files:
            logger.notify("Files:")
            if dist['files'] is not None:
                for line in dist['files']:
                    logger.notify("  %s" % line.strip())
            else:
                logger.notify("Cannot locate installed-files.txt")

########NEW FILE########
__FILENAME__ = uninstall
from pip.req import InstallRequirement, RequirementSet, parse_requirements
from pip.basecommand import Command
from pip.exceptions import InstallationError


class UninstallCommand(Command):
    """
    Uninstall packages.

    pip is able to uninstall most installed packages. Known exceptions are:

    - Pure distutils packages installed with ``python setup.py install``, which
      leave behind no metadata to determine what files were installed.
    - Script wrappers installed by ``python setup.py develop``.
    """
    name = 'uninstall'
    usage = """
      %prog [options] <package> ...
      %prog [options] -r <requirements file> ..."""
    summary = 'Uninstall packages.'

    def __init__(self, *args, **kw):
        super(UninstallCommand, self).__init__(*args, **kw)
        self.cmd_opts.add_option(
            '-r', '--requirement',
            dest='requirements',
            action='append',
            default=[],
            metavar='file',
            help='Uninstall all the packages listed in the given requirements '
                 'file.  This option can be used multiple times.',
        )
        self.cmd_opts.add_option(
            '-y', '--yes',
            dest='yes',
            action='store_true',
            help="Don't ask for confirmation of uninstall deletions.")

        self.parser.insert_option_group(0, self.cmd_opts)

    def run(self, options, args):
        session = self._build_session(options)

        requirement_set = RequirementSet(
            build_dir=None,
            src_dir=None,
            download_dir=None,
            session=session,
        )
        for name in args:
            requirement_set.add_requirement(
                InstallRequirement.from_line(name))
        for filename in options.requirements:
            for req in parse_requirements(
                    filename,
                    options=options,
                    session=session):
                requirement_set.add_requirement(req)
        if not requirement_set.has_requirements:
            raise InstallationError(
                'You must give at least one requirement to %(name)s (see "pip '
                'help %(name)s")' % dict(name=self.name)
            )
        requirement_set.uninstall(auto_confirm=options.yes)

########NEW FILE########
__FILENAME__ = unzip
from pip.commands.zip import ZipCommand


class UnzipCommand(ZipCommand):
    """Unzip individual packages."""
    name = 'unzip'
    summary = 'DEPRECATED. Unzip individual packages.'

########NEW FILE########
__FILENAME__ = wheel
# -*- coding: utf-8 -*-
from __future__ import absolute_import

import os

from pip.basecommand import Command
from pip.index import PackageFinder
from pip.log import logger
from pip.exceptions import CommandError, PreviousBuildDirError
from pip.req import InstallRequirement, RequirementSet, parse_requirements
from pip.util import normalize_path
from pip.wheel import WheelBuilder
from pip import cmdoptions

DEFAULT_WHEEL_DIR = os.path.join(normalize_path(os.curdir), 'wheelhouse')


class WheelCommand(Command):
    """
    Build Wheel archives for your requirements and dependencies.

    Wheel is a built-package format, and offers the advantage of not
    recompiling your software during every install. For more details, see the
    wheel docs: http://wheel.readthedocs.org/en/latest.

    Requirements: setuptools>=0.8, and wheel.

    'pip wheel' uses the bdist_wheel setuptools extension from the wheel
    package to build individual wheels.

    """

    name = 'wheel'
    usage = """
      %prog [options] <requirement specifier> ...
      %prog [options] -r <requirements file> ...
      %prog [options] [-e] <vcs project url> ...
      %prog [options] [-e] <local project path> ...
      %prog [options] <archive url/path> ..."""

    summary = 'Build wheels from your requirements.'

    def __init__(self, *args, **kw):
        super(WheelCommand, self).__init__(*args, **kw)

        cmd_opts = self.cmd_opts

        cmd_opts.add_option(
            '-w', '--wheel-dir',
            dest='wheel_dir',
            metavar='dir',
            default=DEFAULT_WHEEL_DIR,
            help=("Build wheels into <dir>, where the default is "
                  "'<cwd>/wheelhouse'."),
        )
        cmd_opts.add_option(cmdoptions.use_wheel.make())
        cmd_opts.add_option(cmdoptions.no_use_wheel.make())
        cmd_opts.add_option(
            '--build-option',
            dest='build_options',
            metavar='options',
            action='append',
            help="Extra arguments to be supplied to 'setup.py bdist_wheel'.")
        cmd_opts.add_option(cmdoptions.editable.make())
        cmd_opts.add_option(cmdoptions.requirements.make())
        cmd_opts.add_option(cmdoptions.download_cache.make())
        cmd_opts.add_option(cmdoptions.src.make())
        cmd_opts.add_option(cmdoptions.no_deps.make())
        cmd_opts.add_option(cmdoptions.build_dir.make())

        cmd_opts.add_option(
            '--global-option',
            dest='global_options',
            action='append',
            metavar='options',
            help="Extra global options to be supplied to the setup.py "
            "call before the 'bdist_wheel' command.")

        cmd_opts.add_option(
            '--pre',
            action='store_true',
            default=False,
            help=("Include pre-release and development versions. By default, "
                  "pip only finds stable versions."),
        )

        cmd_opts.add_option(cmdoptions.no_clean.make())

        index_opts = cmdoptions.make_option_group(
            cmdoptions.index_group,
            self.parser,
        )

        self.parser.insert_option_group(0, index_opts)
        self.parser.insert_option_group(0, cmd_opts)

    def run(self, options, args):

        # confirm requirements
        try:
            import wheel.bdist_wheel
            # Hack to make flake8 not complain about an unused import
            wheel.bdist_wheel
        except ImportError:
            raise CommandError(
                "'pip wheel' requires the 'wheel' package. To fix this, run: "
                "pip install wheel"
            )

        try:
            import pkg_resources
        except ImportError:
            raise CommandError(
                "'pip wheel' requires setuptools >= 0.8 for dist-info support."
                " To fix this, run: pip install --upgrade setuptools"
            )
        else:
            if not hasattr(pkg_resources, 'DistInfoDistribution'):
                raise CommandError(
                    "'pip wheel' requires setuptools >= 0.8 for dist-info "
                    "support. To fix this, run: pip install --upgrade "
                    "setuptools"
                )

        index_urls = [options.index_url] + options.extra_index_urls
        if options.no_index:
            logger.notify('Ignoring indexes: %s' % ','.join(index_urls))
            index_urls = []

        if options.use_mirrors:
            logger.deprecated(
                "1.7",
                "--use-mirrors has been deprecated and will be removed"
                " in the future. Explicit uses of --index-url and/or "
                "--extra-index-url is suggested."
            )

        if options.mirrors:
            logger.deprecated(
                "1.7",
                "--mirrors has been deprecated and will be removed in "
                " the future. Explicit uses of --index-url and/or "
                "--extra-index-url is suggested."
            )
            index_urls += options.mirrors

        if options.download_cache:
            logger.deprecated(
                "1.8",
                "--download-cache has been deprecated and will be removed in "
                " the future. Pip now automatically uses and configures its "
                "cache."
            )

        session = self._build_session(options)

        finder = PackageFinder(
            find_links=options.find_links,
            index_urls=index_urls,
            use_wheel=options.use_wheel,
            allow_external=options.allow_external,
            allow_unverified=options.allow_unverified,
            allow_all_external=options.allow_all_external,
            allow_all_prereleases=options.pre,
            session=session,
        )

        options.build_dir = os.path.abspath(options.build_dir)
        requirement_set = RequirementSet(
            build_dir=options.build_dir,
            src_dir=options.src_dir,
            download_dir=None,
            ignore_dependencies=options.ignore_dependencies,
            ignore_installed=True,
            session=session,
            wheel_download_dir=options.wheel_dir
        )

        # make the wheelhouse
        if not os.path.exists(options.wheel_dir):
            os.makedirs(options.wheel_dir)

        # parse args and/or requirements files
        for name in args:
            requirement_set.add_requirement(
                InstallRequirement.from_line(name, None))
        for name in options.editables:
            requirement_set.add_requirement(
                InstallRequirement.from_editable(
                    name,
                    default_vcs=options.default_vcs
                )
            )
        for filename in options.requirements:
            for req in parse_requirements(
                    filename,
                    finder=finder,
                    options=options,
                    session=session):
                requirement_set.add_requirement(req)

        # fail if no requirements
        if not requirement_set.has_requirements:
            opts = {'name': self.name}
            msg = ('You must give at least one requirement '
                   'to %(name)s (see "pip help %(name)s")' % opts)
            logger.error(msg)
            return

        try:
            # build wheels
            wb = WheelBuilder(
                requirement_set,
                finder,
                options.wheel_dir,
                build_options=options.build_options or [],
                global_options=options.global_options or [],
            )
            if not wb.build():
                raise CommandError("Failed to build one or more wheels")
        except PreviousBuildDirError:
            options.no_clean = True
            raise
        finally:
            if not options.no_clean:
                requirement_set.cleanup_files()

########NEW FILE########
__FILENAME__ = zip
import sys
import re
import fnmatch
import os
import shutil
import zipfile
from pip.util import display_path, backup_dir, rmtree
from pip.log import logger
from pip.exceptions import InstallationError
from pip.basecommand import Command


class ZipCommand(Command):
    """Zip individual packages."""
    name = 'zip'
    usage = """
     %prog [options] <package> ..."""
    summary = 'DEPRECATED. Zip individual packages.'

    def __init__(self, *args, **kw):
        super(ZipCommand, self).__init__(*args, **kw)
        if self.name == 'zip':
            self.cmd_opts.add_option(
                '--unzip',
                action='store_true',
                dest='unzip',
                help='Unzip (rather than zip) a package.')
        else:
            self.cmd_opts.add_option(
                '--zip',
                action='store_false',
                dest='unzip',
                default=True,
                help='Zip (rather than unzip) a package.')
        self.cmd_opts.add_option(
            '--no-pyc',
            action='store_true',
            dest='no_pyc',
            help=(
                'Do not include .pyc files in zip files (useful on Google App '
                'Engine).'),
        )
        self.cmd_opts.add_option(
            '-l', '--list',
            action='store_true',
            dest='list',
            help='List the packages available, and their zip status.')
        self.cmd_opts.add_option(
            '--sort-files',
            action='store_true',
            dest='sort_files',
            help=('With --list, sort packages according to how many files they'
                  ' contain.'),
        )
        self.cmd_opts.add_option(
            '--path',
            action='append',
            dest='paths',
            help=('Restrict operations to the given paths (may include '
                  'wildcards).'),
        )
        self.cmd_opts.add_option(
            '-n', '--simulate',
            action='store_true',
            help='Do not actually perform the zip/unzip operation.')

        self.parser.insert_option_group(0, self.cmd_opts)

    def paths(self):
        """All the entries of sys.path, possibly restricted by --path"""
        if not self.select_paths:
            return sys.path
        result = []
        match_any = set()
        for path in sys.path:
            path = os.path.normcase(os.path.abspath(path))
            for match in self.select_paths:
                match = os.path.normcase(os.path.abspath(match))
                if '*' in match:
                    if re.search(fnmatch.translate(match + '*'), path):
                        result.append(path)
                        match_any.add(match)
                        break
                else:
                    if path.startswith(match):
                        result.append(path)
                        match_any.add(match)
                        break
            else:
                logger.debug("Skipping path %s because it doesn't match %s"
                             % (path, ', '.join(self.select_paths)))
        for match in self.select_paths:
            if match not in match_any and '*' not in match:
                result.append(match)
                logger.debug("Adding path %s because it doesn't match "
                             "anything already on sys.path" % match)
        return result

    def run(self, options, args):

        logger.deprecated(
            '1.7',
            "DEPRECATION: 'pip zip' and 'pip unzip` are deprecated, and will "
            "be removed in a future release."
        )

        self.select_paths = options.paths
        self.simulate = options.simulate
        if options.list:
            return self.list(options, args)
        if not args:
            raise InstallationError(
                'You must give at least one package to zip or unzip')
        packages = []
        for arg in args:
            module_name, filename = self.find_package(arg)
            if options.unzip and os.path.isdir(filename):
                raise InstallationError(
                    'The module %s (in %s) is not a zip file; cannot be '
                    'unzipped' % (module_name, filename)
                )
            elif not options.unzip and not os.path.isdir(filename):
                raise InstallationError(
                    'The module %s (in %s) is not a directory; cannot be '
                    'zipped' % (module_name, filename)
                )
            packages.append((module_name, filename))
        last_status = None
        for module_name, filename in packages:
            if options.unzip:
                last_status = self.unzip_package(module_name, filename)
            else:
                last_status = self.zip_package(
                    module_name, filename, options.no_pyc
                )
        return last_status

    def unzip_package(self, module_name, filename):
        zip_filename = os.path.dirname(filename)
        if (not os.path.isfile(zip_filename)
                and zipfile.is_zipfile(zip_filename)):
            raise InstallationError(
                'Module %s (in %s) isn\'t located in a zip file in %s'
                % (module_name, filename, zip_filename))
        package_path = os.path.dirname(zip_filename)
        if package_path not in self.paths():
            logger.warn(
                'Unpacking %s into %s, but %s is not on sys.path'
                % (display_path(zip_filename), display_path(package_path),
                   display_path(package_path)))
        logger.notify(
            'Unzipping %s (in %s)' % (module_name, display_path(zip_filename))
        )
        if self.simulate:
            logger.notify(
                'Skipping remaining operations because of --simulate'
            )
            return
        logger.indent += 2
        try:
            # FIXME: this should be undoable:
            zip = zipfile.ZipFile(zip_filename)
            to_save = []
            for info in zip.infolist():
                name = info.filename
                if name.startswith(module_name + os.path.sep):
                    content = zip.read(name)
                    dest = os.path.join(package_path, name)
                    if not os.path.exists(os.path.dirname(dest)):
                        os.makedirs(os.path.dirname(dest))
                    if not content and dest.endswith(os.path.sep):
                        if not os.path.exists(dest):
                            os.makedirs(dest)
                    else:
                        f = open(dest, 'wb')
                        f.write(content)
                        f.close()
                else:
                    to_save.append((name, zip.read(name)))
            zip.close()
            if not to_save:
                logger.info(
                    'Removing now-empty zip file %s' %
                    display_path(zip_filename)
                )
                os.unlink(zip_filename)
                self.remove_filename_from_pth(zip_filename)
            else:
                logger.info(
                    'Removing entries in %s/ from zip file %s' %
                    (module_name, display_path(zip_filename))
                )
                zip = zipfile.ZipFile(zip_filename, 'w')
                for name, content in to_save:
                    zip.writestr(name, content)
                zip.close()
        finally:
            logger.indent -= 2

    def zip_package(self, module_name, filename, no_pyc):
        orig_filename = filename
        logger.notify('Zip %s (in %s)' % (module_name, display_path(filename)))
        logger.indent += 2
        if filename.endswith('.egg'):
            dest_filename = filename
        else:
            dest_filename = filename + '.zip'
        try:
            # FIXME: I think this needs to be undoable:
            if filename == dest_filename:
                filename = backup_dir(orig_filename)
                logger.notify(
                    'Moving %s aside to %s' % (orig_filename, filename)
                )
                if not self.simulate:
                    shutil.move(orig_filename, filename)
            try:
                logger.info(
                    'Creating zip file in %s' % display_path(dest_filename)
                )
                if not self.simulate:
                    zip = zipfile.ZipFile(dest_filename, 'w')
                    zip.writestr(module_name + '/', '')
                    for dirpath, dirnames, filenames in os.walk(filename):
                        if no_pyc:
                            filenames = [f for f in filenames
                                         if not f.lower().endswith('.pyc')]
                        for fns, is_dir in [
                                (dirnames, True), (filenames, False)]:
                            for fn in fns:
                                full = os.path.join(dirpath, fn)
                                dest = os.path.join(
                                    module_name,
                                    dirpath[len(filename):].lstrip(
                                        os.path.sep
                                    ),
                                    fn,
                                )
                                if is_dir:
                                    zip.writestr(dest + '/', '')
                                else:
                                    zip.write(full, dest)
                    zip.close()
                logger.info(
                    'Removing old directory %s' % display_path(filename)
                )
                if not self.simulate:
                    rmtree(filename)
            except:
                # FIXME: need to do an undo here
                raise
            # FIXME: should also be undone:
            self.add_filename_to_pth(dest_filename)
        finally:
            logger.indent -= 2

    def remove_filename_from_pth(self, filename):
        for pth in self.pth_files():
            f = open(pth, 'r')
            lines = f.readlines()
            f.close()
            new_lines = [
                l for l in lines if l.strip() != filename]
            if lines != new_lines:
                logger.info('Removing reference to %s from .pth file %s'
                            % (display_path(filename), display_path(pth)))
                if not [line for line in new_lines if line]:
                    logger.info(
                        '%s file would be empty: deleting' % display_path(pth)
                    )
                    if not self.simulate:
                        os.unlink(pth)
                else:
                    if not self.simulate:
                        f = open(pth, 'wb')
                        f.writelines(new_lines)
                        f.close()
                return
        logger.warn(
            'Cannot find a reference to %s in any .pth file' %
            display_path(filename)
        )

    def add_filename_to_pth(self, filename):
        path = os.path.dirname(filename)
        dest = filename + '.pth'
        if path not in self.paths():
            logger.warn(
                'Adding .pth file %s, but it is not on sys.path' %
                display_path(dest)
            )
        if not self.simulate:
            if os.path.exists(dest):
                f = open(dest)
                lines = f.readlines()
                f.close()
                if lines and not lines[-1].endswith('\n'):
                    lines[-1] += '\n'
                lines.append(filename + '\n')
            else:
                lines = [filename + '\n']
            f = open(dest, 'wb')
            f.writelines(lines)
            f.close()

    def pth_files(self):
        for path in self.paths():
            if not os.path.exists(path) or not os.path.isdir(path):
                continue
            for filename in os.listdir(path):
                if filename.endswith('.pth'):
                    yield os.path.join(path, filename)

    def find_package(self, package):
        for path in self.paths():
            full = os.path.join(path, package)
            if os.path.exists(full):
                return package, full
            if not os.path.isdir(path) and zipfile.is_zipfile(path):
                zip = zipfile.ZipFile(path, 'r')
                try:
                    zip.read(os.path.join(package, '__init__.py'))
                except KeyError:
                    pass
                else:
                    zip.close()
                    return package, full
                zip.close()
        # FIXME: need special error for package.py case:
        raise InstallationError(
            'No package with the name %s found' % package)

    def list(self, options, args):
        if args:
            raise InstallationError(
                'You cannot give an argument with --list')
        for path in sorted(self.paths()):
            if not os.path.exists(path):
                continue
            basename = os.path.basename(path.rstrip(os.path.sep))
            if os.path.isfile(path) and zipfile.is_zipfile(path):
                if os.path.dirname(path) not in self.paths():
                    logger.notify('Zipped egg: %s' % display_path(path))
                continue
            if (basename != 'site-packages'
                    and basename != 'dist-packages'
                    and not path.replace('\\', '/').endswith('lib/python')):
                continue
            logger.notify('In %s:' % display_path(path))
            logger.indent += 2
            zipped = []
            unzipped = []
            try:
                for filename in sorted(os.listdir(path)):
                    ext = os.path.splitext(filename)[1].lower()
                    if ext in ('.pth', '.egg-info', '.egg-link'):
                        continue
                    if ext == '.py':
                        logger.info(
                            'Not displaying %s: not a package' %
                            display_path(filename)
                        )
                        continue
                    full = os.path.join(path, filename)
                    if os.path.isdir(full):
                        unzipped.append((filename, self.count_package(full)))
                    elif zipfile.is_zipfile(full):
                        zipped.append(filename)
                    else:
                        logger.info(
                            'Unknown file: %s' % display_path(filename)
                        )
                if zipped:
                    logger.notify('Zipped packages:')
                    logger.indent += 2
                    try:
                        for filename in zipped:
                            logger.notify(filename)
                    finally:
                        logger.indent -= 2
                else:
                    logger.notify('No zipped packages.')
                if unzipped:
                    if options.sort_files:
                        unzipped.sort(key=lambda x: -x[1])
                    logger.notify('Unzipped packages:')
                    logger.indent += 2
                    try:
                        for filename, count in unzipped:
                            logger.notify('%s  (%i files)' % (filename, count))
                    finally:
                        logger.indent -= 2
                else:
                    logger.notify('No unzipped packages.')
            finally:
                logger.indent -= 2

    def count_package(self, path):
        total = 0
        for dirpath, dirnames, filenames in os.walk(path):
            filenames = [f for f in filenames
                         if not f.lower().endswith('.pyc')]
            total += len(filenames)
        return total

########NEW FILE########
__FILENAME__ = compat
"""Stuff that differs in different Python versions and platform
distributions."""

# flake8: noqa

import os
import imp
import sys
import site

__all__ = ['WindowsError']

uses_pycache = hasattr(imp, 'cache_from_source')


class NeverUsedException(Exception):
    """this exception should never be raised"""

try:
    WindowsError = WindowsError
except NameError:
    WindowsError = NeverUsedException

try:
    #new in Python 3.3
    PermissionError = PermissionError
except NameError:
    PermissionError = NeverUsedException

console_encoding = sys.__stdout__.encoding


try:
    unicode

    def binary(s):
        if isinstance(s, unicode):
            return s.encode('ascii')
        return s
except NameError:
    def binary(s):
        if isinstance(s, str):
            return s.encode('ascii')


if sys.version_info >= (3,):
    from io import StringIO, BytesIO
    from functools import reduce
    from urllib.error import URLError, HTTPError
    from queue import Queue, Empty
    from urllib.request import url2pathname, urlretrieve, pathname2url
    from email import message as emailmessage
    import urllib.parse as urllib
    import urllib.request as urllib2
    import configparser as ConfigParser
    import xmlrpc.client as xmlrpclib
    import urllib.parse as urlparse
    import http.client as httplib

    def cmp(a, b):
        return (a > b) - (a < b)

    def b(s):
        return s.encode('utf-8')

    def u(s):
        return s.decode('utf-8')

    def console_to_str(s):
        try:
            return s.decode(console_encoding)
        except UnicodeDecodeError:
            return s.decode('utf_8')

    def get_http_message_param(http_message, param, default_value):
        return http_message.get_param(param, default_value)

    bytes = bytes
    string_types = (str,)
    raw_input = input
else:
    from cStringIO import StringIO
    from urllib2 import URLError, HTTPError
    from Queue import Queue, Empty
    from urllib import url2pathname, urlretrieve, pathname2url
    from email import Message as emailmessage
    import urllib
    import urllib2
    import urlparse
    import ConfigParser
    import xmlrpclib
    import httplib

    def b(s):
        return s

    def u(s):
        return s

    def console_to_str(s):
        return s

    def get_http_message_param(http_message, param, default_value):
        result = http_message.getparam(param)
        return result or default_value

    bytes = str
    string_types = (basestring,)
    reduce = reduce
    cmp = cmp
    raw_input = raw_input
    BytesIO = StringIO


def get_path_uid(path):
    """
    Return path's uid.

    Does not follow symlinks:
        https://github.com/pypa/pip/pull/935#discussion_r5307003

    Placed this function in compat due to differences on AIX and
    Jython, that should eventually go away.

    :raises OSError: When path is a symlink or can't be read.
    """
    if hasattr(os, 'O_NOFOLLOW'):
        fd = os.open(path, os.O_RDONLY | os.O_NOFOLLOW)
        file_uid = os.fstat(fd).st_uid
        os.close(fd)
    else:  # AIX and Jython
        # WARNING: time of check vulnerabity, but best we can do w/o NOFOLLOW
        if not os.path.islink(path):
            # older versions of Jython don't have `os.fstat`
            file_uid = os.stat(path).st_uid
        else:
            # raise OSError for parity with os.O_NOFOLLOW above
            raise OSError(
                "%s is a symlink; Will not return uid for symlinks" % path
            )
    return file_uid


# packages in the stdlib that may have installation metadata, but should not be
# considered 'installed'.  this theoretically could be determined based on
# dist.location (py27:`sysconfig.get_paths()['stdlib']`,
# py26:sysconfig.get_config_vars('LIBDEST')), but fear platform variation may
# make this ineffective, so hard-coding
stdlib_pkgs = ['python', 'wsgiref']
if sys.version_info >= (2, 7):
    stdlib_pkgs.extend(['argparse'])

########NEW FILE########
__FILENAME__ = download
import cgi
import email.utils
import hashlib
import getpass
import mimetypes
import os
import platform
import re
import shutil
import sys
import tempfile

import pip

from pip.compat import urllib, urlparse, raw_input
from pip.exceptions import InstallationError, HashMismatch
from pip.util import (splitext, rmtree, format_size, display_path,
                      backup_dir, ask_path_exists, unpack_file)
from pip.vcs import vcs
from pip.log import logger
from pip._vendor import requests, six
from pip._vendor.requests.adapters import BaseAdapter, HTTPAdapter
from pip._vendor.requests.auth import AuthBase, HTTPBasicAuth
from pip._vendor.requests.compat import IncompleteRead
from pip._vendor.requests.exceptions import ChunkedEncodingError
from pip._vendor.requests.models import Response
from pip._vendor.requests.structures import CaseInsensitiveDict
from pip._vendor.cachecontrol import CacheControlAdapter
from pip._vendor.cachecontrol.caches import FileCache
from pip._vendor.lockfile import LockError


__all__ = ['get_file_content',
           'is_url', 'url_to_path', 'path_to_url',
           'is_archive_file', 'unpack_vcs_link',
           'unpack_file_url', 'is_vcs_url', 'is_file_url', 'unpack_http_url']


def user_agent():
    """Return a string representing the user agent."""
    _implementation = platform.python_implementation()

    if _implementation == 'CPython':
        _implementation_version = platform.python_version()
    elif _implementation == 'PyPy':
        _implementation_version = '%s.%s.%s' % (sys.pypy_version_info.major,
                                                sys.pypy_version_info.minor,
                                                sys.pypy_version_info.micro)
        if sys.pypy_version_info.releaselevel != 'final':
            _implementation_version = ''.join([
                _implementation_version,
                sys.pypy_version_info.releaselevel,
            ])
    elif _implementation == 'Jython':
        _implementation_version = platform.python_version()  # Complete Guess
    elif _implementation == 'IronPython':
        _implementation_version = platform.python_version()  # Complete Guess
    else:
        _implementation_version = 'Unknown'

    try:
        p_system = platform.system()
        p_release = platform.release()
    except IOError:
        p_system = 'Unknown'
        p_release = 'Unknown'

    return " ".join(['pip/%s' % pip.__version__,
                     '%s/%s' % (_implementation, _implementation_version),
                     '%s/%s' % (p_system, p_release)])


class MultiDomainBasicAuth(AuthBase):

    def __init__(self, prompting=True):
        self.prompting = prompting
        self.passwords = {}

    def __call__(self, req):
        parsed = urlparse.urlparse(req.url)

        # Get the netloc without any embedded credentials
        netloc = parsed.netloc.rsplit("@", 1)[-1]

        # Set the url of the request to the url without any credentials
        req.url = urlparse.urlunparse(parsed[:1] + (netloc,) + parsed[2:])

        # Use any stored credentials that we have for this netloc
        username, password = self.passwords.get(netloc, (None, None))

        # Extract credentials embedded in the url if we have none stored
        if username is None:
            username, password = self.parse_credentials(parsed.netloc)

        if username or password:
            # Store the username and password
            self.passwords[netloc] = (username, password)

            # Send the basic auth with this request
            req = HTTPBasicAuth(username or "", password or "")(req)

        # Attach a hook to handle 401 responses
        req.register_hook("response", self.handle_401)

        return req

    def handle_401(self, resp, **kwargs):
        # We only care about 401 responses, anything else we want to just
        #   pass through the actual response
        if resp.status_code != 401:
            return resp

        # We are not able to prompt the user so simple return the response
        if not self.prompting:
            return resp

        parsed = urlparse.urlparse(resp.url)

        # Prompt the user for a new username and password
        username = raw_input("User for %s: " % parsed.netloc)
        password = getpass.getpass("Password: ")

        # Store the new username and password to use for future requests
        if username or password:
            self.passwords[parsed.netloc] = (username, password)

        # Consume content and release the original connection to allow our new
        #   request to reuse the same one.
        resp.content
        resp.raw.release_conn()

        # Add our new username and password to the request
        req = HTTPBasicAuth(username or "", password or "")(resp.request)

        # Send our new request
        new_resp = resp.connection.send(req, **kwargs)
        new_resp.history.append(resp)

        return new_resp

    def parse_credentials(self, netloc):
        if "@" in netloc:
            userinfo = netloc.rsplit("@", 1)[0]
            if ":" in userinfo:
                return userinfo.split(":", 1)
            return userinfo, None
        return None, None


class LocalFSAdapter(BaseAdapter):

    def send(self, request, stream=None, timeout=None, verify=None, cert=None,
             proxies=None):
        pathname = url_to_path(request.url)

        resp = Response()
        resp.status_code = 200
        resp.url = request.url

        try:
            stats = os.stat(pathname)
        except OSError as exc:
            resp.status_code = 404
            resp.raw = exc
        else:
            modified = email.utils.formatdate(stats.st_mtime, usegmt=True)
            content_type = mimetypes.guess_type(pathname)[0] or "text/plain"
            resp.headers = CaseInsensitiveDict({
                "Content-Type": content_type,
                "Content-Length": stats.st_size,
                "Last-Modified": modified,
            })

            resp.raw = open(pathname, "rb")
            resp.close = resp.raw.close

        return resp

    def close(self):
        pass


class SafeFileCache(FileCache):
    """
    A file based cache which is safe to use even when the target directory may
    not be accessible or writable.
    """

    def get(self, *args, **kwargs):
        try:
            return super(SafeFileCache, self).get(*args, **kwargs)
        except (LockError, OSError, IOError):
            # We intentionally silence this error, if we can't access the cache
            # then we can just skip caching and process the request as if
            # caching wasn't enabled.
            pass

    def set(self, *args, **kwargs):
        try:
            return super(SafeFileCache, self).set(*args, **kwargs)
        except (LockError, OSError, IOError):
            # We intentionally silence this error, if we can't access the cache
            # then we can just skip caching and process the request as if
            # caching wasn't enabled.
            pass

    def delete(self, *args, **kwargs):
        try:
            return super(SafeFileCache, self).delete(*args, **kwargs)
        except (LockError, OSError, IOError):
            # We intentionally silence this error, if we can't access the cache
            # then we can just skip caching and process the request as if
            # caching wasn't enabled.
            pass


class PipSession(requests.Session):

    timeout = None

    def __init__(self, *args, **kwargs):
        retries = kwargs.pop("retries", 0)
        cache = kwargs.pop("cache", None)

        super(PipSession, self).__init__(*args, **kwargs)

        # Attach our User Agent to the request
        self.headers["User-Agent"] = user_agent()

        # Attach our Authentication handler to the session
        self.auth = MultiDomainBasicAuth()

        if cache:
            http_adapter = CacheControlAdapter(
                cache=SafeFileCache(cache),
                max_retries=retries,
            )
        else:
            http_adapter = HTTPAdapter(max_retries=retries)

        self.mount("http://", http_adapter)
        self.mount("https://", http_adapter)

        # Enable file:// urls
        self.mount("file://", LocalFSAdapter())

    def request(self, method, url, *args, **kwargs):
        # Allow setting a default timeout on a session
        kwargs.setdefault("timeout", self.timeout)

        # Dispatch the actual request
        return super(PipSession, self).request(method, url, *args, **kwargs)


def get_file_content(url, comes_from=None, session=None):
    """Gets the content of a file; it may be a filename, file: URL, or
    http: URL.  Returns (location, content).  Content is unicode."""
    if session is None:
        raise TypeError(
            "get_file_content() missing 1 required keyword argument: 'session'"
        )

    match = _scheme_re.search(url)
    if match:
        scheme = match.group(1).lower()
        if (scheme == 'file' and comes_from
                and comes_from.startswith('http')):
            raise InstallationError(
                'Requirements file %s references URL %s, which is local'
                % (comes_from, url))
        if scheme == 'file':
            path = url.split(':', 1)[1]
            path = path.replace('\\', '/')
            match = _url_slash_drive_re.match(path)
            if match:
                path = match.group(1) + ':' + path.split('|', 1)[1]
            path = urllib.unquote(path)
            if path.startswith('/'):
                path = '/' + path.lstrip('/')
            url = path
        else:
            # FIXME: catch some errors
            resp = session.get(url)
            resp.raise_for_status()

            if six.PY3:
                return resp.url, resp.text
            else:
                return resp.url, resp.content
    try:
        f = open(url)
        content = f.read()
    except IOError as exc:
        raise InstallationError(
            'Could not open requirements file: %s' % str(exc)
        )
    else:
        f.close()
    return url, content


_scheme_re = re.compile(r'^(http|https|file):', re.I)
_url_slash_drive_re = re.compile(r'/*([a-z])\|', re.I)


def is_url(name):
    """Returns true if the name looks like a URL"""
    if ':' not in name:
        return False
    scheme = name.split(':', 1)[0].lower()
    return scheme in ['http', 'https', 'file', 'ftp'] + vcs.all_schemes


def url_to_path(url):
    """
    Convert a file: URL to a path.
    """
    assert url.startswith('file:'), (
        "You can only turn file: urls into filenames (not %r)" % url)
    path = url[len('file:'):].lstrip('/')
    path = urllib.unquote(path)
    if _url_drive_re.match(path):
        path = path[0] + ':' + path[2:]
    else:
        path = '/' + path
    return path


_drive_re = re.compile('^([a-z]):', re.I)
_url_drive_re = re.compile('^([a-z])[:|]', re.I)


def path_to_url(path):
    """
    Convert a path to a file: URL.  The path will be made absolute and have
    quoted path parts.
    """
    path = os.path.normpath(os.path.abspath(path))
    drive, path = os.path.splitdrive(path)
    filepath = path.split(os.path.sep)
    url = '/'.join([urllib.quote(part) for part in filepath])
    if not drive:
        url = url.lstrip('/')
    return 'file:///' + drive + url


def is_archive_file(name):
    """Return True if `name` is a considered as an archive file."""
    archives = (
        '.zip', '.tar.gz', '.tar.bz2', '.tgz', '.tar', '.whl'
    )
    ext = splitext(name)[1].lower()
    if ext in archives:
        return True
    return False


def unpack_vcs_link(link, location, only_download=False):
    vcs_backend = _get_used_vcs_backend(link)
    if only_download:
        vcs_backend.export(location)
    else:
        vcs_backend.unpack(location)


def _get_used_vcs_backend(link):
    for backend in vcs.backends:
        if link.scheme in backend.schemes:
            vcs_backend = backend(link.url)
            return vcs_backend


def is_vcs_url(link):
    return bool(_get_used_vcs_backend(link))


def is_file_url(link):
    return link.url.lower().startswith('file:')


def _check_hash(download_hash, link):
    if download_hash.digest_size != hashlib.new(link.hash_name).digest_size:
        logger.fatal(
            "Hash digest size of the package %d (%s) doesn't match the "
            "expected hash name %s!" %
            (download_hash.digest_size, link, link.hash_name)
        )
        raise HashMismatch('Hash name mismatch for package %s' % link)
    if download_hash.hexdigest() != link.hash:
        logger.fatal(
            "Hash of the package %s (%s) doesn't match the expected hash %s!" %
            (link, download_hash.hexdigest(), link.hash)
        )
        raise HashMismatch(
            'Bad %s hash for package %s' % (link.hash_name, link)
        )


def _get_hash_from_file(target_file, link):
    try:
        download_hash = hashlib.new(link.hash_name)
    except (ValueError, TypeError):
        logger.warn(
            "Unsupported hash name %s for package %s" % (link.hash_name, link)
        )
        return None

    fp = open(target_file, 'rb')
    while True:
        chunk = fp.read(4096)
        if not chunk:
            break
        download_hash.update(chunk)
    fp.close()
    return download_hash


def _download_url(resp, link, temp_location):
    fp = open(temp_location, 'wb')
    download_hash = None
    if link.hash and link.hash_name:
        try:
            download_hash = hashlib.new(link.hash_name)
        except ValueError:
            logger.warn(
                "Unsupported hash name %s for package %s" %
                (link.hash_name, link)
            )

    try:
        total_length = int(resp.headers['content-length'])
    except (ValueError, KeyError, TypeError):
        total_length = 0
    downloaded = 0
    show_progress = total_length > 40 * 1000 or not total_length
    show_url = link.show_url
    try:
        if show_progress:
            # FIXME: the URL can get really long in this message:
            if total_length:
                logger.start_progress(
                    'Downloading %s (%s): ' %
                    (show_url, format_size(total_length))
                )
            else:
                logger.start_progress(
                    'Downloading %s (unknown size): ' % show_url
                )
        else:
            logger.notify('Downloading %s' % show_url)
        logger.info('Downloading from URL %s' % link)

        def resp_read(chunk_size):
            try:
                # Special case for urllib3.
                try:
                    for chunk in resp.raw.stream(
                            chunk_size,
                            # We use decode_content=False here because we do
                            # want urllib3 to mess with the raw bytes we get
                            # from the server. If we decompress inside of
                            # urllib3 then we cannot verify the checksum
                            # because the checksum will be of the compressed
                            # file. This breakage will only occur if the
                            # server adds a Content-Encoding header, which
                            # depends on how the server was configured:
                            # - Some servers will notice that the file isn't a
                            #   compressible file and will leave the file alone
                            #   and with an empty Content-Encoding
                            # - Some servers will notice that the file is
                            #   already compressed and will leave the file
                            #   alone and will add a Content-Encoding: gzip
                            #   header
                            # - Some servers won't notice anything at all and
                            #   will take a file that's already been compressed
                            #   and compress it again and set the
                            #   Content-Encoding: gzip header
                            #
                            # By setting this not to decode automatically we
                            # hope to eliminate problems with the second case.
                            decode_content=False):
                        yield chunk
                except IncompleteRead as e:
                    raise ChunkedEncodingError(e)
            except AttributeError:
                # Standard file-like object.
                while True:
                    chunk = resp.raw.read(chunk_size)
                    if not chunk:
                        break
                    yield chunk

        for chunk in resp_read(4096):
            downloaded += len(chunk)
            if show_progress:
                if not total_length:
                    logger.show_progress('%s' % format_size(downloaded))
                else:
                    logger.show_progress(
                        '%3i%%  %s' %
                        (
                            100 * downloaded / total_length,
                            format_size(downloaded)
                        )
                    )
            if download_hash is not None:
                download_hash.update(chunk)
            fp.write(chunk)
        fp.close()
    finally:
        if show_progress:
            logger.end_progress('%s downloaded' % format_size(downloaded))
    return download_hash


def _copy_file(filename, location, content_type, link):
    copy = True
    download_location = os.path.join(location, link.filename)
    if os.path.exists(download_location):
        response = ask_path_exists(
            'The file %s exists. (i)gnore, (w)ipe, (b)ackup ' %
            display_path(download_location), ('i', 'w', 'b'))
        if response == 'i':
            copy = False
        elif response == 'w':
            logger.warn('Deleting %s' % display_path(download_location))
            os.remove(download_location)
        elif response == 'b':
            dest_file = backup_dir(download_location)
            logger.warn(
                'Backing up %s to %s' %
                (display_path(download_location), display_path(dest_file))
            )
            shutil.move(download_location, dest_file)
    if copy:
        shutil.copy(filename, download_location)
        logger.notify('Saved %s' % display_path(download_location))


def unpack_http_url(link, location, download_dir=None, session=None):
    if session is None:
        raise TypeError(
            "unpack_http_url() missing 1 required keyword argument: 'session'"
        )

    temp_dir = tempfile.mkdtemp('-unpack', 'pip-')
    temp_location = None
    target_url = link.url.split('#', 1)[0]

    download_hash = None

    # If a download dir is specified, is the file already downloaded there?
    already_downloaded = None
    if download_dir:
        already_downloaded = os.path.join(download_dir, link.filename)
        if not os.path.exists(already_downloaded):
            already_downloaded = None

    # If already downloaded, does its hash match?
    if already_downloaded:
        temp_location = already_downloaded
        content_type = mimetypes.guess_type(already_downloaded)[0]
        logger.notify('File was already downloaded %s' % already_downloaded)
        if link.hash:
            download_hash = _get_hash_from_file(temp_location, link)
            try:
                _check_hash(download_hash, link)
            except HashMismatch:
                logger.warn(
                    'Previously-downloaded file %s has bad hash, '
                    're-downloading.' % temp_location
                )
                temp_location = None
                os.unlink(already_downloaded)
                already_downloaded = None

    # let's download to a tmp dir
    if not temp_location:
        try:
            resp = session.get(
                target_url,
                # We use Accept-Encoding: identity here because requests
                # defaults to accepting compressed responses. This breaks in
                # a variety of ways depending on how the server is configured.
                # - Some servers will notice that the file isn't a compressible
                #   file and will leave the file alone and with an empty
                #   Content-Encoding
                # - Some servers will notice that the file is already
                #   compressed and will leave the file alone and will add a
                #   Content-Encoding: gzip header
                # - Some servers won't notice anything at all and will take
                #   a file that's already been compressed and compress it again
                #   and set the Content-Encoding: gzip header
                # By setting this to request only the identity encoding We're
                # hoping to eliminate the third case. Hopefully there does not
                # exist a server which when given a file will notice it is
                # already compressed and that you're not asking for a
                # compressed file and will then decompress it before sending
                # because if that's the case I don't think it'll ever be
                # possible to make this work.
                headers={"Accept-Encoding": "identity"},
                stream=True,
            )
            resp.raise_for_status()
        except requests.HTTPError as exc:
            logger.fatal("HTTP error %s while getting %s" %
                         (exc.response.status_code, link))
            raise

        content_type = resp.headers.get('content-type', '')
        filename = link.filename  # fallback
        # Have a look at the Content-Disposition header for a better guess
        content_disposition = resp.headers.get('content-disposition')
        if content_disposition:
            type, params = cgi.parse_header(content_disposition)
            # We use ``or`` here because we don't want to use an "empty" value
            # from the filename param.
            filename = params.get('filename') or filename
        ext = splitext(filename)[1]
        if not ext:
            ext = mimetypes.guess_extension(content_type)
            if ext:
                filename += ext
        if not ext and link.url != resp.url:
            ext = os.path.splitext(resp.url)[1]
            if ext:
                filename += ext
        temp_location = os.path.join(temp_dir, filename)
        download_hash = _download_url(resp, link, temp_location)
        if link.hash and link.hash_name:
            _check_hash(download_hash, link)

    # a download dir is specified; let's copy the archive there
    if download_dir and not already_downloaded:
        _copy_file(temp_location, download_dir, content_type, link)

    # unpack the archive to the build dir location. even when only downloading
    # archives, they have to be unpacked to parse dependencies
    unpack_file(temp_location, location, content_type, link)

    if not already_downloaded:
        os.unlink(temp_location)

    os.rmdir(temp_dir)


def unpack_file_url(link, location, download_dir=None):

    link_path = url_to_path(link.url_without_fragment)
    already_downloaded = False

    # If it's a url to a local directory
    if os.path.isdir(link_path):
        if os.path.isdir(location):
            rmtree(location)
        shutil.copytree(link_path, location, symlinks=True)
        return

    # if link has a hash, let's confirm it matches
    if link.hash:
        link_path_hash = _get_hash_from_file(link_path, link)
        _check_hash(link_path_hash, link)

    # If a download dir is specified, is the file already there and valid?
    if download_dir:
        download_path = os.path.join(download_dir, link.filename)
        if os.path.exists(download_path):
            content_type = mimetypes.guess_type(download_path)[0]
            logger.notify('File was already downloaded %s' % download_path)
            if link.hash:
                download_hash = _get_hash_from_file(download_path, link)
                try:
                    _check_hash(download_hash, link)
                    already_downloaded = True
                except HashMismatch:
                    logger.warn(
                        'Previously-downloaded file %s has bad hash, '
                        're-downloading.' % link_path
                    )
                    os.unlink(download_path)
            else:
                already_downloaded = True

    if already_downloaded:
        from_path = download_path
    else:
        from_path = link_path

    content_type = mimetypes.guess_type(from_path)[0]

    # unpack the archive to the build dir location. even when only downloading
    # archives, they have to be unpacked to parse dependencies
    unpack_file(from_path, location, content_type, link)

    # a download dir is specified and not already downloaded
    if download_dir and not already_downloaded:
        _copy_file(from_path, download_dir, content_type, link)

########NEW FILE########
__FILENAME__ = exceptions
"""Exceptions used throughout package"""


class PipError(Exception):
    """Base pip exception"""


class InstallationError(PipError):
    """General exception during installation"""


class UninstallationError(PipError):
    """General exception during uninstallation"""


class DistributionNotFound(InstallationError):
    """Raised when a distribution cannot be found to satisfy a requirement"""


class BestVersionAlreadyInstalled(PipError):
    """Raised when the most up-to-date version of a package is already
    installed.  """


class BadCommand(PipError):
    """Raised when virtualenv or a command is not found"""


class CommandError(PipError):
    """Raised when there is an error in command-line arguments"""


class PreviousBuildDirError(PipError):
    """Raised when there's a previous conflicting build directory"""


class HashMismatch(InstallationError):
    """Distribution file hash values don't match."""


class InvalidWheelFilename(InstallationError):
    """Invalid wheel filename."""


class UnsupportedWheel(InstallationError):
    """Unsupported wheel."""

########NEW FILE########
__FILENAME__ = index
"""Routines related to PyPI, indexes"""

import sys
import os
import re
import mimetypes
import posixpath

from pip.log import logger
from pip.util import Inf, normalize_name, splitext, is_prerelease
from pip.exceptions import (
    DistributionNotFound, BestVersionAlreadyInstalled, InvalidWheelFilename,
    UnsupportedWheel,
)
from pip.compat import urlparse, url2pathname
from pip.download import url_to_path, path_to_url
from pip.wheel import Wheel, wheel_ext
from pip.pep425tags import supported_tags, supported_tags_noarch, get_platform
from pip._vendor import html5lib, requests, pkg_resources
from pip._vendor.requests.exceptions import SSLError


__all__ = ['PackageFinder']


INSECURE_SCHEMES = {
    "http": ["https"],
}


class PackageFinder(object):
    """This finds packages.

    This is meant to match easy_install's technique for looking for
    packages, by reading pages and looking for appropriate links
    """

    def __init__(self, find_links, index_urls,
                 use_wheel=True, allow_external=[], allow_unverified=[],
                 allow_all_external=False, allow_all_prereleases=False,
                 session=None):
        if session is None:
            raise TypeError(
                "PackageFinder() missing 1 required keyword argument: "
                "'session'"
            )

        self.find_links = find_links
        self.index_urls = index_urls

        # These are boring links that have already been logged somehow:
        self.logged_links = set()

        self.use_wheel = use_wheel

        # Do we allow (safe and verifiable) externally hosted files?
        self.allow_external = set(normalize_name(n) for n in allow_external)

        # Which names are allowed to install insecure and unverifiable files?
        self.allow_unverified = set(
            normalize_name(n) for n in allow_unverified
        )

        # Anything that is allowed unverified is also allowed external
        self.allow_external |= self.allow_unverified

        # Do we allow all (safe and verifiable) externally hosted files?
        self.allow_all_external = allow_all_external

        # Stores if we ignored any external links so that we can instruct
        #   end users how to install them if no distributions are available
        self.need_warn_external = False

        # Stores if we ignored any unsafe links so that we can instruct
        #   end users how to install them if no distributions are available
        self.need_warn_unverified = False

        # Do we want to allow _all_ pre-releases?
        self.allow_all_prereleases = allow_all_prereleases

        # The Session we'll use to make requests
        self.session = session

    def _sort_locations(self, locations):
        """
        Sort locations into "files" (archives) and "urls", and return
        a pair of lists (files,urls)
        """
        files = []
        urls = []

        # puts the url for the given file path into the appropriate list
        def sort_path(path):
            url = path_to_url(path)
            if mimetypes.guess_type(url, strict=False)[0] == 'text/html':
                urls.append(url)
            else:
                files.append(url)

        for url in locations:

            is_local_path = os.path.exists(url)
            is_file_url = url.startswith('file:')
            is_find_link = url in self.find_links

            if is_local_path or is_file_url:
                if is_local_path:
                    path = url
                else:
                    path = url_to_path(url)
                if is_find_link and os.path.isdir(path):
                    path = os.path.realpath(path)
                    for item in os.listdir(path):
                        sort_path(os.path.join(path, item))
                elif is_file_url and os.path.isdir(path):
                    urls.append(url)
                elif os.path.isfile(path):
                    sort_path(path)
            else:
                urls.append(url)

        return files, urls

    def _link_sort_key(self, link_tuple):
        """
        Function used to generate link sort key for link tuples.
        The greater the return value, the more preferred it is.
        If not finding wheels, then sorted by version only.
        If finding wheels, then the sort order is by version, then:
          1. existing installs
          2. wheels ordered via Wheel.support_index_min()
          3. source archives
        Note: it was considered to embed this logic into the Link
              comparison operators, but then different sdist links
              with the same version, would have to be considered equal
        """
        parsed_version, link, _ = link_tuple
        if self.use_wheel:
            support_num = len(supported_tags)
            if link == INSTALLED_VERSION:
                pri = 1
            elif link.ext == wheel_ext:
                wheel = Wheel(link.filename)  # can raise InvalidWheelFilename
                if not wheel.supported():
                    raise UnsupportedWheel(
                        "%s is not a supported wheel for this platform. It "
                        "can't be sorted." % wheel.filename
                    )
                pri = -(wheel.support_index_min())
            else:  # sdist
                pri = -(support_num)
            return (parsed_version, pri)
        else:
            return parsed_version

    def _sort_versions(self, applicable_versions):
        """
        Bring the latest version (and wheels) to the front, but maintain the
        existing ordering as secondary. See the docstring for `_link_sort_key`
        for details. This function is isolated for easier unit testing.
        """
        return sorted(
            applicable_versions,
            key=self._link_sort_key,
            reverse=True
        )

    def find_requirement(self, req, upgrade):

        def mkurl_pypi_url(url):
            loc = posixpath.join(url, url_name)
            # For maximum compatibility with easy_install, ensure the path
            # ends in a trailing slash.  Although this isn't in the spec
            # (and PyPI can handle it without the slash) some other index
            # implementations might break if they relied on easy_install's
            # behavior.
            if not loc.endswith('/'):
                loc = loc + '/'
            return loc

        url_name = req.url_name
        # Only check main index if index URL is given:
        main_index_url = None
        if self.index_urls:
            # Check that we have the url_name correctly spelled:
            main_index_url = Link(
                mkurl_pypi_url(self.index_urls[0]),
                trusted=True,
            )

            page = self._get_page(main_index_url, req)
            if page is None:
                url_name = self._find_url_name(
                    Link(self.index_urls[0], trusted=True),
                    url_name, req
                ) or req.url_name

        if url_name is not None:
            locations = [
                mkurl_pypi_url(url)
                for url in self.index_urls] + self.find_links
        else:
            locations = list(self.find_links)
        for version in req.absolute_versions:
            if url_name is not None and main_index_url is not None:
                locations = [
                    posixpath.join(main_index_url.url, version)] + locations

        file_locations, url_locations = self._sort_locations(locations)

        # We trust every url that the user has given us whether it was given
        #   via --index-url or --find-links
        locations = [Link(url, trusted=True) for url in url_locations]

        logger.debug('URLs to search for versions for %s:' % req)
        for location in locations:
            logger.debug('* %s' % location)

            # Determine if this url used a secure transport mechanism
            parsed = urlparse.urlparse(str(location))
            if parsed.scheme in INSECURE_SCHEMES:
                secure_schemes = INSECURE_SCHEMES[parsed.scheme]

                if len(secure_schemes) == 1:
                    ctx = (location, parsed.scheme, secure_schemes[0],
                           parsed.netloc)
                    logger.warn("%s uses an insecure transport scheme (%s). "
                                "Consider using %s if %s has it available" %
                                ctx)
                elif len(secure_schemes) > 1:
                    ctx = (
                        location,
                        parsed.scheme,
                        ", ".join(secure_schemes),
                        parsed.netloc,
                    )
                    logger.warn("%s uses an insecure transport scheme (%s). "
                                "Consider using one of %s if %s has any of "
                                "them available" % ctx)
                else:
                    ctx = (location, parsed.scheme)
                    logger.warn("%s uses an insecure transport scheme (%s)." %
                                ctx)

        found_versions = []
        found_versions.extend(
            self._package_versions(
                # We trust every directly linked archive in find_links
                [Link(url, '-f', trusted=True) for url in self.find_links],
                req.name.lower()
            )
        )
        page_versions = []
        for page in self._get_pages(locations, req):
            logger.debug('Analyzing links from page %s' % page.url)
            logger.indent += 2
            try:
                page_versions.extend(
                    self._package_versions(page.links, req.name.lower())
                )
            finally:
                logger.indent -= 2
        file_versions = list(
            self._package_versions(
                [Link(url) for url in file_locations],
                req.name.lower()
            )
        )
        if (not found_versions
                and not page_versions
                and not file_versions):
            logger.fatal(
                'Could not find any downloads that satisfy the requirement'
                ' %s' % req
            )

            if self.need_warn_external:
                logger.warn(
                    "Some externally hosted files were ignored as access to "
                    "them may be unreliable (use --allow-external %s to "
                    "allow)." % req.name
                )

            if self.need_warn_unverified:
                logger.warn("Some insecure and unverifiable files were ignored"
                            " (use --allow-unverified %s to allow)." %
                            req.name)

            raise DistributionNotFound(
                'No distributions at all found for %s' % req
            )
        installed_version = []
        if req.satisfied_by is not None:
            installed_version = [(
                req.satisfied_by.parsed_version,
                INSTALLED_VERSION,
                req.satisfied_by.version,
            )]
        if file_versions:
            file_versions.sort(reverse=True)
            logger.info(
                'Local files found: %s' %
                ', '.join([
                    url_to_path(link.url)
                    for _, link, _ in file_versions
                ])
            )
        # this is an intentional priority ordering
        all_versions = installed_version + file_versions + found_versions \
            + page_versions
        applicable_versions = []
        for (parsed_version, link, version) in all_versions:
            if version not in req.req:
                logger.info(
                    "Ignoring link %s, version %s doesn't match %s" %
                    (
                        link,
                        version,
                        ','.join([''.join(s) for s in req.req.specs])
                    )
                )
                continue
            elif (is_prerelease(version)
                    and not (self.allow_all_prereleases or req.prereleases)):
                # If this version isn't the already installed one, then
                #   ignore it if it's a pre-release.
                if link is not INSTALLED_VERSION:
                    logger.info(
                        "Ignoring link %s, version %s is a pre-release (use "
                        "--pre to allow)." % (link, version)
                    )
                    continue
            applicable_versions.append((parsed_version, link, version))
        applicable_versions = self._sort_versions(applicable_versions)
        existing_applicable = bool([
            link
            for parsed_version, link, version in applicable_versions
            if link is INSTALLED_VERSION
        ])
        if not upgrade and existing_applicable:
            if applicable_versions[0][1] is INSTALLED_VERSION:
                logger.info(
                    'Existing installed version (%s) is most up-to-date and '
                    'satisfies requirement' % req.satisfied_by.version
                )
            else:
                logger.info(
                    'Existing installed version (%s) satisfies requirement '
                    '(most up-to-date version is %s)' %
                    (req.satisfied_by.version, applicable_versions[0][2])
                )
            return None
        if not applicable_versions:
            logger.fatal(
                'Could not find a version that satisfies the requirement %s '
                '(from versions: %s)' %
                (
                    req,
                    ', '.join(
                        sorted(set([
                            version
                            for parsed_version, link, version in all_versions
                        ])))
                )
            )

            if self.need_warn_external:
                logger.warn(
                    "Some externally hosted files were ignored as access to "
                    "them may be unreliable (use --allow-external to allow)."
                )

            if self.need_warn_unverified:
                logger.warn("Some insecure and unverifiable files were ignored"
                            " (use --allow-unverified %s to allow)." %
                            req.name)

            raise DistributionNotFound(
                'No distributions matching the version for %s' % req
            )
        if applicable_versions[0][1] is INSTALLED_VERSION:
            # We have an existing version, and its the best version
            logger.info(
                'Installed version (%s) is most up-to-date (past versions: '
                '%s)' % (
                    req.satisfied_by.version,
                    ', '.join([
                        version for parsed_version, link, version
                        in applicable_versions[1:]
                    ]) or 'none'))
            raise BestVersionAlreadyInstalled
        if len(applicable_versions) > 1:
            logger.info(
                'Using version %s (newest of versions: %s)' %
                (
                    applicable_versions[0][2],
                    ', '.join([
                        version for parsed_version, link, version
                        in applicable_versions
                    ])
                )
            )

        selected_version = applicable_versions[0][1]

        if (selected_version.verifiable is not None
                and not selected_version.verifiable):
            logger.warn("%s is potentially insecure and "
                        "unverifiable." % req.name)

        if selected_version._deprecated_regex:
            logger.deprecated(
                "1.7",
                "%s discovered using a deprecated method of parsing, "
                "in the future it will no longer be discovered" % req.name
            )

        return selected_version

    def _find_url_name(self, index_url, url_name, req):
        """
        Finds the true URL name of a package, when the given name isn't quite
        correct.
        This is usually used to implement case-insensitivity.
        """
        if not index_url.url.endswith('/'):
            # Vaguely part of the PyPI API... weird but true.
            # FIXME: bad to modify this?
            index_url.url += '/'
        page = self._get_page(index_url, req)
        if page is None:
            logger.fatal('Cannot fetch index base URL %s' % index_url)
            return
        norm_name = normalize_name(req.url_name)
        for link in page.links:
            base = posixpath.basename(link.path.rstrip('/'))
            if norm_name == normalize_name(base):
                logger.notify(
                    'Real name of requirement %s is %s' % (url_name, base)
                )
                return base
        return None

    def _get_pages(self, locations, req):
        """
        Yields (page, page_url) from the given locations, skipping
        locations that have errors, and adding download/homepage links
        """
        all_locations = list(locations)
        seen = set()

        while all_locations:
            location = all_locations.pop(0)
            if location in seen:
                continue
            seen.add(location)

            page = self._get_page(location, req)
            if page is None:
                continue

            yield page

            for link in page.rel_links():
                normalized = normalize_name(req.name).lower()

                if (normalized not in self.allow_external
                        and not self.allow_all_external):
                    self.need_warn_external = True
                    logger.debug("Not searching %s for files because external "
                                 "urls are disallowed." % link)
                    continue

                if (link.trusted is not None
                        and not link.trusted
                        and normalized not in self.allow_unverified):
                    logger.debug(
                        "Not searching %s for urls, it is an "
                        "untrusted link and cannot produce safe or "
                        "verifiable files." % link
                    )
                    self.need_warn_unverified = True
                    continue

                all_locations.append(link)

    _egg_fragment_re = re.compile(r'#egg=([^&]*)')
    _egg_info_re = re.compile(r'([a-z0-9_.]+)-([a-z0-9_.-]+)', re.I)
    _py_version_re = re.compile(r'-py([123]\.?[0-9]?)$')

    def _sort_links(self, links):
        """
        Returns elements of links in order, non-egg links first, egg links
        second, while eliminating duplicates
        """
        eggs, no_eggs = [], []
        seen = set()
        for link in links:
            if link not in seen:
                seen.add(link)
                if link.egg_fragment:
                    eggs.append(link)
                else:
                    no_eggs.append(link)
        return no_eggs + eggs

    def _package_versions(self, links, search_name):
        for link in self._sort_links(links):
            for v in self._link_package_versions(link, search_name):
                yield v

    def _known_extensions(self):
        extensions = ('.tar.gz', '.tar.bz2', '.tar', '.tgz', '.zip')
        if self.use_wheel:
            return extensions + (wheel_ext,)
        return extensions

    def _link_package_versions(self, link, search_name):
        """
        Return an iterable of triples (pkg_resources_version_key,
        link, python_version) that can be extracted from the given
        link.

        Meant to be overridden by subclasses, not called by clients.
        """
        platform = get_platform()

        version = None
        if link.egg_fragment:
            egg_info = link.egg_fragment
        else:
            egg_info, ext = link.splitext()
            if not ext:
                if link not in self.logged_links:
                    logger.debug('Skipping link %s; not a file' % link)
                    self.logged_links.add(link)
                return []
            if egg_info.endswith('.tar'):
                # Special double-extension case:
                egg_info = egg_info[:-4]
                ext = '.tar' + ext
            if ext not in self._known_extensions():
                if link not in self.logged_links:
                    logger.debug(
                        'Skipping link %s; unknown archive format: %s' %
                        (link, ext)
                    )
                    self.logged_links.add(link)
                return []
            if "macosx10" in link.path and ext == '.zip':
                if link not in self.logged_links:
                    logger.debug('Skipping link %s; macosx10 one' % (link))
                    self.logged_links.add(link)
                return []
            if ext == wheel_ext:
                try:
                    wheel = Wheel(link.filename)
                except InvalidWheelFilename:
                    logger.debug(
                        'Skipping %s because the wheel filename is invalid' %
                        link
                    )
                    return []
                if wheel.name.lower() != search_name.lower():
                    logger.debug(
                        'Skipping link %s; wrong project name (not %s)' %
                        (link, search_name)
                    )
                    return []
                if not wheel.supported():
                    logger.debug(
                        'Skipping %s because it is not compatible with this '
                        'Python' % link
                    )
                    return []
                # This is a dirty hack to prevent installing Binary Wheels from
                # PyPI unless it is a Windows or Mac Binary Wheel. This is
                # paired with a change to PyPI disabling uploads for the
                # same. Once we have a mechanism for enabling support for
                # binary wheels on linux that deals with the inherent problems
                # of binary distribution this can be removed.
                comes_from = getattr(link, "comes_from", None)
                if (
                        (
                            not platform.startswith('win')
                            and not platform.startswith('macosx')
                        )
                        and comes_from is not None
                        and urlparse.urlparse(
                            comes_from.url
                        ).netloc.endswith("pypi.python.org")):
                    if not wheel.supported(tags=supported_tags_noarch):
                        logger.debug(
                            "Skipping %s because it is a pypi-hosted binary "
                            "Wheel on an unsupported platform" % link
                        )
                        return []
                version = wheel.version

        if not version:
            version = self._egg_info_matches(egg_info, search_name, link)
        if version is None:
            logger.debug(
                'Skipping link %s; wrong project name (not %s)' %
                (link, search_name)
            )
            return []

        if (link.internal is not None
                and not link.internal
                and not normalize_name(search_name).lower()
                in self.allow_external
                and not self.allow_all_external):
            # We have a link that we are sure is external, so we should skip
            #   it unless we are allowing externals
            logger.debug("Skipping %s because it is externally hosted." % link)
            self.need_warn_external = True
            return []

        if (link.verifiable is not None
                and not link.verifiable
                and not (normalize_name(search_name).lower()
                         in self.allow_unverified)):
            # We have a link that we are sure we cannot verify its integrity,
            #   so we should skip it unless we are allowing unsafe installs
            #   for this requirement.
            logger.debug("Skipping %s because it is an insecure and "
                         "unverifiable file." % link)
            self.need_warn_unverified = True
            return []

        match = self._py_version_re.search(version)
        if match:
            version = version[:match.start()]
            py_version = match.group(1)
            if py_version != sys.version[:3]:
                logger.debug(
                    'Skipping %s because Python version is incorrect' % link
                )
                return []
        logger.debug('Found link %s, version: %s' % (link, version))
        return [(
            pkg_resources.parse_version(version),
            link,
            version,
        )]

    def _egg_info_matches(self, egg_info, search_name, link):
        match = self._egg_info_re.search(egg_info)
        if not match:
            logger.debug('Could not parse version from link: %s' % link)
            return None
        name = match.group(0).lower()
        # To match the "safe" name that pkg_resources creates:
        name = name.replace('_', '-')
        # project name and version must be separated by a dash
        look_for = search_name.lower() + "-"
        if name.startswith(look_for):
            return match.group(0)[len(look_for):]
        else:
            return None

    def _get_page(self, link, req):
        return HTMLPage.get_page(link, req, session=self.session)


class HTMLPage(object):
    """Represents one page, along with its URL"""

    # FIXME: these regexes are horrible hacks:
    _homepage_re = re.compile(r'<th>\s*home\s*page', re.I)
    _download_re = re.compile(r'<th>\s*download\s+url', re.I)
    _href_re = re.compile(
        'href=(?:"([^"]*)"|\'([^\']*)\'|([^>\\s\\n]*))',
        re.I | re.S
    )

    def __init__(self, content, url, headers=None, trusted=None):
        self.content = content
        self.parsed = html5lib.parse(self.content, namespaceHTMLElements=False)
        self.url = url
        self.headers = headers
        self.trusted = trusted

    def __str__(self):
        return self.url

    @classmethod
    def get_page(cls, link, req, skip_archives=True, session=None):
        if session is None:
            raise TypeError(
                "get_page() missing 1 required keyword argument: 'session'"
            )

        url = link.url
        url = url.split('#', 1)[0]

        # Check for VCS schemes that do not support lookup as web pages.
        from pip.vcs import VcsSupport
        for scheme in VcsSupport.schemes:
            if url.lower().startswith(scheme) and url[len(scheme)] in '+:':
                logger.debug(
                    'Cannot look at %(scheme)s URL %(link)s' % locals()
                )
                return None

        try:
            if skip_archives:
                filename = link.filename
                for bad_ext in ['.tar', '.tar.gz', '.tar.bz2', '.tgz', '.zip']:
                    if filename.endswith(bad_ext):
                        content_type = cls._get_content_type(
                            url, session=session,
                        )
                        if content_type.lower().startswith('text/html'):
                            break
                        else:
                            logger.debug(
                                'Skipping page %s because of Content-Type: '
                                '%s' % (link, content_type)
                            )
                            return

            logger.debug('Getting page %s' % url)

            # Tack index.html onto file:// URLs that point to directories
            (scheme, netloc, path, params, query, fragment) = \
                urlparse.urlparse(url)
            if scheme == 'file' and os.path.isdir(url2pathname(path)):
                # add trailing slash if not present so urljoin doesn't trim
                # final segment
                if not url.endswith('/'):
                    url += '/'
                url = urlparse.urljoin(url, 'index.html')
                logger.debug(' file: URL is directory, getting %s' % url)

            resp = session.get(
                url,
                headers={
                    "Accept": "text/html",
                    "Cache-Control": "max-age=600",
                },
            )
            resp.raise_for_status()

            # The check for archives above only works if the url ends with
            #   something that looks like an archive. However that is not a
            #   requirement of an url. Unless we issue a HEAD request on every
            #   url we cannot know ahead of time for sure if something is HTML
            #   or not. However we can check after we've downloaded it.
            content_type = resp.headers.get('Content-Type', 'unknown')
            if not content_type.lower().startswith("text/html"):
                logger.debug(
                    'Skipping page %s because of Content-Type: %s' %
                    (link, content_type)
                )
                return

            inst = cls(resp.text, resp.url, resp.headers, trusted=link.trusted)
        except requests.HTTPError as exc:
            level = 2 if exc.response.status_code == 404 else 1
            cls._handle_fail(req, link, exc, url, level=level)
        except requests.ConnectionError as exc:
            cls._handle_fail(
                req, link, "connection error: %s" % exc, url,
            )
        except requests.Timeout:
            cls._handle_fail(req, link, "timed out", url)
        except SSLError as exc:
            reason = ("There was a problem confirming the ssl certificate: "
                      "%s" % exc)
            cls._handle_fail(
                req, link, reason, url,
                level=2,
                meth=logger.notify,
            )
        else:
            return inst

    @staticmethod
    def _handle_fail(req, link, reason, url, level=1, meth=None):
        if meth is None:
            meth = logger.info

        meth("Could not fetch URL %s: %s", link, reason)
        meth("Will skip URL %s when looking for download links for %s" %
             (link.url, req))

    @staticmethod
    def _get_content_type(url, session):
        """Get the Content-Type of the given url, using a HEAD request"""
        scheme, netloc, path, query, fragment = urlparse.urlsplit(url)
        if scheme not in ('http', 'https', 'ftp', 'ftps'):
            # FIXME: some warning or something?
            # assertion error?
            return ''

        resp = session.head(url, allow_redirects=True)
        resp.raise_for_status()

        return resp.headers.get("Content-Type", "")

    @property
    def api_version(self):
        if not hasattr(self, "_api_version"):
            _api_version = None

            metas = [
                x for x in self.parsed.findall(".//meta")
                if x.get("name", "").lower() == "api-version"
            ]
            if metas:
                try:
                    _api_version = int(metas[0].get("value", None))
                except (TypeError, ValueError):
                    _api_version = None
            self._api_version = _api_version
        return self._api_version

    @property
    def base_url(self):
        if not hasattr(self, "_base_url"):
            base = self.parsed.find(".//base")
            if base is not None and base.get("href"):
                self._base_url = base.get("href")
            else:
                self._base_url = self.url
        return self._base_url

    @property
    def links(self):
        """Yields all links in the page"""
        for anchor in self.parsed.findall(".//a"):
            if anchor.get("href"):
                href = anchor.get("href")
                url = self.clean_link(urlparse.urljoin(self.base_url, href))

                # Determine if this link is internal. If that distinction
                #   doesn't make sense in this context, then we don't make
                #   any distinction.
                internal = None
                if self.api_version and self.api_version >= 2:
                    # Only api_versions >= 2 have a distinction between
                    #   external and internal links
                    internal = bool(
                        anchor.get("rel")
                        and "internal" in anchor.get("rel").split()
                    )

                yield Link(url, self, internal=internal)

    def rel_links(self):
        for url in self.explicit_rel_links():
            yield url
        for url in self.scraped_rel_links():
            yield url

    def explicit_rel_links(self, rels=('homepage', 'download')):
        """Yields all links with the given relations"""
        rels = set(rels)

        for anchor in self.parsed.findall(".//a"):
            if anchor.get("rel") and anchor.get("href"):
                found_rels = set(anchor.get("rel").split())
                # Determine the intersection between what rels were found and
                #   what rels were being looked for
                if found_rels & rels:
                    href = anchor.get("href")
                    url = self.clean_link(
                        urlparse.urljoin(self.base_url, href)
                    )
                    yield Link(url, self, trusted=False)

    def scraped_rel_links(self):
        # Can we get rid of this horrible horrible method?
        for regex in (self._homepage_re, self._download_re):
            match = regex.search(self.content)
            if not match:
                continue
            href_match = self._href_re.search(self.content, pos=match.end())
            if not href_match:
                continue
            url = (
                href_match.group(1)
                or href_match.group(2)
                or href_match.group(3)
            )
            if not url:
                continue
            url = self.clean_link(urlparse.urljoin(self.base_url, url))
            yield Link(url, self, trusted=False, _deprecated_regex=True)

    _clean_re = re.compile(r'[^a-z0-9$&+,/:;=?@.#%_\\|-]', re.I)

    def clean_link(self, url):
        """Makes sure a link is fully encoded.  That is, if a ' ' shows up in
        the link, it will be rewritten to %20 (while not over-quoting
        % or other characters)."""
        return self._clean_re.sub(
            lambda match: '%%%2x' % ord(match.group(0)), url)


class Link(object):

    def __init__(self, url, comes_from=None, internal=None, trusted=None,
                 _deprecated_regex=False):
        self.url = url
        self.comes_from = comes_from
        self.internal = internal
        self.trusted = trusted
        self._deprecated_regex = _deprecated_regex

    def __str__(self):
        if self.comes_from:
            return '%s (from %s)' % (self.url, self.comes_from)
        else:
            return str(self.url)

    def __repr__(self):
        return '<Link %s>' % self

    def __eq__(self, other):
        return self.url == other.url

    def __ne__(self, other):
        return self.url != other.url

    def __lt__(self, other):
        return self.url < other.url

    def __le__(self, other):
        return self.url <= other.url

    def __gt__(self, other):
        return self.url > other.url

    def __ge__(self, other):
        return self.url >= other.url

    def __hash__(self):
        return hash(self.url)

    @property
    def filename(self):
        _, netloc, path, _, _ = urlparse.urlsplit(self.url)
        name = posixpath.basename(path.rstrip('/')) or netloc
        assert name, ('URL %r produced no filename' % self.url)
        return name

    @property
    def scheme(self):
        return urlparse.urlsplit(self.url)[0]

    @property
    def path(self):
        return urlparse.urlsplit(self.url)[2]

    def splitext(self):
        return splitext(posixpath.basename(self.path.rstrip('/')))

    @property
    def ext(self):
        return self.splitext()[1]

    @property
    def url_without_fragment(self):
        scheme, netloc, path, query, fragment = urlparse.urlsplit(self.url)
        return urlparse.urlunsplit((scheme, netloc, path, query, None))

    _egg_fragment_re = re.compile(r'#egg=([^&]*)')

    @property
    def egg_fragment(self):
        match = self._egg_fragment_re.search(self.url)
        if not match:
            return None
        return match.group(1)

    _hash_re = re.compile(
        r'(sha1|sha224|sha384|sha256|sha512|md5)=([a-f0-9]+)'
    )

    @property
    def hash(self):
        match = self._hash_re.search(self.url)
        if match:
            return match.group(2)
        return None

    @property
    def hash_name(self):
        match = self._hash_re.search(self.url)
        if match:
            return match.group(1)
        return None

    @property
    def show_url(self):
        return posixpath.basename(self.url.split('#', 1)[0].split('?', 1)[0])

    @property
    def verifiable(self):
        """
        Returns True if this link can be verified after download, False if it
        cannot, and None if we cannot determine.
        """
        trusted = self.trusted or getattr(self.comes_from, "trusted", None)
        if trusted is not None and trusted:
            # This link came from a trusted source. It *may* be verifiable but
            #   first we need to see if this page is operating under the new
            #   API version.
            try:
                api_version = getattr(self.comes_from, "api_version", None)
                api_version = int(api_version)
            except (ValueError, TypeError):
                api_version = None

            if api_version is None or api_version <= 1:
                # This link is either trusted, or it came from a trusted,
                #   however it is not operating under the API version 2 so
                #   we can't make any claims about if it's safe or not
                return

            if self.hash:
                # This link came from a trusted source and it has a hash, so we
                #   can consider it safe.
                return True
            else:
                # This link came from a trusted source, using the new API
                #   version, and it does not have a hash. It is NOT verifiable
                return False
        elif trusted is not None:
            # This link came from an untrusted source and we cannot trust it
            return False


# An object to represent the "link" for the installed version of a requirement.
# Using Inf as the url makes it sort higher.
INSTALLED_VERSION = Link(Inf)


def get_requirement_from_url(url):
    """Get a requirement from the URL, if possible.  This looks for #egg
    in the URL"""
    link = Link(url)
    egg_info = link.egg_fragment
    if not egg_info:
        egg_info = splitext(link.filename)[0]
    return package_to_requirement(egg_info)


def package_to_requirement(package_name):
    """Translate a name like Foo-1.2 to Foo==1.3"""
    match = re.search(r'^(.*?)-(dev|\d.*)', package_name)
    if match:
        name = match.group(1)
        version = match.group(2)
    else:
        name = package_name
        version = ''
    if version:
        return '%s==%s' % (name, version)
    else:
        return name

########NEW FILE########
__FILENAME__ = locations
"""Locations where we look for configs, install stuff, etc"""

import getpass
import os
import site
import sys
import tempfile

from distutils import sysconfig
from distutils.command.install import install, SCHEME_KEYS

from pip import appdirs
from pip.compat import get_path_uid
import pip.exceptions


# Hack for flake8
install

# Application Directories
USER_CACHE_DIR = appdirs.user_cache_dir("pip")


DELETE_MARKER_MESSAGE = '''\
This file is placed here by pip to indicate the source was put
here by pip.

Once this package is successfully installed this source code will be
deleted (unless you remove this file).
'''
PIP_DELETE_MARKER_FILENAME = 'pip-delete-this-directory.txt'


def write_delete_marker_file(directory):
    """
    Write the pip delete marker file into this directory.
    """
    filepath = os.path.join(directory, PIP_DELETE_MARKER_FILENAME)
    marker_fp = open(filepath, 'w')
    marker_fp.write(DELETE_MARKER_MESSAGE)
    marker_fp.close()


def running_under_virtualenv():
    """
    Return True if we're running inside a virtualenv, False otherwise.

    """
    if hasattr(sys, 'real_prefix'):
        return True
    elif sys.prefix != getattr(sys, "base_prefix", sys.prefix):
        return True

    return False


def virtualenv_no_global():
    """
    Return True if in a venv and no system site packages.
    """
    # this mirrors the logic in virtualenv.py for locating the
    # no-global-site-packages.txt file
    site_mod_dir = os.path.dirname(os.path.abspath(site.__file__))
    no_global_file = os.path.join(site_mod_dir, 'no-global-site-packages.txt')
    if running_under_virtualenv() and os.path.isfile(no_global_file):
        return True


def __get_username():
    """ Returns the effective username of the current process. """
    if sys.platform == 'win32':
        return getpass.getuser()
    import pwd
    return pwd.getpwuid(os.geteuid()).pw_name


def _get_build_prefix():
    """ Returns a safe build_prefix """
    path = os.path.join(
        tempfile.gettempdir(),
        'pip_build_%s' % __get_username()
    )
    if sys.platform == 'win32':
        """ on windows(tested on 7) temp dirs are isolated """
        return path
    try:
        os.mkdir(path)
        write_delete_marker_file(path)
    except OSError:
        file_uid = None
        try:
            # raises OSError for symlinks
            # https://github.com/pypa/pip/pull/935#discussion_r5307003
            file_uid = get_path_uid(path)
        except OSError:
            file_uid = None

        if file_uid != os.geteuid():
            msg = (
                "The temporary folder for building (%s) is either not owned by"
                " you, or is a symlink." % path
            )
            print(msg)
            print(
                "pip will not work until the temporary folder is either "
                "deleted or is a real directory owned by your user account."
            )
            raise pip.exceptions.InstallationError(msg)
    return path

if running_under_virtualenv():
    build_prefix = os.path.join(sys.prefix, 'build')
    src_prefix = os.path.join(sys.prefix, 'src')
else:
    # Note: intentionally NOT using mkdtemp
    # See https://github.com/pypa/pip/issues/906 for plan to move to mkdtemp
    build_prefix = _get_build_prefix()

    # FIXME: keep src in cwd for now (it is not a temporary folder)
    try:
        src_prefix = os.path.join(os.getcwd(), 'src')
    except OSError:
        # In case the current working directory has been renamed or deleted
        sys.exit(
            "The folder you are executing pip from can no longer be found."
        )

# under Mac OS X + virtualenv sys.prefix is not properly resolved
# it is something like /path/to/python/bin/..
# Note: using realpath due to tmp dirs on OSX being symlinks
build_prefix = os.path.abspath(os.path.realpath(build_prefix))
src_prefix = os.path.abspath(src_prefix)

# FIXME doesn't account for venv linked to global site-packages

site_packages = sysconfig.get_python_lib()
user_site = site.USER_SITE
user_dir = os.path.expanduser('~')
if sys.platform == 'win32':
    bin_py = os.path.join(sys.prefix, 'Scripts')
    bin_user = os.path.join(user_site, 'Scripts')
    # buildout uses 'bin' on Windows too?
    if not os.path.exists(bin_py):
        bin_py = os.path.join(sys.prefix, 'bin')
        bin_user = os.path.join(user_site, 'bin')
    default_storage_dir = os.path.join(user_dir, 'pip')
    default_config_basename = 'pip.ini'
    default_config_file = os.path.join(
        default_storage_dir,
        default_config_basename,
    )
    default_log_file = os.path.join(default_storage_dir, 'pip.log')
else:
    bin_py = os.path.join(sys.prefix, 'bin')
    bin_user = os.path.join(user_site, 'bin')
    default_storage_dir = os.path.join(user_dir, '.pip')
    default_config_basename = 'pip.conf'
    default_config_file = os.path.join(
        default_storage_dir,
        default_config_basename,
    )
    default_log_file = os.path.join(default_storage_dir, 'pip.log')

    # Forcing to use /usr/local/bin for standard Mac OS X framework installs
    # Also log to ~/Library/Logs/ for use with the Console.app log viewer
    if sys.platform[:6] == 'darwin' and sys.prefix[:16] == '/System/Library/':
        bin_py = '/usr/local/bin'
        default_log_file = os.path.join(user_dir, 'Library/Logs/pip.log')


def distutils_scheme(dist_name, user=False, home=None, root=None):
    """
    Return a distutils install scheme
    """
    from distutils.dist import Distribution

    scheme = {}
    d = Distribution({'name': dist_name})
    d.parse_config_files()
    i = d.get_command_obj('install', create=True)
    # NOTE: setting user or home has the side-effect of creating the home dir
    # or user base for installations during finalize_options()
    # ideally, we'd prefer a scheme class that has no side-effects.
    i.user = user or i.user
    i.home = home or i.home
    i.root = root or i.root
    i.finalize_options()
    for key in SCHEME_KEYS:
        scheme[key] = getattr(i, 'install_' + key)

    if i.install_lib is not None:
        # install_lib takes precedence over purelib and platlib
        scheme.update(dict(purelib=i.install_lib, platlib=i.install_lib))

    if running_under_virtualenv():
        scheme['headers'] = os.path.join(
            sys.prefix,
            'include',
            'site',
            'python' + sys.version[:3],
            dist_name,
        )

        if root is not None:
            scheme["headers"] = os.path.join(
                root,
                os.path.abspath(scheme["headers"])[1:],
            )

    return scheme

########NEW FILE########
__FILENAME__ = log
"""Logging
"""

import sys
import os
import logging

from pip._vendor import colorama, pkg_resources


def _color_wrap(*colors):
    def wrapped(inp):
        return "".join(list(colors) + [inp, colorama.Style.RESET_ALL])
    return wrapped


def should_color(consumer, environ, std=(sys.stdout, sys.stderr)):
    real_consumer = (
        consumer if not isinstance(consumer, colorama.AnsiToWin32)
        else consumer.wrapped
    )

    # If consumer isn't stdout or stderr we shouldn't colorize it
    if real_consumer not in std:
        return False

    # If consumer is a tty we should color it
    if hasattr(real_consumer, "isatty") and real_consumer.isatty():
        return True

    # If we have an ASNI term we should color it
    if environ.get("TERM") == "ANSI":
        return True

    # If anything else we should not color it
    return False


def should_warn(current_version, removal_version):
    # Our Significant digits on versions is 2, so remove everything but the
    #   first two places.
    current_version = ".".join(current_version.split(".")[:2])
    removal_version = ".".join(removal_version.split(".")[:2])

    # Our warning threshold is one minor version before removal, so we
    #   decrement the minor version by one
    major, minor = removal_version.split(".")
    minor = str(int(minor) - 1)
    warn_version = ".".join([major, minor])

    # Test if our current_version should be a warn
    return (pkg_resources.parse_version(current_version)
            < pkg_resources.parse_version(warn_version))


class Logger(object):
    """
    Logging object for use in command-line script.  Allows ranges of
    levels, to avoid some redundancy of displayed information.
    """
    VERBOSE_DEBUG = logging.DEBUG - 1
    DEBUG = logging.DEBUG
    INFO = logging.INFO
    NOTIFY = (logging.INFO + logging.WARN) / 2
    WARN = WARNING = logging.WARN
    ERROR = logging.ERROR
    FATAL = logging.FATAL

    LEVELS = [VERBOSE_DEBUG, DEBUG, INFO, NOTIFY, WARN, ERROR, FATAL]

    COLORS = {
        WARN: _color_wrap(colorama.Fore.YELLOW),
        ERROR: _color_wrap(colorama.Fore.RED),
        FATAL: _color_wrap(colorama.Fore.RED),
    }

    def __init__(self):
        self.consumers = []
        self.indent = 0
        self.explicit_levels = False
        self.in_progress = None
        self.in_progress_hanging = False

    def add_consumers(self, *consumers):
        for level, consumer in consumers:
            # Try to check for duplicate consumers before adding them
            for chk_level, chk_consumer in self.consumers:
                # Account for coloroma wrapped streams
                if isinstance(chk_consumer, colorama.AnsiToWin32):
                    chk_consumer = chk_consumer.wrapped

                if (level, consumer) == (chk_level, chk_consumer):
                    break
            # If we didn't find a duplicate, then add it
            else:
                # Colorize consumer for Windows
                if sys.platform.startswith('win') \
                   and hasattr(consumer, 'write'):
                    consumer = colorama.AnsiToWin32(consumer)

                self.consumers.append((level, consumer))

    def debug(self, msg, *args, **kw):
        self.log(self.DEBUG, msg, *args, **kw)

    def info(self, msg, *args, **kw):
        self.log(self.INFO, msg, *args, **kw)

    def notify(self, msg, *args, **kw):
        self.log(self.NOTIFY, msg, *args, **kw)

    def warn(self, msg, *args, **kw):
        self.log(self.WARN, msg, *args, **kw)

    def error(self, msg, *args, **kw):
        self.log(self.ERROR, msg, *args, **kw)

    def fatal(self, msg, *args, **kw):
        self.log(self.FATAL, msg, *args, **kw)

    def deprecated(self, removal_version, msg, *args, **kwargs):
        """
        Logs deprecation message which is log level WARN if the
        ``removal_version`` is > 1 minor release away and log level ERROR
        otherwise.

        removal_version should be the version that the deprecated feature is
        expected to be removed in, so something that will not exist in
        version 1.7, but will in 1.6 would have a removal_version of 1.7.
        """
        from pip import __version__

        if should_warn(__version__, removal_version):
            self.warn(msg, *args, **kwargs)
        else:
            self.error(msg, *args, **kwargs)

    def log(self, level, msg, *args, **kw):
        if args:
            if kw:
                raise TypeError(
                    "You may give positional or keyword arguments, not both")
        args = args or kw

        # render
        if args:
            rendered = msg % args
        else:
            rendered = msg
        rendered = ' ' * self.indent + rendered
        if self.explicit_levels:
            # FIXME: should this be a name, not a level number?
            rendered = '%02i %s' % (level, rendered)

        for consumer_level, consumer in self.consumers:
            if self.level_matches(level, consumer_level):
                if (self.in_progress_hanging
                        and consumer in (sys.stdout, sys.stderr)):
                    self.in_progress_hanging = False
                    sys.stdout.write('\n')
                    sys.stdout.flush()
                if hasattr(consumer, 'write'):
                    write_content = rendered + '\n'
                    if should_color(consumer, os.environ):
                        # We are printing to stdout or stderr and it supports
                        #   colors so render our text colored
                        colorizer = self.COLORS.get(level, lambda x: x)
                        write_content = colorizer(write_content)

                    consumer.write(write_content)
                    if hasattr(consumer, 'flush'):
                        consumer.flush()
                else:
                    consumer(rendered)

    def _show_progress(self):
        """Should we display download progress?"""
        return (self.stdout_level_matches(self.NOTIFY) and sys.stdout.isatty())

    def start_progress(self, msg):
        assert not self.in_progress, (
            "Tried to start_progress(%r) while in_progress %r"
            % (msg, self.in_progress))
        if self._show_progress():
            sys.stdout.write(' ' * self.indent + msg)
            sys.stdout.flush()
            self.in_progress_hanging = True
        else:
            self.in_progress_hanging = False
        self.in_progress = msg
        self.last_message = None

    def end_progress(self, msg='done.'):
        assert self.in_progress, (
            "Tried to end_progress without start_progress")
        if self._show_progress():
            if not self.in_progress_hanging:
                # Some message has been printed out since start_progress
                sys.stdout.write('...' + self.in_progress + msg + '\n')
                sys.stdout.flush()
            else:
                # These erase any messages shown with show_progress
                # (besides .'s)
                logger.show_progress('')
                logger.show_progress('')
                sys.stdout.write(msg + '\n')
                sys.stdout.flush()
        self.in_progress = None
        self.in_progress_hanging = False

    def show_progress(self, message=None):
        """If we are in a progress scope, and no log messages have been
        shown, write out another '.'"""
        if self.in_progress_hanging:
            if message is None:
                sys.stdout.write('.')
                sys.stdout.flush()
            else:
                if self.last_message:
                    padding = ' ' * max(
                        0,
                        len(self.last_message) - len(message)
                    )
                else:
                    padding = ''
                sys.stdout.write(
                    '\r%s%s%s%s' %
                    (' ' * self.indent, self.in_progress, message, padding)
                )
                sys.stdout.flush()
                self.last_message = message

    def stdout_level_matches(self, level):
        """Returns true if a message at this level will go to stdout"""
        return self.level_matches(level, self._stdout_level())

    def _stdout_level(self):
        """Returns the level that stdout runs at"""
        for level, consumer in self.consumers:
            if consumer is sys.stdout:
                return level
        return self.FATAL

    def level_matches(self, level, consumer_level):
        """
        >>> l = Logger()
        >>> l.level_matches(3, 4)
        False
        >>> l.level_matches(3, 2)
        True
        >>> l.level_matches(slice(None, 3), 3)
        False
        >>> l.level_matches(slice(None, 3), 2)
        True
        >>> l.level_matches(slice(1, 3), 1)
        True
        >>> l.level_matches(slice(2, 3), 1)
        False
        """
        if isinstance(level, slice):
            start, stop = level.start, level.stop
            if start is not None and start > consumer_level:
                return False
            if stop is not None or stop <= consumer_level:
                return False
            return True
        else:
            return level >= consumer_level

    @classmethod
    def level_for_integer(cls, level):
        levels = cls.LEVELS
        if level < 0:
            return levels[0]
        if level >= len(levels):
            return levels[-1]
        return levels[level]

    def move_stdout_to_stderr(self):
        to_remove = []
        to_add = []
        for consumer_level, consumer in self.consumers:
            if consumer == sys.stdout:
                to_remove.append((consumer_level, consumer))
                to_add.append((consumer_level, sys.stderr))
        for item in to_remove:
            self.consumers.remove(item)
        self.consumers.extend(to_add)

logger = Logger()

########NEW FILE########
__FILENAME__ = pep425tags
"""Generate and work with PEP 425 Compatibility Tags."""

import sys
import warnings

try:
    import sysconfig
except ImportError:  # pragma nocover
    # Python < 2.7
    import distutils.sysconfig as sysconfig
import distutils.util


def get_abbr_impl():
    """Return abbreviated implementation name."""
    if hasattr(sys, 'pypy_version_info'):
        pyimpl = 'pp'
    elif sys.platform.startswith('java'):
        pyimpl = 'jy'
    elif sys.platform == 'cli':
        pyimpl = 'ip'
    else:
        pyimpl = 'cp'
    return pyimpl


def get_impl_ver():
    """Return implementation version."""
    return ''.join(map(str, sys.version_info[:2]))


def get_platform():
    """Return our platform name 'win32', 'linux_x86_64'"""
    # XXX remove distutils dependency
    return distutils.util.get_platform().replace('.', '_').replace('-', '_')


def get_supported(versions=None, noarch=False):
    """Return a list of supported tags for each version specified in
    `versions`.

    :param versions: a list of string versions, of the form ["33", "32"],
        or None. The first version will be assumed to support our ABI.
    """
    supported = []

    # Versions must be given with respect to the preference
    if versions is None:
        versions = []
        major = sys.version_info[0]
        # Support all previous minor Python versions.
        for minor in range(sys.version_info[1], -1, -1):
            versions.append(''.join(map(str, (major, minor))))

    impl = get_abbr_impl()

    abis = []

    try:
        soabi = sysconfig.get_config_var('SOABI')
    except IOError as e:  # Issue #1074
        warnings.warn("{0}".format(e), RuntimeWarning)
        soabi = None

    if soabi and soabi.startswith('cpython-'):
        abis[0:0] = ['cp' + soabi.split('-', 1)[-1]]

    abi3s = set()
    import imp
    for suffix in imp.get_suffixes():
        if suffix[0].startswith('.abi'):
            abi3s.add(suffix[0].split('.', 2)[1])

    abis.extend(sorted(list(abi3s)))

    abis.append('none')

    if not noarch:
        arch = get_platform()

        # Current version, current API (built specifically for our Python):
        for abi in abis:
            supported.append(('%s%s' % (impl, versions[0]), abi, arch))

    # No abi / arch, but requires our implementation:
    for i, version in enumerate(versions):
        supported.append(('%s%s' % (impl, version), 'none', 'any'))
        if i == 0:
            # Tagged specifically as being cross-version compatible
            # (with just the major version specified)
            supported.append(('%s%s' % (impl, versions[0][0]), 'none', 'any'))

    # No abi / arch, generic Python
    for i, version in enumerate(versions):
        supported.append(('py%s' % (version,), 'none', 'any'))
        if i == 0:
            supported.append(('py%s' % (version[0]), 'none', 'any'))

    return supported

supported_tags = get_supported()
supported_tags_noarch = get_supported(noarch=True)

########NEW FILE########
__FILENAME__ = req_file
import os
import re

from pip.compat import urlparse
from pip.download import get_file_content
from pip.req.req_install import InstallRequirement
from pip.util import normalize_name

_scheme_re = re.compile(r'^(http|https|file):', re.I)


def parse_requirements(filename, finder=None, comes_from=None, options=None,
                       session=None):
    if session is None:
        raise TypeError(
            "parse_requirements() missing 1 required keyword argument: "
            "'session'"
        )

    skip_match = None
    skip_regex = options.skip_requirements_regex if options else None
    if skip_regex:
        skip_match = re.compile(skip_regex)
    reqs_file_dir = os.path.dirname(os.path.abspath(filename))
    filename, content = get_file_content(
        filename,
        comes_from=comes_from,
        session=session,
    )
    for line_number, line in enumerate(content.splitlines(), 1):
        line = line.strip()

        # Remove comments from file
        line = re.sub(r"(^|\s)#.*$", "", line)

        if not line or line.startswith('#'):
            continue
        if skip_match and skip_match.search(line):
            continue
        if line.startswith('-r') or line.startswith('--requirement'):
            if line.startswith('-r'):
                req_url = line[2:].strip()
            else:
                req_url = line[len('--requirement'):].strip().strip('=')
            if _scheme_re.search(filename):
                # Relative to a URL
                req_url = urlparse.urljoin(filename, req_url)
            elif not _scheme_re.search(req_url):
                req_url = os.path.join(os.path.dirname(filename), req_url)
            for item in parse_requirements(
                    req_url, finder,
                    comes_from=filename,
                    options=options,
                    session=session):
                yield item
        elif line.startswith('-Z') or line.startswith('--always-unzip'):
            # No longer used, but previously these were used in
            # requirement files, so we'll ignore.
            pass
        elif line.startswith('-f') or line.startswith('--find-links'):
            if line.startswith('-f'):
                line = line[2:].strip()
            else:
                line = line[len('--find-links'):].strip().lstrip('=')
            # FIXME: it would be nice to keep track of the source of
            # the find_links:
            # support a find-links local path relative to a requirements file
            relative_to_reqs_file = os.path.join(reqs_file_dir, line)
            if os.path.exists(relative_to_reqs_file):
                line = relative_to_reqs_file
            if finder:
                finder.find_links.append(line)
        elif line.startswith('-i') or line.startswith('--index-url'):
            if line.startswith('-i'):
                line = line[2:].strip()
            else:
                line = line[len('--index-url'):].strip().lstrip('=')
            if finder:
                finder.index_urls = [line]
        elif line.startswith('--extra-index-url'):
            line = line[len('--extra-index-url'):].strip().lstrip('=')
            if finder:
                finder.index_urls.append(line)
        elif line.startswith('--use-wheel'):
            finder.use_wheel = True
        elif line.startswith('--no-index'):
            finder.index_urls = []
        elif line.startswith("--allow-external"):
            line = line[len("--allow-external"):].strip().lstrip("=")
            finder.allow_external |= set([normalize_name(line).lower()])
        elif line.startswith("--allow-all-external"):
            finder.allow_all_external = True
        # Remove in 1.7
        elif line.startswith("--no-allow-external"):
            pass
        # Remove in 1.7
        elif line.startswith("--no-allow-insecure"):
            pass
        # Remove after 1.7
        elif line.startswith("--allow-insecure"):
            line = line[len("--allow-insecure"):].strip().lstrip("=")
            finder.allow_unverified |= set([normalize_name(line).lower()])
        elif line.startswith("--allow-unverified"):
            line = line[len("--allow-unverified"):].strip().lstrip("=")
            finder.allow_unverified |= set([normalize_name(line).lower()])
        else:
            comes_from = '-r %s (line %s)' % (filename, line_number)
            if line.startswith('-e') or line.startswith('--editable'):
                if line.startswith('-e'):
                    line = line[2:].strip()
                else:
                    line = line[len('--editable'):].strip().lstrip('=')
                req = InstallRequirement.from_editable(
                    line,
                    comes_from=comes_from,
                    default_vcs=options.default_vcs if options else None
                )
            else:
                req = InstallRequirement.from_line(
                    line,
                    comes_from,
                    prereleases=getattr(options, "pre", None)
                )
            yield req

########NEW FILE########
__FILENAME__ = req_install
import os
import re
import shutil
import sys
import tempfile
import zipfile
from distutils.util import change_root
from distutils import sysconfig
from email.parser import FeedParser

import pip.wheel
from pip._vendor import pkg_resources, six
from pip.compat import (
    urllib, ConfigParser, string_types,
)
from pip.download import is_url, url_to_path, path_to_url, is_archive_file
from pip.exceptions import (
    InstallationError, UninstallationError, UnsupportedWheel,
)
from pip.index import Link
from pip.locations import (
    bin_py, running_under_virtualenv, PIP_DELETE_MARKER_FILENAME, bin_user,
)
from pip.log import logger
from pip.util import (
    display_path, rmtree, ask_path_exists, backup_dir, is_installable_dir,
    dist_in_usersite, dist_in_site_packages, egg_link_path, make_path_relative,
    call_subprocess, is_prerelease, read_text_file, FakeFile, _make_build_dir,
)
from pip.req.req_uninstall import UninstallPathSet
from pip.vcs import vcs
from pip.wheel import move_wheel_files, Wheel, wheel_ext


class InstallRequirement(object):

    def __init__(self, req, comes_from, source_dir=None, editable=False,
                 url=None, as_egg=False, update=True, prereleases=None,
                 editable_options=None, pycompile=True):
        self.extras = ()
        if isinstance(req, string_types):
            req = pkg_resources.Requirement.parse(req)
            self.extras = req.extras
        self.req = req
        self.comes_from = comes_from
        self.source_dir = source_dir
        self.editable = editable

        if editable_options is None:
            editable_options = {}

        self.editable_options = editable_options
        self.url = url
        self.as_egg = as_egg
        self._egg_info_path = None
        # This holds the pkg_resources.Distribution object if this requirement
        # is already available:
        self.satisfied_by = None
        # This hold the pkg_resources.Distribution object if this requirement
        # conflicts with another installed distribution:
        self.conflicts_with = None
        self._temp_build_dir = None
        # True if the editable should be updated:
        self.update = update
        # Set to True after successful installation
        self.install_succeeded = None
        # UninstallPathSet of uninstalled distribution (for possible rollback)
        self.uninstalled = None
        self.use_user_site = False
        self.target_dir = None

        self.pycompile = pycompile

        # True if pre-releases are acceptable
        if prereleases:
            self.prereleases = True
        elif self.req is not None:
            self.prereleases = any([
                is_prerelease(x[1]) and x[0] != "!=" for x in self.req.specs
            ])
        else:
            self.prereleases = False

    @classmethod
    def from_editable(cls, editable_req, comes_from=None, default_vcs=None):
        name, url, extras_override = parse_editable(editable_req, default_vcs)
        if url.startswith('file:'):
            source_dir = url_to_path(url)
        else:
            source_dir = None

        res = cls(name, comes_from, source_dir=source_dir,
                  editable=True,
                  url=url,
                  editable_options=extras_override,
                  prereleases=True)

        if extras_override is not None:
            res.extras = extras_override

        return res

    @classmethod
    def from_line(cls, name, comes_from=None, prereleases=None):
        """Creates an InstallRequirement from a name, which might be a
        requirement, directory containing 'setup.py', filename, or URL.
        """
        url = None
        name = name.strip()
        req = None
        path = os.path.normpath(os.path.abspath(name))
        link = None

        if is_url(name):
            link = Link(name)
        elif (os.path.isdir(path)
                and (os.path.sep in name or name.startswith('.'))):
            if not is_installable_dir(path):
                raise InstallationError(
                    "Directory %r is not installable. File 'setup.py' not "
                    "found." % name
                )
            link = Link(path_to_url(name))
        elif is_archive_file(path):
            if not os.path.isfile(path):
                logger.warn(
                    'Requirement %r looks like a filename, but the file does '
                    'not exist',
                    name
                )
            link = Link(path_to_url(name))

        # it's a local file, dir, or url
        if link:

            url = link.url_without_fragment
            # Handle relative file URLs
            if link.scheme == 'file' and re.search(r'\.\./', url):
                url = path_to_url(os.path.normpath(os.path.abspath(link.path)))

            # wheel file
            if link.ext == wheel_ext:
                wheel = Wheel(link.filename)  # can raise InvalidWheelFilename
                if not wheel.supported():
                    raise UnsupportedWheel(
                        "%s is not a supported wheel on this platform." %
                        wheel.filename
                    )
                req = "%s==%s" % (wheel.name, wheel.version)
            else:
                # set the req to the egg fragment.  when it's not there, this
                # will become an 'unnamed' requirement
                req = link.egg_fragment

        # a requirement specifier
        else:
            req = name

        return cls(req, comes_from, url=url, prereleases=prereleases)

    def __str__(self):
        if self.req:
            s = str(self.req)
            if self.url:
                s += ' from %s' % self.url
        else:
            s = self.url
        if self.satisfied_by is not None:
            s += ' in %s' % display_path(self.satisfied_by.location)
        if self.comes_from:
            if isinstance(self.comes_from, string_types):
                comes_from = self.comes_from
            else:
                comes_from = self.comes_from.from_path()
            if comes_from:
                s += ' (from %s)' % comes_from
        return s

    def from_path(self):
        if self.req is None:
            return None
        s = str(self.req)
        if self.comes_from:
            if isinstance(self.comes_from, string_types):
                comes_from = self.comes_from
            else:
                comes_from = self.comes_from.from_path()
            if comes_from:
                s += '->' + comes_from
        return s

    def build_location(self, build_dir, unpack=True):
        if self._temp_build_dir is not None:
            return self._temp_build_dir
        if self.req is None:
            self._temp_build_dir = tempfile.mkdtemp('-build', 'pip-')
            self._ideal_build_dir = build_dir
            return self._temp_build_dir
        if self.editable:
            name = self.name.lower()
        else:
            name = self.name
        # FIXME: Is there a better place to create the build_dir? (hg and bzr
        # need this)
        if not os.path.exists(build_dir):
            _make_build_dir(build_dir)
        return os.path.join(build_dir, name)

    def correct_build_location(self):
        """If the build location was a temporary directory, this will move it
        to a new more permanent location"""
        if self.source_dir is not None:
            return
        assert self.req is not None
        assert self._temp_build_dir
        old_location = self._temp_build_dir
        new_build_dir = self._ideal_build_dir
        del self._ideal_build_dir
        if self.editable:
            name = self.name.lower()
        else:
            name = self.name
        new_location = os.path.join(new_build_dir, name)
        if not os.path.exists(new_build_dir):
            logger.debug('Creating directory %s' % new_build_dir)
            _make_build_dir(new_build_dir)
        if os.path.exists(new_location):
            raise InstallationError(
                'A package already exists in %s; please remove it to continue'
                % display_path(new_location))
        logger.debug(
            'Moving package %s from %s to new location %s' %
            (self, display_path(old_location), display_path(new_location))
        )
        shutil.move(old_location, new_location)
        self._temp_build_dir = new_location
        self.source_dir = new_location
        self._egg_info_path = None

    @property
    def name(self):
        if self.req is None:
            return None
        return self.req.project_name

    @property
    def url_name(self):
        if self.req is None:
            return None
        return urllib.quote(self.req.unsafe_name)

    @property
    def setup_py(self):
        try:
            import setuptools  # noqa
        except ImportError:
            # Setuptools is not available
            raise InstallationError(
                "setuptools must be installed to install from a source "
                "distribution"
            )

        setup_file = 'setup.py'

        if self.editable_options and 'subdirectory' in self.editable_options:
            setup_py = os.path.join(self.source_dir,
                                    self.editable_options['subdirectory'],
                                    setup_file)

        else:
            setup_py = os.path.join(self.source_dir, setup_file)

        # Python2 __file__ should not be unicode
        if six.PY2 and isinstance(setup_py, six.text_type):
            setup_py = setup_py.encode(sys.getfilesystemencoding())

        return setup_py

    def run_egg_info(self):
        assert self.source_dir
        if self.name:
            logger.notify(
                'Running setup.py (path:%s) egg_info for package %s' %
                (self.setup_py, self.name)
            )
        else:
            logger.notify(
                'Running setup.py (path:%s) egg_info for package from %s' %
                (self.setup_py, self.url)
            )
        logger.indent += 2
        try:

            # if it's distribute>=0.7, it won't contain an importable
            # setuptools, and having an egg-info dir blocks the ability of
            # setup.py to find setuptools plugins, so delete the egg-info dir
            # if no setuptools. it will get recreated by the run of egg_info
            # NOTE: this self.name check only works when installing from a
            #       specifier (not archive path/urls)
            # TODO: take this out later
            if (self.name == 'distribute'
                    and not os.path.isdir(
                        os.path.join(self.source_dir, 'setuptools'))):
                rmtree(os.path.join(self.source_dir, 'distribute.egg-info'))

            script = self._run_setup_py
            script = script.replace('__SETUP_PY__', repr(self.setup_py))
            script = script.replace('__PKG_NAME__', repr(self.name))
            egg_info_cmd = [sys.executable, '-c', script, 'egg_info']
            # We can't put the .egg-info files at the root, because then the
            # source code will be mistaken for an installed egg, causing
            # problems
            if self.editable:
                egg_base_option = []
            else:
                egg_info_dir = os.path.join(self.source_dir, 'pip-egg-info')
                if not os.path.exists(egg_info_dir):
                    os.makedirs(egg_info_dir)
                egg_base_option = ['--egg-base', 'pip-egg-info']
            cwd = self.source_dir
            if self.editable_options and \
                    'subdirectory' in self.editable_options:
                cwd = os.path.join(cwd, self.editable_options['subdirectory'])
            call_subprocess(
                egg_info_cmd + egg_base_option,
                cwd=cwd,
                filter_stdout=self._filter_install,
                show_stdout=False,
                command_level=logger.VERBOSE_DEBUG,
                command_desc='python setup.py egg_info')
        finally:
            logger.indent -= 2
        if not self.req:
            self.req = pkg_resources.Requirement.parse(
                "%(Name)s==%(Version)s" % self.pkg_info())
            self.correct_build_location()

    # FIXME: This is a lame hack, entirely for PasteScript which has
    # a self-provided entry point that causes this awkwardness
    _run_setup_py = """
__file__ = __SETUP_PY__
from setuptools.command import egg_info
import pkg_resources
import os
import tokenize
def replacement_run(self):
    self.mkpath(self.egg_info)
    installer = self.distribution.fetch_build_egg
    for ep in pkg_resources.iter_entry_points('egg_info.writers'):
        # require=False is the change we're making:
        writer = ep.load(require=False)
        if writer:
            writer(self, ep.name, os.path.join(self.egg_info,ep.name))
    self.find_sources()
egg_info.egg_info.run = replacement_run
exec(compile(
    getattr(tokenize, 'open', open)(__file__).read().replace('\\r\\n', '\\n'),
    __file__,
    'exec'
))
"""

    def egg_info_data(self, filename):
        if self.satisfied_by is not None:
            if not self.satisfied_by.has_metadata(filename):
                return None
            return self.satisfied_by.get_metadata(filename)
        assert self.source_dir
        filename = self.egg_info_path(filename)
        if not os.path.exists(filename):
            return None
        data = read_text_file(filename)
        return data

    def egg_info_path(self, filename):
        if self._egg_info_path is None:
            if self.editable:
                base = self.source_dir
            else:
                base = os.path.join(self.source_dir, 'pip-egg-info')
            filenames = os.listdir(base)
            if self.editable:
                filenames = []
                for root, dirs, files in os.walk(base):
                    for dir in vcs.dirnames:
                        if dir in dirs:
                            dirs.remove(dir)
                    # Iterate over a copy of ``dirs``, since mutating
                    # a list while iterating over it can cause trouble.
                    # (See https://github.com/pypa/pip/pull/462.)
                    for dir in list(dirs):
                        # Don't search in anything that looks like a virtualenv
                        # environment
                        if (
                                os.path.exists(
                                    os.path.join(root, dir, 'bin', 'python')
                                )
                                or os.path.exists(
                                    os.path.join(
                                        root, dir, 'Scripts', 'Python.exe'
                                    )
                                )):
                            dirs.remove(dir)
                        # Also don't search through tests
                        elif dir == 'test' or dir == 'tests':
                            dirs.remove(dir)
                    filenames.extend([os.path.join(root, dir)
                                     for dir in dirs])
                filenames = [f for f in filenames if f.endswith('.egg-info')]

            if not filenames:
                raise InstallationError(
                    'No files/directories in %s (from %s)' % (base, filename)
                )
            assert filenames, \
                "No files/directories in %s (from %s)" % (base, filename)

            # if we have more than one match, we pick the toplevel one.  This
            # can easily be the case if there is a dist folder which contains
            # an extracted tarball for testing purposes.
            if len(filenames) > 1:
                filenames.sort(
                    key=lambda x: x.count(os.path.sep)
                    + (os.path.altsep and x.count(os.path.altsep) or 0)
                )
            self._egg_info_path = os.path.join(base, filenames[0])
        return os.path.join(self._egg_info_path, filename)

    def egg_info_lines(self, filename):
        data = self.egg_info_data(filename)
        if not data:
            return []
        result = []
        for line in data.splitlines():
            line = line.strip()
            if not line or line.startswith('#'):
                continue
            result.append(line)
        return result

    def pkg_info(self):
        p = FeedParser()
        data = self.egg_info_data('PKG-INFO')
        if not data:
            logger.warn(
                'No PKG-INFO file found in %s' %
                display_path(self.egg_info_path('PKG-INFO'))
            )
        p.feed(data or '')
        return p.close()

    _requirements_section_re = re.compile(r'\[(.*?)\]')

    def requirements(self, extras=()):
        in_extra = None
        for line in self.egg_info_lines('requires.txt'):
            match = self._requirements_section_re.match(line.lower())
            if match:
                in_extra = match.group(1)
                continue
            if in_extra and in_extra not in extras:
                logger.debug('skipping extra %s' % in_extra)
                # Skip requirement for an extra we aren't requiring
                continue
            yield line

    @property
    def absolute_versions(self):
        for qualifier, version in self.req.specs:
            if qualifier == '==':
                yield version

    @property
    def installed_version(self):
        return self.pkg_info()['version']

    def assert_source_matches_version(self):
        assert self.source_dir
        version = self.installed_version
        if version not in self.req:
            logger.warn(
                'Requested %s, but installing version %s' %
                (self, self.installed_version)
            )
        else:
            logger.debug(
                'Source in %s has version %s, which satisfies requirement %s' %
                (display_path(self.source_dir), version, self)
            )

    def update_editable(self, obtain=True):
        if not self.url:
            logger.info(
                "Cannot update repository at %s; repository location is "
                "unknown" % self.source_dir
            )
            return
        assert self.editable
        assert self.source_dir
        if self.url.startswith('file:'):
            # Static paths don't get updated
            return
        assert '+' in self.url, "bad url: %r" % self.url
        if not self.update:
            return
        vc_type, url = self.url.split('+', 1)
        backend = vcs.get_backend(vc_type)
        if backend:
            vcs_backend = backend(self.url)
            if obtain:
                vcs_backend.obtain(self.source_dir)
            else:
                vcs_backend.export(self.source_dir)
        else:
            assert 0, (
                'Unexpected version control type (in %s): %s'
                % (self.url, vc_type))

    def uninstall(self, auto_confirm=False):
        """
        Uninstall the distribution currently satisfying this requirement.

        Prompts before removing or modifying files unless
        ``auto_confirm`` is True.

        Refuses to delete or modify files outside of ``sys.prefix`` -
        thus uninstallation within a virtual environment can only
        modify that virtual environment, even if the virtualenv is
        linked to global site-packages.

        """
        if not self.check_if_exists():
            raise UninstallationError(
                "Cannot uninstall requirement %s, not installed" % (self.name,)
            )
        dist = self.satisfied_by or self.conflicts_with

        paths_to_remove = UninstallPathSet(dist)

        pip_egg_info_path = os.path.join(dist.location,
                                         dist.egg_name()) + '.egg-info'
        dist_info_path = os.path.join(dist.location,
                                      '-'.join(dist.egg_name().split('-')[:2])
                                      ) + '.dist-info'
        # Workaround - http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=618367
        debian_egg_info_path = pip_egg_info_path.replace(
            '-py%s' % pkg_resources.PY_MAJOR, '')
        easy_install_egg = dist.egg_name() + '.egg'
        develop_egg_link = egg_link_path(dist)

        pip_egg_info_exists = os.path.exists(pip_egg_info_path)
        debian_egg_info_exists = os.path.exists(debian_egg_info_path)
        dist_info_exists = os.path.exists(dist_info_path)
        if pip_egg_info_exists or debian_egg_info_exists:
            # package installed by pip
            if pip_egg_info_exists:
                egg_info_path = pip_egg_info_path
            else:
                egg_info_path = debian_egg_info_path
            paths_to_remove.add(egg_info_path)
            if dist.has_metadata('installed-files.txt'):
                for installed_file in dist.get_metadata(
                        'installed-files.txt').splitlines():
                    path = os.path.normpath(
                        os.path.join(egg_info_path, installed_file)
                    )
                    paths_to_remove.add(path)
            # FIXME: need a test for this elif block
            # occurs with --single-version-externally-managed/--record outside
            # of pip
            elif dist.has_metadata('top_level.txt'):
                if dist.has_metadata('namespace_packages.txt'):
                    namespaces = dist.get_metadata('namespace_packages.txt')
                else:
                    namespaces = []
                for top_level_pkg in [
                        p for p
                        in dist.get_metadata('top_level.txt').splitlines()
                        if p and p not in namespaces]:
                    path = os.path.join(dist.location, top_level_pkg)
                    paths_to_remove.add(path)
                    paths_to_remove.add(path + '.py')
                    paths_to_remove.add(path + '.pyc')

        elif dist.location.endswith(easy_install_egg):
            # package installed by easy_install
            paths_to_remove.add(dist.location)
            easy_install_pth = os.path.join(os.path.dirname(dist.location),
                                            'easy-install.pth')
            paths_to_remove.add_pth(easy_install_pth, './' + easy_install_egg)

        elif develop_egg_link:
            # develop egg
            fh = open(develop_egg_link, 'r')
            link_pointer = os.path.normcase(fh.readline().strip())
            fh.close()
            assert (link_pointer == dist.location), (
                'Egg-link %s does not match installed location of %s '
                '(at %s)' % (link_pointer, self.name, dist.location)
            )
            paths_to_remove.add(develop_egg_link)
            easy_install_pth = os.path.join(os.path.dirname(develop_egg_link),
                                            'easy-install.pth')
            paths_to_remove.add_pth(easy_install_pth, dist.location)
        elif dist_info_exists:
            for path in pip.wheel.uninstallation_paths(dist):
                paths_to_remove.add(path)

        # find distutils scripts= scripts
        if dist.has_metadata('scripts') and dist.metadata_isdir('scripts'):
            for script in dist.metadata_listdir('scripts'):
                if dist_in_usersite(dist):
                    bin_dir = bin_user
                else:
                    bin_dir = bin_py
                paths_to_remove.add(os.path.join(bin_dir, script))
                if sys.platform == 'win32':
                    paths_to_remove.add(os.path.join(bin_dir, script) + '.bat')

        # find console_scripts
        if dist.has_metadata('entry_points.txt'):
            config = ConfigParser.SafeConfigParser()
            config.readfp(
                FakeFile(dist.get_metadata_lines('entry_points.txt'))
            )
            if config.has_section('console_scripts'):
                for name, value in config.items('console_scripts'):
                    if dist_in_usersite(dist):
                        bin_dir = bin_user
                    else:
                        bin_dir = bin_py
                    paths_to_remove.add(os.path.join(bin_dir, name))
                    if sys.platform == 'win32':
                        paths_to_remove.add(
                            os.path.join(bin_dir, name) + '.exe'
                        )
                        paths_to_remove.add(
                            os.path.join(bin_dir, name) + '.exe.manifest'
                        )
                        paths_to_remove.add(
                            os.path.join(bin_dir, name) + '-script.py'
                        )

        paths_to_remove.remove(auto_confirm)
        self.uninstalled = paths_to_remove

    def rollback_uninstall(self):
        if self.uninstalled:
            self.uninstalled.rollback()
        else:
            logger.error("Can't rollback %s, nothing uninstalled."
                         % (self.project_name,))

    def commit_uninstall(self):
        if self.uninstalled:
            self.uninstalled.commit()
        else:
            logger.error("Can't commit %s, nothing uninstalled."
                         % (self.project_name,))

    def archive(self, build_dir):
        assert self.source_dir
        create_archive = True
        archive_name = '%s-%s.zip' % (self.name, self.installed_version)
        archive_path = os.path.join(build_dir, archive_name)
        if os.path.exists(archive_path):
            response = ask_path_exists(
                'The file %s exists. (i)gnore, (w)ipe, (b)ackup ' %
                display_path(archive_path), ('i', 'w', 'b'))
            if response == 'i':
                create_archive = False
            elif response == 'w':
                logger.warn('Deleting %s' % display_path(archive_path))
                os.remove(archive_path)
            elif response == 'b':
                dest_file = backup_dir(archive_path)
                logger.warn(
                    'Backing up %s to %s' %
                    (display_path(archive_path), display_path(dest_file))
                )
                shutil.move(archive_path, dest_file)
        if create_archive:
            zip = zipfile.ZipFile(archive_path, 'w', zipfile.ZIP_DEFLATED)
            dir = os.path.normcase(os.path.abspath(self.source_dir))
            for dirpath, dirnames, filenames in os.walk(dir):
                if 'pip-egg-info' in dirnames:
                    dirnames.remove('pip-egg-info')
                for dirname in dirnames:
                    dirname = os.path.join(dirpath, dirname)
                    name = self._clean_zip_name(dirname, dir)
                    zipdir = zipfile.ZipInfo(self.name + '/' + name + '/')
                    zipdir.external_attr = 0x1ED << 16  # 0o755
                    zip.writestr(zipdir, '')
                for filename in filenames:
                    if filename == PIP_DELETE_MARKER_FILENAME:
                        continue
                    filename = os.path.join(dirpath, filename)
                    name = self._clean_zip_name(filename, dir)
                    zip.write(filename, self.name + '/' + name)
            zip.close()
            logger.indent -= 2
            logger.notify('Saved %s' % display_path(archive_path))

    def _clean_zip_name(self, name, prefix):
        assert name.startswith(prefix + os.path.sep), (
            "name %r doesn't start with prefix %r" % (name, prefix)
        )
        name = name[len(prefix) + 1:]
        name = name.replace(os.path.sep, '/')
        return name

    def install(self, install_options, global_options=(), root=None):
        if self.editable:
            self.install_editable(install_options, global_options)
            return
        if self.is_wheel:
            version = pip.wheel.wheel_version(self.source_dir)
            pip.wheel.check_compatibility(version, self.name)

            self.move_wheel_files(self.source_dir, root=root)
            self.install_succeeded = True
            return

        temp_location = tempfile.mkdtemp('-record', 'pip-')
        record_filename = os.path.join(temp_location, 'install-record.txt')
        try:
            install_args = [sys.executable]
            install_args.append('-c')
            install_args.append(
                "import setuptools, tokenize;__file__=%r;"
                "exec(compile(getattr(tokenize, 'open', open)(__file__).read()"
                ".replace('\\r\\n', '\\n'), __file__, 'exec'))" % self.setup_py
            )
            install_args += list(global_options) + \
                ['install', '--record', record_filename]

            if not self.as_egg:
                install_args += ['--single-version-externally-managed']

            if root is not None:
                install_args += ['--root', root]

            if self.pycompile:
                install_args += ["--compile"]
            else:
                install_args += ["--no-compile"]

            if running_under_virtualenv():
                # FIXME: I'm not sure if this is a reasonable location;
                # probably not but we can't put it in the default location, as
                # that is a virtualenv symlink that isn't writable
                py_ver_str = 'python' + sysconfig.get_python_version()
                install_args += ['--install-headers',
                                 os.path.join(sys.prefix, 'include', 'site',
                                              py_ver_str)]
            logger.notify('Running setup.py install for %s' % self.name)
            logger.indent += 2
            try:
                call_subprocess(
                    install_args + install_options,
                    cwd=self.source_dir,
                    filter_stdout=self._filter_install,
                    show_stdout=False,
                )
            finally:
                logger.indent -= 2
            if not os.path.exists(record_filename):
                logger.notify('Record file %s not found' % record_filename)
                return
            self.install_succeeded = True
            if self.as_egg:
                # there's no --always-unzip option we can pass to install
                # command so we unable to save the installed-files.txt
                return

            def prepend_root(path):
                if root is None or not os.path.isabs(path):
                    return path
                else:
                    return change_root(root, path)

            f = open(record_filename)
            for line in f:
                line = line.strip()
                if line.endswith('.egg-info'):
                    egg_info_dir = prepend_root(line)
                    break
            else:
                logger.warn(
                    'Could not find .egg-info directory in install record for '
                    '%s' % self
                )
                f.close()
                # FIXME: put the record somewhere
                # FIXME: should this be an error?
                return
            f.close()
            new_lines = []
            f = open(record_filename)
            for line in f:
                filename = line.strip()
                if os.path.isdir(filename):
                    filename += os.path.sep
                new_lines.append(
                    make_path_relative(prepend_root(filename), egg_info_dir)
                )
            f.close()
            f = open(os.path.join(egg_info_dir, 'installed-files.txt'), 'w')
            f.write('\n'.join(new_lines) + '\n')
            f.close()
        finally:
            if os.path.exists(record_filename):
                os.remove(record_filename)
            os.rmdir(temp_location)

    def remove_temporary_source(self):
        """Remove the source files from this requirement, if they are marked
        for deletion"""
        if os.path.exists(self.delete_marker_filename):
            logger.info('Removing source in %s' % self.source_dir)
            if self.source_dir:
                rmtree(self.source_dir)
            self.source_dir = None
        if self._temp_build_dir and os.path.exists(self._temp_build_dir):
            rmtree(self._temp_build_dir)
        self._temp_build_dir = None

    def install_editable(self, install_options, global_options=()):
        logger.notify('Running setup.py develop for %s' % self.name)
        logger.indent += 2
        try:
            # FIXME: should we do --install-headers here too?
            cwd = self.source_dir
            if self.editable_options and \
                    'subdirectory' in self.editable_options:
                cwd = os.path.join(cwd, self.editable_options['subdirectory'])
            call_subprocess(
                [
                    sys.executable,
                    '-c',
                    "import setuptools, tokenize; __file__=%r; exec(compile("
                    "getattr(tokenize, 'open', open)(__file__).read().replace"
                    "('\\r\\n', '\\n'), __file__, 'exec'))" % self.setup_py
                ]
                + list(global_options)
                + ['develop', '--no-deps']
                + list(install_options),

                cwd=cwd, filter_stdout=self._filter_install,
                show_stdout=False)
        finally:
            logger.indent -= 2
        self.install_succeeded = True

    def _filter_install(self, line):
        level = logger.NOTIFY
        for regex in [
                r'^running .*',
                r'^writing .*',
                '^creating .*',
                '^[Cc]opying .*',
                r'^reading .*',
                r"^removing .*\.egg-info' \(and everything under it\)$",
                r'^byte-compiling ',
                # Not sure what this warning is, but it seems harmless:
                r"^warning: manifest_maker: standard file '-c' not found$"]:
            if re.search(regex, line.strip()):
                level = logger.INFO
                break
        return (level, line)

    def check_if_exists(self):
        """Find an installed distribution that satisfies or conflicts
        with this requirement, and set self.satisfied_by or
        self.conflicts_with appropriately."""

        if self.req is None:
            return False
        try:
            # DISTRIBUTE TO SETUPTOOLS UPGRADE HACK (1 of 3 parts)
            # if we've already set distribute as a conflict to setuptools
            # then this check has already run before.  we don't want it to
            # run again, and return False, since it would block the uninstall
            # TODO: remove this later
            if (self.req.project_name == 'setuptools'
                    and self.conflicts_with
                    and self.conflicts_with.project_name == 'distribute'):
                return True
            else:
                self.satisfied_by = pkg_resources.get_distribution(self.req)
        except pkg_resources.DistributionNotFound:
            return False
        except pkg_resources.VersionConflict:
            existing_dist = pkg_resources.get_distribution(
                self.req.project_name
            )
            if self.use_user_site:
                if dist_in_usersite(existing_dist):
                    self.conflicts_with = existing_dist
                elif (running_under_virtualenv()
                        and dist_in_site_packages(existing_dist)):
                    raise InstallationError(
                        "Will not install to the user site because it will "
                        "lack sys.path precedence to %s in %s" %
                        (existing_dist.project_name, existing_dist.location)
                    )
            else:
                self.conflicts_with = existing_dist
        return True

    @property
    def is_wheel(self):
        return self.url and '.whl' in self.url

    def move_wheel_files(self, wheeldir, root=None):
        move_wheel_files(
            self.name, self.req, wheeldir,
            user=self.use_user_site,
            home=self.target_dir,
            root=root,
            pycompile=self.pycompile,
        )

    @property
    def delete_marker_filename(self):
        assert self.source_dir
        return os.path.join(self.source_dir, PIP_DELETE_MARKER_FILENAME)


def _strip_postfix(req):
    """
        Strip req postfix ( -dev, 0.2, etc )
    """
    # FIXME: use package_to_requirement?
    match = re.search(r'^(.*?)(?:-dev|-\d.*)$', req)
    if match:
        # Strip off -dev, -0.2, etc.
        req = match.group(1)
    return req


def _build_req_from_url(url):

    parts = [p for p in url.split('#', 1)[0].split('/') if p]

    req = None
    if parts[-2] in ('tags', 'branches', 'tag', 'branch'):
        req = parts[-3]
    elif parts[-1] == 'trunk':
        req = parts[-2]
    return req


def _build_editable_options(req):

    """
        This method generates a dictionary of the query string
        parameters contained in a given editable URL.
    """
    regexp = re.compile(r"[\?#&](?P<name>[^&=]+)=(?P<value>[^&=]+)")
    matched = regexp.findall(req)

    if matched:
        ret = dict()
        for option in matched:
            (name, value) = option
            if name in ret:
                raise Exception("%s option already defined" % name)
            ret[name] = value
        return ret
    return None


def parse_editable(editable_req, default_vcs=None):
    """Parses svn+http://blahblah@rev#egg=Foobar into a requirement
    (Foobar) and a URL"""

    url = editable_req
    extras = None

    # If a file path is specified with extras, strip off the extras.
    m = re.match(r'^(.+)(\[[^\]]+\])$', url)
    if m:
        url_no_extras = m.group(1)
        extras = m.group(2)
    else:
        url_no_extras = url

    if os.path.isdir(url_no_extras):
        if not os.path.exists(os.path.join(url_no_extras, 'setup.py')):
            raise InstallationError(
                "Directory %r is not installable. File 'setup.py' not found." %
                url_no_extras
            )
        # Treating it as code that has already been checked out
        url_no_extras = path_to_url(url_no_extras)

    if url_no_extras.lower().startswith('file:'):
        if extras:
            return (
                None,
                url_no_extras,
                pkg_resources.Requirement.parse(
                    '__placeholder__' + extras
                ).extras,
            )
        else:
            return None, url_no_extras, None

    for version_control in vcs:
        if url.lower().startswith('%s:' % version_control):
            url = '%s+%s' % (version_control, url)
            break

    if '+' not in url:
        if default_vcs:
            url = default_vcs + '+' + url
        else:
            raise InstallationError(
                '%s should either be a path to a local project or a VCS url '
                'beginning with svn+, git+, hg+, or bzr+' %
                editable_req
            )

    vc_type = url.split('+', 1)[0].lower()

    if not vcs.get_backend(vc_type):
        error_message = 'For --editable=%s only ' % editable_req + \
            ', '.join([backend.name + '+URL' for backend in vcs.backends]) + \
            ' is currently supported'
        raise InstallationError(error_message)

    try:
        options = _build_editable_options(editable_req)
    except Exception as exc:
        raise InstallationError(
            '--editable=%s error in editable options:%s' % (editable_req, exc)
        )
    if not options or 'egg' not in options:
        req = _build_req_from_url(editable_req)
        if not req:
            raise InstallationError(
                '--editable=%s is not the right format; it must have '
                '#egg=Package' % editable_req
            )
    else:
        req = options['egg']

    package = _strip_postfix(req)
    return package, url, options

########NEW FILE########
__FILENAME__ = req_set
import os
import shutil

from pip._vendor import pkg_resources
from pip.compat import HTTPError
from pip.download import (url_to_path, unpack_vcs_link, is_vcs_url,
                          is_file_url, unpack_file_url, unpack_http_url)
from pip.exceptions import (InstallationError, BestVersionAlreadyInstalled,
                            DistributionNotFound, PreviousBuildDirError)
from pip.index import Link
from pip.locations import (PIP_DELETE_MARKER_FILENAME, build_prefix,
                           write_delete_marker_file)
from pip.log import logger
from pip.req.req_install import InstallRequirement
from pip.util import (display_path, rmtree, dist_in_usersite, call_subprocess,
                      _make_build_dir, normalize_path)
from pip.vcs import vcs
from pip.wheel import wheel_ext


class Requirements(object):

    def __init__(self):
        self._keys = []
        self._dict = {}

    def keys(self):
        return self._keys

    def values(self):
        return [self._dict[key] for key in self._keys]

    def __contains__(self, item):
        return item in self._keys

    def __setitem__(self, key, value):
        if key not in self._keys:
            self._keys.append(key)
        self._dict[key] = value

    def __getitem__(self, key):
        return self._dict[key]

    def __repr__(self):
        values = ['%s: %s' % (repr(k), repr(self[k])) for k in self.keys()]
        return 'Requirements({%s})' % ', '.join(values)


class RequirementSet(object):

    def __init__(self, build_dir, src_dir, download_dir, upgrade=False,
                 ignore_installed=False, as_egg=False, target_dir=None,
                 ignore_dependencies=False, force_reinstall=False,
                 use_user_site=False, session=None, pycompile=True,
                 wheel_download_dir=None):
        if session is None:
            raise TypeError(
                "RequirementSet() missing 1 required keyword argument: "
                "'session'"
            )

        self.build_dir = build_dir
        self.src_dir = src_dir
        self.download_dir = download_dir
        self.upgrade = upgrade
        self.ignore_installed = ignore_installed
        self.force_reinstall = force_reinstall
        self.requirements = Requirements()
        # Mapping of alias: real_name
        self.requirement_aliases = {}
        self.unnamed_requirements = []
        self.ignore_dependencies = ignore_dependencies
        self.successfully_downloaded = []
        self.successfully_installed = []
        self.reqs_to_cleanup = []
        self.as_egg = as_egg
        self.use_user_site = use_user_site
        self.target_dir = target_dir  # set from --target option
        self.session = session
        self.pycompile = pycompile
        if wheel_download_dir:
            wheel_download_dir = normalize_path(wheel_download_dir)
        self.wheel_download_dir = wheel_download_dir

    def __str__(self):
        reqs = [req for req in self.requirements.values()
                if not req.comes_from]
        reqs.sort(key=lambda req: req.name.lower())
        return ' '.join([str(req.req) for req in reqs])

    def add_requirement(self, install_req):
        name = install_req.name
        install_req.as_egg = self.as_egg
        install_req.use_user_site = self.use_user_site
        install_req.target_dir = self.target_dir
        install_req.pycompile = self.pycompile
        if not name:
            # url or path requirement w/o an egg fragment
            self.unnamed_requirements.append(install_req)
        else:
            if self.has_requirement(name):
                raise InstallationError(
                    'Double requirement given: %s (already in %s, name=%r)'
                    % (install_req, self.get_requirement(name), name))
            self.requirements[name] = install_req
            # FIXME: what about other normalizations?  E.g., _ vs. -?
            if name.lower() != name:
                self.requirement_aliases[name.lower()] = name

    def has_requirement(self, project_name):
        for name in project_name, project_name.lower():
            if name in self.requirements or name in self.requirement_aliases:
                return True
        return False

    @property
    def has_requirements(self):
        return list(self.requirements.values()) or self.unnamed_requirements

    @property
    def has_editables(self):
        if any(req.editable for req in self.requirements.values()):
            return True
        if any(req.editable for req in self.unnamed_requirements):
            return True
        return False

    @property
    def is_download(self):
        if self.download_dir:
            self.download_dir = os.path.expanduser(self.download_dir)
            if os.path.exists(self.download_dir):
                return True
            else:
                logger.fatal('Could not find download directory')
                raise InstallationError(
                    "Could not find or access download directory '%s'"
                    % display_path(self.download_dir))
        return False

    def get_requirement(self, project_name):
        for name in project_name, project_name.lower():
            if name in self.requirements:
                return self.requirements[name]
            if name in self.requirement_aliases:
                return self.requirements[self.requirement_aliases[name]]
        raise KeyError("No project with the name %r" % project_name)

    def uninstall(self, auto_confirm=False):
        for req in self.requirements.values():
            req.uninstall(auto_confirm=auto_confirm)
            req.commit_uninstall()

    def locate_files(self):
        # FIXME: duplicates code from prepare_files; relevant code should
        #        probably be factored out into a separate method
        unnamed = list(self.unnamed_requirements)
        reqs = list(self.requirements.values())
        while reqs or unnamed:
            if unnamed:
                req_to_install = unnamed.pop(0)
            else:
                req_to_install = reqs.pop(0)
            install_needed = True
            if not self.ignore_installed and not req_to_install.editable:
                req_to_install.check_if_exists()
                if req_to_install.satisfied_by:
                    if self.upgrade:
                        # don't uninstall conflict if user install and
                        # conflict is not user install
                        if not (self.use_user_site
                                and not dist_in_usersite(
                                    req_to_install.satisfied_by
                                )):
                            req_to_install.conflicts_with = \
                                req_to_install.satisfied_by
                        req_to_install.satisfied_by = None
                    else:
                        install_needed = False
                if req_to_install.satisfied_by:
                    logger.notify('Requirement already satisfied '
                                  '(use --upgrade to upgrade): %s'
                                  % req_to_install)

            if req_to_install.editable:
                if req_to_install.source_dir is None:
                    req_to_install.source_dir = req_to_install.build_location(
                        self.src_dir
                    )
            elif install_needed:
                req_to_install.source_dir = req_to_install.build_location(
                    self.build_dir,
                    not self.is_download,
                )

            if (req_to_install.source_dir is not None
                    and not os.path.isdir(req_to_install.source_dir)):
                raise InstallationError(
                    'Could not install requirement %s because source folder %s'
                    ' does not exist (perhaps --no-download was used without '
                    'first running an equivalent install with --no-install?)' %
                    (req_to_install, req_to_install.source_dir)
                )

    def prepare_files(self, finder):
        """
        Prepare process. Create temp directories, download and/or unpack files.
        """
        unnamed = list(self.unnamed_requirements)
        reqs = list(self.requirements.values())
        while reqs or unnamed:
            if unnamed:
                req_to_install = unnamed.pop(0)
            else:
                req_to_install = reqs.pop(0)
            install = True
            best_installed = False
            not_found = None

            # ############################################# #
            # # Search for archive to fulfill requirement # #
            # ############################################# #

            if not self.ignore_installed and not req_to_install.editable:
                req_to_install.check_if_exists()
                if req_to_install.satisfied_by:
                    if self.upgrade:
                        if not self.force_reinstall and not req_to_install.url:
                            try:
                                url = finder.find_requirement(
                                    req_to_install, self.upgrade)
                            except BestVersionAlreadyInstalled:
                                best_installed = True
                                install = False
                            except DistributionNotFound as exc:
                                not_found = exc
                            else:
                                # Avoid the need to call find_requirement again
                                req_to_install.url = url.url

                        if not best_installed:
                            # don't uninstall conflict if user install and
                            # conflict is not user install
                            if not (self.use_user_site
                                    and not dist_in_usersite(
                                        req_to_install.satisfied_by
                                    )):
                                req_to_install.conflicts_with = \
                                    req_to_install.satisfied_by
                            req_to_install.satisfied_by = None
                    else:
                        install = False
                if req_to_install.satisfied_by:
                    if best_installed:
                        logger.notify('Requirement already up-to-date: %s'
                                      % req_to_install)
                    else:
                        logger.notify('Requirement already satisfied '
                                      '(use --upgrade to upgrade): %s'
                                      % req_to_install)
            if req_to_install.editable:
                logger.notify('Obtaining %s' % req_to_install)
            elif install:
                if (req_to_install.url
                        and req_to_install.url.lower().startswith('file:')):
                    logger.notify(
                        'Unpacking %s' %
                        display_path(url_to_path(req_to_install.url))
                    )
                else:
                    logger.notify('Downloading/unpacking %s' % req_to_install)
            logger.indent += 2

            # ################################ #
            # # vcs update or unpack archive # #
            # ################################ #

            try:
                is_wheel = False
                if req_to_install.editable:
                    if req_to_install.source_dir is None:
                        location = req_to_install.build_location(self.src_dir)
                        req_to_install.source_dir = location
                    else:
                        location = req_to_install.source_dir
                    if not os.path.exists(self.build_dir):
                        _make_build_dir(self.build_dir)
                    req_to_install.update_editable(not self.is_download)
                    if self.is_download:
                        req_to_install.run_egg_info()
                        req_to_install.archive(self.download_dir)
                    else:
                        req_to_install.run_egg_info()
                elif install:
                    # @@ if filesystem packages are not marked
                    # editable in a req, a non deterministic error
                    # occurs when the script attempts to unpack the
                    # build directory

                    # NB: This call can result in the creation of a temporary
                    # build directory
                    location = req_to_install.build_location(
                        self.build_dir,
                        not self.is_download,
                    )
                    unpack = True
                    url = None

                    # If a checkout exists, it's unwise to keep going.  version
                    # inconsistencies are logged later, but do not fail the
                    # installation.
                    if os.path.exists(os.path.join(location, 'setup.py')):
                        raise PreviousBuildDirError(
                            "pip can't proceed with requirements '%s' due to a"
                            " pre-existing build directory (%s). This is "
                            "likely due to a previous installation that failed"
                            ". pip is being responsible and not assuming it "
                            "can delete this. Please delete it and try again."
                            % (req_to_install, location)
                        )
                    else:
                        # FIXME: this won't upgrade when there's an existing
                        # package unpacked in `location`
                        if req_to_install.url is None:
                            if not_found:
                                raise not_found
                            url = finder.find_requirement(
                                req_to_install,
                                upgrade=self.upgrade,
                            )
                        else:
                            # FIXME: should req_to_install.url already be a
                            # link?
                            url = Link(req_to_install.url)
                            assert url
                        if url:
                            try:

                                if (
                                    url.filename.endswith(wheel_ext)
                                    and self.wheel_download_dir
                                ):
                                    # when doing 'pip wheel`
                                    download_dir = self.wheel_download_dir
                                    do_download = True
                                else:
                                    download_dir = self.download_dir
                                    do_download = self.is_download
                                self.unpack_url(
                                    url, location, download_dir,
                                    do_download,
                                )
                            except HTTPError as exc:
                                logger.fatal(
                                    'Could not install requirement %s because '
                                    'of error %s' % (req_to_install, exc)
                                )
                                raise InstallationError(
                                    'Could not install requirement %s because '
                                    'of HTTP error %s for URL %s' %
                                    (req_to_install, exc, url)
                                )
                        else:
                            unpack = False
                    if unpack:
                        is_wheel = url and url.filename.endswith(wheel_ext)
                        if self.is_download:
                            req_to_install.source_dir = location
                            if not is_wheel:
                                # FIXME:https://github.com/pypa/pip/issues/1112
                                req_to_install.run_egg_info()
                            if url and url.scheme in vcs.all_schemes:
                                req_to_install.archive(self.download_dir)
                        elif is_wheel:
                            req_to_install.source_dir = location
                            req_to_install.url = url.url
                        else:
                            req_to_install.source_dir = location
                            req_to_install.run_egg_info()
                            req_to_install.assert_source_matches_version()
                        # req_to_install.req is only avail after unpack for URL
                        # pkgs repeat check_if_exists to uninstall-on-upgrade
                        # (#14)
                        if not self.ignore_installed:
                            req_to_install.check_if_exists()
                        if req_to_install.satisfied_by:
                            if self.upgrade or self.ignore_installed:
                                # don't uninstall conflict if user install and
                                # conflict is not user install
                                if not (self.use_user_site
                                        and not dist_in_usersite(
                                            req_to_install.satisfied_by)):
                                    req_to_install.conflicts_with = \
                                        req_to_install.satisfied_by
                                req_to_install.satisfied_by = None
                            else:
                                logger.notify(
                                    'Requirement already satisfied (use '
                                    '--upgrade to upgrade): %s' %
                                    req_to_install
                                )
                                install = False

                # ###################### #
                # # parse dependencies # #
                # ###################### #

                if is_wheel:
                    dist = list(
                        pkg_resources.find_distributions(location)
                    )[0]
                    if not req_to_install.req:
                        req_to_install.req = dist.as_requirement()
                        self.add_requirement(req_to_install)
                    if not self.ignore_dependencies:
                        for subreq in dist.requires(
                                req_to_install.extras):
                            if self.has_requirement(
                                    subreq.project_name):
                                continue
                            subreq = InstallRequirement(str(subreq),
                                                        req_to_install)
                            reqs.append(subreq)
                            self.add_requirement(subreq)

                # sdists
                else:
                    if (req_to_install.extras):
                        logger.notify(
                            "Installing extra requirements: %r" %
                            ','.join(req_to_install.extras)
                        )
                    if not self.ignore_dependencies:
                        for req in req_to_install.requirements(
                                req_to_install.extras):
                            try:
                                name = pkg_resources.Requirement.parse(
                                    req
                                ).project_name
                            except ValueError as exc:
                                # FIXME: proper warning
                                logger.error(
                                    'Invalid requirement: %r (%s) in '
                                    'requirement %s' %
                                    (req, exc, req_to_install)
                                )
                                continue
                            if self.has_requirement(name):
                                # FIXME: check for conflict
                                continue
                            subreq = InstallRequirement(req, req_to_install)
                            reqs.append(subreq)
                            self.add_requirement(subreq)
                    if not self.has_requirement(req_to_install.name):
                        # 'unnamed' requirements will get added here
                        self.add_requirement(req_to_install)

                # cleanup tmp src
                if (self.is_download or
                        req_to_install._temp_build_dir is not None):
                    self.reqs_to_cleanup.append(req_to_install)

                if install:
                    self.successfully_downloaded.append(req_to_install)

            finally:
                logger.indent -= 2

    def cleanup_files(self):
        """Clean up files, remove builds."""
        logger.notify('Cleaning up...')
        logger.indent += 2
        for req in self.reqs_to_cleanup:
            req.remove_temporary_source()

        remove_dir = []
        if self._pip_has_created_build_dir():
            remove_dir.append(self.build_dir)

        for dir in remove_dir:
            if os.path.exists(dir):
                logger.info('Removing temporary dir %s...' % dir)
                rmtree(dir)

        logger.indent -= 2

    def _pip_has_created_build_dir(self):
        return (
            self.build_dir == build_prefix
            and os.path.exists(
                os.path.join(self.build_dir, PIP_DELETE_MARKER_FILENAME)
            )
        )

    def copy_to_build_dir(self, req_to_install):
        target_dir = req_to_install.editable and self.src_dir or self.build_dir
        logger.info("Copying %s to %s" % (req_to_install.name, target_dir))
        dest = os.path.join(target_dir, req_to_install.name)
        shutil.copytree(req_to_install.source_dir, dest)
        call_subprocess(["python", "%s/setup.py" % dest, "clean"], cwd=dest,
                        command_desc='python setup.py clean')

    def unpack_url(self, link, location, download_dir=None,
                   only_download=False):
        if download_dir is None:
            download_dir = self.download_dir

        # non-editable vcs urls
        if is_vcs_url(link):
            if only_download:
                loc = download_dir
            else:
                loc = location
            unpack_vcs_link(link, loc, only_download)

        # file urls
        elif is_file_url(link):
            unpack_file_url(link, location, download_dir)
            if only_download:
                write_delete_marker_file(location)

        # http urls
        else:
            unpack_http_url(
                link,
                location,
                download_dir,
                self.session,
            )
            if only_download:
                write_delete_marker_file(location)

    def install(self, install_options, global_options=(), *args, **kwargs):
        """
        Install everything in this set (after having downloaded and unpacked
        the packages)
        """
        to_install = [r for r in self.requirements.values()
                      if not r.satisfied_by]

        # DISTRIBUTE TO SETUPTOOLS UPGRADE HACK (1 of 3 parts)
        # move the distribute-0.7.X wrapper to the end because it does not
        # install a setuptools package. by moving it to the end, we ensure it's
        # setuptools dependency is handled first, which will provide the
        # setuptools package
        # TODO: take this out later
        distribute_req = pkg_resources.Requirement.parse("distribute>=0.7")
        for req in to_install:
            if (req.name == 'distribute'
                    and req.installed_version in distribute_req):
                to_install.remove(req)
                to_install.append(req)

        if to_install:
            logger.notify(
                'Installing collected packages: %s' %
                ', '.join([req.name for req in to_install])
            )
        logger.indent += 2
        try:
            for requirement in to_install:

                # DISTRIBUTE TO SETUPTOOLS UPGRADE HACK (1 of 3 parts)
                # when upgrading from distribute-0.6.X to the new merged
                # setuptools in py2, we need to force setuptools to uninstall
                # distribute. In py3, which is always using distribute, this
                # conversion is already happening in distribute's
                # pkg_resources. It's ok *not* to check if setuptools>=0.7
                # because if someone were actually trying to ugrade from
                # distribute to setuptools 0.6.X, then all this could do is
                # actually help, although that upgade path was certainly never
                # "supported"
                # TODO: remove this later
                if requirement.name == 'setuptools':
                    try:
                        # only uninstall distribute<0.7. For >=0.7, setuptools
                        # will also be present, and that's what we need to
                        # uninstall
                        distribute_requirement = \
                            pkg_resources.Requirement.parse("distribute<0.7")
                        existing_distribute = \
                            pkg_resources.get_distribution("distribute")
                        if existing_distribute in distribute_requirement:
                            requirement.conflicts_with = existing_distribute
                    except pkg_resources.DistributionNotFound:
                        # distribute wasn't installed, so nothing to do
                        pass

                if requirement.conflicts_with:
                    logger.notify('Found existing installation: %s'
                                  % requirement.conflicts_with)
                    logger.indent += 2
                    try:
                        requirement.uninstall(auto_confirm=True)
                    finally:
                        logger.indent -= 2
                try:
                    requirement.install(
                        install_options,
                        global_options,
                        *args,
                        **kwargs
                    )
                except:
                    # if install did not succeed, rollback previous uninstall
                    if (requirement.conflicts_with
                            and not requirement.install_succeeded):
                        requirement.rollback_uninstall()
                    raise
                else:
                    if (requirement.conflicts_with
                            and requirement.install_succeeded):
                        requirement.commit_uninstall()
                requirement.remove_temporary_source()
        finally:
            logger.indent -= 2
        self.successfully_installed = to_install

########NEW FILE########
__FILENAME__ = req_uninstall
import imp
import os
import sys
import tempfile

from pip.compat import uses_pycache, b
from pip.exceptions import UninstallationError
from pip.log import logger
from pip.util import (rmtree, ask, is_local, dist_is_local, renames,
                      normalize_path)


class UninstallPathSet(object):
    """A set of file paths to be removed in the uninstallation of a
    requirement."""
    def __init__(self, dist):
        self.paths = set()
        self._refuse = set()
        self.pth = {}
        self.dist = dist
        self.save_dir = None
        self._moved_paths = []

    def _permitted(self, path):
        """
        Return True if the given path is one we are permitted to
        remove/modify, False otherwise.

        """
        return is_local(path)

    def _can_uninstall(self):
        if not dist_is_local(self.dist):
            logger.notify(
                "Not uninstalling %s at %s, outside environment %s" %
                (
                    self.dist.project_name,
                    normalize_path(self.dist.location),
                    sys.prefix
                ),
            )
            return False
        return True

    def add(self, path):
        path = normalize_path(path)
        if not os.path.exists(path):
            return
        if self._permitted(path):
            self.paths.add(path)
        else:
            self._refuse.add(path)

        # __pycache__ files can show up after 'installed-files.txt' is created,
        # due to imports
        if os.path.splitext(path)[1] == '.py' and uses_pycache:
            self.add(imp.cache_from_source(path))

    def add_pth(self, pth_file, entry):
        pth_file = normalize_path(pth_file)
        if self._permitted(pth_file):
            if pth_file not in self.pth:
                self.pth[pth_file] = UninstallPthEntries(pth_file)
            self.pth[pth_file].add(entry)
        else:
            self._refuse.add(pth_file)

    def compact(self, paths):
        """Compact a path set to contain the minimal number of paths
        necessary to contain all paths in the set. If /a/path/ and
        /a/path/to/a/file.txt are both in the set, leave only the
        shorter path."""
        short_paths = set()
        for path in sorted(paths, key=len):
            if not any([
                    (path.startswith(shortpath) and
                     path[len(shortpath.rstrip(os.path.sep))] == os.path.sep)
                    for shortpath in short_paths]):
                short_paths.add(path)
        return short_paths

    def _stash(self, path):
        return os.path.join(
            self.save_dir, os.path.splitdrive(path)[1].lstrip(os.path.sep))

    def remove(self, auto_confirm=False):
        """Remove paths in ``self.paths`` with confirmation (unless
        ``auto_confirm`` is True)."""
        if not self._can_uninstall():
            return
        if not self.paths:
            logger.notify(
                "Can't uninstall '%s'. No files were found to uninstall." %
                self.dist.project_name
            )
            return
        logger.notify('Uninstalling %s:' % self.dist.project_name)
        logger.indent += 2
        paths = sorted(self.compact(self.paths))
        try:
            if auto_confirm:
                response = 'y'
            else:
                for path in paths:
                    logger.notify(path)
                response = ask('Proceed (y/n)? ', ('y', 'n'))
            if self._refuse:
                logger.notify('Not removing or modifying (outside of prefix):')
                for path in self.compact(self._refuse):
                    logger.notify(path)
            if response == 'y':
                self.save_dir = tempfile.mkdtemp(suffix='-uninstall',
                                                 prefix='pip-')
                for path in paths:
                    new_path = self._stash(path)
                    logger.info('Removing file or directory %s' % path)
                    self._moved_paths.append(path)
                    renames(path, new_path)
                for pth in self.pth.values():
                    pth.remove()
                logger.notify(
                    'Successfully uninstalled %s' % self.dist.project_name
                )

        finally:
            logger.indent -= 2

    def rollback(self):
        """Rollback the changes previously made by remove()."""
        if self.save_dir is None:
            logger.error(
                "Can't roll back %s; was not uninstalled" %
                self.dist.project_name
            )
            return False
        logger.notify('Rolling back uninstall of %s' % self.dist.project_name)
        for path in self._moved_paths:
            tmp_path = self._stash(path)
            logger.info('Replacing %s' % path)
            renames(tmp_path, path)
        for pth in self.pth.values():
            pth.rollback()

    def commit(self):
        """Remove temporary save dir: rollback will no longer be possible."""
        if self.save_dir is not None:
            rmtree(self.save_dir)
            self.save_dir = None
            self._moved_paths = []


class UninstallPthEntries(object):
    def __init__(self, pth_file):
        if not os.path.isfile(pth_file):
            raise UninstallationError(
                "Cannot remove entries from nonexistent file %s" % pth_file
            )
        self.file = pth_file
        self.entries = set()
        self._saved_lines = None

    def add(self, entry):
        entry = os.path.normcase(entry)
        # On Windows, os.path.normcase converts the entry to use
        # backslashes.  This is correct for entries that describe absolute
        # paths outside of site-packages, but all the others use forward
        # slashes.
        if sys.platform == 'win32' and not os.path.splitdrive(entry)[0]:
            entry = entry.replace('\\', '/')
        self.entries.add(entry)

    def remove(self):
        logger.info('Removing pth entries from %s:' % self.file)
        fh = open(self.file, 'rb')
        # windows uses '\r\n' with py3k, but uses '\n' with py2.x
        lines = fh.readlines()
        self._saved_lines = lines
        fh.close()
        if any(b('\r\n') in line for line in lines):
            endline = '\r\n'
        else:
            endline = '\n'
        for entry in self.entries:
            try:
                logger.info('Removing entry: %s' % entry)
                lines.remove(b(entry + endline))
            except ValueError:
                pass
        fh = open(self.file, 'wb')
        fh.writelines(lines)
        fh.close()

    def rollback(self):
        if self._saved_lines is None:
            logger.error(
                'Cannot roll back changes to %s, none were made' % self.file
            )
            return False
        logger.info('Rolling %s back to previous state' % self.file)
        fh = open(self.file, 'wb')
        fh.writelines(self._saved_lines)
        fh.close()
        return True

########NEW FILE########
__FILENAME__ = status_codes
SUCCESS = 0
ERROR = 1
UNKNOWN_ERROR = 2
VIRTUALENV_NOT_FOUND = 3
PREVIOUS_BUILD_DIR_ERROR = 4
NO_MATCHES_FOUND = 23

########NEW FILE########
__FILENAME__ = util
import locale
import re
import os
import posixpath
import shutil
import stat
import subprocess
import sys
import tarfile
import zipfile

from pip.exceptions import InstallationError, BadCommand
from pip.compat import(
    string_types, raw_input, console_to_str, stdlib_pkgs
)
from pip.locations import (
    site_packages, user_site, running_under_virtualenv, virtualenv_no_global,
    write_delete_marker_file
)
from pip.log import logger
from pip._vendor import pkg_resources
from pip._vendor.distlib import version

__all__ = ['rmtree', 'display_path', 'backup_dir',
           'find_command', 'ask', 'Inf',
           'normalize_name', 'splitext',
           'format_size', 'is_installable_dir',
           'is_svn_page', 'file_contents',
           'split_leading_dir', 'has_leading_dir',
           'make_path_relative', 'normalize_path',
           'renames', 'get_terminal_size', 'get_prog',
           'unzip_file', 'untar_file', 'unpack_file', 'call_subprocess']


def get_prog():
    try:
        if os.path.basename(sys.argv[0]) in ('__main__.py', '-c'):
            return "%s -m pip" % sys.executable
    except (AttributeError, TypeError, IndexError):
        pass
    return 'pip'


def rmtree(dir, ignore_errors=False):
    shutil.rmtree(dir, ignore_errors=ignore_errors,
                  onerror=rmtree_errorhandler)


def rmtree_errorhandler(func, path, exc_info):
    """On Windows, the files in .svn are read-only, so when rmtree() tries to
    remove them, an exception is thrown.  We catch that here, remove the
    read-only attribute, and hopefully continue without problems."""
    # if file type currently read only
    if os.stat(path).st_mode & stat.S_IREAD:
        # convert to read/write
        os.chmod(path, stat.S_IWRITE)
        # use the original function to repeat the operation
        func(path)
        return
    else:
        raise


def display_path(path):
    """Gives the display value for a given path, making it relative to cwd
    if possible."""
    path = os.path.normcase(os.path.abspath(path))
    if path.startswith(os.getcwd() + os.path.sep):
        path = '.' + path[len(os.getcwd()):]
    return path


def backup_dir(dir, ext='.bak'):
    """Figure out the name of a directory to back up the given dir to
    (adding .bak, .bak2, etc)"""
    n = 1
    extension = ext
    while os.path.exists(dir + extension):
        n += 1
        extension = ext + str(n)
    return dir + extension


def find_command(cmd, paths=None, pathext=None):
    """Searches the PATH for the given command and returns its path"""
    if paths is None:
        paths = os.environ.get('PATH', '').split(os.pathsep)
    if isinstance(paths, string_types):
        paths = [paths]
    # check if there are funny path extensions for executables, e.g. Windows
    if pathext is None:
        pathext = get_pathext()
    pathext = [ext for ext in pathext.lower().split(os.pathsep) if len(ext)]
    # don't use extensions if the command ends with one of them
    if os.path.splitext(cmd)[1].lower() in pathext:
        pathext = ['']
    # check if we find the command on PATH
    for path in paths:
        # try without extension first
        cmd_path = os.path.join(path, cmd)
        for ext in pathext:
            # then including the extension
            cmd_path_ext = cmd_path + ext
            if os.path.isfile(cmd_path_ext):
                return cmd_path_ext
        if os.path.isfile(cmd_path):
            return cmd_path
    raise BadCommand('Cannot find command %r' % cmd)


def get_pathext(default_pathext=None):
    """Returns the path extensions from environment or a default"""
    if default_pathext is None:
        default_pathext = os.pathsep.join(['.COM', '.EXE', '.BAT', '.CMD'])
    pathext = os.environ.get('PATHEXT', default_pathext)
    return pathext


def ask_path_exists(message, options):
    for action in os.environ.get('PIP_EXISTS_ACTION', '').split():
        if action in options:
            return action
    return ask(message, options)


def ask(message, options):
    """Ask the message interactively, with the given possible responses"""
    while 1:
        if os.environ.get('PIP_NO_INPUT'):
            raise Exception(
                'No input was expected ($PIP_NO_INPUT set); question: %s' %
                message
            )
        response = raw_input(message)
        response = response.strip().lower()
        if response not in options:
            print(
                'Your response (%r) was not one of the expected responses: '
                '%s' % (response, ', '.join(options))
            )
        else:
            return response


class _Inf(object):
    """I am bigger than everything!"""

    def __eq__(self, other):
        if self is other:
            return True
        else:
            return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def __lt__(self, other):
        return False

    def __le__(self, other):
        return False

    def __gt__(self, other):
        return True

    def __ge__(self, other):
        return True

    def __repr__(self):
        return 'Inf'


Inf = _Inf()  # this object is not currently used as a sortable in our code
del _Inf


_normalize_re = re.compile(r'[^a-z]', re.I)


def normalize_name(name):
    return _normalize_re.sub('-', name.lower())


def format_size(bytes):
    if bytes > 1000 * 1000:
        return '%.1fMB' % (bytes / 1000.0 / 1000)
    elif bytes > 10 * 1000:
        return '%ikB' % (bytes / 1000)
    elif bytes > 1000:
        return '%.1fkB' % (bytes / 1000.0)
    else:
        return '%ibytes' % bytes


def is_installable_dir(path):
    """Return True if `path` is a directory containing a setup.py file."""
    if not os.path.isdir(path):
        return False
    setup_py = os.path.join(path, 'setup.py')
    if os.path.isfile(setup_py):
        return True
    return False


def is_svn_page(html):
    """
    Returns true if the page appears to be the index page of an svn repository
    """
    return (re.search(r'<title>[^<]*Revision \d+:', html)
            and re.search(r'Powered by (?:<a[^>]*?>)?Subversion', html, re.I))


def file_contents(filename):
    fp = open(filename, 'rb')
    try:
        return fp.read().decode('utf-8')
    finally:
        fp.close()


def split_leading_dir(path):
    path = str(path)
    path = path.lstrip('/').lstrip('\\')
    if '/' in path and (('\\' in path and path.find('/') < path.find('\\'))
                        or '\\' not in path):
        return path.split('/', 1)
    elif '\\' in path:
        return path.split('\\', 1)
    else:
        return path, ''


def has_leading_dir(paths):
    """Returns true if all the paths have the same leading path name
    (i.e., everything is in one subdirectory in an archive)"""
    common_prefix = None
    for path in paths:
        prefix, rest = split_leading_dir(path)
        if not prefix:
            return False
        elif common_prefix is None:
            common_prefix = prefix
        elif prefix != common_prefix:
            return False
    return True


def make_path_relative(path, rel_to):
    """
    Make a filename relative, where the filename path, and it is
    relative to rel_to

        >>> make_path_relative('/usr/share/something/a-file.pth',
        ...                    '/usr/share/another-place/src/Directory')
        '../../../something/a-file.pth'
        >>> make_path_relative('/usr/share/something/a-file.pth',
        ...                    '/home/user/src/Directory')
        '../../../usr/share/something/a-file.pth'
        >>> make_path_relative('/usr/share/a-file.pth', '/usr/share/')
        'a-file.pth'
    """
    path_filename = os.path.basename(path)
    path = os.path.dirname(path)
    path = os.path.normpath(os.path.abspath(path))
    rel_to = os.path.normpath(os.path.abspath(rel_to))
    path_parts = path.strip(os.path.sep).split(os.path.sep)
    rel_to_parts = rel_to.strip(os.path.sep).split(os.path.sep)
    while path_parts and rel_to_parts and path_parts[0] == rel_to_parts[0]:
        path_parts.pop(0)
        rel_to_parts.pop(0)
    full_parts = ['..'] * len(rel_to_parts) + path_parts + [path_filename]
    if full_parts == ['']:
        return '.' + os.path.sep
    return os.path.sep.join(full_parts)


def normalize_path(path):
    """
    Convert a path to its canonical, case-normalized, absolute version.

    """
    return os.path.normcase(os.path.realpath(os.path.expanduser(path)))


def splitext(path):
    """Like os.path.splitext, but take off .tar too"""
    base, ext = posixpath.splitext(path)
    if base.lower().endswith('.tar'):
        ext = base[-4:] + ext
        base = base[:-4]
    return base, ext


def renames(old, new):
    """Like os.renames(), but handles renaming across devices."""
    # Implementation borrowed from os.renames().
    head, tail = os.path.split(new)
    if head and tail and not os.path.exists(head):
        os.makedirs(head)

    shutil.move(old, new)

    head, tail = os.path.split(old)
    if head and tail:
        try:
            os.removedirs(head)
        except OSError:
            pass


def is_local(path):
    """
    Return True if path is within sys.prefix, if we're running in a virtualenv.

    If we're not in a virtualenv, all paths are considered "local."

    """
    if not running_under_virtualenv():
        return True
    return normalize_path(path).startswith(normalize_path(sys.prefix))


def dist_is_local(dist):
    """
    Return True if given Distribution object is installed locally
    (i.e. within current virtualenv).

    Always True if we're not in a virtualenv.

    """
    return is_local(dist_location(dist))


def dist_in_usersite(dist):
    """
    Return True if given Distribution is installed in user site.
    """
    norm_path = normalize_path(dist_location(dist))
    return norm_path.startswith(normalize_path(user_site))


def dist_in_site_packages(dist):
    """
    Return True if given Distribution is installed in
    distutils.sysconfig.get_python_lib().
    """
    return normalize_path(
        dist_location(dist)
    ).startswith(normalize_path(site_packages))


def dist_is_editable(dist):
    """Is distribution an editable install?"""
    # TODO: factor out determining editableness out of FrozenRequirement
    from pip import FrozenRequirement
    req = FrozenRequirement.from_dist(dist, [])
    return req.editable


def get_installed_distributions(local_only=True,
                                skip=stdlib_pkgs,
                                include_editables=True,
                                editables_only=False):
    """
    Return a list of installed Distribution objects.

    If ``local_only`` is True (default), only return installations
    local to the current virtualenv, if in a virtualenv.

    ``skip`` argument is an iterable of lower-case project names to
    ignore; defaults to stdlib_pkgs

    If ``editables`` is False, don't report editables.

    If ``editables_only`` is True , only report editables.

    """
    if local_only:
        local_test = dist_is_local
    else:
        local_test = lambda d: True

    if include_editables:
        editable_test = lambda d: True
    else:
        editable_test = lambda d: not dist_is_editable(d)

    if editables_only:
        editables_only_test = lambda d: dist_is_editable(d)
    else:
        editables_only_test = lambda d: True

    return [d for d in pkg_resources.working_set
            if local_test(d)
            and d.key not in skip
            and editable_test(d)
            and editables_only_test(d)
            ]


def egg_link_path(dist):
    """
    Return the path for the .egg-link file if it exists, otherwise, None.

    There's 3 scenarios:
    1) not in a virtualenv
       try to find in site.USER_SITE, then site_packages
    2) in a no-global virtualenv
       try to find in site_packages
    3) in a yes-global virtualenv
       try to find in site_packages, then site.USER_SITE
       (don't look in global location)

    For #1 and #3, there could be odd cases, where there's an egg-link in 2
    locations.

    This method will just return the first one found.
    """
    sites = []
    if running_under_virtualenv():
        if virtualenv_no_global():
            sites.append(site_packages)
        else:
            sites.append(site_packages)
            if user_site:
                sites.append(user_site)
    else:
        if user_site:
            sites.append(user_site)
        sites.append(site_packages)

    for site in sites:
        egglink = os.path.join(site, dist.project_name) + '.egg-link'
        if os.path.isfile(egglink):
            return egglink


def dist_location(dist):
    """
    Get the site-packages location of this distribution. Generally
    this is dist.location, except in the case of develop-installed
    packages, where dist.location is the source code location, and we
    want to know where the egg-link file is.

    """
    egg_link = egg_link_path(dist)
    if egg_link:
        return egg_link
    return dist.location


def get_terminal_size():
    """Returns a tuple (x, y) representing the width(x) and the height(x)
    in characters of the terminal window."""
    def ioctl_GWINSZ(fd):
        try:
            import fcntl
            import termios
            import struct
            cr = struct.unpack(
                'hh',
                fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234')
            )
        except:
            return None
        if cr == (0, 0):
            return None
        if cr == (0, 0):
            return None
        return cr
    cr = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)
    if not cr:
        try:
            fd = os.open(os.ctermid(), os.O_RDONLY)
            cr = ioctl_GWINSZ(fd)
            os.close(fd)
        except:
            pass
    if not cr:
        cr = (os.environ.get('LINES', 25), os.environ.get('COLUMNS', 80))
    return int(cr[1]), int(cr[0])


def current_umask():
    """Get the current umask which involves having to set it temporarily."""
    mask = os.umask(0)
    os.umask(mask)
    return mask


def unzip_file(filename, location, flatten=True):
    """
    Unzip the file (with path `filename`) to the destination `location`.  All
    files are written based on system defaults and umask (i.e. permissions are
    not preserved), except that regular file members with any execute
    permissions (user, group, or world) have "chmod +x" applied after being
    written. Note that for windows, any execute changes using os.chmod are
    no-ops per the python docs.
    """
    if not os.path.exists(location):
        os.makedirs(location)
    zipfp = open(filename, 'rb')
    try:
        zip = zipfile.ZipFile(zipfp)
        leading = has_leading_dir(zip.namelist()) and flatten
        for info in zip.infolist():
            name = info.filename
            data = zip.read(name)
            fn = name
            if leading:
                fn = split_leading_dir(name)[1]
            fn = os.path.join(location, fn)
            dir = os.path.dirname(fn)
            if not os.path.exists(dir):
                os.makedirs(dir)
            if fn.endswith('/') or fn.endswith('\\'):
                # A directory
                if not os.path.exists(fn):
                    os.makedirs(fn)
            else:
                fp = open(fn, 'wb')
                try:
                    fp.write(data)
                finally:
                    fp.close()
                    mode = info.external_attr >> 16
                    # if mode and regular file and any execute permissions for
                    # user/group/world?
                    if mode and stat.S_ISREG(mode) and mode & 0o111:
                        # make dest file have execute for user/group/world
                        # (chmod +x) no-op on windows per python docs
                        os.chmod(fn, (0o777 - current_umask() | 0o111))
    finally:
        zipfp.close()


def untar_file(filename, location):
    """
    Untar the file (with path `filename`) to the destination `location`.
    All files are written based on system defaults and umask (i.e. permissions
    are not preserved), except that regular file members with any execute
    permissions (user, group, or world) have "chmod +x" applied after being
    written.  Note that for windows, any execute changes using os.chmod are
    no-ops per the python docs.
    """
    if not os.path.exists(location):
        os.makedirs(location)
    if filename.lower().endswith('.gz') or filename.lower().endswith('.tgz'):
        mode = 'r:gz'
    elif (filename.lower().endswith('.bz2')
            or filename.lower().endswith('.tbz')):
        mode = 'r:bz2'
    elif filename.lower().endswith('.tar'):
        mode = 'r'
    else:
        logger.warn('Cannot determine compression type for file %s' % filename)
        mode = 'r:*'
    tar = tarfile.open(filename, mode)
    try:
        # note: python<=2.5 doesn't seem to know about pax headers, filter them
        leading = has_leading_dir([
            member.name for member in tar.getmembers()
            if member.name != 'pax_global_header'
        ])
        for member in tar.getmembers():
            fn = member.name
            if fn == 'pax_global_header':
                continue
            if leading:
                fn = split_leading_dir(fn)[1]
            path = os.path.join(location, fn)
            if member.isdir():
                if not os.path.exists(path):
                    os.makedirs(path)
            elif member.issym():
                try:
                    tar._extract_member(member, path)
                except Exception as exc:
                    # Some corrupt tar files seem to produce this
                    # (specifically bad symlinks)
                    logger.warn(
                        'In the tar file %s the member %s is invalid: %s'
                        % (filename, member.name, exc))
                    continue
            else:
                try:
                    fp = tar.extractfile(member)
                except (KeyError, AttributeError) as exc:
                    # Some corrupt tar files seem to produce this
                    # (specifically bad symlinks)
                    logger.warn(
                        'In the tar file %s the member %s is invalid: %s'
                        % (filename, member.name, exc))
                    continue
                if not os.path.exists(os.path.dirname(path)):
                    os.makedirs(os.path.dirname(path))
                destfp = open(path, 'wb')
                try:
                    shutil.copyfileobj(fp, destfp)
                finally:
                    destfp.close()
                fp.close()
                # member have any execute permissions for user/group/world?
                if member.mode & 0o111:
                    # make dest file have execute for user/group/world
                    # no-op on windows per python docs
                    os.chmod(path, (0o777 - current_umask() | 0o111))
    finally:
        tar.close()


def unpack_file(filename, location, content_type, link):
    filename = os.path.realpath(filename)
    if (content_type == 'application/zip'
            or filename.endswith('.zip')
            or filename.endswith('.whl')
            or zipfile.is_zipfile(filename)):
        unzip_file(
            filename,
            location,
            flatten=not filename.endswith('.whl')
        )
    elif (content_type == 'application/x-gzip'
            or tarfile.is_tarfile(filename)
            or splitext(filename)[1].lower() in (
                '.tar', '.tar.gz', '.tar.bz2', '.tgz', '.tbz')):
        untar_file(filename, location)
    elif (content_type and content_type.startswith('text/html')
            and is_svn_page(file_contents(filename))):
        # We don't really care about this
        from pip.vcs.subversion import Subversion
        Subversion('svn+' + link.url).unpack(location)
    else:
        # FIXME: handle?
        # FIXME: magic signatures?
        logger.fatal(
            'Cannot unpack file %s (downloaded from %s, content-type: %s); '
            'cannot detect archive format' %
            (filename, location, content_type)
        )
        raise InstallationError(
            'Cannot determine archive format of %s' % location
        )


def call_subprocess(cmd, show_stdout=True,
                    filter_stdout=None, cwd=None,
                    raise_on_returncode=True,
                    command_level=logger.DEBUG, command_desc=None,
                    extra_environ=None):
    if command_desc is None:
        cmd_parts = []
        for part in cmd:
            if ' ' in part or '\n' in part or '"' in part or "'" in part:
                part = '"%s"' % part.replace('"', '\\"')
            cmd_parts.append(part)
        command_desc = ' '.join(cmd_parts)
    if show_stdout:
        stdout = None
    else:
        stdout = subprocess.PIPE
    logger.log(command_level, "Running command %s" % command_desc)
    env = os.environ.copy()
    if extra_environ:
        env.update(extra_environ)
    try:
        proc = subprocess.Popen(
            cmd, stderr=subprocess.STDOUT, stdin=None, stdout=stdout,
            cwd=cwd, env=env)
    except Exception as exc:
        logger.fatal(
            "Error %s while executing command %s" % (exc, command_desc))
        raise
    all_output = []
    if stdout is not None:
        stdout = proc.stdout
        while 1:
            line = console_to_str(stdout.readline())
            if not line:
                break
            line = line.rstrip()
            all_output.append(line + '\n')
            if filter_stdout:
                level = filter_stdout(line)
                if isinstance(level, tuple):
                    level, line = level
                logger.log(level, line)
                if not logger.stdout_level_matches(level):
                    logger.show_progress()
            else:
                logger.info(line)
    else:
        returned_stdout, returned_stderr = proc.communicate()
        all_output = [returned_stdout or '']
    proc.wait()
    if proc.returncode:
        if raise_on_returncode:
            if all_output:
                logger.notify(
                    'Complete output from command %s:' % command_desc
                )
                logger.notify(
                    '\n'.join(all_output) +
                    '\n----------------------------------------'
                )
            raise InstallationError(
                'Command "%s" failed with error code %s in %s'
                % (command_desc, proc.returncode, cwd))
        else:
            logger.warn(
                'Command "%s" had error code %s in %s'
                % (command_desc, proc.returncode, cwd))
    if stdout is not None:
        return ''.join(all_output)


def is_prerelease(vers):
    """
    Attempt to determine if this is a pre-release using PEP386/PEP426 rules.

    Will return True if it is a pre-release and False if not. Versions are
    assumed to be a pre-release if they cannot be parsed.
    """
    normalized = version._suggest_normalized_version(vers)

    if normalized is None:
        # Cannot normalize, assume it is a pre-release
        return True

    parsed = version._normalized_key(normalized)
    return any([
        any([y in set(["a", "b", "c", "rc", "dev"]) for y in x])
        for x in parsed
    ])


def read_text_file(filename):
    """Return the contents of *filename*.

    Try to decode the file contents with utf-8, the preferred system encoding
    (e.g., cp1252 on some Windows machines), and latin1, in that order.
    Decoding a byte string with latin1 will never raise an error. In the worst
    case, the returned string will contain some garbage characters.

    """
    with open(filename, 'rb') as fp:
        data = fp.read()

    encodings = ['utf-8', locale.getpreferredencoding(False), 'latin1']
    for enc in encodings:
        try:
            data = data.decode(enc)
        except UnicodeDecodeError:
            continue
        break

    assert type(data) != bytes  # Latin1 should have worked.
    return data


def _make_build_dir(build_dir):
    os.makedirs(build_dir)
    write_delete_marker_file(build_dir)


class FakeFile(object):
    """Wrap a list of lines in an object with readline() to make
    ConfigParser happy."""
    def __init__(self, lines):
        self._gen = (l for l in lines)

    def readline(self):
        try:
            try:
                return next(self._gen)
            except NameError:
                return self._gen.next()
        except StopIteration:
            return ''

    def __iter__(self):
        return self._gen

########NEW FILE########
__FILENAME__ = bazaar
import os
import tempfile
import re
from pip.compat import urlparse
from pip.log import logger
from pip.util import rmtree, display_path, call_subprocess
from pip.vcs import vcs, VersionControl
from pip.download import path_to_url


class Bazaar(VersionControl):
    name = 'bzr'
    dirname = '.bzr'
    repo_name = 'branch'
    schemes = (
        'bzr', 'bzr+http', 'bzr+https', 'bzr+ssh', 'bzr+sftp', 'bzr+ftp',
        'bzr+lp',
    )

    def __init__(self, url=None, *args, **kwargs):
        super(Bazaar, self).__init__(url, *args, **kwargs)
        # Python >= 2.7.4, 3.3 doesn't have uses_fragment or non_hierarchical
        # Register lp but do not expose as a scheme to support bzr+lp.
        if getattr(urlparse, 'uses_fragment', None):
            urlparse.uses_fragment.extend(['lp'])
            urlparse.non_hierarchical.extend(['lp'])

    def export(self, location):
        """
        Export the Bazaar repository at the url to the destination location
        """
        temp_dir = tempfile.mkdtemp('-export', 'pip-')
        self.unpack(temp_dir)
        if os.path.exists(location):
            # Remove the location to make sure Bazaar can export it correctly
            rmtree(location)
        try:
            call_subprocess([self.cmd, 'export', location], cwd=temp_dir,
                            filter_stdout=self._filter, show_stdout=False)
        finally:
            rmtree(temp_dir)

    def switch(self, dest, url, rev_options):
        call_subprocess([self.cmd, 'switch', url], cwd=dest)

    def update(self, dest, rev_options):
        call_subprocess(
            [self.cmd, 'pull', '-q'] + rev_options, cwd=dest)

    def obtain(self, dest):
        url, rev = self.get_url_rev()
        if rev:
            rev_options = ['-r', rev]
            rev_display = ' (to revision %s)' % rev
        else:
            rev_options = []
            rev_display = ''
        if self.check_destination(dest, url, rev_options, rev_display):
            logger.notify('Checking out %s%s to %s'
                          % (url, rev_display, display_path(dest)))
            call_subprocess(
                [self.cmd, 'branch', '-q'] + rev_options + [url, dest])

    def get_url_rev(self):
        # hotfix the URL scheme after removing bzr+ from bzr+ssh:// readd it
        url, rev = super(Bazaar, self).get_url_rev()
        if url.startswith('ssh://'):
            url = 'bzr+' + url
        return url, rev

    def get_url(self, location):
        urls = call_subprocess(
            [self.cmd, 'info'], show_stdout=False, cwd=location)
        for line in urls.splitlines():
            line = line.strip()
            for x in ('checkout of branch: ',
                      'parent branch: '):
                if line.startswith(x):
                    repo = line.split(x)[1]
                    if self._is_local_repository(repo):
                        return path_to_url(repo)
                    return repo
        return None

    def get_revision(self, location):
        revision = call_subprocess(
            [self.cmd, 'revno'], show_stdout=False, cwd=location)
        return revision.splitlines()[-1]

    def get_tag_revs(self, location):
        tags = call_subprocess(
            [self.cmd, 'tags'], show_stdout=False, cwd=location)
        tag_revs = []
        for line in tags.splitlines():
            tags_match = re.search(r'([.\w-]+)\s*(.*)$', line)
            if tags_match:
                tag = tags_match.group(1)
                rev = tags_match.group(2)
                tag_revs.append((rev.strip(), tag.strip()))
        return dict(tag_revs)

    def get_src_requirement(self, dist, location, find_tags):
        repo = self.get_url(location)
        if not repo.lower().startswith('bzr:'):
            repo = 'bzr+' + repo
        egg_project_name = dist.egg_name().split('-', 1)[0]
        if not repo:
            return None
        current_rev = self.get_revision(location)
        tag_revs = self.get_tag_revs(location)

        if current_rev in tag_revs:
            # It's a tag
            full_egg_name = '%s-%s' % (egg_project_name, tag_revs[current_rev])
        else:
            full_egg_name = '%s-dev_r%s' % (dist.egg_name(), current_rev)
        return '%s@%s#egg=%s' % (repo, current_rev, full_egg_name)


vcs.register(Bazaar)

########NEW FILE########
__FILENAME__ = git
import tempfile
import os.path

from pip.util import call_subprocess
from pip.util import display_path, rmtree
from pip.vcs import vcs, VersionControl
from pip.log import logger
from pip.compat import url2pathname, urlparse

urlsplit = urlparse.urlsplit
urlunsplit = urlparse.urlunsplit


class Git(VersionControl):
    name = 'git'
    dirname = '.git'
    repo_name = 'clone'
    schemes = (
        'git', 'git+http', 'git+https', 'git+ssh', 'git+git', 'git+file',
    )

    def __init__(self, url=None, *args, **kwargs):

        # Works around an apparent Git bug
        # (see http://article.gmane.org/gmane.comp.version-control.git/146500)
        if url:
            scheme, netloc, path, query, fragment = urlsplit(url)
            if scheme.endswith('file'):
                initial_slashes = path[:-len(path.lstrip('/'))]
                newpath = (
                    initial_slashes +
                    url2pathname(path).replace('\\', '/').lstrip('/')
                )
                url = urlunsplit((scheme, netloc, newpath, query, fragment))
                after_plus = scheme.find('+') + 1
                url = scheme[:after_plus] + urlunsplit(
                    (scheme[after_plus:], netloc, newpath, query, fragment),
                )

        super(Git, self).__init__(url, *args, **kwargs)

    def export(self, location):
        """Export the Git repository at the url to the destination location"""
        temp_dir = tempfile.mkdtemp('-export', 'pip-')
        self.unpack(temp_dir)
        try:
            if not location.endswith('/'):
                location = location + '/'
            call_subprocess(
                [self.cmd, 'checkout-index', '-a', '-f', '--prefix', location],
                filter_stdout=self._filter, show_stdout=False, cwd=temp_dir)
        finally:
            rmtree(temp_dir)

    def check_rev_options(self, rev, dest, rev_options):
        """Check the revision options before checkout to compensate that tags
        and branches may need origin/ as a prefix.
        Returns the SHA1 of the branch or tag if found.
        """
        revisions = self.get_refs(dest)

        origin_rev = 'origin/%s' % rev
        if origin_rev in revisions:
            # remote branch
            return [revisions[origin_rev]]
        elif rev in revisions:
            # a local tag or branch name
            return [revisions[rev]]
        else:
            logger.warn(
                "Could not find a tag or branch '%s', assuming commit." % rev,
            )
            return rev_options

    def switch(self, dest, url, rev_options):
        call_subprocess(
            [self.cmd, 'config', 'remote.origin.url', url], cwd=dest)
        call_subprocess(
            [self.cmd, 'checkout', '-q'] + rev_options, cwd=dest)

        self.update_submodules(dest)

    def update(self, dest, rev_options):
        # First fetch changes from the default remote
        call_subprocess([self.cmd, 'fetch', '-q'], cwd=dest)
        # Then reset to wanted revision (maby even origin/master)
        if rev_options:
            rev_options = self.check_rev_options(
                rev_options[0], dest, rev_options,
            )
        call_subprocess(
            [self.cmd, 'reset', '--hard', '-q'] + rev_options,
            cwd=dest,
        )
        #: update submodules
        self.update_submodules(dest)

    def obtain(self, dest):
        url, rev = self.get_url_rev()
        if rev:
            rev_options = [rev]
            rev_display = ' (to %s)' % rev
        else:
            rev_options = ['origin/master']
            rev_display = ''
        if self.check_destination(dest, url, rev_options, rev_display):
            logger.notify(
                'Cloning %s%s to %s' % (url, rev_display, display_path(dest)),
            )
            call_subprocess([self.cmd, 'clone', '-q', url, dest])
            #: repo may contain submodules
            self.update_submodules(dest)
            if rev:
                rev_options = self.check_rev_options(rev, dest, rev_options)
                # Only do a checkout if rev_options differs from HEAD
                if not self.get_revision(dest).startswith(rev_options[0]):
                    call_subprocess(
                        [self.cmd, 'checkout', '-q'] + rev_options,
                        cwd=dest,
                    )

    def get_url(self, location):
        url = call_subprocess(
            [self.cmd, 'config', 'remote.origin.url'],
            show_stdout=False, cwd=location)
        return url.strip()

    def get_revision(self, location):
        current_rev = call_subprocess(
            [self.cmd, 'rev-parse', 'HEAD'], show_stdout=False, cwd=location)
        return current_rev.strip()

    def get_refs(self, location):
        """Return map of named refs (branches or tags) to commit hashes."""
        output = call_subprocess([self.cmd, 'show-ref'],
                                 show_stdout=False, cwd=location)
        rv = {}
        for line in output.strip().splitlines():
            commit, ref = line.split(' ', 1)
            ref = ref.strip()
            ref_name = None
            if ref.startswith('refs/remotes/'):
                ref_name = ref[len('refs/remotes/'):]
            elif ref.startswith('refs/heads/'):
                ref_name = ref[len('refs/heads/'):]
            elif ref.startswith('refs/tags/'):
                ref_name = ref[len('refs/tags/'):]
            if ref_name is not None:
                rv[ref_name] = commit.strip()
        return rv

    def get_src_requirement(self, dist, location, find_tags):
        repo = self.get_url(location)
        if not repo.lower().startswith('git:'):
            repo = 'git+' + repo
        egg_project_name = dist.egg_name().split('-', 1)[0]
        if not repo:
            return None
        current_rev = self.get_revision(location)
        refs = self.get_refs(location)
        # refs maps names to commit hashes; we need the inverse
        # if multiple names map to a single commit, this arbitrarily picks one
        names_by_commit = dict((commit, ref) for ref, commit in refs.items())

        if current_rev in names_by_commit:
            # It's a tag
            full_egg_name = (
                '%s-%s' % (egg_project_name, names_by_commit[current_rev])
            )
        else:
            full_egg_name = '%s-dev' % egg_project_name

        return '%s@%s#egg=%s' % (repo, current_rev, full_egg_name)

    def get_url_rev(self):
        """
        Prefixes stub URLs like 'user@hostname:user/repo.git' with 'ssh://'.
        That's required because although they use SSH they sometimes doesn't
        work with a ssh:// scheme (e.g. Github). But we need a scheme for
        parsing. Hence we remove it again afterwards and return it as a stub.
        """
        if '://' not in self.url:
            assert 'file:' not in self.url
            self.url = self.url.replace('git+', 'git+ssh://')
            url, rev = super(Git, self).get_url_rev()
            url = url.replace('ssh://', '')
        else:
            url, rev = super(Git, self).get_url_rev()

        return url, rev

    def update_submodules(self, location):
        if not os.path.exists(os.path.join(location, '.gitmodules')):
            return
        call_subprocess(
            [self.cmd, 'submodule', 'update', '--init', '--recursive', '-q'],
            cwd=location,
        )

vcs.register(Git)

########NEW FILE########
__FILENAME__ = mercurial
import os
import tempfile
import re

from pip.util import call_subprocess
from pip.util import display_path, rmtree
from pip.log import logger
from pip.vcs import vcs, VersionControl
from pip.download import path_to_url
from pip.compat import ConfigParser


class Mercurial(VersionControl):
    name = 'hg'
    dirname = '.hg'
    repo_name = 'clone'
    schemes = ('hg', 'hg+http', 'hg+https', 'hg+ssh', 'hg+static-http')

    def export(self, location):
        """Export the Hg repository at the url to the destination location"""
        temp_dir = tempfile.mkdtemp('-export', 'pip-')
        self.unpack(temp_dir)
        try:
            call_subprocess(
                [self.cmd, 'archive', location],
                filter_stdout=self._filter, show_stdout=False, cwd=temp_dir)
        finally:
            rmtree(temp_dir)

    def switch(self, dest, url, rev_options):
        repo_config = os.path.join(dest, self.dirname, 'hgrc')
        config = ConfigParser.SafeConfigParser()
        try:
            config.read(repo_config)
            config.set('paths', 'default', url)
            config_file = open(repo_config, 'w')
            config.write(config_file)
            config_file.close()
        except (OSError, ConfigParser.NoSectionError) as exc:
            logger.warn(
                'Could not switch Mercurial repository to %s: %s'
                % (url, exc))
        else:
            call_subprocess([self.cmd, 'update', '-q'] + rev_options, cwd=dest)

    def update(self, dest, rev_options):
        call_subprocess([self.cmd, 'pull', '-q'], cwd=dest)
        call_subprocess(
            [self.cmd, 'update', '-q'] + rev_options, cwd=dest)

    def obtain(self, dest):
        url, rev = self.get_url_rev()
        if rev:
            rev_options = [rev]
            rev_display = ' (to revision %s)' % rev
        else:
            rev_options = []
            rev_display = ''
        if self.check_destination(dest, url, rev_options, rev_display):
            logger.notify('Cloning hg %s%s to %s'
                          % (url, rev_display, display_path(dest)))
            call_subprocess([self.cmd, 'clone', '--noupdate', '-q', url, dest])
            call_subprocess([self.cmd, 'update', '-q'] + rev_options, cwd=dest)

    def get_url(self, location):
        url = call_subprocess(
            [self.cmd, 'showconfig', 'paths.default'],
            show_stdout=False, cwd=location).strip()
        if self._is_local_repository(url):
            url = path_to_url(url)
        return url.strip()

    def get_tag_revs(self, location):
        tags = call_subprocess(
            [self.cmd, 'tags'], show_stdout=False, cwd=location)
        tag_revs = []
        for line in tags.splitlines():
            tags_match = re.search(r'([\w\d\.-]+)\s*([\d]+):.*$', line)
            if tags_match:
                tag = tags_match.group(1)
                rev = tags_match.group(2)
                if "tip" != tag:
                    tag_revs.append((rev.strip(), tag.strip()))
        return dict(tag_revs)

    def get_branch_revs(self, location):
        branches = call_subprocess(
            [self.cmd, 'branches'], show_stdout=False, cwd=location)
        branch_revs = []
        for line in branches.splitlines():
            branches_match = re.search(r'([\w\d\.-]+)\s*([\d]+):.*$', line)
            if branches_match:
                branch = branches_match.group(1)
                rev = branches_match.group(2)
                if "default" != branch:
                    branch_revs.append((rev.strip(), branch.strip()))
        return dict(branch_revs)

    def get_revision(self, location):
        current_revision = call_subprocess(
            [self.cmd, 'parents', '--template={rev}'],
            show_stdout=False, cwd=location).strip()
        return current_revision

    def get_revision_hash(self, location):
        current_rev_hash = call_subprocess(
            [self.cmd, 'parents', '--template={node}'],
            show_stdout=False, cwd=location).strip()
        return current_rev_hash

    def get_src_requirement(self, dist, location, find_tags):
        repo = self.get_url(location)
        if not repo.lower().startswith('hg:'):
            repo = 'hg+' + repo
        egg_project_name = dist.egg_name().split('-', 1)[0]
        if not repo:
            return None
        current_rev = self.get_revision(location)
        current_rev_hash = self.get_revision_hash(location)
        tag_revs = self.get_tag_revs(location)
        branch_revs = self.get_branch_revs(location)
        if current_rev in tag_revs:
            # It's a tag
            full_egg_name = '%s-%s' % (egg_project_name, tag_revs[current_rev])
        elif current_rev in branch_revs:
            # It's the tip of a branch
            full_egg_name = '%s-%s' % (
                egg_project_name,
                branch_revs[current_rev],
            )
        else:
            full_egg_name = '%s-dev' % egg_project_name
        return '%s@%s#egg=%s' % (repo, current_rev_hash, full_egg_name)

vcs.register(Mercurial)

########NEW FILE########
__FILENAME__ = subversion
import os
import re
from pip.compat import urlparse
from pip.util import rmtree, display_path, call_subprocess
from pip.log import logger
from pip.vcs import vcs, VersionControl

_svn_xml_url_re = re.compile('url="([^"]+)"')
_svn_rev_re = re.compile('committed-rev="(\d+)"')
_svn_url_re = re.compile(r'URL: (.+)')
_svn_revision_re = re.compile(r'Revision: (.+)')
_svn_info_xml_rev_re = re.compile(r'\s*revision="(\d+)"')
_svn_info_xml_url_re = re.compile(r'<url>(.*)</url>')


class Subversion(VersionControl):
    name = 'svn'
    dirname = '.svn'
    repo_name = 'checkout'
    schemes = ('svn', 'svn+ssh', 'svn+http', 'svn+https', 'svn+svn')

    def get_info(self, location):
        """Returns (url, revision), where both are strings"""
        assert not location.rstrip('/').endswith(self.dirname), \
            'Bad directory: %s' % location
        output = call_subprocess(
            [self.cmd, 'info', location],
            show_stdout=False,
            extra_environ={'LANG': 'C'},
        )
        match = _svn_url_re.search(output)
        if not match:
            logger.warn(
                'Cannot determine URL of svn checkout %s' %
                display_path(location)
            )
            return None, None
        url = match.group(1).strip()
        match = _svn_revision_re.search(output)
        if not match:
            logger.warn(
                'Cannot determine revision of svn checkout %s' %
                display_path(location)
            )
            logger.info('Output that cannot be parsed: \n%s' % output)
            return url, None
        return url, match.group(1)

    def export(self, location):
        """Export the svn repository at the url to the destination location"""
        url, rev = self.get_url_rev()
        rev_options = get_rev_options(url, rev)
        logger.notify('Exporting svn repository %s to %s' % (url, location))
        logger.indent += 2
        try:
            if os.path.exists(location):
                # Subversion doesn't like to check out over an existing
                # directory --force fixes this, but was only added in svn 1.5
                rmtree(location)
            call_subprocess(
                [self.cmd, 'export'] + rev_options + [url, location],
                filter_stdout=self._filter, show_stdout=False)
        finally:
            logger.indent -= 2

    def switch(self, dest, url, rev_options):
        call_subprocess(
            [self.cmd, 'switch'] + rev_options + [url, dest])

    def update(self, dest, rev_options):
        call_subprocess(
            [self.cmd, 'update'] + rev_options + [dest])

    def obtain(self, dest):
        url, rev = self.get_url_rev()
        rev_options = get_rev_options(url, rev)
        if rev:
            rev_display = ' (to revision %s)' % rev
        else:
            rev_display = ''
        if self.check_destination(dest, url, rev_options, rev_display):
            logger.notify('Checking out %s%s to %s'
                          % (url, rev_display, display_path(dest)))
            call_subprocess(
                [self.cmd, 'checkout', '-q'] + rev_options + [url, dest])

    def get_revision(self, location):
        """
        Return the maximum revision for all files under a given location
        """
        # Note: taken from setuptools.command.egg_info
        revision = 0

        for base, dirs, files in os.walk(location):
            if self.dirname not in dirs:
                dirs[:] = []
                continue    # no sense walking uncontrolled subdirs
            dirs.remove(self.dirname)
            entries_fn = os.path.join(base, self.dirname, 'entries')
            if not os.path.exists(entries_fn):
                # FIXME: should we warn?
                continue

            dirurl, localrev = self._get_svn_url_rev(base)

            if base == location:
                base_url = dirurl + '/'   # save the root url
            elif not dirurl or not dirurl.startswith(base_url):
                dirs[:] = []
                continue    # not part of the same svn tree, skip it
            revision = max(revision, localrev)
        return revision

    def get_url_rev(self):
        # hotfix the URL scheme after removing svn+ from svn+ssh:// readd it
        url, rev = super(Subversion, self).get_url_rev()
        if url.startswith('ssh://'):
            url = 'svn+' + url
        return url, rev

    def get_url(self, location):
        # In cases where the source is in a subdirectory, not alongside
        # setup.py we have to look up in the location until we find a real
        # setup.py
        orig_location = location
        while not os.path.exists(os.path.join(location, 'setup.py')):
            last_location = location
            location = os.path.dirname(location)
            if location == last_location:
                # We've traversed up to the root of the filesystem without
                # finding setup.py
                logger.warn(
                    "Could not find setup.py for directory %s (tried all "
                    "parent directories)" %
                    orig_location
                )
                return None

        return self._get_svn_url_rev(location)[0]

    def _get_svn_url_rev(self, location):
        from pip.exceptions import InstallationError

        f = open(os.path.join(location, self.dirname, 'entries'))
        data = f.read()
        f.close()
        if (data.startswith('8')
                or data.startswith('9')
                or data.startswith('10')):
            data = list(map(str.splitlines, data.split('\n\x0c\n')))
            del data[0][0]  # get rid of the '8'
            url = data[0][3]
            revs = [int(d[9]) for d in data if len(d) > 9 and d[9]] + [0]
        elif data.startswith('<?xml'):
            match = _svn_xml_url_re.search(data)
            if not match:
                raise ValueError('Badly formatted data: %r' % data)
            url = match.group(1)    # get repository URL
            revs = [int(m.group(1)) for m in _svn_rev_re.finditer(data)] + [0]
        else:
            try:
                # subversion >= 1.7
                xml = call_subprocess(
                    [self.cmd, 'info', '--xml', location],
                    show_stdout=False,
                )
                url = _svn_info_xml_url_re.search(xml).group(1)
                revs = [
                    int(m.group(1)) for m in _svn_info_xml_rev_re.finditer(xml)
                ]
            except InstallationError:
                url, revs = None, []

        if revs:
            rev = max(revs)
        else:
            rev = 0

        return url, rev

    def get_tag_revs(self, svn_tag_url):
        stdout = call_subprocess(
            [self.cmd, 'ls', '-v', svn_tag_url], show_stdout=False)
        results = []
        for line in stdout.splitlines():
            parts = line.split()
            rev = int(parts[0])
            tag = parts[-1].strip('/')
            results.append((tag, rev))
        return results

    def find_tag_match(self, rev, tag_revs):
        best_match_rev = None
        best_tag = None
        for tag, tag_rev in tag_revs:
            if (tag_rev > rev and
                    (best_match_rev is None or best_match_rev > tag_rev)):
                # FIXME: Is best_match > tag_rev really possible?
                # or is it a sign something is wacky?
                best_match_rev = tag_rev
                best_tag = tag
        return best_tag

    def get_src_requirement(self, dist, location, find_tags=False):
        repo = self.get_url(location)
        if repo is None:
            return None
        parts = repo.split('/')
        # FIXME: why not project name?
        egg_project_name = dist.egg_name().split('-', 1)[0]
        rev = self.get_revision(location)
        if parts[-2] in ('tags', 'tag'):
            # It's a tag, perfect!
            full_egg_name = '%s-%s' % (egg_project_name, parts[-1])
        elif parts[-2] in ('branches', 'branch'):
            # It's a branch :(
            full_egg_name = '%s-%s-r%s' % (dist.egg_name(), parts[-1], rev)
        elif parts[-1] == 'trunk':
            # Trunk :-/
            full_egg_name = '%s-dev_r%s' % (dist.egg_name(), rev)
            if find_tags:
                tag_url = '/'.join(parts[:-1]) + '/tags'
                tag_revs = self.get_tag_revs(tag_url)
                match = self.find_tag_match(rev, tag_revs)
                if match:
                    logger.notify(
                        'trunk checkout %s seems to be equivalent to tag %s' %
                        match
                    )
                    repo = '%s/%s' % (tag_url, match)
                    full_egg_name = '%s-%s' % (egg_project_name, match)
        else:
            # Don't know what it is
            logger.warn(
                'svn URL does not fit normal structure (tags/branches/trunk): '
                '%s' % repo
            )
            full_egg_name = '%s-dev_r%s' % (egg_project_name, rev)
        return 'svn+%s@%s#egg=%s' % (repo, rev, full_egg_name)


def get_rev_options(url, rev):
    if rev:
        rev_options = ['-r', rev]
    else:
        rev_options = []

    r = urlparse.urlsplit(url)
    if hasattr(r, 'username'):
        # >= Python-2.5
        username, password = r.username, r.password
    else:
        netloc = r[1]
        if '@' in netloc:
            auth = netloc.split('@')[0]
            if ':' in auth:
                username, password = auth.split(':', 1)
            else:
                username, password = auth, None
        else:
            username, password = None, None

    if username:
        rev_options += ['--username', username]
    if password:
        rev_options += ['--password', password]
    return rev_options


vcs.register(Subversion)

########NEW FILE########
__FILENAME__ = wheel
"""
Support for installing and building the "wheel" binary package format.
"""
from __future__ import with_statement

import compileall
import csv
import functools
import hashlib
import os
import re
import shutil
import sys

from base64 import urlsafe_b64encode
from email.parser import Parser

from pip.compat import ConfigParser, StringIO, binary
from pip.exceptions import InvalidWheelFilename, UnsupportedWheel
from pip.locations import distutils_scheme
from pip.log import logger
from pip import pep425tags
from pip.util import call_subprocess, normalize_path, make_path_relative
from pip._vendor.distlib.scripts import ScriptMaker
from pip._vendor import pkg_resources


wheel_ext = '.whl'

VERSION_COMPATIBLE = (1, 0)


def rehash(path, algo='sha256', blocksize=1 << 20):
    """Return (hash, length) for path using hashlib.new(algo)"""
    h = hashlib.new(algo)
    length = 0
    with open(path, 'rb') as f:
        block = f.read(blocksize)
        while block:
            length += len(block)
            h.update(block)
            block = f.read(blocksize)
    digest = 'sha256=' + urlsafe_b64encode(
        h.digest()
    ).decode('latin1').rstrip('=')
    return (digest, length)


def open_for_csv(name, mode):
    if sys.version_info[0] < 3:
        nl = {}
        bin = 'b'
    else:
        nl = {'newline': ''}
        bin = ''
    return open(name, mode + bin, **nl)


def fix_script(path):
    """Replace #!python with #!/path/to/python
    Return True if file was changed."""
    # XXX RECORD hashes will need to be updated
    if os.path.isfile(path):
        script = open(path, 'rb')
        try:
            firstline = script.readline()
            if not firstline.startswith(binary('#!python')):
                return False
            exename = sys.executable.encode(sys.getfilesystemencoding())
            firstline = binary('#!') + exename + binary(os.linesep)
            rest = script.read()
        finally:
            script.close()
        script = open(path, 'wb')
        try:
            script.write(firstline)
            script.write(rest)
        finally:
            script.close()
        return True

dist_info_re = re.compile(r"""^(?P<namever>(?P<name>.+?)(-(?P<ver>\d.+?))?)
                                \.dist-info$""", re.VERBOSE)


def root_is_purelib(name, wheeldir):
    """
    Return True if the extracted wheel in wheeldir should go into purelib.
    """
    name_folded = name.replace("-", "_")
    for item in os.listdir(wheeldir):
        match = dist_info_re.match(item)
        if match and match.group('name') == name_folded:
            with open(os.path.join(wheeldir, item, 'WHEEL')) as wheel:
                for line in wheel:
                    line = line.lower().rstrip()
                    if line == "root-is-purelib: true":
                        return True
    return False


def get_entrypoints(filename):
    if not os.path.exists(filename):
        return {}, {}

    # This is done because you can pass a string to entry_points wrappers which
    # means that they may or may not be valid INI files. The attempt here is to
    # strip leading and trailing whitespace in order to make them valid INI
    # files.
    with open(filename) as fp:
        data = StringIO()
        for line in fp:
            data.write(line.strip())
            data.write("\n")
        data.seek(0)

    cp = ConfigParser.RawConfigParser()
    cp.readfp(data)

    console = {}
    gui = {}
    if cp.has_section('console_scripts'):
        console = dict(cp.items('console_scripts'))
    if cp.has_section('gui_scripts'):
        gui = dict(cp.items('gui_scripts'))
    return console, gui


def move_wheel_files(name, req, wheeldir, user=False, home=None, root=None,
                     pycompile=True, scheme=None):
    """Install a wheel"""

    if not scheme:
        scheme = distutils_scheme(name, user=user, home=home, root=root)

    if root_is_purelib(name, wheeldir):
        lib_dir = scheme['purelib']
    else:
        lib_dir = scheme['platlib']

    info_dir = []
    data_dirs = []
    source = wheeldir.rstrip(os.path.sep) + os.path.sep

    # Record details of the files moved
    #   installed = files copied from the wheel to the destination
    #   changed = files changed while installing (scripts #! line typically)
    #   generated = files newly generated during the install (script wrappers)
    installed = {}
    changed = set()
    generated = []

    # Compile all of the pyc files that we're going to be installing
    if pycompile:
        compileall.compile_dir(source, force=True, quiet=True)

    def normpath(src, p):
        return make_path_relative(src, p).replace(os.path.sep, '/')

    def record_installed(srcfile, destfile, modified=False):
        """Map archive RECORD paths to installation RECORD paths."""
        oldpath = normpath(srcfile, wheeldir)
        newpath = normpath(destfile, lib_dir)
        installed[oldpath] = newpath
        if modified:
            changed.add(destfile)

    def clobber(source, dest, is_base, fixer=None, filter=None):
        if not os.path.exists(dest):  # common for the 'include' path
            os.makedirs(dest)

        for dir, subdirs, files in os.walk(source):
            basedir = dir[len(source):].lstrip(os.path.sep)
            destdir = os.path.join(dest, basedir)
            if is_base and basedir.split(os.path.sep, 1)[0].endswith('.data'):
                continue
            for s in subdirs:
                destsubdir = os.path.join(dest, basedir, s)
                if is_base and basedir == '' and destsubdir.endswith('.data'):
                    data_dirs.append(s)
                    continue
                elif (is_base
                        and s.endswith('.dist-info')
                        # is self.req.project_name case preserving?
                        and s.lower().startswith(
                            req.project_name.replace('-', '_').lower())):
                    assert not info_dir, 'Multiple .dist-info directories'
                    info_dir.append(destsubdir)
            for f in files:
                # Skip unwanted files
                if filter and filter(f):
                    continue
                srcfile = os.path.join(dir, f)
                destfile = os.path.join(dest, basedir, f)
                # directory creation is lazy and after the file filtering above
                # to ensure we don't install empty dirs; empty dirs can't be
                # uninstalled.
                if not os.path.exists(destdir):
                    os.makedirs(destdir)
                # use copy2 (not move) to be extra sure we're not moving
                # directories over; copy2 fails for directories.  this would
                # fail tests (not during released/user execution)
                shutil.copy2(srcfile, destfile)
                changed = False
                if fixer:
                    changed = fixer(destfile)
                record_installed(srcfile, destfile, changed)

    clobber(source, lib_dir, True)

    assert info_dir, "%s .dist-info directory not found" % req

    # Get the defined entry points
    ep_file = os.path.join(info_dir[0], 'entry_points.txt')
    console, gui = get_entrypoints(ep_file)

    def is_entrypoint_wrapper(name):
        # EP, EP.exe and EP-script.py are scripts generated for
        # entry point EP by setuptools
        if name.lower().endswith('.exe'):
            matchname = name[:-4]
        elif name.lower().endswith('-script.py'):
            matchname = name[:-10]
        elif name.lower().endswith(".pya"):
            matchname = name[:-4]
        else:
            matchname = name
        # Ignore setuptools-generated scripts
        return (matchname in console or matchname in gui)

    for datadir in data_dirs:
        fixer = None
        filter = None
        for subdir in os.listdir(os.path.join(wheeldir, datadir)):
            fixer = None
            if subdir == 'scripts':
                fixer = fix_script
                filter = is_entrypoint_wrapper
            source = os.path.join(wheeldir, datadir, subdir)
            dest = scheme[subdir]
            clobber(source, dest, False, fixer=fixer, filter=filter)

    maker = ScriptMaker(None, scheme['scripts'])

    # Ensure we don't generate any variants for scripts because this is almost
    # never what somebody wants.
    # See https://bitbucket.org/pypa/distlib/issue/35/
    maker.variants = set(('', ))

    # This is required because otherwise distlib creates scripts that are not
    # executable.
    # See https://bitbucket.org/pypa/distlib/issue/32/
    maker.set_mode = True

    # Simplify the script and fix the fact that the default script swallows
    # every single stack trace.
    # See https://bitbucket.org/pypa/distlib/issue/34/
    # See https://bitbucket.org/pypa/distlib/issue/33/
    def _get_script_text(entry):
        return maker.script_template % {
            "module": entry.prefix,
            "import_name": entry.suffix.split(".")[0],
            "func": entry.suffix,
        }

    maker._get_script_text = _get_script_text
    maker.script_template = """# -*- coding: utf-8 -*-
import re
import sys

from %(module)s import %(import_name)s

if __name__ == '__main__':
    sys.argv[0] = re.sub(r'(-script\.pyw|\.exe)?$', '', sys.argv[0])
    sys.exit(%(func)s())
"""

    # Special case pip and setuptools to generate versioned wrappers
    #
    # The issue is that some projects (specifically, pip and setuptools) use
    # code in setup.py to create "versioned" entry points - pip2.7 on Python
    # 2.7, pip3.3 on Python 3.3, etc. But these entry points are baked into
    # the wheel metadata at build time, and so if the wheel is installed with
    # a *different* version of Python the entry points will be wrong. The
    # correct fix for this is to enhance the metadata to be able to describe
    # such versioned entry points, but that won't happen till Metadata 2.0 is
    # available.
    # In the meantime, projects using versioned entry points will either have
    # incorrect versioned entry points, or they will not be able to distribute
    # "universal" wheels (i.e., they will need a wheel per Python version).
    #
    # Because setuptools and pip are bundled with _ensurepip and virtualenv,
    # we need to use universal wheels. So, as a stopgap until Metadata 2.0, we
    # override the versioned entry points in the wheel and generate the
    # correct ones. This code is purely a short-term measure until Metadat 2.0
    # is available.
    #
    # To add the level of hack in this section of code, in order to support
    # ensurepip this code will look for an ``ENSUREPIP_OPTIONS`` environment
    # variable which will control which version scripts get installed.
    #
    # ENSUREPIP_OPTIONS=altinstall
    #   - Only pipX.Y and easy_install-X.Y will be generated and installed
    # ENSUREPIP_OPTIONS=install
    #   - pipX.Y, pipX, easy_install-X.Y will be generated and installed. Note
    #     that this option is technically if ENSUREPIP_OPTIONS is set and is
    #     not altinstall
    # DEFAULT
    #   - The default behavior is to install pip, pipX, pipX.Y, easy_install
    #     and easy_install-X.Y.
    pip_script = console.pop('pip', None)
    if pip_script:
        if "ENSUREPIP_OPTIONS" not in os.environ:
            spec = 'pip = ' + pip_script
            generated.extend(maker.make(spec))

        if os.environ.get("ENSUREPIP_OPTIONS", "") != "altinstall":
            spec = 'pip%s = %s' % (sys.version[:1], pip_script)
            generated.extend(maker.make(spec))

        spec = 'pip%s = %s' % (sys.version[:3], pip_script)
        generated.extend(maker.make(spec))
        # Delete any other versioned pip entry points
        pip_ep = [k for k in console if re.match(r'pip(\d(\.\d)?)?$', k)]
        for k in pip_ep:
            del console[k]
    easy_install_script = console.pop('easy_install', None)
    if easy_install_script:
        if "ENSUREPIP_OPTIONS" not in os.environ:
            spec = 'easy_install = ' + easy_install_script
            generated.extend(maker.make(spec))

        spec = 'easy_install-%s = %s' % (sys.version[:3], easy_install_script)
        generated.extend(maker.make(spec))
        # Delete any other versioned easy_install entry points
        easy_install_ep = [
            k for k in console if re.match(r'easy_install(-\d\.\d)?$', k)
        ]
        for k in easy_install_ep:
            del console[k]

    # Generate the console and GUI entry points specified in the wheel
    if len(console) > 0:
        generated.extend(
            maker.make_multiple(['%s = %s' % kv for kv in console.items()])
        )
    if len(gui) > 0:
        generated.extend(
            maker.make_multiple(
                ['%s = %s' % kv for kv in gui.items()],
                {'gui': True}
            )
        )

    record = os.path.join(info_dir[0], 'RECORD')
    temp_record = os.path.join(info_dir[0], 'RECORD.pip')
    with open_for_csv(record, 'r') as record_in:
        with open_for_csv(temp_record, 'w+') as record_out:
            reader = csv.reader(record_in)
            writer = csv.writer(record_out)
            for row in reader:
                row[0] = installed.pop(row[0], row[0])
                if row[0] in changed:
                    row[1], row[2] = rehash(row[0])
                writer.writerow(row)
            for f in generated:
                h, l = rehash(f)
                writer.writerow((f, h, l))
            for f in installed:
                writer.writerow((installed[f], '', ''))
    shutil.move(temp_record, record)


def _unique(fn):
    @functools.wraps(fn)
    def unique(*args, **kw):
        seen = set()
        for item in fn(*args, **kw):
            if item not in seen:
                seen.add(item)
                yield item
    return unique


# TODO: this goes somewhere besides the wheel module
@_unique
def uninstallation_paths(dist):
    """
    Yield all the uninstallation paths for dist based on RECORD-without-.pyc

    Yield paths to all the files in RECORD. For each .py file in RECORD, add
    the .pyc in the same directory.

    UninstallPathSet.add() takes care of the __pycache__ .pyc.
    """
    from pip.util import FakeFile  # circular import
    r = csv.reader(FakeFile(dist.get_metadata_lines('RECORD')))
    for row in r:
        path = os.path.join(dist.location, row[0])
        yield path
        if path.endswith('.py'):
            dn, fn = os.path.split(path)
            base = fn[:-3]
            path = os.path.join(dn, base + '.pyc')
            yield path


def wheel_version(source_dir):
    """
    Return the Wheel-Version of an extracted wheel, if possible.

    Otherwise, return False if we couldn't parse / extract it.
    """
    try:
        dist = [d for d in pkg_resources.find_on_path(None, source_dir)][0]

        wheel_data = dist.get_metadata('WHEEL')
        wheel_data = Parser().parsestr(wheel_data)

        version = wheel_data['Wheel-Version'].strip()
        version = tuple(map(int, version.split('.')))
        return version
    except:
        return False


def check_compatibility(version, name):
    """
    Raises errors or warns if called with an incompatible Wheel-Version.

    Pip should refuse to install a Wheel-Version that's a major series
    ahead of what it's compatible with (e.g 2.0 > 1.1); and warn when
    installing a version only minor version ahead (e.g 1.2 > 1.1).

    version: a 2-tuple representing a Wheel-Version (Major, Minor)
    name: name of wheel or package to raise exception about

    :raises UnsupportedWheel: when an incompatible Wheel-Version is given
    """
    if not version:
        raise UnsupportedWheel(
            "%s is in an unsupported or invalid wheel" % name
        )
    if version[0] > VERSION_COMPATIBLE[0]:
        raise UnsupportedWheel(
            "%s's Wheel-Version (%s) is not compatible with this version "
            "of pip" % (name, '.'.join(map(str, version)))
        )
    elif version > VERSION_COMPATIBLE:
        logger.warn('Installing from a newer Wheel-Version (%s)'
                    % '.'.join(map(str, version)))


class Wheel(object):
    """A wheel file"""

    # TODO: maybe move the install code into this class

    wheel_file_re = re.compile(
        r"""^(?P<namever>(?P<name>.+?)-(?P<ver>\d.*?))
        ((-(?P<build>\d.*?))?-(?P<pyver>.+?)-(?P<abi>.+?)-(?P<plat>.+?)
        \.whl|\.dist-info)$""",
        re.VERBOSE
    )

    def __init__(self, filename):
        """
        :raises InvalidWheelFilename: when the filename is invalid for a wheel
        """
        wheel_info = self.wheel_file_re.match(filename)
        if not wheel_info:
            raise InvalidWheelFilename(
                "%s is not a valid wheel filename." % filename
            )
        self.filename = filename
        self.name = wheel_info.group('name').replace('_', '-')
        # we'll assume "_" means "-" due to wheel naming scheme
        # (https://github.com/pypa/pip/issues/1150)
        self.version = wheel_info.group('ver').replace('_', '-')
        self.pyversions = wheel_info.group('pyver').split('.')
        self.abis = wheel_info.group('abi').split('.')
        self.plats = wheel_info.group('plat').split('.')

        # All the tag combinations from this file
        self.file_tags = set(
            (x, y, z) for x in self.pyversions
            for y in self.abis for z in self.plats
        )

    def support_index_min(self, tags=None):
        """
        Return the lowest index that one of the wheel's file_tag combinations
        achieves in the supported_tags list e.g. if there are 8 supported tags,
        and one of the file tags is first in the list, then return 0.  Returns
        None is the wheel is not supported.
        """
        if tags is None:  # for mock
            tags = pep425tags.supported_tags
        indexes = [tags.index(c) for c in self.file_tags if c in tags]
        return min(indexes) if indexes else None

    def supported(self, tags=None):
        """Is this wheel supported on this system?"""
        if tags is None:  # for mock
            tags = pep425tags.supported_tags
        return bool(set(tags).intersection(self.file_tags))


class WheelBuilder(object):
    """Build wheels from a RequirementSet."""

    def __init__(self, requirement_set, finder, wheel_dir, build_options=[],
                 global_options=[]):
        self.requirement_set = requirement_set
        self.finder = finder
        self.wheel_dir = normalize_path(wheel_dir)
        self.build_options = build_options
        self.global_options = global_options

    def _build_one(self, req):
        """Build one wheel."""

        base_args = [
            sys.executable, '-c',
            "import setuptools;__file__=%r;"
            "exec(compile(open(__file__).read().replace('\\r\\n', '\\n'), "
            "__file__, 'exec'))" % req.setup_py
        ] + list(self.global_options)

        logger.notify('Running setup.py bdist_wheel for %s' % req.name)
        logger.notify('Destination directory: %s' % self.wheel_dir)
        wheel_args = base_args + ['bdist_wheel', '-d', self.wheel_dir] \
            + self.build_options
        try:
            call_subprocess(wheel_args, cwd=req.source_dir, show_stdout=False)
            return True
        except:
            logger.error('Failed building wheel for %s' % req.name)
            return False

    def build(self):
        """Build wheels."""

        # unpack and constructs req set
        self.requirement_set.prepare_files(self.finder)

        reqset = self.requirement_set.requirements.values()

        buildset = []
        for req in reqset:
            if req.is_wheel:
                logger.notify(
                    'Skipping %s, due to already being wheel.' % req.name)
            elif req.editable:
                logger.notify(
                    'Skipping %s, due to being editable' % req.name)
            else:
                buildset.append(req)

        if not buildset:
            return True

        # Build the wheels.
        logger.notify(
            'Building wheels for collected packages: %s' %
            ', '.join([req.name for req in buildset])
        )
        logger.indent += 2
        build_success, build_failure = [], []
        for req in buildset:
            if self._build_one(req):
                build_success.append(req)
            else:
                build_failure.append(req)
        logger.indent -= 2

        # notify success/failure
        if build_success:
            logger.notify(
                'Successfully built %s' %
                ' '.join([req.name for req in build_success])
            )
        if build_failure:
            logger.notify(
                'Failed to build %s' %
                ' '.join([req.name for req in build_failure])
            )
        # Return True if all builds were successful
        return len(build_failure) == 0

########NEW FILE########
__FILENAME__ = adapter
import functools

from pip._vendor.requests.adapters import HTTPAdapter

from .controller import CacheController
from .cache import DictCache
from .filewrapper import CallbackFileWrapper


class CacheControlAdapter(HTTPAdapter):
    invalidating_methods = set(['PUT', 'DELETE'])

    def __init__(self, cache=None, cache_etags=True, controller_class=None,
                 serializer=None, *args, **kw):
        super(CacheControlAdapter, self).__init__(*args, **kw)
        self.cache = cache or DictCache()

        controller_factory = controller_class or CacheController
        self.controller = controller_factory(
            self.cache,
            cache_etags=cache_etags,
            serializer=serializer,
        )

    def send(self, request, **kw):
        """
        Send a request. Use the request information to see if it
        exists in the cache and cache the response if we need to and can.
        """
        if request.method == 'GET':
            cached_response = self.controller.cached_request(request)
            if cached_response:
                return self.build_response(request, cached_response, from_cache=True)

            # check for etags and add headers if appropriate
            request.headers.update(self.controller.conditional_headers(request))

        resp = super(CacheControlAdapter, self).send(request, **kw)

        return resp

    def build_response(self, request, response, from_cache=False):
        """
        Build a response by making a request or using the cache.

        This will end up calling send and returning a potentially
        cached response
        """
        if not from_cache and request.method == 'GET':
            if response.status == 304:
                # We must have sent an ETag request. This could mean
                # that we've been expired already or that we simply
                # have an etag. In either case, we want to try and
                # update the cache if that is the case.
                cached_response = self.controller.update_cached_response(
                    request, response
                )

                if cached_response is not response:
                    from_cache = True

                response = cached_response
            else:
                # Wrap the response file with a wrapper that will cache the
                #   response when the stream has been consumed.
                response._fp = CallbackFileWrapper(
                    response._fp,
                    functools.partial(
                        self.controller.cache_response,
                        request,
                        response,
                    )
                )

        resp = super(CacheControlAdapter, self).build_response(
            request, response
        )

        # See if we should invalidate the cache.
        if request.method in self.invalidating_methods and resp.ok:
            cache_url = self.controller.cache_url(request.url)
            self.cache.delete(cache_url)

        # Give the request a from_cache attr to let people use it
        resp.from_cache = from_cache

        return resp

########NEW FILE########
__FILENAME__ = cache
"""
The cache object API for implementing caches. The default is just a
dictionary, which in turns means it is not threadsafe for writing.
"""
from threading import Lock


class BaseCache(object):

    def get(self, key):
        raise NotImplemented()

    def set(self, key, value):
        raise NotImplemented()

    def delete(self, key):
        raise NotImplemented()


class DictCache(BaseCache):

    def __init__(self, init_dict=None):
        self.lock = Lock()
        self.data = init_dict or {}

    def get(self, key):
        return self.data.get(key, None)

    def set(self, key, value):
        with self.lock:
            self.data.update({key: value})

    def delete(self, key):
        with self.lock:
            if key in self.data:
                self.data.pop(key)

########NEW FILE########
__FILENAME__ = file_cache
import hashlib
import os

from pip._vendor.lockfile import FileLock


def _secure_open_write(filename, fmode):
    # We only want to write to this file, so open it in write only mode
    flags = os.O_WRONLY

    # os.O_CREAT | os.O_EXCL will fail if the file already exists, so we only
    #  will open *new* files.
    # We specify this because we want to ensure that the mode we pass is the
    # mode of the file.
    flags |= os.O_CREAT | os.O_EXCL

    # Do not follow symlinks to prevent someone from making a symlink that
    # we follow and insecurely open a cache file.
    if hasattr(os, "O_NOFOLLOW"):
        flags |= os.O_NOFOLLOW

    # On Windows we'll mark this file as binary
    if hasattr(os, "O_BINARY"):
        flags |= os.O_BINARY

    # Before we open our file, we want to delete any existing file that is
    # there
    try:
        os.remove(filename)
    except (IOError, OSError):
        # The file must not exist already, so we can just skip ahead to opening
        pass

    # Open our file, the use of os.O_CREAT | os.O_EXCL will ensure that if a
    # race condition happens between the os.remove and this line, that an
    # error will be raised. Because we utilize a lockfile this should only
    # happen if someone is attempting to attack us.
    fd = os.open(filename, flags, fmode)
    try:
        return os.fdopen(fd, "wb")
    except:
        # An error occurred wrapping our FD in a file object
        os.close(fd)
        raise


class FileCache(object):
    def __init__(self, directory, forever=False, filemode=0o0600,
                 dirmode=0o0700):
        self.directory = directory
        self.forever = forever
        self.filemode = filemode
        self.dirmode = dirmode

    @staticmethod
    def encode(x):
        return hashlib.sha224(x.encode()).hexdigest()

    def _fn(self, name):
        hashed = self.encode(name)
        parts = list(hashed[:5]) + [hashed]
        return os.path.join(self.directory, *parts)

    def get(self, key):
        name = self._fn(key)
        if not os.path.exists(name):
            return None

        with open(name, 'rb') as fh:
            return fh.read()

    def set(self, key, value):
        name = self._fn(key)

        # Make sure the directory exists
        try:
            os.makedirs(os.path.dirname(name), self.dirmode)
        except (IOError, OSError):
            pass

        with FileLock(name) as lock:
            # Write our actual file
            with _secure_open_write(lock.path, self.filemode) as fh:
                fh.write(value)

    def delete(self, key):
        name = self._fn(key)
        if not self.forever:
            os.remove(name)

########NEW FILE########
__FILENAME__ = redis_cache
from __future__ import division

from datetime import datetime


def total_seconds(td):
    """Python 2.6 compatability"""
    if hasattr(td, 'total_seconds'):
        return td.total_seconds()

    ms = td.microseconds
    secs = (td.seconds + td.days * 24 * 3600)
    return (ms + secs * 10**6) / 10**6


class RedisCache(object):

    def __init__(self, conn):
        self.conn = conn

    def get(self, key):
        return self.conn.get(key)

    def set(self, key, value, expires=None):
        if not expires:
            self.conn.set(key, value)
        else:
            expires = expires - datetime.now()
            self.conn.setex(key, total_seconds(expires), value)

    def delete(self, key):
        self.conn.delete(key)

    def clear(self):
        """Helper for clearing all the keys in a database. Use with
        caution!"""
        for key in self.conn.keys():
            self.conn.delete(key)

########NEW FILE########
__FILENAME__ = compat
try:
    from urllib.parse import urljoin
except ImportError:
    from urlparse import urljoin


try:
    import email.utils
    parsedate_tz = email.utils.parsedate_tz
except ImportError:
    import email.Utils
    parsedate_tz = email.Utils.parsedate_tz


try:
    import cPickle as pickle
except ImportError:
    import pickle


# Handle the case where the requests has been patched to not have urllib3
# bundled as part of it's source.
from pip._vendor.requests.packages.urllib3.response import HTTPResponse
from pip._vendor.requests.packages.urllib3.util import is_fp_closed

########NEW FILE########
__FILENAME__ = controller
"""
The httplib2 algorithms ported for use with requests.
"""
import re
import calendar
import time

from pip._vendor.requests.structures import CaseInsensitiveDict

from .cache import DictCache
from .compat import parsedate_tz
from .serialize import Serializer


URI = re.compile(r"^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?")


def parse_uri(uri):
    """Parses a URI using the regex given in Appendix B of RFC 3986.

        (scheme, authority, path, query, fragment) = parse_uri(uri)
    """
    groups = URI.match(uri).groups()
    return (groups[1], groups[3], groups[4], groups[6], groups[8])


class CacheController(object):
    """An interface to see if request should cached or not.
    """
    def __init__(self, cache=None, cache_etags=True, serializer=None):
        self.cache = cache or DictCache()
        self.cache_etags = cache_etags
        self.serializer = serializer or Serializer()

    def _urlnorm(self, uri):
        """Normalize the URL to create a safe key for the cache"""
        (scheme, authority, path, query, fragment) = parse_uri(uri)
        if not scheme or not authority:
            raise Exception("Only absolute URIs are allowed. uri = %s" % uri)
        authority = authority.lower()
        scheme = scheme.lower()
        if not path:
            path = "/"

        # Could do syntax based normalization of the URI before
        # computing the digest. See Section 6.2.2 of Std 66.
        request_uri = query and "?".join([path, query]) or path
        scheme = scheme.lower()
        defrag_uri = scheme + "://" + authority + request_uri

        return defrag_uri

    def cache_url(self, uri):
        return self._urlnorm(uri)

    def parse_cache_control(self, headers):
        """
        Parse the cache control headers returning a dictionary with values
        for the different directives.
        """
        retval = {}

        cc_header = 'cache-control'
        if 'Cache-Control' in headers:
            cc_header = 'Cache-Control'

        if cc_header in headers:
            parts = headers[cc_header].split(',')
            parts_with_args = [
                tuple([x.strip().lower() for x in part.split("=", 1)])
                for part in parts if -1 != part.find("=")]
            parts_wo_args = [(name.strip().lower(), 1)
                             for name in parts if -1 == name.find("=")]
            retval = dict(parts_with_args + parts_wo_args)
        return retval

    def cached_request(self, request):
        cache_url = self.cache_url(request.url)
        cc = self.parse_cache_control(request.headers)

        # non-caching states
        no_cache = True if 'no-cache' in cc else False
        if 'max-age' in cc and cc['max-age'] == 0:
            no_cache = True

        # Bail out if no-cache was set
        if no_cache:
            return False

        # It is in the cache, so lets see if it is going to be
        # fresh enough
        resp = self.serializer.loads(request, self.cache.get(cache_url))

        # Check to see if we have a cached object
        if not resp:
            return False

        headers = CaseInsensitiveDict(resp.headers)

        now = time.time()
        date = calendar.timegm(
            parsedate_tz(headers['date'])
        )
        current_age = max(0, now - date)

        # TODO: There is an assumption that the result will be a
        # urllib3 response object. This may not be best since we
        # could probably avoid instantiating or constructing the
        # response until we know we need it.
        resp_cc = self.parse_cache_control(headers)

        # determine freshness
        freshness_lifetime = 0
        if 'max-age' in resp_cc and resp_cc['max-age'].isdigit():
            freshness_lifetime = int(resp_cc['max-age'])
        elif 'expires' in headers:
            expires = parsedate_tz(headers['expires'])
            if expires is not None:
                expire_time = calendar.timegm(expires) - date
                freshness_lifetime = max(0, expire_time)

        # determine if we are setting freshness limit in the req
        if 'max-age' in cc:
            try:
                freshness_lifetime = int(cc['max-age'])
            except ValueError:
                freshness_lifetime = 0

        if 'min-fresh' in cc:
            try:
                min_fresh = int(cc['min-fresh'])
            except ValueError:
                min_fresh = 0
            # adjust our current age by our min fresh
            current_age += min_fresh

        # see how fresh we actually are
        fresh = (freshness_lifetime > current_age)

        if fresh:
            return resp

        # we're not fresh. If we don't have an Etag, clear it out
        if 'etag' not in headers:
            self.cache.delete(cache_url)

        # return the original handler
        return False

    def conditional_headers(self, request):
        cache_url = self.cache_url(request.url)
        resp = self.serializer.loads(request, self.cache.get(cache_url))
        new_headers = {}

        if resp:
            headers = CaseInsensitiveDict(resp.headers)

            if 'etag' in headers:
                new_headers['If-None-Match'] = headers['ETag']

            if 'last-modified' in headers:
                new_headers['If-Modified-Since'] = headers['Last-Modified']

        return new_headers

    def cache_response(self, request, response, body=None):
        """
        Algorithm for caching requests.

        This assumes a requests Response object.
        """
        # From httplib2: Don't cache 206's since we aren't going to
        # handle byte range requests
        if response.status not in [200, 203]:
            return

        response_headers = CaseInsensitiveDict(response.headers)

        cc_req = self.parse_cache_control(request.headers)
        cc = self.parse_cache_control(response_headers)

        cache_url = self.cache_url(request.url)

        # Delete it from the cache if we happen to have it stored there
        no_store = cc.get('no-store') or cc_req.get('no-store')
        if no_store and self.cache.get(cache_url):
            self.cache.delete(cache_url)

        # If we've been given an etag, then keep the response
        if self.cache_etags and 'etag' in response_headers:
            self.cache.set(
                cache_url,
                self.serializer.dumps(request, response, body=body),
            )

        # Add to the cache if the response headers demand it. If there
        # is no date header then we can't do anything about expiring
        # the cache.
        elif 'date' in response_headers:
            # cache when there is a max-age > 0
            if cc and cc.get('max-age'):
                if int(cc['max-age']) > 0:
                    self.cache.set(
                        cache_url,
                        self.serializer.dumps(request, response, body=body),
                    )

            # If the request can expire, it means we should cache it
            # in the meantime.
            elif 'expires' in response_headers:
                if response_headers['expires']:
                    self.cache.set(
                        cache_url,
                        self.serializer.dumps(request, response, body=body),
                    )

    def update_cached_response(self, request, response):
        """On a 304 we will get a new set of headers that we want to
        update our cached value with, assuming we have one.

        This should only ever be called when we've sent an ETag and
        gotten a 304 as the response.
        """
        cache_url = self.cache_url(request.url)

        cached_response = self.serializer.loads(request, self.cache.get(cache_url))

        if not cached_response:
            # we didn't have a cached response
            return response

        # Lets update our headers with the headers from the new request:
        # http://tools.ietf.org/html/draft-ietf-httpbis-p4-conditional-26#section-4.1
        #
        # The server isn't supposed to send headers that would make
        # the cached body invalid. But... just in case, we'll be sure
        # to strip out ones we know that might be problmatic due to
        # typical assumptions.
        excluded_headers = [
            "content-length",
        ]

        cached_response.headers.update(
            dict((k, v) for k, v in response.headers.items()
                 if k.lower() not in excluded_headers)
        )

        # we want a 200 b/c we have content via the cache
        cached_response.status = 200

        # update our cache
        self.cache.set(
            cache_url,
            self.serializer.dumps(request, cached_response),
        )

        return cached_response

########NEW FILE########
__FILENAME__ = filewrapper
from io import BytesIO

from .compat import is_fp_closed


class CallbackFileWrapper(object):
    """
    Small wrapper around a fp object which will tee everything read into a
    buffer, and when that file is closed it will execute a callback with the
    contents of that buffer.

    All attributes are proxied to the underlying file object.

    This class uses members with a double underscore (__) leading prefix so as
    not to accidentally shadow an attribute.
    """

    def __init__(self, fp, callback):
        self.__buf = BytesIO()
        self.__fp = fp
        self.__callback = callback

    def __getattr__(self, name):
        return getattr(self.__fp, name)

    def read(self, amt=None):
        data = self.__fp.read(amt)
        self.__buf.write(data)

        # Is this the best way to figure out if the file has been completely
        #   consumed?
        if is_fp_closed(self.__fp):
            self.__callback(self.__buf.getvalue())

        return data

########NEW FILE########
__FILENAME__ = serialize
import io

from pip._vendor.requests.structures import CaseInsensitiveDict

from .compat import HTTPResponse, pickle


class Serializer(object):

    def dumps(self, request, response, body=None):
        response_headers = CaseInsensitiveDict(response.headers)

        if body is None:
            body = response.read(decode_content=False)
            response._fp = io.BytesIO(body)

        data = {
            "response": {
                "body": body,
                "headers": response.headers,
                "status": response.status,
                "version": response.version,
                "reason": response.reason,
                "strict": response.strict,
                "decode_content": response.decode_content,
            },
        }

        # Construct our vary headers
        data["vary"] = {}
        if "vary" in response_headers:
            varied_headers = response_headers['vary'].split(',')
            for header in varied_headers:
                header = header.strip()
                data["vary"][header] = request.headers.get(header, None)

        return b"cc=1," + pickle.dumps(data, pickle.HIGHEST_PROTOCOL)

    def loads(self, request, data):
        # Short circuit if we've been given an empty set of data
        if not data:
            return

        # Determine what version of the serializer the data was serialized
        # with
        try:
            ver, data = data.split(b",", 1)
        except ValueError:
            ver = b"cc=0"

        # Make sure that our "ver" is actually a version and isn't a false
        # positive from a , being in the data stream.
        if ver[:3] != b"cc=":
            data = ver + data
            ver = b"cc=0"

        # Get the version number out of the cc=N
        ver = ver.split(b"=", 1)[-1].decode("ascii")

        # Dispatch to the actual load method for the given version
        try:
            return getattr(self, "_loads_v{0}".format(ver))(request, data)
        except AttributeError:
            # This is a version we don't have a loads function for, so we'll
            # just treat it as a miss and return None
            return

    def _loads_v0(self, request, data):
        # The original legacy cache data. This doesn't contain enough
        # information to construct everything we need, so we'll treat this as
        # a miss.
        return

    def _loads_v1(self, request, data):
        try:
            cached = pickle.loads(data)
        except ValueError:
            return

        # Special case the '*' Vary value as it means we cannot actually
        # determine if the cached response is suitable for this request.
        if "*" in cached.get("vary", {}):
            return

        # Ensure that the Vary headers for the cached response match our
        # request
        for header, value in cached.get("vary", {}).items():
            if request.headers.get(header, None) != value:
                return

        body = io.BytesIO(cached["response"].pop("body"))
        return HTTPResponse(
            body=body,
            preload_content=False,
            **cached["response"]
        )

########NEW FILE########
__FILENAME__ = wrapper
from .adapter import CacheControlAdapter
from .cache import DictCache


def CacheControl(sess, cache=None, cache_etags=True, serializer=None):
    cache = cache or DictCache()
    adapter = CacheControlAdapter(
        cache,
        cache_etags=cache_etags,
        serializer=serializer,
    )
    sess.mount('http://', adapter)
    sess.mount('https://', adapter)

    return sess

########NEW FILE########
__FILENAME__ = ansi
# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
'''
This module generates ANSI character codes to printing colors to terminals.
See: http://en.wikipedia.org/wiki/ANSI_escape_code
'''

CSI = '\033['

def code_to_chars(code):
    return CSI + str(code) + 'm'

class AnsiCodes(object):
    def __init__(self, codes):
        for name in dir(codes):
            if not name.startswith('_'):
                value = getattr(codes, name)
                setattr(self, name, code_to_chars(value))

class AnsiFore:
    BLACK   = 30
    RED     = 31
    GREEN   = 32
    YELLOW  = 33
    BLUE    = 34
    MAGENTA = 35
    CYAN    = 36
    WHITE   = 37
    RESET   = 39

class AnsiBack:
    BLACK   = 40
    RED     = 41
    GREEN   = 42
    YELLOW  = 43
    BLUE    = 44
    MAGENTA = 45
    CYAN    = 46
    WHITE   = 47
    RESET   = 49

class AnsiStyle:
    BRIGHT    = 1
    DIM       = 2
    NORMAL    = 22
    RESET_ALL = 0

Fore = AnsiCodes( AnsiFore )
Back = AnsiCodes( AnsiBack )
Style = AnsiCodes( AnsiStyle )


########NEW FILE########
__FILENAME__ = ansitowin32
# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
import re
import sys

from .ansi import AnsiFore, AnsiBack, AnsiStyle, Style
from .winterm import WinTerm, WinColor, WinStyle
from .win32 import windll


winterm = None
if windll is not None:
    winterm = WinTerm()


def is_a_tty(stream):
    return hasattr(stream, 'isatty') and stream.isatty()


class StreamWrapper(object):
    '''
    Wraps a stream (such as stdout), acting as a transparent proxy for all
    attribute access apart from method 'write()', which is delegated to our
    Converter instance.
    '''
    def __init__(self, wrapped, converter):
        # double-underscore everything to prevent clashes with names of
        # attributes on the wrapped stream object.
        self.__wrapped = wrapped
        self.__convertor = converter

    def __getattr__(self, name):
        return getattr(self.__wrapped, name)

    def write(self, text):
        self.__convertor.write(text)


class AnsiToWin32(object):
    '''
    Implements a 'write()' method which, on Windows, will strip ANSI character
    sequences from the text, and if outputting to a tty, will convert them into
    win32 function calls.
    '''
    ANSI_RE = re.compile('\033\[((?:\d|;)*)([a-zA-Z])')

    def __init__(self, wrapped, convert=None, strip=None, autoreset=False):
        # The wrapped stream (normally sys.stdout or sys.stderr)
        self.wrapped = wrapped

        # should we reset colors to defaults after every .write()
        self.autoreset = autoreset

        # create the proxy wrapping our output stream
        self.stream = StreamWrapper(wrapped, self)

        on_windows = sys.platform.startswith('win')

        # should we strip ANSI sequences from our output?
        if strip is None:
            strip = on_windows
        self.strip = strip

        # should we should convert ANSI sequences into win32 calls?
        if convert is None:
            convert = on_windows and is_a_tty(wrapped)
        self.convert = convert

        # dict of ansi codes to win32 functions and parameters
        self.win32_calls = self.get_win32_calls()

        # are we wrapping stderr?
        self.on_stderr = self.wrapped is sys.stderr


    def should_wrap(self):
        '''
        True if this class is actually needed. If false, then the output
        stream will not be affected, nor will win32 calls be issued, so
        wrapping stdout is not actually required. This will generally be
        False on non-Windows platforms, unless optional functionality like
        autoreset has been requested using kwargs to init()
        '''
        return self.convert or self.strip or self.autoreset


    def get_win32_calls(self):
        if self.convert and winterm:
            return {
                AnsiStyle.RESET_ALL: (winterm.reset_all, ),
                AnsiStyle.BRIGHT: (winterm.style, WinStyle.BRIGHT),
                AnsiStyle.DIM: (winterm.style, WinStyle.NORMAL),
                AnsiStyle.NORMAL: (winterm.style, WinStyle.NORMAL),
                AnsiFore.BLACK: (winterm.fore, WinColor.BLACK),
                AnsiFore.RED: (winterm.fore, WinColor.RED),
                AnsiFore.GREEN: (winterm.fore, WinColor.GREEN),
                AnsiFore.YELLOW: (winterm.fore, WinColor.YELLOW),
                AnsiFore.BLUE: (winterm.fore, WinColor.BLUE),
                AnsiFore.MAGENTA: (winterm.fore, WinColor.MAGENTA),
                AnsiFore.CYAN: (winterm.fore, WinColor.CYAN),
                AnsiFore.WHITE: (winterm.fore, WinColor.GREY),
                AnsiFore.RESET: (winterm.fore, ),
                AnsiBack.BLACK: (winterm.back, WinColor.BLACK),
                AnsiBack.RED: (winterm.back, WinColor.RED),
                AnsiBack.GREEN: (winterm.back, WinColor.GREEN),
                AnsiBack.YELLOW: (winterm.back, WinColor.YELLOW),
                AnsiBack.BLUE: (winterm.back, WinColor.BLUE),
                AnsiBack.MAGENTA: (winterm.back, WinColor.MAGENTA),
                AnsiBack.CYAN: (winterm.back, WinColor.CYAN),
                AnsiBack.WHITE: (winterm.back, WinColor.GREY),
                AnsiBack.RESET: (winterm.back, ),
            }


    def write(self, text):
        if self.strip or self.convert:
            self.write_and_convert(text)
        else:
            self.wrapped.write(text)
            self.wrapped.flush()
        if self.autoreset:
            self.reset_all()


    def reset_all(self):
        if self.convert:
            self.call_win32('m', (0,))
        elif not self.wrapped.closed and is_a_tty(self.wrapped):
            self.wrapped.write(Style.RESET_ALL)


    def write_and_convert(self, text):
        '''
        Write the given text to our wrapped stream, stripping any ANSI
        sequences from the text, and optionally converting them into win32
        calls.
        '''
        cursor = 0
        for match in self.ANSI_RE.finditer(text):
            start, end = match.span()
            self.write_plain_text(text, cursor, start)
            self.convert_ansi(*match.groups())
            cursor = end
        self.write_plain_text(text, cursor, len(text))


    def write_plain_text(self, text, start, end):
        if start < end:
            self.wrapped.write(text[start:end])
            self.wrapped.flush()


    def convert_ansi(self, paramstring, command):
        if self.convert:
            params = self.extract_params(paramstring)
            self.call_win32(command, params)


    def extract_params(self, paramstring):
        def split(paramstring):
            for p in paramstring.split(';'):
                if p != '':
                    yield int(p)
        return tuple(split(paramstring))


    def call_win32(self, command, params):
        if params == []:
            params = [0]
        if command == 'm':
            for param in params:
                if param in self.win32_calls:
                    func_args = self.win32_calls[param]
                    func = func_args[0]
                    args = func_args[1:]
                    kwargs = dict(on_stderr=self.on_stderr)
                    func(*args, **kwargs)
        elif command in ('H', 'f'): # set cursor position
            func = winterm.set_cursor_position
            func(params, on_stderr=self.on_stderr)
        elif command in ('J'):
            func = winterm.erase_data
            func(params, on_stderr=self.on_stderr)
        elif command == 'A':
            if params == () or params == None:
                num_rows = 1
            else:
                num_rows = params[0]
            func = winterm.cursor_up
            func(num_rows, on_stderr=self.on_stderr)


########NEW FILE########
__FILENAME__ = initialise
# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
import atexit
import sys

from .ansitowin32 import AnsiToWin32


orig_stdout = sys.stdout
orig_stderr = sys.stderr

wrapped_stdout = sys.stdout
wrapped_stderr = sys.stderr

atexit_done = False


def reset_all():
    AnsiToWin32(orig_stdout).reset_all()


def init(autoreset=False, convert=None, strip=None, wrap=True):

    if not wrap and any([autoreset, convert, strip]):
        raise ValueError('wrap=False conflicts with any other arg=True')

    global wrapped_stdout, wrapped_stderr
    sys.stdout = wrapped_stdout = \
        wrap_stream(orig_stdout, convert, strip, autoreset, wrap)
    sys.stderr = wrapped_stderr = \
        wrap_stream(orig_stderr, convert, strip, autoreset, wrap)

    global atexit_done
    if not atexit_done:
        atexit.register(reset_all)
        atexit_done = True


def deinit():
    sys.stdout = orig_stdout
    sys.stderr = orig_stderr


def reinit():
    sys.stdout = wrapped_stdout
    sys.stderr = wrapped_stdout


def wrap_stream(stream, convert, strip, autoreset, wrap):
    if wrap:
        wrapper = AnsiToWin32(stream,
            convert=convert, strip=strip, autoreset=autoreset)
        if wrapper.should_wrap():
            stream = wrapper.stream
    return stream



########NEW FILE########
__FILENAME__ = win32
# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.

# from winbase.h
STDOUT = -11
STDERR = -12

import ctypes
from ctypes import LibraryLoader

try:
    windll = LibraryLoader(ctypes.WinDLL)
    from ctypes import wintypes
except (AttributeError, ImportError):
    windll = None
    SetConsoleTextAttribute = lambda *_: None
else:
    from ctypes import (
        byref, Structure, c_char, c_short, c_uint32, c_ushort, POINTER
    )

    class CONSOLE_SCREEN_BUFFER_INFO(Structure):
        """struct in wincon.h."""
        _fields_ = [
            ("dwSize", wintypes._COORD),
            ("dwCursorPosition", wintypes._COORD),
            ("wAttributes", wintypes.WORD),
            ("srWindow", wintypes.SMALL_RECT),
            ("dwMaximumWindowSize", wintypes._COORD),
        ]
        def __str__(self):
            return '(%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d)' % (
                self.dwSize.Y, self.dwSize.X
                , self.dwCursorPosition.Y, self.dwCursorPosition.X
                , self.wAttributes
                , self.srWindow.Top, self.srWindow.Left, self.srWindow.Bottom, self.srWindow.Right
                , self.dwMaximumWindowSize.Y, self.dwMaximumWindowSize.X
            )

    _GetStdHandle = windll.kernel32.GetStdHandle
    _GetStdHandle.argtypes = [
        wintypes.DWORD,
    ]
    _GetStdHandle.restype = wintypes.HANDLE

    _GetConsoleScreenBufferInfo = windll.kernel32.GetConsoleScreenBufferInfo
    _GetConsoleScreenBufferInfo.argtypes = [
        wintypes.HANDLE,
        POINTER(CONSOLE_SCREEN_BUFFER_INFO),
    ]
    _GetConsoleScreenBufferInfo.restype = wintypes.BOOL

    _SetConsoleTextAttribute = windll.kernel32.SetConsoleTextAttribute
    _SetConsoleTextAttribute.argtypes = [
        wintypes.HANDLE,
        wintypes.WORD,
    ]
    _SetConsoleTextAttribute.restype = wintypes.BOOL

    _SetConsoleCursorPosition = windll.kernel32.SetConsoleCursorPosition
    _SetConsoleCursorPosition.argtypes = [
        wintypes.HANDLE,
        wintypes._COORD,
    ]
    _SetConsoleCursorPosition.restype = wintypes.BOOL

    _FillConsoleOutputCharacterA = windll.kernel32.FillConsoleOutputCharacterA
    _FillConsoleOutputCharacterA.argtypes = [
        wintypes.HANDLE,
        c_char,
        wintypes.DWORD,
        wintypes._COORD,
        POINTER(wintypes.DWORD),
    ]
    _FillConsoleOutputCharacterA.restype = wintypes.BOOL

    _FillConsoleOutputAttribute = windll.kernel32.FillConsoleOutputAttribute
    _FillConsoleOutputAttribute.argtypes = [
        wintypes.HANDLE,
        wintypes.WORD,
        wintypes.DWORD,
        wintypes._COORD,
        POINTER(wintypes.DWORD),
    ]
    _FillConsoleOutputAttribute.restype = wintypes.BOOL

    handles = {
        STDOUT: _GetStdHandle(STDOUT),
        STDERR: _GetStdHandle(STDERR),
    }

    def GetConsoleScreenBufferInfo(stream_id=STDOUT):
        handle = handles[stream_id]
        csbi = CONSOLE_SCREEN_BUFFER_INFO()
        success = _GetConsoleScreenBufferInfo(
            handle, byref(csbi))
        return csbi

    def SetConsoleTextAttribute(stream_id, attrs):
        handle = handles[stream_id]
        return _SetConsoleTextAttribute(handle, attrs)

    def SetConsoleCursorPosition(stream_id, position):
        position = wintypes._COORD(*position)
        # If the position is out of range, do nothing.
        if position.Y <= 0 or position.X <= 0:
            return
        # Adjust for Windows' SetConsoleCursorPosition:
        #    1. being 0-based, while ANSI is 1-based.
        #    2. expecting (x,y), while ANSI uses (y,x).
        adjusted_position = wintypes._COORD(position.Y - 1, position.X - 1)
        # Adjust for viewport's scroll position
        sr = GetConsoleScreenBufferInfo(STDOUT).srWindow
        adjusted_position.Y += sr.Top
        adjusted_position.X += sr.Left
        # Resume normal processing
        handle = handles[stream_id]
        return _SetConsoleCursorPosition(handle, adjusted_position)

    def FillConsoleOutputCharacter(stream_id, char, length, start):
        handle = handles[stream_id]
        char = c_char(char)
        length = wintypes.DWORD(length)
        num_written = wintypes.DWORD(0)
        # Note that this is hard-coded for ANSI (vs wide) bytes.
        success = _FillConsoleOutputCharacterA(
            handle, char, length, start, byref(num_written))
        return num_written.value

    def FillConsoleOutputAttribute(stream_id, attr, length, start):
        ''' FillConsoleOutputAttribute( hConsole, csbi.wAttributes, dwConSize, coordScreen, &cCharsWritten )'''
        handle = handles[stream_id]
        attribute = wintypes.WORD(attr)
        length = wintypes.DWORD(length)
        num_written = wintypes.DWORD(0)
        # Note that this is hard-coded for ANSI (vs wide) bytes.
        return _FillConsoleOutputAttribute(
            handle, attribute, length, start, byref(num_written))

########NEW FILE########
__FILENAME__ = winterm
# Copyright Jonathan Hartley 2013. BSD 3-Clause license, see LICENSE file.
from . import win32


# from wincon.h
class WinColor(object):
    BLACK   = 0
    BLUE    = 1
    GREEN   = 2
    CYAN    = 3
    RED     = 4
    MAGENTA = 5
    YELLOW  = 6
    GREY    = 7

# from wincon.h
class WinStyle(object):
    NORMAL = 0x00 # dim text, dim background
    BRIGHT = 0x08 # bright text, dim background


class WinTerm(object):

    def __init__(self):
        self._default = win32.GetConsoleScreenBufferInfo(win32.STDOUT).wAttributes
        self.set_attrs(self._default)
        self._default_fore = self._fore
        self._default_back = self._back
        self._default_style = self._style

    def get_attrs(self):
        return self._fore + self._back * 16 + self._style

    def set_attrs(self, value):
        self._fore = value & 7
        self._back = (value >> 4) & 7
        self._style = value & WinStyle.BRIGHT

    def reset_all(self, on_stderr=None):
        self.set_attrs(self._default)
        self.set_console(attrs=self._default)

    def fore(self, fore=None, on_stderr=False):
        if fore is None:
            fore = self._default_fore
        self._fore = fore
        self.set_console(on_stderr=on_stderr)

    def back(self, back=None, on_stderr=False):
        if back is None:
            back = self._default_back
        self._back = back
        self.set_console(on_stderr=on_stderr)

    def style(self, style=None, on_stderr=False):
        if style is None:
            style = self._default_style
        self._style = style
        self.set_console(on_stderr=on_stderr)

    def set_console(self, attrs=None, on_stderr=False):
        if attrs is None:
            attrs = self.get_attrs()
        handle = win32.STDOUT
        if on_stderr:
            handle = win32.STDERR
        win32.SetConsoleTextAttribute(handle, attrs)

    def get_position(self, handle):
        position = win32.GetConsoleScreenBufferInfo(handle).dwCursorPosition
        # Because Windows coordinates are 0-based,
        # and win32.SetConsoleCursorPosition expects 1-based.
        position.X += 1
        position.Y += 1
        return position
    
    def set_cursor_position(self, position=None, on_stderr=False):
        if position is None:
            #I'm not currently tracking the position, so there is no default.
            #position = self.get_position()
            return
        handle = win32.STDOUT
        if on_stderr:
            handle = win32.STDERR
        win32.SetConsoleCursorPosition(handle, position)

    def cursor_up(self, num_rows=0, on_stderr=False):
        if num_rows == 0:
            return
        handle = win32.STDOUT
        if on_stderr:
            handle = win32.STDERR
        position = self.get_position(handle)
        adjusted_position = (position.Y - num_rows, position.X)
        self.set_cursor_position(adjusted_position, on_stderr)

    def erase_data(self, mode=0, on_stderr=False):
        # 0 (or None) should clear from the cursor to the end of the screen.
        # 1 should clear from the cursor to the beginning of the screen.
        # 2 should clear the entire screen. (And maybe move cursor to (1,1)?)
        #
        # At the moment, I only support mode 2. From looking at the API, it
        #    should be possible to calculate a different number of bytes to clear,
        #    and to do so relative to the cursor position.
        if mode[0] not in (2,):
            return
        handle = win32.STDOUT
        if on_stderr:
            handle = win32.STDERR
        # here's where we'll home the cursor
        coord_screen = win32.COORD(0,0)
        csbi = win32.GetConsoleScreenBufferInfo(handle)
        # get the number of character cells in the current buffer
        dw_con_size = csbi.dwSize.X * csbi.dwSize.Y
        # fill the entire screen with blanks
        win32.FillConsoleOutputCharacter(handle, ' ', dw_con_size, coord_screen)
        # now set the buffer's attributes accordingly
        win32.FillConsoleOutputAttribute(handle, self.get_attrs(), dw_con_size, coord_screen );
        # put the cursor at (0, 0)
        win32.SetConsoleCursorPosition(handle, (coord_screen.X, coord_screen.Y))

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-
#
# Copyright (C) 2013 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
from __future__ import absolute_import

import os
import re
import sys

if sys.version_info[0] < 3:
    from StringIO import StringIO
    string_types = basestring,
    text_type = unicode
    from types import FileType as file_type
    import __builtin__ as builtins
    import ConfigParser as configparser
    from ._backport import shutil
    from urlparse import urlparse, urlunparse, urljoin, urlsplit, urlunsplit
    from urllib import (urlretrieve, quote as _quote, unquote, url2pathname,
                        pathname2url, ContentTooShortError, splittype)

    def quote(s):
        if isinstance(s, unicode):
            s = s.encode('utf-8')
        return _quote(s)

    import urllib2
    from urllib2 import (Request, urlopen, URLError, HTTPError,
                         HTTPBasicAuthHandler, HTTPPasswordMgr,
                         HTTPSHandler, HTTPHandler, HTTPRedirectHandler,
                         build_opener)
    import httplib
    import xmlrpclib
    import Queue as queue
    from HTMLParser import HTMLParser
    import htmlentitydefs
    raw_input = raw_input
    from itertools import ifilter as filter
    from itertools import ifilterfalse as filterfalse

    _userprog = None
    def splituser(host):
        """splituser('user[:passwd]@host[:port]') --> 'user[:passwd]', 'host[:port]'."""
        global _userprog
        if _userprog is None:
            import re
            _userprog = re.compile('^(.*)@(.*)$')

        match = _userprog.match(host)
        if match: return match.group(1, 2)
        return None, host

else:
    from io import StringIO
    string_types = str,
    text_type = str
    from io import TextIOWrapper as file_type
    import builtins
    import configparser
    import shutil
    from urllib.parse import (urlparse, urlunparse, urljoin, splituser, quote,
                              unquote, urlsplit, urlunsplit, splittype)
    from urllib.request import (urlopen, urlretrieve, Request, url2pathname,
                                pathname2url,
                                HTTPBasicAuthHandler, HTTPPasswordMgr,
                                HTTPSHandler, HTTPHandler, HTTPRedirectHandler,
                                build_opener)
    from urllib.error import HTTPError, URLError, ContentTooShortError
    import http.client as httplib
    import urllib.request as urllib2
    import xmlrpc.client as xmlrpclib
    import queue
    from html.parser import HTMLParser
    import html.entities as htmlentitydefs
    raw_input = input
    from itertools import filterfalse
    filter = filter

try:
    from ssl import match_hostname, CertificateError
except ImportError:
    class CertificateError(ValueError):
        pass


    def _dnsname_to_pat(dn):
        pats = []
        for frag in dn.split(r'.'):
            if frag == '*':
                # When '*' is a fragment by itself, it matches a non-empty
                # dotless fragment.
                pats.append('[^.]+')
            else:
                # Otherwise, '*' matches any dotless fragment.
                frag = re.escape(frag)
                pats.append(frag.replace(r'\*', '[^.]*'))
        return re.compile(r'\A' + r'\.'.join(pats) + r'\Z', re.IGNORECASE)


    def match_hostname(cert, hostname):
        """Verify that *cert* (in decoded format as returned by
        SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 rules
        are mostly followed, but IP addresses are not accepted for *hostname*.

        CertificateError is raised on failure. On success, the function
        returns nothing.
        """
        if not cert:
            raise ValueError("empty or no certificate")
        dnsnames = []
        san = cert.get('subjectAltName', ())
        for key, value in san:
            if key == 'DNS':
                if _dnsname_to_pat(value).match(hostname):
                    return
                dnsnames.append(value)
        if not dnsnames:
            # The subject is only checked when there is no dNSName entry
            # in subjectAltName
            for sub in cert.get('subject', ()):
                for key, value in sub:
                    # XXX according to RFC 2818, the most specific Common Name
                    # must be used.
                    if key == 'commonName':
                        if _dnsname_to_pat(value).match(hostname):
                            return
                        dnsnames.append(value)
        if len(dnsnames) > 1:
            raise CertificateError("hostname %r "
                "doesn't match either of %s"
                % (hostname, ', '.join(map(repr, dnsnames))))
        elif len(dnsnames) == 1:
            raise CertificateError("hostname %r "
                "doesn't match %r"
                % (hostname, dnsnames[0]))
        else:
            raise CertificateError("no appropriate commonName or "
                "subjectAltName fields were found")


try:
    from types import SimpleNamespace as Container
except ImportError:
    class Container(object):
        """
        A generic container for when multiple values need to be returned
        """
        def __init__(self, **kwargs):
            self.__dict__.update(kwargs)


try:
    from shutil import which
except ImportError:
    # Implementation from Python 3.3
    def which(cmd, mode=os.F_OK | os.X_OK, path=None):
        """Given a command, mode, and a PATH string, return the path which
        conforms to the given mode on the PATH, or None if there is no such
        file.

        `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result
        of os.environ.get("PATH"), or can be overridden with a custom search
        path.

        """
        # Check that a given file can be accessed with the correct mode.
        # Additionally check that `file` is not a directory, as on Windows
        # directories pass the os.access check.
        def _access_check(fn, mode):
            return (os.path.exists(fn) and os.access(fn, mode)
                    and not os.path.isdir(fn))

        # If we're given a path with a directory part, look it up directly rather
        # than referring to PATH directories. This includes checking relative to the
        # current directory, e.g. ./script
        if os.path.dirname(cmd):
            if _access_check(cmd, mode):
                return cmd
            return None

        if path is None:
            path = os.environ.get("PATH", os.defpath)
        if not path:
            return None
        path = path.split(os.pathsep)

        if sys.platform == "win32":
            # The current directory takes precedence on Windows.
            if not os.curdir in path:
                path.insert(0, os.curdir)

            # PATHEXT is necessary to check on Windows.
            pathext = os.environ.get("PATHEXT", "").split(os.pathsep)
            # See if the given file matches any of the expected path extensions.
            # This will allow us to short circuit when given "python.exe".
            # If it does match, only test that one, otherwise we have to try
            # others.
            if any(cmd.lower().endswith(ext.lower()) for ext in pathext):
                files = [cmd]
            else:
                files = [cmd + ext for ext in pathext]
        else:
            # On other platforms you don't have things like PATHEXT to tell you
            # what file suffixes are executable, so just pass on cmd as-is.
            files = [cmd]

        seen = set()
        for dir in path:
            normdir = os.path.normcase(dir)
            if not normdir in seen:
                seen.add(normdir)
                for thefile in files:
                    name = os.path.join(dir, thefile)
                    if _access_check(name, mode):
                        return name
        return None


# ZipFile is a context manager in 2.7, but not in 2.6

from zipfile import ZipFile as BaseZipFile

if hasattr(BaseZipFile, '__enter__'):
    ZipFile = BaseZipFile
else:
    from zipfile import ZipExtFile as BaseZipExtFile

    class ZipExtFile(BaseZipExtFile):
        def __init__(self, base):
            self.__dict__.update(base.__dict__)

        def __enter__(self):
            return self

        def __exit__(self, *exc_info):
            self.close()
            # return None, so if an exception occurred, it will propagate

    class ZipFile(BaseZipFile):
        def __enter__(self):
            return self

        def __exit__(self, *exc_info):
            self.close()
            # return None, so if an exception occurred, it will propagate

        def open(self, *args, **kwargs):
            base = BaseZipFile.open(self, *args, **kwargs)
            return ZipExtFile(base)

try:
    from platform import python_implementation
except ImportError: # pragma: no cover
    def python_implementation():
        """Return a string identifying the Python implementation."""
        if 'PyPy' in sys.version:
            return 'PyPy'
        if os.name == 'java':
            return 'Jython'
        if sys.version.startswith('IronPython'):
            return 'IronPython'
        return 'CPython'

try:
    import sysconfig
except ImportError: # pragma: no cover
    from ._backport import sysconfig

try:
    callable = callable
except NameError:   # pragma: no cover
    from collections import Callable

    def callable(obj):
        return isinstance(obj, Callable)


try:
    fsencode = os.fsencode
    fsdecode = os.fsdecode
except AttributeError:  # pragma: no cover
    _fsencoding = sys.getfilesystemencoding()
    if _fsencoding == 'mbcs':
        _fserrors = 'strict'
    else:
        _fserrors = 'surrogateescape'

    def fsencode(filename):
        if isinstance(filename, bytes):
            return filename
        elif isinstance(filename, text_type):
            return filename.encode(_fsencoding, _fserrors)
        else:
            raise TypeError("expect bytes or str, not %s" %
                            type(filename).__name__)

    def fsdecode(filename):
        if isinstance(filename, text_type):
            return filename
        elif isinstance(filename, bytes):
            return filename.decode(_fsencoding, _fserrors)
        else:
            raise TypeError("expect bytes or str, not %s" %
                            type(filename).__name__)

try:
    from tokenize import detect_encoding
except ImportError: # pragma: no cover
    from codecs import BOM_UTF8, lookup
    import re

    cookie_re = re.compile("coding[:=]\s*([-\w.]+)")

    def _get_normal_name(orig_enc):
        """Imitates get_normal_name in tokenizer.c."""
        # Only care about the first 12 characters.
        enc = orig_enc[:12].lower().replace("_", "-")
        if enc == "utf-8" or enc.startswith("utf-8-"):
            return "utf-8"
        if enc in ("latin-1", "iso-8859-1", "iso-latin-1") or \
           enc.startswith(("latin-1-", "iso-8859-1-", "iso-latin-1-")):
            return "iso-8859-1"
        return orig_enc

    def detect_encoding(readline):
        """
        The detect_encoding() function is used to detect the encoding that should
        be used to decode a Python source file.  It requires one argment, readline,
        in the same way as the tokenize() generator.

        It will call readline a maximum of twice, and return the encoding used
        (as a string) and a list of any lines (left as bytes) it has read in.

        It detects the encoding from the presence of a utf-8 bom or an encoding
        cookie as specified in pep-0263.  If both a bom and a cookie are present,
        but disagree, a SyntaxError will be raised.  If the encoding cookie is an
        invalid charset, raise a SyntaxError.  Note that if a utf-8 bom is found,
        'utf-8-sig' is returned.

        If no encoding is specified, then the default of 'utf-8' will be returned.
        """
        try:
            filename = readline.__self__.name
        except AttributeError:
            filename = None
        bom_found = False
        encoding = None
        default = 'utf-8'
        def read_or_stop():
            try:
                return readline()
            except StopIteration:
                return b''

        def find_cookie(line):
            try:
                # Decode as UTF-8. Either the line is an encoding declaration,
                # in which case it should be pure ASCII, or it must be UTF-8
                # per default encoding.
                line_string = line.decode('utf-8')
            except UnicodeDecodeError:
                msg = "invalid or missing encoding declaration"
                if filename is not None:
                    msg = '{} for {!r}'.format(msg, filename)
                raise SyntaxError(msg)

            matches = cookie_re.findall(line_string)
            if not matches:
                return None
            encoding = _get_normal_name(matches[0])
            try:
                codec = lookup(encoding)
            except LookupError:
                # This behaviour mimics the Python interpreter
                if filename is None:
                    msg = "unknown encoding: " + encoding
                else:
                    msg = "unknown encoding for {!r}: {}".format(filename,
                            encoding)
                raise SyntaxError(msg)

            if bom_found:
                if codec.name != 'utf-8':
                    # This behaviour mimics the Python interpreter
                    if filename is None:
                        msg = 'encoding problem: utf-8'
                    else:
                        msg = 'encoding problem for {!r}: utf-8'.format(filename)
                    raise SyntaxError(msg)
                encoding += '-sig'
            return encoding

        first = read_or_stop()
        if first.startswith(BOM_UTF8):
            bom_found = True
            first = first[3:]
            default = 'utf-8-sig'
        if not first:
            return default, []

        encoding = find_cookie(first)
        if encoding:
            return encoding, [first]

        second = read_or_stop()
        if not second:
            return default, [first]

        encoding = find_cookie(second)
        if encoding:
            return encoding, [first, second]

        return default, [first, second]

# For converting & <-> &amp; etc.
try:
    from html import escape
except ImportError:
    from cgi import escape
if sys.version_info[:2] < (3, 4):
    unescape = HTMLParser().unescape
else:
    from html import unescape

try:
    from collections import ChainMap
except ImportError: # pragma: no cover
    from collections import MutableMapping

    try:
        from reprlib import recursive_repr as _recursive_repr
    except ImportError:
        def _recursive_repr(fillvalue='...'):
            '''
            Decorator to make a repr function return fillvalue for a recursive
            call
            '''

            def decorating_function(user_function):
                repr_running = set()

                def wrapper(self):
                    key = id(self), get_ident()
                    if key in repr_running:
                        return fillvalue
                    repr_running.add(key)
                    try:
                        result = user_function(self)
                    finally:
                        repr_running.discard(key)
                    return result

                # Can't use functools.wraps() here because of bootstrap issues
                wrapper.__module__ = getattr(user_function, '__module__')
                wrapper.__doc__ = getattr(user_function, '__doc__')
                wrapper.__name__ = getattr(user_function, '__name__')
                wrapper.__annotations__ = getattr(user_function, '__annotations__', {})
                return wrapper

            return decorating_function

    class ChainMap(MutableMapping):
        ''' A ChainMap groups multiple dicts (or other mappings) together
        to create a single, updateable view.

        The underlying mappings are stored in a list.  That list is public and can
        accessed or updated using the *maps* attribute.  There is no other state.

        Lookups search the underlying mappings successively until a key is found.
        In contrast, writes, updates, and deletions only operate on the first
        mapping.

        '''

        def __init__(self, *maps):
            '''Initialize a ChainMap by setting *maps* to the given mappings.
            If no mappings are provided, a single empty dictionary is used.

            '''
            self.maps = list(maps) or [{}]          # always at least one map

        def __missing__(self, key):
            raise KeyError(key)

        def __getitem__(self, key):
            for mapping in self.maps:
                try:
                    return mapping[key]             # can't use 'key in mapping' with defaultdict
                except KeyError:
                    pass
            return self.__missing__(key)            # support subclasses that define __missing__

        def get(self, key, default=None):
            return self[key] if key in self else default

        def __len__(self):
            return len(set().union(*self.maps))     # reuses stored hash values if possible

        def __iter__(self):
            return iter(set().union(*self.maps))

        def __contains__(self, key):
            return any(key in m for m in self.maps)

        def __bool__(self):
            return any(self.maps)

        @_recursive_repr()
        def __repr__(self):
            return '{0.__class__.__name__}({1})'.format(
                self, ', '.join(map(repr, self.maps)))

        @classmethod
        def fromkeys(cls, iterable, *args):
            'Create a ChainMap with a single dict created from the iterable.'
            return cls(dict.fromkeys(iterable, *args))

        def copy(self):
            'New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]'
            return self.__class__(self.maps[0].copy(), *self.maps[1:])

        __copy__ = copy

        def new_child(self):                        # like Django's Context.push()
            'New ChainMap with a new dict followed by all previous maps.'
            return self.__class__({}, *self.maps)

        @property
        def parents(self):                          # like Django's Context.pop()
            'New ChainMap from maps[1:].'
            return self.__class__(*self.maps[1:])

        def __setitem__(self, key, value):
            self.maps[0][key] = value

        def __delitem__(self, key):
            try:
                del self.maps[0][key]
            except KeyError:
                raise KeyError('Key not found in the first mapping: {!r}'.format(key))

        def popitem(self):
            'Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.'
            try:
                return self.maps[0].popitem()
            except KeyError:
                raise KeyError('No keys found in the first mapping.')

        def pop(self, key, *args):
            'Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].'
            try:
                return self.maps[0].pop(key, *args)
            except KeyError:
                raise KeyError('Key not found in the first mapping: {!r}'.format(key))

        def clear(self):
            'Clear maps[0], leaving maps[1:] intact.'
            self.maps[0].clear()

try:
    from imp import cache_from_source
except ImportError: # pragma: no cover
    def cache_from_source(path, debug_override=None):
        assert path.endswith('.py')
        if debug_override is None:
            debug_override = __debug__
        if debug_override:
            suffix = 'c'
        else:
            suffix = 'o'
        return path + suffix

try:
    from collections import OrderedDict
except ImportError: # pragma: no cover
## {{{ http://code.activestate.com/recipes/576693/ (r9)
# Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
# Passes Python2.7's test suite and incorporates all the latest updates.
    try:
        from thread import get_ident as _get_ident
    except ImportError:
        from dummy_thread import get_ident as _get_ident

    try:
        from _abcoll import KeysView, ValuesView, ItemsView
    except ImportError:
        pass


    class OrderedDict(dict):
        'Dictionary that remembers insertion order'
        # An inherited dict maps keys to values.
        # The inherited dict provides __getitem__, __len__, __contains__, and get.
        # The remaining methods are order-aware.
        # Big-O running times for all methods are the same as for regular dictionaries.

        # The internal self.__map dictionary maps keys to links in a doubly linked list.
        # The circular doubly linked list starts and ends with a sentinel element.
        # The sentinel element never gets deleted (this simplifies the algorithm).
        # Each link is stored as a list of length three:  [PREV, NEXT, KEY].

        def __init__(self, *args, **kwds):
            '''Initialize an ordered dictionary.  Signature is the same as for
            regular dictionaries, but keyword arguments are not recommended
            because their insertion order is arbitrary.

            '''
            if len(args) > 1:
                raise TypeError('expected at most 1 arguments, got %d' % len(args))
            try:
                self.__root
            except AttributeError:
                self.__root = root = []                     # sentinel node
                root[:] = [root, root, None]
                self.__map = {}
            self.__update(*args, **kwds)

        def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
            'od.__setitem__(i, y) <==> od[i]=y'
            # Setting a new item creates a new link which goes at the end of the linked
            # list, and the inherited dictionary is updated with the new key/value pair.
            if key not in self:
                root = self.__root
                last = root[0]
                last[1] = root[0] = self.__map[key] = [last, root, key]
            dict_setitem(self, key, value)

        def __delitem__(self, key, dict_delitem=dict.__delitem__):
            'od.__delitem__(y) <==> del od[y]'
            # Deleting an existing item uses self.__map to find the link which is
            # then removed by updating the links in the predecessor and successor nodes.
            dict_delitem(self, key)
            link_prev, link_next, key = self.__map.pop(key)
            link_prev[1] = link_next
            link_next[0] = link_prev

        def __iter__(self):
            'od.__iter__() <==> iter(od)'
            root = self.__root
            curr = root[1]
            while curr is not root:
                yield curr[2]
                curr = curr[1]

        def __reversed__(self):
            'od.__reversed__() <==> reversed(od)'
            root = self.__root
            curr = root[0]
            while curr is not root:
                yield curr[2]
                curr = curr[0]

        def clear(self):
            'od.clear() -> None.  Remove all items from od.'
            try:
                for node in self.__map.itervalues():
                    del node[:]
                root = self.__root
                root[:] = [root, root, None]
                self.__map.clear()
            except AttributeError:
                pass
            dict.clear(self)

        def popitem(self, last=True):
            '''od.popitem() -> (k, v), return and remove a (key, value) pair.
            Pairs are returned in LIFO order if last is true or FIFO order if false.

            '''
            if not self:
                raise KeyError('dictionary is empty')
            root = self.__root
            if last:
                link = root[0]
                link_prev = link[0]
                link_prev[1] = root
                root[0] = link_prev
            else:
                link = root[1]
                link_next = link[1]
                root[1] = link_next
                link_next[0] = root
            key = link[2]
            del self.__map[key]
            value = dict.pop(self, key)
            return key, value

        # -- the following methods do not depend on the internal structure --

        def keys(self):
            'od.keys() -> list of keys in od'
            return list(self)

        def values(self):
            'od.values() -> list of values in od'
            return [self[key] for key in self]

        def items(self):
            'od.items() -> list of (key, value) pairs in od'
            return [(key, self[key]) for key in self]

        def iterkeys(self):
            'od.iterkeys() -> an iterator over the keys in od'
            return iter(self)

        def itervalues(self):
            'od.itervalues -> an iterator over the values in od'
            for k in self:
                yield self[k]

        def iteritems(self):
            'od.iteritems -> an iterator over the (key, value) items in od'
            for k in self:
                yield (k, self[k])

        def update(*args, **kwds):
            '''od.update(E, **F) -> None.  Update od from dict/iterable E and F.

            If E is a dict instance, does:           for k in E: od[k] = E[k]
            If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
            Or if E is an iterable of items, does:   for k, v in E: od[k] = v
            In either case, this is followed by:     for k, v in F.items(): od[k] = v

            '''
            if len(args) > 2:
                raise TypeError('update() takes at most 2 positional '
                                'arguments (%d given)' % (len(args),))
            elif not args:
                raise TypeError('update() takes at least 1 argument (0 given)')
            self = args[0]
            # Make progressively weaker assumptions about "other"
            other = ()
            if len(args) == 2:
                other = args[1]
            if isinstance(other, dict):
                for key in other:
                    self[key] = other[key]
            elif hasattr(other, 'keys'):
                for key in other.keys():
                    self[key] = other[key]
            else:
                for key, value in other:
                    self[key] = value
            for key, value in kwds.items():
                self[key] = value

        __update = update  # let subclasses override update without breaking __init__

        __marker = object()

        def pop(self, key, default=__marker):
            '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.
            If key is not found, d is returned if given, otherwise KeyError is raised.

            '''
            if key in self:
                result = self[key]
                del self[key]
                return result
            if default is self.__marker:
                raise KeyError(key)
            return default

        def setdefault(self, key, default=None):
            'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
            if key in self:
                return self[key]
            self[key] = default
            return default

        def __repr__(self, _repr_running=None):
            'od.__repr__() <==> repr(od)'
            if not _repr_running: _repr_running = {}
            call_key = id(self), _get_ident()
            if call_key in _repr_running:
                return '...'
            _repr_running[call_key] = 1
            try:
                if not self:
                    return '%s()' % (self.__class__.__name__,)
                return '%s(%r)' % (self.__class__.__name__, self.items())
            finally:
                del _repr_running[call_key]

        def __reduce__(self):
            'Return state information for pickling'
            items = [[k, self[k]] for k in self]
            inst_dict = vars(self).copy()
            for k in vars(OrderedDict()):
                inst_dict.pop(k, None)
            if inst_dict:
                return (self.__class__, (items,), inst_dict)
            return self.__class__, (items,)

        def copy(self):
            'od.copy() -> a shallow copy of od'
            return self.__class__(self)

        @classmethod
        def fromkeys(cls, iterable, value=None):
            '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S
            and values equal to v (which defaults to None).

            '''
            d = cls()
            for key in iterable:
                d[key] = value
            return d

        def __eq__(self, other):
            '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
            while comparison to a regular mapping is order-insensitive.

            '''
            if isinstance(other, OrderedDict):
                return len(self)==len(other) and self.items() == other.items()
            return dict.__eq__(self, other)

        def __ne__(self, other):
            return not self == other

        # -- the following methods are only used in Python 2.7 --

        def viewkeys(self):
            "od.viewkeys() -> a set-like object providing a view on od's keys"
            return KeysView(self)

        def viewvalues(self):
            "od.viewvalues() -> an object providing a view on od's values"
            return ValuesView(self)

        def viewitems(self):
            "od.viewitems() -> a set-like object providing a view on od's items"
            return ItemsView(self)

try:
    from logging.config import BaseConfigurator, valid_ident
except ImportError: # pragma: no cover
    IDENTIFIER = re.compile('^[a-z_][a-z0-9_]*$', re.I)


    def valid_ident(s):
        m = IDENTIFIER.match(s)
        if not m:
            raise ValueError('Not a valid Python identifier: %r' % s)
        return True


    # The ConvertingXXX classes are wrappers around standard Python containers,
    # and they serve to convert any suitable values in the container. The
    # conversion converts base dicts, lists and tuples to their wrapped
    # equivalents, whereas strings which match a conversion format are converted
    # appropriately.
    #
    # Each wrapper should have a configurator attribute holding the actual
    # configurator to use for conversion.

    class ConvertingDict(dict):
        """A converting dictionary wrapper."""

        def __getitem__(self, key):
            value = dict.__getitem__(self, key)
            result = self.configurator.convert(value)
            #If the converted value is different, save for next time
            if value is not result:
                self[key] = result
                if type(result) in (ConvertingDict, ConvertingList,
                                    ConvertingTuple):
                    result.parent = self
                    result.key = key
            return result

        def get(self, key, default=None):
            value = dict.get(self, key, default)
            result = self.configurator.convert(value)
            #If the converted value is different, save for next time
            if value is not result:
                self[key] = result
                if type(result) in (ConvertingDict, ConvertingList,
                                    ConvertingTuple):
                    result.parent = self
                    result.key = key
            return result

    def pop(self, key, default=None):
        value = dict.pop(self, key, default)
        result = self.configurator.convert(value)
        if value is not result:
            if type(result) in (ConvertingDict, ConvertingList,
                                ConvertingTuple):
                result.parent = self
                result.key = key
        return result

    class ConvertingList(list):
        """A converting list wrapper."""
        def __getitem__(self, key):
            value = list.__getitem__(self, key)
            result = self.configurator.convert(value)
            #If the converted value is different, save for next time
            if value is not result:
                self[key] = result
                if type(result) in (ConvertingDict, ConvertingList,
                                    ConvertingTuple):
                    result.parent = self
                    result.key = key
            return result

        def pop(self, idx=-1):
            value = list.pop(self, idx)
            result = self.configurator.convert(value)
            if value is not result:
                if type(result) in (ConvertingDict, ConvertingList,
                                    ConvertingTuple):
                    result.parent = self
            return result

    class ConvertingTuple(tuple):
        """A converting tuple wrapper."""
        def __getitem__(self, key):
            value = tuple.__getitem__(self, key)
            result = self.configurator.convert(value)
            if value is not result:
                if type(result) in (ConvertingDict, ConvertingList,
                                    ConvertingTuple):
                    result.parent = self
                    result.key = key
            return result

    class BaseConfigurator(object):
        """
        The configurator base class which defines some useful defaults.
        """

        CONVERT_PATTERN = re.compile(r'^(?P<prefix>[a-z]+)://(?P<suffix>.*)$')

        WORD_PATTERN = re.compile(r'^\s*(\w+)\s*')
        DOT_PATTERN = re.compile(r'^\.\s*(\w+)\s*')
        INDEX_PATTERN = re.compile(r'^\[\s*(\w+)\s*\]\s*')
        DIGIT_PATTERN = re.compile(r'^\d+$')

        value_converters = {
            'ext' : 'ext_convert',
            'cfg' : 'cfg_convert',
        }

        # We might want to use a different one, e.g. importlib
        importer = staticmethod(__import__)

        def __init__(self, config):
            self.config = ConvertingDict(config)
            self.config.configurator = self

        def resolve(self, s):
            """
            Resolve strings to objects using standard import and attribute
            syntax.
            """
            name = s.split('.')
            used = name.pop(0)
            try:
                found = self.importer(used)
                for frag in name:
                    used += '.' + frag
                    try:
                        found = getattr(found, frag)
                    except AttributeError:
                        self.importer(used)
                        found = getattr(found, frag)
                return found
            except ImportError:
                e, tb = sys.exc_info()[1:]
                v = ValueError('Cannot resolve %r: %s' % (s, e))
                v.__cause__, v.__traceback__ = e, tb
                raise v

        def ext_convert(self, value):
            """Default converter for the ext:// protocol."""
            return self.resolve(value)

        def cfg_convert(self, value):
            """Default converter for the cfg:// protocol."""
            rest = value
            m = self.WORD_PATTERN.match(rest)
            if m is None:
                raise ValueError("Unable to convert %r" % value)
            else:
                rest = rest[m.end():]
                d = self.config[m.groups()[0]]
                #print d, rest
                while rest:
                    m = self.DOT_PATTERN.match(rest)
                    if m:
                        d = d[m.groups()[0]]
                    else:
                        m = self.INDEX_PATTERN.match(rest)
                        if m:
                            idx = m.groups()[0]
                            if not self.DIGIT_PATTERN.match(idx):
                                d = d[idx]
                            else:
                                try:
                                    n = int(idx) # try as number first (most likely)
                                    d = d[n]
                                except TypeError:
                                    d = d[idx]
                    if m:
                        rest = rest[m.end():]
                    else:
                        raise ValueError('Unable to convert '
                                         '%r at %r' % (value, rest))
            #rest should be empty
            return d

        def convert(self, value):
            """
            Convert values to an appropriate type. dicts, lists and tuples are
            replaced by their converting alternatives. Strings are checked to
            see if they have a conversion format and are converted if they do.
            """
            if not isinstance(value, ConvertingDict) and isinstance(value, dict):
                value = ConvertingDict(value)
                value.configurator = self
            elif not isinstance(value, ConvertingList) and isinstance(value, list):
                value = ConvertingList(value)
                value.configurator = self
            elif not isinstance(value, ConvertingTuple) and\
                     isinstance(value, tuple):
                value = ConvertingTuple(value)
                value.configurator = self
            elif isinstance(value, string_types):
                m = self.CONVERT_PATTERN.match(value)
                if m:
                    d = m.groupdict()
                    prefix = d['prefix']
                    converter = self.value_converters.get(prefix, None)
                    if converter:
                        suffix = d['suffix']
                        converter = getattr(self, converter)
                        value = converter(suffix)
            return value

        def configure_custom(self, config):
            """Configure an object with a user-supplied factory."""
            c = config.pop('()')
            if not callable(c):
                c = self.resolve(c)
            props = config.pop('.', None)
            # Check for valid identifiers
            kwargs = dict([(k, config[k]) for k in config if valid_ident(k)])
            result = c(**kwargs)
            if props:
                for name, value in props.items():
                    setattr(result, name, value)
            return result

        def as_tuple(self, value):
            """Utility function which converts lists to tuples."""
            if isinstance(value, list):
                value = tuple(value)
            return value

########NEW FILE########
__FILENAME__ = database
# -*- coding: utf-8 -*-
#
# Copyright (C) 2012-2013 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""PEP 376 implementation."""

from __future__ import unicode_literals

import base64
import codecs
import contextlib
import hashlib
import logging
import os
import posixpath
import sys
import zipimport

from . import DistlibException, resources
from .compat import StringIO
from .version import get_scheme, UnsupportedVersionError
from .metadata import Metadata, METADATA_FILENAME
from .util import (parse_requirement, cached_property, parse_name_and_version,
                   read_exports, write_exports, CSVReader, CSVWriter)


__all__ = ['Distribution', 'BaseInstalledDistribution',
           'InstalledDistribution', 'EggInfoDistribution',
           'DistributionPath']


logger = logging.getLogger(__name__)

EXPORTS_FILENAME = 'pydist-exports.json'
COMMANDS_FILENAME = 'pydist-commands.json'

DIST_FILES = ('INSTALLER', METADATA_FILENAME, 'RECORD', 'REQUESTED',
              'RESOURCES', EXPORTS_FILENAME, 'SHARED')

DISTINFO_EXT = '.dist-info'


class _Cache(object):
    """
    A simple cache mapping names and .dist-info paths to distributions
    """
    def __init__(self):
        """
        Initialise an instance. There is normally one for each DistributionPath.
        """
        self.name = {}
        self.path = {}
        self.generated = False

    def clear(self):
        """
        Clear the cache, setting it to its initial state.
        """
        self.name.clear()
        self.path.clear()
        self.generated = False

    def add(self, dist):
        """
        Add a distribution to the cache.
        :param dist: The distribution to add.
        """
        if dist.path not in self.path:
            self.path[dist.path] = dist
            self.name.setdefault(dist.key, []).append(dist)


class DistributionPath(object):
    """
    Represents a set of distributions installed on a path (typically sys.path).
    """
    def __init__(self, path=None, include_egg=False):
        """
        Create an instance from a path, optionally including legacy (distutils/
        setuptools/distribute) distributions.
        :param path: The path to use, as a list of directories. If not specified,
                     sys.path is used.
        :param include_egg: If True, this instance will look for and return legacy
                            distributions as well as those based on PEP 376.
        """
        if path is None:
            path = sys.path
        self.path = path
        self._include_dist = True
        self._include_egg = include_egg

        self._cache = _Cache()
        self._cache_egg = _Cache()
        self._cache_enabled = True
        self._scheme = get_scheme('default')

    def _get_cache_enabled(self):
        return self._cache_enabled

    def _set_cache_enabled(self, value):
        self._cache_enabled = value

    cache_enabled = property(_get_cache_enabled, _set_cache_enabled)

    def clear_cache(self):
        """
        Clears the internal cache.
        """
        self._cache.clear()
        self._cache_egg.clear()


    def _yield_distributions(self):
        """
        Yield .dist-info and/or .egg(-info) distributions.
        """
        # We need to check if we've seen some resources already, because on
        # some Linux systems (e.g. some Debian/Ubuntu variants) there are
        # symlinks which alias other files in the environment.
        seen = set()
        for path in self.path:
            finder = resources.finder_for_path(path)
            if finder is None:
                continue
            r = finder.find('')
            if not r or not r.is_container:
                continue
            rset = sorted(r.resources)
            for entry in rset:
                r = finder.find(entry)
                if not r or r.path in seen:
                    continue
                if self._include_dist and entry.endswith(DISTINFO_EXT):
                    metadata_path = posixpath.join(entry, METADATA_FILENAME)
                    pydist = finder.find(metadata_path)
                    if not pydist:
                        continue

                    metadata = Metadata(fileobj=pydist.as_stream(),
                                        scheme='legacy')
                    logger.debug('Found %s', r.path)
                    seen.add(r.path)
                    yield new_dist_class(r.path, metadata=metadata,
                                         env=self)
                elif self._include_egg and entry.endswith(('.egg-info',
                                                          '.egg')):
                    logger.debug('Found %s', r.path)
                    seen.add(r.path)
                    yield old_dist_class(r.path, self)

    def _generate_cache(self):
        """
        Scan the path for distributions and populate the cache with
        those that are found.
        """
        gen_dist = not self._cache.generated
        gen_egg = self._include_egg and not self._cache_egg.generated
        if gen_dist or gen_egg:
            for dist in self._yield_distributions():
                if isinstance(dist, InstalledDistribution):
                    self._cache.add(dist)
                else:
                    self._cache_egg.add(dist)

            if gen_dist:
                self._cache.generated = True
            if gen_egg:
                self._cache_egg.generated = True

    @classmethod
    def distinfo_dirname(cls, name, version):
        """
        The *name* and *version* parameters are converted into their
        filename-escaped form, i.e. any ``'-'`` characters are replaced
        with ``'_'`` other than the one in ``'dist-info'`` and the one
        separating the name from the version number.

        :parameter name: is converted to a standard distribution name by replacing
                         any runs of non- alphanumeric characters with a single
                         ``'-'``.
        :type name: string
        :parameter version: is converted to a standard version string. Spaces
                            become dots, and all other non-alphanumeric characters
                            (except dots) become dashes, with runs of multiple
                            dashes condensed to a single dash.
        :type version: string
        :returns: directory name
        :rtype: string"""
        name = name.replace('-', '_')
        return '-'.join([name, version]) + DISTINFO_EXT

    def get_distributions(self):
        """
        Provides an iterator that looks for distributions and returns
        :class:`InstalledDistribution` or
        :class:`EggInfoDistribution` instances for each one of them.

        :rtype: iterator of :class:`InstalledDistribution` and
                :class:`EggInfoDistribution` instances
        """
        if not self._cache_enabled:
            for dist in self._yield_distributions():
                yield dist
        else:
            self._generate_cache()

            for dist in self._cache.path.values():
                yield dist

            if self._include_egg:
                for dist in self._cache_egg.path.values():
                    yield dist

    def get_distribution(self, name):
        """
        Looks for a named distribution on the path.

        This function only returns the first result found, as no more than one
        value is expected. If nothing is found, ``None`` is returned.

        :rtype: :class:`InstalledDistribution`, :class:`EggInfoDistribution`
                or ``None``
        """
        result = None
        name = name.lower()
        if not self._cache_enabled:
            for dist in self._yield_distributions():
                if dist.key == name:
                    result = dist
                    break
        else:
            self._generate_cache()

            if name in self._cache.name:
                result = self._cache.name[name][0]
            elif self._include_egg and name in self._cache_egg.name:
                result = self._cache_egg.name[name][0]
        return result

    def provides_distribution(self, name, version=None):
        """
        Iterates over all distributions to find which distributions provide *name*.
        If a *version* is provided, it will be used to filter the results.

        This function only returns the first result found, since no more than
        one values are expected. If the directory is not found, returns ``None``.

        :parameter version: a version specifier that indicates the version
                            required, conforming to the format in ``PEP-345``

        :type name: string
        :type version: string
        """
        matcher = None
        if not version is None:
            try:
                matcher = self._scheme.matcher('%s (%s)' % (name, version))
            except ValueError:
                raise DistlibException('invalid name or version: %r, %r' %
                                      (name, version))

        for dist in self.get_distributions():
            provided = dist.provides

            for p in provided:
                p_name, p_ver = parse_name_and_version(p)
                if matcher is None:
                    if p_name == name:
                        yield dist
                        break
                else:
                    if p_name == name and matcher.match(p_ver):
                        yield dist
                        break

    def get_file_path(self, name, relative_path):
        """
        Return the path to a resource file.
        """
        dist = self.get_distribution(name)
        if dist is None:
            raise LookupError('no distribution named %r found' % name)
        return dist.get_resource_path(relative_path)

    def get_exported_entries(self, category, name=None):
        """
        Return all of the exported entries in a particular category.

        :param category: The category to search for entries.
        :param name: If specified, only entries with that name are returned.
        """
        for dist in self.get_distributions():
            r = dist.exports
            if category in r:
                d = r[category]
                if name is not None:
                    if name in d:
                        yield d[name]
                else:
                    for v in d.values():
                        yield v


class Distribution(object):
    """
    A base class for distributions, whether installed or from indexes.
    Either way, it must have some metadata, so that's all that's needed
    for construction.
    """

    build_time_dependency = False
    """
    Set to True if it's known to be only a build-time dependency (i.e.
    not needed after installation).
    """

    requested = False
    """A boolean that indicates whether the ``REQUESTED`` metadata file is
    present (in other words, whether the package was installed by user
    request or it was installed as a dependency)."""

    def __init__(self, metadata):
        """
        Initialise an instance.
        :param metadata: The instance of :class:`Metadata` describing this
        distribution.
        """
        self.metadata = metadata
        self.name = metadata.name
        self.key = self.name.lower()    # for case-insensitive comparisons
        self.version = metadata.version
        self.locator = None
        self.digest = None
        self.extras = None      # additional features requested
        self.context = None     # environment marker overrides

    @property
    def source_url(self):
        """
        The source archive download URL for this distribution.
        """
        return self.metadata.source_url

    download_url = source_url   # Backward compatibility

    @property
    def name_and_version(self):
        """
        A utility property which displays the name and version in parentheses.
        """
        return '%s (%s)' % (self.name, self.version)

    @property
    def provides(self):
        """
        A set of distribution names and versions provided by this distribution.
        :return: A set of "name (version)" strings.
        """
        plist = self.metadata.provides
        s = '%s (%s)' % (self.name, self.version)
        if s not in plist:
            plist.append(s)
        return plist

    def _get_requirements(self, req_attr):
        reqts = getattr(self.metadata, req_attr)
        return set(self.metadata.get_requirements(reqts, extras=self.extras,
                                                  env=self.context))

    @property
    def run_requires(self):
        return self._get_requirements('run_requires')

    @property
    def meta_requires(self):
        return self._get_requirements('meta_requires')

    @property
    def build_requires(self):
        return self._get_requirements('build_requires')

    @property
    def test_requires(self):
        return self._get_requirements('test_requires')

    @property
    def dev_requires(self):
        return self._get_requirements('dev_requires')

    def matches_requirement(self, req):
        """
        Say if this instance matches (fulfills) a requirement.
        :param req: The requirement to match.
        :rtype req: str
        :return: True if it matches, else False.
        """
        # Requirement may contain extras - parse to lose those
        # from what's passed to the matcher
        r = parse_requirement(req)
        scheme = get_scheme(self.metadata.scheme)
        try:
            matcher = scheme.matcher(r.requirement)
        except UnsupportedVersionError:
            # XXX compat-mode if cannot read the version
            logger.warning('could not read version %r - using name only',
                           req)
            name = req.split()[0]
            matcher = scheme.matcher(name)

        name = matcher.key   # case-insensitive

        result = False
        for p in self.provides:
            p_name, p_ver = parse_name_and_version(p)
            if p_name != name:
                continue
            try:
                result = matcher.match(p_ver)
                break
            except UnsupportedVersionError:
                pass
        return result

    def __repr__(self):
        """
        Return a textual representation of this instance,
        """
        if self.source_url:
            suffix = ' [%s]' % self.source_url
        else:
            suffix = ''
        return '<Distribution %s (%s)%s>' % (self.name, self.version, suffix)

    def __eq__(self, other):
        """
        See if this distribution is the same as another.
        :param other: The distribution to compare with. To be equal to one
                      another. distributions must have the same type, name,
                      version and source_url.
        :return: True if it is the same, else False.
        """
        if type(other) is not type(self):
            result = False
        else:
            result = (self.name == other.name and
                      self.version == other.version and
                      self.source_url == other.source_url)
        return result

    def __hash__(self):
        """
        Compute hash in a way which matches the equality test.
        """
        return hash(self.name) + hash(self.version) + hash(self.source_url)


class BaseInstalledDistribution(Distribution):
    """
    This is the base class for installed distributions (whether PEP 376 or
    legacy).
    """

    hasher = None

    def __init__(self, metadata, path, env=None):
        """
        Initialise an instance.
        :param metadata: An instance of :class:`Metadata` which describes the
                         distribution. This will normally have been initialised
                         from a metadata file in the ``path``.
        :param path:     The path of the ``.dist-info`` or ``.egg-info``
                         directory for the distribution.
        :param env:      This is normally the :class:`DistributionPath`
                         instance where this distribution was found.
        """
        super(BaseInstalledDistribution, self).__init__(metadata)
        self.path = path
        self.dist_path = env

    def get_hash(self, data, hasher=None):
        """
        Get the hash of some data, using a particular hash algorithm, if
        specified.

        :param data: The data to be hashed.
        :type data: bytes
        :param hasher: The name of a hash implementation, supported by hashlib,
                       or ``None``. Examples of valid values are ``'sha1'``,
                       ``'sha224'``, ``'sha384'``, '``sha256'``, ``'md5'`` and
                       ``'sha512'``. If no hasher is specified, the ``hasher``
                       attribute of the :class:`InstalledDistribution` instance
                       is used. If the hasher is determined to be ``None``, MD5
                       is used as the hashing algorithm.
        :returns: The hash of the data. If a hasher was explicitly specified,
                  the returned hash will be prefixed with the specified hasher
                  followed by '='.
        :rtype: str
        """
        if hasher is None:
            hasher = self.hasher
        if hasher is None:
            hasher = hashlib.md5
            prefix = ''
        else:
            hasher = getattr(hashlib, hasher)
            prefix = '%s=' % self.hasher
        digest = hasher(data).digest()
        digest = base64.urlsafe_b64encode(digest).rstrip(b'=').decode('ascii')
        return '%s%s' % (prefix, digest)


class InstalledDistribution(BaseInstalledDistribution):
    """
    Created with the *path* of the ``.dist-info`` directory provided to the
    constructor. It reads the metadata contained in ``pydist.json`` when it is
    instantiated., or uses a passed in Metadata instance (useful for when
    dry-run mode is being used).
    """

    hasher = 'sha256'

    def __init__(self, path, metadata=None, env=None):
        self.finder = finder = resources.finder_for_path(path)
        if finder is None:
            import pdb; pdb.set_trace ()
        if env and env._cache_enabled and path in env._cache.path:
            metadata = env._cache.path[path].metadata
        elif metadata is None:
            r = finder.find(METADATA_FILENAME)
            # Temporary - for legacy support
            if r is None:
                r = finder.find('METADATA')
            if r is None:
                raise ValueError('no %s found in %s' % (METADATA_FILENAME,
                                                        path))
            with contextlib.closing(r.as_stream()) as stream:
                metadata = Metadata(fileobj=stream, scheme='legacy')

        super(InstalledDistribution, self).__init__(metadata, path, env)

        if env and env._cache_enabled:
            env._cache.add(self)

        try:
            r = finder.find('REQUESTED')
        except AttributeError:
            import pdb; pdb.set_trace ()
        self.requested = r is not None

    def __repr__(self):
        return '<InstalledDistribution %r %s at %r>' % (
            self.name, self.version, self.path)

    def __str__(self):
        return "%s %s" % (self.name, self.version)

    def _get_records(self):
        """
        Get the list of installed files for the distribution
        :return: A list of tuples of path, hash and size. Note that hash and
                 size might be ``None`` for some entries. The path is exactly
                 as stored in the file (which is as in PEP 376).
        """
        results = []
        r = self.get_distinfo_resource('RECORD')
        with contextlib.closing(r.as_stream()) as stream:
            with CSVReader(stream=stream) as record_reader:
                # Base location is parent dir of .dist-info dir
                #base_location = os.path.dirname(self.path)
                #base_location = os.path.abspath(base_location)
                for row in record_reader:
                    missing = [None for i in range(len(row), 3)]
                    path, checksum, size = row + missing
                    #if not os.path.isabs(path):
                    #    path = path.replace('/', os.sep)
                    #    path = os.path.join(base_location, path)
                    results.append((path, checksum, size))
        return results

    @cached_property
    def exports(self):
        """
        Return the information exported by this distribution.
        :return: A dictionary of exports, mapping an export category to a dict
                 of :class:`ExportEntry` instances describing the individual
                 export entries, and keyed by name.
        """
        result = {}
        r = self.get_distinfo_resource(EXPORTS_FILENAME)
        if r:
            result = self.read_exports()
        return result

    def read_exports(self):
        """
        Read exports data from a file in .ini format.

        :return: A dictionary of exports, mapping an export category to a list
                 of :class:`ExportEntry` instances describing the individual
                 export entries.
        """
        result = {}
        r = self.get_distinfo_resource(EXPORTS_FILENAME)
        if r:
            with contextlib.closing(r.as_stream()) as stream:
                result = read_exports(stream)
        return result

    def write_exports(self, exports):
        """
        Write a dictionary of exports to a file in .ini format.
        :param exports: A dictionary of exports, mapping an export category to
                        a list of :class:`ExportEntry` instances describing the
                        individual export entries.
        """
        rf = self.get_distinfo_file(EXPORTS_FILENAME)
        with open(rf, 'w') as f:
            write_exports(exports, f)

    def get_resource_path(self, relative_path):
        """
        NOTE: This API may change in the future.

        Return the absolute path to a resource file with the given relative
        path.

        :param relative_path: The path, relative to .dist-info, of the resource
                              of interest.
        :return: The absolute path where the resource is to be found.
        """
        r = self.get_distinfo_resource('RESOURCES')
        with contextlib.closing(r.as_stream()) as stream:
            with CSVReader(stream=stream) as resources_reader:
                for relative, destination in resources_reader:
                    if relative == relative_path:
                        return destination
        raise KeyError('no resource file with relative path %r '
                       'is installed' % relative_path)

    def list_installed_files(self):
        """
        Iterates over the ``RECORD`` entries and returns a tuple
        ``(path, hash, size)`` for each line.

        :returns: iterator of (path, hash, size)
        """
        for result in self._get_records():
            yield result

    def write_installed_files(self, paths, prefix, dry_run=False):
        """
        Writes the ``RECORD`` file, using the ``paths`` iterable passed in. Any
        existing ``RECORD`` file is silently overwritten.

        prefix is used to determine when to write absolute paths.
        """
        prefix = os.path.join(prefix, '')
        base = os.path.dirname(self.path)
        base_under_prefix = base.startswith(prefix)
        base = os.path.join(base, '')
        record_path = self.get_distinfo_file('RECORD')
        logger.info('creating %s', record_path)
        if dry_run:
            return None
        with CSVWriter(record_path) as writer:
            for path in paths:
                if os.path.isdir(path) or path.endswith(('.pyc', '.pyo')):
                    # do not put size and hash, as in PEP-376
                    hash_value = size = ''
                else:
                    size = '%d' % os.path.getsize(path)
                    with open(path, 'rb') as fp:
                        hash_value = self.get_hash(fp.read())
                if path.startswith(base) or (base_under_prefix and
                                             path.startswith(prefix)):
                    path = os.path.relpath(path, base)
                writer.writerow((path, hash_value, size))

            # add the RECORD file itself
            if record_path.startswith(base):
                record_path = os.path.relpath(record_path, base)
            writer.writerow((record_path, '', ''))
        return record_path

    def check_installed_files(self):
        """
        Checks that the hashes and sizes of the files in ``RECORD`` are
        matched by the files themselves. Returns a (possibly empty) list of
        mismatches. Each entry in the mismatch list will be a tuple consisting
        of the path, 'exists', 'size' or 'hash' according to what didn't match
        (existence is checked first, then size, then hash), the expected
        value and the actual value.
        """
        mismatches = []
        base = os.path.dirname(self.path)
        record_path = self.get_distinfo_file('RECORD')
        for path, hash_value, size in self.list_installed_files():
            if not os.path.isabs(path):
                path = os.path.join(base, path)
            if path == record_path:
                continue
            if not os.path.exists(path):
                mismatches.append((path, 'exists', True, False))
            elif os.path.isfile(path):
                actual_size = str(os.path.getsize(path))
                if size and actual_size != size:
                    mismatches.append((path, 'size', size, actual_size))
                elif hash_value:
                    if '=' in hash_value:
                        hasher = hash_value.split('=', 1)[0]
                    else:
                        hasher = None

                    with open(path, 'rb') as f:
                        actual_hash = self.get_hash(f.read(), hasher)
                        if actual_hash != hash_value:
                            mismatches.append((path, 'hash', hash_value, actual_hash))
        return mismatches

    @cached_property
    def shared_locations(self):
        """
        A dictionary of shared locations whose keys are in the set 'prefix',
        'purelib', 'platlib', 'scripts', 'headers', 'data' and 'namespace'.
        The corresponding value is the absolute path of that category for
        this distribution, and takes into account any paths selected by the
        user at installation time (e.g. via command-line arguments). In the
        case of the 'namespace' key, this would be a list of absolute paths
        for the roots of namespace packages in this distribution.

        The first time this property is accessed, the relevant information is
        read from the SHARED file in the .dist-info directory.
        """
        result = {}
        shared_path = os.path.join(self.path, 'SHARED')
        if os.path.isfile(shared_path):
            with codecs.open(shared_path, 'r', encoding='utf-8') as f:
                lines = f.read().splitlines()
            for line in lines:
                key, value = line.split('=', 1)
                if key == 'namespace':
                    result.setdefault(key, []).append(value)
                else:
                    result[key] = value
        return result

    def write_shared_locations(self, paths, dry_run=False):
        """
        Write shared location information to the SHARED file in .dist-info.
        :param paths: A dictionary as described in the documentation for
        :meth:`shared_locations`.
        :param dry_run: If True, the action is logged but no file is actually
                        written.
        :return: The path of the file written to.
        """
        shared_path = os.path.join(self.path, 'SHARED')
        logger.info('creating %s', shared_path)
        if dry_run:
            return None
        lines = []
        for key in ('prefix', 'lib', 'headers', 'scripts', 'data'):
            path = paths[key]
            if os.path.isdir(paths[key]):
                lines.append('%s=%s' % (key,  path))
        for ns in paths.get('namespace', ()):
            lines.append('namespace=%s' % ns)

        with codecs.open(shared_path, 'w', encoding='utf-8') as f:
            f.write('\n'.join(lines))
        return shared_path

    def get_distinfo_resource(self, path):
        if path not in DIST_FILES:
            raise DistlibException('invalid path for a dist-info file: '
                                   '%r at %r' % (path, self.path))
        finder = resources.finder_for_path(self.path)
        if finder is None:
            raise DistlibException('Unable to get a finder for %s' % self.path)
        return finder.find(path)

    def get_distinfo_file(self, path):
        """
        Returns a path located under the ``.dist-info`` directory. Returns a
        string representing the path.

        :parameter path: a ``'/'``-separated path relative to the
                         ``.dist-info`` directory or an absolute path;
                         If *path* is an absolute path and doesn't start
                         with the ``.dist-info`` directory path,
                         a :class:`DistlibException` is raised
        :type path: str
        :rtype: str
        """
        # Check if it is an absolute path  # XXX use relpath, add tests
        if path.find(os.sep) >= 0:
            # it's an absolute path?
            distinfo_dirname, path = path.split(os.sep)[-2:]
            if distinfo_dirname != self.path.split(os.sep)[-1]:
                raise DistlibException(
                    'dist-info file %r does not belong to the %r %s '
                    'distribution' % (path, self.name, self.version))

        # The file must be relative
        if path not in DIST_FILES:
            raise DistlibException('invalid path for a dist-info file: '
                                   '%r at %r' % (path, self.path))

        return os.path.join(self.path, path)

    def list_distinfo_files(self):
        """
        Iterates over the ``RECORD`` entries and returns paths for each line if
        the path is pointing to a file located in the ``.dist-info`` directory
        or one of its subdirectories.

        :returns: iterator of paths
        """
        base = os.path.dirname(self.path)
        for path, checksum, size in self._get_records():
            # XXX add separator or use real relpath algo
            if not os.path.isabs(path):
                path = os.path.join(base, path)
            if path.startswith(self.path):
                yield path

    def __eq__(self, other):
        return (isinstance(other, InstalledDistribution) and
                self.path == other.path)

    # See http://docs.python.org/reference/datamodel#object.__hash__
    __hash__ = object.__hash__


class EggInfoDistribution(BaseInstalledDistribution):
    """Created with the *path* of the ``.egg-info`` directory or file provided
    to the constructor. It reads the metadata contained in the file itself, or
    if the given path happens to be a directory, the metadata is read from the
    file ``PKG-INFO`` under that directory."""

    requested = True    # as we have no way of knowing, assume it was
    shared_locations = {}

    def __init__(self, path, env=None):
        def set_name_and_version(s, n, v):
            s.name = n
            s.key = n.lower()   # for case-insensitive comparisons
            s.version = v

        self.path = path
        self.dist_path = env
        if env and env._cache_enabled and path in env._cache_egg.path:
            metadata = env._cache_egg.path[path].metadata
            set_name_and_version(self, metadata.name, metadata.version)
        else:
            metadata = self._get_metadata(path)

            # Need to be set before caching
            set_name_and_version(self, metadata.name, metadata.version)

            if env and env._cache_enabled:
                env._cache_egg.add(self)
        super(EggInfoDistribution, self).__init__(metadata, path, env)

    def _get_metadata(self, path):
        requires = None

        def parse_requires_data(data):
            """Create a list of dependencies from a requires.txt file.

            *data*: the contents of a setuptools-produced requires.txt file.
            """
            reqs = []
            lines = data.splitlines()
            for line in lines:
                line = line.strip()
                if line.startswith('['):
                    logger.warning('Unexpected line: quitting requirement scan: %r',
                                   line)
                    break
                r = parse_requirement(line)
                if not r:
                    logger.warning('Not recognised as a requirement: %r', line)
                    continue
                if r.extras:
                    logger.warning('extra requirements in requires.txt are '
                                   'not supported')
                if not r.constraints:
                    reqs.append(r.name)
                else:
                    cons = ', '.join('%s%s' % c for c in r.constraints)
                    reqs.append('%s (%s)' % (r.name, cons))
            return reqs

        def parse_requires_path(req_path):
            """Create a list of dependencies from a requires.txt file.

            *req_path*: the path to a setuptools-produced requires.txt file.
            """

            reqs = []
            try:
                with codecs.open(req_path, 'r', 'utf-8') as fp:
                    reqs = parse_requires_data(fp.read())
            except IOError:
                pass
            return reqs

        if path.endswith('.egg'):
            if os.path.isdir(path):
                meta_path = os.path.join(path, 'EGG-INFO', 'PKG-INFO')
                metadata = Metadata(path=meta_path, scheme='legacy')
                req_path = os.path.join(path, 'EGG-INFO', 'requires.txt')
                requires = parse_requires_path(req_path)
            else:
                # FIXME handle the case where zipfile is not available
                zipf = zipimport.zipimporter(path)
                fileobj = StringIO(
                    zipf.get_data('EGG-INFO/PKG-INFO').decode('utf8'))
                metadata = Metadata(fileobj=fileobj, scheme='legacy')
                try:
                    data = zipf.get_data('EGG-INFO/requires.txt')
                    requires = parse_requires_data(data.decode('utf-8'))
                except IOError:
                    requires = None
        elif path.endswith('.egg-info'):
            if os.path.isdir(path):
                path = os.path.join(path, 'PKG-INFO')
                req_path = os.path.join(path, 'requires.txt')
                requires = parse_requires_path(req_path)
            metadata = Metadata(path=path, scheme='legacy')
        else:
            raise DistlibException('path must end with .egg-info or .egg, '
                                   'got %r' % path)

        if requires:
            metadata.add_requirements(requires)
        return metadata

    def __repr__(self):
        return '<EggInfoDistribution %r %s at %r>' % (
            self.name, self.version, self.path)

    def __str__(self):
        return "%s %s" % (self.name, self.version)

    def check_installed_files(self):
        """
        Checks that the hashes and sizes of the files in ``RECORD`` are
        matched by the files themselves. Returns a (possibly empty) list of
        mismatches. Each entry in the mismatch list will be a tuple consisting
        of the path, 'exists', 'size' or 'hash' according to what didn't match
        (existence is checked first, then size, then hash), the expected
        value and the actual value.
        """
        mismatches = []
        record_path = os.path.join(self.path, 'installed-files.txt')
        if os.path.exists(record_path):
            for path, _, _ in self.list_installed_files():
                if path == record_path:
                    continue
                if not os.path.exists(path):
                    mismatches.append((path, 'exists', True, False))
        return mismatches

    def list_installed_files(self):
        """
        Iterates over the ``installed-files.txt`` entries and returns a tuple
        ``(path, hash, size)`` for each line.

        :returns: a list of (path, hash, size)
        """

        def _md5(path):
            f = open(path, 'rb')
            try:
                content = f.read()
            finally:
                f.close()
            return hashlib.md5(content).hexdigest()

        def _size(path):
            return os.stat(path).st_size

        record_path = os.path.join(self.path, 'installed-files.txt')
        result = []
        if os.path.exists(record_path):
            with codecs.open(record_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    p = os.path.normpath(os.path.join(self.path, line))
                    # "./" is present as a marker between installed files
                    # and installation metadata files
                    if not os.path.exists(p):
                        logger.warning('Non-existent file: %s', p)
                        if p.endswith(('.pyc', '.pyo')):
                            continue
                        #otherwise fall through and fail
                    if not os.path.isdir(p):
                        result.append((p, _md5(p), _size(p)))
            result.append((record_path, None, None))
        return result

    def list_distinfo_files(self, absolute=False):
        """
        Iterates over the ``installed-files.txt`` entries and returns paths for
        each line if the path is pointing to a file located in the
        ``.egg-info`` directory or one of its subdirectories.

        :parameter absolute: If *absolute* is ``True``, each returned path is
                          transformed into a local absolute path. Otherwise the
                          raw value from ``installed-files.txt`` is returned.
        :type absolute: boolean
        :returns: iterator of paths
        """
        record_path = os.path.join(self.path, 'installed-files.txt')
        skip = True
        with codecs.open(record_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line == './':
                    skip = False
                    continue
                if not skip:
                    p = os.path.normpath(os.path.join(self.path, line))
                    if p.startswith(self.path):
                        if absolute:
                            yield p
                        else:
                            yield line

    def __eq__(self, other):
        return (isinstance(other, EggInfoDistribution) and
                self.path == other.path)

    # See http://docs.python.org/reference/datamodel#object.__hash__
    __hash__ = object.__hash__

new_dist_class = InstalledDistribution
old_dist_class = EggInfoDistribution


class DependencyGraph(object):
    """
    Represents a dependency graph between distributions.

    The dependency relationships are stored in an ``adjacency_list`` that maps
    distributions to a list of ``(other, label)`` tuples where  ``other``
    is a distribution and the edge is labeled with ``label`` (i.e. the version
    specifier, if such was provided). Also, for more efficient traversal, for
    every distribution ``x``, a list of predecessors is kept in
    ``reverse_list[x]``. An edge from distribution ``a`` to
    distribution ``b`` means that ``a`` depends on ``b``. If any missing
    dependencies are found, they are stored in ``missing``, which is a
    dictionary that maps distributions to a list of requirements that were not
    provided by any other distributions.
    """

    def __init__(self):
        self.adjacency_list = {}
        self.reverse_list = {}
        self.missing = {}

    def add_distribution(self, distribution):
        """Add the *distribution* to the graph.

        :type distribution: :class:`distutils2.database.InstalledDistribution`
                            or :class:`distutils2.database.EggInfoDistribution`
        """
        self.adjacency_list[distribution] = []
        self.reverse_list[distribution] = []
        #self.missing[distribution] = []

    def add_edge(self, x, y, label=None):
        """Add an edge from distribution *x* to distribution *y* with the given
        *label*.

        :type x: :class:`distutils2.database.InstalledDistribution` or
                 :class:`distutils2.database.EggInfoDistribution`
        :type y: :class:`distutils2.database.InstalledDistribution` or
                 :class:`distutils2.database.EggInfoDistribution`
        :type label: ``str`` or ``None``
        """
        self.adjacency_list[x].append((y, label))
        # multiple edges are allowed, so be careful
        if x not in self.reverse_list[y]:
            self.reverse_list[y].append(x)

    def add_missing(self, distribution, requirement):
        """
        Add a missing *requirement* for the given *distribution*.

        :type distribution: :class:`distutils2.database.InstalledDistribution`
                            or :class:`distutils2.database.EggInfoDistribution`
        :type requirement: ``str``
        """
        logger.debug('%s missing %r', distribution, requirement)
        self.missing.setdefault(distribution, []).append(requirement)

    def _repr_dist(self, dist):
        return '%s %s' % (dist.name, dist.version)

    def repr_node(self, dist, level=1):
        """Prints only a subgraph"""
        output = [self._repr_dist(dist)]
        for other, label in self.adjacency_list[dist]:
            dist = self._repr_dist(other)
            if label is not None:
                dist = '%s [%s]' % (dist, label)
            output.append('    ' * level + str(dist))
            suboutput = self.repr_node(other, level + 1)
            subs = suboutput.split('\n')
            output.extend(subs[1:])
        return '\n'.join(output)

    def to_dot(self, f, skip_disconnected=True):
        """Writes a DOT output for the graph to the provided file *f*.

        If *skip_disconnected* is set to ``True``, then all distributions
        that are not dependent on any other distribution are skipped.

        :type f: has to support ``file``-like operations
        :type skip_disconnected: ``bool``
        """
        disconnected = []

        f.write("digraph dependencies {\n")
        for dist, adjs in self.adjacency_list.items():
            if len(adjs) == 0 and not skip_disconnected:
                disconnected.append(dist)
            for other, label in adjs:
                if not label is None:
                    f.write('"%s" -> "%s" [label="%s"]\n' %
                            (dist.name, other.name, label))
                else:
                    f.write('"%s" -> "%s"\n' % (dist.name, other.name))
        if not skip_disconnected and len(disconnected) > 0:
            f.write('subgraph disconnected {\n')
            f.write('label = "Disconnected"\n')
            f.write('bgcolor = red\n')

            for dist in disconnected:
                f.write('"%s"' % dist.name)
                f.write('\n')
            f.write('}\n')
        f.write('}\n')

    def topological_sort(self):
        """
        Perform a topological sort of the graph.
        :return: A tuple, the first element of which is a topologically sorted
                 list of distributions, and the second element of which is a
                 list of distributions that cannot be sorted because they have
                 circular dependencies and so form a cycle.
        """
        result = []
        # Make a shallow copy of the adjacency list
        alist = {}
        for k, v in self.adjacency_list.items():
            alist[k] = v[:]
        while True:
            # See what we can remove in this run
            to_remove = []
            for k, v in list(alist.items())[:]:
                if not v:
                    to_remove.append(k)
                    del alist[k]
            if not to_remove:
                # What's left in alist (if anything) is a cycle.
                break
            # Remove from the adjacency list of others
            for k, v in alist.items():
                alist[k] = [(d, r) for d, r in v if d not in to_remove]
            logger.debug('Moving to result: %s',
                         ['%s (%s)' % (d.name, d.version) for d in to_remove])
            result.extend(to_remove)
        return result, list(alist.keys())

    def __repr__(self):
        """Representation of the graph"""
        output = []
        for dist, adjs in self.adjacency_list.items():
            output.append(self.repr_node(dist))
        return '\n'.join(output)


def make_graph(dists, scheme='default'):
    """Makes a dependency graph from the given distributions.

    :parameter dists: a list of distributions
    :type dists: list of :class:`distutils2.database.InstalledDistribution` and
                 :class:`distutils2.database.EggInfoDistribution` instances
    :rtype: a :class:`DependencyGraph` instance
    """
    scheme = get_scheme(scheme)
    graph = DependencyGraph()
    provided = {}  # maps names to lists of (version, dist) tuples

    # first, build the graph and find out what's provided
    for dist in dists:
        graph.add_distribution(dist)

        for p in dist.provides:
            name, version = parse_name_and_version(p)
            logger.debug('Add to provided: %s, %s, %s', name, version, dist)
            provided.setdefault(name, []).append((version, dist))

    # now make the edges
    for dist in dists:
        requires = (dist.run_requires | dist.meta_requires |
                    dist.build_requires | dist.dev_requires)
        for req in requires:
            try:
                matcher = scheme.matcher(req)
            except UnsupportedVersionError:
                # XXX compat-mode if cannot read the version
                logger.warning('could not read version %r - using name only',
                               req)
                name = req.split()[0]
                matcher = scheme.matcher(name)

            name = matcher.key   # case-insensitive

            matched = False
            if name in provided:
                for version, provider in provided[name]:
                    try:
                        match = matcher.match(version)
                    except UnsupportedVersionError:
                        match = False

                    if match:
                        graph.add_edge(dist, provider, req)
                        matched = True
                        break
            if not matched:
                graph.add_missing(dist, req)
    return graph


def get_dependent_dists(dists, dist):
    """Recursively generate a list of distributions from *dists* that are
    dependent on *dist*.

    :param dists: a list of distributions
    :param dist: a distribution, member of *dists* for which we are interested
    """
    if dist not in dists:
        raise DistlibException('given distribution %r is not a member '
                               'of the list' % dist.name)
    graph = make_graph(dists)

    dep = [dist]  # dependent distributions
    todo = graph.reverse_list[dist]  # list of nodes we should inspect

    while todo:
        d = todo.pop()
        dep.append(d)
        for succ in graph.reverse_list[d]:
            if succ not in dep:
                todo.append(succ)

    dep.pop(0)  # remove dist from dep, was there to prevent infinite loops
    return dep


def get_required_dists(dists, dist):
    """Recursively generate a list of distributions from *dists* that are
    required by *dist*.

    :param dists: a list of distributions
    :param dist: a distribution, member of *dists* for which we are interested
    """
    if dist not in dists:
        raise DistlibException('given distribution %r is not a member '
                               'of the list' % dist.name)
    graph = make_graph(dists)

    req = []  # required distributions
    todo = graph.adjacency_list[dist]  # list of nodes we should inspect

    while todo:
        d = todo.pop()[0]
        req.append(d)
        for pred in graph.adjacency_list[d]:
            if pred not in req:
                todo.append(pred)

    return req


def make_dist(name, version, **kwargs):
    """
    A convenience method for making a dist given just a name and version.
    """
    summary = kwargs.pop('summary', 'Placeholder for summary')
    md = Metadata(**kwargs)
    md.name = name
    md.version = version
    md.summary = summary or 'Plaeholder for summary'
    return Distribution(md)

########NEW FILE########
__FILENAME__ = index
# -*- coding: utf-8 -*-
#
# Copyright (C) 2013 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
import hashlib
import logging
import os
import shutil
import subprocess
import tempfile
try:
    from threading import Thread
except ImportError:
    from dummy_threading import Thread

from . import DistlibException
from .compat import (HTTPBasicAuthHandler, Request, HTTPPasswordMgr,
                     urlparse, build_opener, string_types)
from .util import cached_property, zip_dir, ServerProxy

logger = logging.getLogger(__name__)

DEFAULT_INDEX = 'https://pypi.python.org/pypi'
DEFAULT_REALM = 'pypi'

class PackageIndex(object):
    """
    This class represents a package index compatible with PyPI, the Python
    Package Index.
    """

    boundary = b'----------ThIs_Is_tHe_distlib_index_bouNdaRY_$'

    def __init__(self, url=None):
        """
        Initialise an instance.

        :param url: The URL of the index. If not specified, the URL for PyPI is
                    used.
        """
        self.url = url or DEFAULT_INDEX
        self.read_configuration()
        scheme, netloc, path, params, query, frag = urlparse(self.url)
        if params or query or frag or scheme not in ('http', 'https'):
            raise DistlibException('invalid repository: %s' % self.url)
        self.password_handler = None
        self.ssl_verifier = None
        self.gpg = None
        self.gpg_home = None
        self.rpc_proxy = None
        with open(os.devnull, 'w') as sink:
            for s in ('gpg2', 'gpg'):
                try:
                    rc = subprocess.check_call([s, '--version'], stdout=sink,
                                               stderr=sink)
                    if rc == 0:
                        self.gpg = s
                        break
                except OSError:
                    pass

    def _get_pypirc_command(self):
        """
        Get the distutils command for interacting with PyPI configurations.
        :return: the command.
        """
        from distutils.core import Distribution
        from distutils.config import PyPIRCCommand
        d = Distribution()
        return PyPIRCCommand(d)

    def read_configuration(self):
        """
        Read the PyPI access configuration as supported by distutils, getting
        PyPI to do the acutal work. This populates ``username``, ``password``,
        ``realm`` and ``url`` attributes from the configuration.
        """
        # get distutils to do the work
        c = self._get_pypirc_command()
        c.repository = self.url
        cfg = c._read_pypirc()
        self.username = cfg.get('username')
        self.password = cfg.get('password')
        self.realm = cfg.get('realm', 'pypi')
        self.url = cfg.get('repository', self.url)

    def save_configuration(self):
        """
        Save the PyPI access configuration. You must have set ``username`` and
        ``password`` attributes before calling this method.

        Again, distutils is used to do the actual work.
        """
        self.check_credentials()
        # get distutils to do the work
        c = self._get_pypirc_command()
        c._store_pypirc(self.username, self.password)

    def check_credentials(self):
        """
        Check that ``username`` and ``password`` have been set, and raise an
        exception if not.
        """
        if self.username is None or self.password is None:
            raise DistlibException('username and password must be set')
        pm = HTTPPasswordMgr()
        _, netloc, _, _, _, _ = urlparse(self.url)
        pm.add_password(self.realm, netloc, self.username, self.password)
        self.password_handler = HTTPBasicAuthHandler(pm)

    def register(self, metadata):
        """
        Register a distribution on PyPI, using the provided metadata.

        :param metadata: A :class:`Metadata` instance defining at least a name
                         and version number for the distribution to be
                         registered.
        :return: The HTTP response received from PyPI upon submission of the
                request.
        """
        self.check_credentials()
        metadata.validate()
        d = metadata.todict()
        d[':action'] = 'verify'
        request = self.encode_request(d.items(), [])
        response = self.send_request(request)
        d[':action'] = 'submit'
        request = self.encode_request(d.items(), [])
        return self.send_request(request)

    def _reader(self, name, stream, outbuf):
        """
        Thread runner for reading lines of from a subprocess into a buffer.

        :param name: The logical name of the stream (used for logging only).
        :param stream: The stream to read from. This will typically a pipe
                       connected to the output stream of a subprocess.
        :param outbuf: The list to append the read lines to.
        """
        while True:
            s = stream.readline()
            if not s:
                break
            s = s.decode('utf-8').rstrip()
            outbuf.append(s)
            logger.debug('%s: %s' % (name, s))
        stream.close()

    def get_sign_command(self, filename, signer, sign_password):
        """
        Return a suitable command for signing a file.

        :param filename: The pathname to the file to be signed.
        :param signer: The identifier of the signer of the file.
        :param sign_password: The passphrase for the signer's
                              private key used for signing.
        :return: The signing command as a list suitable to be
                 passed to :class:`subprocess.Popen`.
        """
        cmd = [self.gpg, '--status-fd', '2', '--no-tty']
        if self.gpg_home:
            cmd.extend(['--homedir', self.gpg_home])
        if sign_password is not None:
            cmd.extend(['--batch', '--passphrase-fd', '0'])
        td = tempfile.mkdtemp()
        sf = os.path.join(td, os.path.basename(filename) + '.asc')
        cmd.extend(['--detach-sign', '--armor', '--local-user',
                    signer, '--output', sf, filename])
        logger.debug('invoking: %s', ' '.join(cmd))
        return cmd, sf

    def run_command(self, cmd, input_data=None):
        """
        Run a command in a child process , passing it any input data specified.

        :param cmd: The command to run.
        :param input_data: If specified, this must be a byte string containing
                           data to be sent to the child process.
        :return: A tuple consisting of the subprocess' exit code, a list of
                 lines read from the subprocess' ``stdout``, and a list of
                 lines read from the subprocess' ``stderr``.
        """
        kwargs = {
            'stdout': subprocess.PIPE,
            'stderr': subprocess.PIPE,
        }
        if input_data is not None:
            kwargs['stdin'] = subprocess.PIPE
        stdout = []
        stderr = []
        p = subprocess.Popen(cmd, **kwargs)
        # We don't use communicate() here because we may need to
        # get clever with interacting with the command
        t1 = Thread(target=self._reader, args=('stdout', p.stdout, stdout))
        t1.start()
        t2 = Thread(target=self._reader, args=('stderr', p.stderr, stderr))
        t2.start()
        if input_data is not None:
            p.stdin.write(input_data)
            p.stdin.close()

        p.wait()
        t1.join()
        t2.join()
        return p.returncode, stdout, stderr

    def sign_file(self, filename, signer, sign_password):
        """
        Sign a file.

        :param filename: The pathname to the file to be signed.
        :param signer: The identifier of the signer of the file.
        :param sign_password: The passphrase for the signer's
                              private key used for signing.
        :return: The absolute pathname of the file where the signature is
                 stored.
        """
        cmd, sig_file = self.get_sign_command(filename, signer, sign_password)
        rc, stdout, stderr = self.run_command(cmd,
                                              sign_password.encode('utf-8'))
        if rc != 0:
            raise DistlibException('sign command failed with error '
                                   'code %s' % rc)
        return sig_file

    def upload_file(self, metadata, filename, signer=None, sign_password=None,
                    filetype='sdist', pyversion='source'):
        """
        Upload a release file to the index.

        :param metadata: A :class:`Metadata` instance defining at least a name
                         and version number for the file to be uploaded.
        :param filename: The pathname of the file to be uploaded.
        :param signer: The identifier of the signer of the file.
        :param sign_password: The passphrase for the signer's
                              private key used for signing.
        :param filetype: The type of the file being uploaded. This is the
                        distutils command which produced that file, e.g.
                        ``sdist`` or ``bdist_wheel``.
        :param pyversion: The version of Python which the release relates
                          to. For code compatible with any Python, this would
                          be ``source``, otherwise it would be e.g. ``3.2``.
        :return: The HTTP response received from PyPI upon submission of the
                request.
        """
        self.check_credentials()
        if not os.path.exists(filename):
            raise DistlibException('not found: %s' % filename)
        metadata.validate()
        d = metadata.todict()
        sig_file = None
        if signer:
            if not self.gpg:
                logger.warning('no signing program available - not signed')
            else:
                sig_file = self.sign_file(filename, signer, sign_password)
        with open(filename, 'rb') as f:
            file_data = f.read()
        md5_digest = hashlib.md5(file_data).hexdigest()
        sha256_digest = hashlib.sha256(file_data).hexdigest()
        d.update({
            ':action': 'file_upload',
            'protcol_version': '1',
            'filetype': filetype,
            'pyversion': pyversion,
            'md5_digest': md5_digest,
            'sha256_digest': sha256_digest,
        })
        files = [('content', os.path.basename(filename), file_data)]
        if sig_file:
            with open(sig_file, 'rb') as f:
                sig_data = f.read()
            files.append(('gpg_signature', os.path.basename(sig_file),
                         sig_data))
            shutil.rmtree(os.path.dirname(sig_file))
        request = self.encode_request(d.items(), files)
        return self.send_request(request)

    def upload_documentation(self, metadata, doc_dir):
        """
        Upload documentation to the index.

        :param metadata: A :class:`Metadata` instance defining at least a name
                         and version number for the documentation to be
                         uploaded.
        :param doc_dir: The pathname of the directory which contains the
                        documentation. This should be the directory that
                        contains the ``index.html`` for the documentation.
        :return: The HTTP response received from PyPI upon submission of the
                request.
        """
        self.check_credentials()
        if not os.path.isdir(doc_dir):
            raise DistlibException('not a directory: %r' % doc_dir)
        fn = os.path.join(doc_dir, 'index.html')
        if not os.path.exists(fn):
            raise DistlibException('not found: %r' % fn)
        metadata.validate()
        name, version = metadata.name, metadata.version
        zip_data = zip_dir(doc_dir).getvalue()
        fields = [(':action', 'doc_upload'),
                  ('name', name), ('version', version)]
        files = [('content', name, zip_data)]
        request = self.encode_request(fields, files)
        return self.send_request(request)

    def get_verify_command(self, signature_filename, data_filename):
        """
        Return a suitable command for verifying a file.

        :param signature_filename: The pathname to the file containing the
                                   signature.
        :param data_filename: The pathname to the file containing the
                              signed data.
        :return: The verifying command as a list suitable to be
                 passed to :class:`subprocess.Popen`.
        """
        cmd = [self.gpg, '--status-fd', '2', '--no-tty']
        if self.gpg_home:
            cmd.extend(['--homedir', self.gpg_home])
        cmd.extend(['--verify', signature_filename, data_filename])
        logger.debug('invoking: %s', ' '.join(cmd))
        return cmd

    def verify_signature(self, signature_filename, data_filename):
        """
        Verify a signature for a file.

        :param signature_filename: The pathname to the file containing the
                                   signature.
        :param data_filename: The pathname to the file containing the
                              signed data.
        :return: True if the signature was verified, else False.
        """
        if not self.gpg:
            raise DistlibException('verification unavailable because gpg '
                                   'unavailable')
        cmd = self.get_verify_command(signature_filename, data_filename)
        rc, stdout, stderr = self.run_command(cmd)
        if rc not in (0, 1):
            raise DistlibException('verify command failed with error '
                             'code %s' % rc)
        return rc == 0

    def download_file(self, url, destfile, digest=None, reporthook=None):
        """
        This is a convenience method for downloading a file from an URL.
        Normally, this will be a file from the index, though currently
        no check is made for this (i.e. a file can be downloaded from
        anywhere).

        The method is just like the :func:`urlretrieve` function in the
        standard library, except that it allows digest computation to be
        done during download and checking that the downloaded data
        matched any expected value.

        :param url: The URL of the file to be downloaded (assumed to be
                    available via an HTTP GET request).
        :param destfile: The pathname where the downloaded file is to be
                         saved.
        :param digest: If specified, this must be a (hasher, value)
                       tuple, where hasher is the algorithm used (e.g.
                       ``'md5'``) and ``value`` is the expected value.
        :param reporthook: The same as for :func:`urlretrieve` in the
                           standard library.
        """
        if digest is None:
            digester = None
            logger.debug('No digest specified')
        else:
            if isinstance(digest, (list, tuple)):
                hasher, digest = digest
            else:
                hasher = 'md5'
            digester = getattr(hashlib, hasher)()
            logger.debug('Digest specified: %s' % digest)
        # The following code is equivalent to urlretrieve.
        # We need to do it this way so that we can compute the
        # digest of the file as we go.
        with open(destfile, 'wb') as dfp:
            # addinfourl is not a context manager on 2.x
            # so we have to use try/finally
            sfp = self.send_request(Request(url))
            try:
                headers = sfp.info()
                blocksize = 8192
                size = -1
                read = 0
                blocknum = 0
                if "content-length" in headers:
                    size = int(headers["Content-Length"])
                if reporthook:
                    reporthook(blocknum, blocksize, size)
                while True:
                    block = sfp.read(blocksize)
                    if not block:
                        break
                    read += len(block)
                    dfp.write(block)
                    if digester:
                        digester.update(block)
                    blocknum += 1
                    if reporthook:
                        reporthook(blocknum, blocksize, size)
            finally:
                sfp.close()

        # check that we got the whole file, if we can
        if size >= 0 and read < size:
            raise DistlibException(
                'retrieval incomplete: got only %d out of %d bytes'
                % (read, size))
        # if we have a digest, it must match.
        if digester:
            actual = digester.hexdigest()
            if digest != actual:
                raise DistlibException('%s digest mismatch for %s: expected '
                                       '%s, got %s' % (hasher, destfile,
                                                       digest, actual))
            logger.debug('Digest verified: %s', digest)

    def send_request(self, req):
        """
        Send a standard library :class:`Request` to PyPI and return its
        response.

        :param req: The request to send.
        :return: The HTTP response from PyPI (a standard library HTTPResponse).
        """
        handlers = []
        if self.password_handler:
            handlers.append(self.password_handler)
        if self.ssl_verifier:
            handlers.append(self.ssl_verifier)
        opener = build_opener(*handlers)
        return opener.open(req)

    def encode_request(self, fields, files):
        """
        Encode fields and files for posting to an HTTP server.

        :param fields: The fields to send as a list of (fieldname, value)
                       tuples.
        :param files: The files to send as a list of (fieldname, filename,
                      file_bytes) tuple.
        """
        # Adapted from packaging, which in turn was adapted from
        # http://code.activestate.com/recipes/146306

        parts = []
        boundary = self.boundary
        for k, values in fields:
            if not isinstance(values, (list, tuple)):
                values = [values]

            for v in values:
                parts.extend((
                    b'--' + boundary,
                    ('Content-Disposition: form-data; name="%s"' %
                     k).encode('utf-8'),
                    b'',
                    v.encode('utf-8')))
        for key, filename, value in files:
            parts.extend((
                b'--' + boundary,
                ('Content-Disposition: form-data; name="%s"; filename="%s"' %
                 (key, filename)).encode('utf-8'),
                b'',
                value))

        parts.extend((b'--' + boundary + b'--', b''))

        body = b'\r\n'.join(parts)
        ct = b'multipart/form-data; boundary=' + boundary
        headers = {
            'Content-type': ct,
            'Content-length': str(len(body))
        }
        return Request(self.url, body, headers)

    def search(self, terms, operator=None):
        if isinstance(terms, string_types):
            terms = {'name': terms}
        if self.rpc_proxy is None:
            self.rpc_proxy = ServerProxy(self.url, timeout=3.0)
        return self.rpc_proxy.search(terms, operator or 'and')

########NEW FILE########
__FILENAME__ = locators
# -*- coding: utf-8 -*-
#
# Copyright (C) 2012-2013 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#

import gzip
from io import BytesIO
import json
import logging
import os
import posixpath
import re
try:
    import threading
except ImportError:
    import dummy_threading as threading
import zlib

from . import DistlibException
from .compat import (urljoin, urlparse, urlunparse, url2pathname, pathname2url,
                     queue, quote, unescape, string_types, build_opener,
                     HTTPRedirectHandler as BaseRedirectHandler,
                     Request, HTTPError, URLError)
from .database import Distribution, DistributionPath, make_dist
from .metadata import Metadata
from .util import (cached_property, parse_credentials, ensure_slash,
                   split_filename, get_project_data, parse_requirement,
                   parse_name_and_version, ServerProxy)
from .version import get_scheme, UnsupportedVersionError
from .wheel import Wheel, is_compatible

logger = logging.getLogger(__name__)

HASHER_HASH = re.compile('^(\w+)=([a-f0-9]+)')
CHARSET = re.compile(r';\s*charset\s*=\s*(.*)\s*$', re.I)
HTML_CONTENT_TYPE = re.compile('text/html|application/x(ht)?ml')
DEFAULT_INDEX = 'http://python.org/pypi'

def get_all_distribution_names(url=None):
    """
    Return all distribution names known by an index.
    :param url: The URL of the index.
    :return: A list of all known distribution names.
    """
    if url is None:
        url = DEFAULT_INDEX
    client = ServerProxy(url, timeout=3.0)
    return client.list_packages()

class RedirectHandler(BaseRedirectHandler):
    """
    A class to work around a bug in some Python 3.2.x releases.
    """
    # There's a bug in the base version for some 3.2.x
    # (e.g. 3.2.2 on Ubuntu Oneiric). If a Location header
    # returns e.g. /abc, it bails because it says the scheme ''
    # is bogus, when actually it should use the request's
    # URL for the scheme. See Python issue #13696.
    def http_error_302(self, req, fp, code, msg, headers):
        # Some servers (incorrectly) return multiple Location headers
        # (so probably same goes for URI).  Use first header.
        newurl = None
        for key in ('location', 'uri'):
            if key in headers:
                newurl = headers[key]
                break
        if newurl is None:
            return
        urlparts = urlparse(newurl)
        if urlparts.scheme == '':
            newurl = urljoin(req.get_full_url(), newurl)
            if hasattr(headers, 'replace_header'):
                headers.replace_header(key, newurl)
            else:
                headers[key] = newurl
        return BaseRedirectHandler.http_error_302(self, req, fp, code, msg,
                                                  headers)

    http_error_301 = http_error_303 = http_error_307 = http_error_302

class Locator(object):
    """
    A base class for locators - things that locate distributions.
    """
    source_extensions = ('.tar.gz', '.tar.bz2', '.tar', '.zip', '.tgz', '.tbz')
    binary_extensions = ('.egg', '.exe', '.whl')
    excluded_extensions = ('.pdf',)

    # A list of tags indicating which wheels you want to match. The default
    # value of None matches against the tags compatible with the running
    # Python. If you want to match other values, set wheel_tags on a locator
    # instance to a list of tuples (pyver, abi, arch) which you want to match.
    wheel_tags = None

    downloadable_extensions = source_extensions + ('.whl',)

    def __init__(self, scheme='default'):
        """
        Initialise an instance.
        :param scheme: Because locators look for most recent versions, they
                       need to know the version scheme to use. This specifies
                       the current PEP-recommended scheme - use ``'legacy'``
                       if you need to support existing distributions on PyPI.
        """
        self._cache = {}
        self.scheme = scheme
        # Because of bugs in some of the handlers on some of the platforms,
        # we use our own opener rather than just using urlopen.
        self.opener = build_opener(RedirectHandler())
        # If get_project() is called from locate(), the matcher instance
        # is set from the requirement passed to locate(). See issue #18 for
        # why this can be useful to know.
        self.matcher = None

    def clear_cache(self):
        self._cache.clear()

    def _get_scheme(self):
        return self._scheme

    def _set_scheme(self, value):
        self._scheme = value

    scheme = property(_get_scheme, _set_scheme)

    def _get_project(self, name):
        """
        For a given project, get a dictionary mapping available versions to Distribution
        instances.

        This should be implemented in subclasses.

        If called from a locate() request, self.matcher will be set to a
        matcher for the requirement to satisfy, otherwise it will be None.
        """
        raise NotImplementedError('Please implement in the subclass')

    def get_distribution_names(self):
        """
        Return all the distribution names known to this locator.
        """
        raise NotImplementedError('Please implement in the subclass')

    def get_project(self, name):
        """
        For a given project, get a dictionary mapping available versions to Distribution
        instances.

        This calls _get_project to do all the work, and just implements a caching layer on top.
        """
        if self._cache is None:
            result = self._get_project(name)
        elif name in self._cache:
            result = self._cache[name]
        else:
            result = self._get_project(name)
            self._cache[name] = result
        return result

    def score_url(self, url):
        """
        Give an url a score which can be used to choose preferred URLs
        for a given project release.
        """
        t = urlparse(url)
        return (t.scheme != 'https', 'pypi.python.org' in t.netloc,
                posixpath.basename(t.path))

    def prefer_url(self, url1, url2):
        """
        Choose one of two URLs where both are candidates for distribution
        archives for the same version of a distribution (for example,
        .tar.gz vs. zip).

        The current implement favours http:// URLs over https://, archives
        from PyPI over those from other locations and then the archive name.
        """
        result = url2
        if url1:
            s1 = self.score_url(url1)
            s2 = self.score_url(url2)
            if s1 > s2:
                result = url1
            if result != url2:
                logger.debug('Not replacing %r with %r', url1, url2)
            else:
                logger.debug('Replacing %r with %r', url1, url2)
        return result

    def split_filename(self, filename, project_name):
        """
        Attempt to split a filename in project name, version and Python version.
        """
        return split_filename(filename, project_name)

    def convert_url_to_download_info(self, url, project_name):
        """
        See if a URL is a candidate for a download URL for a project (the URL
        has typically been scraped from an HTML page).

        If it is, a dictionary is returned with keys "name", "version",
        "filename" and "url"; otherwise, None is returned.
        """
        def same_project(name1, name2):
            name1, name2 = name1.lower(), name2.lower()
            if name1 == name2:
                result = True
            else:
                # distribute replaces '-' by '_' in project names, so it
                # can tell where the version starts in a filename.
                result = name1.replace('_', '-') == name2.replace('_', '-')
            return result

        result = None
        scheme, netloc, path, params, query, frag = urlparse(url)
        if frag.lower().startswith('egg='):
            logger.debug('%s: version hint in fragment: %r',
                         project_name, frag)
        m = HASHER_HASH.match(frag)
        if m:
            algo, digest = m.groups()
        else:
            algo, digest = None, None
        origpath = path
        if path and path[-1] == '/':
            path = path[:-1]
        if path.endswith('.whl'):
            try:
                wheel = Wheel(path)
                if is_compatible(wheel, self.wheel_tags):
                    if project_name is None:
                        include = True
                    else:
                        include = same_project(wheel.name, project_name)
                    if include:
                        result = {
                            'name': wheel.name,
                            'version': wheel.version,
                            'filename': wheel.filename,
                            'url': urlunparse((scheme, netloc, origpath,
                                               params, query, '')),
                            'python-version': ', '.join(
                                ['.'.join(list(v[2:])) for v in wheel.pyver]),
                        }
            except Exception as e:
                logger.warning('invalid path for wheel: %s', path)
        elif path.endswith(self.downloadable_extensions):
            path = filename = posixpath.basename(path)
            for ext in self.downloadable_extensions:
                if path.endswith(ext):
                    path = path[:-len(ext)]
                    t = self.split_filename(path, project_name)
                    if not t:
                        logger.debug('No match for project/version: %s', path)
                    else:
                        name, version, pyver = t
                        if not project_name or same_project(project_name, name):
                            result = {
                                'name': name,
                                'version': version,
                                'filename': filename,
                                'url': urlunparse((scheme, netloc, origpath,
                                                   params, query, '')),
                                #'packagetype': 'sdist',
                            }
                            if pyver:
                                result['python-version'] = pyver
                    break
        if result and algo:
            result['%s_digest' % algo] = digest
        return result

    def _get_digest(self, info):
        """
        Get a digest from a dictionary by looking at keys of the form
        'algo_digest'.

        Returns a 2-tuple (algo, digest) if found, else None. Currently
        looks only for SHA256, then MD5.
        """
        result = None
        for algo in ('sha256', 'md5'):
            key = '%s_digest' % algo
            if key in info:
                result = (algo, info[key])
                break
        return result

    def _update_version_data(self, result, info):
        """
        Update a result dictionary (the final result from _get_project) with a dictionary for a
        specific version, whih typically holds information gleaned from a filename or URL for an
        archive for the distribution.
        """
        name = info.pop('name')
        version = info.pop('version')
        if version in result:
            dist = result[version]
            md = dist.metadata
        else:
            dist = make_dist(name, version, scheme=self.scheme)
            md = dist.metadata
        dist.digest = self._get_digest(info)
        if md.source_url != info['url']:
            md.source_url = self.prefer_url(md.source_url, info['url'])
        dist.locator = self
        result[version] = dist

    def locate(self, requirement, prereleases=False):
        """
        Find the most recent distribution which matches the given
        requirement.

        :param requirement: A requirement of the form 'foo (1.0)' or perhaps
                            'foo (>= 1.0, < 2.0, != 1.3)'
        :param prereleases: If ``True``, allow pre-release versions
                            to be located. Otherwise, pre-release versions
                            are not returned.
        :return: A :class:`Distribution` instance, or ``None`` if no such
                 distribution could be located.
        """
        result = None
        r = parse_requirement(requirement)
        if r is None:
            raise DistlibException('Not a valid requirement: %r' % requirement)
        scheme = get_scheme(self.scheme)
        self.matcher = matcher = scheme.matcher(r.requirement)
        logger.debug('matcher: %s (%s)', matcher, type(matcher).__name__)
        versions = self.get_project(r.name)
        if versions:
            # sometimes, versions are invalid
            slist = []
            vcls = matcher.version_class
            for k in versions:
                try:
                    if not matcher.match(k):
                        logger.debug('%s did not match %r', matcher, k)
                    else:
                        if prereleases or not vcls(k).is_prerelease:
                            slist.append(k)
                        else:
                            logger.debug('skipping pre-release '
                                         'version %s of %s', k, matcher.name)
                except Exception:
                    logger.warning('error matching %s with %r', matcher, k)
                    pass # slist.append(k)
            if len(slist) > 1:
                slist = sorted(slist, key=scheme.key)
            if slist:
                logger.debug('sorted list: %s', slist)
                result = versions[slist[-1]]
        if result and r.extras:
            result.extras = r.extras
        self.matcher = None
        return result


class PyPIRPCLocator(Locator):
    """
    This locator uses XML-RPC to locate distributions. It therefore
    cannot be used with simple mirrors (that only mirror file content).
    """
    def __init__(self, url, **kwargs):
        """
        Initialise an instance.

        :param url: The URL to use for XML-RPC.
        :param kwargs: Passed to the superclass constructor.
        """
        super(PyPIRPCLocator, self).__init__(**kwargs)
        self.base_url = url
        self.client = ServerProxy(url, timeout=3.0)

    def get_distribution_names(self):
        """
        Return all the distribution names known to this locator.
        """
        return set(self.client.list_packages())

    def _get_project(self, name):
        result = {}
        versions = self.client.package_releases(name, True)
        for v in versions:
            urls = self.client.release_urls(name, v)
            data = self.client.release_data(name, v)
            metadata = Metadata(scheme=self.scheme)
            metadata.name = data['name']
            metadata.version = data['version']
            metadata.license = data.get('license')
            metadata.keywords = data.get('keywords', [])
            metadata.summary = data.get('summary')
            dist = Distribution(metadata)
            if urls:
                info = urls[0]
                metadata.source_url = info['url']
                dist.digest = self._get_digest(info)
                dist.locator = self
                result[v] = dist
        return result

class PyPIJSONLocator(Locator):
    """
    This locator uses PyPI's JSON interface. It's very limited in functionality
    nad probably not worth using.
    """
    def __init__(self, url, **kwargs):
        super(PyPIJSONLocator, self).__init__(**kwargs)
        self.base_url = ensure_slash(url)

    def get_distribution_names(self):
        """
        Return all the distribution names known to this locator.
        """
        raise NotImplementedError('Not available from this locator')

    def _get_project(self, name):
        result = {}
        url = urljoin(self.base_url, '%s/json' % quote(name))
        try:
            resp = self.opener.open(url)
            data = resp.read().decode() # for now
            d = json.loads(data)
            md = Metadata(scheme=self.scheme)
            data = d['info']
            md.name = data['name']
            md.version = data['version']
            md.license = data.get('license')
            md.keywords = data.get('keywords', [])
            md.summary = data.get('summary')
            dist = Distribution(md)
            urls = d['urls']
            if urls:
                info = urls[0]
                md.source_url = info['url']
                dist.digest = self._get_digest(info)
                dist.locator = self
                result[md.version] = dist
        except Exception as e:
            logger.exception('JSON fetch failed: %s', e)
        return result


class Page(object):
    """
    This class represents a scraped HTML page.
    """
    # The following slightly hairy-looking regex just looks for the contents of
    # an anchor link, which has an attribute "href" either immediately preceded
    # or immediately followed by a "rel" attribute. The attribute values can be
    # declared with double quotes, single quotes or no quotes - which leads to
    # the length of the expression.
    _href = re.compile("""
(rel\s*=\s*(?:"(?P<rel1>[^"]*)"|'(?P<rel2>[^']*)'|(?P<rel3>[^>\s\n]*))\s+)?
href\s*=\s*(?:"(?P<url1>[^"]*)"|'(?P<url2>[^']*)'|(?P<url3>[^>\s\n]*))
(\s+rel\s*=\s*(?:"(?P<rel4>[^"]*)"|'(?P<rel5>[^']*)'|(?P<rel6>[^>\s\n]*)))?
""", re.I | re.S | re.X)
    _base = re.compile(r"""<base\s+href\s*=\s*['"]?([^'">]+)""", re.I | re.S)

    def __init__(self, data, url):
        """
        Initialise an instance with the Unicode page contents and the URL they
        came from.
        """
        self.data = data
        self.base_url = self.url = url
        m = self._base.search(self.data)
        if m:
            self.base_url = m.group(1)

    _clean_re = re.compile(r'[^a-z0-9$&+,/:;=?@.#%_\\|-]', re.I)

    @cached_property
    def links(self):
        """
        Return the URLs of all the links on a page together with information
        about their "rel" attribute, for determining which ones to treat as
        downloads and which ones to queue for further scraping.
        """
        def clean(url):
            "Tidy up an URL."
            scheme, netloc, path, params, query, frag = urlparse(url)
            return urlunparse((scheme, netloc, quote(path),
                               params, query, frag))

        result = set()
        for match in self._href.finditer(self.data):
            d = match.groupdict('')
            rel = (d['rel1'] or d['rel2'] or d['rel3'] or
                   d['rel4'] or d['rel5'] or d['rel6'])
            url = d['url1'] or d['url2'] or d['url3']
            url = urljoin(self.base_url, url)
            url = unescape(url)
            url = self._clean_re.sub(lambda m: '%%%2x' % ord(m.group(0)), url)
            result.add((url, rel))
        # We sort the result, hoping to bring the most recent versions
        # to the front
        result = sorted(result, key=lambda t: t[0], reverse=True)
        return result


class SimpleScrapingLocator(Locator):
    """
    A locator which scrapes HTML pages to locate downloads for a distribution.
    This runs multiple threads to do the I/O; performance is at least as good
    as pip's PackageFinder, which works in an analogous fashion.
    """

    # These are used to deal with various Content-Encoding schemes.
    decoders = {
        'deflate': zlib.decompress,
        'gzip': lambda b: gzip.GzipFile(fileobj=BytesIO(d)).read(),
        'none': lambda b: b,
    }

    def __init__(self, url, timeout=None, num_workers=10, **kwargs):
        """
        Initialise an instance.
        :param url: The root URL to use for scraping.
        :param timeout: The timeout, in seconds, to be applied to requests.
                        This defaults to ``None`` (no timeout specified).
        :param num_workers: The number of worker threads you want to do I/O,
                            This defaults to 10.
        :param kwargs: Passed to the superclass.
        """
        super(SimpleScrapingLocator, self).__init__(**kwargs)
        self.base_url = ensure_slash(url)
        self.timeout = timeout
        self._page_cache = {}
        self._seen = set()
        self._to_fetch = queue.Queue()
        self._bad_hosts = set()
        self.skip_externals = False
        self.num_workers = num_workers
        self._lock = threading.RLock()
        # See issue #45: we need to be resilient when the locator is used
        # in a thread, e.g. with concurrent.futures. We can't use self._lock
        # as it is for coordinating our internal threads - the ones created
        # in _prepare_threads.
        self._gplock = threading.RLock()

    def _prepare_threads(self):
        """
        Threads are created only when get_project is called, and terminate
        before it returns. They are there primarily to parallelise I/O (i.e.
        fetching web pages).
        """
        self._threads = []
        for i in range(self.num_workers):
            t = threading.Thread(target=self._fetch)
            t.setDaemon(True)
            t.start()
            self._threads.append(t)

    def _wait_threads(self):
        """
        Tell all the threads to terminate (by sending a sentinel value) and
        wait for them to do so.
        """
        # Note that you need two loops, since you can't say which
        # thread will get each sentinel
        for t in self._threads:
            self._to_fetch.put(None)    # sentinel
        for t in self._threads:
            t.join()
        self._threads = []

    def _get_project(self, name):
        result = {}
        with self._gplock:
            self.result = result
            self.project_name = name
            url = urljoin(self.base_url, '%s/' % quote(name))
            self._seen.clear()
            self._page_cache.clear()
            self._prepare_threads()
            try:
                logger.debug('Queueing %s', url)
                self._to_fetch.put(url)
                self._to_fetch.join()
            finally:
                self._wait_threads()
            del self.result
        return result

    platform_dependent = re.compile(r'\b(linux-(i\d86|x86_64|arm\w+)|'
                                    r'win(32|-amd64)|macosx-?\d+)\b', re.I)

    def _is_platform_dependent(self, url):
        """
        Does an URL refer to a platform-specific download?
        """
        return self.platform_dependent.search(url)

    def _process_download(self, url):
        """
        See if an URL is a suitable download for a project.

        If it is, register information in the result dictionary (for
        _get_project) about the specific version it's for.

        Note that the return value isn't actually used other than as a boolean
        value.
        """
        if self._is_platform_dependent(url):
            info = None
        else:
            info = self.convert_url_to_download_info(url, self.project_name)
        logger.debug('process_download: %s -> %s', url, info)
        if info:
            with self._lock:    # needed because self.result is shared
                self._update_version_data(self.result, info)
        return info

    def _should_queue(self, link, referrer, rel):
        """
        Determine whether a link URL from a referring page and with a
        particular "rel" attribute should be queued for scraping.
        """
        scheme, netloc, path, _, _, _ = urlparse(link)
        if path.endswith(self.source_extensions + self.binary_extensions +
                         self.excluded_extensions):
            result = False
        elif self.skip_externals and not link.startswith(self.base_url):
            result = False
        elif not referrer.startswith(self.base_url):
            result = False
        elif rel not in ('homepage', 'download'):
            result = False
        elif scheme not in ('http', 'https', 'ftp'):
            result = False
        elif self._is_platform_dependent(link):
            result = False
        else:
            host = netloc.split(':', 1)[0]
            if host.lower() == 'localhost':
                result = False
            else:
                result = True
        logger.debug('should_queue: %s (%s) from %s -> %s', link, rel,
                     referrer, result)
        return result

    def _fetch(self):
        """
        Get a URL to fetch from the work queue, get the HTML page, examine its
        links for download candidates and candidates for further scraping.

        This is a handy method to run in a thread.
        """
        while True:
            url = self._to_fetch.get()
            try:
                if url:
                    page = self.get_page(url)
                    if page is None:    # e.g. after an error
                        continue
                    for link, rel in page.links:
                        if link not in self._seen:
                            self._seen.add(link)
                            if (not self._process_download(link) and
                                self._should_queue(link, url, rel)):
                                logger.debug('Queueing %s from %s', link, url)
                                self._to_fetch.put(link)
            finally:
                # always do this, to avoid hangs :-)
                self._to_fetch.task_done()
            if not url:
                #logger.debug('Sentinel seen, quitting.')
                break

    def get_page(self, url):
        """
        Get the HTML for an URL, possibly from an in-memory cache.

        XXX TODO Note: this cache is never actually cleared. It's assumed that
        the data won't get stale over the lifetime of a locator instance (not
        necessarily true for the default_locator).
        """
        # http://peak.telecommunity.com/DevCenter/EasyInstall#package-index-api
        scheme, netloc, path, _, _, _ = urlparse(url)
        if scheme == 'file' and os.path.isdir(url2pathname(path)):
            url = urljoin(ensure_slash(url), 'index.html')

        if url in self._page_cache:
            result = self._page_cache[url]
            logger.debug('Returning %s from cache: %s', url, result)
        else:
            host = netloc.split(':', 1)[0]
            result = None
            if host in self._bad_hosts:
                logger.debug('Skipping %s due to bad host %s', url, host)
            else:
                req = Request(url, headers={'Accept-encoding': 'identity'})
                try:
                    logger.debug('Fetching %s', url)
                    resp = self.opener.open(req, timeout=self.timeout)
                    logger.debug('Fetched %s', url)
                    headers = resp.info()
                    content_type = headers.get('Content-Type', '')
                    if HTML_CONTENT_TYPE.match(content_type):
                        final_url = resp.geturl()
                        data = resp.read()
                        encoding = headers.get('Content-Encoding')
                        if encoding:
                            decoder = self.decoders[encoding]   # fail if not found
                            data = decoder(data)
                        encoding = 'utf-8'
                        m = CHARSET.search(content_type)
                        if m:
                            encoding = m.group(1)
                        try:
                            data = data.decode(encoding)
                        except UnicodeError:
                            data = data.decode('latin-1')    # fallback
                        result = Page(data, final_url)
                        self._page_cache[final_url] = result
                except HTTPError as e:
                    if e.code != 404:
                        logger.exception('Fetch failed: %s: %s', url, e)
                except URLError as e:
                    logger.exception('Fetch failed: %s: %s', url, e)
                    with self._lock:
                        self._bad_hosts.add(host)
                except Exception as e:
                    logger.exception('Fetch failed: %s: %s', url, e)
                finally:
                    self._page_cache[url] = result   # even if None (failure)
        return result

    _distname_re = re.compile('<a href=[^>]*>([^<]+)<')

    def get_distribution_names(self):
        """
        Return all the distribution names known to this locator.
        """
        result = set()
        page = self.get_page(self.base_url)
        if not page:
            raise DistlibException('Unable to get %s' % self.base_url)
        for match in self._distname_re.finditer(page.data):
            result.add(match.group(1))
        return result

class DirectoryLocator(Locator):
    """
    This class locates distributions in a directory tree.
    """

    def __init__(self, path, **kwargs):
        """
        Initialise an instance.
        :param path: The root of the directory tree to search.
        :param kwargs: Passed to the superclass constructor,
                       except for:
                       * recursive - if True (the default), subdirectories are
                         recursed into. If False, only the top-level directory
                         is searched,
        """
        self.recursive = kwargs.pop('recursive', True)
        super(DirectoryLocator, self).__init__(**kwargs)
        path = os.path.abspath(path)
        if not os.path.isdir(path):
            raise DistlibException('Not a directory: %r' % path)
        self.base_dir = path

    def should_include(self, filename, parent):
        """
        Should a filename be considered as a candidate for a distribution
        archive? As well as the filename, the directory which contains it
        is provided, though not used by the current implementation.
        """
        return filename.endswith(self.downloadable_extensions)

    def _get_project(self, name):
        result = {}
        for root, dirs, files in os.walk(self.base_dir):
            for fn in files:
                if self.should_include(fn, root):
                    fn = os.path.join(root, fn)
                    url = urlunparse(('file', '',
                                      pathname2url(os.path.abspath(fn)),
                                      '', '', ''))
                    info = self.convert_url_to_download_info(url, name)
                    if info:
                        self._update_version_data(result, info)
            if not self.recursive:
                break
        return result

    def get_distribution_names(self):
        """
        Return all the distribution names known to this locator.
        """
        result = set()
        for root, dirs, files in os.walk(self.base_dir):
            for fn in files:
                if self.should_include(fn, root):
                    fn = os.path.join(root, fn)
                    url = urlunparse(('file', '',
                                      pathname2url(os.path.abspath(fn)),
                                      '', '', ''))
                    info = self.convert_url_to_download_info(url, None)
                    if info:
                        result.add(info['name'])
            if not self.recursive:
                break
        return result

class JSONLocator(Locator):
    """
    This locator uses special extended metadata (not available on PyPI) and is
    the basis of performant dependency resolution in distlib. Other locators
    require archive downloads before dependencies can be determined! As you
    might imagine, that can be slow.
    """
    def get_distribution_names(self):
        """
        Return all the distribution names known to this locator.
        """
        raise NotImplementedError('Not available from this locator')

    def _get_project(self, name):
        result = {}
        data = get_project_data(name)
        if data:
            for info in data.get('files', []):
                if info['ptype'] != 'sdist' or info['pyversion'] != 'source':
                    continue
                # We don't store summary in project metadata as it makes
                # the data bigger for no benefit during dependency
                # resolution
                dist = make_dist(data['name'], info['version'],
                                 summary=data.get('summary',
                                                  'Placeholder for summary'),
                                 scheme=self.scheme)
                md = dist.metadata
                md.source_url = info['url']
                # TODO SHA256 digest
                if 'digest' in info and info['digest']:
                    dist.digest = ('md5', info['digest'])
                md.dependencies = info.get('requirements', {})
                dist.exports = info.get('exports', {})
                result[dist.version] = dist
        return result

class DistPathLocator(Locator):
    """
    This locator finds installed distributions in a path. It can be useful for
    adding to an :class:`AggregatingLocator`.
    """
    def __init__(self, distpath, **kwargs):
        """
        Initialise an instance.

        :param distpath: A :class:`DistributionPath` instance to search.
        """
        super(DistPathLocator, self).__init__(**kwargs)
        assert isinstance(distpath, DistributionPath)
        self.distpath = distpath

    def _get_project(self, name):
        dist = self.distpath.get_distribution(name)
        if dist is None:
            result = {}
        else:
            result = { dist.version: dist }
        return result


class AggregatingLocator(Locator):
    """
    This class allows you to chain and/or merge a list of locators.
    """
    def __init__(self, *locators, **kwargs):
        """
        Initialise an instance.

        :param locators: The list of locators to search.
        :param kwargs: Passed to the superclass constructor,
                       except for:
                       * merge - if False (the default), the first successful
                         search from any of the locators is returned. If True,
                         the results from all locators are merged (this can be
                         slow).
        """
        self.merge = kwargs.pop('merge', False)
        self.locators = locators
        super(AggregatingLocator, self).__init__(**kwargs)

    def clear_cache(self):
        super(AggregatingLocator, self).clear_cache()
        for locator in self.locators:
            locator.clear_cache()

    def _set_scheme(self, value):
        self._scheme = value
        for locator in self.locators:
            locator.scheme = value

    scheme = property(Locator.scheme.fget, _set_scheme)

    def _get_project(self, name):
        result = {}
        for locator in self.locators:
            d = locator.get_project(name)
            if d:
                if self.merge:
                    result.update(d)
                else:
                    # See issue #18. If any dists are found and we're looking
                    # for specific constraints, we only return something if
                    # a match is found. For example, if a DirectoryLocator
                    # returns just foo (1.0) while we're looking for
                    # foo (>= 2.0), we'll pretend there was nothing there so
                    # that subsequent locators can be queried. Otherwise we
                    # would just return foo (1.0) which would then lead to a
                    # failure to find foo (>= 2.0), because other locators
                    # weren't searched. Note that this only matters when
                    # merge=False.
                    if self.matcher is None:
                        found = True
                    else:
                        found = False
                        for k in d:
                            if self.matcher.match(k):
                                found = True
                                break
                    if found:
                        result = d
                        break
        return result

    def get_distribution_names(self):
        """
        Return all the distribution names known to this locator.
        """
        result = set()
        for locator in self.locators:
            try:
                result |= locator.get_distribution_names()
            except NotImplementedError:
                pass
        return result


# We use a legacy scheme simply because most of the dists on PyPI use legacy
# versions which don't conform to PEP 426 / PEP 440.
default_locator = AggregatingLocator(
                    JSONLocator(),
                    SimpleScrapingLocator('https://pypi.python.org/simple/',
                                          timeout=3.0),
                    scheme='legacy')

locate = default_locator.locate

NAME_VERSION_RE = re.compile(r'(?P<name>[\w-]+)\s*'
                             r'\(\s*(==\s*)?(?P<ver>[^)]+)\)$')

class DependencyFinder(object):
    """
    Locate dependencies for distributions.
    """

    def __init__(self, locator=None):
        """
        Initialise an instance, using the specified locator
        to locate distributions.
        """
        self.locator = locator or default_locator
        self.scheme = get_scheme(self.locator.scheme)

    def add_distribution(self, dist):
        """
        Add a distribution to the finder. This will update internal information
        about who provides what.
        :param dist: The distribution to add.
        """
        logger.debug('adding distribution %s', dist)
        name = dist.key
        self.dists_by_name[name] = dist
        self.dists[(name, dist.version)] = dist
        for p in dist.provides:
            name, version = parse_name_and_version(p)
            logger.debug('Add to provided: %s, %s, %s', name, version, dist)
            self.provided.setdefault(name, set()).add((version, dist))

    def remove_distribution(self, dist):
        """
        Remove a distribution from the finder. This will update internal
        information about who provides what.
        :param dist: The distribution to remove.
        """
        logger.debug('removing distribution %s', dist)
        name = dist.key
        del self.dists_by_name[name]
        del self.dists[(name, dist.version)]
        for p in dist.provides:
            name, version = parse_name_and_version(p)
            logger.debug('Remove from provided: %s, %s, %s', name, version, dist)
            s = self.provided[name]
            s.remove((version, dist))
            if not s:
                del self.provided[name]

    def get_matcher(self, reqt):
        """
        Get a version matcher for a requirement.
        :param reqt: The requirement
        :type reqt: str
        :return: A version matcher (an instance of
                 :class:`distlib.version.Matcher`).
        """
        try:
            matcher = self.scheme.matcher(reqt)
        except UnsupportedVersionError:
            # XXX compat-mode if cannot read the version
            name = reqt.split()[0]
            matcher = self.scheme.matcher(name)
        return matcher

    def find_providers(self, reqt):
        """
        Find the distributions which can fulfill a requirement.

        :param reqt: The requirement.
         :type reqt: str
        :return: A set of distribution which can fulfill the requirement.
        """
        matcher = self.get_matcher(reqt)
        name = matcher.key   # case-insensitive
        result = set()
        provided = self.provided
        if name in provided:
            for version, provider in provided[name]:
                try:
                    match = matcher.match(version)
                except UnsupportedVersionError:
                    match = False

                if match:
                    result.add(provider)
                    break
        return result

    def try_to_replace(self, provider, other, problems):
        """
        Attempt to replace one provider with another. This is typically used
        when resolving dependencies from multiple sources, e.g. A requires
        (B >= 1.0) while C requires (B >= 1.1).

        For successful replacement, ``provider`` must meet all the requirements
        which ``other`` fulfills.

        :param provider: The provider we are trying to replace with.
        :param other: The provider we're trying to replace.
        :param problems: If False is returned, this will contain what
                         problems prevented replacement. This is currently
                         a tuple of the literal string 'cantreplace',
                         ``provider``, ``other``  and the set of requirements
                         that ``provider`` couldn't fulfill.
        :return: True if we can replace ``other`` with ``provider``, else
                 False.
        """
        rlist = self.reqts[other]
        unmatched = set()
        for s in rlist:
            matcher = self.get_matcher(s)
            if not matcher.match(provider.version):
                unmatched.add(s)
        if unmatched:
            # can't replace other with provider
            problems.add(('cantreplace', provider, other, unmatched))
            result = False
        else:
            # can replace other with provider
            self.remove_distribution(other)
            del self.reqts[other]
            for s in rlist:
                self.reqts.setdefault(provider, set()).add(s)
            self.add_distribution(provider)
            result = True
        return result

    def find(self, requirement, meta_extras=None, prereleases=False):
        """
        Find a distribution and all distributions it depends on.

        :param requirement: The requirement specifying the distribution to
                            find, or a Distribution instance.
        :param meta_extras: A list of meta extras such as :test:, :build: and
                            so on.
        :param prereleases: If ``True``, allow pre-release versions to be
                            returned - otherwise, don't return prereleases
                            unless they're all that's available.

        Return a set of :class:`Distribution` instances and a set of
        problems.

        The distributions returned should be such that they have the
        :attr:`required` attribute set to ``True`` if they were
        from the ``requirement`` passed to ``find()``, and they have the
        :attr:`build_time_dependency` attribute set to ``True`` unless they
        are post-installation dependencies of the ``requirement``.

        The problems should be a tuple consisting of the string
        ``'unsatisfied'`` and the requirement which couldn't be satisfied
        by any distribution known to the locator.
        """

        self.provided = {}
        self.dists = {}
        self.dists_by_name = {}
        self.reqts = {}

        meta_extras = set(meta_extras or [])
        if ':*:' in meta_extras:
            meta_extras.remove(':*:')
            # :meta: and :run: are implicitly included
            meta_extras |= set([':test:', ':build:', ':dev:'])

        if isinstance(requirement, Distribution):
            dist = odist = requirement
            logger.debug('passed %s as requirement', odist)
        else:
            dist = odist = self.locator.locate(requirement,
                                               prereleases=prereleases)
            if dist is None:
                raise DistlibException('Unable to locate %r' % requirement)
            logger.debug('located %s', odist)
        dist.requested = True
        problems = set()
        todo = set([dist])
        install_dists = set([odist])
        while todo:
            dist = todo.pop()
            name = dist.key     # case-insensitive
            if name not in self.dists_by_name:
                self.add_distribution(dist)
            else:
                #import pdb; pdb.set_trace()
                other = self.dists_by_name[name]
                if other != dist:
                    self.try_to_replace(dist, other, problems)

            ireqts = dist.run_requires | dist.meta_requires
            sreqts = dist.build_requires
            ereqts = set()
            if dist in install_dists:
                for key in ('test', 'build', 'dev'):
                    e = ':%s:' % key
                    if e in meta_extras:
                        ereqts |= getattr(dist, '%s_requires' % key)
            all_reqts = ireqts | sreqts | ereqts
            for r in all_reqts:
                providers = self.find_providers(r)
                if not providers:
                    logger.debug('No providers found for %r', r)
                    provider = self.locator.locate(r, prereleases=prereleases)
                    # If no provider is found and we didn't consider
                    # prereleases, consider them now.
                    if provider is None and not prereleases:
                        provider = self.locator.locate(r, prereleases=True)
                    if provider is None:
                        logger.debug('Cannot satisfy %r', r)
                        problems.add(('unsatisfied', r))
                    else:
                        n, v = provider.key, provider.version
                        if (n, v) not in self.dists:
                            todo.add(provider)
                        providers.add(provider)
                        if r in ireqts and dist in install_dists:
                            install_dists.add(provider)
                            logger.debug('Adding %s to install_dists',
                                         provider.name_and_version)
                for p in providers:
                    name = p.key
                    if name not in self.dists_by_name:
                        self.reqts.setdefault(p, set()).add(r)
                    else:
                        other = self.dists_by_name[name]
                        if other != p:
                            # see if other can be replaced by p
                            self.try_to_replace(p, other, problems)

        dists = set(self.dists.values())
        for dist in dists:
            dist.build_time_dependency = dist not in install_dists
            if dist.build_time_dependency:
                logger.debug('%s is a build-time dependency only.',
                             dist.name_and_version)
        logger.debug('find done for %s', odist)
        return dists, problems

########NEW FILE########
__FILENAME__ = manifest
# -*- coding: utf-8 -*-
#
# Copyright (C) 2012-2013 Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""
Class representing the list of files in a distribution.

Equivalent to distutils.filelist, but fixes some problems.
"""
import fnmatch
import logging
import os
import re

from . import DistlibException
from .compat import fsdecode
from .util import convert_path


__all__ = ['Manifest']

logger = logging.getLogger(__name__)

# a \ followed by some spaces + EOL
_COLLAPSE_PATTERN = re.compile('\\\w*\n', re.M)
_COMMENTED_LINE = re.compile('#.*?(?=\n)|\n(?=$)', re.M | re.S)


class Manifest(object):
    """A list of files built by on exploring the filesystem and filtered by
    applying various patterns to what we find there.
    """

    def __init__(self, base=None):
        """
        Initialise an instance.

        :param base: The base directory to explore under.
        """
        self.base = os.path.abspath(os.path.normpath(base or os.getcwd()))
        self.prefix = self.base + os.sep
        self.allfiles = None
        self.files = set()

    #
    # Public API
    #

    def findall(self):
        """Find all files under the base and set ``allfiles`` to the absolute
        pathnames of files found.
        """
        from stat import S_ISREG, S_ISDIR, S_ISLNK

        self.allfiles = allfiles = []
        root = self.base
        stack = [root]
        pop = stack.pop
        push = stack.append

        while stack:
            root = pop()
            names = os.listdir(root)

            for name in names:
                fullname = os.path.join(root, name)

                # Avoid excess stat calls -- just one will do, thank you!
                stat = os.stat(fullname)
                mode = stat.st_mode
                if S_ISREG(mode):
                    allfiles.append(fsdecode(fullname))
                elif S_ISDIR(mode) and not S_ISLNK(mode):
                    push(fullname)

    def add(self, item):
        """
        Add a file to the manifest.

        :param item: The pathname to add. This can be relative to the base.
        """
        if not item.startswith(self.prefix):
            item = os.path.join(self.base, item)
        self.files.add(os.path.normpath(item))

    def add_many(self, items):
        """
        Add a list of files to the manifest.

        :param items: The pathnames to add. These can be relative to the base.
        """
        for item in items:
            self.add(item)

    def sorted(self, wantdirs=False):
        """
        Return sorted files in directory order
        """

        def add_dir(dirs, d):
            dirs.add(d)
            logger.debug('add_dir added %s', d)
            if d != self.base:
                parent, _ = os.path.split(d)
                assert parent not in ('', '/')
                add_dir(dirs, parent)

        result = set(self.files)    # make a copy!
        if wantdirs:
            dirs = set()
            for f in result:
                add_dir(dirs, os.path.dirname(f))
            result |= dirs
        return [os.path.join(*path_tuple) for path_tuple in
                sorted(os.path.split(path) for path in result)]

    def clear(self):
        """Clear all collected files."""
        self.files = set()
        self.allfiles = []

    def process_directive(self, directive):
        """
        Process a directive which either adds some files from ``allfiles`` to
        ``files``, or removes some files from ``files``.

        :param directive: The directive to process. This should be in a format
                     compatible with distutils ``MANIFEST.in`` files:

                     http://docs.python.org/distutils/sourcedist.html#commands
        """
        # Parse the line: split it up, make sure the right number of words
        # is there, and return the relevant words.  'action' is always
        # defined: it's the first word of the line.  Which of the other
        # three are defined depends on the action; it'll be either
        # patterns, (dir and patterns), or (dirpattern).
        action, patterns, thedir, dirpattern = self._parse_directive(directive)

        # OK, now we know that the action is valid and we have the
        # right number of words on the line for that action -- so we
        # can proceed with minimal error-checking.
        if action == 'include':
            for pattern in patterns:
                if not self._include_pattern(pattern, anchor=True):
                    logger.warning('no files found matching %r', pattern)

        elif action == 'exclude':
            for pattern in patterns:
                if not self._exclude_pattern(pattern, anchor=True):
                    logger.warning('no previously-included files '
                                   'found matching %r', pattern)

        elif action == 'global-include':
            for pattern in patterns:
                if not self._include_pattern(pattern, anchor=False):
                    logger.warning('no files found matching %r '
                                   'anywhere in distribution', pattern)

        elif action == 'global-exclude':
            for pattern in patterns:
                if not self._exclude_pattern(pattern, anchor=False):
                    logger.warning('no previously-included files '
                                   'matching %r found anywhere in '
                                   'distribution', pattern)

        elif action == 'recursive-include':
            for pattern in patterns:
                if not self._include_pattern(pattern, prefix=thedir):
                    logger.warning('no files found matching %r '
                                   'under directory %r', pattern, thedir)

        elif action == 'recursive-exclude':
            for pattern in patterns:
                if not self._exclude_pattern(pattern, prefix=thedir):
                    logger.warning('no previously-included files '
                                   'matching %r found under directory %r',
                                   pattern, thedir)

        elif action == 'graft':
            if not self._include_pattern(None, prefix=dirpattern):
                logger.warning('no directories found matching %r',
                               dirpattern)

        elif action == 'prune':
            if not self._exclude_pattern(None, prefix=dirpattern):
                logger.warning('no previously-included directories found '
                               'matching %r', dirpattern)
        else:   # pragma: no cover
            # This should never happen, as it should be caught in
            # _parse_template_line
            raise DistlibException(
                'invalid action %r' % action)

    #
    # Private API
    #

    def _parse_directive(self, directive):
        """
        Validate a directive.
        :param directive: The directive to validate.
        :return: A tuple of action, patterns, thedir, dir_patterns
        """
        words = directive.split()
        if len(words) == 1 and words[0] not in ('include', 'exclude',
                                                'global-include',
                                                'global-exclude',
                                                'recursive-include',
                                                'recursive-exclude',
                                                'graft', 'prune'):
            # no action given, let's use the default 'include'
            words.insert(0, 'include')

        action = words[0]
        patterns = thedir = dir_pattern = None

        if action in ('include', 'exclude',
                      'global-include', 'global-exclude'):
            if len(words) < 2:
                raise DistlibException(
                    '%r expects <pattern1> <pattern2> ...' % action)

            patterns = [convert_path(word) for word in words[1:]]

        elif action in ('recursive-include', 'recursive-exclude'):
            if len(words) < 3:
                raise DistlibException(
                    '%r expects <dir> <pattern1> <pattern2> ...' % action)

            thedir = convert_path(words[1])
            patterns = [convert_path(word) for word in words[2:]]

        elif action in ('graft', 'prune'):
            if len(words) != 2:
                raise DistlibException(
                    '%r expects a single <dir_pattern>' % action)

            dir_pattern = convert_path(words[1])

        else:
            raise DistlibException('unknown action %r' % action)

        return action, patterns, thedir, dir_pattern

    def _include_pattern(self, pattern, anchor=True, prefix=None,
                         is_regex=False):
        """Select strings (presumably filenames) from 'self.files' that
        match 'pattern', a Unix-style wildcard (glob) pattern.

        Patterns are not quite the same as implemented by the 'fnmatch'
        module: '*' and '?'  match non-special characters, where "special"
        is platform-dependent: slash on Unix; colon, slash, and backslash on
        DOS/Windows; and colon on Mac OS.

        If 'anchor' is true (the default), then the pattern match is more
        stringent: "*.py" will match "foo.py" but not "foo/bar.py".  If
        'anchor' is false, both of these will match.

        If 'prefix' is supplied, then only filenames starting with 'prefix'
        (itself a pattern) and ending with 'pattern', with anything in between
        them, will match.  'anchor' is ignored in this case.

        If 'is_regex' is true, 'anchor' and 'prefix' are ignored, and
        'pattern' is assumed to be either a string containing a regex or a
        regex object -- no translation is done, the regex is just compiled
        and used as-is.

        Selected strings will be added to self.files.

        Return True if files are found.
        """
        # XXX docstring lying about what the special chars are?
        found = False
        pattern_re = self._translate_pattern(pattern, anchor, prefix, is_regex)

        # delayed loading of allfiles list
        if self.allfiles is None:
            self.findall()

        for name in self.allfiles:
            if pattern_re.search(name):
                self.files.add(name)
                found = True
        return found

    def _exclude_pattern(self, pattern, anchor=True, prefix=None,
                         is_regex=False):
        """Remove strings (presumably filenames) from 'files' that match
        'pattern'.

        Other parameters are the same as for 'include_pattern()', above.
        The list 'self.files' is modified in place. Return True if files are
        found.

        This API is public to allow e.g. exclusion of SCM subdirs, e.g. when
        packaging source distributions
        """
        found = False
        pattern_re = self._translate_pattern(pattern, anchor, prefix, is_regex)
        for f in list(self.files):
            if pattern_re.search(f):
                self.files.remove(f)
                found = True
        return found

    def _translate_pattern(self, pattern, anchor=True, prefix=None,
                           is_regex=False):
        """Translate a shell-like wildcard pattern to a compiled regular
        expression.

        Return the compiled regex.  If 'is_regex' true,
        then 'pattern' is directly compiled to a regex (if it's a string)
        or just returned as-is (assumes it's a regex object).
        """
        if is_regex:
            if isinstance(pattern, str):
                return re.compile(pattern)
            else:
                return pattern

        if pattern:
            pattern_re = self._glob_to_re(pattern)
        else:
            pattern_re = ''

        base = re.escape(os.path.join(self.base, ''))
        if prefix is not None:
            # ditch end of pattern character
            empty_pattern = self._glob_to_re('')
            prefix_re = self._glob_to_re(prefix)[:-len(empty_pattern)]
            sep = os.sep
            if os.sep == '\\':
                sep = r'\\'
            pattern_re = '^' + base + sep.join((prefix_re,
                                                '.*' + pattern_re))
        else:                               # no prefix -- respect anchor flag
            if anchor:
                pattern_re = '^' + base + pattern_re

        return re.compile(pattern_re)

    def _glob_to_re(self, pattern):
        """Translate a shell-like glob pattern to a regular expression.

        Return a string containing the regex.  Differs from
        'fnmatch.translate()' in that '*' does not match "special characters"
        (which are platform-specific).
        """
        pattern_re = fnmatch.translate(pattern)

        # '?' and '*' in the glob pattern become '.' and '.*' in the RE, which
        # IMHO is wrong -- '?' and '*' aren't supposed to match slash in Unix,
        # and by extension they shouldn't match such "special characters" under
        # any OS.  So change all non-escaped dots in the RE to match any
        # character except the special characters (currently: just os.sep).
        sep = os.sep
        if os.sep == '\\':
            # we're using a regex to manipulate a regex, so we need
            # to escape the backslash twice
            sep = r'\\\\'
        escaped = r'\1[^%s]' % sep
        pattern_re = re.sub(r'((?<!\\)(\\\\)*)\.', escaped, pattern_re)
        return pattern_re

########NEW FILE########
__FILENAME__ = markers
# -*- coding: utf-8 -*-
#
# Copyright (C) 2012-2013 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""Parser for the environment markers micro-language defined in PEP 345."""

import ast
import os
import sys
import platform

from .compat import python_implementation, string_types
from .util import in_venv

__all__ = ['interpret']


class Evaluator(object):
    """
    A limited evaluator for Python expressions.
    """

    operators = {
        'eq': lambda x, y: x == y,
        'gt': lambda x, y: x > y,
        'gte': lambda x, y: x >= y,
        'in': lambda x, y: x in y,
        'lt': lambda x, y: x < y,
        'lte': lambda x, y: x <= y,
        'not': lambda x: not x,
        'noteq': lambda x, y: x != y,
        'notin': lambda x, y: x not in y,
    }

    allowed_values = {
        'sys_platform': sys.platform,
        'python_version': '%s.%s' % sys.version_info[:2],
        # parsing sys.platform is not reliable, but there is no other
        # way to get e.g. 2.7.2+, and the PEP is defined with sys.version
        'python_full_version': sys.version.split(' ', 1)[0],
        'os_name': os.name,
        'platform_in_venv': str(in_venv()),
        'platform_release': platform.release(),
        'platform_version': platform.version(),
        'platform_machine': platform.machine(),
        'platform_python_implementation': python_implementation(),
    }

    def __init__(self, context=None):
        """
        Initialise an instance.

        :param context: If specified, names are looked up in this mapping.
        """
        self.context = context or {}
        self.source = None

    def get_fragment(self, offset):
        """
        Get the part of the source which is causing a problem.
        """
        fragment_len = 10
        s = '%r' % (self.source[offset:offset + fragment_len])
        if offset + fragment_len < len(self.source):
            s += '...'
        return s

    def get_handler(self, node_type):
        """
        Get a handler for the specified AST node type.
        """
        return getattr(self, 'do_%s' % node_type, None)

    def evaluate(self, node, filename=None):
        """
        Evaluate a source string or node, using ``filename`` when
        displaying errors.
        """
        if isinstance(node, string_types):
            self.source = node
            kwargs = {'mode': 'eval'}
            if filename:
                kwargs['filename'] = filename
            try:
                node = ast.parse(node, **kwargs)
            except SyntaxError as e:
                s = self.get_fragment(e.offset)
                raise SyntaxError('syntax error %s' % s)
        node_type = node.__class__.__name__.lower()
        handler = self.get_handler(node_type)
        if handler is None:
            if self.source is None:
                s = '(source not available)'
            else:
                s = self.get_fragment(node.col_offset)
            raise SyntaxError("don't know how to evaluate %r %s" % (
                node_type, s))
        return handler(node)

    def get_attr_key(self, node):
        assert isinstance(node, ast.Attribute), 'attribute node expected'
        return '%s.%s' % (node.value.id, node.attr)

    def do_attribute(self, node):
        if not isinstance(node.value, ast.Name):
            valid = False
        else:
            key = self.get_attr_key(node)
            valid = key in self.context or key in self.allowed_values
        if not valid:
            raise SyntaxError('invalid expression: %s' % key)
        if key in self.context:
            result = self.context[key]
        else:
            result = self.allowed_values[key]
        return result

    def do_boolop(self, node):
        result = self.evaluate(node.values[0])
        is_or = node.op.__class__ is ast.Or
        is_and = node.op.__class__ is ast.And
        assert is_or or is_and
        if (is_and and result) or (is_or and not result):
            for n in node.values[1:]:
                result = self.evaluate(n)
                if (is_or and result) or (is_and and not result):
                    break
        return result

    def do_compare(self, node):
        def sanity_check(lhsnode, rhsnode):
            valid = True
            if isinstance(lhsnode, ast.Str) and isinstance(rhsnode, ast.Str):
                valid = False
            #elif (isinstance(lhsnode, ast.Attribute)
            #      and isinstance(rhsnode, ast.Attribute)):
            #    klhs = self.get_attr_key(lhsnode)
            #    krhs = self.get_attr_key(rhsnode)
            #    valid = klhs != krhs
            if not valid:
                s = self.get_fragment(node.col_offset)
                raise SyntaxError('Invalid comparison: %s' % s)

        lhsnode = node.left
        lhs = self.evaluate(lhsnode)
        result = True
        for op, rhsnode in zip(node.ops, node.comparators):
            sanity_check(lhsnode, rhsnode)
            op = op.__class__.__name__.lower()
            if op not in self.operators:
                raise SyntaxError('unsupported operation: %r' % op)
            rhs = self.evaluate(rhsnode)
            result = self.operators[op](lhs, rhs)
            if not result:
                break
            lhs = rhs
            lhsnode = rhsnode
        return result

    def do_expression(self, node):
        return self.evaluate(node.body)

    def do_name(self, node):
        valid = False
        if node.id in self.context:
            valid = True
            result = self.context[node.id]
        elif node.id in self.allowed_values:
            valid = True
            result = self.allowed_values[node.id]
        if not valid:
            raise SyntaxError('invalid expression: %s' % node.id)
        return result

    def do_str(self, node):
        return node.s


def interpret(marker, execution_context=None):
    """
    Interpret a marker and return a result depending on environment.

    :param marker: The marker to interpret.
    :type marker: str
    :param execution_context: The context used for name lookup.
    :type execution_context: mapping
    """
    return Evaluator(execution_context).evaluate(marker.strip())

########NEW FILE########
__FILENAME__ = metadata
# -*- coding: utf-8 -*-
#
# Copyright (C) 2012 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""Implementation of the Metadata for Python packages PEPs.

Supports all metadata formats (1.0, 1.1, 1.2, and 2.0 experimental).
"""
from __future__ import unicode_literals

import codecs
from email import message_from_file
import json
import logging
import re


from . import DistlibException, __version__
from .compat import StringIO, string_types, text_type
from .markers import interpret
from .util import extract_by_key, get_extras
from .version import get_scheme, PEP426_VERSION_RE

logger = logging.getLogger(__name__)


class MetadataMissingError(DistlibException):
    """A required metadata is missing"""


class MetadataConflictError(DistlibException):
    """Attempt to read or write metadata fields that are conflictual."""


class MetadataUnrecognizedVersionError(DistlibException):
    """Unknown metadata version number."""


class MetadataInvalidError(DistlibException):
    """A metadata value is invalid"""

# public API of this module
__all__ = ['Metadata', 'PKG_INFO_ENCODING', 'PKG_INFO_PREFERRED_VERSION']

# Encoding used for the PKG-INFO files
PKG_INFO_ENCODING = 'utf-8'

# preferred version. Hopefully will be changed
# to 1.2 once PEP 345 is supported everywhere
PKG_INFO_PREFERRED_VERSION = '1.1'

_LINE_PREFIX = re.compile('\n       \|')
_241_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform',
               'Summary', 'Description',
               'Keywords', 'Home-page', 'Author', 'Author-email',
               'License')

_314_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform',
               'Supported-Platform', 'Summary', 'Description',
               'Keywords', 'Home-page', 'Author', 'Author-email',
               'License', 'Classifier', 'Download-URL', 'Obsoletes',
               'Provides', 'Requires')

_314_MARKERS = ('Obsoletes', 'Provides', 'Requires', 'Classifier',
                'Download-URL')

_345_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform',
               'Supported-Platform', 'Summary', 'Description',
               'Keywords', 'Home-page', 'Author', 'Author-email',
               'Maintainer', 'Maintainer-email', 'License',
               'Classifier', 'Download-URL', 'Obsoletes-Dist',
               'Project-URL', 'Provides-Dist', 'Requires-Dist',
               'Requires-Python', 'Requires-External')

_345_MARKERS = ('Provides-Dist', 'Requires-Dist', 'Requires-Python',
                'Obsoletes-Dist', 'Requires-External', 'Maintainer',
                'Maintainer-email', 'Project-URL')

_426_FIELDS = ('Metadata-Version', 'Name', 'Version', 'Platform',
               'Supported-Platform', 'Summary', 'Description',
               'Keywords', 'Home-page', 'Author', 'Author-email',
               'Maintainer', 'Maintainer-email', 'License',
               'Classifier', 'Download-URL', 'Obsoletes-Dist',
               'Project-URL', 'Provides-Dist', 'Requires-Dist',
               'Requires-Python', 'Requires-External', 'Private-Version',
               'Obsoleted-By', 'Setup-Requires-Dist', 'Extension',
               'Provides-Extra')

_426_MARKERS = ('Private-Version', 'Provides-Extra', 'Obsoleted-By',
                'Setup-Requires-Dist', 'Extension')

_ALL_FIELDS = set()
_ALL_FIELDS.update(_241_FIELDS)
_ALL_FIELDS.update(_314_FIELDS)
_ALL_FIELDS.update(_345_FIELDS)
_ALL_FIELDS.update(_426_FIELDS)

EXTRA_RE = re.compile(r'''extra\s*==\s*("([^"]+)"|'([^']+)')''')


def _version2fieldlist(version):
    if version == '1.0':
        return _241_FIELDS
    elif version == '1.1':
        return _314_FIELDS
    elif version == '1.2':
        return _345_FIELDS
    elif version == '2.0':
        return _426_FIELDS
    raise MetadataUnrecognizedVersionError(version)


def _best_version(fields):
    """Detect the best version depending on the fields used."""
    def _has_marker(keys, markers):
        for marker in markers:
            if marker in keys:
                return True
        return False

    keys = []
    for key, value in fields.items():
        if value in ([], 'UNKNOWN', None):
            continue
        keys.append(key)

    possible_versions = ['1.0', '1.1', '1.2', '2.0']

    # first let's try to see if a field is not part of one of the version
    for key in keys:
        if key not in _241_FIELDS and '1.0' in possible_versions:
            possible_versions.remove('1.0')
        if key not in _314_FIELDS and '1.1' in possible_versions:
            possible_versions.remove('1.1')
        if key not in _345_FIELDS and '1.2' in possible_versions:
            possible_versions.remove('1.2')
        if key not in _426_FIELDS and '2.0' in possible_versions:
            possible_versions.remove('2.0')

    # possible_version contains qualified versions
    if len(possible_versions) == 1:
        return possible_versions[0]   # found !
    elif len(possible_versions) == 0:
        raise MetadataConflictError('Unknown metadata set')

    # let's see if one unique marker is found
    is_1_1 = '1.1' in possible_versions and _has_marker(keys, _314_MARKERS)
    is_1_2 = '1.2' in possible_versions and _has_marker(keys, _345_MARKERS)
    is_2_0 = '2.0' in possible_versions and _has_marker(keys, _426_MARKERS)
    if int(is_1_1) + int(is_1_2) + int(is_2_0) > 1:
        raise MetadataConflictError('You used incompatible 1.1/1.2/2.0 fields')

    # we have the choice, 1.0, or 1.2, or 2.0
    #   - 1.0 has a broken Summary field but works with all tools
    #   - 1.1 is to avoid
    #   - 1.2 fixes Summary but has little adoption
    #   - 2.0 adds more features and is very new
    if not is_1_1 and not is_1_2 and not is_2_0:
        # we couldn't find any specific marker
        if PKG_INFO_PREFERRED_VERSION in possible_versions:
            return PKG_INFO_PREFERRED_VERSION
    if is_1_1:
        return '1.1'
    if is_1_2:
        return '1.2'

    return '2.0'

_ATTR2FIELD = {
    'metadata_version': 'Metadata-Version',
    'name': 'Name',
    'version': 'Version',
    'platform': 'Platform',
    'supported_platform': 'Supported-Platform',
    'summary': 'Summary',
    'description': 'Description',
    'keywords': 'Keywords',
    'home_page': 'Home-page',
    'author': 'Author',
    'author_email': 'Author-email',
    'maintainer': 'Maintainer',
    'maintainer_email': 'Maintainer-email',
    'license': 'License',
    'classifier': 'Classifier',
    'download_url': 'Download-URL',
    'obsoletes_dist': 'Obsoletes-Dist',
    'provides_dist': 'Provides-Dist',
    'requires_dist': 'Requires-Dist',
    'setup_requires_dist': 'Setup-Requires-Dist',
    'requires_python': 'Requires-Python',
    'requires_external': 'Requires-External',
    'requires': 'Requires',
    'provides': 'Provides',
    'obsoletes': 'Obsoletes',
    'project_url': 'Project-URL',
    'private_version': 'Private-Version',
    'obsoleted_by': 'Obsoleted-By',
    'extension': 'Extension',
    'provides_extra': 'Provides-Extra',
}

_PREDICATE_FIELDS = ('Requires-Dist', 'Obsoletes-Dist', 'Provides-Dist')
_VERSIONS_FIELDS = ('Requires-Python',)
_VERSION_FIELDS = ('Version',)
_LISTFIELDS = ('Platform', 'Classifier', 'Obsoletes',
               'Requires', 'Provides', 'Obsoletes-Dist',
               'Provides-Dist', 'Requires-Dist', 'Requires-External',
               'Project-URL', 'Supported-Platform', 'Setup-Requires-Dist',
               'Provides-Extra', 'Extension')
_LISTTUPLEFIELDS = ('Project-URL',)

_ELEMENTSFIELD = ('Keywords',)

_UNICODEFIELDS = ('Author', 'Maintainer', 'Summary', 'Description')

_MISSING = object()

_FILESAFE = re.compile('[^A-Za-z0-9.]+')


def _get_name_and_version(name, version, for_filename=False):
    """Return the distribution name with version.

    If for_filename is true, return a filename-escaped form."""
    if for_filename:
        # For both name and version any runs of non-alphanumeric or '.'
        # characters are replaced with a single '-'.  Additionally any
        # spaces in the version string become '.'
        name = _FILESAFE.sub('-', name)
        version = _FILESAFE.sub('-', version.replace(' ', '.'))
    return '%s-%s' % (name, version)


class LegacyMetadata(object):
    """The legacy metadata of a release.

    Supports versions 1.0, 1.1 and 1.2 (auto-detected). You can
    instantiate the class with one of these arguments (or none):
    - *path*, the path to a metadata file
    - *fileobj* give a file-like object with metadata as content
    - *mapping* is a dict-like object
    - *scheme* is a version scheme name
    """
    # TODO document the mapping API and UNKNOWN default key

    def __init__(self, path=None, fileobj=None, mapping=None,
                 scheme='default'):
        if [path, fileobj, mapping].count(None) < 2:
            raise TypeError('path, fileobj and mapping are exclusive')
        self._fields = {}
        self.requires_files = []
        self._dependencies = None
        self.scheme = scheme
        if path is not None:
            self.read(path)
        elif fileobj is not None:
            self.read_file(fileobj)
        elif mapping is not None:
            self.update(mapping)
            self.set_metadata_version()

    def set_metadata_version(self):
        self._fields['Metadata-Version'] = _best_version(self._fields)

    def _write_field(self, fileobj, name, value):
        fileobj.write('%s: %s\n' % (name, value))

    def __getitem__(self, name):
        return self.get(name)

    def __setitem__(self, name, value):
        return self.set(name, value)

    def __delitem__(self, name):
        field_name = self._convert_name(name)
        try:
            del self._fields[field_name]
        except KeyError:
            raise KeyError(name)

    def __contains__(self, name):
        return (name in self._fields or
                self._convert_name(name) in self._fields)

    def _convert_name(self, name):
        if name in _ALL_FIELDS:
            return name
        name = name.replace('-', '_').lower()
        return _ATTR2FIELD.get(name, name)

    def _default_value(self, name):
        if name in _LISTFIELDS or name in _ELEMENTSFIELD:
            return []
        return 'UNKNOWN'

    def _remove_line_prefix(self, value):
        return _LINE_PREFIX.sub('\n', value)

    def __getattr__(self, name):
        if name in _ATTR2FIELD:
            return self[name]
        raise AttributeError(name)

    #
    # Public API
    #

#    dependencies = property(_get_dependencies, _set_dependencies)

    def get_fullname(self, filesafe=False):
        """Return the distribution name with version.

        If filesafe is true, return a filename-escaped form."""
        return _get_name_and_version(self['Name'], self['Version'], filesafe)

    def is_field(self, name):
        """return True if name is a valid metadata key"""
        name = self._convert_name(name)
        return name in _ALL_FIELDS

    def is_multi_field(self, name):
        name = self._convert_name(name)
        return name in _LISTFIELDS

    def read(self, filepath):
        """Read the metadata values from a file path."""
        fp = codecs.open(filepath, 'r', encoding='utf-8')
        try:
            self.read_file(fp)
        finally:
            fp.close()

    def read_file(self, fileob):
        """Read the metadata values from a file object."""
        msg = message_from_file(fileob)
        self._fields['Metadata-Version'] = msg['metadata-version']

        # When reading, get all the fields we can
        for field in _ALL_FIELDS:
            if field not in msg:
                continue
            if field in _LISTFIELDS:
                # we can have multiple lines
                values = msg.get_all(field)
                if field in _LISTTUPLEFIELDS and values is not None:
                    values = [tuple(value.split(',')) for value in values]
                self.set(field, values)
            else:
                # single line
                value = msg[field]
                if value is not None and value != 'UNKNOWN':
                    self.set(field, value)
        self.set_metadata_version()

    def write(self, filepath, skip_unknown=False):
        """Write the metadata fields to filepath."""
        fp = codecs.open(filepath, 'w', encoding='utf-8')
        try:
            self.write_file(fp, skip_unknown)
        finally:
            fp.close()

    def write_file(self, fileobject, skip_unknown=False):
        """Write the PKG-INFO format data to a file object."""
        self.set_metadata_version()

        for field in _version2fieldlist(self['Metadata-Version']):
            values = self.get(field)
            if skip_unknown and values in ('UNKNOWN', [], ['UNKNOWN']):
                continue
            if field in _ELEMENTSFIELD:
                self._write_field(fileobject, field, ','.join(values))
                continue
            if field not in _LISTFIELDS:
                if field == 'Description':
                    values = values.replace('\n', '\n       |')
                values = [values]

            if field in _LISTTUPLEFIELDS:
                values = [','.join(value) for value in values]

            for value in values:
                self._write_field(fileobject, field, value)

    def update(self, other=None, **kwargs):
        """Set metadata values from the given iterable `other` and kwargs.

        Behavior is like `dict.update`: If `other` has a ``keys`` method,
        they are looped over and ``self[key]`` is assigned ``other[key]``.
        Else, ``other`` is an iterable of ``(key, value)`` iterables.

        Keys that don't match a metadata field or that have an empty value are
        dropped.
        """
        def _set(key, value):
            if key in _ATTR2FIELD and value:
                self.set(self._convert_name(key), value)

        if not other:
            # other is None or empty container
            pass
        elif hasattr(other, 'keys'):
            for k in other.keys():
                _set(k, other[k])
        else:
            for k, v in other:
                _set(k, v)

        if kwargs:
            for k, v in kwargs.items():
                _set(k, v)

    def set(self, name, value):
        """Control then set a metadata field."""
        name = self._convert_name(name)

        if ((name in _ELEMENTSFIELD or name == 'Platform') and
            not isinstance(value, (list, tuple))):
            if isinstance(value, string_types):
                value = [v.strip() for v in value.split(',')]
            else:
                value = []
        elif (name in _LISTFIELDS and
              not isinstance(value, (list, tuple))):
            if isinstance(value, string_types):
                value = [value]
            else:
                value = []

        if logger.isEnabledFor(logging.WARNING):
            project_name = self['Name']

            scheme = get_scheme(self.scheme)
            if name in _PREDICATE_FIELDS and value is not None:
                for v in value:
                    # check that the values are valid
                    if not scheme.is_valid_matcher(v.split(';')[0]):
                        logger.warning(
                            '%r: %r is not valid (field %r)',
                            project_name, v, name)
            # FIXME this rejects UNKNOWN, is that right?
            elif name in _VERSIONS_FIELDS and value is not None:
                if not scheme.is_valid_constraint_list(value):
                    logger.warning('%r: %r is not a valid version (field %r)',
                                   project_name, value, name)
            elif name in _VERSION_FIELDS and value is not None:
                if not scheme.is_valid_version(value):
                    logger.warning('%r: %r is not a valid version (field %r)',
                                   project_name, value, name)

        if name in _UNICODEFIELDS:
            if name == 'Description':
                value = self._remove_line_prefix(value)

        self._fields[name] = value

    def get(self, name, default=_MISSING):
        """Get a metadata field."""
        name = self._convert_name(name)
        if name not in self._fields:
            if default is _MISSING:
                default = self._default_value(name)
            return default
        if name in _UNICODEFIELDS:
            value = self._fields[name]
            return value
        elif name in _LISTFIELDS:
            value = self._fields[name]
            if value is None:
                return []
            res = []
            for val in value:
                if name not in _LISTTUPLEFIELDS:
                    res.append(val)
                else:
                    # That's for Project-URL
                    res.append((val[0], val[1]))
            return res

        elif name in _ELEMENTSFIELD:
            value = self._fields[name]
            if isinstance(value, string_types):
                return value.split(',')
        return self._fields[name]

    def check(self, strict=False):
        """Check if the metadata is compliant. If strict is True then raise if
        no Name or Version are provided"""
        self.set_metadata_version()

        # XXX should check the versions (if the file was loaded)
        missing, warnings = [], []

        for attr in ('Name', 'Version'):  # required by PEP 345
            if attr not in self:
                missing.append(attr)

        if strict and missing != []:
            msg = 'missing required metadata: %s' % ', '.join(missing)
            raise MetadataMissingError(msg)

        for attr in ('Home-page', 'Author'):
            if attr not in self:
                missing.append(attr)

        # checking metadata 1.2 (XXX needs to check 1.1, 1.0)
        if self['Metadata-Version'] != '1.2':
            return missing, warnings

        scheme = get_scheme(self.scheme)

        def are_valid_constraints(value):
            for v in value:
                if not scheme.is_valid_matcher(v.split(';')[0]):
                    return False
            return True

        for fields, controller in ((_PREDICATE_FIELDS, are_valid_constraints),
                                   (_VERSIONS_FIELDS,
                                    scheme.is_valid_constraint_list),
                                   (_VERSION_FIELDS,
                                    scheme.is_valid_version)):
            for field in fields:
                value = self.get(field, None)
                if value is not None and not controller(value):
                    warnings.append('Wrong value for %r: %s' % (field, value))

        return missing, warnings

    def todict(self, skip_missing=False):
        """Return fields as a dict.

        Field names will be converted to use the underscore-lowercase style
        instead of hyphen-mixed case (i.e. home_page instead of Home-page).
        """
        self.set_metadata_version()

        mapping_1_0 = (
            ('metadata_version', 'Metadata-Version'),
            ('name', 'Name'),
            ('version', 'Version'),
            ('summary', 'Summary'),
            ('home_page', 'Home-page'),
            ('author', 'Author'),
            ('author_email', 'Author-email'),
            ('license', 'License'),
            ('description', 'Description'),
            ('keywords', 'Keywords'),
            ('platform', 'Platform'),
            ('classifier', 'Classifier'),
            ('download_url', 'Download-URL'),
        )

        data = {}
        for key, field_name in mapping_1_0:
            if not skip_missing or field_name in self._fields:
                data[key] = self[field_name]

        if self['Metadata-Version'] == '1.2':
            mapping_1_2 = (
                ('requires_dist', 'Requires-Dist'),
                ('requires_python', 'Requires-Python'),
                ('requires_external', 'Requires-External'),
                ('provides_dist', 'Provides-Dist'),
                ('obsoletes_dist', 'Obsoletes-Dist'),
                ('project_url', 'Project-URL'),
                ('maintainer', 'Maintainer'),
                ('maintainer_email', 'Maintainer-email'),
            )
            for key, field_name in mapping_1_2:
                if not skip_missing or field_name in self._fields:
                    if key != 'project_url':
                        data[key] = self[field_name]
                    else:
                        data[key] = [','.join(u) for u in self[field_name]]

        elif self['Metadata-Version'] == '1.1':
            mapping_1_1 = (
                ('provides', 'Provides'),
                ('requires', 'Requires'),
                ('obsoletes', 'Obsoletes'),
            )
            for key, field_name in mapping_1_1:
                if not skip_missing or field_name in self._fields:
                    data[key] = self[field_name]

        return data

    def add_requirements(self, requirements):
        if self['Metadata-Version'] == '1.1':
            # we can't have 1.1 metadata *and* Setuptools requires
            for field in ('Obsoletes', 'Requires', 'Provides'):
                if field in self:
                    del self[field]
        self['Requires-Dist'] += requirements

    # Mapping API
    # TODO could add iter* variants

    def keys(self):
        return list(_version2fieldlist(self['Metadata-Version']))

    def __iter__(self):
        for key in self.keys():
            yield key

    def values(self):
        return [self[key] for key in self.keys()]

    def items(self):
        return [(key, self[key]) for key in self.keys()]

    def __repr__(self):
        return '<%s %s %s>' % (self.__class__.__name__, self.name,
                               self.version)


METADATA_FILENAME = 'pydist.json'


class Metadata(object):
    """
    The metadata of a release. This implementation uses 2.0 (JSON)
    metadata where possible. If not possible, it wraps a LegacyMetadata
    instance which handles the key-value metadata format.
    """

    METADATA_VERSION_MATCHER = re.compile('^\d+(\.\d+)*$')

    NAME_MATCHER = re.compile('^[0-9A-Z]([0-9A-Z_.-]*[0-9A-Z])?$', re.I)

    VERSION_MATCHER = PEP426_VERSION_RE

    SUMMARY_MATCHER = re.compile('.{1,2047}')

    METADATA_VERSION = '2.0'

    GENERATOR = 'distlib (%s)' % __version__

    MANDATORY_KEYS = {
        'name': (),
        'version': (),
        'summary': ('legacy',),
    }

    INDEX_KEYS = ('name version license summary description author '
                  'author_email keywords platform home_page classifiers '
                  'download_url')

    DEPENDENCY_KEYS = ('extras run_requires test_requires build_requires '
                       'dev_requires provides meta_requires obsoleted_by '
                       'supports_environments')

    SYNTAX_VALIDATORS = {
        'metadata_version': (METADATA_VERSION_MATCHER, ()),
        'name': (NAME_MATCHER, ('legacy',)),
        'version': (VERSION_MATCHER, ('legacy',)),
        'summary': (SUMMARY_MATCHER, ('legacy',)),
    }

    __slots__ = ('_legacy', '_data', 'scheme')

    def __init__(self, path=None, fileobj=None, mapping=None,
                 scheme='default'):
        if [path, fileobj, mapping].count(None) < 2:
            raise TypeError('path, fileobj and mapping are exclusive')
        self._legacy = None
        self._data = None
        self.scheme = scheme
        #import pdb; pdb.set_trace()
        if mapping is not None:
            try:
                self._validate_mapping(mapping, scheme)
                self._data = mapping
            except MetadataUnrecognizedVersionError:
                self._legacy = LegacyMetadata(mapping=mapping, scheme=scheme)
                self.validate()
        else:
            data = None
            if path:
                with open(path, 'rb') as f:
                    data = f.read()
            elif fileobj:
                data = fileobj.read()
            if data is None:
                # Initialised with no args - to be added
                self._data = {
                    'metadata_version': self.METADATA_VERSION,
                    'generator': self.GENERATOR,
                }
            else:
                if not isinstance(data, text_type):
                    data = data.decode('utf-8')
                try:
                    self._data = json.loads(data)
                    self._validate_mapping(self._data, scheme)
                except ValueError:
                    # Note: MetadataUnrecognizedVersionError does not
                    # inherit from ValueError (it's a DistlibException,
                    # which should not inherit from ValueError).
                    # The ValueError comes from the json.load - if that
                    # succeeds and we get a validation error, we want
                    # that to propagate
                    self._legacy = LegacyMetadata(fileobj=StringIO(data),
                                                  scheme=scheme)
                    self.validate()

    common_keys = set(('name', 'version', 'license', 'keywords', 'summary'))

    none_list = (None, list)
    none_dict = (None, dict)

    mapped_keys = {
        'run_requires': ('Requires-Dist', list),
        'build_requires': ('Setup-Requires-Dist', list),
        'dev_requires': none_list,
        'test_requires': none_list,
        'meta_requires': none_list,
        'extras': ('Provides-Extra', list),
        'modules': none_list,
        'namespaces': none_list,
        'exports': none_dict,
        'commands': none_dict,
        'classifiers': ('Classifier', list),
        'source_url': ('Download-URL', None),
        'metadata_version': ('Metadata-Version', None),
    }

    del none_list, none_dict

    def __getattribute__(self, key):
        common = object.__getattribute__(self, 'common_keys')
        mapped = object.__getattribute__(self, 'mapped_keys')
        if key in mapped:
            lk, maker = mapped[key]
            if self._legacy:
                if lk is None:
                    result = None if maker is None else maker()
                else:
                    result = self._legacy.get(lk)
            else:
                value = None if maker is None else maker()
                result = self._data.get(key, value)
        elif key not in common:
            result = object.__getattribute__(self, key)
        elif self._legacy:
            result = self._legacy.get(key)
        else:
            result = self._data.get(key)
        return result

    def _validate_value(self, key, value, scheme=None):
        if key in self.SYNTAX_VALIDATORS:
            pattern, exclusions = self.SYNTAX_VALIDATORS[key]
            if (scheme or self.scheme) not in exclusions:
                m = pattern.match(value)
                if not m:
                    raise MetadataInvalidError('%r is an invalid value for '
                                               'the %r property' % (value,
                                                                    key))

    def __setattr__(self, key, value):
        self._validate_value(key, value)
        common = object.__getattribute__(self, 'common_keys')
        mapped = object.__getattribute__(self, 'mapped_keys')
        if key in mapped:
            lk, _ = mapped[key]
            if self._legacy:
                if lk is None:
                    raise NotImplementedError
                self._legacy[lk] = value
            else:
                self._data[key] = value
        elif key not in common:
            object.__setattr__(self, key, value)
        else:
            if key == 'keywords':
                if isinstance(value, string_types):
                    value = value.strip()
                    if value:
                        value = value.split()
                    else:
                        value = []
            if self._legacy:
                self._legacy[key] = value
            else:
                self._data[key] = value

    @property
    def name_and_version(self):
        return _get_name_and_version(self.name, self.version, True)

    @property
    def provides(self):
        if self._legacy:
            result = self._legacy['Provides-Dist']
        else:
            result = self._data.setdefault('provides', [])
        s = '%s (%s)' % (self.name, self.version)
        if s not in result:
            result.append(s)
        return result

    @provides.setter
    def provides(self, value):
        if self._legacy:
            self._legacy['Provides-Dist'] = value
        else:
            self._data['provides'] = value

    def get_requirements(self, reqts, extras=None, env=None):
        """
        Base method to get dependencies, given a set of extras
        to satisfy and an optional environment context.
        :param reqts: A list of sometimes-wanted dependencies,
                      perhaps dependent on extras and environment.
        :param extras: A list of optional components being requested.
        :param env: An optional environment for marker evaluation.
        """
        if self._legacy:
            result = reqts
        else:
            result = []
            extras = get_extras(extras or [], self.extras)
            for d in reqts:
                if 'extra' not in d and 'environment' not in d:
                    # unconditional
                    include = True
                else:
                    if 'extra' not in d:
                        # Not extra-dependent - only environment-dependent
                        include = True
                    else:
                        include = d.get('extra') in extras
                    if include:
                        # Not excluded because of extras, check environment
                        marker = d.get('environment')
                        if marker:
                            include = interpret(marker, env)
                if include:
                    result.extend(d['requires'])
            for key in ('build', 'dev', 'test'):
                e = ':%s:' % key
                if e in extras:
                    extras.remove(e)
                    # A recursive call, but it should terminate since 'test'
                    # has been removed from the extras
                    reqts = self._data.get('%s_requires' % key, [])
                    result.extend(self.get_requirements(reqts, extras=extras,
                                                        env=env))
        return result

    @property
    def dictionary(self):
        if self._legacy:
            return self._from_legacy()
        return self._data

    @property
    def dependencies(self):
        if self._legacy:
            raise NotImplementedError
        else:
            return extract_by_key(self._data, self.DEPENDENCY_KEYS)

    @dependencies.setter
    def dependencies(self, value):
        if self._legacy:
            raise NotImplementedError
        else:
            self._data.update(value)

    def _validate_mapping(self, mapping, scheme):
        if mapping.get('metadata_version') != self.METADATA_VERSION:
            raise MetadataUnrecognizedVersionError()
        missing = []
        for key, exclusions in self.MANDATORY_KEYS.items():
            if key not in mapping:
                if scheme not in exclusions:
                    missing.append(key)
        if missing:
            msg = 'Missing metadata items: %s' % ', '.join(missing)
            raise MetadataMissingError(msg)
        for k, v in mapping.items():
            self._validate_value(k, v, scheme)

    def validate(self):
        if self._legacy:
            missing, warnings = self._legacy.check(True)
            if missing or warnings:
                logger.warning('Metadata: missing: %s, warnings: %s',
                               missing, warnings)
        else:
            self._validate_mapping(self._data, self.scheme)

    def todict(self):
        if self._legacy:
            return self._legacy.todict(True)
        else:
            result = extract_by_key(self._data, self.INDEX_KEYS)
            return result

    def _from_legacy(self):
        assert self._legacy and not self._data
        result = {
            'metadata_version': self.METADATA_VERSION,
            'generator': self.GENERATOR,
        }
        lmd = self._legacy.todict(True)     # skip missing ones
        for k in ('name', 'version', 'license', 'summary', 'description',
                  'classifier'):
            if k in lmd:
                if k == 'classifier':
                    nk = 'classifiers'
                else:
                    nk = k
                result[nk] = lmd[k]
        kw = lmd.get('Keywords', [])
        if kw == ['']:
            kw = []
        result['keywords'] = kw
        keys = (('requires_dist', 'run_requires'),
                ('setup_requires_dist', 'build_requires'))
        for ok, nk in keys:
            if ok in lmd and lmd[ok]:
                result[nk] = [{'requires': lmd[ok]}]
        result['provides'] = self.provides
        author = {}
        maintainer = {}
        return result

    LEGACY_MAPPING = {
        'name': 'Name',
        'version': 'Version',
        'license': 'License',
        'summary': 'Summary',
        'description': 'Description',
        'classifiers': 'Classifier',
    }

    def _to_legacy(self):
        def process_entries(entries):
            reqts = set()
            for e in entries:
                extra = e.get('extra')
                env = e.get('environment')
                rlist = e['requires']
                for r in rlist:
                    if not env and not extra:
                        reqts.add(r)
                    else:
                        marker = ''
                        if extra:
                            marker = 'extra == "%s"' % extra
                        if env:
                            if marker:
                                marker = '(%s) and %s' % (env, marker)
                            else:
                                marker = env
                        reqts.add(';'.join((r, marker)))
            return reqts

        assert self._data and not self._legacy
        result = LegacyMetadata()
        nmd = self._data
        for nk, ok in self.LEGACY_MAPPING.items():
            if nk in nmd:
                result[ok] = nmd[nk]
        r1 = process_entries(self.run_requires + self.meta_requires)
        r2 = process_entries(self.build_requires + self.dev_requires)
        if self.extras:
            result['Provides-Extra'] = sorted(self.extras)
        result['Requires-Dist'] = sorted(r1)
        result['Setup-Requires-Dist'] = sorted(r2)
        # TODO: other fields such as contacts
        return result

    def write(self, path=None, fileobj=None, legacy=False, skip_unknown=True):
        if [path, fileobj].count(None) != 1:
            raise ValueError('Exactly one of path and fileobj is needed')
        self.validate()
        if legacy:
            if self._legacy:
                legacy_md = self._legacy
            else:
                legacy_md = self._to_legacy()
            if path:
                legacy_md.write(path, skip_unknown=skip_unknown)
            else:
                legacy_md.write_file(fileobj, skip_unknown=skip_unknown)
        else:
            if self._legacy:
                d = self._from_legacy()
            else:
                d = self._data
            if fileobj:
                json.dump(d, fileobj, ensure_ascii=True, indent=2,
                          sort_keys=True)
            else:
                with codecs.open(path, 'w', 'utf-8') as f:
                    json.dump(d, f, ensure_ascii=True, indent=2,
                              sort_keys=True)

    def add_requirements(self, requirements):
        if self._legacy:
            self._legacy.add_requirements(requirements)
        else:
            run_requires = self._data.setdefault('run_requires', [])
            always = None
            for entry in run_requires:
                if 'environment' not in entry and 'extra' not in entry:
                    always = entry
                    break
            if always is None:
                always = { 'requires': requirements }
                run_requires.insert(0, always)
            else:
                rset = set(always['requires']) | set(requirements)
                always['requires'] = sorted(rset)

    def __repr__(self):
        name = self.name or '(no name)'
        version = self.version or 'no version'
        return '<%s %s %s (%s)>' % (self.__class__.__name__,
                                    self.metadata_version, name, version)

########NEW FILE########
__FILENAME__ = resources
# -*- coding: utf-8 -*-
#
# Copyright (C) 2013 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
from __future__ import unicode_literals

import bisect
import io
import logging
import os
import pkgutil
import shutil
import sys
import types
import zipimport

from . import DistlibException
from .util import cached_property, get_cache_base, path_to_cache_dir, Cache

logger = logging.getLogger(__name__)


cache = None    # created when needed


class ResourceCache(Cache):
    def __init__(self, base=None):
        if base is None:
            # Use native string to avoid issues on 2.x: see Python #20140.
            base = os.path.join(get_cache_base(), str('resource-cache'))
        super(ResourceCache, self).__init__(base)

    def is_stale(self, resource, path):
        """
        Is the cache stale for the given resource?

        :param resource: The :class:`Resource` being cached.
        :param path: The path of the resource in the cache.
        :return: True if the cache is stale.
        """
        # Cache invalidation is a hard problem :-)
        return True

    def get(self, resource):
        """
        Get a resource into the cache,

        :param resource: A :class:`Resource` instance.
        :return: The pathname of the resource in the cache.
        """
        prefix, path = resource.finder.get_cache_info(resource)
        if prefix is None:
            result = path
        else:
            result = os.path.join(self.base, self.prefix_to_dir(prefix), path)
            dirname = os.path.dirname(result)
            if not os.path.isdir(dirname):
                os.makedirs(dirname)
            if not os.path.exists(result):
                stale = True
            else:
                stale = self.is_stale(resource, path)
            if stale:
                # write the bytes of the resource to the cache location
                with open(result, 'wb') as f:
                    f.write(resource.bytes)
        return result


class ResourceBase(object):
    def __init__(self, finder, name):
        self.finder = finder
        self.name = name


class Resource(ResourceBase):
    """
    A class representing an in-package resource, such as a data file. This is
    not normally instantiated by user code, but rather by a
    :class:`ResourceFinder` which manages the resource.
    """
    is_container = False        # Backwards compatibility

    def as_stream(self):
        """
        Get the resource as a stream.

        This is not a property to make it obvious that it returns a new stream
        each time.
        """
        return self.finder.get_stream(self)

    @cached_property
    def file_path(self):
        global cache
        if cache is None:
            cache = ResourceCache()
        return cache.get(self)

    @cached_property
    def bytes(self):
        return self.finder.get_bytes(self)

    @cached_property
    def size(self):
        return self.finder.get_size(self)


class ResourceContainer(ResourceBase):
    is_container = True     # Backwards compatibility

    @cached_property
    def resources(self):
        return self.finder.get_resources(self)


class ResourceFinder(object):
    """
    Resource finder for file system resources.
    """
    def __init__(self, module):
        self.module = module
        self.loader = getattr(module, '__loader__', None)
        self.base = os.path.dirname(getattr(module, '__file__', ''))

    def _adjust_path(self, path):
        return os.path.realpath(path)

    def _make_path(self, resource_name):
        parts = resource_name.split('/')
        parts.insert(0, self.base)
        result = os.path.join(*parts)
        return self._adjust_path(result)

    def _find(self, path):
        return os.path.exists(path)

    def get_cache_info(self, resource):
        return None, resource.path

    def find(self, resource_name):
        path = self._make_path(resource_name)
        if not self._find(path):
            result = None
        else:
            if self._is_directory(path):
                result = ResourceContainer(self, resource_name)
            else:
                result = Resource(self, resource_name)
            result.path = path
        return result

    def get_stream(self, resource):
        return open(resource.path, 'rb')

    def get_bytes(self, resource):
        with open(resource.path, 'rb') as f:
            return f.read()

    def get_size(self, resource):
        return os.path.getsize(resource.path)

    def get_resources(self, resource):
        def allowed(f):
            return f != '__pycache__' and not f.endswith(('.pyc', '.pyo'))
        return set([f for f in os.listdir(resource.path) if allowed(f)])

    def is_container(self, resource):
        return self._is_directory(resource.path)

    _is_directory = staticmethod(os.path.isdir)


class ZipResourceFinder(ResourceFinder):
    """
    Resource finder for resources in .zip files.
    """
    def __init__(self, module):
        super(ZipResourceFinder, self).__init__(module)
        archive = self.loader.archive
        self.prefix_len = 1 + len(archive)
        # PyPy doesn't have a _files attr on zipimporter, and you can't set one
        if hasattr(self.loader, '_files'):
            self._files = self.loader._files
        else:
            self._files = zipimport._zip_directory_cache[archive]
        self.index = sorted(self._files)

    def _adjust_path(self, path):
        return path

    def _find(self, path):
        path = path[self.prefix_len:]
        if path in self._files:
            result = True
        else:
            if path and path[-1] != os.sep:
                path = path + os.sep
            i = bisect.bisect(self.index, path)
            try:
                result = self.index[i].startswith(path)
            except IndexError:
                result = False
        if not result:
            logger.debug('_find failed: %r %r', path, self.loader.prefix)
        else:
            logger.debug('_find worked: %r %r', path, self.loader.prefix)
        return result

    def get_cache_info(self, resource):
        prefix = self.loader.archive
        path = resource.path[1 + len(prefix):]
        return prefix, path

    def get_bytes(self, resource):
        return self.loader.get_data(resource.path)

    def get_stream(self, resource):
        return io.BytesIO(self.get_bytes(resource))

    def get_size(self, resource):
        path = resource.path[self.prefix_len:]
        return self._files[path][3]

    def get_resources(self, resource):
        path = resource.path[self.prefix_len:]
        if path and path[-1] != os.sep:
            path += os.sep
        plen = len(path)
        result = set()
        i = bisect.bisect(self.index, path)
        while i < len(self.index):
            if not self.index[i].startswith(path):
                break
            s = self.index[i][plen:]
            result.add(s.split(os.sep, 1)[0])   # only immediate children
            i += 1
        return result

    def _is_directory(self, path):
        path = path[self.prefix_len:]
        if path and path[-1] != os.sep:
            path += os.sep
        i = bisect.bisect(self.index, path)
        try:
            result = self.index[i].startswith(path)
        except IndexError:
            result = False
        return result

_finder_registry = {
    type(None): ResourceFinder,
    zipimport.zipimporter: ZipResourceFinder
}

try:
    import _frozen_importlib
    _finder_registry[_frozen_importlib.SourceFileLoader] = ResourceFinder
    _finder_registry[_frozen_importlib.FileFinder] = ResourceFinder
except (ImportError, AttributeError):
    pass


def register_finder(loader, finder_maker):
    _finder_registry[type(loader)] = finder_maker

_finder_cache = {}


def finder(package):
    """
    Return a resource finder for a package.
    :param package: The name of the package.
    :return: A :class:`ResourceFinder` instance for the package.
    """
    if package in _finder_cache:
        result = _finder_cache[package]
    else:
        if package not in sys.modules:
            __import__(package)
        module = sys.modules[package]
        path = getattr(module, '__path__', None)
        if path is None:
            raise DistlibException('You cannot get a finder for a module, '
                                   'only for a package')
        loader = getattr(module, '__loader__', None)
        finder_maker = _finder_registry.get(type(loader))
        if finder_maker is None:
            raise DistlibException('Unable to locate finder for %r' % package)
        result = finder_maker(module)
        _finder_cache[package] = result
    return result


_dummy_module = types.ModuleType(str('__dummy__'))


def finder_for_path(path):
    """
    Return a resource finder for a path, which should represent a container.

    :param path: The path.
    :return: A :class:`ResourceFinder` instance for the path.
    """
    result = None
    # calls any path hooks, gets importer into cache
    pkgutil.get_importer(path)
    loader = sys.path_importer_cache.get(path)
    finder = _finder_registry.get(type(loader))
    if finder:
        module = _dummy_module
        module.__file__ = os.path.join(path, '')
        module.__loader__ = loader
        result = finder(module)
    return result

########NEW FILE########
__FILENAME__ = scripts
# -*- coding: utf-8 -*-
#
# Copyright (C) 2013 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
from io import BytesIO
import logging
import os
import re
import struct
import sys

from .compat import sysconfig, fsencode, detect_encoding, ZipFile
from .resources import finder
from .util import (FileOperator, get_export_entry, convert_path,
                   get_executable, in_venv)

logger = logging.getLogger(__name__)

_DEFAULT_MANIFEST = '''
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
 <assemblyIdentity version="1.0.0.0"
 processorArchitecture="X86"
 name="%s"
 type="win32"/>

 <!-- Identify the application security requirements. -->
 <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
 <security>
 <requestedPrivileges>
 <requestedExecutionLevel level="asInvoker" uiAccess="false"/>
 </requestedPrivileges>
 </security>
 </trustInfo>
</assembly>'''.strip()

# check if Python is called on the first line with this expression
FIRST_LINE_RE = re.compile(b'^#!.*pythonw?[0-9.]*([ \t].*)?$')
SCRIPT_TEMPLATE = '''# -*- coding: utf-8 -*-
if __name__ == '__main__':
    import sys, re

    def _resolve(module, func):
        __import__(module)
        mod = sys.modules[module]
        parts = func.split('.')
        result = getattr(mod, parts.pop(0))
        for p in parts:
            result = getattr(result, p)
        return result

    try:
        sys.argv[0] = re.sub(r'(-script\.pyw|\.exe)?$', '', sys.argv[0])

        func = _resolve('%(module)s', '%(func)s')
        rc = func() # None interpreted as 0
    except Exception as e:  # only supporting Python >= 2.6
        sys.stderr.write('%%s\\n' %% e)
        rc = 1
    sys.exit(rc)
'''


class ScriptMaker(object):
    """
    A class to copy or create scripts from source scripts or callable
    specifications.
    """
    script_template = SCRIPT_TEMPLATE

    executable = None  # for shebangs

    def __init__(self, source_dir, target_dir, add_launchers=True,
                 dry_run=False, fileop=None):
        self.source_dir = source_dir
        self.target_dir = target_dir
        self.add_launchers = add_launchers
        self.force = False
        self.clobber = False
        # It only makes sense to set mode bits on POSIX.
        self.set_mode = (os.name == 'posix')
        self.variants = set(('', 'X.Y'))
        self._fileop = fileop or FileOperator(dry_run)

    def _get_alternate_executable(self, executable, options):
        if options.get('gui', False) and os.name == 'nt':
            dn, fn = os.path.split(executable)
            fn = fn.replace('python', 'pythonw')
            executable = os.path.join(dn, fn)
        return executable

    def _get_shebang(self, encoding, post_interp=b'', options=None):
        enquote = True
        if self.executable:
            executable = self.executable
            enquote = False     # assume this will be taken care of
        elif not sysconfig.is_python_build():
            executable = get_executable()
        elif in_venv():
            executable = os.path.join(sysconfig.get_path('scripts'),
                            'python%s' % sysconfig.get_config_var('EXE'))
        else:
            executable = os.path.join(
                sysconfig.get_config_var('BINDIR'),
               'python%s%s' % (sysconfig.get_config_var('VERSION'),
                               sysconfig.get_config_var('EXE')))
        if options:
            executable = self._get_alternate_executable(executable, options)

        # If the user didn't specify an executable, it may be necessary to
        # cater for executable paths with spaces (not uncommon on Windows)
        if enquote and ' ' in executable:
            executable = '"%s"' % executable
        executable = fsencode(executable)
        shebang = b'#!' + executable + post_interp + b'\n'
        # Python parser starts to read a script using UTF-8 until
        # it gets a #coding:xxx cookie. The shebang has to be the
        # first line of a file, the #coding:xxx cookie cannot be
        # written before. So the shebang has to be decodable from
        # UTF-8.
        try:
            shebang.decode('utf-8')
        except UnicodeDecodeError:
            raise ValueError(
                'The shebang (%r) is not decodable from utf-8' % shebang)
        # If the script is encoded to a custom encoding (use a
        # #coding:xxx cookie), the shebang has to be decodable from
        # the script encoding too.
        if encoding != 'utf-8':
            try:
                shebang.decode(encoding)
            except UnicodeDecodeError:
                raise ValueError(
                    'The shebang (%r) is not decodable '
                    'from the script encoding (%r)' % (shebang, encoding))
        return shebang

    def _get_script_text(self, entry):
        return self.script_template % dict(module=entry.prefix,
                                           func=entry.suffix)

    manifest = _DEFAULT_MANIFEST

    def get_manifest(self, exename):
        base = os.path.basename(exename)
        return self.manifest % base

    def _write_script(self, names, shebang, script_bytes, filenames, ext):
        use_launcher = self.add_launchers and os.name == 'nt'
        linesep = os.linesep.encode('utf-8')
        if not use_launcher:
            script_bytes = shebang + linesep + script_bytes
        else:
            if ext == 'py':
                launcher = self._get_launcher('t')
            else:
                launcher = self._get_launcher('w')
            stream = BytesIO()
            with ZipFile(stream, 'w') as zf:
                zf.writestr('__main__.py', script_bytes)
            zip_data = stream.getvalue()
            script_bytes = launcher + shebang + linesep + zip_data
        for name in names:
            outname = os.path.join(self.target_dir, name)
            if use_launcher:
                n, e = os.path.splitext(outname)
                if e.startswith('.py'):
                    outname = n
                outname = '%s.exe' % outname
                try:
                    self._fileop.write_binary_file(outname, script_bytes)
                except Exception:
                    # Failed writing an executable - it might be in use.
                    logger.warning('Failed to write executable - trying to '
                                   'use .deleteme logic')
                    dfname = '%s.deleteme' % outname
                    if os.path.exists(dfname):
                        os.remove(dfname)       # Not allowed to fail here
                    os.rename(outname, dfname)  # nor here
                    self._fileop.write_binary_file(outname, script_bytes)
                    logger.debug('Able to replace executable using '
                                 '.deleteme logic')
                    try:
                        os.remove(dfname)
                    except Exception:
                        pass    # still in use - ignore error
            else:
                if os.name == 'nt' and not outname.endswith('.' + ext):
                    outname = '%s.%s' % (outname, ext)
                if os.path.exists(outname) and not self.clobber:
                    logger.warning('Skipping existing file %s', outname)
                    continue
                self._fileop.write_binary_file(outname, script_bytes)
                if self.set_mode:
                    self._fileop.set_executable_mode([outname])
            filenames.append(outname)

    def _make_script(self, entry, filenames, options=None):
        shebang = self._get_shebang('utf-8', options=options)
        script = self._get_script_text(entry).encode('utf-8')
        name = entry.name
        scriptnames = set()
        if '' in self.variants:
            scriptnames.add(name)
        if 'X' in self.variants:
            scriptnames.add('%s%s' % (name, sys.version[0]))
        if 'X.Y' in self.variants:
            scriptnames.add('%s-%s' % (name, sys.version[:3]))
        if options and options.get('gui', False):
            ext = 'pyw'
        else:
            ext = 'py'
        self._write_script(scriptnames, shebang, script, filenames, ext)

    def _copy_script(self, script, filenames):
        adjust = False
        script = os.path.join(self.source_dir, convert_path(script))
        outname = os.path.join(self.target_dir, os.path.basename(script))
        if not self.force and not self._fileop.newer(script, outname):
            logger.debug('not copying %s (up-to-date)', script)
            return

        # Always open the file, but ignore failures in dry-run mode --
        # that way, we'll get accurate feedback if we can read the
        # script.
        try:
            f = open(script, 'rb')
        except IOError:
            if not self.dry_run:
                raise
            f = None
        else:
            encoding, lines = detect_encoding(f.readline)
            f.seek(0)
            first_line = f.readline()
            if not first_line:
                logger.warning('%s: %s is an empty file (skipping)',
                               self.get_command_name(),  script)
                return

            match = FIRST_LINE_RE.match(first_line.replace(b'\r\n', b'\n'))
            if match:
                adjust = True
                post_interp = match.group(1) or b''

        if not adjust:
            if f:
                f.close()
            self._fileop.copy_file(script, outname)
            if self.set_mode:
                self._fileop.set_executable_mode([outname])
            filenames.append(outname)
        else:
            logger.info('copying and adjusting %s -> %s', script,
                        self.target_dir)
            if not self._fileop.dry_run:
                shebang = self._get_shebang(encoding, post_interp)
                if b'pythonw' in first_line:
                    ext = 'pyw'
                else:
                    ext = 'py'
                n = os.path.basename(outname)
                self._write_script([n], shebang, f.read(), filenames, ext)
            if f:
                f.close()

    @property
    def dry_run(self):
        return self._fileop.dry_run

    @dry_run.setter
    def dry_run(self, value):
        self._fileop.dry_run = value

    if os.name == 'nt':
        # Executable launcher support.
        # Launchers are from https://bitbucket.org/vinay.sajip/simple_launcher/

        def _get_launcher(self, kind):
            if struct.calcsize('P') == 8:   # 64-bit
                bits = '64'
            else:
                bits = '32'
            name = '%s%s.exe' % (kind, bits)
            # Issue 31: don't hardcode an absolute package name, but
            # determine it relative to the current package
            distlib_package = __name__.rsplit('.', 1)[0]
            result = finder(distlib_package).find(name).bytes
            return result

    # Public API follows

    def make(self, specification, options=None):
        """
        Make a script.

        :param specification: The specification, which is either a valid export
                              entry specification (to make a script from a
                              callable) or a filename (to make a script by
                              copying from a source location).
        :param options: A dictionary of options controlling script generation.
        :return: A list of all absolute pathnames written to.
        """
        filenames = []
        entry = get_export_entry(specification)
        if entry is None:
            self._copy_script(specification, filenames)
        else:
            self._make_script(entry, filenames, options=options)
        return filenames

    def make_multiple(self, specifications, options=None):
        """
        Take a list of specifications and make scripts from them,
        :param specifications: A list of specifications.
        :return: A list of all absolute pathnames written to,
        """
        filenames = []
        for specification in specifications:
            filenames.extend(self.make(specification, options))
        return filenames

########NEW FILE########
__FILENAME__ = util
#
# Copyright (C) 2012-2013 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
import codecs
from collections import deque
import contextlib
import csv
from glob import iglob as std_iglob
import io
import json
import logging
import os
import py_compile
import re
import shutil
import socket
import ssl
import subprocess
import sys
import tarfile
import tempfile
try:
    import threading
except ImportError:
    import dummy_threading as threading
import time

from . import DistlibException
from .compat import (string_types, text_type, shutil, raw_input, StringIO,
                     cache_from_source, urlopen, httplib, xmlrpclib, splittype,
                     HTTPHandler, HTTPSHandler as BaseHTTPSHandler,
                     BaseConfigurator, valid_ident, Container, configparser,
                     URLError, match_hostname, CertificateError, ZipFile)

logger = logging.getLogger(__name__)

#
# Requirement parsing code for name + optional constraints + optional extras
#
# e.g. 'foo >= 1.2, < 2.0 [bar, baz]'
#
# The regex can seem a bit hairy, so we build it up out of smaller pieces
# which are manageable.
#

COMMA = r'\s*,\s*'
COMMA_RE = re.compile(COMMA)

IDENT = r'(\w|[.-])+'
EXTRA_IDENT = r'(\*|:(\*|\w+):|' + IDENT + ')'
VERSPEC = IDENT + r'\*?'

RELOP = '([<>=!~]=)|[<>]'

#
# The first relop is optional - if absent, will be taken as '~='
#
BARE_CONSTRAINTS = ('(' + RELOP + r')?\s*(' + VERSPEC + ')(' + COMMA + '(' +
                    RELOP + r')\s*(' + VERSPEC + '))*')

DIRECT_REF = '(from\s+(?P<diref>.*))'

#
# Either the bare constraints or the bare constraints in parentheses
#
CONSTRAINTS = (r'\(\s*(?P<c1>' + BARE_CONSTRAINTS + '|' + DIRECT_REF +
               r')\s*\)|(?P<c2>' + BARE_CONSTRAINTS + '\s*)')

EXTRA_LIST = EXTRA_IDENT + '(' + COMMA + EXTRA_IDENT + ')*'
EXTRAS = r'\[\s*(?P<ex>' + EXTRA_LIST + r')?\s*\]'
REQUIREMENT = ('(?P<dn>'  + IDENT + r')\s*(' + EXTRAS + r'\s*)?(\s*' +
               CONSTRAINTS + ')?$')
REQUIREMENT_RE = re.compile(REQUIREMENT)

#
# Used to scan through the constraints
#
RELOP_IDENT = '(?P<op>' + RELOP + r')\s*(?P<vn>' + VERSPEC + ')'
RELOP_IDENT_RE = re.compile(RELOP_IDENT)

def parse_requirement(s):

    def get_constraint(m):
        d = m.groupdict()
        return d['op'], d['vn']

    result = None
    m = REQUIREMENT_RE.match(s)
    if m:
        d = m.groupdict()
        name = d['dn']
        cons = d['c1'] or d['c2']
        if not d['diref']:
            url = None
        else:
            # direct reference
            cons = None
            url = d['diref'].strip()
        if not cons:
            cons = None
            constr = ''
            rs = d['dn']
        else:
            if cons[0] not in '<>!=':
                cons = '~=' + cons
            iterator = RELOP_IDENT_RE.finditer(cons)
            cons = [get_constraint(m) for m in iterator]
            rs = '%s (%s)' % (name, ', '.join(['%s %s' % con for con in cons]))
        if not d['ex']:
            extras = None
        else:
            extras = COMMA_RE.split(d['ex'])
        result = Container(name=name, constraints=cons, extras=extras,
                           requirement=rs, source=s, url=url)
    return result


def get_resources_dests(resources_root, rules):
    """Find destinations for resources files"""

    def get_rel_path(base, path):
        # normalizes and returns a lstripped-/-separated path
        base = base.replace(os.path.sep, '/')
        path = path.replace(os.path.sep, '/')
        assert path.startswith(base)
        return path[len(base):].lstrip('/')


    destinations = {}
    for base, suffix, dest in rules:
        prefix = os.path.join(resources_root, base)
        for abs_base in iglob(prefix):
            abs_glob = os.path.join(abs_base, suffix)
            for abs_path in iglob(abs_glob):
                resource_file = get_rel_path(resources_root, abs_path)
                if dest is None:  # remove the entry if it was here
                    destinations.pop(resource_file, None)
                else:
                    rel_path = get_rel_path(abs_base, abs_path)
                    rel_dest = dest.replace(os.path.sep, '/').rstrip('/')
                    destinations[resource_file] = rel_dest + '/' + rel_path
    return destinations


def in_venv():
    if hasattr(sys, 'real_prefix'):
        # virtualenv venvs
        result = True
    else:
        # PEP 405 venvs
        result = sys.prefix != getattr(sys, 'base_prefix', sys.prefix)
    return result


def get_executable():
    if sys.platform == 'darwin' and ('__PYVENV_LAUNCHER__'
                                     in os.environ):
        result =  os.environ['__PYVENV_LAUNCHER__']
    else:
        result = sys.executable
    return result


def proceed(prompt, allowed_chars, error_prompt=None, default=None):
    p = prompt
    while True:
        s = raw_input(p)
        p = prompt
        if not s and default:
            s = default
        if s:
            c = s[0].lower()
            if c in allowed_chars:
                break
            if error_prompt:
                p = '%c: %s\n%s' % (c, error_prompt, prompt)
    return c


def extract_by_key(d, keys):
    if isinstance(keys, string_types):
        keys = keys.split()
    result = {}
    for key in keys:
        if key in d:
            result[key] = d[key]
    return result

def read_exports(stream):
    if sys.version_info[0] >= 3:
        # needs to be a text stream
        stream = codecs.getreader('utf-8')(stream)
    # Try to load as JSON, falling back on legacy format
    data = stream.read()
    stream = StringIO(data)
    try:
        data = json.load(stream)
        result = data['exports']
        for group, entries in result.items():
            for k, v in entries.items():
                s = '%s = %s' % (k, v)
                entry = get_export_entry(s)
                assert entry is not None
                entries[k] = entry
        return result
    except Exception:
        stream.seek(0, 0)
    cp = configparser.ConfigParser()
    if hasattr(cp, 'read_file'):
        cp.read_file(stream)
    else:
        cp.readfp(stream)
    result = {}
    for key in cp.sections():
        result[key] = entries = {}
        for name, value in cp.items(key):
            s = '%s = %s' % (name, value)
            entry = get_export_entry(s)
            assert entry is not None
            #entry.dist = self
            entries[name] = entry
    return result


def write_exports(exports, stream):
    if sys.version_info[0] >= 3:
        # needs to be a text stream
        stream = codecs.getwriter('utf-8')(stream)
    cp = configparser.ConfigParser()
    for k, v in exports.items():
        # TODO check k, v for valid values
        cp.add_section(k)
        for entry in v.values():
            if entry.suffix is None:
                s = entry.prefix
            else:
                s = '%s:%s' % (entry.prefix, entry.suffix)
            if entry.flags:
                s = '%s [%s]' % (s, ', '.join(entry.flags))
            cp.set(k, entry.name, s)
    cp.write(stream)


@contextlib.contextmanager
def tempdir():
    td = tempfile.mkdtemp()
    try:
        yield td
    finally:
        shutil.rmtree(td)

@contextlib.contextmanager
def chdir(d):
    cwd = os.getcwd()
    try:
        os.chdir(d)
        yield
    finally:
        os.chdir(cwd)


@contextlib.contextmanager
def socket_timeout(seconds=15):
    cto = socket.getdefaulttimeout()
    try:
        socket.setdefaulttimeout(seconds)
        yield
    finally:
        socket.setdefaulttimeout(cto)


class cached_property(object):
    def __init__(self, func):
        self.func = func
        #for attr in ('__name__', '__module__', '__doc__'):
        #    setattr(self, attr, getattr(func, attr, None))

    def __get__(self, obj, cls=None):
        if obj is None:
            return self
        value = self.func(obj)
        object.__setattr__(obj, self.func.__name__, value)
        #obj.__dict__[self.func.__name__] = value = self.func(obj)
        return value

def convert_path(pathname):
    """Return 'pathname' as a name that will work on the native filesystem.

    The path is split on '/' and put back together again using the current
    directory separator.  Needed because filenames in the setup script are
    always supplied in Unix style, and have to be converted to the local
    convention before we can actually use them in the filesystem.  Raises
    ValueError on non-Unix-ish systems if 'pathname' either starts or
    ends with a slash.
    """
    if os.sep == '/':
        return pathname
    if not pathname:
        return pathname
    if pathname[0] == '/':
        raise ValueError("path '%s' cannot be absolute" % pathname)
    if pathname[-1] == '/':
        raise ValueError("path '%s' cannot end with '/'" % pathname)

    paths = pathname.split('/')
    while os.curdir in paths:
        paths.remove(os.curdir)
    if not paths:
        return os.curdir
    return os.path.join(*paths)


class FileOperator(object):
    def __init__(self, dry_run=False):
        self.dry_run = dry_run
        self.ensured = set()
        self._init_record()

    def _init_record(self):
        self.record = False
        self.files_written = set()
        self.dirs_created = set()

    def record_as_written(self, path):
        if self.record:
            self.files_written.add(path)

    def newer(self, source, target):
        """Tell if the target is newer than the source.

        Returns true if 'source' exists and is more recently modified than
        'target', or if 'source' exists and 'target' doesn't.

        Returns false if both exist and 'target' is the same age or younger
        than 'source'. Raise PackagingFileError if 'source' does not exist.

        Note that this test is not very accurate: files created in the same
        second will have the same "age".
        """
        if not os.path.exists(source):
            raise DistlibException("file '%r' does not exist" %
                                   os.path.abspath(source))
        if not os.path.exists(target):
            return True

        return os.stat(source).st_mtime > os.stat(target).st_mtime

    def copy_file(self, infile, outfile, check=True):
        """Copy a file respecting dry-run and force flags.
        """
        self.ensure_dir(os.path.dirname(outfile))
        logger.info('Copying %s to %s', infile, outfile)
        if not self.dry_run:
            msg = None
            if check:
                if os.path.islink(outfile):
                    msg = '%s is a symlink' % outfile
                elif os.path.exists(outfile) and not os.path.isfile(outfile):
                    msg = '%s is a non-regular file' % outfile
            if msg:
                raise ValueError(msg + ' which would be overwritten')
            shutil.copyfile(infile, outfile)
        self.record_as_written(outfile)

    def copy_stream(self, instream, outfile, encoding=None):
        assert not os.path.isdir(outfile)
        self.ensure_dir(os.path.dirname(outfile))
        logger.info('Copying stream %s to %s', instream, outfile)
        if not self.dry_run:
            if encoding is None:
                outstream = open(outfile, 'wb')
            else:
                outstream = codecs.open(outfile, 'w', encoding=encoding)
            try:
                shutil.copyfileobj(instream, outstream)
            finally:
                outstream.close()
        self.record_as_written(outfile)

    def write_binary_file(self, path, data):
        self.ensure_dir(os.path.dirname(path))
        if not self.dry_run:
            with open(path, 'wb') as f:
                f.write(data)
        self.record_as_written(path)

    def write_text_file(self, path, data, encoding):
        self.ensure_dir(os.path.dirname(path))
        if not self.dry_run:
            with open(path, 'wb') as f:
                f.write(data.encode(encoding))
        self.record_as_written(path)

    def set_mode(self, bits, mask, files):
        if os.name == 'posix':
            # Set the executable bits (owner, group, and world) on
            # all the files specified.
            for f in files:
                if self.dry_run:
                    logger.info("changing mode of %s", f)
                else:
                    mode = (os.stat(f).st_mode | bits) & mask
                    logger.info("changing mode of %s to %o", f, mode)
                    os.chmod(f, mode)

    set_executable_mode = lambda s, f: s.set_mode(0o555, 0o7777, f)

    def ensure_dir(self, path):
        path = os.path.abspath(path)
        if path not in self.ensured and not os.path.exists(path):
            self.ensured.add(path)
            d, f = os.path.split(path)
            self.ensure_dir(d)
            logger.info('Creating %s' % path)
            if not self.dry_run:
                os.mkdir(path)
            if self.record:
                self.dirs_created.add(path)

    def byte_compile(self, path, optimize=False, force=False, prefix=None):
        dpath = cache_from_source(path, not optimize)
        logger.info('Byte-compiling %s to %s', path, dpath)
        if not self.dry_run:
            if force or self.newer(path, dpath):
                if not prefix:
                    diagpath = None
                else:
                    assert path.startswith(prefix)
                    diagpath = path[len(prefix):]
            py_compile.compile(path, dpath, diagpath, True)     # raise error
        self.record_as_written(dpath)
        return dpath

    def ensure_removed(self, path):
        if os.path.exists(path):
            if os.path.isdir(path) and not os.path.islink(path):
                logger.debug('Removing directory tree at %s', path)
                if not self.dry_run:
                    shutil.rmtree(path)
                if self.record:
                    if path in self.dirs_created:
                        self.dirs_created.remove(path)
            else:
                if os.path.islink(path):
                    s = 'link'
                else:
                    s = 'file'
                logger.debug('Removing %s %s', s, path)
                if not self.dry_run:
                    os.remove(path)
                if self.record:
                    if path in self.files_written:
                        self.files_written.remove(path)

    def is_writable(self, path):
        result = False
        while not result:
            if os.path.exists(path):
                result = os.access(path, os.W_OK)
                break
            parent = os.path.dirname(path)
            if parent == path:
                break
            path = parent
        return result

    def commit(self):
        """
        Commit recorded changes, turn off recording, return
        changes.
        """
        assert self.record
        result = self.files_written, self.dirs_created
        self._init_record()
        return result

    def rollback(self):
        if not self.dry_run:
            for f in list(self.files_written):
                if os.path.exists(f):
                    os.remove(f)
            # dirs should all be empty now, except perhaps for
            # __pycache__ subdirs
            # reverse so that subdirs appear before their parents
            dirs = sorted(self.dirs_created, reverse=True)
            for d in dirs:
                flist = os.listdir(d)
                if flist:
                    assert flist == ['__pycache__']
                    sd = os.path.join(d, flist[0])
                    os.rmdir(sd)
                os.rmdir(d)     # should fail if non-empty
        self._init_record()

def resolve(module_name, dotted_path):
    if module_name in sys.modules:
        mod = sys.modules[module_name]
    else:
        mod = __import__(module_name)
    if dotted_path is None:
        result = mod
    else:
        parts = dotted_path.split('.')
        result = getattr(mod, parts.pop(0))
        for p in parts:
            result = getattr(result, p)
    return result


class ExportEntry(object):
    def __init__(self, name, prefix, suffix, flags):
        self.name = name
        self.prefix = prefix
        self.suffix = suffix
        self.flags = flags

    @cached_property
    def value(self):
        return resolve(self.prefix, self.suffix)

    def __repr__(self):
        return '<ExportEntry %s = %s:%s %s>' % (self.name, self.prefix,
                                                self.suffix, self.flags)

    def __eq__(self, other):
        if not isinstance(other, ExportEntry):
            result = False
        else:
            result = (self.name == other.name and
                      self.prefix == other.prefix and
                      self.suffix == other.suffix and
                      self.flags == other.flags)
        return result

    __hash__ = object.__hash__


ENTRY_RE = re.compile(r'''(?P<name>(\w|[-.])+)
                      \s*=\s*(?P<callable>(\w+)([:\.]\w+)*)
                      \s*(\[\s*(?P<flags>\w+(=\w+)?(,\s*\w+(=\w+)?)*)\s*\])?
                      ''', re.VERBOSE)


def get_export_entry(specification):
    m = ENTRY_RE.search(specification)
    if not m:
        result = None
        if '[' in specification or ']' in specification:
            raise DistlibException('Invalid specification '
                                   '%r' % specification)
    else:
        d = m.groupdict()
        name = d['name']
        path = d['callable']
        colons = path.count(':')
        if colons == 0:
            prefix, suffix = path, None
        else:
            if colons != 1:
                raise DistlibException('Invalid specification '
                                       '%r' % specification)
            prefix, suffix = path.split(':')
        flags = d['flags']
        if flags is None:
            if '[' in specification or ']' in specification:
                raise DistlibException('Invalid specification '
                                       '%r' % specification)
            flags = []
        else:
            flags = [f.strip() for f in flags.split(',')]
        result = ExportEntry(name, prefix, suffix, flags)
    return result


def get_cache_base(suffix=None):
    """
    Return the default base location for distlib caches. If the directory does
    not exist, it is created. Use the suffix provided for the base directory,
    and default to '.distlib' if it isn't provided.

    On Windows, if LOCALAPPDATA is defined in the environment, then it is
    assumed to be a directory, and will be the parent directory of the result.
    On POSIX, and on Windows if LOCALAPPDATA is not defined, the user's home
    directory - using os.expanduser('~') - will be the parent directory of
    the result.

    The result is just the directory '.distlib' in the parent directory as
    determined above, or with the name specified with ``suffix``.
    """
    if suffix is None:
        suffix = '.distlib'
    if os.name == 'nt' and 'LOCALAPPDATA' in os.environ:
        result = os.path.expandvars('$localappdata')
    else:
        # Assume posix, or old Windows
        result = os.path.expanduser('~')
    # we use 'isdir' instead of 'exists', because we want to
    # fail if there's a file with that name
    if os.path.isdir(result):
        usable = os.access(result, os.W_OK)
        if not usable:
            logger.warning('Directory exists but is not writable: %s', result)
    else:
        try:
            os.makedirs(result)
            usable = True
        except OSError:
            logger.warning('Unable to create %s', result, exc_info=True)
            usable = False
    if not usable:
        result = tempfile.mkdtemp()
        logger.warning('Default location unusable, using %s', result)
    return os.path.join(result, suffix)


def path_to_cache_dir(path):
    """
    Convert an absolute path to a directory name for use in a cache.

    The algorithm used is:

    #. On Windows, any ``':'`` in the drive is replaced with ``'---'``.
    #. Any occurrence of ``os.sep`` is replaced with ``'--'``.
    #. ``'.cache'`` is appended.
    """
    d, p = os.path.splitdrive(os.path.abspath(path))
    if d:
        d = d.replace(':', '---')
    p = p.replace(os.sep, '--')
    return d + p + '.cache'


def ensure_slash(s):
    if not s.endswith('/'):
        return s + '/'
    return s


def parse_credentials(netloc):
    username = password = None
    if '@' in netloc:
        prefix, netloc = netloc.split('@', 1)
        if ':' not in prefix:
            username = prefix
        else:
            username, password = prefix.split(':', 1)
    return username, password, netloc


def get_process_umask():
    result = os.umask(0o22)
    os.umask(result)
    return result

def is_string_sequence(seq):
    result = True
    i = None
    for i, s in enumerate(seq):
        if not isinstance(s, string_types):
            result = False
            break
    assert i is not None
    return result

PROJECT_NAME_AND_VERSION = re.compile('([a-z0-9_]+([.-][a-z_][a-z0-9_]*)*)-'
                                      '([a-z0-9_.+-]+)', re.I)
PYTHON_VERSION = re.compile(r'-py(\d\.?\d?)')


def split_filename(filename, project_name=None):
    """
    Extract name, version, python version from a filename (no extension)

    Return name, version, pyver or None
    """
    result = None
    pyver = None
    m = PYTHON_VERSION.search(filename)
    if m:
        pyver = m.group(1)
        filename = filename[:m.start()]
    if project_name and len(filename) > len(project_name) + 1:
        m = re.match(re.escape(project_name) + r'\b', filename)
        if m:
            n = m.end()
            result = filename[:n], filename[n + 1:], pyver
    if result is None:
        m = PROJECT_NAME_AND_VERSION.match(filename)
        if m:
            result = m.group(1), m.group(3), pyver
    return result

# Allow spaces in name because of legacy dists like "Twisted Core"
NAME_VERSION_RE = re.compile(r'(?P<name>[\w .-]+)\s*'
                             r'\(\s*(?P<ver>[^\s)]+)\)$')

def parse_name_and_version(p):
    """
    A utility method used to get name and version from a string.

    From e.g. a Provides-Dist value.

    :param p: A value in a form 'foo (1.0)'
    :return: The name and version as a tuple.
    """
    m = NAME_VERSION_RE.match(p)
    if not m:
        raise DistlibException('Ill-formed name/version string: \'%s\'' % p)
    d = m.groupdict()
    return d['name'].strip().lower(), d['ver']

def get_extras(requested, available):
    result = set()
    requested = set(requested or [])
    available = set(available or [])
    if '*' in requested:
        requested.remove('*')
        result |= available
    for r in requested:
        if r == '-':
            result.add(r)
        elif r.startswith('-'):
            unwanted = r[1:]
            if unwanted not in available:
                logger.warning('undeclared extra: %s' % unwanted)
            if unwanted in result:
                result.remove(unwanted)
        else:
            if r not in available:
                logger.warning('undeclared extra: %s' % r)
            result.add(r)
    return result
#
# Extended metadata functionality
#

def _get_external_data(url):
    result = {}
    try:
        # urlopen might fail if it runs into redirections,
        # because of Python issue #13696. Fixed in locators
        # using a custom redirect handler.
        resp = urlopen(url)
        headers = resp.info()
        if headers.get('Content-Type') != 'application/json':
            logger.debug('Unexpected response for JSON request')
        else:
            reader = codecs.getreader('utf-8')(resp)
            #data = reader.read().decode('utf-8')
            #result = json.loads(data)
            result = json.load(reader)
    except Exception as e:
        logger.exception('Failed to get external data for %s: %s', url, e)
    return result


def get_project_data(name):
    url = ('https://www.red-dove.com/pypi/projects/'
           '%s/%s/project.json' % (name[0].upper(), name))
    result = _get_external_data(url)
    return result

def get_package_data(name, version):
    url = ('https://www.red-dove.com/pypi/projects/'
           '%s/%s/package-%s.json' % (name[0].upper(), name, version))
    return _get_external_data(url)


class Cache(object):
    """
    A class implementing a cache for resources that need to live in the file system
    e.g. shared libraries. This class was moved from resources to here because it
    could be used by other modules, e.g. the wheel module.
    """

    def __init__(self, base):
        """
        Initialise an instance.

        :param base: The base directory where the cache should be located.
        """
        # we use 'isdir' instead of 'exists', because we want to
        # fail if there's a file with that name
        if not os.path.isdir(base):
            os.makedirs(base)
        if (os.stat(base).st_mode & 0o77) != 0:
            logger.warning('Directory \'%s\' is not private', base)
        self.base = os.path.abspath(os.path.normpath(base))

    def prefix_to_dir(self, prefix):
        """
        Converts a resource prefix to a directory name in the cache.
        """
        return path_to_cache_dir(prefix)

    def clear(self):
        """
        Clear the cache.
        """
        not_removed = []
        for fn in os.listdir(self.base):
            fn = os.path.join(self.base, fn)
            try:
                if os.path.islink(fn) or os.path.isfile(fn):
                    os.remove(fn)
                elif os.path.isdir(fn):
                    shutil.rmtree(fn)
            except Exception:
                not_removed.append(fn)
        return not_removed


class EventMixin(object):
    """
    A very simple publish/subscribe system.
    """
    def __init__(self):
        self._subscribers = {}

    def add(self, event, subscriber, append=True):
        """
        Add a subscriber for an event.

        :param event: The name of an event.
        :param subscriber: The subscriber to be added (and called when the
                           event is published).
        :param append: Whether to append or prepend the subscriber to an
                       existing subscriber list for the event.
        """
        subs = self._subscribers
        if event not in subs:
            subs[event] = deque([subscriber])
        else:
            sq = subs[event]
            if append:
                sq.append(subscriber)
            else:
                sq.appendleft(subscriber)

    def remove(self, event, subscriber):
        """
        Remove a subscriber for an event.

        :param event: The name of an event.
        :param subscriber: The subscriber to be removed.
        """
        subs = self._subscribers
        if event not in subs:
            raise ValueError('No subscribers: %r' % event)
        subs[event].remove(subscriber)

    def get_subscribers(self, event):
        """
        Return an iterator for the subscribers for an event.
        :param event: The event to return subscribers for.
        """
        return iter(self._subscribers.get(event, ()))

    def publish(self, event, *args, **kwargs):
        """
        Publish a event and return a list of values returned by its
        subscribers.

        :param event: The event to publish.
        :param args: The positional arguments to pass to the event's
                     subscribers.
        :param kwargs: The keyword arguments to pass to the event's
                       subscribers.
        """
        result = []
        for subscriber in self.get_subscribers(event):
            try:
                value = subscriber(event, *args, **kwargs)
            except Exception:
                logger.exception('Exception during event publication')
                value = None
            result.append(value)
        logger.debug('publish %s: args = %s, kwargs = %s, result = %s',
                     event, args, kwargs, result)
        return result

#
# Simple sequencing
#
class Sequencer(object):
    def __init__(self):
        self._preds = {}
        self._succs = {}
        self._nodes = set()     # nodes with no preds/succs

    def add_node(self, node):
        self._nodes.add(node)

    def remove_node(self, node, edges=False):
        if node in self._nodes:
            self._nodes.remove(node)
        if edges:
            for p in set(self._preds.get(node, ())):
                self.remove(p, node)
            for s in set(self._succs.get(node, ())):
                self.remove(node, s)
            # Remove empties
            for k, v in list(self._preds.items()):
                if not v:
                    del self._preds[k]
            for k, v in list(self._succs.items()):
                if not v:
                    del self._succs[k]

    def add(self, pred, succ):
        assert pred != succ
        self._preds.setdefault(succ, set()).add(pred)
        self._succs.setdefault(pred, set()).add(succ)

    def remove(self, pred, succ):
        assert pred != succ
        try:
            preds = self._preds[succ]
            succs = self._succs[pred]
        except KeyError:
            raise ValueError('%r not a successor of anything' % succ)
        try:
            preds.remove(pred)
            succs.remove(succ)
        except KeyError:
            raise ValueError('%r not a successor of %r' % (succ, pred))

    def is_step(self, step):
        return (step in self._preds or step in self._succs or
                step in self._nodes)

    def get_steps(self, final):
        if not self.is_step(final):
            raise ValueError('Unknown: %r' % final)
        result = []
        todo = []
        seen = set()
        todo.append(final)
        while todo:
            step = todo.pop(0)
            if step in seen:
                # if a step was already seen,
                # move it to the end (so it will appear earlier
                # when reversed on return) ... but not for the
                # final step, as that would be confusing for
                # users
                if step != final:
                    result.remove(step)
                    result.append(step)
            else:
                seen.add(step)
                result.append(step)
                preds = self._preds.get(step, ())
                todo.extend(preds)
        return reversed(result)

    @property
    def strong_connections(self):
        #http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm
        index_counter = [0]
        stack = []
        lowlinks = {}
        index = {}
        result = []

        graph = self._succs

        def strongconnect(node):
            # set the depth index for this node to the smallest unused index
            index[node] = index_counter[0]
            lowlinks[node] = index_counter[0]
            index_counter[0] += 1
            stack.append(node)

            # Consider successors
            try:
                successors = graph[node]
            except Exception:
                successors = []
            for successor in successors:
                if successor not in lowlinks:
                    # Successor has not yet been visited
                    strongconnect(successor)
                    lowlinks[node] = min(lowlinks[node],lowlinks[successor])
                elif successor in stack:
                    # the successor is in the stack and hence in the current
                    # strongly connected component (SCC)
                    lowlinks[node] = min(lowlinks[node],index[successor])

            # If `node` is a root node, pop the stack and generate an SCC
            if lowlinks[node] == index[node]:
                connected_component = []

                while True:
                    successor = stack.pop()
                    connected_component.append(successor)
                    if successor == node: break
                component = tuple(connected_component)
                # storing the result
                result.append(component)

        for node in graph:
            if node not in lowlinks:
                strongconnect(node)

        return result

    @property
    def dot(self):
        result = ['digraph G {']
        for succ in self._preds:
            preds = self._preds[succ]
            for pred in preds:
                result.append('  %s -> %s;' % (pred, succ))
        for node in self._nodes:
            result.append('  %s;' % node)
        result.append('}')
        return '\n'.join(result)

#
# Unarchiving functionality for zip, tar, tgz, tbz, whl
#

ARCHIVE_EXTENSIONS = ('.tar.gz', '.tar.bz2', '.tar', '.zip',
                      '.tgz', '.tbz', '.whl')

def unarchive(archive_filename, dest_dir, format=None, check=True):

    def check_path(path):
        if not isinstance(path, text_type):
            path = path.decode('utf-8')
        p = os.path.abspath(os.path.join(dest_dir, path))
        if not p.startswith(dest_dir) or p[plen] != os.sep:
            raise ValueError('path outside destination: %r' % p)

    dest_dir = os.path.abspath(dest_dir)
    plen = len(dest_dir)
    archive = None
    if format is None:
        if archive_filename.endswith(('.zip', '.whl')):
            format = 'zip'
        elif archive_filename.endswith(('.tar.gz', '.tgz')):
            format = 'tgz'
            mode = 'r:gz'
        elif archive_filename.endswith(('.tar.bz2', '.tbz')):
            format = 'tbz'
            mode = 'r:bz2'
        elif archive_filename.endswith('.tar'):
            format = 'tar'
            mode = 'r'
        else:
            raise ValueError('Unknown format for %r' % archive_filename)
    try:
        if format == 'zip':
            archive = ZipFile(archive_filename, 'r')
            if check:
                names = archive.namelist()
                for name in names:
                    check_path(name)
        else:
            archive = tarfile.open(archive_filename, mode)
            if check:
                names = archive.getnames()
                for name in names:
                    check_path(name)
        if format != 'zip' and sys.version_info[0] < 3:
            # See Python issue 17153. If the dest path contains Unicode,
            # tarfile extraction fails on Python 2.x if a member path name
            # contains non-ASCII characters - it leads to an implicit
            # bytes -> unicode conversion using ASCII to decode.
            for tarinfo in archive.getmembers():
                if not isinstance(tarinfo.name, text_type):
                    tarinfo.name = tarinfo.name.decode('utf-8')
        archive.extractall(dest_dir)

    finally:
        if archive:
            archive.close()


def zip_dir(directory):
    """zip a directory tree into a BytesIO object"""
    result = io.BytesIO()
    dlen = len(directory)
    with ZipFile(result, "w") as zf:
        for root, dirs, files in os.walk(directory):
            for name in files:
                full = os.path.join(root, name)
                rel = root[dlen:]
                dest = os.path.join(rel, name)
                zf.write(full, dest)
    return result

#
# Simple progress bar
#

UNITS = ('', 'K', 'M', 'G','T','P')


class Progress(object):
    unknown = 'UNKNOWN'

    def __init__(self, minval=0, maxval=100):
        assert maxval is None or maxval >= minval
        self.min = self.cur = minval
        self.max = maxval
        self.started = None
        self.elapsed = 0
        self.done = False

    def update(self, curval):
        assert self.min <= curval
        assert self.max is None or curval <= self.max
        self.cur = curval
        now = time.time()
        if self.started is None:
            self.started = now
        else:
            self.elapsed = now - self.started

    def increment(self, incr):
        assert incr >= 0
        self.update(self.cur + incr)

    def start(self):
        self.update(self.min)
        return self

    def stop(self):
        if self.max is not None:
            self.update(self.max)
        self.done = True

    @property
    def maximum(self):
        return self.unknown if self.max is None else self.max

    @property
    def percentage(self):
        if self.done:
            result = '100 %'
        elif self.max is None:
            result = ' ?? %'
        else:
            v = 100.0 * (self.cur - self.min) / (self.max - self.min)
            result = '%3d %%' % v
        return result

    def format_duration(self, duration):
        if (duration <= 0) and self.max is None or self.cur == self.min:
            result = '??:??:??'
        #elif duration < 1:
        #    result = '--:--:--'
        else:
            result = time.strftime('%H:%M:%S', time.gmtime(duration))
        return result

    @property
    def ETA(self):
        if self.done:
            prefix = 'Done'
            t = self.elapsed
            #import pdb; pdb.set_trace()
        else:
            prefix = 'ETA '
            if self.max is None:
                t = -1
            elif self.elapsed == 0 or (self.cur == self.min):
                t = 0
            else:
                #import pdb; pdb.set_trace()
                t = float(self.max - self.min)
                t /= self.cur - self.min
                t = (t - 1) * self.elapsed
        return '%s: %s' % (prefix, self.format_duration(t))

    @property
    def speed(self):
        if self.elapsed == 0:
            result = 0.0
        else:
            result = (self.cur - self.min) / self.elapsed
        for unit in UNITS:
            if result < 1000:
                break
            result /= 1000.0
        return '%d %sB/s' % (result, unit)

#
# Glob functionality
#

RICH_GLOB = re.compile(r'\{([^}]*)\}')
_CHECK_RECURSIVE_GLOB = re.compile(r'[^/\\,{]\*\*|\*\*[^/\\,}]')
_CHECK_MISMATCH_SET = re.compile(r'^[^{]*\}|\{[^}]*$')


def iglob(path_glob):
    """Extended globbing function that supports ** and {opt1,opt2,opt3}."""
    if _CHECK_RECURSIVE_GLOB.search(path_glob):
        msg = """invalid glob %r: recursive glob "**" must be used alone"""
        raise ValueError(msg % path_glob)
    if _CHECK_MISMATCH_SET.search(path_glob):
        msg = """invalid glob %r: mismatching set marker '{' or '}'"""
        raise ValueError(msg % path_glob)
    return _iglob(path_glob)


def _iglob(path_glob):
    rich_path_glob = RICH_GLOB.split(path_glob, 1)
    if len(rich_path_glob) > 1:
        assert len(rich_path_glob) == 3, rich_path_glob
        prefix, set, suffix = rich_path_glob
        for item in set.split(','):
            for path in _iglob(''.join((prefix, item, suffix))):
                yield path
    else:
        if '**' not in path_glob:
            for item in std_iglob(path_glob):
                yield item
        else:
            prefix, radical = path_glob.split('**', 1)
            if prefix == '':
                prefix = '.'
            if radical == '':
                radical = '*'
            else:
                # we support both
                radical = radical.lstrip('/')
                radical = radical.lstrip('\\')
            for path, dir, files in os.walk(prefix):
                path = os.path.normpath(path)
                for fn in _iglob(os.path.join(path, radical)):
                    yield fn



#
# HTTPSConnection which verifies certificates/matches domains
#

class HTTPSConnection(httplib.HTTPSConnection):
    ca_certs = None # set this to the path to the certs file (.pem)
    check_domain = True # only used if ca_certs is not None

    # noinspection PyPropertyAccess
    def connect(self):
        sock = socket.create_connection((self.host, self.port), self.timeout)
        if getattr(self, '_tunnel_host', False):
            self.sock = sock
            self._tunnel()

        if not hasattr(ssl, 'SSLContext'):
            # For 2.x
            if self.ca_certs:
                cert_reqs = ssl.CERT_REQUIRED
            else:
                cert_reqs = ssl.CERT_NONE
            self.sock = ssl.wrap_socket(sock, self.key_file, self.cert_file,
                                        cert_reqs=cert_reqs,
                                        ssl_version=ssl.PROTOCOL_SSLv23,
                                        ca_certs=self.ca_certs)
        else:
            context = ssl.SSLContext(ssl.PROTOCOL_SSLv23)
            context.options |= ssl.OP_NO_SSLv2
            if self.cert_file:
                context.load_cert_chain(self.cert_file, self.key_file)
            kwargs = {}
            if self.ca_certs:
                context.verify_mode = ssl.CERT_REQUIRED
                context.load_verify_locations(cafile=self.ca_certs)
                if getattr(ssl, 'HAS_SNI', False):
                    kwargs['server_hostname'] = self.host
            self.sock = context.wrap_socket(sock, **kwargs)
        if self.ca_certs and self.check_domain:
            try:
                match_hostname(self.sock.getpeercert(), self.host)
                logger.debug('Host verified: %s', self.host)
            except CertificateError:
                self.sock.shutdown(socket.SHUT_RDWR)
                self.sock.close()
                raise

class HTTPSHandler(BaseHTTPSHandler):
    def __init__(self, ca_certs, check_domain=True):
        BaseHTTPSHandler.__init__(self)
        self.ca_certs = ca_certs
        self.check_domain = check_domain

    def _conn_maker(self, *args, **kwargs):
        """
        This is called to create a connection instance. Normally you'd
        pass a connection class to do_open, but it doesn't actually check for
        a class, and just expects a callable. As long as we behave just as a
        constructor would have, we should be OK. If it ever changes so that
        we *must* pass a class, we'll create an UnsafeHTTPSConnection class
        which just sets check_domain to False in the class definition, and
        choose which one to pass to do_open.
        """
        result = HTTPSConnection(*args, **kwargs)
        if self.ca_certs:
            result.ca_certs = self.ca_certs
            result.check_domain = self.check_domain
        return result

    def https_open(self, req):
        try:
            return self.do_open(self._conn_maker, req)
        except URLError as e:
            if 'certificate verify failed' in str(e.reason):
                raise CertificateError('Unable to verify server certificate '
                                       'for %s' % req.host)
            else:
                raise

#
# To prevent against mixing HTTP traffic with HTTPS (examples: A Man-In-The-
# Middle proxy using HTTP listens on port 443, or an index mistakenly serves
# HTML containing a http://xyz link when it should be https://xyz),
# you can use the following handler class, which does not allow HTTP traffic.
#
# It works by inheriting from HTTPHandler - so build_opener won't add a
# handler for HTTP itself.
#
class HTTPSOnlyHandler(HTTPSHandler, HTTPHandler):
    def http_open(self, req):
        raise URLError('Unexpected HTTP request on what should be a secure '
                       'connection: %s' % req)

#
# XML-RPC with timeouts
#

_ver_info = sys.version_info[:2]

if _ver_info == (2, 6):
    class HTTP(httplib.HTTP):
        def __init__(self, host='', port=None, **kwargs):
            if port == 0:   # 0 means use port 0, not the default port
                port = None
            self._setup(self._connection_class(host, port, **kwargs))


    class HTTPS(httplib.HTTPS):
        def __init__(self, host='', port=None, **kwargs):
            if port == 0:   # 0 means use port 0, not the default port
                port = None
            self._setup(self._connection_class(host, port, **kwargs))


class Transport(xmlrpclib.Transport):
    def __init__(self, timeout, use_datetime=0):
        self.timeout = timeout
        xmlrpclib.Transport.__init__(self, use_datetime)

    def make_connection(self, host):
        h, eh, x509 = self.get_host_info(host)
        if _ver_info == (2, 6):
            result = HTTP(h, timeout=self.timeout)
        else:
            if not self._connection or host != self._connection[0]:
                self._extra_headers = eh
                self._connection = host, httplib.HTTPConnection(h)
            result = self._connection[1]
        return result

class SafeTransport(xmlrpclib.SafeTransport):
    def __init__(self, timeout, use_datetime=0):
        self.timeout = timeout
        xmlrpclib.SafeTransport.__init__(self, use_datetime)

    def make_connection(self, host):
        h, eh, kwargs = self.get_host_info(host)
        if not kwargs:
            kwargs = {}
        kwargs['timeout'] = self.timeout
        if _ver_info == (2, 6):
            result = HTTPS(host, None, **kwargs)
        else:
            if not self._connection or host != self._connection[0]:
                self._extra_headers = eh
                self._connection = host, httplib.HTTPSConnection(h, None,
                                                                 **kwargs)
            result = self._connection[1]
        return result


class ServerProxy(xmlrpclib.ServerProxy):
    def __init__(self, uri, **kwargs):
        self.timeout = timeout = kwargs.pop('timeout', None)
        # The above classes only come into play if a timeout
        # is specified
        if timeout is not None:
            scheme, _ = splittype(uri)
            use_datetime = kwargs.get('use_datetime', 0)
            if scheme == 'https':
                tcls = SafeTransport
            else:
                tcls = Transport
            kwargs['transport'] = t = tcls(timeout, use_datetime=use_datetime)
            self.transport = t
        xmlrpclib.ServerProxy.__init__(self, uri, **kwargs)

#
# CSV functionality. This is provided because on 2.x, the csv module can't
# handle Unicode. However, we need to deal with Unicode in e.g. RECORD files.
#

def _csv_open(fn, mode, **kwargs):
    if sys.version_info[0] < 3:
        mode += 'b'
    else:
        kwargs['newline'] = ''
    return open(fn, mode, **kwargs)


class CSVBase(object):
    defaults = {
        'delimiter': str(','),      # The strs are used because we need native
        'quotechar': str('"'),      # str in the csv API (2.x won't take
        'lineterminator': str('\n') # Unicode)
    }

    def __enter__(self):
        return self

    def __exit__(self, *exc_info):
        self.stream.close()


class CSVReader(CSVBase):
    def __init__(self, **kwargs):
        if 'stream' in kwargs:
            stream = kwargs['stream']
            if sys.version_info[0] >= 3:
                # needs to be a text stream
                stream = codecs.getreader('utf-8')(stream)
            self.stream = stream
        else:
            self.stream = _csv_open(kwargs['path'], 'r')
        self.reader = csv.reader(self.stream, **self.defaults)

    def __iter__(self):
        return self

    def next(self):
        result = next(self.reader)
        if sys.version_info[0] < 3:
            for i, item in enumerate(result):
                if not isinstance(item, text_type):
                    result[i] = item.decode('utf-8')
        return result

    __next__ = next

class CSVWriter(CSVBase):
    def __init__(self, fn, **kwargs):
        self.stream = _csv_open(fn, 'w')
        self.writer = csv.writer(self.stream, **self.defaults)

    def writerow(self, row):
        if sys.version_info[0] < 3:
            r = []
            for item in row:
                if isinstance(item, text_type):
                    item = item.encode('utf-8')
                r.append(item)
            row = r
        self.writer.writerow(row)

#
#   Configurator functionality
#

class Configurator(BaseConfigurator):

    value_converters = dict(BaseConfigurator.value_converters)
    value_converters['inc'] = 'inc_convert'

    def __init__(self, config, base=None):
        super(Configurator, self).__init__(config)
        self.base = base or os.getcwd()

    def configure_custom(self, config):
        def convert(o):
            if isinstance(o, (list, tuple)):
                result = type(o)([convert(i) for i in o])
            elif isinstance(o, dict):
                if '()' in o:
                    result = self.configure_custom(o)
                else:
                    result = {}
                    for k in o:
                        result[k] = convert(o[k])
            else:
                result = self.convert(o)
            return result

        c = config.pop('()')
        if not callable(c):
            c = self.resolve(c)
        props = config.pop('.', None)
        # Check for valid identifiers
        args = config.pop('[]', ())
        if args:
            args = tuple([convert(o) for o in args])
        items = [(k, convert(config[k])) for k in config if valid_ident(k)]
        kwargs = dict(items)
        result = c(*args, **kwargs)
        if props:
            for n, v in props.items():
                setattr(result, n, convert(v))
        return result

    def __getitem__(self, key):
        result = self.config[key]
        if isinstance(result, dict) and '()' in result:
            self.config[key] = result = self.configure_custom(result)
        return result

    def inc_convert(self, value):
        """Default converter for the inc:// protocol."""
        if not os.path.isabs(value):
            value = os.path.join(self.base, value)
        with codecs.open(value, 'r', encoding='utf-8') as f:
            result = json.load(f)
        return result

#
# Mixin for running subprocesses and capturing their output
#

class SubprocessMixin(object):
    def __init__(self, verbose=False, progress=None):
        self.verbose = verbose
        self.progress = progress

    def reader(self, stream, context):
        """
        Read lines from a subprocess' output stream and either pass to a progress
        callable (if specified) or write progress information to sys.stderr.
        """
        progress = self.progress
        verbose = self.verbose
        while True:
            s = stream.readline()
            if not s:
                break
            if progress is not None:
                progress(s, context)
            else:
                if not verbose:
                    sys.stderr.write('.')
                else:
                    sys.stderr.write(s.decode('utf-8'))
                sys.stderr.flush()
        stream.close()

    def run_command(self, cmd, **kwargs):
        p = subprocess.Popen(cmd, stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE, **kwargs)
        t1 = threading.Thread(target=self.reader, args=(p.stdout, 'stdout'))
        t1.start()
        t2 = threading.Thread(target=self.reader, args=(p.stderr, 'stderr'))
        t2.start()
        p.wait()
        t1.join()
        t2.join()
        if self.progress is not None:
            self.progress('done.', 'main')
        elif self.verbose:
            sys.stderr.write('done.\n')
        return p

########NEW FILE########
__FILENAME__ = version
# -*- coding: utf-8 -*-
#
# Copyright (C) 2012-2013 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""
Implementation of a flexible versioning scheme providing support for PEP-386,
distribute-compatible and semantic versioning.
"""

import logging
import re

from .compat import string_types

__all__ = ['NormalizedVersion', 'NormalizedMatcher',
           'LegacyVersion', 'LegacyMatcher',
           'SemanticVersion', 'SemanticMatcher',
           'UnsupportedVersionError', 'get_scheme']

logger = logging.getLogger(__name__)


class UnsupportedVersionError(ValueError):
    """This is an unsupported version."""
    pass


class Version(object):
    def __init__(self, s):
        self._string = s = s.strip()
        self._parts = parts = self.parse(s)
        assert isinstance(parts, tuple)
        assert len(parts) > 0

    def parse(self, s):
        raise NotImplementedError('please implement in a subclass')

    def _check_compatible(self, other):
        if type(self) != type(other):
            raise TypeError('cannot compare %r and %r' % (self, other))

    def __eq__(self, other):
        self._check_compatible(other)
        return self._parts == other._parts

    def __ne__(self, other):
        return not self.__eq__(other)

    def __lt__(self, other):
        self._check_compatible(other)
        return self._parts < other._parts

    def __gt__(self, other):
        return not (self.__lt__(other) or self.__eq__(other))

    def __le__(self, other):
        return self.__lt__(other) or self.__eq__(other)

    def __ge__(self, other):
        return self.__gt__(other) or self.__eq__(other)

    # See http://docs.python.org/reference/datamodel#object.__hash__
    def __hash__(self):
        return hash(self._parts)

    def __repr__(self):
        return "%s('%s')" % (self.__class__.__name__, self._string)

    def __str__(self):
        return self._string

    @property
    def is_prerelease(self):
        raise NotImplementedError('Please implement in subclasses.')


class Matcher(object):
    version_class = None

    dist_re = re.compile(r"^(\w[\s\w'.-]*)(\((.*)\))?")
    comp_re = re.compile(r'^(<=|>=|<|>|!=|==|~=)?\s*([^\s,]+)$')
    num_re = re.compile(r'^\d+(\.\d+)*$')

    # value is either a callable or the name of a method
    _operators = {
        '<': lambda v, c, p: v < c,
        '>': lambda v, c, p: v > c,
        '<=': lambda v, c, p: v == c or v < c,
        '>=': lambda v, c, p: v == c or v > c,
        '==': lambda v, c, p: v == c,
        # by default, compatible => >=.
        '~=': lambda v, c, p: v == c or v > c,
        '!=': lambda v, c, p: v != c,
    }

    def __init__(self, s):
        if self.version_class is None:
            raise ValueError('Please specify a version class')
        self._string = s = s.strip()
        m = self.dist_re.match(s)
        if not m:
            raise ValueError('Not valid: %r' % s)
        groups = m.groups('')
        self.name = groups[0].strip()
        self.key = self.name.lower()    # for case-insensitive comparisons
        clist = []
        if groups[2]:
            constraints = [c.strip() for c in groups[2].split(',')]
            for c in constraints:
                m = self.comp_re.match(c)
                if not m:
                    raise ValueError('Invalid %r in %r' % (c, s))
                groups = m.groups()
                op = groups[0] or '~='
                s = groups[1]
                if s.endswith('.*'):
                    if op not in ('==', '!='):
                        raise ValueError('\'.*\' not allowed for '
                                         '%r constraints' % op)
                    # Could be a partial version (e.g. for '2.*') which
                    # won't parse as a version, so keep it as a string
                    vn, prefix = s[:-2], True
                    if not self.num_re.match(vn):
                        # Just to check that vn is a valid version
                        self.version_class(vn)
                else:
                    # Should parse as a version, so we can create an
                    # instance for the comparison
                    vn, prefix = self.version_class(s), False
                clist.append((op, vn, prefix))
        self._parts = tuple(clist)

    def match(self, version):
        """
        Check if the provided version matches the constraints.

        :param version: The version to match against this instance.
        :type version: Strring or :class:`Version` instance.
        """
        if isinstance(version, string_types):
            version = self.version_class(version)
        for operator, constraint, prefix in self._parts:
            f = self._operators.get(operator)
            if isinstance(f, string_types):
                f = getattr(self, f)
            if not f:
                msg = ('%r not implemented '
                       'for %s' % (operator, self.__class__.__name__))
                raise NotImplementedError(msg)
            if not f(version, constraint, prefix):
                return False
        return True

    @property
    def exact_version(self):
        result = None
        if len(self._parts) == 1 and self._parts[0][0] == '==':
            result = self._parts[0][1]
        return result

    def _check_compatible(self, other):
        if type(self) != type(other) or self.name != other.name:
            raise TypeError('cannot compare %s and %s' % (self, other))

    def __eq__(self, other):
        self._check_compatible(other)
        return self.key == other.key and self._parts == other._parts

    def __ne__(self, other):
        return not self.__eq__(other)

    # See http://docs.python.org/reference/datamodel#object.__hash__
    def __hash__(self):
        return hash(self.key) + hash(self._parts)

    def __repr__(self):
        return "%s(%r)" % (self.__class__.__name__, self._string)

    def __str__(self):
        return self._string


PEP426_VERSION_RE = re.compile(r'^(\d+(\.\d+)*)((a|b|c|rc)(\d+))?'
                               r'(\.(post)(\d+))?(\.(dev)(\d+))?'
                               r'(-(\d+(\.\d+)?))?$')


def _pep426_key(s):
    s = s.strip()
    m = PEP426_VERSION_RE.match(s)
    if not m:
        raise UnsupportedVersionError('Not a valid version: %s' % s)
    groups = m.groups()
    nums = tuple(int(v) for v in groups[0].split('.'))
    while len(nums) > 1 and nums[-1] == 0:
        nums = nums[:-1]

    pre = groups[3:5]
    post = groups[6:8]
    dev = groups[9:11]
    local = groups[12]
    if pre == (None, None):
        pre = ()
    else:
        pre = pre[0], int(pre[1])
    if post == (None, None):
        post = ()
    else:
        post = post[0], int(post[1])
    if dev == (None, None):
        dev = ()
    else:
        dev = dev[0], int(dev[1])
    if local is None:
        local = ()
    else:
        local = tuple([int(s) for s in local.split('.')])
    if not pre:
        # either before pre-release, or final release and after
        if not post and dev:
            # before pre-release
            pre = ('a', -1)     # to sort before a0
        else:
            pre = ('z',)        # to sort after all pre-releases
    # now look at the state of post and dev.
    if not post:
        post = ('_',)   # sort before 'a'
    if not dev:
        dev = ('final',)

    #print('%s -> %s' % (s, m.groups()))
    return nums, pre, post, dev, local


_normalized_key = _pep426_key


class NormalizedVersion(Version):
    """A rational version.

    Good:
        1.2         # equivalent to "1.2.0"
        1.2.0
        1.2a1
        1.2.3a2
        1.2.3b1
        1.2.3c1
        1.2.3.4
        TODO: fill this out

    Bad:
        1           # mininum two numbers
        1.2a        # release level must have a release serial
        1.2.3b
    """
    def parse(self, s):
        result = _normalized_key(s)
        # _normalized_key loses trailing zeroes in the release
        # clause, since that's needed to ensure that X.Y == X.Y.0 == X.Y.0.0
        # However, PEP 440 prefix matching needs it: for example,
        # (~= 1.4.5.0) matches differently to (~= 1.4.5.0.0).
        m = PEP426_VERSION_RE.match(s)      # must succeed
        groups = m.groups()
        self._release_clause = tuple(int(v) for v in groups[0].split('.'))
        return result

    PREREL_TAGS = set(['a', 'b', 'c', 'rc', 'dev'])

    @property
    def is_prerelease(self):
        return any(t[0] in self.PREREL_TAGS for t in self._parts if t)


def _match_prefix(x, y):
    x = str(x)
    y = str(y)
    if x == y:
        return True
    if not x.startswith(y):
        return False
    n = len(y)
    return x[n] == '.'


class NormalizedMatcher(Matcher):
    version_class = NormalizedVersion

    # value is either a callable or the name of a method
    _operators = {
        '~=': '_match_compatible',
        '<': '_match_lt',
        '>': '_match_gt',
        '<=': '_match_le',
        '>=': '_match_ge',
        '==': '_match_eq',
        '!=': '_match_ne',
    }

    def _adjust_local(self, version, constraint, prefix):
        if prefix:
            strip_local = '-' not in constraint and version._parts[-1]
        else:
            # both constraint and version are
            # NormalizedVersion instances.
            # If constraint does not have a local component,
            # ensure the version doesn't, either.
            strip_local = not constraint._parts[-1] and version._parts[-1]
        if strip_local:
            s = version._string.split('-', 1)[0]
            version = self.version_class(s)
        return version, constraint

    def _match_lt(self, version, constraint, prefix):
        version, constraint = self._adjust_local(version, constraint, prefix)
        if version >= constraint:
            return False
        release_clause = constraint._release_clause
        pfx = '.'.join([str(i) for i in release_clause])
        return not _match_prefix(version, pfx)

    def _match_gt(self, version, constraint, prefix):
        version, constraint = self._adjust_local(version, constraint, prefix)
        if version <= constraint:
            return False
        release_clause = constraint._release_clause
        pfx = '.'.join([str(i) for i in release_clause])
        return not _match_prefix(version, pfx)

    def _match_le(self, version, constraint, prefix):
        version, constraint = self._adjust_local(version, constraint, prefix)
        return version <= constraint

    def _match_ge(self, version, constraint, prefix):
        version, constraint = self._adjust_local(version, constraint, prefix)
        return version >= constraint

    def _match_eq(self, version, constraint, prefix):
        version, constraint = self._adjust_local(version, constraint, prefix)
        if not prefix:
            result = (version == constraint)
        else:
            result = _match_prefix(version, constraint)
        return result

    def _match_ne(self, version, constraint, prefix):
        version, constraint = self._adjust_local(version, constraint, prefix)
        if not prefix:
            result = (version != constraint)
        else:
            result = not _match_prefix(version, constraint)
        return result

    def _match_compatible(self, version, constraint, prefix):
        version, constraint = self._adjust_local(version, constraint, prefix)
        if version == constraint:
            return True
        if version < constraint:
            return False
        release_clause = constraint._release_clause
        if len(release_clause) > 1:
            release_clause = release_clause[:-1]
        pfx = '.'.join([str(i) for i in release_clause])
        return _match_prefix(version, pfx)

_REPLACEMENTS = (
    (re.compile('[.+-]$'), ''),                     # remove trailing puncts
    (re.compile(r'^[.](\d)'), r'0.\1'),             # .N -> 0.N at start
    (re.compile('^[.-]'), ''),                      # remove leading puncts
    (re.compile(r'^\((.*)\)$'), r'\1'),             # remove parentheses
    (re.compile(r'^v(ersion)?\s*(\d+)'), r'\2'),    # remove leading v(ersion)
    (re.compile(r'^r(ev)?\s*(\d+)'), r'\2'),        # remove leading v(ersion)
    (re.compile('[.]{2,}'), '.'),                   # multiple runs of '.'
    (re.compile(r'\b(alfa|apha)\b'), 'alpha'),      # misspelt alpha
    (re.compile(r'\b(pre-alpha|prealpha)\b'),
                'pre.alpha'),                       # standardise
    (re.compile(r'\(beta\)$'), 'beta'),             # remove parentheses
)

_SUFFIX_REPLACEMENTS = (
    (re.compile('^[:~._+-]+'), ''),                   # remove leading puncts
    (re.compile('[,*")([\]]'), ''),                   # remove unwanted chars
    (re.compile('[~:+_ -]'), '.'),                    # replace illegal chars
    (re.compile('[.]{2,}'), '.'),                   # multiple runs of '.'
    (re.compile(r'\.$'), ''),                       # trailing '.'
)

_NUMERIC_PREFIX = re.compile(r'(\d+(\.\d+)*)')


def _suggest_semantic_version(s):
    """
    Try to suggest a semantic form for a version for which
    _suggest_normalized_version couldn't come up with anything.
    """
    result = s.strip().lower()
    for pat, repl in _REPLACEMENTS:
        result = pat.sub(repl, result)
    if not result:
        result = '0.0.0'

    # Now look for numeric prefix, and separate it out from
    # the rest.
    #import pdb; pdb.set_trace()
    m = _NUMERIC_PREFIX.match(result)
    if not m:
        prefix = '0.0.0'
        suffix = result
    else:
        prefix = m.groups()[0].split('.')
        prefix = [int(i) for i in prefix]
        while len(prefix) < 3:
            prefix.append(0)
        if len(prefix) == 3:
            suffix = result[m.end():]
        else:
            suffix = '.'.join([str(i) for i in prefix[3:]]) + result[m.end():]
            prefix = prefix[:3]
        prefix = '.'.join([str(i) for i in prefix])
        suffix = suffix.strip()
    if suffix:
        #import pdb; pdb.set_trace()
        # massage the suffix.
        for pat, repl in _SUFFIX_REPLACEMENTS:
            suffix = pat.sub(repl, suffix)

    if not suffix:
        result = prefix
    else:
        sep = '-' if 'dev' in suffix else '+'
        result = prefix + sep + suffix
    if not is_semver(result):
        result = None
    return result


def _suggest_normalized_version(s):
    """Suggest a normalized version close to the given version string.

    If you have a version string that isn't rational (i.e. NormalizedVersion
    doesn't like it) then you might be able to get an equivalent (or close)
    rational version from this function.

    This does a number of simple normalizations to the given string, based
    on observation of versions currently in use on PyPI. Given a dump of
    those version during PyCon 2009, 4287 of them:
    - 2312 (53.93%) match NormalizedVersion without change
      with the automatic suggestion
    - 3474 (81.04%) match when using this suggestion method

    @param s {str} An irrational version string.
    @returns A rational version string, or None, if couldn't determine one.
    """
    try:
        _normalized_key(s)
        return s   # already rational
    except UnsupportedVersionError:
        pass

    rs = s.lower()

    # part of this could use maketrans
    for orig, repl in (('-alpha', 'a'), ('-beta', 'b'), ('alpha', 'a'),
                       ('beta', 'b'), ('rc', 'c'), ('-final', ''),
                       ('-pre', 'c'),
                       ('-release', ''), ('.release', ''), ('-stable', ''),
                       ('+', '.'), ('_', '.'), (' ', ''), ('.final', ''),
                       ('final', '')):
        rs = rs.replace(orig, repl)

    # if something ends with dev or pre, we add a 0
    rs = re.sub(r"pre$", r"pre0", rs)
    rs = re.sub(r"dev$", r"dev0", rs)

    # if we have something like "b-2" or "a.2" at the end of the
    # version, that is pobably beta, alpha, etc
    # let's remove the dash or dot
    rs = re.sub(r"([abc]|rc)[\-\.](\d+)$", r"\1\2", rs)

    # 1.0-dev-r371 -> 1.0.dev371
    # 0.1-dev-r79 -> 0.1.dev79
    rs = re.sub(r"[\-\.](dev)[\-\.]?r?(\d+)$", r".\1\2", rs)

    # Clean: 2.0.a.3, 2.0.b1, 0.9.0~c1
    rs = re.sub(r"[.~]?([abc])\.?", r"\1", rs)

    # Clean: v0.3, v1.0
    if rs.startswith('v'):
        rs = rs[1:]

    # Clean leading '0's on numbers.
    #TODO: unintended side-effect on, e.g., "2003.05.09"
    # PyPI stats: 77 (~2%) better
    rs = re.sub(r"\b0+(\d+)(?!\d)", r"\1", rs)

    # Clean a/b/c with no version. E.g. "1.0a" -> "1.0a0". Setuptools infers
    # zero.
    # PyPI stats: 245 (7.56%) better
    rs = re.sub(r"(\d+[abc])$", r"\g<1>0", rs)

    # the 'dev-rNNN' tag is a dev tag
    rs = re.sub(r"\.?(dev-r|dev\.r)\.?(\d+)$", r".dev\2", rs)

    # clean the - when used as a pre delimiter
    rs = re.sub(r"-(a|b|c)(\d+)$", r"\1\2", rs)

    # a terminal "dev" or "devel" can be changed into ".dev0"
    rs = re.sub(r"[\.\-](dev|devel)$", r".dev0", rs)

    # a terminal "dev" can be changed into ".dev0"
    rs = re.sub(r"(?![\.\-])dev$", r".dev0", rs)

    # a terminal "final" or "stable" can be removed
    rs = re.sub(r"(final|stable)$", "", rs)

    # The 'r' and the '-' tags are post release tags
    #   0.4a1.r10       ->  0.4a1.post10
    #   0.9.33-17222    ->  0.9.33.post17222
    #   0.9.33-r17222   ->  0.9.33.post17222
    rs = re.sub(r"\.?(r|-|-r)\.?(\d+)$", r".post\2", rs)

    # Clean 'r' instead of 'dev' usage:
    #   0.9.33+r17222   ->  0.9.33.dev17222
    #   1.0dev123       ->  1.0.dev123
    #   1.0.git123      ->  1.0.dev123
    #   1.0.bzr123      ->  1.0.dev123
    #   0.1a0dev.123    ->  0.1a0.dev123
    # PyPI stats:  ~150 (~4%) better
    rs = re.sub(r"\.?(dev|git|bzr)\.?(\d+)$", r".dev\2", rs)

    # Clean '.pre' (normalized from '-pre' above) instead of 'c' usage:
    #   0.2.pre1        ->  0.2c1
    #   0.2-c1         ->  0.2c1
    #   1.0preview123   ->  1.0c123
    # PyPI stats: ~21 (0.62%) better
    rs = re.sub(r"\.?(pre|preview|-c)(\d+)$", r"c\g<2>", rs)

    # Tcl/Tk uses "px" for their post release markers
    rs = re.sub(r"p(\d+)$", r".post\1", rs)

    try:
        _normalized_key(rs)
    except UnsupportedVersionError:
        rs = None
    return rs

#
#   Legacy version processing (distribute-compatible)
#

_VERSION_PART = re.compile(r'([a-z]+|\d+|[\.-])', re.I)
_VERSION_REPLACE = {
    'pre': 'c',
    'preview': 'c',
    '-': 'final-',
    'rc': 'c',
    'dev': '@',
    '': None,
    '.': None,
}


def _legacy_key(s):
    def get_parts(s):
        result = []
        for p in _VERSION_PART.split(s.lower()):
            p = _VERSION_REPLACE.get(p, p)
            if p:
                if '0' <= p[:1] <= '9':
                    p = p.zfill(8)
                else:
                    p = '*' + p
                result.append(p)
        result.append('*final')
        return result

    result = []
    for p in get_parts(s):
        if p.startswith('*'):
            if p < '*final':
                while result and result[-1] == '*final-':
                    result.pop()
            while result and result[-1] == '00000000':
                result.pop()
        result.append(p)
    return tuple(result)


class LegacyVersion(Version):
    def parse(self, s):
        return _legacy_key(s)

    @property
    def is_prerelease(self):
        result = False
        for x in self._parts:
            if (isinstance(x, string_types) and x.startswith('*') and
                x < '*final'):
                result = True
                break
        return result


class LegacyMatcher(Matcher):
    version_class = LegacyVersion

    _operators = dict(Matcher._operators)
    _operators['~='] = '_match_compatible'

    numeric_re = re.compile('^(\d+(\.\d+)*)')

    def _match_compatible(self, version, constraint, prefix):
        if version < constraint:
            return False
        m = self.numeric_re.match(str(constraint))
        if not m:
            logger.warning('Cannot compute compatible match for version %s '
                           ' and constraint %s', version, constraint)
            return True
        s = m.groups()[0]
        if '.' in s:
            s = s.rsplit('.', 1)[0]
        return _match_prefix(version, s)

#
#   Semantic versioning
#

_SEMVER_RE = re.compile(r'^(\d+)\.(\d+)\.(\d+)'
                        r'(-[a-z0-9]+(\.[a-z0-9-]+)*)?'
                        r'(\+[a-z0-9]+(\.[a-z0-9-]+)*)?$', re.I)


def is_semver(s):
    return _SEMVER_RE.match(s)


def _semantic_key(s):
    def make_tuple(s, absent):
        if s is None:
            result = (absent,)
        else:
            parts = s[1:].split('.')
            # We can't compare ints and strings on Python 3, so fudge it
            # by zero-filling numeric values so simulate a numeric comparison
            result = tuple([p.zfill(8) if p.isdigit() else p for p in parts])
        return result

    m = is_semver(s)
    if not m:
        raise UnsupportedVersionError(s)
    groups = m.groups()
    major, minor, patch = [int(i) for i in groups[:3]]
    # choose the '|' and '*' so that versions sort correctly
    pre, build = make_tuple(groups[3], '|'), make_tuple(groups[5], '*')
    return (major, minor, patch), pre, build


class SemanticVersion(Version):
    def parse(self, s):
        return _semantic_key(s)

    @property
    def is_prerelease(self):
        return self._parts[1][0] != '|'


class SemanticMatcher(Matcher):
    version_class = SemanticVersion


class VersionScheme(object):
    def __init__(self, key, matcher, suggester=None):
        self.key = key
        self.matcher = matcher
        self.suggester = suggester

    def is_valid_version(self, s):
        try:
            self.matcher.version_class(s)
            result = True
        except UnsupportedVersionError:
            result = False
        return result

    def is_valid_matcher(self, s):
        try:
            self.matcher(s)
            result = True
        except UnsupportedVersionError:
            result = False
        return result

    def is_valid_constraint_list(self, s):
        """
        Used for processing some metadata fields
        """
        return self.is_valid_matcher('dummy_name (%s)' % s)

    def suggest(self, s):
        if self.suggester is None:
            result = None
        else:
            result = self.suggester(s)
        return result

_SCHEMES = {
    'normalized': VersionScheme(_normalized_key, NormalizedMatcher,
                                _suggest_normalized_version),
    'legacy': VersionScheme(_legacy_key, LegacyMatcher, lambda self, s: s),
    'semantic': VersionScheme(_semantic_key, SemanticMatcher,
                              _suggest_semantic_version),
}

_SCHEMES['default'] = _SCHEMES['normalized']


def get_scheme(name):
    if name not in _SCHEMES:
        raise ValueError('unknown scheme name: %r' % name)
    return _SCHEMES[name]

########NEW FILE########
__FILENAME__ = wheel
# -*- coding: utf-8 -*-
#
# Copyright (C) 2013-2014 Vinay Sajip.
# Licensed to the Python Software Foundation under a contributor agreement.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
from __future__ import unicode_literals

import base64
import codecs
import datetime
import distutils.util
from email import message_from_file
import hashlib
import imp
import json
import logging
import os
import posixpath
import re
import shutil
import sys
import tempfile
import zipfile

from . import __version__, DistlibException
from .compat import sysconfig, ZipFile, fsdecode, text_type, filter
from .database import InstalledDistribution
from .metadata import Metadata, METADATA_FILENAME
from .util import (FileOperator, convert_path, CSVReader, CSVWriter, Cache,
                   cached_property, get_cache_base, read_exports, tempdir)
from .version import NormalizedVersion, UnsupportedVersionError

logger = logging.getLogger(__name__)

cache = None    # created when needed

if hasattr(sys, 'pypy_version_info'):
    IMP_PREFIX = 'pp'
elif sys.platform.startswith('java'):
    IMP_PREFIX = 'jy'
elif sys.platform == 'cli':
    IMP_PREFIX = 'ip'
else:
    IMP_PREFIX = 'cp'

VER_SUFFIX = sysconfig.get_config_var('py_version_nodot')
if not VER_SUFFIX:   # pragma: no cover
    VER_SUFFIX = '%s%s' % sys.version_info[:2]
PYVER = 'py' + VER_SUFFIX
IMPVER = IMP_PREFIX + VER_SUFFIX

ARCH = distutils.util.get_platform().replace('-', '_').replace('.', '_')

ABI = sysconfig.get_config_var('SOABI')
if ABI and ABI.startswith('cpython-'):
    ABI = ABI.replace('cpython-', 'cp')
else:
    def _derive_abi():
        parts = ['cp', VER_SUFFIX]
        if sysconfig.get_config_var('Py_DEBUG'):
            parts.append('d')
        if sysconfig.get_config_var('WITH_PYMALLOC'):
            parts.append('m')
        if sysconfig.get_config_var('Py_UNICODE_SIZE') == 4:
            parts.append('u')
        return ''.join(parts)
    ABI = _derive_abi()
    del _derive_abi

FILENAME_RE = re.compile(r'''
(?P<nm>[^-]+)
-(?P<vn>\d+[^-]*)
(-(?P<bn>\d+[^-]*))?
-(?P<py>\w+\d+(\.\w+\d+)*)
-(?P<bi>\w+)
-(?P<ar>\w+)
\.whl$
''', re.IGNORECASE | re.VERBOSE)

NAME_VERSION_RE = re.compile(r'''
(?P<nm>[^-]+)
-(?P<vn>\d+[^-]*)
(-(?P<bn>\d+[^-]*))?$
''', re.IGNORECASE | re.VERBOSE)

SHEBANG_RE = re.compile(br'\s*#![^\r\n]*')

if os.sep == '/':
    to_posix = lambda o: o
else:
    to_posix = lambda o: o.replace(os.sep, '/')


class Mounter(object):
    def __init__(self):
        self.impure_wheels = {}
        self.libs = {}

    def add(self, pathname, extensions):
        self.impure_wheels[pathname] = extensions
        self.libs.update(extensions)

    def remove(self, pathname):
        extensions = self.impure_wheels.pop(pathname)
        for k, v in extensions:
            if k in self.libs:
                del self.libs[k]

    def find_module(self, fullname, path=None):
        if fullname in self.libs:
            result = self
        else:
            result = None
        return result

    def load_module(self, fullname):
        if fullname in sys.modules:
            result = sys.modules[fullname]
        else:
            if fullname not in self.libs:
                raise ImportError('unable to find extension for %s' % fullname)
            result = imp.load_dynamic(fullname, self.libs[fullname])
            result.__loader__ = self
            parts = fullname.rsplit('.', 1)
            if len(parts) > 1:
                result.__package__ = parts[0]
        return result

_hook = Mounter()


class Wheel(object):
    """
    Class to build and install from Wheel files (PEP 427).
    """

    wheel_version = (1, 1)
    hash_kind = 'sha256'

    def __init__(self, filename=None, sign=False, verify=False):
        """
        Initialise an instance using a (valid) filename.
        """
        self.sign = sign
        self.should_verify = verify
        self.buildver = ''
        self.pyver = [PYVER]
        self.abi = ['none']
        self.arch = ['any']
        self.dirname = os.getcwd()
        if filename is None:
            self.name = 'dummy'
            self.version = '0.1'
            self._filename = self.filename
        else:
            m = NAME_VERSION_RE.match(filename)
            if m:
                info = m.groupdict('')
                self.name = info['nm']
                # Reinstate the local version separator
                self.version = info['vn'].replace('_', '-')
                self.buildver = info['bn']
                self._filename = self.filename
            else:
                dirname, filename = os.path.split(filename)
                m = FILENAME_RE.match(filename)
                if not m:
                    raise DistlibException('Invalid name or '
                                           'filename: %r' % filename)
                if dirname:
                    self.dirname = os.path.abspath(dirname)
                self._filename = filename
                info = m.groupdict('')
                self.name = info['nm']
                self.version = info['vn']
                self.buildver = info['bn']
                self.pyver = info['py'].split('.')
                self.abi = info['bi'].split('.')
                self.arch = info['ar'].split('.')

    @property
    def filename(self):
        """
        Build and return a filename from the various components.
        """
        if self.buildver:
            buildver = '-' + self.buildver
        else:
            buildver = ''
        pyver = '.'.join(self.pyver)
        abi = '.'.join(self.abi)
        arch = '.'.join(self.arch)
        # replace - with _ as a local version separator
        version = self.version.replace('-', '_')
        return '%s-%s%s-%s-%s-%s.whl' % (self.name, version, buildver,
                                         pyver, abi, arch)

    @property
    def exists(self):
        path = os.path.join(self.dirname, self.filename)
        return os.path.isfile(path)

    @property
    def tags(self):
        for pyver in self.pyver:
            for abi in self.abi:
                for arch in self.arch:
                    yield pyver, abi, arch

    @cached_property
    def metadata(self):
        pathname = os.path.join(self.dirname, self.filename)
        name_ver = '%s-%s' % (self.name, self.version)
        info_dir = '%s.dist-info' % name_ver
        wrapper = codecs.getreader('utf-8')
        with ZipFile(pathname, 'r') as zf:
            wheel_metadata = self.get_wheel_metadata(zf)
            wv = wheel_metadata['Wheel-Version'].split('.', 1)
            file_version = tuple([int(i) for i in wv])
            if file_version < (1, 1):
                fn = 'METADATA'
            else:
                fn = METADATA_FILENAME
            try:
                metadata_filename = posixpath.join(info_dir, fn)
                with zf.open(metadata_filename) as bf:
                    wf = wrapper(bf)
                    result = Metadata(fileobj=wf)
            except KeyError:
                raise ValueError('Invalid wheel, because %s is '
                                 'missing' % fn)
        return result

    def get_wheel_metadata(self, zf):
        name_ver = '%s-%s' % (self.name, self.version)
        info_dir = '%s.dist-info' % name_ver
        metadata_filename = posixpath.join(info_dir, 'WHEEL')
        with zf.open(metadata_filename) as bf:
            wf = codecs.getreader('utf-8')(bf)
            message = message_from_file(wf)
        return dict(message)

    @cached_property
    def info(self):
        pathname = os.path.join(self.dirname, self.filename)
        with ZipFile(pathname, 'r') as zf:
            result = self.get_wheel_metadata(zf)
        return result

    def process_shebang(self, data):
        m = SHEBANG_RE.match(data)
        if m:
            data = b'#!python' + data[m.end():]
        else:
            cr = data.find(b'\r')
            lf = data.find(b'\n')
            if cr < 0 or cr > lf:
                term = b'\n'
            else:
                if data[cr:cr + 2] == b'\r\n':
                    term = b'\r\n'
                else:
                    term = b'\r'
            data = b'#!python' + term + data
        return data

    def get_hash(self, data, hash_kind=None):
        if hash_kind is None:
            hash_kind = self.hash_kind
        try:
            hasher = getattr(hashlib, hash_kind)
        except AttributeError:
            raise DistlibException('Unsupported hash algorithm: %r' % hash_kind)
        result = hasher(data).digest()
        result = base64.urlsafe_b64encode(result).rstrip(b'=').decode('ascii')
        return hash_kind, result

    def write_record(self, records, record_path, base):
        with CSVWriter(record_path) as writer:
            for row in records:
                writer.writerow(row)
            p = to_posix(os.path.relpath(record_path, base))
            writer.writerow((p, '', ''))

    def write_records(self, info, libdir, archive_paths):
        records = []
        distinfo, info_dir = info
        hasher = getattr(hashlib, self.hash_kind)
        for ap, p in archive_paths:
            with open(p, 'rb') as f:
                data = f.read()
            digest = '%s=%s' % self.get_hash(data)
            size = os.path.getsize(p)
            records.append((ap, digest, size))

        p = os.path.join(distinfo, 'RECORD')
        self.write_record(records, p, libdir)
        ap = to_posix(os.path.join(info_dir, 'RECORD'))
        archive_paths.append((ap, p))

    def build_zip(self, pathname, archive_paths):
        with ZipFile(pathname, 'w', zipfile.ZIP_DEFLATED) as zf:
            for ap, p in archive_paths:
                logger.debug('Wrote %s to %s in wheel', p, ap)
                zf.write(p, ap)

    def build(self, paths, tags=None, wheel_version=None):
        """
        Build a wheel from files in specified paths, and use any specified tags
        when determining the name of the wheel.
        """
        if tags is None:
            tags = {}

        libkey = list(filter(lambda o: o in paths, ('purelib', 'platlib')))[0]
        if libkey == 'platlib':
            is_pure = 'false'
            default_pyver = [IMPVER]
            default_abi = [ABI]
            default_arch = [ARCH]
        else:
            is_pure = 'true'
            default_pyver = [PYVER]
            default_abi = ['none']
            default_arch = ['any']

        self.pyver = tags.get('pyver', default_pyver)
        self.abi = tags.get('abi', default_abi)
        self.arch = tags.get('arch', default_arch)

        libdir = paths[libkey]

        name_ver = '%s-%s' % (self.name, self.version)
        data_dir = '%s.data' % name_ver
        info_dir = '%s.dist-info' % name_ver

        archive_paths = []

        # First, stuff which is not in site-packages
        for key in ('data', 'headers', 'scripts'):
            if key not in paths:
                continue
            path = paths[key]
            if os.path.isdir(path):
                for root, dirs, files in os.walk(path):
                    for fn in files:
                        p = fsdecode(os.path.join(root, fn))
                        rp = os.path.relpath(p, path)
                        ap = to_posix(os.path.join(data_dir, key, rp))
                        archive_paths.append((ap, p))
                        if key == 'scripts' and not p.endswith('.exe'):
                            with open(p, 'rb') as f:
                                data = f.read()
                            data = self.process_shebang(data)
                            with open(p, 'wb') as f:
                                f.write(data)

        # Now, stuff which is in site-packages, other than the
        # distinfo stuff.
        path = libdir
        distinfo = None
        for root, dirs, files in os.walk(path):
            if root == path:
                # At the top level only, save distinfo for later
                # and skip it for now
                for i, dn in enumerate(dirs):
                    dn = fsdecode(dn)
                    if dn.endswith('.dist-info'):
                        distinfo = os.path.join(root, dn)
                        del dirs[i]
                        break
                assert distinfo, '.dist-info directory expected, not found'

            for fn in files:
                # comment out next suite to leave .pyc files in
                if fsdecode(fn).endswith(('.pyc', '.pyo')):
                    continue
                p = os.path.join(root, fn)
                rp = to_posix(os.path.relpath(p, path))
                archive_paths.append((rp, p))

        # Now distinfo. Assumed to be flat, i.e. os.listdir is enough.
        files = os.listdir(distinfo)
        for fn in files:
            if fn not in ('RECORD', 'INSTALLER', 'SHARED'):
                p = fsdecode(os.path.join(distinfo, fn))
                ap = to_posix(os.path.join(info_dir, fn))
                archive_paths.append((ap, p))

        wheel_metadata = [
            'Wheel-Version: %d.%d' % (wheel_version or self.wheel_version),
            'Generator: distlib %s' % __version__,
            'Root-Is-Purelib: %s' % is_pure,
        ]
        for pyver, abi, arch in self.tags:
            wheel_metadata.append('Tag: %s-%s-%s' % (pyver, abi, arch))
        p = os.path.join(distinfo, 'WHEEL')
        with open(p, 'w') as f:
            f.write('\n'.join(wheel_metadata))
        ap = to_posix(os.path.join(info_dir, 'WHEEL'))
        archive_paths.append((ap, p))

        # Now, at last, RECORD.
        # Paths in here are archive paths - nothing else makes sense.
        self.write_records((distinfo, info_dir), libdir, archive_paths)
        # Now, ready to build the zip file
        pathname = os.path.join(self.dirname, self.filename)
        self.build_zip(pathname, archive_paths)
        return pathname

    def install(self, paths, maker, **kwargs):
        """
        Install a wheel to the specified paths. If kwarg ``warner`` is
        specified, it should be a callable, which will be called with two
        tuples indicating the wheel version of this software and the wheel
        version in the file, if there is a discrepancy in the versions.
        This can be used to issue any warnings to raise any exceptions.
        If kwarg ``lib_only`` is True, only the purelib/platlib files are
        installed, and the headers, scripts, data and dist-info metadata are
        not written.

        The return value is a :class:`InstalledDistribution` instance unless
        ``options.lib_only`` is True, in which case the return value is ``None``.
        """

        dry_run = maker.dry_run
        warner = kwargs.get('warner')
        lib_only = kwargs.get('lib_only', False)

        pathname = os.path.join(self.dirname, self.filename)
        name_ver = '%s-%s' % (self.name, self.version)
        data_dir = '%s.data' % name_ver
        info_dir = '%s.dist-info' % name_ver

        metadata_name = posixpath.join(info_dir, METADATA_FILENAME)
        wheel_metadata_name = posixpath.join(info_dir, 'WHEEL')
        record_name = posixpath.join(info_dir, 'RECORD')

        wrapper = codecs.getreader('utf-8')

        with ZipFile(pathname, 'r') as zf:
            with zf.open(wheel_metadata_name) as bwf:
                wf = wrapper(bwf)
                message = message_from_file(wf)
            wv = message['Wheel-Version'].split('.', 1)
            file_version = tuple([int(i) for i in wv])
            if (file_version != self.wheel_version) and warner:
                warner(self.wheel_version, file_version)

            if message['Root-Is-Purelib'] == 'true':
                libdir = paths['purelib']
            else:
                libdir = paths['platlib']

            records = {}
            with zf.open(record_name) as bf:
                with CSVReader(stream=bf) as reader:
                    for row in reader:
                        p = row[0]
                        records[p] = row

            data_pfx = posixpath.join(data_dir, '')
            info_pfx = posixpath.join(info_dir, '')
            script_pfx = posixpath.join(data_dir, 'scripts', '')

            # make a new instance rather than a copy of maker's,
            # as we mutate it
            fileop = FileOperator(dry_run=dry_run)
            fileop.record = True    # so we can rollback if needed

            bc = not sys.dont_write_bytecode    # Double negatives. Lovely!

            outfiles = []   # for RECORD writing

            # for script copying/shebang processing
            workdir = tempfile.mkdtemp()
            # set target dir later
            # we default add_launchers to False, as the
            # Python Launcher should be used instead
            maker.source_dir = workdir
            maker.target_dir = None
            try:
                for zinfo in zf.infolist():
                    arcname = zinfo.filename
                    if isinstance(arcname, text_type):
                        u_arcname = arcname
                    else:
                        u_arcname = arcname.decode('utf-8')
                    # The signature file won't be in RECORD,
                    # and we  don't currently don't do anything with it
                    if u_arcname.endswith('/RECORD.jws'):
                        continue
                    row = records[u_arcname]
                    if row[2] and str(zinfo.file_size) != row[2]:
                        raise DistlibException('size mismatch for '
                                               '%s' % u_arcname)
                    if row[1]:
                        kind, value = row[1].split('=', 1)
                        with zf.open(arcname) as bf:
                            data = bf.read()
                        _, digest = self.get_hash(data, kind)
                        if digest != value:
                            raise DistlibException('digest mismatch for '
                                                   '%s' % arcname)

                    if lib_only and u_arcname.startswith((info_pfx, data_pfx)):
                        logger.debug('lib_only: skipping %s', u_arcname)
                        continue
                    is_script = (u_arcname.startswith(script_pfx)
                                 and not u_arcname.endswith('.exe'))

                    if u_arcname.startswith(data_pfx):
                        _, where, rp = u_arcname.split('/', 2)
                        outfile = os.path.join(paths[where], convert_path(rp))
                    else:
                        # meant for site-packages.
                        if u_arcname in (wheel_metadata_name, record_name):
                            continue
                        outfile = os.path.join(libdir, convert_path(u_arcname))
                    if not is_script:
                        with zf.open(arcname) as bf:
                            fileop.copy_stream(bf, outfile)
                        outfiles.append(outfile)
                        # Double check the digest of the written file
                        if not dry_run and row[1]:
                            with open(outfile, 'rb') as bf:
                                data = bf.read()
                                _, newdigest = self.get_hash(data, kind)
                                if newdigest != digest:
                                    raise DistlibException('digest mismatch '
                                                           'on write for '
                                                           '%s' % outfile)
                        if bc and outfile.endswith('.py'):
                            try:
                                pyc = fileop.byte_compile(outfile)
                                outfiles.append(pyc)
                            except Exception:
                                # Don't give up if byte-compilation fails,
                                # but log it and perhaps warn the user
                                logger.warning('Byte-compilation failed',
                                               exc_info=True)
                    else:
                        fn = os.path.basename(convert_path(arcname))
                        workname = os.path.join(workdir, fn)
                        with zf.open(arcname) as bf:
                            fileop.copy_stream(bf, workname)

                        dn, fn = os.path.split(outfile)
                        maker.target_dir = dn
                        filenames = maker.make(fn)
                        fileop.set_executable_mode(filenames)
                        outfiles.extend(filenames)

                if lib_only:
                    logger.debug('lib_only: returning None')
                    dist = None
                else:
                    # Generate scripts

                    # Try to get pydist.json so we can see if there are
                    # any commands to generate. If this fails (e.g. because
                    # of a legacy wheel), log a warning but don't give up.
                    commands = None
                    file_version = self.info['Wheel-Version']
                    if file_version == '1.0':
                        # Use legacy info
                        ep = posixpath.join(info_dir, 'entry_points.txt')
                        try:
                            with zf.open(ep) as bwf:
                                epdata = read_exports(bwf)
                            commands = {}
                            for key in ('console', 'gui'):
                                k = '%s_scripts' % key
                                if k in epdata:
                                    commands['wrap_%s' % key] = d = {}
                                    for v in epdata[k].values():
                                        s = '%s:%s' % (v.prefix, v.suffix)
                                        if v.flags:
                                            s += ' %s' % v.flags
                                        d[v.name] = s
                        except Exception:
                            logger.warning('Unable to read legacy script '
                                           'metadata, so cannot generate '
                                           'scripts')
                    else:
                        try:
                            with zf.open(metadata_name) as bwf:
                                wf = wrapper(bwf)
                                commands = json.load(wf).get('commands')
                        except Exception:
                            logger.warning('Unable to read JSON metadata, so '
                                           'cannot generate scripts')
                    if commands:
                        console_scripts = commands.get('wrap_console', {})
                        gui_scripts = commands.get('wrap_gui', {})
                        if console_scripts or gui_scripts:
                            script_dir = paths.get('scripts', '')
                            if not os.path.isdir(script_dir):
                                raise ValueError('Valid script path not '
                                                 'specified')
                            maker.target_dir = script_dir
                            for k, v in console_scripts.items():
                                script = '%s = %s' % (k, v)
                                filenames = maker.make(script)
                                fileop.set_executable_mode(filenames)

                            if gui_scripts:
                                options = {'gui': True }
                                for k, v in gui_scripts.items():
                                    script = '%s = %s' % (k, v)
                                    filenames = maker.make(script, options)
                                    fileop.set_executable_mode(filenames)

                    p = os.path.join(libdir, info_dir)
                    dist = InstalledDistribution(p)

                    # Write SHARED
                    paths = dict(paths)     # don't change passed in dict
                    del paths['purelib']
                    del paths['platlib']
                    paths['lib'] = libdir
                    p = dist.write_shared_locations(paths, dry_run)
                    if p:
                        outfiles.append(p)

                    # Write RECORD
                    dist.write_installed_files(outfiles, paths['prefix'],
                                               dry_run)
                return dist
            except Exception:  # pragma: no cover
                logger.exception('installation failed.')
                fileop.rollback()
                raise
            finally:
                shutil.rmtree(workdir)

    def _get_dylib_cache(self):
        global cache
        if cache is None:
            # Use native string to avoid issues on 2.x: see Python #20140.
            base = os.path.join(get_cache_base(), str('dylib-cache'),
                                sys.version[:3])
            cache = Cache(base)
        return cache

    def _get_extensions(self):
        pathname = os.path.join(self.dirname, self.filename)
        name_ver = '%s-%s' % (self.name, self.version)
        info_dir = '%s.dist-info' % name_ver
        arcname = posixpath.join(info_dir, 'EXTENSIONS')
        wrapper = codecs.getreader('utf-8')
        result = []
        with ZipFile(pathname, 'r') as zf:
            try:
                with zf.open(arcname) as bf:
                    wf = wrapper(bf)
                    extensions = json.load(wf)
                    cache = self._get_dylib_cache()
                    prefix = cache.prefix_to_dir(pathname)
                    cache_base = os.path.join(cache.base, prefix)
                    if not os.path.isdir(cache_base):
                        os.makedirs(cache_base)
                    for name, relpath in extensions.items():
                        dest = os.path.join(cache_base, convert_path(relpath))
                        if not os.path.exists(dest):
                            extract = True
                        else:
                            file_time = os.stat(dest).st_mtime
                            file_time = datetime.datetime.fromtimestamp(file_time)
                            info = zf.getinfo(relpath)
                            wheel_time = datetime.datetime(*info.date_time)
                            extract = wheel_time > file_time
                        if extract:
                            zf.extract(relpath, cache_base)
                        result.append((name, dest))
            except KeyError:
                pass
        return result

    def is_compatible(self):
        """
        Determine if a wheel is compatible with the running system.
        """
        return is_compatible(self)

    def is_mountable(self):
        """
        Determine if a wheel is asserted as mountable by its metadata.
        """
        return True # for now - metadata details TBD

    def mount(self, append=False):
        pathname = os.path.abspath(os.path.join(self.dirname, self.filename))
        if not self.is_compatible():
            msg = 'Wheel %s not compatible with this Python.' % pathname
            raise DistlibException(msg)
        if not self.is_mountable():
            msg = 'Wheel %s is marked as not mountable.' % pathname
            raise DistlibException(msg)
        if pathname in sys.path:
            logger.debug('%s already in path', pathname)
        else:
            if append:
                sys.path.append(pathname)
            else:
                sys.path.insert(0, pathname)
            extensions = self._get_extensions()
            if extensions:
                if _hook not in sys.meta_path:
                    sys.meta_path.append(_hook)
                _hook.add(pathname, extensions)

    def unmount(self):
        pathname = os.path.abspath(os.path.join(self.dirname, self.filename))
        if pathname not in sys.path:
            logger.debug('%s not in path', pathname)
        else:
            sys.path.remove(pathname)
            if pathname in _hook.impure_wheels:
                _hook.remove(pathname)
            if not _hook.impure_wheels:
                if _hook in sys.meta_path:
                    sys.meta_path.remove(_hook)

    def verify(self):
        pathname = os.path.join(self.dirname, self.filename)
        name_ver = '%s-%s' % (self.name, self.version)
        data_dir = '%s.data' % name_ver
        info_dir = '%s.dist-info' % name_ver

        metadata_name = posixpath.join(info_dir, METADATA_FILENAME)
        wheel_metadata_name = posixpath.join(info_dir, 'WHEEL')
        record_name = posixpath.join(info_dir, 'RECORD')

        wrapper = codecs.getreader('utf-8')

        with ZipFile(pathname, 'r') as zf:
            with zf.open(wheel_metadata_name) as bwf:
                wf = wrapper(bwf)
                message = message_from_file(wf)
            wv = message['Wheel-Version'].split('.', 1)
            file_version = tuple([int(i) for i in wv])
            # TODO version verification

            records = {}
            with zf.open(record_name) as bf:
                with CSVReader(stream=bf) as reader:
                    for row in reader:
                        p = row[0]
                        records[p] = row

            for zinfo in zf.infolist():
                arcname = zinfo.filename
                if isinstance(arcname, text_type):
                    u_arcname = arcname
                else:
                    u_arcname = arcname.decode('utf-8')
                if '..' in u_arcname:
                    raise DistlibException('invalid entry in '
                                           'wheel: %r' % u_arcname)

                # The signature file won't be in RECORD,
                # and we  don't currently don't do anything with it
                if u_arcname.endswith('/RECORD.jws'):
                    continue
                row = records[u_arcname]
                if row[2] and str(zinfo.file_size) != row[2]:
                    raise DistlibException('size mismatch for '
                                           '%s' % u_arcname)
                if row[1]:
                    kind, value = row[1].split('=', 1)
                    with zf.open(arcname) as bf:
                        data = bf.read()
                    _, digest = self.get_hash(data, kind)
                    if digest != value:
                        raise DistlibException('digest mismatch for '
                                               '%s' % arcname)

    def update(self, modifier, dest_dir=None, **kwargs):
        """
        Update the contents of a wheel in a generic way. The modifier should
        be a callable which expects a dictionary argument: its keys are
        archive-entry paths, and its values are absolute filesystem paths
        where the contents the corresponding archive entries can be found. The
        modifier is free to change the contents of the files pointed to, add
        new entries and remove entries, before returning. This method will
        extract the entire contents of the wheel to a temporary location, call
        the modifier, and then use the passed (and possibly updated)
        dictionary to write a new wheel. If ``dest_dir`` is specified, the new
        wheel is written there -- otherwise, the original wheel is overwritten.

        The modifier should return True if it updated the wheel, else False.
        This method returns the same value the modifier returns.
        """

        def get_version(path_map, info_dir):
            version = path = None
            key = '%s/%s' % (info_dir, METADATA_FILENAME)
            if key not in path_map:
                key = '%s/PKG-INFO' % info_dir
            if key in path_map:
                path = path_map[key]
                version = Metadata(path=path).version
            return version, path

        def update_version(version, path):
            updated = None
            try:
                v = NormalizedVersion(version)
                i = version.find('-')
                if i < 0:
                    updated = '%s-1' % version
                else:
                    parts = [int(s) for s in version[i + 1:].split('.')]
                    parts[-1] += 1
                    updated = '%s-%s' % (version[:i],
                                         '.'.join(str(i) for i in parts))
            except UnsupportedVersionError:
                logger.debug('Cannot update non-compliant (PEP-440) '
                             'version %r', version)
            if updated:
                md = Metadata(path=path)
                md.version = updated
                legacy = not path.endswith(METADATA_FILENAME)
                md.write(path=path, legacy=legacy)
                logger.debug('Version updated from %r to %r', version,
                             updated)

        pathname = os.path.join(self.dirname, self.filename)
        name_ver = '%s-%s' % (self.name, self.version)
        info_dir = '%s.dist-info' % name_ver
        record_name = posixpath.join(info_dir, 'RECORD')
        with tempdir() as workdir:
            with ZipFile(pathname, 'r') as zf:
                path_map = {}
                for zinfo in zf.infolist():
                    arcname = zinfo.filename
                    if isinstance(arcname, text_type):
                        u_arcname = arcname
                    else:
                        u_arcname = arcname.decode('utf-8')
                    if u_arcname == record_name:
                        continue
                    if '..' in u_arcname:
                        raise DistlibException('invalid entry in '
                                               'wheel: %r' % u_arcname)
                    zf.extract(zinfo, workdir)
                    path = os.path.join(workdir, convert_path(u_arcname))
                    path_map[u_arcname] = path

            # Remember the version.
            original_version, _ = get_version(path_map, info_dir)
            # Files extracted. Call the modifier.
            modified = modifier(path_map, **kwargs)
            if modified:
                # Something changed - need to build a new wheel.
                current_version, path = get_version(path_map, info_dir)
                if current_version and (current_version == original_version):
                    # Add or update local version to signify changes.
                    update_version(current_version, path)
                # Decide where the new wheel goes.
                if dest_dir is None:
                    fd, newpath = tempfile.mkstemp(suffix='.whl',
                                                   prefix='wheel-update-',
                                                   dir=workdir)
                    os.close(fd)
                else:
                    if not os.path.isdir(dest_dir):
                        raise DistlibException('Not a directory: %r' % dest_dir)
                    newpath = os.path.join(dest_dir, self.filename)
                archive_paths = list(path_map.items())
                distinfo = os.path.join(workdir, info_dir)
                info = distinfo, info_dir
                self.write_records(info, workdir, archive_paths)
                self.build_zip(newpath, archive_paths)
                if dest_dir is None:
                    shutil.copyfile(newpath, pathname)
        return modified

def compatible_tags():
    """
    Return (pyver, abi, arch) tuples compatible with this Python.
    """
    versions = [VER_SUFFIX]
    major = VER_SUFFIX[0]
    for minor in range(sys.version_info[1] - 1, - 1, -1):
        versions.append(''.join([major, str(minor)]))

    abis = []
    for suffix, _, _ in imp.get_suffixes():
        if suffix.startswith('.abi'):
            abis.append(suffix.split('.', 2)[1])
    abis.sort()
    if ABI != 'none':
        abis.insert(0, ABI)
    abis.append('none')
    result = []

    arches = [ARCH]
    if sys.platform == 'darwin':
        m = re.match('(\w+)_(\d+)_(\d+)_(\w+)$', ARCH)
        if m:
            name, major, minor, arch = m.groups()
            minor = int(minor)
            matches = [arch]
            if arch in ('i386', 'ppc'):
                matches.append('fat')
            if arch in ('i386', 'ppc', 'x86_64'):
                matches.append('fat3')
            if arch in ('ppc64', 'x86_64'):
                matches.append('fat64')
            if arch in ('i386', 'x86_64'):
                matches.append('intel')
            if arch in ('i386', 'x86_64', 'intel', 'ppc', 'ppc64'):
                matches.append('universal')
            while minor >= 0:
                for match in matches:
                    s = '%s_%s_%s_%s' % (name, major, minor, match)
                    if s != ARCH:   # already there
                        arches.append(s)
                minor -= 1

    # Most specific - our Python version, ABI and arch
    for abi in abis:
        for arch in arches:
            result.append((''.join((IMP_PREFIX, versions[0])), abi, arch))

    # where no ABI / arch dependency, but IMP_PREFIX dependency
    for i, version in enumerate(versions):
        result.append((''.join((IMP_PREFIX, version)), 'none', 'any'))
        if i == 0:
            result.append((''.join((IMP_PREFIX, version[0])), 'none', 'any'))

    # no IMP_PREFIX, ABI or arch dependency
    for i, version in enumerate(versions):
        result.append((''.join(('py', version)), 'none', 'any'))
        if i == 0:
            result.append((''.join(('py', version[0])), 'none', 'any'))
    return set(result)


COMPATIBLE_TAGS = compatible_tags()

del compatible_tags


def is_compatible(wheel, tags=None):
    if not isinstance(wheel, Wheel):
        wheel = Wheel(wheel)    # assume it's a filename
    result = False
    if tags is None:
        tags = COMPATIBLE_TAGS
    for ver, abi, arch in tags:
        if ver in wheel.pyver and abi in wheel.abi and arch in wheel.arch:
            result = True
            break
    return result

########NEW FILE########
__FILENAME__ = misc
# -*- coding: utf-8 -*-
#
# Copyright (C) 2012 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""Backports for individual classes and functions."""

import os
import sys

__all__ = ['cache_from_source', 'callable', 'fsencode']


try:
    from imp import cache_from_source
except ImportError:
    def cache_from_source(py_file, debug=__debug__):
        ext = debug and 'c' or 'o'
        return py_file + ext


try:
    callable = callable
except NameError:
    from collections import Callable

    def callable(obj):
        return isinstance(obj, Callable)


try:
    fsencode = os.fsencode
except AttributeError:
    def fsencode(filename):
        if isinstance(filename, bytes):
            return filename
        elif isinstance(filename, str):
            return filename.encode(sys.getfilesystemencoding())
        else:
            raise TypeError("expect bytes or str, not %s" %
                            type(filename).__name__)

########NEW FILE########
__FILENAME__ = shutil
# -*- coding: utf-8 -*-
#
# Copyright (C) 2012 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""Utility functions for copying and archiving files and directory trees.

XXX The functions here don't copy the resource fork or other metadata on Mac.

"""

import os
import sys
import stat
from os.path import abspath
import fnmatch
import collections
import errno
from . import tarfile

try:
    import bz2
    _BZ2_SUPPORTED = True
except ImportError:
    _BZ2_SUPPORTED = False

try:
    from pwd import getpwnam
except ImportError:
    getpwnam = None

try:
    from grp import getgrnam
except ImportError:
    getgrnam = None

__all__ = ["copyfileobj", "copyfile", "copymode", "copystat", "copy", "copy2",
           "copytree", "move", "rmtree", "Error", "SpecialFileError",
           "ExecError", "make_archive", "get_archive_formats",
           "register_archive_format", "unregister_archive_format",
           "get_unpack_formats", "register_unpack_format",
           "unregister_unpack_format", "unpack_archive", "ignore_patterns"]

class Error(EnvironmentError):
    pass

class SpecialFileError(EnvironmentError):
    """Raised when trying to do a kind of operation (e.g. copying) which is
    not supported on a special file (e.g. a named pipe)"""

class ExecError(EnvironmentError):
    """Raised when a command could not be executed"""

class ReadError(EnvironmentError):
    """Raised when an archive cannot be read"""

class RegistryError(Exception):
    """Raised when a registery operation with the archiving
    and unpacking registeries fails"""


try:
    WindowsError
except NameError:
    WindowsError = None

def copyfileobj(fsrc, fdst, length=16*1024):
    """copy data from file-like object fsrc to file-like object fdst"""
    while 1:
        buf = fsrc.read(length)
        if not buf:
            break
        fdst.write(buf)

def _samefile(src, dst):
    # Macintosh, Unix.
    if hasattr(os.path, 'samefile'):
        try:
            return os.path.samefile(src, dst)
        except OSError:
            return False

    # All other platforms: check for same pathname.
    return (os.path.normcase(os.path.abspath(src)) ==
            os.path.normcase(os.path.abspath(dst)))

def copyfile(src, dst):
    """Copy data from src to dst"""
    if _samefile(src, dst):
        raise Error("`%s` and `%s` are the same file" % (src, dst))

    for fn in [src, dst]:
        try:
            st = os.stat(fn)
        except OSError:
            # File most likely does not exist
            pass
        else:
            # XXX What about other special files? (sockets, devices...)
            if stat.S_ISFIFO(st.st_mode):
                raise SpecialFileError("`%s` is a named pipe" % fn)

    with open(src, 'rb') as fsrc:
        with open(dst, 'wb') as fdst:
            copyfileobj(fsrc, fdst)

def copymode(src, dst):
    """Copy mode bits from src to dst"""
    if hasattr(os, 'chmod'):
        st = os.stat(src)
        mode = stat.S_IMODE(st.st_mode)
        os.chmod(dst, mode)

def copystat(src, dst):
    """Copy all stat info (mode bits, atime, mtime, flags) from src to dst"""
    st = os.stat(src)
    mode = stat.S_IMODE(st.st_mode)
    if hasattr(os, 'utime'):
        os.utime(dst, (st.st_atime, st.st_mtime))
    if hasattr(os, 'chmod'):
        os.chmod(dst, mode)
    if hasattr(os, 'chflags') and hasattr(st, 'st_flags'):
        try:
            os.chflags(dst, st.st_flags)
        except OSError as why:
            if (not hasattr(errno, 'EOPNOTSUPP') or
                why.errno != errno.EOPNOTSUPP):
                raise

def copy(src, dst):
    """Copy data and mode bits ("cp src dst").

    The destination may be a directory.

    """
    if os.path.isdir(dst):
        dst = os.path.join(dst, os.path.basename(src))
    copyfile(src, dst)
    copymode(src, dst)

def copy2(src, dst):
    """Copy data and all stat info ("cp -p src dst").

    The destination may be a directory.

    """
    if os.path.isdir(dst):
        dst = os.path.join(dst, os.path.basename(src))
    copyfile(src, dst)
    copystat(src, dst)

def ignore_patterns(*patterns):
    """Function that can be used as copytree() ignore parameter.

    Patterns is a sequence of glob-style patterns
    that are used to exclude files"""
    def _ignore_patterns(path, names):
        ignored_names = []
        for pattern in patterns:
            ignored_names.extend(fnmatch.filter(names, pattern))
        return set(ignored_names)
    return _ignore_patterns

def copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2,
             ignore_dangling_symlinks=False):
    """Recursively copy a directory tree.

    The destination directory must not already exist.
    If exception(s) occur, an Error is raised with a list of reasons.

    If the optional symlinks flag is true, symbolic links in the
    source tree result in symbolic links in the destination tree; if
    it is false, the contents of the files pointed to by symbolic
    links are copied. If the file pointed by the symlink doesn't
    exist, an exception will be added in the list of errors raised in
    an Error exception at the end of the copy process.

    You can set the optional ignore_dangling_symlinks flag to true if you
    want to silence this exception. Notice that this has no effect on
    platforms that don't support os.symlink.

    The optional ignore argument is a callable. If given, it
    is called with the `src` parameter, which is the directory
    being visited by copytree(), and `names` which is the list of
    `src` contents, as returned by os.listdir():

        callable(src, names) -> ignored_names

    Since copytree() is called recursively, the callable will be
    called once for each directory that is copied. It returns a
    list of names relative to the `src` directory that should
    not be copied.

    The optional copy_function argument is a callable that will be used
    to copy each file. It will be called with the source path and the
    destination path as arguments. By default, copy2() is used, but any
    function that supports the same signature (like copy()) can be used.

    """
    names = os.listdir(src)
    if ignore is not None:
        ignored_names = ignore(src, names)
    else:
        ignored_names = set()

    os.makedirs(dst)
    errors = []
    for name in names:
        if name in ignored_names:
            continue
        srcname = os.path.join(src, name)
        dstname = os.path.join(dst, name)
        try:
            if os.path.islink(srcname):
                linkto = os.readlink(srcname)
                if symlinks:
                    os.symlink(linkto, dstname)
                else:
                    # ignore dangling symlink if the flag is on
                    if not os.path.exists(linkto) and ignore_dangling_symlinks:
                        continue
                    # otherwise let the copy occurs. copy2 will raise an error
                    copy_function(srcname, dstname)
            elif os.path.isdir(srcname):
                copytree(srcname, dstname, symlinks, ignore, copy_function)
            else:
                # Will raise a SpecialFileError for unsupported file types
                copy_function(srcname, dstname)
        # catch the Error from the recursive copytree so that we can
        # continue with other files
        except Error as err:
            errors.extend(err.args[0])
        except EnvironmentError as why:
            errors.append((srcname, dstname, str(why)))
    try:
        copystat(src, dst)
    except OSError as why:
        if WindowsError is not None and isinstance(why, WindowsError):
            # Copying file access times may fail on Windows
            pass
        else:
            errors.extend((src, dst, str(why)))
    if errors:
        raise Error(errors)

def rmtree(path, ignore_errors=False, onerror=None):
    """Recursively delete a directory tree.

    If ignore_errors is set, errors are ignored; otherwise, if onerror
    is set, it is called to handle the error with arguments (func,
    path, exc_info) where func is os.listdir, os.remove, or os.rmdir;
    path is the argument to that function that caused it to fail; and
    exc_info is a tuple returned by sys.exc_info().  If ignore_errors
    is false and onerror is None, an exception is raised.

    """
    if ignore_errors:
        def onerror(*args):
            pass
    elif onerror is None:
        def onerror(*args):
            raise
    try:
        if os.path.islink(path):
            # symlinks to directories are forbidden, see bug #1669
            raise OSError("Cannot call rmtree on a symbolic link")
    except OSError:
        onerror(os.path.islink, path, sys.exc_info())
        # can't continue even if onerror hook returns
        return
    names = []
    try:
        names = os.listdir(path)
    except os.error:
        onerror(os.listdir, path, sys.exc_info())
    for name in names:
        fullname = os.path.join(path, name)
        try:
            mode = os.lstat(fullname).st_mode
        except os.error:
            mode = 0
        if stat.S_ISDIR(mode):
            rmtree(fullname, ignore_errors, onerror)
        else:
            try:
                os.remove(fullname)
            except os.error:
                onerror(os.remove, fullname, sys.exc_info())
    try:
        os.rmdir(path)
    except os.error:
        onerror(os.rmdir, path, sys.exc_info())


def _basename(path):
    # A basename() variant which first strips the trailing slash, if present.
    # Thus we always get the last component of the path, even for directories.
    return os.path.basename(path.rstrip(os.path.sep))

def move(src, dst):
    """Recursively move a file or directory to another location. This is
    similar to the Unix "mv" command.

    If the destination is a directory or a symlink to a directory, the source
    is moved inside the directory. The destination path must not already
    exist.

    If the destination already exists but is not a directory, it may be
    overwritten depending on os.rename() semantics.

    If the destination is on our current filesystem, then rename() is used.
    Otherwise, src is copied to the destination and then removed.
    A lot more could be done here...  A look at a mv.c shows a lot of
    the issues this implementation glosses over.

    """
    real_dst = dst
    if os.path.isdir(dst):
        if _samefile(src, dst):
            # We might be on a case insensitive filesystem,
            # perform the rename anyway.
            os.rename(src, dst)
            return

        real_dst = os.path.join(dst, _basename(src))
        if os.path.exists(real_dst):
            raise Error("Destination path '%s' already exists" % real_dst)
    try:
        os.rename(src, real_dst)
    except OSError:
        if os.path.isdir(src):
            if _destinsrc(src, dst):
                raise Error("Cannot move a directory '%s' into itself '%s'." % (src, dst))
            copytree(src, real_dst, symlinks=True)
            rmtree(src)
        else:
            copy2(src, real_dst)
            os.unlink(src)

def _destinsrc(src, dst):
    src = abspath(src)
    dst = abspath(dst)
    if not src.endswith(os.path.sep):
        src += os.path.sep
    if not dst.endswith(os.path.sep):
        dst += os.path.sep
    return dst.startswith(src)

def _get_gid(name):
    """Returns a gid, given a group name."""
    if getgrnam is None or name is None:
        return None
    try:
        result = getgrnam(name)
    except KeyError:
        result = None
    if result is not None:
        return result[2]
    return None

def _get_uid(name):
    """Returns an uid, given a user name."""
    if getpwnam is None or name is None:
        return None
    try:
        result = getpwnam(name)
    except KeyError:
        result = None
    if result is not None:
        return result[2]
    return None

def _make_tarball(base_name, base_dir, compress="gzip", verbose=0, dry_run=0,
                  owner=None, group=None, logger=None):
    """Create a (possibly compressed) tar file from all the files under
    'base_dir'.

    'compress' must be "gzip" (the default), "bzip2", or None.

    'owner' and 'group' can be used to define an owner and a group for the
    archive that is being built. If not provided, the current owner and group
    will be used.

    The output tar file will be named 'base_name' +  ".tar", possibly plus
    the appropriate compression extension (".gz", or ".bz2").

    Returns the output filename.
    """
    tar_compression = {'gzip': 'gz', None: ''}
    compress_ext = {'gzip': '.gz'}

    if _BZ2_SUPPORTED:
        tar_compression['bzip2'] = 'bz2'
        compress_ext['bzip2'] = '.bz2'

    # flags for compression program, each element of list will be an argument
    if compress is not None and compress not in compress_ext:
        raise ValueError("bad value for 'compress', or compression format not "
                         "supported : {0}".format(compress))

    archive_name = base_name + '.tar' + compress_ext.get(compress, '')
    archive_dir = os.path.dirname(archive_name)

    if not os.path.exists(archive_dir):
        if logger is not None:
            logger.info("creating %s", archive_dir)
        if not dry_run:
            os.makedirs(archive_dir)

    # creating the tarball
    if logger is not None:
        logger.info('Creating tar archive')

    uid = _get_uid(owner)
    gid = _get_gid(group)

    def _set_uid_gid(tarinfo):
        if gid is not None:
            tarinfo.gid = gid
            tarinfo.gname = group
        if uid is not None:
            tarinfo.uid = uid
            tarinfo.uname = owner
        return tarinfo

    if not dry_run:
        tar = tarfile.open(archive_name, 'w|%s' % tar_compression[compress])
        try:
            tar.add(base_dir, filter=_set_uid_gid)
        finally:
            tar.close()

    return archive_name

def _call_external_zip(base_dir, zip_filename, verbose=False, dry_run=False):
    # XXX see if we want to keep an external call here
    if verbose:
        zipoptions = "-r"
    else:
        zipoptions = "-rq"
    from distutils.errors import DistutilsExecError
    from distutils.spawn import spawn
    try:
        spawn(["zip", zipoptions, zip_filename, base_dir], dry_run=dry_run)
    except DistutilsExecError:
        # XXX really should distinguish between "couldn't find
        # external 'zip' command" and "zip failed".
        raise ExecError("unable to create zip file '%s': "
            "could neither import the 'zipfile' module nor "
            "find a standalone zip utility") % zip_filename

def _make_zipfile(base_name, base_dir, verbose=0, dry_run=0, logger=None):
    """Create a zip file from all the files under 'base_dir'.

    The output zip file will be named 'base_name' + ".zip".  Uses either the
    "zipfile" Python module (if available) or the InfoZIP "zip" utility
    (if installed and found on the default search path).  If neither tool is
    available, raises ExecError.  Returns the name of the output zip
    file.
    """
    zip_filename = base_name + ".zip"
    archive_dir = os.path.dirname(base_name)

    if not os.path.exists(archive_dir):
        if logger is not None:
            logger.info("creating %s", archive_dir)
        if not dry_run:
            os.makedirs(archive_dir)

    # If zipfile module is not available, try spawning an external 'zip'
    # command.
    try:
        import zipfile
    except ImportError:
        zipfile = None

    if zipfile is None:
        _call_external_zip(base_dir, zip_filename, verbose, dry_run)
    else:
        if logger is not None:
            logger.info("creating '%s' and adding '%s' to it",
                        zip_filename, base_dir)

        if not dry_run:
            zip = zipfile.ZipFile(zip_filename, "w",
                                  compression=zipfile.ZIP_DEFLATED)

            for dirpath, dirnames, filenames in os.walk(base_dir):
                for name in filenames:
                    path = os.path.normpath(os.path.join(dirpath, name))
                    if os.path.isfile(path):
                        zip.write(path, path)
                        if logger is not None:
                            logger.info("adding '%s'", path)
            zip.close()

    return zip_filename

_ARCHIVE_FORMATS = {
    'gztar': (_make_tarball, [('compress', 'gzip')], "gzip'ed tar-file"),
    'bztar': (_make_tarball, [('compress', 'bzip2')], "bzip2'ed tar-file"),
    'tar':   (_make_tarball, [('compress', None)], "uncompressed tar file"),
    'zip':   (_make_zipfile, [], "ZIP file"),
    }

if _BZ2_SUPPORTED:
    _ARCHIVE_FORMATS['bztar'] = (_make_tarball, [('compress', 'bzip2')],
                                "bzip2'ed tar-file")

def get_archive_formats():
    """Returns a list of supported formats for archiving and unarchiving.

    Each element of the returned sequence is a tuple (name, description)
    """
    formats = [(name, registry[2]) for name, registry in
               _ARCHIVE_FORMATS.items()]
    formats.sort()
    return formats

def register_archive_format(name, function, extra_args=None, description=''):
    """Registers an archive format.

    name is the name of the format. function is the callable that will be
    used to create archives. If provided, extra_args is a sequence of
    (name, value) tuples that will be passed as arguments to the callable.
    description can be provided to describe the format, and will be returned
    by the get_archive_formats() function.
    """
    if extra_args is None:
        extra_args = []
    if not isinstance(function, collections.Callable):
        raise TypeError('The %s object is not callable' % function)
    if not isinstance(extra_args, (tuple, list)):
        raise TypeError('extra_args needs to be a sequence')
    for element in extra_args:
        if not isinstance(element, (tuple, list)) or len(element) !=2:
            raise TypeError('extra_args elements are : (arg_name, value)')

    _ARCHIVE_FORMATS[name] = (function, extra_args, description)

def unregister_archive_format(name):
    del _ARCHIVE_FORMATS[name]

def make_archive(base_name, format, root_dir=None, base_dir=None, verbose=0,
                 dry_run=0, owner=None, group=None, logger=None):
    """Create an archive file (eg. zip or tar).

    'base_name' is the name of the file to create, minus any format-specific
    extension; 'format' is the archive format: one of "zip", "tar", "bztar"
    or "gztar".

    'root_dir' is a directory that will be the root directory of the
    archive; ie. we typically chdir into 'root_dir' before creating the
    archive.  'base_dir' is the directory where we start archiving from;
    ie. 'base_dir' will be the common prefix of all files and
    directories in the archive.  'root_dir' and 'base_dir' both default
    to the current directory.  Returns the name of the archive file.

    'owner' and 'group' are used when creating a tar archive. By default,
    uses the current owner and group.
    """
    save_cwd = os.getcwd()
    if root_dir is not None:
        if logger is not None:
            logger.debug("changing into '%s'", root_dir)
        base_name = os.path.abspath(base_name)
        if not dry_run:
            os.chdir(root_dir)

    if base_dir is None:
        base_dir = os.curdir

    kwargs = {'dry_run': dry_run, 'logger': logger}

    try:
        format_info = _ARCHIVE_FORMATS[format]
    except KeyError:
        raise ValueError("unknown archive format '%s'" % format)

    func = format_info[0]
    for arg, val in format_info[1]:
        kwargs[arg] = val

    if format != 'zip':
        kwargs['owner'] = owner
        kwargs['group'] = group

    try:
        filename = func(base_name, base_dir, **kwargs)
    finally:
        if root_dir is not None:
            if logger is not None:
                logger.debug("changing back to '%s'", save_cwd)
            os.chdir(save_cwd)

    return filename


def get_unpack_formats():
    """Returns a list of supported formats for unpacking.

    Each element of the returned sequence is a tuple
    (name, extensions, description)
    """
    formats = [(name, info[0], info[3]) for name, info in
               _UNPACK_FORMATS.items()]
    formats.sort()
    return formats

def _check_unpack_options(extensions, function, extra_args):
    """Checks what gets registered as an unpacker."""
    # first make sure no other unpacker is registered for this extension
    existing_extensions = {}
    for name, info in _UNPACK_FORMATS.items():
        for ext in info[0]:
            existing_extensions[ext] = name

    for extension in extensions:
        if extension in existing_extensions:
            msg = '%s is already registered for "%s"'
            raise RegistryError(msg % (extension,
                                       existing_extensions[extension]))

    if not isinstance(function, collections.Callable):
        raise TypeError('The registered function must be a callable')


def register_unpack_format(name, extensions, function, extra_args=None,
                           description=''):
    """Registers an unpack format.

    `name` is the name of the format. `extensions` is a list of extensions
    corresponding to the format.

    `function` is the callable that will be
    used to unpack archives. The callable will receive archives to unpack.
    If it's unable to handle an archive, it needs to raise a ReadError
    exception.

    If provided, `extra_args` is a sequence of
    (name, value) tuples that will be passed as arguments to the callable.
    description can be provided to describe the format, and will be returned
    by the get_unpack_formats() function.
    """
    if extra_args is None:
        extra_args = []
    _check_unpack_options(extensions, function, extra_args)
    _UNPACK_FORMATS[name] = extensions, function, extra_args, description

def unregister_unpack_format(name):
    """Removes the pack format from the registery."""
    del _UNPACK_FORMATS[name]

def _ensure_directory(path):
    """Ensure that the parent directory of `path` exists"""
    dirname = os.path.dirname(path)
    if not os.path.isdir(dirname):
        os.makedirs(dirname)

def _unpack_zipfile(filename, extract_dir):
    """Unpack zip `filename` to `extract_dir`
    """
    try:
        import zipfile
    except ImportError:
        raise ReadError('zlib not supported, cannot unpack this archive.')

    if not zipfile.is_zipfile(filename):
        raise ReadError("%s is not a zip file" % filename)

    zip = zipfile.ZipFile(filename)
    try:
        for info in zip.infolist():
            name = info.filename

            # don't extract absolute paths or ones with .. in them
            if name.startswith('/') or '..' in name:
                continue

            target = os.path.join(extract_dir, *name.split('/'))
            if not target:
                continue

            _ensure_directory(target)
            if not name.endswith('/'):
                # file
                data = zip.read(info.filename)
                f = open(target, 'wb')
                try:
                    f.write(data)
                finally:
                    f.close()
                    del data
    finally:
        zip.close()

def _unpack_tarfile(filename, extract_dir):
    """Unpack tar/tar.gz/tar.bz2 `filename` to `extract_dir`
    """
    try:
        tarobj = tarfile.open(filename)
    except tarfile.TarError:
        raise ReadError(
            "%s is not a compressed or uncompressed tar file" % filename)
    try:
        tarobj.extractall(extract_dir)
    finally:
        tarobj.close()

_UNPACK_FORMATS = {
    'gztar': (['.tar.gz', '.tgz'], _unpack_tarfile, [], "gzip'ed tar-file"),
    'tar':   (['.tar'], _unpack_tarfile, [], "uncompressed tar file"),
    'zip':   (['.zip'], _unpack_zipfile, [], "ZIP file")
    }

if _BZ2_SUPPORTED:
    _UNPACK_FORMATS['bztar'] = (['.bz2'], _unpack_tarfile, [],
                                "bzip2'ed tar-file")

def _find_unpack_format(filename):
    for name, info in _UNPACK_FORMATS.items():
        for extension in info[0]:
            if filename.endswith(extension):
                return name
    return None

def unpack_archive(filename, extract_dir=None, format=None):
    """Unpack an archive.

    `filename` is the name of the archive.

    `extract_dir` is the name of the target directory, where the archive
    is unpacked. If not provided, the current working directory is used.

    `format` is the archive format: one of "zip", "tar", or "gztar". Or any
    other registered format. If not provided, unpack_archive will use the
    filename extension and see if an unpacker was registered for that
    extension.

    In case none is found, a ValueError is raised.
    """
    if extract_dir is None:
        extract_dir = os.getcwd()

    if format is not None:
        try:
            format_info = _UNPACK_FORMATS[format]
        except KeyError:
            raise ValueError("Unknown unpack format '{0}'".format(format))

        func = format_info[1]
        func(filename, extract_dir, **dict(format_info[2]))
    else:
        # we need to look at the registered unpackers supported extensions
        format = _find_unpack_format(filename)
        if format is None:
            raise ReadError("Unknown archive format '{0}'".format(filename))

        func = _UNPACK_FORMATS[format][1]
        kwargs = dict(_UNPACK_FORMATS[format][2])
        func(filename, extract_dir, **kwargs)

########NEW FILE########
__FILENAME__ = sysconfig
# -*- coding: utf-8 -*-
#
# Copyright (C) 2012 The Python Software Foundation.
# See LICENSE.txt and CONTRIBUTORS.txt.
#
"""Access to Python's configuration information."""

import codecs
import os
import re
import sys
from os.path import pardir, realpath
try:
    import configparser
except ImportError:
    import ConfigParser as configparser


__all__ = [
    'get_config_h_filename',
    'get_config_var',
    'get_config_vars',
    'get_makefile_filename',
    'get_path',
    'get_path_names',
    'get_paths',
    'get_platform',
    'get_python_version',
    'get_scheme_names',
    'parse_config_h',
]


def _safe_realpath(path):
    try:
        return realpath(path)
    except OSError:
        return path


if sys.executable:
    _PROJECT_BASE = os.path.dirname(_safe_realpath(sys.executable))
else:
    # sys.executable can be empty if argv[0] has been changed and Python is
    # unable to retrieve the real program name
    _PROJECT_BASE = _safe_realpath(os.getcwd())

if os.name == "nt" and "pcbuild" in _PROJECT_BASE[-8:].lower():
    _PROJECT_BASE = _safe_realpath(os.path.join(_PROJECT_BASE, pardir))
# PC/VS7.1
if os.name == "nt" and "\\pc\\v" in _PROJECT_BASE[-10:].lower():
    _PROJECT_BASE = _safe_realpath(os.path.join(_PROJECT_BASE, pardir, pardir))
# PC/AMD64
if os.name == "nt" and "\\pcbuild\\amd64" in _PROJECT_BASE[-14:].lower():
    _PROJECT_BASE = _safe_realpath(os.path.join(_PROJECT_BASE, pardir, pardir))


def is_python_build():
    for fn in ("Setup.dist", "Setup.local"):
        if os.path.isfile(os.path.join(_PROJECT_BASE, "Modules", fn)):
            return True
    return False

_PYTHON_BUILD = is_python_build()

_cfg_read = False

def _ensure_cfg_read():
    global _cfg_read
    if not _cfg_read:
        from ..resources import finder
        backport_package = __name__.rsplit('.', 1)[0]
        _finder = finder(backport_package)
        _cfgfile = _finder.find('sysconfig.cfg')
        assert _cfgfile, 'sysconfig.cfg exists'
        with _cfgfile.as_stream() as s:
            _SCHEMES.readfp(s)
        if _PYTHON_BUILD:
            for scheme in ('posix_prefix', 'posix_home'):
                _SCHEMES.set(scheme, 'include', '{srcdir}/Include')
                _SCHEMES.set(scheme, 'platinclude', '{projectbase}/.')

        _cfg_read = True


_SCHEMES = configparser.RawConfigParser()
_VAR_REPL = re.compile(r'\{([^{]*?)\}')

def _expand_globals(config):
    _ensure_cfg_read()
    if config.has_section('globals'):
        globals = config.items('globals')
    else:
        globals = tuple()

    sections = config.sections()
    for section in sections:
        if section == 'globals':
            continue
        for option, value in globals:
            if config.has_option(section, option):
                continue
            config.set(section, option, value)
    config.remove_section('globals')

    # now expanding local variables defined in the cfg file
    #
    for section in config.sections():
        variables = dict(config.items(section))

        def _replacer(matchobj):
            name = matchobj.group(1)
            if name in variables:
                return variables[name]
            return matchobj.group(0)

        for option, value in config.items(section):
            config.set(section, option, _VAR_REPL.sub(_replacer, value))

#_expand_globals(_SCHEMES)

 # FIXME don't rely on sys.version here, its format is an implementation detail
 # of CPython, use sys.version_info or sys.hexversion
_PY_VERSION = sys.version.split()[0]
_PY_VERSION_SHORT = sys.version[:3]
_PY_VERSION_SHORT_NO_DOT = _PY_VERSION[0] + _PY_VERSION[2]
_PREFIX = os.path.normpath(sys.prefix)
_EXEC_PREFIX = os.path.normpath(sys.exec_prefix)
_CONFIG_VARS = None
_USER_BASE = None


def _subst_vars(path, local_vars):
    """In the string `path`, replace tokens like {some.thing} with the
    corresponding value from the map `local_vars`.

    If there is no corresponding value, leave the token unchanged.
    """
    def _replacer(matchobj):
        name = matchobj.group(1)
        if name in local_vars:
            return local_vars[name]
        elif name in os.environ:
            return os.environ[name]
        return matchobj.group(0)
    return _VAR_REPL.sub(_replacer, path)


def _extend_dict(target_dict, other_dict):
    target_keys = target_dict.keys()
    for key, value in other_dict.items():
        if key in target_keys:
            continue
        target_dict[key] = value


def _expand_vars(scheme, vars):
    res = {}
    if vars is None:
        vars = {}
    _extend_dict(vars, get_config_vars())

    for key, value in _SCHEMES.items(scheme):
        if os.name in ('posix', 'nt'):
            value = os.path.expanduser(value)
        res[key] = os.path.normpath(_subst_vars(value, vars))
    return res


def format_value(value, vars):
    def _replacer(matchobj):
        name = matchobj.group(1)
        if name in vars:
            return vars[name]
        return matchobj.group(0)
    return _VAR_REPL.sub(_replacer, value)


def _get_default_scheme():
    if os.name == 'posix':
        # the default scheme for posix is posix_prefix
        return 'posix_prefix'
    return os.name


def _getuserbase():
    env_base = os.environ.get("PYTHONUSERBASE", None)

    def joinuser(*args):
        return os.path.expanduser(os.path.join(*args))

    # what about 'os2emx', 'riscos' ?
    if os.name == "nt":
        base = os.environ.get("APPDATA") or "~"
        if env_base:
            return env_base
        else:
            return joinuser(base, "Python")

    if sys.platform == "darwin":
        framework = get_config_var("PYTHONFRAMEWORK")
        if framework:
            if env_base:
                return env_base
            else:
                return joinuser("~", "Library", framework, "%d.%d" %
                                sys.version_info[:2])

    if env_base:
        return env_base
    else:
        return joinuser("~", ".local")


def _parse_makefile(filename, vars=None):
    """Parse a Makefile-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    """
    # Regexes needed for parsing Makefile (and similar syntaxes,
    # like old-style Setup files).
    _variable_rx = re.compile("([a-zA-Z][a-zA-Z0-9_]+)\s*=\s*(.*)")
    _findvar1_rx = re.compile(r"\$\(([A-Za-z][A-Za-z0-9_]*)\)")
    _findvar2_rx = re.compile(r"\${([A-Za-z][A-Za-z0-9_]*)}")

    if vars is None:
        vars = {}
    done = {}
    notdone = {}

    with codecs.open(filename, encoding='utf-8', errors="surrogateescape") as f:
        lines = f.readlines()

    for line in lines:
        if line.startswith('#') or line.strip() == '':
            continue
        m = _variable_rx.match(line)
        if m:
            n, v = m.group(1, 2)
            v = v.strip()
            # `$$' is a literal `$' in make
            tmpv = v.replace('$$', '')

            if "$" in tmpv:
                notdone[n] = v
            else:
                try:
                    v = int(v)
                except ValueError:
                    # insert literal `$'
                    done[n] = v.replace('$$', '$')
                else:
                    done[n] = v

    # do variable interpolation here
    variables = list(notdone.keys())

    # Variables with a 'PY_' prefix in the makefile. These need to
    # be made available without that prefix through sysconfig.
    # Special care is needed to ensure that variable expansion works, even
    # if the expansion uses the name without a prefix.
    renamed_variables = ('CFLAGS', 'LDFLAGS', 'CPPFLAGS')

    while len(variables) > 0:
        for name in tuple(variables):
            value = notdone[name]
            m = _findvar1_rx.search(value) or _findvar2_rx.search(value)
            if m is not None:
                n = m.group(1)
                found = True
                if n in done:
                    item = str(done[n])
                elif n in notdone:
                    # get it on a subsequent round
                    found = False
                elif n in os.environ:
                    # do it like make: fall back to environment
                    item = os.environ[n]

                elif n in renamed_variables:
                    if (name.startswith('PY_') and
                        name[3:] in renamed_variables):
                        item = ""

                    elif 'PY_' + n in notdone:
                        found = False

                    else:
                        item = str(done['PY_' + n])

                else:
                    done[n] = item = ""

                if found:
                    after = value[m.end():]
                    value = value[:m.start()] + item + after
                    if "$" in after:
                        notdone[name] = value
                    else:
                        try:
                            value = int(value)
                        except ValueError:
                            done[name] = value.strip()
                        else:
                            done[name] = value
                        variables.remove(name)

                        if (name.startswith('PY_') and
                            name[3:] in renamed_variables):

                            name = name[3:]
                            if name not in done:
                                done[name] = value

            else:
                # bogus variable reference (e.g. "prefix=$/opt/python");
                # just drop it since we can't deal
                done[name] = value
                variables.remove(name)

    # strip spurious spaces
    for k, v in done.items():
        if isinstance(v, str):
            done[k] = v.strip()

    # save the results in the global dictionary
    vars.update(done)
    return vars


def get_makefile_filename():
    """Return the path of the Makefile."""
    if _PYTHON_BUILD:
        return os.path.join(_PROJECT_BASE, "Makefile")
    if hasattr(sys, 'abiflags'):
        config_dir_name = 'config-%s%s' % (_PY_VERSION_SHORT, sys.abiflags)
    else:
        config_dir_name = 'config'
    return os.path.join(get_path('stdlib'), config_dir_name, 'Makefile')


def _init_posix(vars):
    """Initialize the module as appropriate for POSIX systems."""
    # load the installed Makefile:
    makefile = get_makefile_filename()
    try:
        _parse_makefile(makefile, vars)
    except IOError as e:
        msg = "invalid Python installation: unable to open %s" % makefile
        if hasattr(e, "strerror"):
            msg = msg + " (%s)" % e.strerror
        raise IOError(msg)
    # load the installed pyconfig.h:
    config_h = get_config_h_filename()
    try:
        with open(config_h) as f:
            parse_config_h(f, vars)
    except IOError as e:
        msg = "invalid Python installation: unable to open %s" % config_h
        if hasattr(e, "strerror"):
            msg = msg + " (%s)" % e.strerror
        raise IOError(msg)
    # On AIX, there are wrong paths to the linker scripts in the Makefile
    # -- these paths are relative to the Python source, but when installed
    # the scripts are in another directory.
    if _PYTHON_BUILD:
        vars['LDSHARED'] = vars['BLDSHARED']


def _init_non_posix(vars):
    """Initialize the module as appropriate for NT"""
    # set basic install directories
    vars['LIBDEST'] = get_path('stdlib')
    vars['BINLIBDEST'] = get_path('platstdlib')
    vars['INCLUDEPY'] = get_path('include')
    vars['SO'] = '.pyd'
    vars['EXE'] = '.exe'
    vars['VERSION'] = _PY_VERSION_SHORT_NO_DOT
    vars['BINDIR'] = os.path.dirname(_safe_realpath(sys.executable))

#
# public APIs
#


def parse_config_h(fp, vars=None):
    """Parse a config.h-style file.

    A dictionary containing name/value pairs is returned.  If an
    optional dictionary is passed in as the second argument, it is
    used instead of a new dictionary.
    """
    if vars is None:
        vars = {}
    define_rx = re.compile("#define ([A-Z][A-Za-z0-9_]+) (.*)\n")
    undef_rx = re.compile("/[*] #undef ([A-Z][A-Za-z0-9_]+) [*]/\n")

    while True:
        line = fp.readline()
        if not line:
            break
        m = define_rx.match(line)
        if m:
            n, v = m.group(1, 2)
            try:
                v = int(v)
            except ValueError:
                pass
            vars[n] = v
        else:
            m = undef_rx.match(line)
            if m:
                vars[m.group(1)] = 0
    return vars


def get_config_h_filename():
    """Return the path of pyconfig.h."""
    if _PYTHON_BUILD:
        if os.name == "nt":
            inc_dir = os.path.join(_PROJECT_BASE, "PC")
        else:
            inc_dir = _PROJECT_BASE
    else:
        inc_dir = get_path('platinclude')
    return os.path.join(inc_dir, 'pyconfig.h')


def get_scheme_names():
    """Return a tuple containing the schemes names."""
    return tuple(sorted(_SCHEMES.sections()))


def get_path_names():
    """Return a tuple containing the paths names."""
    # xxx see if we want a static list
    return _SCHEMES.options('posix_prefix')


def get_paths(scheme=_get_default_scheme(), vars=None, expand=True):
    """Return a mapping containing an install scheme.

    ``scheme`` is the install scheme name. If not provided, it will
    return the default scheme for the current platform.
    """
    _ensure_cfg_read()
    if expand:
        return _expand_vars(scheme, vars)
    else:
        return dict(_SCHEMES.items(scheme))


def get_path(name, scheme=_get_default_scheme(), vars=None, expand=True):
    """Return a path corresponding to the scheme.

    ``scheme`` is the install scheme name.
    """
    return get_paths(scheme, vars, expand)[name]


def get_config_vars(*args):
    """With no arguments, return a dictionary of all configuration
    variables relevant for the current platform.

    On Unix, this means every variable defined in Python's installed Makefile;
    On Windows and Mac OS it's a much smaller set.

    With arguments, return a list of values that result from looking up
    each argument in the configuration variable dictionary.
    """
    global _CONFIG_VARS
    if _CONFIG_VARS is None:
        _CONFIG_VARS = {}
        # Normalized versions of prefix and exec_prefix are handy to have;
        # in fact, these are the standard versions used most places in the
        # distutils2 module.
        _CONFIG_VARS['prefix'] = _PREFIX
        _CONFIG_VARS['exec_prefix'] = _EXEC_PREFIX
        _CONFIG_VARS['py_version'] = _PY_VERSION
        _CONFIG_VARS['py_version_short'] = _PY_VERSION_SHORT
        _CONFIG_VARS['py_version_nodot'] = _PY_VERSION[0] + _PY_VERSION[2]
        _CONFIG_VARS['base'] = _PREFIX
        _CONFIG_VARS['platbase'] = _EXEC_PREFIX
        _CONFIG_VARS['projectbase'] = _PROJECT_BASE
        try:
            _CONFIG_VARS['abiflags'] = sys.abiflags
        except AttributeError:
            # sys.abiflags may not be defined on all platforms.
            _CONFIG_VARS['abiflags'] = ''

        if os.name in ('nt', 'os2'):
            _init_non_posix(_CONFIG_VARS)
        if os.name == 'posix':
            _init_posix(_CONFIG_VARS)
        # Setting 'userbase' is done below the call to the
        # init function to enable using 'get_config_var' in
        # the init-function.
        if sys.version >= '2.6':
            _CONFIG_VARS['userbase'] = _getuserbase()

        if 'srcdir' not in _CONFIG_VARS:
            _CONFIG_VARS['srcdir'] = _PROJECT_BASE
        else:
            _CONFIG_VARS['srcdir'] = _safe_realpath(_CONFIG_VARS['srcdir'])

        # Convert srcdir into an absolute path if it appears necessary.
        # Normally it is relative to the build directory.  However, during
        # testing, for example, we might be running a non-installed python
        # from a different directory.
        if _PYTHON_BUILD and os.name == "posix":
            base = _PROJECT_BASE
            try:
                cwd = os.getcwd()
            except OSError:
                cwd = None
            if (not os.path.isabs(_CONFIG_VARS['srcdir']) and
                base != cwd):
                # srcdir is relative and we are not in the same directory
                # as the executable. Assume executable is in the build
                # directory and make srcdir absolute.
                srcdir = os.path.join(base, _CONFIG_VARS['srcdir'])
                _CONFIG_VARS['srcdir'] = os.path.normpath(srcdir)

        if sys.platform == 'darwin':
            kernel_version = os.uname()[2]  # Kernel version (8.4.3)
            major_version = int(kernel_version.split('.')[0])

            if major_version < 8:
                # On Mac OS X before 10.4, check if -arch and -isysroot
                # are in CFLAGS or LDFLAGS and remove them if they are.
                # This is needed when building extensions on a 10.3 system
                # using a universal build of python.
                for key in ('LDFLAGS', 'BASECFLAGS',
                        # a number of derived variables. These need to be
                        # patched up as well.
                        'CFLAGS', 'PY_CFLAGS', 'BLDSHARED'):
                    flags = _CONFIG_VARS[key]
                    flags = re.sub('-arch\s+\w+\s', ' ', flags)
                    flags = re.sub('-isysroot [^ \t]*', ' ', flags)
                    _CONFIG_VARS[key] = flags
            else:
                # Allow the user to override the architecture flags using
                # an environment variable.
                # NOTE: This name was introduced by Apple in OSX 10.5 and
                # is used by several scripting languages distributed with
                # that OS release.
                if 'ARCHFLAGS' in os.environ:
                    arch = os.environ['ARCHFLAGS']
                    for key in ('LDFLAGS', 'BASECFLAGS',
                        # a number of derived variables. These need to be
                        # patched up as well.
                        'CFLAGS', 'PY_CFLAGS', 'BLDSHARED'):

                        flags = _CONFIG_VARS[key]
                        flags = re.sub('-arch\s+\w+\s', ' ', flags)
                        flags = flags + ' ' + arch
                        _CONFIG_VARS[key] = flags

                # If we're on OSX 10.5 or later and the user tries to
                # compiles an extension using an SDK that is not present
                # on the current machine it is better to not use an SDK
                # than to fail.
                #
                # The major usecase for this is users using a Python.org
                # binary installer  on OSX 10.6: that installer uses
                # the 10.4u SDK, but that SDK is not installed by default
                # when you install Xcode.
                #
                CFLAGS = _CONFIG_VARS.get('CFLAGS', '')
                m = re.search('-isysroot\s+(\S+)', CFLAGS)
                if m is not None:
                    sdk = m.group(1)
                    if not os.path.exists(sdk):
                        for key in ('LDFLAGS', 'BASECFLAGS',
                             # a number of derived variables. These need to be
                             # patched up as well.
                            'CFLAGS', 'PY_CFLAGS', 'BLDSHARED'):

                            flags = _CONFIG_VARS[key]
                            flags = re.sub('-isysroot\s+\S+(\s|$)', ' ', flags)
                            _CONFIG_VARS[key] = flags

    if args:
        vals = []
        for name in args:
            vals.append(_CONFIG_VARS.get(name))
        return vals
    else:
        return _CONFIG_VARS


def get_config_var(name):
    """Return the value of a single variable using the dictionary returned by
    'get_config_vars()'.

    Equivalent to get_config_vars().get(name)
    """
    return get_config_vars().get(name)


def get_platform():
    """Return a string that identifies the current platform.

    This is used mainly to distinguish platform-specific build directories and
    platform-specific built distributions.  Typically includes the OS name
    and version and the architecture (as supplied by 'os.uname()'),
    although the exact information included depends on the OS; eg. for IRIX
    the architecture isn't particularly important (IRIX only runs on SGI
    hardware), but for Linux the kernel version isn't particularly
    important.

    Examples of returned values:
       linux-i586
       linux-alpha (?)
       solaris-2.6-sun4u
       irix-5.3
       irix64-6.2

    Windows will return one of:
       win-amd64 (64bit Windows on AMD64 (aka x86_64, Intel64, EM64T, etc)
       win-ia64 (64bit Windows on Itanium)
       win32 (all others - specifically, sys.platform is returned)

    For other non-POSIX platforms, currently just returns 'sys.platform'.
    """
    if os.name == 'nt':
        # sniff sys.version for architecture.
        prefix = " bit ("
        i = sys.version.find(prefix)
        if i == -1:
            return sys.platform
        j = sys.version.find(")", i)
        look = sys.version[i+len(prefix):j].lower()
        if look == 'amd64':
            return 'win-amd64'
        if look == 'itanium':
            return 'win-ia64'
        return sys.platform

    if os.name != "posix" or not hasattr(os, 'uname'):
        # XXX what about the architecture? NT is Intel or Alpha,
        # Mac OS is M68k or PPC, etc.
        return sys.platform

    # Try to distinguish various flavours of Unix
    osname, host, release, version, machine = os.uname()

    # Convert the OS name to lowercase, remove '/' characters
    # (to accommodate BSD/OS), and translate spaces (for "Power Macintosh")
    osname = osname.lower().replace('/', '')
    machine = machine.replace(' ', '_')
    machine = machine.replace('/', '-')

    if osname[:5] == "linux":
        # At least on Linux/Intel, 'machine' is the processor --
        # i386, etc.
        # XXX what about Alpha, SPARC, etc?
        return  "%s-%s" % (osname, machine)
    elif osname[:5] == "sunos":
        if release[0] >= "5":           # SunOS 5 == Solaris 2
            osname = "solaris"
            release = "%d.%s" % (int(release[0]) - 3, release[2:])
        # fall through to standard osname-release-machine representation
    elif osname[:4] == "irix":              # could be "irix64"!
        return "%s-%s" % (osname, release)
    elif osname[:3] == "aix":
        return "%s-%s.%s" % (osname, version, release)
    elif osname[:6] == "cygwin":
        osname = "cygwin"
        rel_re = re.compile(r'[\d.]+')
        m = rel_re.match(release)
        if m:
            release = m.group()
    elif osname[:6] == "darwin":
        #
        # For our purposes, we'll assume that the system version from
        # distutils' perspective is what MACOSX_DEPLOYMENT_TARGET is set
        # to. This makes the compatibility story a bit more sane because the
        # machine is going to compile and link as if it were
        # MACOSX_DEPLOYMENT_TARGET.
        cfgvars = get_config_vars()
        macver = cfgvars.get('MACOSX_DEPLOYMENT_TARGET')

        if True:
            # Always calculate the release of the running machine,
            # needed to determine if we can build fat binaries or not.

            macrelease = macver
            # Get the system version. Reading this plist is a documented
            # way to get the system version (see the documentation for
            # the Gestalt Manager)
            try:
                f = open('/System/Library/CoreServices/SystemVersion.plist')
            except IOError:
                # We're on a plain darwin box, fall back to the default
                # behaviour.
                pass
            else:
                try:
                    m = re.search(r'<key>ProductUserVisibleVersion</key>\s*'
                                  r'<string>(.*?)</string>', f.read())
                finally:
                    f.close()
                if m is not None:
                    macrelease = '.'.join(m.group(1).split('.')[:2])
                # else: fall back to the default behaviour

        if not macver:
            macver = macrelease

        if macver:
            release = macver
            osname = "macosx"

            if ((macrelease + '.') >= '10.4.' and
                '-arch' in get_config_vars().get('CFLAGS', '').strip()):
                # The universal build will build fat binaries, but not on
                # systems before 10.4
                #
                # Try to detect 4-way universal builds, those have machine-type
                # 'universal' instead of 'fat'.

                machine = 'fat'
                cflags = get_config_vars().get('CFLAGS')

                archs = re.findall('-arch\s+(\S+)', cflags)
                archs = tuple(sorted(set(archs)))

                if len(archs) == 1:
                    machine = archs[0]
                elif archs == ('i386', 'ppc'):
                    machine = 'fat'
                elif archs == ('i386', 'x86_64'):
                    machine = 'intel'
                elif archs == ('i386', 'ppc', 'x86_64'):
                    machine = 'fat3'
                elif archs == ('ppc64', 'x86_64'):
                    machine = 'fat64'
                elif archs == ('i386', 'ppc', 'ppc64', 'x86_64'):
                    machine = 'universal'
                else:
                    raise ValueError(
                       "Don't know machine value for archs=%r" % (archs,))

            elif machine == 'i386':
                # On OSX the machine type returned by uname is always the
                # 32-bit variant, even if the executable architecture is
                # the 64-bit variant
                if sys.maxsize >= 2**32:
                    machine = 'x86_64'

            elif machine in ('PowerPC', 'Power_Macintosh'):
                # Pick a sane name for the PPC architecture.
                # See 'i386' case
                if sys.maxsize >= 2**32:
                    machine = 'ppc64'
                else:
                    machine = 'ppc'

    return "%s-%s-%s" % (osname, release, machine)


def get_python_version():
    return _PY_VERSION_SHORT


def _print_dict(title, data):
    for index, (key, value) in enumerate(sorted(data.items())):
        if index == 0:
            print('%s: ' % (title))
        print('\t%s = "%s"' % (key, value))


def _main():
    """Display all information sysconfig detains."""
    print('Platform: "%s"' % get_platform())
    print('Python version: "%s"' % get_python_version())
    print('Current installation scheme: "%s"' % _get_default_scheme())
    print()
    _print_dict('Paths', get_paths())
    print()
    _print_dict('Variables', get_config_vars())


if __name__ == '__main__':
    _main()

########NEW FILE########
__FILENAME__ = tarfile
#-------------------------------------------------------------------
# tarfile.py
#-------------------------------------------------------------------
# Copyright (C) 2002 Lars Gustaebel <lars@gustaebel.de>
# All rights reserved.
#
# Permission  is  hereby granted,  free  of charge,  to  any person
# obtaining a  copy of  this software  and associated documentation
# files  (the  "Software"),  to   deal  in  the  Software   without
# restriction,  including  without limitation  the  rights to  use,
# copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies  of  the  Software,  and to  permit  persons  to  whom the
# Software  is  furnished  to  do  so,  subject  to  the  following
# conditions:
#
# The above copyright  notice and this  permission notice shall  be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS  IS", WITHOUT WARRANTY OF ANY  KIND,
# EXPRESS OR IMPLIED, INCLUDING  BUT NOT LIMITED TO  THE WARRANTIES
# OF  MERCHANTABILITY,  FITNESS   FOR  A  PARTICULAR   PURPOSE  AND
# NONINFRINGEMENT.  IN  NO  EVENT SHALL  THE  AUTHORS  OR COPYRIGHT
# HOLDERS  BE LIABLE  FOR ANY  CLAIM, DAMAGES  OR OTHER  LIABILITY,
# WHETHER  IN AN  ACTION OF  CONTRACT, TORT  OR OTHERWISE,  ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
from __future__ import print_function

"""Read from and write to tar format archives.
"""

__version__ = "$Revision$"

version     = "0.9.0"
__author__  = "Lars Gust\u00e4bel (lars@gustaebel.de)"
__date__    = "$Date: 2011-02-25 17:42:01 +0200 (Fri, 25 Feb 2011) $"
__cvsid__   = "$Id: tarfile.py 88586 2011-02-25 15:42:01Z marc-andre.lemburg $"
__credits__ = "Gustavo Niemeyer, Niels Gust\u00e4bel, Richard Townsend."

#---------
# Imports
#---------
import sys
import os
import stat
import errno
import time
import struct
import copy
import re

try:
    import grp, pwd
except ImportError:
    grp = pwd = None

# os.symlink on Windows prior to 6.0 raises NotImplementedError
symlink_exception = (AttributeError, NotImplementedError)
try:
    # WindowsError (1314) will be raised if the caller does not hold the
    # SeCreateSymbolicLinkPrivilege privilege
    symlink_exception += (WindowsError,)
except NameError:
    pass

# from tarfile import *
__all__ = ["TarFile", "TarInfo", "is_tarfile", "TarError"]

if sys.version_info[0] < 3:
    import __builtin__ as builtins
else:
    import builtins

_open = builtins.open   # Since 'open' is TarFile.open

#---------------------------------------------------------
# tar constants
#---------------------------------------------------------
NUL = b"\0"                     # the null character
BLOCKSIZE = 512                 # length of processing blocks
RECORDSIZE = BLOCKSIZE * 20     # length of records
GNU_MAGIC = b"ustar  \0"        # magic gnu tar string
POSIX_MAGIC = b"ustar\x0000"    # magic posix tar string

LENGTH_NAME = 100               # maximum length of a filename
LENGTH_LINK = 100               # maximum length of a linkname
LENGTH_PREFIX = 155             # maximum length of the prefix field

REGTYPE = b"0"                  # regular file
AREGTYPE = b"\0"                # regular file
LNKTYPE = b"1"                  # link (inside tarfile)
SYMTYPE = b"2"                  # symbolic link
CHRTYPE = b"3"                  # character special device
BLKTYPE = b"4"                  # block special device
DIRTYPE = b"5"                  # directory
FIFOTYPE = b"6"                 # fifo special device
CONTTYPE = b"7"                 # contiguous file

GNUTYPE_LONGNAME = b"L"         # GNU tar longname
GNUTYPE_LONGLINK = b"K"         # GNU tar longlink
GNUTYPE_SPARSE = b"S"           # GNU tar sparse file

XHDTYPE = b"x"                  # POSIX.1-2001 extended header
XGLTYPE = b"g"                  # POSIX.1-2001 global header
SOLARIS_XHDTYPE = b"X"          # Solaris extended header

USTAR_FORMAT = 0                # POSIX.1-1988 (ustar) format
GNU_FORMAT = 1                  # GNU tar format
PAX_FORMAT = 2                  # POSIX.1-2001 (pax) format
DEFAULT_FORMAT = GNU_FORMAT

#---------------------------------------------------------
# tarfile constants
#---------------------------------------------------------
# File types that tarfile supports:
SUPPORTED_TYPES = (REGTYPE, AREGTYPE, LNKTYPE,
                   SYMTYPE, DIRTYPE, FIFOTYPE,
                   CONTTYPE, CHRTYPE, BLKTYPE,
                   GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,
                   GNUTYPE_SPARSE)

# File types that will be treated as a regular file.
REGULAR_TYPES = (REGTYPE, AREGTYPE,
                 CONTTYPE, GNUTYPE_SPARSE)

# File types that are part of the GNU tar format.
GNU_TYPES = (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK,
             GNUTYPE_SPARSE)

# Fields from a pax header that override a TarInfo attribute.
PAX_FIELDS = ("path", "linkpath", "size", "mtime",
              "uid", "gid", "uname", "gname")

# Fields from a pax header that are affected by hdrcharset.
PAX_NAME_FIELDS = set(("path", "linkpath", "uname", "gname"))

# Fields in a pax header that are numbers, all other fields
# are treated as strings.
PAX_NUMBER_FIELDS = {
    "atime": float,
    "ctime": float,
    "mtime": float,
    "uid": int,
    "gid": int,
    "size": int
}

#---------------------------------------------------------
# Bits used in the mode field, values in octal.
#---------------------------------------------------------
S_IFLNK = 0o120000        # symbolic link
S_IFREG = 0o100000        # regular file
S_IFBLK = 0o060000        # block device
S_IFDIR = 0o040000        # directory
S_IFCHR = 0o020000        # character device
S_IFIFO = 0o010000        # fifo

TSUID   = 0o4000          # set UID on execution
TSGID   = 0o2000          # set GID on execution
TSVTX   = 0o1000          # reserved

TUREAD  = 0o400           # read by owner
TUWRITE = 0o200           # write by owner
TUEXEC  = 0o100           # execute/search by owner
TGREAD  = 0o040           # read by group
TGWRITE = 0o020           # write by group
TGEXEC  = 0o010           # execute/search by group
TOREAD  = 0o004           # read by other
TOWRITE = 0o002           # write by other
TOEXEC  = 0o001           # execute/search by other

#---------------------------------------------------------
# initialization
#---------------------------------------------------------
if os.name in ("nt", "ce"):
    ENCODING = "utf-8"
else:
    ENCODING = sys.getfilesystemencoding()

#---------------------------------------------------------
# Some useful functions
#---------------------------------------------------------

def stn(s, length, encoding, errors):
    """Convert a string to a null-terminated bytes object.
    """
    s = s.encode(encoding, errors)
    return s[:length] + (length - len(s)) * NUL

def nts(s, encoding, errors):
    """Convert a null-terminated bytes object to a string.
    """
    p = s.find(b"\0")
    if p != -1:
        s = s[:p]
    return s.decode(encoding, errors)

def nti(s):
    """Convert a number field to a python number.
    """
    # There are two possible encodings for a number field, see
    # itn() below.
    if s[0] != chr(0o200):
        try:
            n = int(nts(s, "ascii", "strict") or "0", 8)
        except ValueError:
            raise InvalidHeaderError("invalid header")
    else:
        n = 0
        for i in range(len(s) - 1):
            n <<= 8
            n += ord(s[i + 1])
    return n

def itn(n, digits=8, format=DEFAULT_FORMAT):
    """Convert a python number to a number field.
    """
    # POSIX 1003.1-1988 requires numbers to be encoded as a string of
    # octal digits followed by a null-byte, this allows values up to
    # (8**(digits-1))-1. GNU tar allows storing numbers greater than
    # that if necessary. A leading 0o200 byte indicates this particular
    # encoding, the following digits-1 bytes are a big-endian
    # representation. This allows values up to (256**(digits-1))-1.
    if 0 <= n < 8 ** (digits - 1):
        s = ("%0*o" % (digits - 1, n)).encode("ascii") + NUL
    else:
        if format != GNU_FORMAT or n >= 256 ** (digits - 1):
            raise ValueError("overflow in number field")

        if n < 0:
            # XXX We mimic GNU tar's behaviour with negative numbers,
            # this could raise OverflowError.
            n = struct.unpack("L", struct.pack("l", n))[0]

        s = bytearray()
        for i in range(digits - 1):
            s.insert(0, n & 0o377)
            n >>= 8
        s.insert(0, 0o200)
    return s

def calc_chksums(buf):
    """Calculate the checksum for a member's header by summing up all
       characters except for the chksum field which is treated as if
       it was filled with spaces. According to the GNU tar sources,
       some tars (Sun and NeXT) calculate chksum with signed char,
       which will be different if there are chars in the buffer with
       the high bit set. So we calculate two checksums, unsigned and
       signed.
    """
    unsigned_chksum = 256 + sum(struct.unpack("148B", buf[:148]) + struct.unpack("356B", buf[156:512]))
    signed_chksum = 256 + sum(struct.unpack("148b", buf[:148]) + struct.unpack("356b", buf[156:512]))
    return unsigned_chksum, signed_chksum

def copyfileobj(src, dst, length=None):
    """Copy length bytes from fileobj src to fileobj dst.
       If length is None, copy the entire content.
    """
    if length == 0:
        return
    if length is None:
        while True:
            buf = src.read(16*1024)
            if not buf:
                break
            dst.write(buf)
        return

    BUFSIZE = 16 * 1024
    blocks, remainder = divmod(length, BUFSIZE)
    for b in range(blocks):
        buf = src.read(BUFSIZE)
        if len(buf) < BUFSIZE:
            raise IOError("end of file reached")
        dst.write(buf)

    if remainder != 0:
        buf = src.read(remainder)
        if len(buf) < remainder:
            raise IOError("end of file reached")
        dst.write(buf)
    return

filemode_table = (
    ((S_IFLNK,      "l"),
     (S_IFREG,      "-"),
     (S_IFBLK,      "b"),
     (S_IFDIR,      "d"),
     (S_IFCHR,      "c"),
     (S_IFIFO,      "p")),

    ((TUREAD,       "r"),),
    ((TUWRITE,      "w"),),
    ((TUEXEC|TSUID, "s"),
     (TSUID,        "S"),
     (TUEXEC,       "x")),

    ((TGREAD,       "r"),),
    ((TGWRITE,      "w"),),
    ((TGEXEC|TSGID, "s"),
     (TSGID,        "S"),
     (TGEXEC,       "x")),

    ((TOREAD,       "r"),),
    ((TOWRITE,      "w"),),
    ((TOEXEC|TSVTX, "t"),
     (TSVTX,        "T"),
     (TOEXEC,       "x"))
)

def filemode(mode):
    """Convert a file's mode to a string of the form
       -rwxrwxrwx.
       Used by TarFile.list()
    """
    perm = []
    for table in filemode_table:
        for bit, char in table:
            if mode & bit == bit:
                perm.append(char)
                break
        else:
            perm.append("-")
    return "".join(perm)

class TarError(Exception):
    """Base exception."""
    pass
class ExtractError(TarError):
    """General exception for extract errors."""
    pass
class ReadError(TarError):
    """Exception for unreadble tar archives."""
    pass
class CompressionError(TarError):
    """Exception for unavailable compression methods."""
    pass
class StreamError(TarError):
    """Exception for unsupported operations on stream-like TarFiles."""
    pass
class HeaderError(TarError):
    """Base exception for header errors."""
    pass
class EmptyHeaderError(HeaderError):
    """Exception for empty headers."""
    pass
class TruncatedHeaderError(HeaderError):
    """Exception for truncated headers."""
    pass
class EOFHeaderError(HeaderError):
    """Exception for end of file headers."""
    pass
class InvalidHeaderError(HeaderError):
    """Exception for invalid headers."""
    pass
class SubsequentHeaderError(HeaderError):
    """Exception for missing and invalid extended headers."""
    pass

#---------------------------
# internal stream interface
#---------------------------
class _LowLevelFile(object):
    """Low-level file object. Supports reading and writing.
       It is used instead of a regular file object for streaming
       access.
    """

    def __init__(self, name, mode):
        mode = {
            "r": os.O_RDONLY,
            "w": os.O_WRONLY | os.O_CREAT | os.O_TRUNC,
        }[mode]
        if hasattr(os, "O_BINARY"):
            mode |= os.O_BINARY
        self.fd = os.open(name, mode, 0o666)

    def close(self):
        os.close(self.fd)

    def read(self, size):
        return os.read(self.fd, size)

    def write(self, s):
        os.write(self.fd, s)

class _Stream(object):
    """Class that serves as an adapter between TarFile and
       a stream-like object.  The stream-like object only
       needs to have a read() or write() method and is accessed
       blockwise.  Use of gzip or bzip2 compression is possible.
       A stream-like object could be for example: sys.stdin,
       sys.stdout, a socket, a tape device etc.

       _Stream is intended to be used only internally.
    """

    def __init__(self, name, mode, comptype, fileobj, bufsize):
        """Construct a _Stream object.
        """
        self._extfileobj = True
        if fileobj is None:
            fileobj = _LowLevelFile(name, mode)
            self._extfileobj = False

        if comptype == '*':
            # Enable transparent compression detection for the
            # stream interface
            fileobj = _StreamProxy(fileobj)
            comptype = fileobj.getcomptype()

        self.name     = name or ""
        self.mode     = mode
        self.comptype = comptype
        self.fileobj  = fileobj
        self.bufsize  = bufsize
        self.buf      = b""
        self.pos      = 0
        self.closed   = False

        try:
            if comptype == "gz":
                try:
                    import zlib
                except ImportError:
                    raise CompressionError("zlib module is not available")
                self.zlib = zlib
                self.crc = zlib.crc32(b"")
                if mode == "r":
                    self._init_read_gz()
                else:
                    self._init_write_gz()

            if comptype == "bz2":
                try:
                    import bz2
                except ImportError:
                    raise CompressionError("bz2 module is not available")
                if mode == "r":
                    self.dbuf = b""
                    self.cmp = bz2.BZ2Decompressor()
                else:
                    self.cmp = bz2.BZ2Compressor()
        except:
            if not self._extfileobj:
                self.fileobj.close()
            self.closed = True
            raise

    def __del__(self):
        if hasattr(self, "closed") and not self.closed:
            self.close()

    def _init_write_gz(self):
        """Initialize for writing with gzip compression.
        """
        self.cmp = self.zlib.compressobj(9, self.zlib.DEFLATED,
                                            -self.zlib.MAX_WBITS,
                                            self.zlib.DEF_MEM_LEVEL,
                                            0)
        timestamp = struct.pack("<L", int(time.time()))
        self.__write(b"\037\213\010\010" + timestamp + b"\002\377")
        if self.name.endswith(".gz"):
            self.name = self.name[:-3]
        # RFC1952 says we must use ISO-8859-1 for the FNAME field.
        self.__write(self.name.encode("iso-8859-1", "replace") + NUL)

    def write(self, s):
        """Write string s to the stream.
        """
        if self.comptype == "gz":
            self.crc = self.zlib.crc32(s, self.crc)
        self.pos += len(s)
        if self.comptype != "tar":
            s = self.cmp.compress(s)
        self.__write(s)

    def __write(self, s):
        """Write string s to the stream if a whole new block
           is ready to be written.
        """
        self.buf += s
        while len(self.buf) > self.bufsize:
            self.fileobj.write(self.buf[:self.bufsize])
            self.buf = self.buf[self.bufsize:]

    def close(self):
        """Close the _Stream object. No operation should be
           done on it afterwards.
        """
        if self.closed:
            return

        if self.mode == "w" and self.comptype != "tar":
            self.buf += self.cmp.flush()

        if self.mode == "w" and self.buf:
            self.fileobj.write(self.buf)
            self.buf = b""
            if self.comptype == "gz":
                # The native zlib crc is an unsigned 32-bit integer, but
                # the Python wrapper implicitly casts that to a signed C
                # long.  So, on a 32-bit box self.crc may "look negative",
                # while the same crc on a 64-bit box may "look positive".
                # To avoid irksome warnings from the `struct` module, force
                # it to look positive on all boxes.
                self.fileobj.write(struct.pack("<L", self.crc & 0xffffffff))
                self.fileobj.write(struct.pack("<L", self.pos & 0xffffFFFF))

        if not self._extfileobj:
            self.fileobj.close()

        self.closed = True

    def _init_read_gz(self):
        """Initialize for reading a gzip compressed fileobj.
        """
        self.cmp = self.zlib.decompressobj(-self.zlib.MAX_WBITS)
        self.dbuf = b""

        # taken from gzip.GzipFile with some alterations
        if self.__read(2) != b"\037\213":
            raise ReadError("not a gzip file")
        if self.__read(1) != b"\010":
            raise CompressionError("unsupported compression method")

        flag = ord(self.__read(1))
        self.__read(6)

        if flag & 4:
            xlen = ord(self.__read(1)) + 256 * ord(self.__read(1))
            self.read(xlen)
        if flag & 8:
            while True:
                s = self.__read(1)
                if not s or s == NUL:
                    break
        if flag & 16:
            while True:
                s = self.__read(1)
                if not s or s == NUL:
                    break
        if flag & 2:
            self.__read(2)

    def tell(self):
        """Return the stream's file pointer position.
        """
        return self.pos

    def seek(self, pos=0):
        """Set the stream's file pointer to pos. Negative seeking
           is forbidden.
        """
        if pos - self.pos >= 0:
            blocks, remainder = divmod(pos - self.pos, self.bufsize)
            for i in range(blocks):
                self.read(self.bufsize)
            self.read(remainder)
        else:
            raise StreamError("seeking backwards is not allowed")
        return self.pos

    def read(self, size=None):
        """Return the next size number of bytes from the stream.
           If size is not defined, return all bytes of the stream
           up to EOF.
        """
        if size is None:
            t = []
            while True:
                buf = self._read(self.bufsize)
                if not buf:
                    break
                t.append(buf)
            buf = "".join(t)
        else:
            buf = self._read(size)
        self.pos += len(buf)
        return buf

    def _read(self, size):
        """Return size bytes from the stream.
        """
        if self.comptype == "tar":
            return self.__read(size)

        c = len(self.dbuf)
        while c < size:
            buf = self.__read(self.bufsize)
            if not buf:
                break
            try:
                buf = self.cmp.decompress(buf)
            except IOError:
                raise ReadError("invalid compressed data")
            self.dbuf += buf
            c += len(buf)
        buf = self.dbuf[:size]
        self.dbuf = self.dbuf[size:]
        return buf

    def __read(self, size):
        """Return size bytes from stream. If internal buffer is empty,
           read another block from the stream.
        """
        c = len(self.buf)
        while c < size:
            buf = self.fileobj.read(self.bufsize)
            if not buf:
                break
            self.buf += buf
            c += len(buf)
        buf = self.buf[:size]
        self.buf = self.buf[size:]
        return buf
# class _Stream

class _StreamProxy(object):
    """Small proxy class that enables transparent compression
       detection for the Stream interface (mode 'r|*').
    """

    def __init__(self, fileobj):
        self.fileobj = fileobj
        self.buf = self.fileobj.read(BLOCKSIZE)

    def read(self, size):
        self.read = self.fileobj.read
        return self.buf

    def getcomptype(self):
        if self.buf.startswith(b"\037\213\010"):
            return "gz"
        if self.buf.startswith(b"BZh91"):
            return "bz2"
        return "tar"

    def close(self):
        self.fileobj.close()
# class StreamProxy

class _BZ2Proxy(object):
    """Small proxy class that enables external file object
       support for "r:bz2" and "w:bz2" modes. This is actually
       a workaround for a limitation in bz2 module's BZ2File
       class which (unlike gzip.GzipFile) has no support for
       a file object argument.
    """

    blocksize = 16 * 1024

    def __init__(self, fileobj, mode):
        self.fileobj = fileobj
        self.mode = mode
        self.name = getattr(self.fileobj, "name", None)
        self.init()

    def init(self):
        import bz2
        self.pos = 0
        if self.mode == "r":
            self.bz2obj = bz2.BZ2Decompressor()
            self.fileobj.seek(0)
            self.buf = b""
        else:
            self.bz2obj = bz2.BZ2Compressor()

    def read(self, size):
        x = len(self.buf)
        while x < size:
            raw = self.fileobj.read(self.blocksize)
            if not raw:
                break
            data = self.bz2obj.decompress(raw)
            self.buf += data
            x += len(data)

        buf = self.buf[:size]
        self.buf = self.buf[size:]
        self.pos += len(buf)
        return buf

    def seek(self, pos):
        if pos < self.pos:
            self.init()
        self.read(pos - self.pos)

    def tell(self):
        return self.pos

    def write(self, data):
        self.pos += len(data)
        raw = self.bz2obj.compress(data)
        self.fileobj.write(raw)

    def close(self):
        if self.mode == "w":
            raw = self.bz2obj.flush()
            self.fileobj.write(raw)
# class _BZ2Proxy

#------------------------
# Extraction file object
#------------------------
class _FileInFile(object):
    """A thin wrapper around an existing file object that
       provides a part of its data as an individual file
       object.
    """

    def __init__(self, fileobj, offset, size, blockinfo=None):
        self.fileobj = fileobj
        self.offset = offset
        self.size = size
        self.position = 0

        if blockinfo is None:
            blockinfo = [(0, size)]

        # Construct a map with data and zero blocks.
        self.map_index = 0
        self.map = []
        lastpos = 0
        realpos = self.offset
        for offset, size in blockinfo:
            if offset > lastpos:
                self.map.append((False, lastpos, offset, None))
            self.map.append((True, offset, offset + size, realpos))
            realpos += size
            lastpos = offset + size
        if lastpos < self.size:
            self.map.append((False, lastpos, self.size, None))

    def seekable(self):
        if not hasattr(self.fileobj, "seekable"):
            # XXX gzip.GzipFile and bz2.BZ2File
            return True
        return self.fileobj.seekable()

    def tell(self):
        """Return the current file position.
        """
        return self.position

    def seek(self, position):
        """Seek to a position in the file.
        """
        self.position = position

    def read(self, size=None):
        """Read data from the file.
        """
        if size is None:
            size = self.size - self.position
        else:
            size = min(size, self.size - self.position)

        buf = b""
        while size > 0:
            while True:
                data, start, stop, offset = self.map[self.map_index]
                if start <= self.position < stop:
                    break
                else:
                    self.map_index += 1
                    if self.map_index == len(self.map):
                        self.map_index = 0
            length = min(size, stop - self.position)
            if data:
                self.fileobj.seek(offset + (self.position - start))
                buf += self.fileobj.read(length)
            else:
                buf += NUL * length
            size -= length
            self.position += length
        return buf
#class _FileInFile


class ExFileObject(object):
    """File-like object for reading an archive member.
       Is returned by TarFile.extractfile().
    """
    blocksize = 1024

    def __init__(self, tarfile, tarinfo):
        self.fileobj = _FileInFile(tarfile.fileobj,
                                   tarinfo.offset_data,
                                   tarinfo.size,
                                   tarinfo.sparse)
        self.name = tarinfo.name
        self.mode = "r"
        self.closed = False
        self.size = tarinfo.size

        self.position = 0
        self.buffer = b""

    def readable(self):
        return True

    def writable(self):
        return False

    def seekable(self):
        return self.fileobj.seekable()

    def read(self, size=None):
        """Read at most size bytes from the file. If size is not
           present or None, read all data until EOF is reached.
        """
        if self.closed:
            raise ValueError("I/O operation on closed file")

        buf = b""
        if self.buffer:
            if size is None:
                buf = self.buffer
                self.buffer = b""
            else:
                buf = self.buffer[:size]
                self.buffer = self.buffer[size:]

        if size is None:
            buf += self.fileobj.read()
        else:
            buf += self.fileobj.read(size - len(buf))

        self.position += len(buf)
        return buf

    # XXX TextIOWrapper uses the read1() method.
    read1 = read

    def readline(self, size=-1):
        """Read one entire line from the file. If size is present
           and non-negative, return a string with at most that
           size, which may be an incomplete line.
        """
        if self.closed:
            raise ValueError("I/O operation on closed file")

        pos = self.buffer.find(b"\n") + 1
        if pos == 0:
            # no newline found.
            while True:
                buf = self.fileobj.read(self.blocksize)
                self.buffer += buf
                if not buf or b"\n" in buf:
                    pos = self.buffer.find(b"\n") + 1
                    if pos == 0:
                        # no newline found.
                        pos = len(self.buffer)
                    break

        if size != -1:
            pos = min(size, pos)

        buf = self.buffer[:pos]
        self.buffer = self.buffer[pos:]
        self.position += len(buf)
        return buf

    def readlines(self):
        """Return a list with all remaining lines.
        """
        result = []
        while True:
            line = self.readline()
            if not line: break
            result.append(line)
        return result

    def tell(self):
        """Return the current file position.
        """
        if self.closed:
            raise ValueError("I/O operation on closed file")

        return self.position

    def seek(self, pos, whence=os.SEEK_SET):
        """Seek to a position in the file.
        """
        if self.closed:
            raise ValueError("I/O operation on closed file")

        if whence == os.SEEK_SET:
            self.position = min(max(pos, 0), self.size)
        elif whence == os.SEEK_CUR:
            if pos < 0:
                self.position = max(self.position + pos, 0)
            else:
                self.position = min(self.position + pos, self.size)
        elif whence == os.SEEK_END:
            self.position = max(min(self.size + pos, self.size), 0)
        else:
            raise ValueError("Invalid argument")

        self.buffer = b""
        self.fileobj.seek(self.position)

    def close(self):
        """Close the file object.
        """
        self.closed = True

    def __iter__(self):
        """Get an iterator over the file's lines.
        """
        while True:
            line = self.readline()
            if not line:
                break
            yield line
#class ExFileObject

#------------------
# Exported Classes
#------------------
class TarInfo(object):
    """Informational class which holds the details about an
       archive member given by a tar header block.
       TarInfo objects are returned by TarFile.getmember(),
       TarFile.getmembers() and TarFile.gettarinfo() and are
       usually created internally.
    """

    __slots__ = ("name", "mode", "uid", "gid", "size", "mtime",
                 "chksum", "type", "linkname", "uname", "gname",
                 "devmajor", "devminor",
                 "offset", "offset_data", "pax_headers", "sparse",
                 "tarfile", "_sparse_structs", "_link_target")

    def __init__(self, name=""):
        """Construct a TarInfo object. name is the optional name
           of the member.
        """
        self.name = name        # member name
        self.mode = 0o644       # file permissions
        self.uid = 0            # user id
        self.gid = 0            # group id
        self.size = 0           # file size
        self.mtime = 0          # modification time
        self.chksum = 0         # header checksum
        self.type = REGTYPE     # member type
        self.linkname = ""      # link name
        self.uname = ""         # user name
        self.gname = ""         # group name
        self.devmajor = 0       # device major number
        self.devminor = 0       # device minor number

        self.offset = 0         # the tar header starts here
        self.offset_data = 0    # the file's data starts here

        self.sparse = None      # sparse member information
        self.pax_headers = {}   # pax header information

    # In pax headers the "name" and "linkname" field are called
    # "path" and "linkpath".
    def _getpath(self):
        return self.name
    def _setpath(self, name):
        self.name = name
    path = property(_getpath, _setpath)

    def _getlinkpath(self):
        return self.linkname
    def _setlinkpath(self, linkname):
        self.linkname = linkname
    linkpath = property(_getlinkpath, _setlinkpath)

    def __repr__(self):
        return "<%s %r at %#x>" % (self.__class__.__name__,self.name,id(self))

    def get_info(self):
        """Return the TarInfo's attributes as a dictionary.
        """
        info = {
            "name":     self.name,
            "mode":     self.mode & 0o7777,
            "uid":      self.uid,
            "gid":      self.gid,
            "size":     self.size,
            "mtime":    self.mtime,
            "chksum":   self.chksum,
            "type":     self.type,
            "linkname": self.linkname,
            "uname":    self.uname,
            "gname":    self.gname,
            "devmajor": self.devmajor,
            "devminor": self.devminor
        }

        if info["type"] == DIRTYPE and not info["name"].endswith("/"):
            info["name"] += "/"

        return info

    def tobuf(self, format=DEFAULT_FORMAT, encoding=ENCODING, errors="surrogateescape"):
        """Return a tar header as a string of 512 byte blocks.
        """
        info = self.get_info()

        if format == USTAR_FORMAT:
            return self.create_ustar_header(info, encoding, errors)
        elif format == GNU_FORMAT:
            return self.create_gnu_header(info, encoding, errors)
        elif format == PAX_FORMAT:
            return self.create_pax_header(info, encoding)
        else:
            raise ValueError("invalid format")

    def create_ustar_header(self, info, encoding, errors):
        """Return the object as a ustar header block.
        """
        info["magic"] = POSIX_MAGIC

        if len(info["linkname"]) > LENGTH_LINK:
            raise ValueError("linkname is too long")

        if len(info["name"]) > LENGTH_NAME:
            info["prefix"], info["name"] = self._posix_split_name(info["name"])

        return self._create_header(info, USTAR_FORMAT, encoding, errors)

    def create_gnu_header(self, info, encoding, errors):
        """Return the object as a GNU header block sequence.
        """
        info["magic"] = GNU_MAGIC

        buf = b""
        if len(info["linkname"]) > LENGTH_LINK:
            buf += self._create_gnu_long_header(info["linkname"], GNUTYPE_LONGLINK, encoding, errors)

        if len(info["name"]) > LENGTH_NAME:
            buf += self._create_gnu_long_header(info["name"], GNUTYPE_LONGNAME, encoding, errors)

        return buf + self._create_header(info, GNU_FORMAT, encoding, errors)

    def create_pax_header(self, info, encoding):
        """Return the object as a ustar header block. If it cannot be
           represented this way, prepend a pax extended header sequence
           with supplement information.
        """
        info["magic"] = POSIX_MAGIC
        pax_headers = self.pax_headers.copy()

        # Test string fields for values that exceed the field length or cannot
        # be represented in ASCII encoding.
        for name, hname, length in (
                ("name", "path", LENGTH_NAME), ("linkname", "linkpath", LENGTH_LINK),
                ("uname", "uname", 32), ("gname", "gname", 32)):

            if hname in pax_headers:
                # The pax header has priority.
                continue

            # Try to encode the string as ASCII.
            try:
                info[name].encode("ascii", "strict")
            except UnicodeEncodeError:
                pax_headers[hname] = info[name]
                continue

            if len(info[name]) > length:
                pax_headers[hname] = info[name]

        # Test number fields for values that exceed the field limit or values
        # that like to be stored as float.
        for name, digits in (("uid", 8), ("gid", 8), ("size", 12), ("mtime", 12)):
            if name in pax_headers:
                # The pax header has priority. Avoid overflow.
                info[name] = 0
                continue

            val = info[name]
            if not 0 <= val < 8 ** (digits - 1) or isinstance(val, float):
                pax_headers[name] = str(val)
                info[name] = 0

        # Create a pax extended header if necessary.
        if pax_headers:
            buf = self._create_pax_generic_header(pax_headers, XHDTYPE, encoding)
        else:
            buf = b""

        return buf + self._create_header(info, USTAR_FORMAT, "ascii", "replace")

    @classmethod
    def create_pax_global_header(cls, pax_headers):
        """Return the object as a pax global header block sequence.
        """
        return cls._create_pax_generic_header(pax_headers, XGLTYPE, "utf8")

    def _posix_split_name(self, name):
        """Split a name longer than 100 chars into a prefix
           and a name part.
        """
        prefix = name[:LENGTH_PREFIX + 1]
        while prefix and prefix[-1] != "/":
            prefix = prefix[:-1]

        name = name[len(prefix):]
        prefix = prefix[:-1]

        if not prefix or len(name) > LENGTH_NAME:
            raise ValueError("name is too long")
        return prefix, name

    @staticmethod
    def _create_header(info, format, encoding, errors):
        """Return a header block. info is a dictionary with file
           information, format must be one of the *_FORMAT constants.
        """
        parts = [
            stn(info.get("name", ""), 100, encoding, errors),
            itn(info.get("mode", 0) & 0o7777, 8, format),
            itn(info.get("uid", 0), 8, format),
            itn(info.get("gid", 0), 8, format),
            itn(info.get("size", 0), 12, format),
            itn(info.get("mtime", 0), 12, format),
            b"        ", # checksum field
            info.get("type", REGTYPE),
            stn(info.get("linkname", ""), 100, encoding, errors),
            info.get("magic", POSIX_MAGIC),
            stn(info.get("uname", ""), 32, encoding, errors),
            stn(info.get("gname", ""), 32, encoding, errors),
            itn(info.get("devmajor", 0), 8, format),
            itn(info.get("devminor", 0), 8, format),
            stn(info.get("prefix", ""), 155, encoding, errors)
        ]

        buf = struct.pack("%ds" % BLOCKSIZE, b"".join(parts))
        chksum = calc_chksums(buf[-BLOCKSIZE:])[0]
        buf = buf[:-364] + ("%06o\0" % chksum).encode("ascii") + buf[-357:]
        return buf

    @staticmethod
    def _create_payload(payload):
        """Return the string payload filled with zero bytes
           up to the next 512 byte border.
        """
        blocks, remainder = divmod(len(payload), BLOCKSIZE)
        if remainder > 0:
            payload += (BLOCKSIZE - remainder) * NUL
        return payload

    @classmethod
    def _create_gnu_long_header(cls, name, type, encoding, errors):
        """Return a GNUTYPE_LONGNAME or GNUTYPE_LONGLINK sequence
           for name.
        """
        name = name.encode(encoding, errors) + NUL

        info = {}
        info["name"] = "././@LongLink"
        info["type"] = type
        info["size"] = len(name)
        info["magic"] = GNU_MAGIC

        # create extended header + name blocks.
        return cls._create_header(info, USTAR_FORMAT, encoding, errors) + \
                cls._create_payload(name)

    @classmethod
    def _create_pax_generic_header(cls, pax_headers, type, encoding):
        """Return a POSIX.1-2008 extended or global header sequence
           that contains a list of keyword, value pairs. The values
           must be strings.
        """
        # Check if one of the fields contains surrogate characters and thereby
        # forces hdrcharset=BINARY, see _proc_pax() for more information.
        binary = False
        for keyword, value in pax_headers.items():
            try:
                value.encode("utf8", "strict")
            except UnicodeEncodeError:
                binary = True
                break

        records = b""
        if binary:
            # Put the hdrcharset field at the beginning of the header.
            records += b"21 hdrcharset=BINARY\n"

        for keyword, value in pax_headers.items():
            keyword = keyword.encode("utf8")
            if binary:
                # Try to restore the original byte representation of `value'.
                # Needless to say, that the encoding must match the string.
                value = value.encode(encoding, "surrogateescape")
            else:
                value = value.encode("utf8")

            l = len(keyword) + len(value) + 3   # ' ' + '=' + '\n'
            n = p = 0
            while True:
                n = l + len(str(p))
                if n == p:
                    break
                p = n
            records += bytes(str(p), "ascii") + b" " + keyword + b"=" + value + b"\n"

        # We use a hardcoded "././@PaxHeader" name like star does
        # instead of the one that POSIX recommends.
        info = {}
        info["name"] = "././@PaxHeader"
        info["type"] = type
        info["size"] = len(records)
        info["magic"] = POSIX_MAGIC

        # Create pax header + record blocks.
        return cls._create_header(info, USTAR_FORMAT, "ascii", "replace") + \
                cls._create_payload(records)

    @classmethod
    def frombuf(cls, buf, encoding, errors):
        """Construct a TarInfo object from a 512 byte bytes object.
        """
        if len(buf) == 0:
            raise EmptyHeaderError("empty header")
        if len(buf) != BLOCKSIZE:
            raise TruncatedHeaderError("truncated header")
        if buf.count(NUL) == BLOCKSIZE:
            raise EOFHeaderError("end of file header")

        chksum = nti(buf[148:156])
        if chksum not in calc_chksums(buf):
            raise InvalidHeaderError("bad checksum")

        obj = cls()
        obj.name = nts(buf[0:100], encoding, errors)
        obj.mode = nti(buf[100:108])
        obj.uid = nti(buf[108:116])
        obj.gid = nti(buf[116:124])
        obj.size = nti(buf[124:136])
        obj.mtime = nti(buf[136:148])
        obj.chksum = chksum
        obj.type = buf[156:157]
        obj.linkname = nts(buf[157:257], encoding, errors)
        obj.uname = nts(buf[265:297], encoding, errors)
        obj.gname = nts(buf[297:329], encoding, errors)
        obj.devmajor = nti(buf[329:337])
        obj.devminor = nti(buf[337:345])
        prefix = nts(buf[345:500], encoding, errors)

        # Old V7 tar format represents a directory as a regular
        # file with a trailing slash.
        if obj.type == AREGTYPE and obj.name.endswith("/"):
            obj.type = DIRTYPE

        # The old GNU sparse format occupies some of the unused
        # space in the buffer for up to 4 sparse structures.
        # Save the them for later processing in _proc_sparse().
        if obj.type == GNUTYPE_SPARSE:
            pos = 386
            structs = []
            for i in range(4):
                try:
                    offset = nti(buf[pos:pos + 12])
                    numbytes = nti(buf[pos + 12:pos + 24])
                except ValueError:
                    break
                structs.append((offset, numbytes))
                pos += 24
            isextended = bool(buf[482])
            origsize = nti(buf[483:495])
            obj._sparse_structs = (structs, isextended, origsize)

        # Remove redundant slashes from directories.
        if obj.isdir():
            obj.name = obj.name.rstrip("/")

        # Reconstruct a ustar longname.
        if prefix and obj.type not in GNU_TYPES:
            obj.name = prefix + "/" + obj.name
        return obj

    @classmethod
    def fromtarfile(cls, tarfile):
        """Return the next TarInfo object from TarFile object
           tarfile.
        """
        buf = tarfile.fileobj.read(BLOCKSIZE)
        obj = cls.frombuf(buf, tarfile.encoding, tarfile.errors)
        obj.offset = tarfile.fileobj.tell() - BLOCKSIZE
        return obj._proc_member(tarfile)

    #--------------------------------------------------------------------------
    # The following are methods that are called depending on the type of a
    # member. The entry point is _proc_member() which can be overridden in a
    # subclass to add custom _proc_*() methods. A _proc_*() method MUST
    # implement the following
    # operations:
    # 1. Set self.offset_data to the position where the data blocks begin,
    #    if there is data that follows.
    # 2. Set tarfile.offset to the position where the next member's header will
    #    begin.
    # 3. Return self or another valid TarInfo object.
    def _proc_member(self, tarfile):
        """Choose the right processing method depending on
           the type and call it.
        """
        if self.type in (GNUTYPE_LONGNAME, GNUTYPE_LONGLINK):
            return self._proc_gnulong(tarfile)
        elif self.type == GNUTYPE_SPARSE:
            return self._proc_sparse(tarfile)
        elif self.type in (XHDTYPE, XGLTYPE, SOLARIS_XHDTYPE):
            return self._proc_pax(tarfile)
        else:
            return self._proc_builtin(tarfile)

    def _proc_builtin(self, tarfile):
        """Process a builtin type or an unknown type which
           will be treated as a regular file.
        """
        self.offset_data = tarfile.fileobj.tell()
        offset = self.offset_data
        if self.isreg() or self.type not in SUPPORTED_TYPES:
            # Skip the following data blocks.
            offset += self._block(self.size)
        tarfile.offset = offset

        # Patch the TarInfo object with saved global
        # header information.
        self._apply_pax_info(tarfile.pax_headers, tarfile.encoding, tarfile.errors)

        return self

    def _proc_gnulong(self, tarfile):
        """Process the blocks that hold a GNU longname
           or longlink member.
        """
        buf = tarfile.fileobj.read(self._block(self.size))

        # Fetch the next header and process it.
        try:
            next = self.fromtarfile(tarfile)
        except HeaderError:
            raise SubsequentHeaderError("missing or bad subsequent header")

        # Patch the TarInfo object from the next header with
        # the longname information.
        next.offset = self.offset
        if self.type == GNUTYPE_LONGNAME:
            next.name = nts(buf, tarfile.encoding, tarfile.errors)
        elif self.type == GNUTYPE_LONGLINK:
            next.linkname = nts(buf, tarfile.encoding, tarfile.errors)

        return next

    def _proc_sparse(self, tarfile):
        """Process a GNU sparse header plus extra headers.
        """
        # We already collected some sparse structures in frombuf().
        structs, isextended, origsize = self._sparse_structs
        del self._sparse_structs

        # Collect sparse structures from extended header blocks.
        while isextended:
            buf = tarfile.fileobj.read(BLOCKSIZE)
            pos = 0
            for i in range(21):
                try:
                    offset = nti(buf[pos:pos + 12])
                    numbytes = nti(buf[pos + 12:pos + 24])
                except ValueError:
                    break
                if offset and numbytes:
                    structs.append((offset, numbytes))
                pos += 24
            isextended = bool(buf[504])
        self.sparse = structs

        self.offset_data = tarfile.fileobj.tell()
        tarfile.offset = self.offset_data + self._block(self.size)
        self.size = origsize
        return self

    def _proc_pax(self, tarfile):
        """Process an extended or global header as described in
           POSIX.1-2008.
        """
        # Read the header information.
        buf = tarfile.fileobj.read(self._block(self.size))

        # A pax header stores supplemental information for either
        # the following file (extended) or all following files
        # (global).
        if self.type == XGLTYPE:
            pax_headers = tarfile.pax_headers
        else:
            pax_headers = tarfile.pax_headers.copy()

        # Check if the pax header contains a hdrcharset field. This tells us
        # the encoding of the path, linkpath, uname and gname fields. Normally,
        # these fields are UTF-8 encoded but since POSIX.1-2008 tar
        # implementations are allowed to store them as raw binary strings if
        # the translation to UTF-8 fails.
        match = re.search(br"\d+ hdrcharset=([^\n]+)\n", buf)
        if match is not None:
            pax_headers["hdrcharset"] = match.group(1).decode("utf8")

        # For the time being, we don't care about anything other than "BINARY".
        # The only other value that is currently allowed by the standard is
        # "ISO-IR 10646 2000 UTF-8" in other words UTF-8.
        hdrcharset = pax_headers.get("hdrcharset")
        if hdrcharset == "BINARY":
            encoding = tarfile.encoding
        else:
            encoding = "utf8"

        # Parse pax header information. A record looks like that:
        # "%d %s=%s\n" % (length, keyword, value). length is the size
        # of the complete record including the length field itself and
        # the newline. keyword and value are both UTF-8 encoded strings.
        regex = re.compile(br"(\d+) ([^=]+)=")
        pos = 0
        while True:
            match = regex.match(buf, pos)
            if not match:
                break

            length, keyword = match.groups()
            length = int(length)
            value = buf[match.end(2) + 1:match.start(1) + length - 1]

            # Normally, we could just use "utf8" as the encoding and "strict"
            # as the error handler, but we better not take the risk. For
            # example, GNU tar <= 1.23 is known to store filenames it cannot
            # translate to UTF-8 as raw strings (unfortunately without a
            # hdrcharset=BINARY header).
            # We first try the strict standard encoding, and if that fails we
            # fall back on the user's encoding and error handler.
            keyword = self._decode_pax_field(keyword, "utf8", "utf8",
                    tarfile.errors)
            if keyword in PAX_NAME_FIELDS:
                value = self._decode_pax_field(value, encoding, tarfile.encoding,
                        tarfile.errors)
            else:
                value = self._decode_pax_field(value, "utf8", "utf8",
                        tarfile.errors)

            pax_headers[keyword] = value
            pos += length

        # Fetch the next header.
        try:
            next = self.fromtarfile(tarfile)
        except HeaderError:
            raise SubsequentHeaderError("missing or bad subsequent header")

        # Process GNU sparse information.
        if "GNU.sparse.map" in pax_headers:
            # GNU extended sparse format version 0.1.
            self._proc_gnusparse_01(next, pax_headers)

        elif "GNU.sparse.size" in pax_headers:
            # GNU extended sparse format version 0.0.
            self._proc_gnusparse_00(next, pax_headers, buf)

        elif pax_headers.get("GNU.sparse.major") == "1" and pax_headers.get("GNU.sparse.minor") == "0":
            # GNU extended sparse format version 1.0.
            self._proc_gnusparse_10(next, pax_headers, tarfile)

        if self.type in (XHDTYPE, SOLARIS_XHDTYPE):
            # Patch the TarInfo object with the extended header info.
            next._apply_pax_info(pax_headers, tarfile.encoding, tarfile.errors)
            next.offset = self.offset

            if "size" in pax_headers:
                # If the extended header replaces the size field,
                # we need to recalculate the offset where the next
                # header starts.
                offset = next.offset_data
                if next.isreg() or next.type not in SUPPORTED_TYPES:
                    offset += next._block(next.size)
                tarfile.offset = offset

        return next

    def _proc_gnusparse_00(self, next, pax_headers, buf):
        """Process a GNU tar extended sparse header, version 0.0.
        """
        offsets = []
        for match in re.finditer(br"\d+ GNU.sparse.offset=(\d+)\n", buf):
            offsets.append(int(match.group(1)))
        numbytes = []
        for match in re.finditer(br"\d+ GNU.sparse.numbytes=(\d+)\n", buf):
            numbytes.append(int(match.group(1)))
        next.sparse = list(zip(offsets, numbytes))

    def _proc_gnusparse_01(self, next, pax_headers):
        """Process a GNU tar extended sparse header, version 0.1.
        """
        sparse = [int(x) for x in pax_headers["GNU.sparse.map"].split(",")]
        next.sparse = list(zip(sparse[::2], sparse[1::2]))

    def _proc_gnusparse_10(self, next, pax_headers, tarfile):
        """Process a GNU tar extended sparse header, version 1.0.
        """
        fields = None
        sparse = []
        buf = tarfile.fileobj.read(BLOCKSIZE)
        fields, buf = buf.split(b"\n", 1)
        fields = int(fields)
        while len(sparse) < fields * 2:
            if b"\n" not in buf:
                buf += tarfile.fileobj.read(BLOCKSIZE)
            number, buf = buf.split(b"\n", 1)
            sparse.append(int(number))
        next.offset_data = tarfile.fileobj.tell()
        next.sparse = list(zip(sparse[::2], sparse[1::2]))

    def _apply_pax_info(self, pax_headers, encoding, errors):
        """Replace fields with supplemental information from a previous
           pax extended or global header.
        """
        for keyword, value in pax_headers.items():
            if keyword == "GNU.sparse.name":
                setattr(self, "path", value)
            elif keyword == "GNU.sparse.size":
                setattr(self, "size", int(value))
            elif keyword == "GNU.sparse.realsize":
                setattr(self, "size", int(value))
            elif keyword in PAX_FIELDS:
                if keyword in PAX_NUMBER_FIELDS:
                    try:
                        value = PAX_NUMBER_FIELDS[keyword](value)
                    except ValueError:
                        value = 0
                if keyword == "path":
                    value = value.rstrip("/")
                setattr(self, keyword, value)

        self.pax_headers = pax_headers.copy()

    def _decode_pax_field(self, value, encoding, fallback_encoding, fallback_errors):
        """Decode a single field from a pax record.
        """
        try:
            return value.decode(encoding, "strict")
        except UnicodeDecodeError:
            return value.decode(fallback_encoding, fallback_errors)

    def _block(self, count):
        """Round up a byte count by BLOCKSIZE and return it,
           e.g. _block(834) => 1024.
        """
        blocks, remainder = divmod(count, BLOCKSIZE)
        if remainder:
            blocks += 1
        return blocks * BLOCKSIZE

    def isreg(self):
        return self.type in REGULAR_TYPES
    def isfile(self):
        return self.isreg()
    def isdir(self):
        return self.type == DIRTYPE
    def issym(self):
        return self.type == SYMTYPE
    def islnk(self):
        return self.type == LNKTYPE
    def ischr(self):
        return self.type == CHRTYPE
    def isblk(self):
        return self.type == BLKTYPE
    def isfifo(self):
        return self.type == FIFOTYPE
    def issparse(self):
        return self.sparse is not None
    def isdev(self):
        return self.type in (CHRTYPE, BLKTYPE, FIFOTYPE)
# class TarInfo

class TarFile(object):
    """The TarFile Class provides an interface to tar archives.
    """

    debug = 0                   # May be set from 0 (no msgs) to 3 (all msgs)

    dereference = False         # If true, add content of linked file to the
                                # tar file, else the link.

    ignore_zeros = False        # If true, skips empty or invalid blocks and
                                # continues processing.

    errorlevel = 1              # If 0, fatal errors only appear in debug
                                # messages (if debug >= 0). If > 0, errors
                                # are passed to the caller as exceptions.

    format = DEFAULT_FORMAT     # The format to use when creating an archive.

    encoding = ENCODING         # Encoding for 8-bit character strings.

    errors = None               # Error handler for unicode conversion.

    tarinfo = TarInfo           # The default TarInfo class to use.

    fileobject = ExFileObject   # The default ExFileObject class to use.

    def __init__(self, name=None, mode="r", fileobj=None, format=None,
            tarinfo=None, dereference=None, ignore_zeros=None, encoding=None,
            errors="surrogateescape", pax_headers=None, debug=None, errorlevel=None):
        """Open an (uncompressed) tar archive `name'. `mode' is either 'r' to
           read from an existing archive, 'a' to append data to an existing
           file or 'w' to create a new file overwriting an existing one. `mode'
           defaults to 'r'.
           If `fileobj' is given, it is used for reading or writing data. If it
           can be determined, `mode' is overridden by `fileobj's mode.
           `fileobj' is not closed, when TarFile is closed.
        """
        if len(mode) > 1 or mode not in "raw":
            raise ValueError("mode must be 'r', 'a' or 'w'")
        self.mode = mode
        self._mode = {"r": "rb", "a": "r+b", "w": "wb"}[mode]

        if not fileobj:
            if self.mode == "a" and not os.path.exists(name):
                # Create nonexistent files in append mode.
                self.mode = "w"
                self._mode = "wb"
            fileobj = bltn_open(name, self._mode)
            self._extfileobj = False
        else:
            if name is None and hasattr(fileobj, "name"):
                name = fileobj.name
            if hasattr(fileobj, "mode"):
                self._mode = fileobj.mode
            self._extfileobj = True
        self.name = os.path.abspath(name) if name else None
        self.fileobj = fileobj

        # Init attributes.
        if format is not None:
            self.format = format
        if tarinfo is not None:
            self.tarinfo = tarinfo
        if dereference is not None:
            self.dereference = dereference
        if ignore_zeros is not None:
            self.ignore_zeros = ignore_zeros
        if encoding is not None:
            self.encoding = encoding
        self.errors = errors

        if pax_headers is not None and self.format == PAX_FORMAT:
            self.pax_headers = pax_headers
        else:
            self.pax_headers = {}

        if debug is not None:
            self.debug = debug
        if errorlevel is not None:
            self.errorlevel = errorlevel

        # Init datastructures.
        self.closed = False
        self.members = []       # list of members as TarInfo objects
        self._loaded = False    # flag if all members have been read
        self.offset = self.fileobj.tell()
                                # current position in the archive file
        self.inodes = {}        # dictionary caching the inodes of
                                # archive members already added

        try:
            if self.mode == "r":
                self.firstmember = None
                self.firstmember = self.next()

            if self.mode == "a":
                # Move to the end of the archive,
                # before the first empty block.
                while True:
                    self.fileobj.seek(self.offset)
                    try:
                        tarinfo = self.tarinfo.fromtarfile(self)
                        self.members.append(tarinfo)
                    except EOFHeaderError:
                        self.fileobj.seek(self.offset)
                        break
                    except HeaderError as e:
                        raise ReadError(str(e))

            if self.mode in "aw":
                self._loaded = True

                if self.pax_headers:
                    buf = self.tarinfo.create_pax_global_header(self.pax_headers.copy())
                    self.fileobj.write(buf)
                    self.offset += len(buf)
        except:
            if not self._extfileobj:
                self.fileobj.close()
            self.closed = True
            raise

    #--------------------------------------------------------------------------
    # Below are the classmethods which act as alternate constructors to the
    # TarFile class. The open() method is the only one that is needed for
    # public use; it is the "super"-constructor and is able to select an
    # adequate "sub"-constructor for a particular compression using the mapping
    # from OPEN_METH.
    #
    # This concept allows one to subclass TarFile without losing the comfort of
    # the super-constructor. A sub-constructor is registered and made available
    # by adding it to the mapping in OPEN_METH.

    @classmethod
    def open(cls, name=None, mode="r", fileobj=None, bufsize=RECORDSIZE, **kwargs):
        """Open a tar archive for reading, writing or appending. Return
           an appropriate TarFile class.

           mode:
           'r' or 'r:*' open for reading with transparent compression
           'r:'         open for reading exclusively uncompressed
           'r:gz'       open for reading with gzip compression
           'r:bz2'      open for reading with bzip2 compression
           'a' or 'a:'  open for appending, creating the file if necessary
           'w' or 'w:'  open for writing without compression
           'w:gz'       open for writing with gzip compression
           'w:bz2'      open for writing with bzip2 compression

           'r|*'        open a stream of tar blocks with transparent compression
           'r|'         open an uncompressed stream of tar blocks for reading
           'r|gz'       open a gzip compressed stream of tar blocks
           'r|bz2'      open a bzip2 compressed stream of tar blocks
           'w|'         open an uncompressed stream for writing
           'w|gz'       open a gzip compressed stream for writing
           'w|bz2'      open a bzip2 compressed stream for writing
        """

        if not name and not fileobj:
            raise ValueError("nothing to open")

        if mode in ("r", "r:*"):
            # Find out which *open() is appropriate for opening the file.
            for comptype in cls.OPEN_METH:
                func = getattr(cls, cls.OPEN_METH[comptype])
                if fileobj is not None:
                    saved_pos = fileobj.tell()
                try:
                    return func(name, "r", fileobj, **kwargs)
                except (ReadError, CompressionError) as e:
                    if fileobj is not None:
                        fileobj.seek(saved_pos)
                    continue
            raise ReadError("file could not be opened successfully")

        elif ":" in mode:
            filemode, comptype = mode.split(":", 1)
            filemode = filemode or "r"
            comptype = comptype or "tar"

            # Select the *open() function according to
            # given compression.
            if comptype in cls.OPEN_METH:
                func = getattr(cls, cls.OPEN_METH[comptype])
            else:
                raise CompressionError("unknown compression type %r" % comptype)
            return func(name, filemode, fileobj, **kwargs)

        elif "|" in mode:
            filemode, comptype = mode.split("|", 1)
            filemode = filemode or "r"
            comptype = comptype or "tar"

            if filemode not in "rw":
                raise ValueError("mode must be 'r' or 'w'")

            stream = _Stream(name, filemode, comptype, fileobj, bufsize)
            try:
                t = cls(name, filemode, stream, **kwargs)
            except:
                stream.close()
                raise
            t._extfileobj = False
            return t

        elif mode in "aw":
            return cls.taropen(name, mode, fileobj, **kwargs)

        raise ValueError("undiscernible mode")

    @classmethod
    def taropen(cls, name, mode="r", fileobj=None, **kwargs):
        """Open uncompressed tar archive name for reading or writing.
        """
        if len(mode) > 1 or mode not in "raw":
            raise ValueError("mode must be 'r', 'a' or 'w'")
        return cls(name, mode, fileobj, **kwargs)

    @classmethod
    def gzopen(cls, name, mode="r", fileobj=None, compresslevel=9, **kwargs):
        """Open gzip compressed tar archive name for reading or writing.
           Appending is not allowed.
        """
        if len(mode) > 1 or mode not in "rw":
            raise ValueError("mode must be 'r' or 'w'")

        try:
            import gzip
            gzip.GzipFile
        except (ImportError, AttributeError):
            raise CompressionError("gzip module is not available")

        extfileobj = fileobj is not None
        try:
            fileobj = gzip.GzipFile(name, mode + "b", compresslevel, fileobj)
            t = cls.taropen(name, mode, fileobj, **kwargs)
        except IOError:
            if not extfileobj and fileobj is not None:
                fileobj.close()
            if fileobj is None:
                raise
            raise ReadError("not a gzip file")
        except:
            if not extfileobj and fileobj is not None:
                fileobj.close()
            raise
        t._extfileobj = extfileobj
        return t

    @classmethod
    def bz2open(cls, name, mode="r", fileobj=None, compresslevel=9, **kwargs):
        """Open bzip2 compressed tar archive name for reading or writing.
           Appending is not allowed.
        """
        if len(mode) > 1 or mode not in "rw":
            raise ValueError("mode must be 'r' or 'w'.")

        try:
            import bz2
        except ImportError:
            raise CompressionError("bz2 module is not available")

        if fileobj is not None:
            fileobj = _BZ2Proxy(fileobj, mode)
        else:
            fileobj = bz2.BZ2File(name, mode, compresslevel=compresslevel)

        try:
            t = cls.taropen(name, mode, fileobj, **kwargs)
        except (IOError, EOFError):
            fileobj.close()
            raise ReadError("not a bzip2 file")
        t._extfileobj = False
        return t

    # All *open() methods are registered here.
    OPEN_METH = {
        "tar": "taropen",   # uncompressed tar
        "gz":  "gzopen",    # gzip compressed tar
        "bz2": "bz2open"    # bzip2 compressed tar
    }

    #--------------------------------------------------------------------------
    # The public methods which TarFile provides:

    def close(self):
        """Close the TarFile. In write-mode, two finishing zero blocks are
           appended to the archive.
        """
        if self.closed:
            return

        if self.mode in "aw":
            self.fileobj.write(NUL * (BLOCKSIZE * 2))
            self.offset += (BLOCKSIZE * 2)
            # fill up the end with zero-blocks
            # (like option -b20 for tar does)
            blocks, remainder = divmod(self.offset, RECORDSIZE)
            if remainder > 0:
                self.fileobj.write(NUL * (RECORDSIZE - remainder))

        if not self._extfileobj:
            self.fileobj.close()
        self.closed = True

    def getmember(self, name):
        """Return a TarInfo object for member `name'. If `name' can not be
           found in the archive, KeyError is raised. If a member occurs more
           than once in the archive, its last occurrence is assumed to be the
           most up-to-date version.
        """
        tarinfo = self._getmember(name)
        if tarinfo is None:
            raise KeyError("filename %r not found" % name)
        return tarinfo

    def getmembers(self):
        """Return the members of the archive as a list of TarInfo objects. The
           list has the same order as the members in the archive.
        """
        self._check()
        if not self._loaded:    # if we want to obtain a list of
            self._load()        # all members, we first have to
                                # scan the whole archive.
        return self.members

    def getnames(self):
        """Return the members of the archive as a list of their names. It has
           the same order as the list returned by getmembers().
        """
        return [tarinfo.name for tarinfo in self.getmembers()]

    def gettarinfo(self, name=None, arcname=None, fileobj=None):
        """Create a TarInfo object for either the file `name' or the file
           object `fileobj' (using os.fstat on its file descriptor). You can
           modify some of the TarInfo's attributes before you add it using
           addfile(). If given, `arcname' specifies an alternative name for the
           file in the archive.
        """
        self._check("aw")

        # When fileobj is given, replace name by
        # fileobj's real name.
        if fileobj is not None:
            name = fileobj.name

        # Building the name of the member in the archive.
        # Backward slashes are converted to forward slashes,
        # Absolute paths are turned to relative paths.
        if arcname is None:
            arcname = name
        drv, arcname = os.path.splitdrive(arcname)
        arcname = arcname.replace(os.sep, "/")
        arcname = arcname.lstrip("/")

        # Now, fill the TarInfo object with
        # information specific for the file.
        tarinfo = self.tarinfo()
        tarinfo.tarfile = self

        # Use os.stat or os.lstat, depending on platform
        # and if symlinks shall be resolved.
        if fileobj is None:
            if hasattr(os, "lstat") and not self.dereference:
                statres = os.lstat(name)
            else:
                statres = os.stat(name)
        else:
            statres = os.fstat(fileobj.fileno())
        linkname = ""

        stmd = statres.st_mode
        if stat.S_ISREG(stmd):
            inode = (statres.st_ino, statres.st_dev)
            if not self.dereference and statres.st_nlink > 1 and \
                    inode in self.inodes and arcname != self.inodes[inode]:
                # Is it a hardlink to an already
                # archived file?
                type = LNKTYPE
                linkname = self.inodes[inode]
            else:
                # The inode is added only if its valid.
                # For win32 it is always 0.
                type = REGTYPE
                if inode[0]:
                    self.inodes[inode] = arcname
        elif stat.S_ISDIR(stmd):
            type = DIRTYPE
        elif stat.S_ISFIFO(stmd):
            type = FIFOTYPE
        elif stat.S_ISLNK(stmd):
            type = SYMTYPE
            linkname = os.readlink(name)
        elif stat.S_ISCHR(stmd):
            type = CHRTYPE
        elif stat.S_ISBLK(stmd):
            type = BLKTYPE
        else:
            return None

        # Fill the TarInfo object with all
        # information we can get.
        tarinfo.name = arcname
        tarinfo.mode = stmd
        tarinfo.uid = statres.st_uid
        tarinfo.gid = statres.st_gid
        if type == REGTYPE:
            tarinfo.size = statres.st_size
        else:
            tarinfo.size = 0
        tarinfo.mtime = statres.st_mtime
        tarinfo.type = type
        tarinfo.linkname = linkname
        if pwd:
            try:
                tarinfo.uname = pwd.getpwuid(tarinfo.uid)[0]
            except KeyError:
                pass
        if grp:
            try:
                tarinfo.gname = grp.getgrgid(tarinfo.gid)[0]
            except KeyError:
                pass

        if type in (CHRTYPE, BLKTYPE):
            if hasattr(os, "major") and hasattr(os, "minor"):
                tarinfo.devmajor = os.major(statres.st_rdev)
                tarinfo.devminor = os.minor(statres.st_rdev)
        return tarinfo

    def list(self, verbose=True):
        """Print a table of contents to sys.stdout. If `verbose' is False, only
           the names of the members are printed. If it is True, an `ls -l'-like
           output is produced.
        """
        self._check()

        for tarinfo in self:
            if verbose:
                print(filemode(tarinfo.mode), end=' ')
                print("%s/%s" % (tarinfo.uname or tarinfo.uid,
                                 tarinfo.gname or tarinfo.gid), end=' ')
                if tarinfo.ischr() or tarinfo.isblk():
                    print("%10s" % ("%d,%d" \
                                    % (tarinfo.devmajor, tarinfo.devminor)), end=' ')
                else:
                    print("%10d" % tarinfo.size, end=' ')
                print("%d-%02d-%02d %02d:%02d:%02d" \
                      % time.localtime(tarinfo.mtime)[:6], end=' ')

            print(tarinfo.name + ("/" if tarinfo.isdir() else ""), end=' ')

            if verbose:
                if tarinfo.issym():
                    print("->", tarinfo.linkname, end=' ')
                if tarinfo.islnk():
                    print("link to", tarinfo.linkname, end=' ')
            print()

    def add(self, name, arcname=None, recursive=True, exclude=None, filter=None):
        """Add the file `name' to the archive. `name' may be any type of file
           (directory, fifo, symbolic link, etc.). If given, `arcname'
           specifies an alternative name for the file in the archive.
           Directories are added recursively by default. This can be avoided by
           setting `recursive' to False. `exclude' is a function that should
           return True for each filename to be excluded. `filter' is a function
           that expects a TarInfo object argument and returns the changed
           TarInfo object, if it returns None the TarInfo object will be
           excluded from the archive.
        """
        self._check("aw")

        if arcname is None:
            arcname = name

        # Exclude pathnames.
        if exclude is not None:
            import warnings
            warnings.warn("use the filter argument instead",
                    DeprecationWarning, 2)
            if exclude(name):
                self._dbg(2, "tarfile: Excluded %r" % name)
                return

        # Skip if somebody tries to archive the archive...
        if self.name is not None and os.path.abspath(name) == self.name:
            self._dbg(2, "tarfile: Skipped %r" % name)
            return

        self._dbg(1, name)

        # Create a TarInfo object from the file.
        tarinfo = self.gettarinfo(name, arcname)

        if tarinfo is None:
            self._dbg(1, "tarfile: Unsupported type %r" % name)
            return

        # Change or exclude the TarInfo object.
        if filter is not None:
            tarinfo = filter(tarinfo)
            if tarinfo is None:
                self._dbg(2, "tarfile: Excluded %r" % name)
                return

        # Append the tar header and data to the archive.
        if tarinfo.isreg():
            f = bltn_open(name, "rb")
            self.addfile(tarinfo, f)
            f.close()

        elif tarinfo.isdir():
            self.addfile(tarinfo)
            if recursive:
                for f in os.listdir(name):
                    self.add(os.path.join(name, f), os.path.join(arcname, f),
                            recursive, exclude, filter=filter)

        else:
            self.addfile(tarinfo)

    def addfile(self, tarinfo, fileobj=None):
        """Add the TarInfo object `tarinfo' to the archive. If `fileobj' is
           given, tarinfo.size bytes are read from it and added to the archive.
           You can create TarInfo objects using gettarinfo().
           On Windows platforms, `fileobj' should always be opened with mode
           'rb' to avoid irritation about the file size.
        """
        self._check("aw")

        tarinfo = copy.copy(tarinfo)

        buf = tarinfo.tobuf(self.format, self.encoding, self.errors)
        self.fileobj.write(buf)
        self.offset += len(buf)

        # If there's data to follow, append it.
        if fileobj is not None:
            copyfileobj(fileobj, self.fileobj, tarinfo.size)
            blocks, remainder = divmod(tarinfo.size, BLOCKSIZE)
            if remainder > 0:
                self.fileobj.write(NUL * (BLOCKSIZE - remainder))
                blocks += 1
            self.offset += blocks * BLOCKSIZE

        self.members.append(tarinfo)

    def extractall(self, path=".", members=None):
        """Extract all members from the archive to the current working
           directory and set owner, modification time and permissions on
           directories afterwards. `path' specifies a different directory
           to extract to. `members' is optional and must be a subset of the
           list returned by getmembers().
        """
        directories = []

        if members is None:
            members = self

        for tarinfo in members:
            if tarinfo.isdir():
                # Extract directories with a safe mode.
                directories.append(tarinfo)
                tarinfo = copy.copy(tarinfo)
                tarinfo.mode = 0o700
            # Do not set_attrs directories, as we will do that further down
            self.extract(tarinfo, path, set_attrs=not tarinfo.isdir())

        # Reverse sort directories.
        directories.sort(key=lambda a: a.name)
        directories.reverse()

        # Set correct owner, mtime and filemode on directories.
        for tarinfo in directories:
            dirpath = os.path.join(path, tarinfo.name)
            try:
                self.chown(tarinfo, dirpath)
                self.utime(tarinfo, dirpath)
                self.chmod(tarinfo, dirpath)
            except ExtractError as e:
                if self.errorlevel > 1:
                    raise
                else:
                    self._dbg(1, "tarfile: %s" % e)

    def extract(self, member, path="", set_attrs=True):
        """Extract a member from the archive to the current working directory,
           using its full name. Its file information is extracted as accurately
           as possible. `member' may be a filename or a TarInfo object. You can
           specify a different directory using `path'. File attributes (owner,
           mtime, mode) are set unless `set_attrs' is False.
        """
        self._check("r")

        if isinstance(member, str):
            tarinfo = self.getmember(member)
        else:
            tarinfo = member

        # Prepare the link target for makelink().
        if tarinfo.islnk():
            tarinfo._link_target = os.path.join(path, tarinfo.linkname)

        try:
            self._extract_member(tarinfo, os.path.join(path, tarinfo.name),
                                 set_attrs=set_attrs)
        except EnvironmentError as e:
            if self.errorlevel > 0:
                raise
            else:
                if e.filename is None:
                    self._dbg(1, "tarfile: %s" % e.strerror)
                else:
                    self._dbg(1, "tarfile: %s %r" % (e.strerror, e.filename))
        except ExtractError as e:
            if self.errorlevel > 1:
                raise
            else:
                self._dbg(1, "tarfile: %s" % e)

    def extractfile(self, member):
        """Extract a member from the archive as a file object. `member' may be
           a filename or a TarInfo object. If `member' is a regular file, a
           file-like object is returned. If `member' is a link, a file-like
           object is constructed from the link's target. If `member' is none of
           the above, None is returned.
           The file-like object is read-only and provides the following
           methods: read(), readline(), readlines(), seek() and tell()
        """
        self._check("r")

        if isinstance(member, str):
            tarinfo = self.getmember(member)
        else:
            tarinfo = member

        if tarinfo.isreg():
            return self.fileobject(self, tarinfo)

        elif tarinfo.type not in SUPPORTED_TYPES:
            # If a member's type is unknown, it is treated as a
            # regular file.
            return self.fileobject(self, tarinfo)

        elif tarinfo.islnk() or tarinfo.issym():
            if isinstance(self.fileobj, _Stream):
                # A small but ugly workaround for the case that someone tries
                # to extract a (sym)link as a file-object from a non-seekable
                # stream of tar blocks.
                raise StreamError("cannot extract (sym)link as file object")
            else:
                # A (sym)link's file object is its target's file object.
                return self.extractfile(self._find_link_target(tarinfo))
        else:
            # If there's no data associated with the member (directory, chrdev,
            # blkdev, etc.), return None instead of a file object.
            return None

    def _extract_member(self, tarinfo, targetpath, set_attrs=True):
        """Extract the TarInfo object tarinfo to a physical
           file called targetpath.
        """
        # Fetch the TarInfo object for the given name
        # and build the destination pathname, replacing
        # forward slashes to platform specific separators.
        targetpath = targetpath.rstrip("/")
        targetpath = targetpath.replace("/", os.sep)

        # Create all upper directories.
        upperdirs = os.path.dirname(targetpath)
        if upperdirs and not os.path.exists(upperdirs):
            # Create directories that are not part of the archive with
            # default permissions.
            os.makedirs(upperdirs)

        if tarinfo.islnk() or tarinfo.issym():
            self._dbg(1, "%s -> %s" % (tarinfo.name, tarinfo.linkname))
        else:
            self._dbg(1, tarinfo.name)

        if tarinfo.isreg():
            self.makefile(tarinfo, targetpath)
        elif tarinfo.isdir():
            self.makedir(tarinfo, targetpath)
        elif tarinfo.isfifo():
            self.makefifo(tarinfo, targetpath)
        elif tarinfo.ischr() or tarinfo.isblk():
            self.makedev(tarinfo, targetpath)
        elif tarinfo.islnk() or tarinfo.issym():
            self.makelink(tarinfo, targetpath)
        elif tarinfo.type not in SUPPORTED_TYPES:
            self.makeunknown(tarinfo, targetpath)
        else:
            self.makefile(tarinfo, targetpath)

        if set_attrs:
            self.chown(tarinfo, targetpath)
            if not tarinfo.issym():
                self.chmod(tarinfo, targetpath)
                self.utime(tarinfo, targetpath)

    #--------------------------------------------------------------------------
    # Below are the different file methods. They are called via
    # _extract_member() when extract() is called. They can be replaced in a
    # subclass to implement other functionality.

    def makedir(self, tarinfo, targetpath):
        """Make a directory called targetpath.
        """
        try:
            # Use a safe mode for the directory, the real mode is set
            # later in _extract_member().
            os.mkdir(targetpath, 0o700)
        except EnvironmentError as e:
            if e.errno != errno.EEXIST:
                raise

    def makefile(self, tarinfo, targetpath):
        """Make a file called targetpath.
        """
        source = self.fileobj
        source.seek(tarinfo.offset_data)
        target = bltn_open(targetpath, "wb")
        if tarinfo.sparse is not None:
            for offset, size in tarinfo.sparse:
                target.seek(offset)
                copyfileobj(source, target, size)
        else:
            copyfileobj(source, target, tarinfo.size)
        target.seek(tarinfo.size)
        target.truncate()
        target.close()

    def makeunknown(self, tarinfo, targetpath):
        """Make a file from a TarInfo object with an unknown type
           at targetpath.
        """
        self.makefile(tarinfo, targetpath)
        self._dbg(1, "tarfile: Unknown file type %r, " \
                     "extracted as regular file." % tarinfo.type)

    def makefifo(self, tarinfo, targetpath):
        """Make a fifo called targetpath.
        """
        if hasattr(os, "mkfifo"):
            os.mkfifo(targetpath)
        else:
            raise ExtractError("fifo not supported by system")

    def makedev(self, tarinfo, targetpath):
        """Make a character or block device called targetpath.
        """
        if not hasattr(os, "mknod") or not hasattr(os, "makedev"):
            raise ExtractError("special devices not supported by system")

        mode = tarinfo.mode
        if tarinfo.isblk():
            mode |= stat.S_IFBLK
        else:
            mode |= stat.S_IFCHR

        os.mknod(targetpath, mode,
                 os.makedev(tarinfo.devmajor, tarinfo.devminor))

    def makelink(self, tarinfo, targetpath):
        """Make a (symbolic) link called targetpath. If it cannot be created
          (platform limitation), we try to make a copy of the referenced file
          instead of a link.
        """
        try:
            # For systems that support symbolic and hard links.
            if tarinfo.issym():
                os.symlink(tarinfo.linkname, targetpath)
            else:
                # See extract().
                if os.path.exists(tarinfo._link_target):
                    os.link(tarinfo._link_target, targetpath)
                else:
                    self._extract_member(self._find_link_target(tarinfo),
                                         targetpath)
        except symlink_exception:
            if tarinfo.issym():
                linkpath = os.path.join(os.path.dirname(tarinfo.name),
                                        tarinfo.linkname)
            else:
                linkpath = tarinfo.linkname
        else:
            try:
                self._extract_member(self._find_link_target(tarinfo),
                                     targetpath)
            except KeyError:
                raise ExtractError("unable to resolve link inside archive")

    def chown(self, tarinfo, targetpath):
        """Set owner of targetpath according to tarinfo.
        """
        if pwd and hasattr(os, "geteuid") and os.geteuid() == 0:
            # We have to be root to do so.
            try:
                g = grp.getgrnam(tarinfo.gname)[2]
            except KeyError:
                g = tarinfo.gid
            try:
                u = pwd.getpwnam(tarinfo.uname)[2]
            except KeyError:
                u = tarinfo.uid
            try:
                if tarinfo.issym() and hasattr(os, "lchown"):
                    os.lchown(targetpath, u, g)
                else:
                    if sys.platform != "os2emx":
                        os.chown(targetpath, u, g)
            except EnvironmentError as e:
                raise ExtractError("could not change owner")

    def chmod(self, tarinfo, targetpath):
        """Set file permissions of targetpath according to tarinfo.
        """
        if hasattr(os, 'chmod'):
            try:
                os.chmod(targetpath, tarinfo.mode)
            except EnvironmentError as e:
                raise ExtractError("could not change mode")

    def utime(self, tarinfo, targetpath):
        """Set modification time of targetpath according to tarinfo.
        """
        if not hasattr(os, 'utime'):
            return
        try:
            os.utime(targetpath, (tarinfo.mtime, tarinfo.mtime))
        except EnvironmentError as e:
            raise ExtractError("could not change modification time")

    #--------------------------------------------------------------------------
    def next(self):
        """Return the next member of the archive as a TarInfo object, when
           TarFile is opened for reading. Return None if there is no more
           available.
        """
        self._check("ra")
        if self.firstmember is not None:
            m = self.firstmember
            self.firstmember = None
            return m

        # Read the next block.
        self.fileobj.seek(self.offset)
        tarinfo = None
        while True:
            try:
                tarinfo = self.tarinfo.fromtarfile(self)
            except EOFHeaderError as e:
                if self.ignore_zeros:
                    self._dbg(2, "0x%X: %s" % (self.offset, e))
                    self.offset += BLOCKSIZE
                    continue
            except InvalidHeaderError as e:
                if self.ignore_zeros:
                    self._dbg(2, "0x%X: %s" % (self.offset, e))
                    self.offset += BLOCKSIZE
                    continue
                elif self.offset == 0:
                    raise ReadError(str(e))
            except EmptyHeaderError:
                if self.offset == 0:
                    raise ReadError("empty file")
            except TruncatedHeaderError as e:
                if self.offset == 0:
                    raise ReadError(str(e))
            except SubsequentHeaderError as e:
                raise ReadError(str(e))
            break

        if tarinfo is not None:
            self.members.append(tarinfo)
        else:
            self._loaded = True

        return tarinfo

    #--------------------------------------------------------------------------
    # Little helper methods:

    def _getmember(self, name, tarinfo=None, normalize=False):
        """Find an archive member by name from bottom to top.
           If tarinfo is given, it is used as the starting point.
        """
        # Ensure that all members have been loaded.
        members = self.getmembers()

        # Limit the member search list up to tarinfo.
        if tarinfo is not None:
            members = members[:members.index(tarinfo)]

        if normalize:
            name = os.path.normpath(name)

        for member in reversed(members):
            if normalize:
                member_name = os.path.normpath(member.name)
            else:
                member_name = member.name

            if name == member_name:
                return member

    def _load(self):
        """Read through the entire archive file and look for readable
           members.
        """
        while True:
            tarinfo = self.next()
            if tarinfo is None:
                break
        self._loaded = True

    def _check(self, mode=None):
        """Check if TarFile is still open, and if the operation's mode
           corresponds to TarFile's mode.
        """
        if self.closed:
            raise IOError("%s is closed" % self.__class__.__name__)
        if mode is not None and self.mode not in mode:
            raise IOError("bad operation for mode %r" % self.mode)

    def _find_link_target(self, tarinfo):
        """Find the target member of a symlink or hardlink member in the
           archive.
        """
        if tarinfo.issym():
            # Always search the entire archive.
            linkname = os.path.dirname(tarinfo.name) + "/" + tarinfo.linkname
            limit = None
        else:
            # Search the archive before the link, because a hard link is
            # just a reference to an already archived file.
            linkname = tarinfo.linkname
            limit = tarinfo

        member = self._getmember(linkname, tarinfo=limit, normalize=True)
        if member is None:
            raise KeyError("linkname %r not found" % linkname)
        return member

    def __iter__(self):
        """Provide an iterator object.
        """
        if self._loaded:
            return iter(self.members)
        else:
            return TarIter(self)

    def _dbg(self, level, msg):
        """Write debugging output to sys.stderr.
        """
        if level <= self.debug:
            print(msg, file=sys.stderr)

    def __enter__(self):
        self._check()
        return self

    def __exit__(self, type, value, traceback):
        if type is None:
            self.close()
        else:
            # An exception occurred. We must not call close() because
            # it would try to write end-of-archive blocks and padding.
            if not self._extfileobj:
                self.fileobj.close()
            self.closed = True
# class TarFile

class TarIter(object):
    """Iterator Class.

       for tarinfo in TarFile(...):
           suite...
    """

    def __init__(self, tarfile):
        """Construct a TarIter object.
        """
        self.tarfile = tarfile
        self.index = 0
    def __iter__(self):
        """Return iterator object.
        """
        return self

    def __next__(self):
        """Return the next item using TarFile's next() method.
           When all members have been read, set TarFile as _loaded.
        """
        # Fix for SF #1100429: Under rare circumstances it can
        # happen that getmembers() is called during iteration,
        # which will cause TarIter to stop prematurely.
        if not self.tarfile._loaded:
            tarinfo = self.tarfile.next()
            if not tarinfo:
                self.tarfile._loaded = True
                raise StopIteration
        else:
            try:
                tarinfo = self.tarfile.members[self.index]
            except IndexError:
                raise StopIteration
        self.index += 1
        return tarinfo

    next = __next__ # for Python 2.x

#--------------------
# exported functions
#--------------------
def is_tarfile(name):
    """Return True if name points to a tar archive that we
       are able to handle, else return False.
    """
    try:
        t = open(name)
        t.close()
        return True
    except TarError:
        return False

bltn_open = open
open = TarFile.open

########NEW FILE########
__FILENAME__ = constants
from __future__ import absolute_import, division, unicode_literals

import string
import gettext
_ = gettext.gettext

EOF = None

E = {
    "null-character":
        _("Null character in input stream, replaced with U+FFFD."),
    "invalid-codepoint":
        _("Invalid codepoint in stream."),
    "incorrectly-placed-solidus":
        _("Solidus (/) incorrectly placed in tag."),
    "incorrect-cr-newline-entity":
        _("Incorrect CR newline entity, replaced with LF."),
    "illegal-windows-1252-entity":
        _("Entity used with illegal number (windows-1252 reference)."),
    "cant-convert-numeric-entity":
        _("Numeric entity couldn't be converted to character "
          "(codepoint U+%(charAsInt)08x)."),
    "illegal-codepoint-for-numeric-entity":
        _("Numeric entity represents an illegal codepoint: "
          "U+%(charAsInt)08x."),
    "numeric-entity-without-semicolon":
        _("Numeric entity didn't end with ';'."),
    "expected-numeric-entity-but-got-eof":
        _("Numeric entity expected. Got end of file instead."),
    "expected-numeric-entity":
        _("Numeric entity expected but none found."),
    "named-entity-without-semicolon":
        _("Named entity didn't end with ';'."),
    "expected-named-entity":
        _("Named entity expected. Got none."),
    "attributes-in-end-tag":
        _("End tag contains unexpected attributes."),
    'self-closing-flag-on-end-tag':
        _("End tag contains unexpected self-closing flag."),
    "expected-tag-name-but-got-right-bracket":
        _("Expected tag name. Got '>' instead."),
    "expected-tag-name-but-got-question-mark":
        _("Expected tag name. Got '?' instead. (HTML doesn't "
          "support processing instructions.)"),
    "expected-tag-name":
        _("Expected tag name. Got something else instead"),
    "expected-closing-tag-but-got-right-bracket":
        _("Expected closing tag. Got '>' instead. Ignoring '</>'."),
    "expected-closing-tag-but-got-eof":
        _("Expected closing tag. Unexpected end of file."),
    "expected-closing-tag-but-got-char":
        _("Expected closing tag. Unexpected character '%(data)s' found."),
    "eof-in-tag-name":
        _("Unexpected end of file in the tag name."),
    "expected-attribute-name-but-got-eof":
        _("Unexpected end of file. Expected attribute name instead."),
    "eof-in-attribute-name":
        _("Unexpected end of file in attribute name."),
    "invalid-character-in-attribute-name":
        _("Invalid character in attribute name"),
    "duplicate-attribute":
        _("Dropped duplicate attribute on tag."),
    "expected-end-of-tag-name-but-got-eof":
        _("Unexpected end of file. Expected = or end of tag."),
    "expected-attribute-value-but-got-eof":
        _("Unexpected end of file. Expected attribute value."),
    "expected-attribute-value-but-got-right-bracket":
        _("Expected attribute value. Got '>' instead."),
    'equals-in-unquoted-attribute-value':
        _("Unexpected = in unquoted attribute"),
    'unexpected-character-in-unquoted-attribute-value':
        _("Unexpected character in unquoted attribute"),
    "invalid-character-after-attribute-name":
        _("Unexpected character after attribute name."),
    "unexpected-character-after-attribute-value":
        _("Unexpected character after attribute value."),
    "eof-in-attribute-value-double-quote":
        _("Unexpected end of file in attribute value (\")."),
    "eof-in-attribute-value-single-quote":
        _("Unexpected end of file in attribute value (')."),
    "eof-in-attribute-value-no-quotes":
        _("Unexpected end of file in attribute value."),
    "unexpected-EOF-after-solidus-in-tag":
        _("Unexpected end of file in tag. Expected >"),
    "unexpected-character-after-solidus-in-tag":
        _("Unexpected character after / in tag. Expected >"),
    "expected-dashes-or-doctype":
        _("Expected '--' or 'DOCTYPE'. Not found."),
    "unexpected-bang-after-double-dash-in-comment":
        _("Unexpected ! after -- in comment"),
    "unexpected-space-after-double-dash-in-comment":
        _("Unexpected space after -- in comment"),
    "incorrect-comment":
        _("Incorrect comment."),
    "eof-in-comment":
        _("Unexpected end of file in comment."),
    "eof-in-comment-end-dash":
        _("Unexpected end of file in comment (-)"),
    "unexpected-dash-after-double-dash-in-comment":
        _("Unexpected '-' after '--' found in comment."),
    "eof-in-comment-double-dash":
        _("Unexpected end of file in comment (--)."),
    "eof-in-comment-end-space-state":
        _("Unexpected end of file in comment."),
    "eof-in-comment-end-bang-state":
        _("Unexpected end of file in comment."),
    "unexpected-char-in-comment":
        _("Unexpected character in comment found."),
    "need-space-after-doctype":
        _("No space after literal string 'DOCTYPE'."),
    "expected-doctype-name-but-got-right-bracket":
        _("Unexpected > character. Expected DOCTYPE name."),
    "expected-doctype-name-but-got-eof":
        _("Unexpected end of file. Expected DOCTYPE name."),
    "eof-in-doctype-name":
        _("Unexpected end of file in DOCTYPE name."),
    "eof-in-doctype":
        _("Unexpected end of file in DOCTYPE."),
    "expected-space-or-right-bracket-in-doctype":
        _("Expected space or '>'. Got '%(data)s'"),
    "unexpected-end-of-doctype":
        _("Unexpected end of DOCTYPE."),
    "unexpected-char-in-doctype":
        _("Unexpected character in DOCTYPE."),
    "eof-in-innerhtml":
        _("XXX innerHTML EOF"),
    "unexpected-doctype":
        _("Unexpected DOCTYPE. Ignored."),
    "non-html-root":
        _("html needs to be the first start tag."),
    "expected-doctype-but-got-eof":
        _("Unexpected End of file. Expected DOCTYPE."),
    "unknown-doctype":
        _("Erroneous DOCTYPE."),
    "expected-doctype-but-got-chars":
        _("Unexpected non-space characters. Expected DOCTYPE."),
    "expected-doctype-but-got-start-tag":
        _("Unexpected start tag (%(name)s). Expected DOCTYPE."),
    "expected-doctype-but-got-end-tag":
        _("Unexpected end tag (%(name)s). Expected DOCTYPE."),
    "end-tag-after-implied-root":
        _("Unexpected end tag (%(name)s) after the (implied) root element."),
    "expected-named-closing-tag-but-got-eof":
        _("Unexpected end of file. Expected end tag (%(name)s)."),
    "two-heads-are-not-better-than-one":
        _("Unexpected start tag head in existing head. Ignored."),
    "unexpected-end-tag":
        _("Unexpected end tag (%(name)s). Ignored."),
    "unexpected-start-tag-out-of-my-head":
        _("Unexpected start tag (%(name)s) that can be in head. Moved."),
    "unexpected-start-tag":
        _("Unexpected start tag (%(name)s)."),
    "missing-end-tag":
        _("Missing end tag (%(name)s)."),
    "missing-end-tags":
        _("Missing end tags (%(name)s)."),
    "unexpected-start-tag-implies-end-tag":
        _("Unexpected start tag (%(startName)s) "
          "implies end tag (%(endName)s)."),
    "unexpected-start-tag-treated-as":
        _("Unexpected start tag (%(originalName)s). Treated as %(newName)s."),
    "deprecated-tag":
        _("Unexpected start tag %(name)s. Don't use it!"),
    "unexpected-start-tag-ignored":
        _("Unexpected start tag %(name)s. Ignored."),
    "expected-one-end-tag-but-got-another":
        _("Unexpected end tag (%(gotName)s). "
          "Missing end tag (%(expectedName)s)."),
    "end-tag-too-early":
        _("End tag (%(name)s) seen too early. Expected other end tag."),
    "end-tag-too-early-named":
        _("Unexpected end tag (%(gotName)s). Expected end tag (%(expectedName)s)."),
    "end-tag-too-early-ignored":
        _("End tag (%(name)s) seen too early. Ignored."),
    "adoption-agency-1.1":
        _("End tag (%(name)s) violates step 1, "
          "paragraph 1 of the adoption agency algorithm."),
    "adoption-agency-1.2":
        _("End tag (%(name)s) violates step 1, "
          "paragraph 2 of the adoption agency algorithm."),
    "adoption-agency-1.3":
        _("End tag (%(name)s) violates step 1, "
          "paragraph 3 of the adoption agency algorithm."),
    "adoption-agency-4.4":
        _("End tag (%(name)s) violates step 4, "
          "paragraph 4 of the adoption agency algorithm."),
    "unexpected-end-tag-treated-as":
        _("Unexpected end tag (%(originalName)s). Treated as %(newName)s."),
    "no-end-tag":
        _("This element (%(name)s) has no end tag."),
    "unexpected-implied-end-tag-in-table":
        _("Unexpected implied end tag (%(name)s) in the table phase."),
    "unexpected-implied-end-tag-in-table-body":
        _("Unexpected implied end tag (%(name)s) in the table body phase."),
    "unexpected-char-implies-table-voodoo":
        _("Unexpected non-space characters in "
          "table context caused voodoo mode."),
    "unexpected-hidden-input-in-table":
        _("Unexpected input with type hidden in table context."),
    "unexpected-form-in-table":
        _("Unexpected form in table context."),
    "unexpected-start-tag-implies-table-voodoo":
        _("Unexpected start tag (%(name)s) in "
          "table context caused voodoo mode."),
    "unexpected-end-tag-implies-table-voodoo":
        _("Unexpected end tag (%(name)s) in "
          "table context caused voodoo mode."),
    "unexpected-cell-in-table-body":
        _("Unexpected table cell start tag (%(name)s) "
          "in the table body phase."),
    "unexpected-cell-end-tag":
        _("Got table cell end tag (%(name)s) "
          "while required end tags are missing."),
    "unexpected-end-tag-in-table-body":
        _("Unexpected end tag (%(name)s) in the table body phase. Ignored."),
    "unexpected-implied-end-tag-in-table-row":
        _("Unexpected implied end tag (%(name)s) in the table row phase."),
    "unexpected-end-tag-in-table-row":
        _("Unexpected end tag (%(name)s) in the table row phase. Ignored."),
    "unexpected-select-in-select":
        _("Unexpected select start tag in the select phase "
          "treated as select end tag."),
    "unexpected-input-in-select":
        _("Unexpected input start tag in the select phase."),
    "unexpected-start-tag-in-select":
        _("Unexpected start tag token (%(name)s in the select phase. "
          "Ignored."),
    "unexpected-end-tag-in-select":
        _("Unexpected end tag (%(name)s) in the select phase. Ignored."),
    "unexpected-table-element-start-tag-in-select-in-table":
        _("Unexpected table element start tag (%(name)s) in the select in table phase."),
    "unexpected-table-element-end-tag-in-select-in-table":
        _("Unexpected table element end tag (%(name)s) in the select in table phase."),
    "unexpected-char-after-body":
        _("Unexpected non-space characters in the after body phase."),
    "unexpected-start-tag-after-body":
        _("Unexpected start tag token (%(name)s)"
          " in the after body phase."),
    "unexpected-end-tag-after-body":
        _("Unexpected end tag token (%(name)s)"
          " in the after body phase."),
    "unexpected-char-in-frameset":
        _("Unexpected characters in the frameset phase. Characters ignored."),
    "unexpected-start-tag-in-frameset":
        _("Unexpected start tag token (%(name)s)"
          " in the frameset phase. Ignored."),
    "unexpected-frameset-in-frameset-innerhtml":
        _("Unexpected end tag token (frameset) "
          "in the frameset phase (innerHTML)."),
    "unexpected-end-tag-in-frameset":
        _("Unexpected end tag token (%(name)s)"
          " in the frameset phase. Ignored."),
    "unexpected-char-after-frameset":
        _("Unexpected non-space characters in the "
          "after frameset phase. Ignored."),
    "unexpected-start-tag-after-frameset":
        _("Unexpected start tag (%(name)s)"
          " in the after frameset phase. Ignored."),
    "unexpected-end-tag-after-frameset":
        _("Unexpected end tag (%(name)s)"
          " in the after frameset phase. Ignored."),
    "unexpected-end-tag-after-body-innerhtml":
        _("Unexpected end tag after body(innerHtml)"),
    "expected-eof-but-got-char":
        _("Unexpected non-space characters. Expected end of file."),
    "expected-eof-but-got-start-tag":
        _("Unexpected start tag (%(name)s)"
          ". Expected end of file."),
    "expected-eof-but-got-end-tag":
        _("Unexpected end tag (%(name)s)"
          ". Expected end of file."),
    "eof-in-table":
        _("Unexpected end of file. Expected table content."),
    "eof-in-select":
        _("Unexpected end of file. Expected select content."),
    "eof-in-frameset":
        _("Unexpected end of file. Expected frameset content."),
    "eof-in-script-in-script":
        _("Unexpected end of file. Expected script content."),
    "eof-in-foreign-lands":
        _("Unexpected end of file. Expected foreign content"),
    "non-void-element-with-trailing-solidus":
        _("Trailing solidus not allowed on element %(name)s"),
    "unexpected-html-element-in-foreign-content":
        _("Element %(name)s not allowed in a non-html context"),
    "unexpected-end-tag-before-html":
        _("Unexpected end tag (%(name)s) before html."),
    "XXX-undefined-error":
        _("Undefined error (this sucks and should be fixed)"),
}

namespaces = {
    "html": "http://www.w3.org/1999/xhtml",
    "mathml": "http://www.w3.org/1998/Math/MathML",
    "svg": "http://www.w3.org/2000/svg",
    "xlink": "http://www.w3.org/1999/xlink",
    "xml": "http://www.w3.org/XML/1998/namespace",
    "xmlns": "http://www.w3.org/2000/xmlns/"
}

scopingElements = frozenset((
    (namespaces["html"], "applet"),
    (namespaces["html"], "caption"),
    (namespaces["html"], "html"),
    (namespaces["html"], "marquee"),
    (namespaces["html"], "object"),
    (namespaces["html"], "table"),
    (namespaces["html"], "td"),
    (namespaces["html"], "th"),
    (namespaces["mathml"], "mi"),
    (namespaces["mathml"], "mo"),
    (namespaces["mathml"], "mn"),
    (namespaces["mathml"], "ms"),
    (namespaces["mathml"], "mtext"),
    (namespaces["mathml"], "annotation-xml"),
    (namespaces["svg"], "foreignObject"),
    (namespaces["svg"], "desc"),
    (namespaces["svg"], "title"),
))

formattingElements = frozenset((
    (namespaces["html"], "a"),
    (namespaces["html"], "b"),
    (namespaces["html"], "big"),
    (namespaces["html"], "code"),
    (namespaces["html"], "em"),
    (namespaces["html"], "font"),
    (namespaces["html"], "i"),
    (namespaces["html"], "nobr"),
    (namespaces["html"], "s"),
    (namespaces["html"], "small"),
    (namespaces["html"], "strike"),
    (namespaces["html"], "strong"),
    (namespaces["html"], "tt"),
    (namespaces["html"], "u")
))

specialElements = frozenset((
    (namespaces["html"], "address"),
    (namespaces["html"], "applet"),
    (namespaces["html"], "area"),
    (namespaces["html"], "article"),
    (namespaces["html"], "aside"),
    (namespaces["html"], "base"),
    (namespaces["html"], "basefont"),
    (namespaces["html"], "bgsound"),
    (namespaces["html"], "blockquote"),
    (namespaces["html"], "body"),
    (namespaces["html"], "br"),
    (namespaces["html"], "button"),
    (namespaces["html"], "caption"),
    (namespaces["html"], "center"),
    (namespaces["html"], "col"),
    (namespaces["html"], "colgroup"),
    (namespaces["html"], "command"),
    (namespaces["html"], "dd"),
    (namespaces["html"], "details"),
    (namespaces["html"], "dir"),
    (namespaces["html"], "div"),
    (namespaces["html"], "dl"),
    (namespaces["html"], "dt"),
    (namespaces["html"], "embed"),
    (namespaces["html"], "fieldset"),
    (namespaces["html"], "figure"),
    (namespaces["html"], "footer"),
    (namespaces["html"], "form"),
    (namespaces["html"], "frame"),
    (namespaces["html"], "frameset"),
    (namespaces["html"], "h1"),
    (namespaces["html"], "h2"),
    (namespaces["html"], "h3"),
    (namespaces["html"], "h4"),
    (namespaces["html"], "h5"),
    (namespaces["html"], "h6"),
    (namespaces["html"], "head"),
    (namespaces["html"], "header"),
    (namespaces["html"], "hr"),
    (namespaces["html"], "html"),
    (namespaces["html"], "iframe"),
    # Note that image is commented out in the spec as "this isn't an
    # element that can end up on the stack, so it doesn't matter,"
    (namespaces["html"], "image"),
    (namespaces["html"], "img"),
    (namespaces["html"], "input"),
    (namespaces["html"], "isindex"),
    (namespaces["html"], "li"),
    (namespaces["html"], "link"),
    (namespaces["html"], "listing"),
    (namespaces["html"], "marquee"),
    (namespaces["html"], "menu"),
    (namespaces["html"], "meta"),
    (namespaces["html"], "nav"),
    (namespaces["html"], "noembed"),
    (namespaces["html"], "noframes"),
    (namespaces["html"], "noscript"),
    (namespaces["html"], "object"),
    (namespaces["html"], "ol"),
    (namespaces["html"], "p"),
    (namespaces["html"], "param"),
    (namespaces["html"], "plaintext"),
    (namespaces["html"], "pre"),
    (namespaces["html"], "script"),
    (namespaces["html"], "section"),
    (namespaces["html"], "select"),
    (namespaces["html"], "style"),
    (namespaces["html"], "table"),
    (namespaces["html"], "tbody"),
    (namespaces["html"], "td"),
    (namespaces["html"], "textarea"),
    (namespaces["html"], "tfoot"),
    (namespaces["html"], "th"),
    (namespaces["html"], "thead"),
    (namespaces["html"], "title"),
    (namespaces["html"], "tr"),
    (namespaces["html"], "ul"),
    (namespaces["html"], "wbr"),
    (namespaces["html"], "xmp"),
    (namespaces["svg"], "foreignObject")
))

htmlIntegrationPointElements = frozenset((
    (namespaces["mathml"], "annotaion-xml"),
    (namespaces["svg"], "foreignObject"),
    (namespaces["svg"], "desc"),
    (namespaces["svg"], "title")
))

mathmlTextIntegrationPointElements = frozenset((
    (namespaces["mathml"], "mi"),
    (namespaces["mathml"], "mo"),
    (namespaces["mathml"], "mn"),
    (namespaces["mathml"], "ms"),
    (namespaces["mathml"], "mtext")
))

adjustForeignAttributes = {
    "xlink:actuate": ("xlink", "actuate", namespaces["xlink"]),
    "xlink:arcrole": ("xlink", "arcrole", namespaces["xlink"]),
    "xlink:href": ("xlink", "href", namespaces["xlink"]),
    "xlink:role": ("xlink", "role", namespaces["xlink"]),
    "xlink:show": ("xlink", "show", namespaces["xlink"]),
    "xlink:title": ("xlink", "title", namespaces["xlink"]),
    "xlink:type": ("xlink", "type", namespaces["xlink"]),
    "xml:base": ("xml", "base", namespaces["xml"]),
    "xml:lang": ("xml", "lang", namespaces["xml"]),
    "xml:space": ("xml", "space", namespaces["xml"]),
    "xmlns": (None, "xmlns", namespaces["xmlns"]),
    "xmlns:xlink": ("xmlns", "xlink", namespaces["xmlns"])
}

unadjustForeignAttributes = dict([((ns, local), qname) for qname, (prefix, local, ns) in
                                  adjustForeignAttributes.items()])

spaceCharacters = frozenset((
    "\t",
    "\n",
    "\u000C",
    " ",
    "\r"
))

tableInsertModeElements = frozenset((
    "table",
    "tbody",
    "tfoot",
    "thead",
    "tr"
))

asciiLowercase = frozenset(string.ascii_lowercase)
asciiUppercase = frozenset(string.ascii_uppercase)
asciiLetters = frozenset(string.ascii_letters)
digits = frozenset(string.digits)
hexDigits = frozenset(string.hexdigits)

asciiUpper2Lower = dict([(ord(c), ord(c.lower()))
                         for c in string.ascii_uppercase])

# Heading elements need to be ordered
headingElements = (
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6"
)

voidElements = frozenset((
    "base",
    "command",
    "event-source",
    "link",
    "meta",
    "hr",
    "br",
    "img",
    "embed",
    "param",
    "area",
    "col",
    "input",
    "source",
    "track"
))

cdataElements = frozenset(('title', 'textarea'))

rcdataElements = frozenset((
    'style',
    'script',
    'xmp',
    'iframe',
    'noembed',
    'noframes',
    'noscript'
))

booleanAttributes = {
    "": frozenset(("irrelevant",)),
    "style": frozenset(("scoped",)),
    "img": frozenset(("ismap",)),
    "audio": frozenset(("autoplay", "controls")),
    "video": frozenset(("autoplay", "controls")),
    "script": frozenset(("defer", "async")),
    "details": frozenset(("open",)),
    "datagrid": frozenset(("multiple", "disabled")),
    "command": frozenset(("hidden", "disabled", "checked", "default")),
    "hr": frozenset(("noshade")),
    "menu": frozenset(("autosubmit",)),
    "fieldset": frozenset(("disabled", "readonly")),
    "option": frozenset(("disabled", "readonly", "selected")),
    "optgroup": frozenset(("disabled", "readonly")),
    "button": frozenset(("disabled", "autofocus")),
    "input": frozenset(("disabled", "readonly", "required", "autofocus", "checked", "ismap")),
    "select": frozenset(("disabled", "readonly", "autofocus", "multiple")),
    "output": frozenset(("disabled", "readonly")),
}

# entitiesWindows1252 has to be _ordered_ and needs to have an index. It
# therefore can't be a frozenset.
entitiesWindows1252 = (
    8364,   # 0x80  0x20AC  EURO SIGN
    65533,  # 0x81          UNDEFINED
    8218,   # 0x82  0x201A  SINGLE LOW-9 QUOTATION MARK
    402,    # 0x83  0x0192  LATIN SMALL LETTER F WITH HOOK
    8222,   # 0x84  0x201E  DOUBLE LOW-9 QUOTATION MARK
    8230,   # 0x85  0x2026  HORIZONTAL ELLIPSIS
    8224,   # 0x86  0x2020  DAGGER
    8225,   # 0x87  0x2021  DOUBLE DAGGER
    710,    # 0x88  0x02C6  MODIFIER LETTER CIRCUMFLEX ACCENT
    8240,   # 0x89  0x2030  PER MILLE SIGN
    352,    # 0x8A  0x0160  LATIN CAPITAL LETTER S WITH CARON
    8249,   # 0x8B  0x2039  SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    338,    # 0x8C  0x0152  LATIN CAPITAL LIGATURE OE
    65533,  # 0x8D          UNDEFINED
    381,    # 0x8E  0x017D  LATIN CAPITAL LETTER Z WITH CARON
    65533,  # 0x8F          UNDEFINED
    65533,  # 0x90          UNDEFINED
    8216,   # 0x91  0x2018  LEFT SINGLE QUOTATION MARK
    8217,   # 0x92  0x2019  RIGHT SINGLE QUOTATION MARK
    8220,   # 0x93  0x201C  LEFT DOUBLE QUOTATION MARK
    8221,   # 0x94  0x201D  RIGHT DOUBLE QUOTATION MARK
    8226,   # 0x95  0x2022  BULLET
    8211,   # 0x96  0x2013  EN DASH
    8212,   # 0x97  0x2014  EM DASH
    732,    # 0x98  0x02DC  SMALL TILDE
    8482,   # 0x99  0x2122  TRADE MARK SIGN
    353,    # 0x9A  0x0161  LATIN SMALL LETTER S WITH CARON
    8250,   # 0x9B  0x203A  SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    339,    # 0x9C  0x0153  LATIN SMALL LIGATURE OE
    65533,  # 0x9D          UNDEFINED
    382,    # 0x9E  0x017E  LATIN SMALL LETTER Z WITH CARON
    376     # 0x9F  0x0178  LATIN CAPITAL LETTER Y WITH DIAERESIS
)

xmlEntities = frozenset(('lt;', 'gt;', 'amp;', 'apos;', 'quot;'))

entities = {
    "AElig": "\xc6",
    "AElig;": "\xc6",
    "AMP": "&",
    "AMP;": "&",
    "Aacute": "\xc1",
    "Aacute;": "\xc1",
    "Abreve;": "\u0102",
    "Acirc": "\xc2",
    "Acirc;": "\xc2",
    "Acy;": "\u0410",
    "Afr;": "\U0001d504",
    "Agrave": "\xc0",
    "Agrave;": "\xc0",
    "Alpha;": "\u0391",
    "Amacr;": "\u0100",
    "And;": "\u2a53",
    "Aogon;": "\u0104",
    "Aopf;": "\U0001d538",
    "ApplyFunction;": "\u2061",
    "Aring": "\xc5",
    "Aring;": "\xc5",
    "Ascr;": "\U0001d49c",
    "Assign;": "\u2254",
    "Atilde": "\xc3",
    "Atilde;": "\xc3",
    "Auml": "\xc4",
    "Auml;": "\xc4",
    "Backslash;": "\u2216",
    "Barv;": "\u2ae7",
    "Barwed;": "\u2306",
    "Bcy;": "\u0411",
    "Because;": "\u2235",
    "Bernoullis;": "\u212c",
    "Beta;": "\u0392",
    "Bfr;": "\U0001d505",
    "Bopf;": "\U0001d539",
    "Breve;": "\u02d8",
    "Bscr;": "\u212c",
    "Bumpeq;": "\u224e",
    "CHcy;": "\u0427",
    "COPY": "\xa9",
    "COPY;": "\xa9",
    "Cacute;": "\u0106",
    "Cap;": "\u22d2",
    "CapitalDifferentialD;": "\u2145",
    "Cayleys;": "\u212d",
    "Ccaron;": "\u010c",
    "Ccedil": "\xc7",
    "Ccedil;": "\xc7",
    "Ccirc;": "\u0108",
    "Cconint;": "\u2230",
    "Cdot;": "\u010a",
    "Cedilla;": "\xb8",
    "CenterDot;": "\xb7",
    "Cfr;": "\u212d",
    "Chi;": "\u03a7",
    "CircleDot;": "\u2299",
    "CircleMinus;": "\u2296",
    "CirclePlus;": "\u2295",
    "CircleTimes;": "\u2297",
    "ClockwiseContourIntegral;": "\u2232",
    "CloseCurlyDoubleQuote;": "\u201d",
    "CloseCurlyQuote;": "\u2019",
    "Colon;": "\u2237",
    "Colone;": "\u2a74",
    "Congruent;": "\u2261",
    "Conint;": "\u222f",
    "ContourIntegral;": "\u222e",
    "Copf;": "\u2102",
    "Coproduct;": "\u2210",
    "CounterClockwiseContourIntegral;": "\u2233",
    "Cross;": "\u2a2f",
    "Cscr;": "\U0001d49e",
    "Cup;": "\u22d3",
    "CupCap;": "\u224d",
    "DD;": "\u2145",
    "DDotrahd;": "\u2911",
    "DJcy;": "\u0402",
    "DScy;": "\u0405",
    "DZcy;": "\u040f",
    "Dagger;": "\u2021",
    "Darr;": "\u21a1",
    "Dashv;": "\u2ae4",
    "Dcaron;": "\u010e",
    "Dcy;": "\u0414",
    "Del;": "\u2207",
    "Delta;": "\u0394",
    "Dfr;": "\U0001d507",
    "DiacriticalAcute;": "\xb4",
    "DiacriticalDot;": "\u02d9",
    "DiacriticalDoubleAcute;": "\u02dd",
    "DiacriticalGrave;": "`",
    "DiacriticalTilde;": "\u02dc",
    "Diamond;": "\u22c4",
    "DifferentialD;": "\u2146",
    "Dopf;": "\U0001d53b",
    "Dot;": "\xa8",
    "DotDot;": "\u20dc",
    "DotEqual;": "\u2250",
    "DoubleContourIntegral;": "\u222f",
    "DoubleDot;": "\xa8",
    "DoubleDownArrow;": "\u21d3",
    "DoubleLeftArrow;": "\u21d0",
    "DoubleLeftRightArrow;": "\u21d4",
    "DoubleLeftTee;": "\u2ae4",
    "DoubleLongLeftArrow;": "\u27f8",
    "DoubleLongLeftRightArrow;": "\u27fa",
    "DoubleLongRightArrow;": "\u27f9",
    "DoubleRightArrow;": "\u21d2",
    "DoubleRightTee;": "\u22a8",
    "DoubleUpArrow;": "\u21d1",
    "DoubleUpDownArrow;": "\u21d5",
    "DoubleVerticalBar;": "\u2225",
    "DownArrow;": "\u2193",
    "DownArrowBar;": "\u2913",
    "DownArrowUpArrow;": "\u21f5",
    "DownBreve;": "\u0311",
    "DownLeftRightVector;": "\u2950",
    "DownLeftTeeVector;": "\u295e",
    "DownLeftVector;": "\u21bd",
    "DownLeftVectorBar;": "\u2956",
    "DownRightTeeVector;": "\u295f",
    "DownRightVector;": "\u21c1",
    "DownRightVectorBar;": "\u2957",
    "DownTee;": "\u22a4",
    "DownTeeArrow;": "\u21a7",
    "Downarrow;": "\u21d3",
    "Dscr;": "\U0001d49f",
    "Dstrok;": "\u0110",
    "ENG;": "\u014a",
    "ETH": "\xd0",
    "ETH;": "\xd0",
    "Eacute": "\xc9",
    "Eacute;": "\xc9",
    "Ecaron;": "\u011a",
    "Ecirc": "\xca",
    "Ecirc;": "\xca",
    "Ecy;": "\u042d",
    "Edot;": "\u0116",
    "Efr;": "\U0001d508",
    "Egrave": "\xc8",
    "Egrave;": "\xc8",
    "Element;": "\u2208",
    "Emacr;": "\u0112",
    "EmptySmallSquare;": "\u25fb",
    "EmptyVerySmallSquare;": "\u25ab",
    "Eogon;": "\u0118",
    "Eopf;": "\U0001d53c",
    "Epsilon;": "\u0395",
    "Equal;": "\u2a75",
    "EqualTilde;": "\u2242",
    "Equilibrium;": "\u21cc",
    "Escr;": "\u2130",
    "Esim;": "\u2a73",
    "Eta;": "\u0397",
    "Euml": "\xcb",
    "Euml;": "\xcb",
    "Exists;": "\u2203",
    "ExponentialE;": "\u2147",
    "Fcy;": "\u0424",
    "Ffr;": "\U0001d509",
    "FilledSmallSquare;": "\u25fc",
    "FilledVerySmallSquare;": "\u25aa",
    "Fopf;": "\U0001d53d",
    "ForAll;": "\u2200",
    "Fouriertrf;": "\u2131",
    "Fscr;": "\u2131",
    "GJcy;": "\u0403",
    "GT": ">",
    "GT;": ">",
    "Gamma;": "\u0393",
    "Gammad;": "\u03dc",
    "Gbreve;": "\u011e",
    "Gcedil;": "\u0122",
    "Gcirc;": "\u011c",
    "Gcy;": "\u0413",
    "Gdot;": "\u0120",
    "Gfr;": "\U0001d50a",
    "Gg;": "\u22d9",
    "Gopf;": "\U0001d53e",
    "GreaterEqual;": "\u2265",
    "GreaterEqualLess;": "\u22db",
    "GreaterFullEqual;": "\u2267",
    "GreaterGreater;": "\u2aa2",
    "GreaterLess;": "\u2277",
    "GreaterSlantEqual;": "\u2a7e",
    "GreaterTilde;": "\u2273",
    "Gscr;": "\U0001d4a2",
    "Gt;": "\u226b",
    "HARDcy;": "\u042a",
    "Hacek;": "\u02c7",
    "Hat;": "^",
    "Hcirc;": "\u0124",
    "Hfr;": "\u210c",
    "HilbertSpace;": "\u210b",
    "Hopf;": "\u210d",
    "HorizontalLine;": "\u2500",
    "Hscr;": "\u210b",
    "Hstrok;": "\u0126",
    "HumpDownHump;": "\u224e",
    "HumpEqual;": "\u224f",
    "IEcy;": "\u0415",
    "IJlig;": "\u0132",
    "IOcy;": "\u0401",
    "Iacute": "\xcd",
    "Iacute;": "\xcd",
    "Icirc": "\xce",
    "Icirc;": "\xce",
    "Icy;": "\u0418",
    "Idot;": "\u0130",
    "Ifr;": "\u2111",
    "Igrave": "\xcc",
    "Igrave;": "\xcc",
    "Im;": "\u2111",
    "Imacr;": "\u012a",
    "ImaginaryI;": "\u2148",
    "Implies;": "\u21d2",
    "Int;": "\u222c",
    "Integral;": "\u222b",
    "Intersection;": "\u22c2",
    "InvisibleComma;": "\u2063",
    "InvisibleTimes;": "\u2062",
    "Iogon;": "\u012e",
    "Iopf;": "\U0001d540",
    "Iota;": "\u0399",
    "Iscr;": "\u2110",
    "Itilde;": "\u0128",
    "Iukcy;": "\u0406",
    "Iuml": "\xcf",
    "Iuml;": "\xcf",
    "Jcirc;": "\u0134",
    "Jcy;": "\u0419",
    "Jfr;": "\U0001d50d",
    "Jopf;": "\U0001d541",
    "Jscr;": "\U0001d4a5",
    "Jsercy;": "\u0408",
    "Jukcy;": "\u0404",
    "KHcy;": "\u0425",
    "KJcy;": "\u040c",
    "Kappa;": "\u039a",
    "Kcedil;": "\u0136",
    "Kcy;": "\u041a",
    "Kfr;": "\U0001d50e",
    "Kopf;": "\U0001d542",
    "Kscr;": "\U0001d4a6",
    "LJcy;": "\u0409",
    "LT": "<",
    "LT;": "<",
    "Lacute;": "\u0139",
    "Lambda;": "\u039b",
    "Lang;": "\u27ea",
    "Laplacetrf;": "\u2112",
    "Larr;": "\u219e",
    "Lcaron;": "\u013d",
    "Lcedil;": "\u013b",
    "Lcy;": "\u041b",
    "LeftAngleBracket;": "\u27e8",
    "LeftArrow;": "\u2190",
    "LeftArrowBar;": "\u21e4",
    "LeftArrowRightArrow;": "\u21c6",
    "LeftCeiling;": "\u2308",
    "LeftDoubleBracket;": "\u27e6",
    "LeftDownTeeVector;": "\u2961",
    "LeftDownVector;": "\u21c3",
    "LeftDownVectorBar;": "\u2959",
    "LeftFloor;": "\u230a",
    "LeftRightArrow;": "\u2194",
    "LeftRightVector;": "\u294e",
    "LeftTee;": "\u22a3",
    "LeftTeeArrow;": "\u21a4",
    "LeftTeeVector;": "\u295a",
    "LeftTriangle;": "\u22b2",
    "LeftTriangleBar;": "\u29cf",
    "LeftTriangleEqual;": "\u22b4",
    "LeftUpDownVector;": "\u2951",
    "LeftUpTeeVector;": "\u2960",
    "LeftUpVector;": "\u21bf",
    "LeftUpVectorBar;": "\u2958",
    "LeftVector;": "\u21bc",
    "LeftVectorBar;": "\u2952",
    "Leftarrow;": "\u21d0",
    "Leftrightarrow;": "\u21d4",
    "LessEqualGreater;": "\u22da",
    "LessFullEqual;": "\u2266",
    "LessGreater;": "\u2276",
    "LessLess;": "\u2aa1",
    "LessSlantEqual;": "\u2a7d",
    "LessTilde;": "\u2272",
    "Lfr;": "\U0001d50f",
    "Ll;": "\u22d8",
    "Lleftarrow;": "\u21da",
    "Lmidot;": "\u013f",
    "LongLeftArrow;": "\u27f5",
    "LongLeftRightArrow;": "\u27f7",
    "LongRightArrow;": "\u27f6",
    "Longleftarrow;": "\u27f8",
    "Longleftrightarrow;": "\u27fa",
    "Longrightarrow;": "\u27f9",
    "Lopf;": "\U0001d543",
    "LowerLeftArrow;": "\u2199",
    "LowerRightArrow;": "\u2198",
    "Lscr;": "\u2112",
    "Lsh;": "\u21b0",
    "Lstrok;": "\u0141",
    "Lt;": "\u226a",
    "Map;": "\u2905",
    "Mcy;": "\u041c",
    "MediumSpace;": "\u205f",
    "Mellintrf;": "\u2133",
    "Mfr;": "\U0001d510",
    "MinusPlus;": "\u2213",
    "Mopf;": "\U0001d544",
    "Mscr;": "\u2133",
    "Mu;": "\u039c",
    "NJcy;": "\u040a",
    "Nacute;": "\u0143",
    "Ncaron;": "\u0147",
    "Ncedil;": "\u0145",
    "Ncy;": "\u041d",
    "NegativeMediumSpace;": "\u200b",
    "NegativeThickSpace;": "\u200b",
    "NegativeThinSpace;": "\u200b",
    "NegativeVeryThinSpace;": "\u200b",
    "NestedGreaterGreater;": "\u226b",
    "NestedLessLess;": "\u226a",
    "NewLine;": "\n",
    "Nfr;": "\U0001d511",
    "NoBreak;": "\u2060",
    "NonBreakingSpace;": "\xa0",
    "Nopf;": "\u2115",
    "Not;": "\u2aec",
    "NotCongruent;": "\u2262",
    "NotCupCap;": "\u226d",
    "NotDoubleVerticalBar;": "\u2226",
    "NotElement;": "\u2209",
    "NotEqual;": "\u2260",
    "NotEqualTilde;": "\u2242\u0338",
    "NotExists;": "\u2204",
    "NotGreater;": "\u226f",
    "NotGreaterEqual;": "\u2271",
    "NotGreaterFullEqual;": "\u2267\u0338",
    "NotGreaterGreater;": "\u226b\u0338",
    "NotGreaterLess;": "\u2279",
    "NotGreaterSlantEqual;": "\u2a7e\u0338",
    "NotGreaterTilde;": "\u2275",
    "NotHumpDownHump;": "\u224e\u0338",
    "NotHumpEqual;": "\u224f\u0338",
    "NotLeftTriangle;": "\u22ea",
    "NotLeftTriangleBar;": "\u29cf\u0338",
    "NotLeftTriangleEqual;": "\u22ec",
    "NotLess;": "\u226e",
    "NotLessEqual;": "\u2270",
    "NotLessGreater;": "\u2278",
    "NotLessLess;": "\u226a\u0338",
    "NotLessSlantEqual;": "\u2a7d\u0338",
    "NotLessTilde;": "\u2274",
    "NotNestedGreaterGreater;": "\u2aa2\u0338",
    "NotNestedLessLess;": "\u2aa1\u0338",
    "NotPrecedes;": "\u2280",
    "NotPrecedesEqual;": "\u2aaf\u0338",
    "NotPrecedesSlantEqual;": "\u22e0",
    "NotReverseElement;": "\u220c",
    "NotRightTriangle;": "\u22eb",
    "NotRightTriangleBar;": "\u29d0\u0338",
    "NotRightTriangleEqual;": "\u22ed",
    "NotSquareSubset;": "\u228f\u0338",
    "NotSquareSubsetEqual;": "\u22e2",
    "NotSquareSuperset;": "\u2290\u0338",
    "NotSquareSupersetEqual;": "\u22e3",
    "NotSubset;": "\u2282\u20d2",
    "NotSubsetEqual;": "\u2288",
    "NotSucceeds;": "\u2281",
    "NotSucceedsEqual;": "\u2ab0\u0338",
    "NotSucceedsSlantEqual;": "\u22e1",
    "NotSucceedsTilde;": "\u227f\u0338",
    "NotSuperset;": "\u2283\u20d2",
    "NotSupersetEqual;": "\u2289",
    "NotTilde;": "\u2241",
    "NotTildeEqual;": "\u2244",
    "NotTildeFullEqual;": "\u2247",
    "NotTildeTilde;": "\u2249",
    "NotVerticalBar;": "\u2224",
    "Nscr;": "\U0001d4a9",
    "Ntilde": "\xd1",
    "Ntilde;": "\xd1",
    "Nu;": "\u039d",
    "OElig;": "\u0152",
    "Oacute": "\xd3",
    "Oacute;": "\xd3",
    "Ocirc": "\xd4",
    "Ocirc;": "\xd4",
    "Ocy;": "\u041e",
    "Odblac;": "\u0150",
    "Ofr;": "\U0001d512",
    "Ograve": "\xd2",
    "Ograve;": "\xd2",
    "Omacr;": "\u014c",
    "Omega;": "\u03a9",
    "Omicron;": "\u039f",
    "Oopf;": "\U0001d546",
    "OpenCurlyDoubleQuote;": "\u201c",
    "OpenCurlyQuote;": "\u2018",
    "Or;": "\u2a54",
    "Oscr;": "\U0001d4aa",
    "Oslash": "\xd8",
    "Oslash;": "\xd8",
    "Otilde": "\xd5",
    "Otilde;": "\xd5",
    "Otimes;": "\u2a37",
    "Ouml": "\xd6",
    "Ouml;": "\xd6",
    "OverBar;": "\u203e",
    "OverBrace;": "\u23de",
    "OverBracket;": "\u23b4",
    "OverParenthesis;": "\u23dc",
    "PartialD;": "\u2202",
    "Pcy;": "\u041f",
    "Pfr;": "\U0001d513",
    "Phi;": "\u03a6",
    "Pi;": "\u03a0",
    "PlusMinus;": "\xb1",
    "Poincareplane;": "\u210c",
    "Popf;": "\u2119",
    "Pr;": "\u2abb",
    "Precedes;": "\u227a",
    "PrecedesEqual;": "\u2aaf",
    "PrecedesSlantEqual;": "\u227c",
    "PrecedesTilde;": "\u227e",
    "Prime;": "\u2033",
    "Product;": "\u220f",
    "Proportion;": "\u2237",
    "Proportional;": "\u221d",
    "Pscr;": "\U0001d4ab",
    "Psi;": "\u03a8",
    "QUOT": "\"",
    "QUOT;": "\"",
    "Qfr;": "\U0001d514",
    "Qopf;": "\u211a",
    "Qscr;": "\U0001d4ac",
    "RBarr;": "\u2910",
    "REG": "\xae",
    "REG;": "\xae",
    "Racute;": "\u0154",
    "Rang;": "\u27eb",
    "Rarr;": "\u21a0",
    "Rarrtl;": "\u2916",
    "Rcaron;": "\u0158",
    "Rcedil;": "\u0156",
    "Rcy;": "\u0420",
    "Re;": "\u211c",
    "ReverseElement;": "\u220b",
    "ReverseEquilibrium;": "\u21cb",
    "ReverseUpEquilibrium;": "\u296f",
    "Rfr;": "\u211c",
    "Rho;": "\u03a1",
    "RightAngleBracket;": "\u27e9",
    "RightArrow;": "\u2192",
    "RightArrowBar;": "\u21e5",
    "RightArrowLeftArrow;": "\u21c4",
    "RightCeiling;": "\u2309",
    "RightDoubleBracket;": "\u27e7",
    "RightDownTeeVector;": "\u295d",
    "RightDownVector;": "\u21c2",
    "RightDownVectorBar;": "\u2955",
    "RightFloor;": "\u230b",
    "RightTee;": "\u22a2",
    "RightTeeArrow;": "\u21a6",
    "RightTeeVector;": "\u295b",
    "RightTriangle;": "\u22b3",
    "RightTriangleBar;": "\u29d0",
    "RightTriangleEqual;": "\u22b5",
    "RightUpDownVector;": "\u294f",
    "RightUpTeeVector;": "\u295c",
    "RightUpVector;": "\u21be",
    "RightUpVectorBar;": "\u2954",
    "RightVector;": "\u21c0",
    "RightVectorBar;": "\u2953",
    "Rightarrow;": "\u21d2",
    "Ropf;": "\u211d",
    "RoundImplies;": "\u2970",
    "Rrightarrow;": "\u21db",
    "Rscr;": "\u211b",
    "Rsh;": "\u21b1",
    "RuleDelayed;": "\u29f4",
    "SHCHcy;": "\u0429",
    "SHcy;": "\u0428",
    "SOFTcy;": "\u042c",
    "Sacute;": "\u015a",
    "Sc;": "\u2abc",
    "Scaron;": "\u0160",
    "Scedil;": "\u015e",
    "Scirc;": "\u015c",
    "Scy;": "\u0421",
    "Sfr;": "\U0001d516",
    "ShortDownArrow;": "\u2193",
    "ShortLeftArrow;": "\u2190",
    "ShortRightArrow;": "\u2192",
    "ShortUpArrow;": "\u2191",
    "Sigma;": "\u03a3",
    "SmallCircle;": "\u2218",
    "Sopf;": "\U0001d54a",
    "Sqrt;": "\u221a",
    "Square;": "\u25a1",
    "SquareIntersection;": "\u2293",
    "SquareSubset;": "\u228f",
    "SquareSubsetEqual;": "\u2291",
    "SquareSuperset;": "\u2290",
    "SquareSupersetEqual;": "\u2292",
    "SquareUnion;": "\u2294",
    "Sscr;": "\U0001d4ae",
    "Star;": "\u22c6",
    "Sub;": "\u22d0",
    "Subset;": "\u22d0",
    "SubsetEqual;": "\u2286",
    "Succeeds;": "\u227b",
    "SucceedsEqual;": "\u2ab0",
    "SucceedsSlantEqual;": "\u227d",
    "SucceedsTilde;": "\u227f",
    "SuchThat;": "\u220b",
    "Sum;": "\u2211",
    "Sup;": "\u22d1",
    "Superset;": "\u2283",
    "SupersetEqual;": "\u2287",
    "Supset;": "\u22d1",
    "THORN": "\xde",
    "THORN;": "\xde",
    "TRADE;": "\u2122",
    "TSHcy;": "\u040b",
    "TScy;": "\u0426",
    "Tab;": "\t",
    "Tau;": "\u03a4",
    "Tcaron;": "\u0164",
    "Tcedil;": "\u0162",
    "Tcy;": "\u0422",
    "Tfr;": "\U0001d517",
    "Therefore;": "\u2234",
    "Theta;": "\u0398",
    "ThickSpace;": "\u205f\u200a",
    "ThinSpace;": "\u2009",
    "Tilde;": "\u223c",
    "TildeEqual;": "\u2243",
    "TildeFullEqual;": "\u2245",
    "TildeTilde;": "\u2248",
    "Topf;": "\U0001d54b",
    "TripleDot;": "\u20db",
    "Tscr;": "\U0001d4af",
    "Tstrok;": "\u0166",
    "Uacute": "\xda",
    "Uacute;": "\xda",
    "Uarr;": "\u219f",
    "Uarrocir;": "\u2949",
    "Ubrcy;": "\u040e",
    "Ubreve;": "\u016c",
    "Ucirc": "\xdb",
    "Ucirc;": "\xdb",
    "Ucy;": "\u0423",
    "Udblac;": "\u0170",
    "Ufr;": "\U0001d518",
    "Ugrave": "\xd9",
    "Ugrave;": "\xd9",
    "Umacr;": "\u016a",
    "UnderBar;": "_",
    "UnderBrace;": "\u23df",
    "UnderBracket;": "\u23b5",
    "UnderParenthesis;": "\u23dd",
    "Union;": "\u22c3",
    "UnionPlus;": "\u228e",
    "Uogon;": "\u0172",
    "Uopf;": "\U0001d54c",
    "UpArrow;": "\u2191",
    "UpArrowBar;": "\u2912",
    "UpArrowDownArrow;": "\u21c5",
    "UpDownArrow;": "\u2195",
    "UpEquilibrium;": "\u296e",
    "UpTee;": "\u22a5",
    "UpTeeArrow;": "\u21a5",
    "Uparrow;": "\u21d1",
    "Updownarrow;": "\u21d5",
    "UpperLeftArrow;": "\u2196",
    "UpperRightArrow;": "\u2197",
    "Upsi;": "\u03d2",
    "Upsilon;": "\u03a5",
    "Uring;": "\u016e",
    "Uscr;": "\U0001d4b0",
    "Utilde;": "\u0168",
    "Uuml": "\xdc",
    "Uuml;": "\xdc",
    "VDash;": "\u22ab",
    "Vbar;": "\u2aeb",
    "Vcy;": "\u0412",
    "Vdash;": "\u22a9",
    "Vdashl;": "\u2ae6",
    "Vee;": "\u22c1",
    "Verbar;": "\u2016",
    "Vert;": "\u2016",
    "VerticalBar;": "\u2223",
    "VerticalLine;": "|",
    "VerticalSeparator;": "\u2758",
    "VerticalTilde;": "\u2240",
    "VeryThinSpace;": "\u200a",
    "Vfr;": "\U0001d519",
    "Vopf;": "\U0001d54d",
    "Vscr;": "\U0001d4b1",
    "Vvdash;": "\u22aa",
    "Wcirc;": "\u0174",
    "Wedge;": "\u22c0",
    "Wfr;": "\U0001d51a",
    "Wopf;": "\U0001d54e",
    "Wscr;": "\U0001d4b2",
    "Xfr;": "\U0001d51b",
    "Xi;": "\u039e",
    "Xopf;": "\U0001d54f",
    "Xscr;": "\U0001d4b3",
    "YAcy;": "\u042f",
    "YIcy;": "\u0407",
    "YUcy;": "\u042e",
    "Yacute": "\xdd",
    "Yacute;": "\xdd",
    "Ycirc;": "\u0176",
    "Ycy;": "\u042b",
    "Yfr;": "\U0001d51c",
    "Yopf;": "\U0001d550",
    "Yscr;": "\U0001d4b4",
    "Yuml;": "\u0178",
    "ZHcy;": "\u0416",
    "Zacute;": "\u0179",
    "Zcaron;": "\u017d",
    "Zcy;": "\u0417",
    "Zdot;": "\u017b",
    "ZeroWidthSpace;": "\u200b",
    "Zeta;": "\u0396",
    "Zfr;": "\u2128",
    "Zopf;": "\u2124",
    "Zscr;": "\U0001d4b5",
    "aacute": "\xe1",
    "aacute;": "\xe1",
    "abreve;": "\u0103",
    "ac;": "\u223e",
    "acE;": "\u223e\u0333",
    "acd;": "\u223f",
    "acirc": "\xe2",
    "acirc;": "\xe2",
    "acute": "\xb4",
    "acute;": "\xb4",
    "acy;": "\u0430",
    "aelig": "\xe6",
    "aelig;": "\xe6",
    "af;": "\u2061",
    "afr;": "\U0001d51e",
    "agrave": "\xe0",
    "agrave;": "\xe0",
    "alefsym;": "\u2135",
    "aleph;": "\u2135",
    "alpha;": "\u03b1",
    "amacr;": "\u0101",
    "amalg;": "\u2a3f",
    "amp": "&",
    "amp;": "&",
    "and;": "\u2227",
    "andand;": "\u2a55",
    "andd;": "\u2a5c",
    "andslope;": "\u2a58",
    "andv;": "\u2a5a",
    "ang;": "\u2220",
    "ange;": "\u29a4",
    "angle;": "\u2220",
    "angmsd;": "\u2221",
    "angmsdaa;": "\u29a8",
    "angmsdab;": "\u29a9",
    "angmsdac;": "\u29aa",
    "angmsdad;": "\u29ab",
    "angmsdae;": "\u29ac",
    "angmsdaf;": "\u29ad",
    "angmsdag;": "\u29ae",
    "angmsdah;": "\u29af",
    "angrt;": "\u221f",
    "angrtvb;": "\u22be",
    "angrtvbd;": "\u299d",
    "angsph;": "\u2222",
    "angst;": "\xc5",
    "angzarr;": "\u237c",
    "aogon;": "\u0105",
    "aopf;": "\U0001d552",
    "ap;": "\u2248",
    "apE;": "\u2a70",
    "apacir;": "\u2a6f",
    "ape;": "\u224a",
    "apid;": "\u224b",
    "apos;": "'",
    "approx;": "\u2248",
    "approxeq;": "\u224a",
    "aring": "\xe5",
    "aring;": "\xe5",
    "ascr;": "\U0001d4b6",
    "ast;": "*",
    "asymp;": "\u2248",
    "asympeq;": "\u224d",
    "atilde": "\xe3",
    "atilde;": "\xe3",
    "auml": "\xe4",
    "auml;": "\xe4",
    "awconint;": "\u2233",
    "awint;": "\u2a11",
    "bNot;": "\u2aed",
    "backcong;": "\u224c",
    "backepsilon;": "\u03f6",
    "backprime;": "\u2035",
    "backsim;": "\u223d",
    "backsimeq;": "\u22cd",
    "barvee;": "\u22bd",
    "barwed;": "\u2305",
    "barwedge;": "\u2305",
    "bbrk;": "\u23b5",
    "bbrktbrk;": "\u23b6",
    "bcong;": "\u224c",
    "bcy;": "\u0431",
    "bdquo;": "\u201e",
    "becaus;": "\u2235",
    "because;": "\u2235",
    "bemptyv;": "\u29b0",
    "bepsi;": "\u03f6",
    "bernou;": "\u212c",
    "beta;": "\u03b2",
    "beth;": "\u2136",
    "between;": "\u226c",
    "bfr;": "\U0001d51f",
    "bigcap;": "\u22c2",
    "bigcirc;": "\u25ef",
    "bigcup;": "\u22c3",
    "bigodot;": "\u2a00",
    "bigoplus;": "\u2a01",
    "bigotimes;": "\u2a02",
    "bigsqcup;": "\u2a06",
    "bigstar;": "\u2605",
    "bigtriangledown;": "\u25bd",
    "bigtriangleup;": "\u25b3",
    "biguplus;": "\u2a04",
    "bigvee;": "\u22c1",
    "bigwedge;": "\u22c0",
    "bkarow;": "\u290d",
    "blacklozenge;": "\u29eb",
    "blacksquare;": "\u25aa",
    "blacktriangle;": "\u25b4",
    "blacktriangledown;": "\u25be",
    "blacktriangleleft;": "\u25c2",
    "blacktriangleright;": "\u25b8",
    "blank;": "\u2423",
    "blk12;": "\u2592",
    "blk14;": "\u2591",
    "blk34;": "\u2593",
    "block;": "\u2588",
    "bne;": "=\u20e5",
    "bnequiv;": "\u2261\u20e5",
    "bnot;": "\u2310",
    "bopf;": "\U0001d553",
    "bot;": "\u22a5",
    "bottom;": "\u22a5",
    "bowtie;": "\u22c8",
    "boxDL;": "\u2557",
    "boxDR;": "\u2554",
    "boxDl;": "\u2556",
    "boxDr;": "\u2553",
    "boxH;": "\u2550",
    "boxHD;": "\u2566",
    "boxHU;": "\u2569",
    "boxHd;": "\u2564",
    "boxHu;": "\u2567",
    "boxUL;": "\u255d",
    "boxUR;": "\u255a",
    "boxUl;": "\u255c",
    "boxUr;": "\u2559",
    "boxV;": "\u2551",
    "boxVH;": "\u256c",
    "boxVL;": "\u2563",
    "boxVR;": "\u2560",
    "boxVh;": "\u256b",
    "boxVl;": "\u2562",
    "boxVr;": "\u255f",
    "boxbox;": "\u29c9",
    "boxdL;": "\u2555",
    "boxdR;": "\u2552",
    "boxdl;": "\u2510",
    "boxdr;": "\u250c",
    "boxh;": "\u2500",
    "boxhD;": "\u2565",
    "boxhU;": "\u2568",
    "boxhd;": "\u252c",
    "boxhu;": "\u2534",
    "boxminus;": "\u229f",
    "boxplus;": "\u229e",
    "boxtimes;": "\u22a0",
    "boxuL;": "\u255b",
    "boxuR;": "\u2558",
    "boxul;": "\u2518",
    "boxur;": "\u2514",
    "boxv;": "\u2502",
    "boxvH;": "\u256a",
    "boxvL;": "\u2561",
    "boxvR;": "\u255e",
    "boxvh;": "\u253c",
    "boxvl;": "\u2524",
    "boxvr;": "\u251c",
    "bprime;": "\u2035",
    "breve;": "\u02d8",
    "brvbar": "\xa6",
    "brvbar;": "\xa6",
    "bscr;": "\U0001d4b7",
    "bsemi;": "\u204f",
    "bsim;": "\u223d",
    "bsime;": "\u22cd",
    "bsol;": "\\",
    "bsolb;": "\u29c5",
    "bsolhsub;": "\u27c8",
    "bull;": "\u2022",
    "bullet;": "\u2022",
    "bump;": "\u224e",
    "bumpE;": "\u2aae",
    "bumpe;": "\u224f",
    "bumpeq;": "\u224f",
    "cacute;": "\u0107",
    "cap;": "\u2229",
    "capand;": "\u2a44",
    "capbrcup;": "\u2a49",
    "capcap;": "\u2a4b",
    "capcup;": "\u2a47",
    "capdot;": "\u2a40",
    "caps;": "\u2229\ufe00",
    "caret;": "\u2041",
    "caron;": "\u02c7",
    "ccaps;": "\u2a4d",
    "ccaron;": "\u010d",
    "ccedil": "\xe7",
    "ccedil;": "\xe7",
    "ccirc;": "\u0109",
    "ccups;": "\u2a4c",
    "ccupssm;": "\u2a50",
    "cdot;": "\u010b",
    "cedil": "\xb8",
    "cedil;": "\xb8",
    "cemptyv;": "\u29b2",
    "cent": "\xa2",
    "cent;": "\xa2",
    "centerdot;": "\xb7",
    "cfr;": "\U0001d520",
    "chcy;": "\u0447",
    "check;": "\u2713",
    "checkmark;": "\u2713",
    "chi;": "\u03c7",
    "cir;": "\u25cb",
    "cirE;": "\u29c3",
    "circ;": "\u02c6",
    "circeq;": "\u2257",
    "circlearrowleft;": "\u21ba",
    "circlearrowright;": "\u21bb",
    "circledR;": "\xae",
    "circledS;": "\u24c8",
    "circledast;": "\u229b",
    "circledcirc;": "\u229a",
    "circleddash;": "\u229d",
    "cire;": "\u2257",
    "cirfnint;": "\u2a10",
    "cirmid;": "\u2aef",
    "cirscir;": "\u29c2",
    "clubs;": "\u2663",
    "clubsuit;": "\u2663",
    "colon;": ":",
    "colone;": "\u2254",
    "coloneq;": "\u2254",
    "comma;": ",",
    "commat;": "@",
    "comp;": "\u2201",
    "compfn;": "\u2218",
    "complement;": "\u2201",
    "complexes;": "\u2102",
    "cong;": "\u2245",
    "congdot;": "\u2a6d",
    "conint;": "\u222e",
    "copf;": "\U0001d554",
    "coprod;": "\u2210",
    "copy": "\xa9",
    "copy;": "\xa9",
    "copysr;": "\u2117",
    "crarr;": "\u21b5",
    "cross;": "\u2717",
    "cscr;": "\U0001d4b8",
    "csub;": "\u2acf",
    "csube;": "\u2ad1",
    "csup;": "\u2ad0",
    "csupe;": "\u2ad2",
    "ctdot;": "\u22ef",
    "cudarrl;": "\u2938",
    "cudarrr;": "\u2935",
    "cuepr;": "\u22de",
    "cuesc;": "\u22df",
    "cularr;": "\u21b6",
    "cularrp;": "\u293d",
    "cup;": "\u222a",
    "cupbrcap;": "\u2a48",
    "cupcap;": "\u2a46",
    "cupcup;": "\u2a4a",
    "cupdot;": "\u228d",
    "cupor;": "\u2a45",
    "cups;": "\u222a\ufe00",
    "curarr;": "\u21b7",
    "curarrm;": "\u293c",
    "curlyeqprec;": "\u22de",
    "curlyeqsucc;": "\u22df",
    "curlyvee;": "\u22ce",
    "curlywedge;": "\u22cf",
    "curren": "\xa4",
    "curren;": "\xa4",
    "curvearrowleft;": "\u21b6",
    "curvearrowright;": "\u21b7",
    "cuvee;": "\u22ce",
    "cuwed;": "\u22cf",
    "cwconint;": "\u2232",
    "cwint;": "\u2231",
    "cylcty;": "\u232d",
    "dArr;": "\u21d3",
    "dHar;": "\u2965",
    "dagger;": "\u2020",
    "daleth;": "\u2138",
    "darr;": "\u2193",
    "dash;": "\u2010",
    "dashv;": "\u22a3",
    "dbkarow;": "\u290f",
    "dblac;": "\u02dd",
    "dcaron;": "\u010f",
    "dcy;": "\u0434",
    "dd;": "\u2146",
    "ddagger;": "\u2021",
    "ddarr;": "\u21ca",
    "ddotseq;": "\u2a77",
    "deg": "\xb0",
    "deg;": "\xb0",
    "delta;": "\u03b4",
    "demptyv;": "\u29b1",
    "dfisht;": "\u297f",
    "dfr;": "\U0001d521",
    "dharl;": "\u21c3",
    "dharr;": "\u21c2",
    "diam;": "\u22c4",
    "diamond;": "\u22c4",
    "diamondsuit;": "\u2666",
    "diams;": "\u2666",
    "die;": "\xa8",
    "digamma;": "\u03dd",
    "disin;": "\u22f2",
    "div;": "\xf7",
    "divide": "\xf7",
    "divide;": "\xf7",
    "divideontimes;": "\u22c7",
    "divonx;": "\u22c7",
    "djcy;": "\u0452",
    "dlcorn;": "\u231e",
    "dlcrop;": "\u230d",
    "dollar;": "$",
    "dopf;": "\U0001d555",
    "dot;": "\u02d9",
    "doteq;": "\u2250",
    "doteqdot;": "\u2251",
    "dotminus;": "\u2238",
    "dotplus;": "\u2214",
    "dotsquare;": "\u22a1",
    "doublebarwedge;": "\u2306",
    "downarrow;": "\u2193",
    "downdownarrows;": "\u21ca",
    "downharpoonleft;": "\u21c3",
    "downharpoonright;": "\u21c2",
    "drbkarow;": "\u2910",
    "drcorn;": "\u231f",
    "drcrop;": "\u230c",
    "dscr;": "\U0001d4b9",
    "dscy;": "\u0455",
    "dsol;": "\u29f6",
    "dstrok;": "\u0111",
    "dtdot;": "\u22f1",
    "dtri;": "\u25bf",
    "dtrif;": "\u25be",
    "duarr;": "\u21f5",
    "duhar;": "\u296f",
    "dwangle;": "\u29a6",
    "dzcy;": "\u045f",
    "dzigrarr;": "\u27ff",
    "eDDot;": "\u2a77",
    "eDot;": "\u2251",
    "eacute": "\xe9",
    "eacute;": "\xe9",
    "easter;": "\u2a6e",
    "ecaron;": "\u011b",
    "ecir;": "\u2256",
    "ecirc": "\xea",
    "ecirc;": "\xea",
    "ecolon;": "\u2255",
    "ecy;": "\u044d",
    "edot;": "\u0117",
    "ee;": "\u2147",
    "efDot;": "\u2252",
    "efr;": "\U0001d522",
    "eg;": "\u2a9a",
    "egrave": "\xe8",
    "egrave;": "\xe8",
    "egs;": "\u2a96",
    "egsdot;": "\u2a98",
    "el;": "\u2a99",
    "elinters;": "\u23e7",
    "ell;": "\u2113",
    "els;": "\u2a95",
    "elsdot;": "\u2a97",
    "emacr;": "\u0113",
    "empty;": "\u2205",
    "emptyset;": "\u2205",
    "emptyv;": "\u2205",
    "emsp13;": "\u2004",
    "emsp14;": "\u2005",
    "emsp;": "\u2003",
    "eng;": "\u014b",
    "ensp;": "\u2002",
    "eogon;": "\u0119",
    "eopf;": "\U0001d556",
    "epar;": "\u22d5",
    "eparsl;": "\u29e3",
    "eplus;": "\u2a71",
    "epsi;": "\u03b5",
    "epsilon;": "\u03b5",
    "epsiv;": "\u03f5",
    "eqcirc;": "\u2256",
    "eqcolon;": "\u2255",
    "eqsim;": "\u2242",
    "eqslantgtr;": "\u2a96",
    "eqslantless;": "\u2a95",
    "equals;": "=",
    "equest;": "\u225f",
    "equiv;": "\u2261",
    "equivDD;": "\u2a78",
    "eqvparsl;": "\u29e5",
    "erDot;": "\u2253",
    "erarr;": "\u2971",
    "escr;": "\u212f",
    "esdot;": "\u2250",
    "esim;": "\u2242",
    "eta;": "\u03b7",
    "eth": "\xf0",
    "eth;": "\xf0",
    "euml": "\xeb",
    "euml;": "\xeb",
    "euro;": "\u20ac",
    "excl;": "!",
    "exist;": "\u2203",
    "expectation;": "\u2130",
    "exponentiale;": "\u2147",
    "fallingdotseq;": "\u2252",
    "fcy;": "\u0444",
    "female;": "\u2640",
    "ffilig;": "\ufb03",
    "fflig;": "\ufb00",
    "ffllig;": "\ufb04",
    "ffr;": "\U0001d523",
    "filig;": "\ufb01",
    "fjlig;": "fj",
    "flat;": "\u266d",
    "fllig;": "\ufb02",
    "fltns;": "\u25b1",
    "fnof;": "\u0192",
    "fopf;": "\U0001d557",
    "forall;": "\u2200",
    "fork;": "\u22d4",
    "forkv;": "\u2ad9",
    "fpartint;": "\u2a0d",
    "frac12": "\xbd",
    "frac12;": "\xbd",
    "frac13;": "\u2153",
    "frac14": "\xbc",
    "frac14;": "\xbc",
    "frac15;": "\u2155",
    "frac16;": "\u2159",
    "frac18;": "\u215b",
    "frac23;": "\u2154",
    "frac25;": "\u2156",
    "frac34": "\xbe",
    "frac34;": "\xbe",
    "frac35;": "\u2157",
    "frac38;": "\u215c",
    "frac45;": "\u2158",
    "frac56;": "\u215a",
    "frac58;": "\u215d",
    "frac78;": "\u215e",
    "frasl;": "\u2044",
    "frown;": "\u2322",
    "fscr;": "\U0001d4bb",
    "gE;": "\u2267",
    "gEl;": "\u2a8c",
    "gacute;": "\u01f5",
    "gamma;": "\u03b3",
    "gammad;": "\u03dd",
    "gap;": "\u2a86",
    "gbreve;": "\u011f",
    "gcirc;": "\u011d",
    "gcy;": "\u0433",
    "gdot;": "\u0121",
    "ge;": "\u2265",
    "gel;": "\u22db",
    "geq;": "\u2265",
    "geqq;": "\u2267",
    "geqslant;": "\u2a7e",
    "ges;": "\u2a7e",
    "gescc;": "\u2aa9",
    "gesdot;": "\u2a80",
    "gesdoto;": "\u2a82",
    "gesdotol;": "\u2a84",
    "gesl;": "\u22db\ufe00",
    "gesles;": "\u2a94",
    "gfr;": "\U0001d524",
    "gg;": "\u226b",
    "ggg;": "\u22d9",
    "gimel;": "\u2137",
    "gjcy;": "\u0453",
    "gl;": "\u2277",
    "glE;": "\u2a92",
    "gla;": "\u2aa5",
    "glj;": "\u2aa4",
    "gnE;": "\u2269",
    "gnap;": "\u2a8a",
    "gnapprox;": "\u2a8a",
    "gne;": "\u2a88",
    "gneq;": "\u2a88",
    "gneqq;": "\u2269",
    "gnsim;": "\u22e7",
    "gopf;": "\U0001d558",
    "grave;": "`",
    "gscr;": "\u210a",
    "gsim;": "\u2273",
    "gsime;": "\u2a8e",
    "gsiml;": "\u2a90",
    "gt": ">",
    "gt;": ">",
    "gtcc;": "\u2aa7",
    "gtcir;": "\u2a7a",
    "gtdot;": "\u22d7",
    "gtlPar;": "\u2995",
    "gtquest;": "\u2a7c",
    "gtrapprox;": "\u2a86",
    "gtrarr;": "\u2978",
    "gtrdot;": "\u22d7",
    "gtreqless;": "\u22db",
    "gtreqqless;": "\u2a8c",
    "gtrless;": "\u2277",
    "gtrsim;": "\u2273",
    "gvertneqq;": "\u2269\ufe00",
    "gvnE;": "\u2269\ufe00",
    "hArr;": "\u21d4",
    "hairsp;": "\u200a",
    "half;": "\xbd",
    "hamilt;": "\u210b",
    "hardcy;": "\u044a",
    "harr;": "\u2194",
    "harrcir;": "\u2948",
    "harrw;": "\u21ad",
    "hbar;": "\u210f",
    "hcirc;": "\u0125",
    "hearts;": "\u2665",
    "heartsuit;": "\u2665",
    "hellip;": "\u2026",
    "hercon;": "\u22b9",
    "hfr;": "\U0001d525",
    "hksearow;": "\u2925",
    "hkswarow;": "\u2926",
    "hoarr;": "\u21ff",
    "homtht;": "\u223b",
    "hookleftarrow;": "\u21a9",
    "hookrightarrow;": "\u21aa",
    "hopf;": "\U0001d559",
    "horbar;": "\u2015",
    "hscr;": "\U0001d4bd",
    "hslash;": "\u210f",
    "hstrok;": "\u0127",
    "hybull;": "\u2043",
    "hyphen;": "\u2010",
    "iacute": "\xed",
    "iacute;": "\xed",
    "ic;": "\u2063",
    "icirc": "\xee",
    "icirc;": "\xee",
    "icy;": "\u0438",
    "iecy;": "\u0435",
    "iexcl": "\xa1",
    "iexcl;": "\xa1",
    "iff;": "\u21d4",
    "ifr;": "\U0001d526",
    "igrave": "\xec",
    "igrave;": "\xec",
    "ii;": "\u2148",
    "iiiint;": "\u2a0c",
    "iiint;": "\u222d",
    "iinfin;": "\u29dc",
    "iiota;": "\u2129",
    "ijlig;": "\u0133",
    "imacr;": "\u012b",
    "image;": "\u2111",
    "imagline;": "\u2110",
    "imagpart;": "\u2111",
    "imath;": "\u0131",
    "imof;": "\u22b7",
    "imped;": "\u01b5",
    "in;": "\u2208",
    "incare;": "\u2105",
    "infin;": "\u221e",
    "infintie;": "\u29dd",
    "inodot;": "\u0131",
    "int;": "\u222b",
    "intcal;": "\u22ba",
    "integers;": "\u2124",
    "intercal;": "\u22ba",
    "intlarhk;": "\u2a17",
    "intprod;": "\u2a3c",
    "iocy;": "\u0451",
    "iogon;": "\u012f",
    "iopf;": "\U0001d55a",
    "iota;": "\u03b9",
    "iprod;": "\u2a3c",
    "iquest": "\xbf",
    "iquest;": "\xbf",
    "iscr;": "\U0001d4be",
    "isin;": "\u2208",
    "isinE;": "\u22f9",
    "isindot;": "\u22f5",
    "isins;": "\u22f4",
    "isinsv;": "\u22f3",
    "isinv;": "\u2208",
    "it;": "\u2062",
    "itilde;": "\u0129",
    "iukcy;": "\u0456",
    "iuml": "\xef",
    "iuml;": "\xef",
    "jcirc;": "\u0135",
    "jcy;": "\u0439",
    "jfr;": "\U0001d527",
    "jmath;": "\u0237",
    "jopf;": "\U0001d55b",
    "jscr;": "\U0001d4bf",
    "jsercy;": "\u0458",
    "jukcy;": "\u0454",
    "kappa;": "\u03ba",
    "kappav;": "\u03f0",
    "kcedil;": "\u0137",
    "kcy;": "\u043a",
    "kfr;": "\U0001d528",
    "kgreen;": "\u0138",
    "khcy;": "\u0445",
    "kjcy;": "\u045c",
    "kopf;": "\U0001d55c",
    "kscr;": "\U0001d4c0",
    "lAarr;": "\u21da",
    "lArr;": "\u21d0",
    "lAtail;": "\u291b",
    "lBarr;": "\u290e",
    "lE;": "\u2266",
    "lEg;": "\u2a8b",
    "lHar;": "\u2962",
    "lacute;": "\u013a",
    "laemptyv;": "\u29b4",
    "lagran;": "\u2112",
    "lambda;": "\u03bb",
    "lang;": "\u27e8",
    "langd;": "\u2991",
    "langle;": "\u27e8",
    "lap;": "\u2a85",
    "laquo": "\xab",
    "laquo;": "\xab",
    "larr;": "\u2190",
    "larrb;": "\u21e4",
    "larrbfs;": "\u291f",
    "larrfs;": "\u291d",
    "larrhk;": "\u21a9",
    "larrlp;": "\u21ab",
    "larrpl;": "\u2939",
    "larrsim;": "\u2973",
    "larrtl;": "\u21a2",
    "lat;": "\u2aab",
    "latail;": "\u2919",
    "late;": "\u2aad",
    "lates;": "\u2aad\ufe00",
    "lbarr;": "\u290c",
    "lbbrk;": "\u2772",
    "lbrace;": "{",
    "lbrack;": "[",
    "lbrke;": "\u298b",
    "lbrksld;": "\u298f",
    "lbrkslu;": "\u298d",
    "lcaron;": "\u013e",
    "lcedil;": "\u013c",
    "lceil;": "\u2308",
    "lcub;": "{",
    "lcy;": "\u043b",
    "ldca;": "\u2936",
    "ldquo;": "\u201c",
    "ldquor;": "\u201e",
    "ldrdhar;": "\u2967",
    "ldrushar;": "\u294b",
    "ldsh;": "\u21b2",
    "le;": "\u2264",
    "leftarrow;": "\u2190",
    "leftarrowtail;": "\u21a2",
    "leftharpoondown;": "\u21bd",
    "leftharpoonup;": "\u21bc",
    "leftleftarrows;": "\u21c7",
    "leftrightarrow;": "\u2194",
    "leftrightarrows;": "\u21c6",
    "leftrightharpoons;": "\u21cb",
    "leftrightsquigarrow;": "\u21ad",
    "leftthreetimes;": "\u22cb",
    "leg;": "\u22da",
    "leq;": "\u2264",
    "leqq;": "\u2266",
    "leqslant;": "\u2a7d",
    "les;": "\u2a7d",
    "lescc;": "\u2aa8",
    "lesdot;": "\u2a7f",
    "lesdoto;": "\u2a81",
    "lesdotor;": "\u2a83",
    "lesg;": "\u22da\ufe00",
    "lesges;": "\u2a93",
    "lessapprox;": "\u2a85",
    "lessdot;": "\u22d6",
    "lesseqgtr;": "\u22da",
    "lesseqqgtr;": "\u2a8b",
    "lessgtr;": "\u2276",
    "lesssim;": "\u2272",
    "lfisht;": "\u297c",
    "lfloor;": "\u230a",
    "lfr;": "\U0001d529",
    "lg;": "\u2276",
    "lgE;": "\u2a91",
    "lhard;": "\u21bd",
    "lharu;": "\u21bc",
    "lharul;": "\u296a",
    "lhblk;": "\u2584",
    "ljcy;": "\u0459",
    "ll;": "\u226a",
    "llarr;": "\u21c7",
    "llcorner;": "\u231e",
    "llhard;": "\u296b",
    "lltri;": "\u25fa",
    "lmidot;": "\u0140",
    "lmoust;": "\u23b0",
    "lmoustache;": "\u23b0",
    "lnE;": "\u2268",
    "lnap;": "\u2a89",
    "lnapprox;": "\u2a89",
    "lne;": "\u2a87",
    "lneq;": "\u2a87",
    "lneqq;": "\u2268",
    "lnsim;": "\u22e6",
    "loang;": "\u27ec",
    "loarr;": "\u21fd",
    "lobrk;": "\u27e6",
    "longleftarrow;": "\u27f5",
    "longleftrightarrow;": "\u27f7",
    "longmapsto;": "\u27fc",
    "longrightarrow;": "\u27f6",
    "looparrowleft;": "\u21ab",
    "looparrowright;": "\u21ac",
    "lopar;": "\u2985",
    "lopf;": "\U0001d55d",
    "loplus;": "\u2a2d",
    "lotimes;": "\u2a34",
    "lowast;": "\u2217",
    "lowbar;": "_",
    "loz;": "\u25ca",
    "lozenge;": "\u25ca",
    "lozf;": "\u29eb",
    "lpar;": "(",
    "lparlt;": "\u2993",
    "lrarr;": "\u21c6",
    "lrcorner;": "\u231f",
    "lrhar;": "\u21cb",
    "lrhard;": "\u296d",
    "lrm;": "\u200e",
    "lrtri;": "\u22bf",
    "lsaquo;": "\u2039",
    "lscr;": "\U0001d4c1",
    "lsh;": "\u21b0",
    "lsim;": "\u2272",
    "lsime;": "\u2a8d",
    "lsimg;": "\u2a8f",
    "lsqb;": "[",
    "lsquo;": "\u2018",
    "lsquor;": "\u201a",
    "lstrok;": "\u0142",
    "lt": "<",
    "lt;": "<",
    "ltcc;": "\u2aa6",
    "ltcir;": "\u2a79",
    "ltdot;": "\u22d6",
    "lthree;": "\u22cb",
    "ltimes;": "\u22c9",
    "ltlarr;": "\u2976",
    "ltquest;": "\u2a7b",
    "ltrPar;": "\u2996",
    "ltri;": "\u25c3",
    "ltrie;": "\u22b4",
    "ltrif;": "\u25c2",
    "lurdshar;": "\u294a",
    "luruhar;": "\u2966",
    "lvertneqq;": "\u2268\ufe00",
    "lvnE;": "\u2268\ufe00",
    "mDDot;": "\u223a",
    "macr": "\xaf",
    "macr;": "\xaf",
    "male;": "\u2642",
    "malt;": "\u2720",
    "maltese;": "\u2720",
    "map;": "\u21a6",
    "mapsto;": "\u21a6",
    "mapstodown;": "\u21a7",
    "mapstoleft;": "\u21a4",
    "mapstoup;": "\u21a5",
    "marker;": "\u25ae",
    "mcomma;": "\u2a29",
    "mcy;": "\u043c",
    "mdash;": "\u2014",
    "measuredangle;": "\u2221",
    "mfr;": "\U0001d52a",
    "mho;": "\u2127",
    "micro": "\xb5",
    "micro;": "\xb5",
    "mid;": "\u2223",
    "midast;": "*",
    "midcir;": "\u2af0",
    "middot": "\xb7",
    "middot;": "\xb7",
    "minus;": "\u2212",
    "minusb;": "\u229f",
    "minusd;": "\u2238",
    "minusdu;": "\u2a2a",
    "mlcp;": "\u2adb",
    "mldr;": "\u2026",
    "mnplus;": "\u2213",
    "models;": "\u22a7",
    "mopf;": "\U0001d55e",
    "mp;": "\u2213",
    "mscr;": "\U0001d4c2",
    "mstpos;": "\u223e",
    "mu;": "\u03bc",
    "multimap;": "\u22b8",
    "mumap;": "\u22b8",
    "nGg;": "\u22d9\u0338",
    "nGt;": "\u226b\u20d2",
    "nGtv;": "\u226b\u0338",
    "nLeftarrow;": "\u21cd",
    "nLeftrightarrow;": "\u21ce",
    "nLl;": "\u22d8\u0338",
    "nLt;": "\u226a\u20d2",
    "nLtv;": "\u226a\u0338",
    "nRightarrow;": "\u21cf",
    "nVDash;": "\u22af",
    "nVdash;": "\u22ae",
    "nabla;": "\u2207",
    "nacute;": "\u0144",
    "nang;": "\u2220\u20d2",
    "nap;": "\u2249",
    "napE;": "\u2a70\u0338",
    "napid;": "\u224b\u0338",
    "napos;": "\u0149",
    "napprox;": "\u2249",
    "natur;": "\u266e",
    "natural;": "\u266e",
    "naturals;": "\u2115",
    "nbsp": "\xa0",
    "nbsp;": "\xa0",
    "nbump;": "\u224e\u0338",
    "nbumpe;": "\u224f\u0338",
    "ncap;": "\u2a43",
    "ncaron;": "\u0148",
    "ncedil;": "\u0146",
    "ncong;": "\u2247",
    "ncongdot;": "\u2a6d\u0338",
    "ncup;": "\u2a42",
    "ncy;": "\u043d",
    "ndash;": "\u2013",
    "ne;": "\u2260",
    "neArr;": "\u21d7",
    "nearhk;": "\u2924",
    "nearr;": "\u2197",
    "nearrow;": "\u2197",
    "nedot;": "\u2250\u0338",
    "nequiv;": "\u2262",
    "nesear;": "\u2928",
    "nesim;": "\u2242\u0338",
    "nexist;": "\u2204",
    "nexists;": "\u2204",
    "nfr;": "\U0001d52b",
    "ngE;": "\u2267\u0338",
    "nge;": "\u2271",
    "ngeq;": "\u2271",
    "ngeqq;": "\u2267\u0338",
    "ngeqslant;": "\u2a7e\u0338",
    "nges;": "\u2a7e\u0338",
    "ngsim;": "\u2275",
    "ngt;": "\u226f",
    "ngtr;": "\u226f",
    "nhArr;": "\u21ce",
    "nharr;": "\u21ae",
    "nhpar;": "\u2af2",
    "ni;": "\u220b",
    "nis;": "\u22fc",
    "nisd;": "\u22fa",
    "niv;": "\u220b",
    "njcy;": "\u045a",
    "nlArr;": "\u21cd",
    "nlE;": "\u2266\u0338",
    "nlarr;": "\u219a",
    "nldr;": "\u2025",
    "nle;": "\u2270",
    "nleftarrow;": "\u219a",
    "nleftrightarrow;": "\u21ae",
    "nleq;": "\u2270",
    "nleqq;": "\u2266\u0338",
    "nleqslant;": "\u2a7d\u0338",
    "nles;": "\u2a7d\u0338",
    "nless;": "\u226e",
    "nlsim;": "\u2274",
    "nlt;": "\u226e",
    "nltri;": "\u22ea",
    "nltrie;": "\u22ec",
    "nmid;": "\u2224",
    "nopf;": "\U0001d55f",
    "not": "\xac",
    "not;": "\xac",
    "notin;": "\u2209",
    "notinE;": "\u22f9\u0338",
    "notindot;": "\u22f5\u0338",
    "notinva;": "\u2209",
    "notinvb;": "\u22f7",
    "notinvc;": "\u22f6",
    "notni;": "\u220c",
    "notniva;": "\u220c",
    "notnivb;": "\u22fe",
    "notnivc;": "\u22fd",
    "npar;": "\u2226",
    "nparallel;": "\u2226",
    "nparsl;": "\u2afd\u20e5",
    "npart;": "\u2202\u0338",
    "npolint;": "\u2a14",
    "npr;": "\u2280",
    "nprcue;": "\u22e0",
    "npre;": "\u2aaf\u0338",
    "nprec;": "\u2280",
    "npreceq;": "\u2aaf\u0338",
    "nrArr;": "\u21cf",
    "nrarr;": "\u219b",
    "nrarrc;": "\u2933\u0338",
    "nrarrw;": "\u219d\u0338",
    "nrightarrow;": "\u219b",
    "nrtri;": "\u22eb",
    "nrtrie;": "\u22ed",
    "nsc;": "\u2281",
    "nsccue;": "\u22e1",
    "nsce;": "\u2ab0\u0338",
    "nscr;": "\U0001d4c3",
    "nshortmid;": "\u2224",
    "nshortparallel;": "\u2226",
    "nsim;": "\u2241",
    "nsime;": "\u2244",
    "nsimeq;": "\u2244",
    "nsmid;": "\u2224",
    "nspar;": "\u2226",
    "nsqsube;": "\u22e2",
    "nsqsupe;": "\u22e3",
    "nsub;": "\u2284",
    "nsubE;": "\u2ac5\u0338",
    "nsube;": "\u2288",
    "nsubset;": "\u2282\u20d2",
    "nsubseteq;": "\u2288",
    "nsubseteqq;": "\u2ac5\u0338",
    "nsucc;": "\u2281",
    "nsucceq;": "\u2ab0\u0338",
    "nsup;": "\u2285",
    "nsupE;": "\u2ac6\u0338",
    "nsupe;": "\u2289",
    "nsupset;": "\u2283\u20d2",
    "nsupseteq;": "\u2289",
    "nsupseteqq;": "\u2ac6\u0338",
    "ntgl;": "\u2279",
    "ntilde": "\xf1",
    "ntilde;": "\xf1",
    "ntlg;": "\u2278",
    "ntriangleleft;": "\u22ea",
    "ntrianglelefteq;": "\u22ec",
    "ntriangleright;": "\u22eb",
    "ntrianglerighteq;": "\u22ed",
    "nu;": "\u03bd",
    "num;": "#",
    "numero;": "\u2116",
    "numsp;": "\u2007",
    "nvDash;": "\u22ad",
    "nvHarr;": "\u2904",
    "nvap;": "\u224d\u20d2",
    "nvdash;": "\u22ac",
    "nvge;": "\u2265\u20d2",
    "nvgt;": ">\u20d2",
    "nvinfin;": "\u29de",
    "nvlArr;": "\u2902",
    "nvle;": "\u2264\u20d2",
    "nvlt;": "<\u20d2",
    "nvltrie;": "\u22b4\u20d2",
    "nvrArr;": "\u2903",
    "nvrtrie;": "\u22b5\u20d2",
    "nvsim;": "\u223c\u20d2",
    "nwArr;": "\u21d6",
    "nwarhk;": "\u2923",
    "nwarr;": "\u2196",
    "nwarrow;": "\u2196",
    "nwnear;": "\u2927",
    "oS;": "\u24c8",
    "oacute": "\xf3",
    "oacute;": "\xf3",
    "oast;": "\u229b",
    "ocir;": "\u229a",
    "ocirc": "\xf4",
    "ocirc;": "\xf4",
    "ocy;": "\u043e",
    "odash;": "\u229d",
    "odblac;": "\u0151",
    "odiv;": "\u2a38",
    "odot;": "\u2299",
    "odsold;": "\u29bc",
    "oelig;": "\u0153",
    "ofcir;": "\u29bf",
    "ofr;": "\U0001d52c",
    "ogon;": "\u02db",
    "ograve": "\xf2",
    "ograve;": "\xf2",
    "ogt;": "\u29c1",
    "ohbar;": "\u29b5",
    "ohm;": "\u03a9",
    "oint;": "\u222e",
    "olarr;": "\u21ba",
    "olcir;": "\u29be",
    "olcross;": "\u29bb",
    "oline;": "\u203e",
    "olt;": "\u29c0",
    "omacr;": "\u014d",
    "omega;": "\u03c9",
    "omicron;": "\u03bf",
    "omid;": "\u29b6",
    "ominus;": "\u2296",
    "oopf;": "\U0001d560",
    "opar;": "\u29b7",
    "operp;": "\u29b9",
    "oplus;": "\u2295",
    "or;": "\u2228",
    "orarr;": "\u21bb",
    "ord;": "\u2a5d",
    "order;": "\u2134",
    "orderof;": "\u2134",
    "ordf": "\xaa",
    "ordf;": "\xaa",
    "ordm": "\xba",
    "ordm;": "\xba",
    "origof;": "\u22b6",
    "oror;": "\u2a56",
    "orslope;": "\u2a57",
    "orv;": "\u2a5b",
    "oscr;": "\u2134",
    "oslash": "\xf8",
    "oslash;": "\xf8",
    "osol;": "\u2298",
    "otilde": "\xf5",
    "otilde;": "\xf5",
    "otimes;": "\u2297",
    "otimesas;": "\u2a36",
    "ouml": "\xf6",
    "ouml;": "\xf6",
    "ovbar;": "\u233d",
    "par;": "\u2225",
    "para": "\xb6",
    "para;": "\xb6",
    "parallel;": "\u2225",
    "parsim;": "\u2af3",
    "parsl;": "\u2afd",
    "part;": "\u2202",
    "pcy;": "\u043f",
    "percnt;": "%",
    "period;": ".",
    "permil;": "\u2030",
    "perp;": "\u22a5",
    "pertenk;": "\u2031",
    "pfr;": "\U0001d52d",
    "phi;": "\u03c6",
    "phiv;": "\u03d5",
    "phmmat;": "\u2133",
    "phone;": "\u260e",
    "pi;": "\u03c0",
    "pitchfork;": "\u22d4",
    "piv;": "\u03d6",
    "planck;": "\u210f",
    "planckh;": "\u210e",
    "plankv;": "\u210f",
    "plus;": "+",
    "plusacir;": "\u2a23",
    "plusb;": "\u229e",
    "pluscir;": "\u2a22",
    "plusdo;": "\u2214",
    "plusdu;": "\u2a25",
    "pluse;": "\u2a72",
    "plusmn": "\xb1",
    "plusmn;": "\xb1",
    "plussim;": "\u2a26",
    "plustwo;": "\u2a27",
    "pm;": "\xb1",
    "pointint;": "\u2a15",
    "popf;": "\U0001d561",
    "pound": "\xa3",
    "pound;": "\xa3",
    "pr;": "\u227a",
    "prE;": "\u2ab3",
    "prap;": "\u2ab7",
    "prcue;": "\u227c",
    "pre;": "\u2aaf",
    "prec;": "\u227a",
    "precapprox;": "\u2ab7",
    "preccurlyeq;": "\u227c",
    "preceq;": "\u2aaf",
    "precnapprox;": "\u2ab9",
    "precneqq;": "\u2ab5",
    "precnsim;": "\u22e8",
    "precsim;": "\u227e",
    "prime;": "\u2032",
    "primes;": "\u2119",
    "prnE;": "\u2ab5",
    "prnap;": "\u2ab9",
    "prnsim;": "\u22e8",
    "prod;": "\u220f",
    "profalar;": "\u232e",
    "profline;": "\u2312",
    "profsurf;": "\u2313",
    "prop;": "\u221d",
    "propto;": "\u221d",
    "prsim;": "\u227e",
    "prurel;": "\u22b0",
    "pscr;": "\U0001d4c5",
    "psi;": "\u03c8",
    "puncsp;": "\u2008",
    "qfr;": "\U0001d52e",
    "qint;": "\u2a0c",
    "qopf;": "\U0001d562",
    "qprime;": "\u2057",
    "qscr;": "\U0001d4c6",
    "quaternions;": "\u210d",
    "quatint;": "\u2a16",
    "quest;": "?",
    "questeq;": "\u225f",
    "quot": "\"",
    "quot;": "\"",
    "rAarr;": "\u21db",
    "rArr;": "\u21d2",
    "rAtail;": "\u291c",
    "rBarr;": "\u290f",
    "rHar;": "\u2964",
    "race;": "\u223d\u0331",
    "racute;": "\u0155",
    "radic;": "\u221a",
    "raemptyv;": "\u29b3",
    "rang;": "\u27e9",
    "rangd;": "\u2992",
    "range;": "\u29a5",
    "rangle;": "\u27e9",
    "raquo": "\xbb",
    "raquo;": "\xbb",
    "rarr;": "\u2192",
    "rarrap;": "\u2975",
    "rarrb;": "\u21e5",
    "rarrbfs;": "\u2920",
    "rarrc;": "\u2933",
    "rarrfs;": "\u291e",
    "rarrhk;": "\u21aa",
    "rarrlp;": "\u21ac",
    "rarrpl;": "\u2945",
    "rarrsim;": "\u2974",
    "rarrtl;": "\u21a3",
    "rarrw;": "\u219d",
    "ratail;": "\u291a",
    "ratio;": "\u2236",
    "rationals;": "\u211a",
    "rbarr;": "\u290d",
    "rbbrk;": "\u2773",
    "rbrace;": "}",
    "rbrack;": "]",
    "rbrke;": "\u298c",
    "rbrksld;": "\u298e",
    "rbrkslu;": "\u2990",
    "rcaron;": "\u0159",
    "rcedil;": "\u0157",
    "rceil;": "\u2309",
    "rcub;": "}",
    "rcy;": "\u0440",
    "rdca;": "\u2937",
    "rdldhar;": "\u2969",
    "rdquo;": "\u201d",
    "rdquor;": "\u201d",
    "rdsh;": "\u21b3",
    "real;": "\u211c",
    "realine;": "\u211b",
    "realpart;": "\u211c",
    "reals;": "\u211d",
    "rect;": "\u25ad",
    "reg": "\xae",
    "reg;": "\xae",
    "rfisht;": "\u297d",
    "rfloor;": "\u230b",
    "rfr;": "\U0001d52f",
    "rhard;": "\u21c1",
    "rharu;": "\u21c0",
    "rharul;": "\u296c",
    "rho;": "\u03c1",
    "rhov;": "\u03f1",
    "rightarrow;": "\u2192",
    "rightarrowtail;": "\u21a3",
    "rightharpoondown;": "\u21c1",
    "rightharpoonup;": "\u21c0",
    "rightleftarrows;": "\u21c4",
    "rightleftharpoons;": "\u21cc",
    "rightrightarrows;": "\u21c9",
    "rightsquigarrow;": "\u219d",
    "rightthreetimes;": "\u22cc",
    "ring;": "\u02da",
    "risingdotseq;": "\u2253",
    "rlarr;": "\u21c4",
    "rlhar;": "\u21cc",
    "rlm;": "\u200f",
    "rmoust;": "\u23b1",
    "rmoustache;": "\u23b1",
    "rnmid;": "\u2aee",
    "roang;": "\u27ed",
    "roarr;": "\u21fe",
    "robrk;": "\u27e7",
    "ropar;": "\u2986",
    "ropf;": "\U0001d563",
    "roplus;": "\u2a2e",
    "rotimes;": "\u2a35",
    "rpar;": ")",
    "rpargt;": "\u2994",
    "rppolint;": "\u2a12",
    "rrarr;": "\u21c9",
    "rsaquo;": "\u203a",
    "rscr;": "\U0001d4c7",
    "rsh;": "\u21b1",
    "rsqb;": "]",
    "rsquo;": "\u2019",
    "rsquor;": "\u2019",
    "rthree;": "\u22cc",
    "rtimes;": "\u22ca",
    "rtri;": "\u25b9",
    "rtrie;": "\u22b5",
    "rtrif;": "\u25b8",
    "rtriltri;": "\u29ce",
    "ruluhar;": "\u2968",
    "rx;": "\u211e",
    "sacute;": "\u015b",
    "sbquo;": "\u201a",
    "sc;": "\u227b",
    "scE;": "\u2ab4",
    "scap;": "\u2ab8",
    "scaron;": "\u0161",
    "sccue;": "\u227d",
    "sce;": "\u2ab0",
    "scedil;": "\u015f",
    "scirc;": "\u015d",
    "scnE;": "\u2ab6",
    "scnap;": "\u2aba",
    "scnsim;": "\u22e9",
    "scpolint;": "\u2a13",
    "scsim;": "\u227f",
    "scy;": "\u0441",
    "sdot;": "\u22c5",
    "sdotb;": "\u22a1",
    "sdote;": "\u2a66",
    "seArr;": "\u21d8",
    "searhk;": "\u2925",
    "searr;": "\u2198",
    "searrow;": "\u2198",
    "sect": "\xa7",
    "sect;": "\xa7",
    "semi;": ";",
    "seswar;": "\u2929",
    "setminus;": "\u2216",
    "setmn;": "\u2216",
    "sext;": "\u2736",
    "sfr;": "\U0001d530",
    "sfrown;": "\u2322",
    "sharp;": "\u266f",
    "shchcy;": "\u0449",
    "shcy;": "\u0448",
    "shortmid;": "\u2223",
    "shortparallel;": "\u2225",
    "shy": "\xad",
    "shy;": "\xad",
    "sigma;": "\u03c3",
    "sigmaf;": "\u03c2",
    "sigmav;": "\u03c2",
    "sim;": "\u223c",
    "simdot;": "\u2a6a",
    "sime;": "\u2243",
    "simeq;": "\u2243",
    "simg;": "\u2a9e",
    "simgE;": "\u2aa0",
    "siml;": "\u2a9d",
    "simlE;": "\u2a9f",
    "simne;": "\u2246",
    "simplus;": "\u2a24",
    "simrarr;": "\u2972",
    "slarr;": "\u2190",
    "smallsetminus;": "\u2216",
    "smashp;": "\u2a33",
    "smeparsl;": "\u29e4",
    "smid;": "\u2223",
    "smile;": "\u2323",
    "smt;": "\u2aaa",
    "smte;": "\u2aac",
    "smtes;": "\u2aac\ufe00",
    "softcy;": "\u044c",
    "sol;": "/",
    "solb;": "\u29c4",
    "solbar;": "\u233f",
    "sopf;": "\U0001d564",
    "spades;": "\u2660",
    "spadesuit;": "\u2660",
    "spar;": "\u2225",
    "sqcap;": "\u2293",
    "sqcaps;": "\u2293\ufe00",
    "sqcup;": "\u2294",
    "sqcups;": "\u2294\ufe00",
    "sqsub;": "\u228f",
    "sqsube;": "\u2291",
    "sqsubset;": "\u228f",
    "sqsubseteq;": "\u2291",
    "sqsup;": "\u2290",
    "sqsupe;": "\u2292",
    "sqsupset;": "\u2290",
    "sqsupseteq;": "\u2292",
    "squ;": "\u25a1",
    "square;": "\u25a1",
    "squarf;": "\u25aa",
    "squf;": "\u25aa",
    "srarr;": "\u2192",
    "sscr;": "\U0001d4c8",
    "ssetmn;": "\u2216",
    "ssmile;": "\u2323",
    "sstarf;": "\u22c6",
    "star;": "\u2606",
    "starf;": "\u2605",
    "straightepsilon;": "\u03f5",
    "straightphi;": "\u03d5",
    "strns;": "\xaf",
    "sub;": "\u2282",
    "subE;": "\u2ac5",
    "subdot;": "\u2abd",
    "sube;": "\u2286",
    "subedot;": "\u2ac3",
    "submult;": "\u2ac1",
    "subnE;": "\u2acb",
    "subne;": "\u228a",
    "subplus;": "\u2abf",
    "subrarr;": "\u2979",
    "subset;": "\u2282",
    "subseteq;": "\u2286",
    "subseteqq;": "\u2ac5",
    "subsetneq;": "\u228a",
    "subsetneqq;": "\u2acb",
    "subsim;": "\u2ac7",
    "subsub;": "\u2ad5",
    "subsup;": "\u2ad3",
    "succ;": "\u227b",
    "succapprox;": "\u2ab8",
    "succcurlyeq;": "\u227d",
    "succeq;": "\u2ab0",
    "succnapprox;": "\u2aba",
    "succneqq;": "\u2ab6",
    "succnsim;": "\u22e9",
    "succsim;": "\u227f",
    "sum;": "\u2211",
    "sung;": "\u266a",
    "sup1": "\xb9",
    "sup1;": "\xb9",
    "sup2": "\xb2",
    "sup2;": "\xb2",
    "sup3": "\xb3",
    "sup3;": "\xb3",
    "sup;": "\u2283",
    "supE;": "\u2ac6",
    "supdot;": "\u2abe",
    "supdsub;": "\u2ad8",
    "supe;": "\u2287",
    "supedot;": "\u2ac4",
    "suphsol;": "\u27c9",
    "suphsub;": "\u2ad7",
    "suplarr;": "\u297b",
    "supmult;": "\u2ac2",
    "supnE;": "\u2acc",
    "supne;": "\u228b",
    "supplus;": "\u2ac0",
    "supset;": "\u2283",
    "supseteq;": "\u2287",
    "supseteqq;": "\u2ac6",
    "supsetneq;": "\u228b",
    "supsetneqq;": "\u2acc",
    "supsim;": "\u2ac8",
    "supsub;": "\u2ad4",
    "supsup;": "\u2ad6",
    "swArr;": "\u21d9",
    "swarhk;": "\u2926",
    "swarr;": "\u2199",
    "swarrow;": "\u2199",
    "swnwar;": "\u292a",
    "szlig": "\xdf",
    "szlig;": "\xdf",
    "target;": "\u2316",
    "tau;": "\u03c4",
    "tbrk;": "\u23b4",
    "tcaron;": "\u0165",
    "tcedil;": "\u0163",
    "tcy;": "\u0442",
    "tdot;": "\u20db",
    "telrec;": "\u2315",
    "tfr;": "\U0001d531",
    "there4;": "\u2234",
    "therefore;": "\u2234",
    "theta;": "\u03b8",
    "thetasym;": "\u03d1",
    "thetav;": "\u03d1",
    "thickapprox;": "\u2248",
    "thicksim;": "\u223c",
    "thinsp;": "\u2009",
    "thkap;": "\u2248",
    "thksim;": "\u223c",
    "thorn": "\xfe",
    "thorn;": "\xfe",
    "tilde;": "\u02dc",
    "times": "\xd7",
    "times;": "\xd7",
    "timesb;": "\u22a0",
    "timesbar;": "\u2a31",
    "timesd;": "\u2a30",
    "tint;": "\u222d",
    "toea;": "\u2928",
    "top;": "\u22a4",
    "topbot;": "\u2336",
    "topcir;": "\u2af1",
    "topf;": "\U0001d565",
    "topfork;": "\u2ada",
    "tosa;": "\u2929",
    "tprime;": "\u2034",
    "trade;": "\u2122",
    "triangle;": "\u25b5",
    "triangledown;": "\u25bf",
    "triangleleft;": "\u25c3",
    "trianglelefteq;": "\u22b4",
    "triangleq;": "\u225c",
    "triangleright;": "\u25b9",
    "trianglerighteq;": "\u22b5",
    "tridot;": "\u25ec",
    "trie;": "\u225c",
    "triminus;": "\u2a3a",
    "triplus;": "\u2a39",
    "trisb;": "\u29cd",
    "tritime;": "\u2a3b",
    "trpezium;": "\u23e2",
    "tscr;": "\U0001d4c9",
    "tscy;": "\u0446",
    "tshcy;": "\u045b",
    "tstrok;": "\u0167",
    "twixt;": "\u226c",
    "twoheadleftarrow;": "\u219e",
    "twoheadrightarrow;": "\u21a0",
    "uArr;": "\u21d1",
    "uHar;": "\u2963",
    "uacute": "\xfa",
    "uacute;": "\xfa",
    "uarr;": "\u2191",
    "ubrcy;": "\u045e",
    "ubreve;": "\u016d",
    "ucirc": "\xfb",
    "ucirc;": "\xfb",
    "ucy;": "\u0443",
    "udarr;": "\u21c5",
    "udblac;": "\u0171",
    "udhar;": "\u296e",
    "ufisht;": "\u297e",
    "ufr;": "\U0001d532",
    "ugrave": "\xf9",
    "ugrave;": "\xf9",
    "uharl;": "\u21bf",
    "uharr;": "\u21be",
    "uhblk;": "\u2580",
    "ulcorn;": "\u231c",
    "ulcorner;": "\u231c",
    "ulcrop;": "\u230f",
    "ultri;": "\u25f8",
    "umacr;": "\u016b",
    "uml": "\xa8",
    "uml;": "\xa8",
    "uogon;": "\u0173",
    "uopf;": "\U0001d566",
    "uparrow;": "\u2191",
    "updownarrow;": "\u2195",
    "upharpoonleft;": "\u21bf",
    "upharpoonright;": "\u21be",
    "uplus;": "\u228e",
    "upsi;": "\u03c5",
    "upsih;": "\u03d2",
    "upsilon;": "\u03c5",
    "upuparrows;": "\u21c8",
    "urcorn;": "\u231d",
    "urcorner;": "\u231d",
    "urcrop;": "\u230e",
    "uring;": "\u016f",
    "urtri;": "\u25f9",
    "uscr;": "\U0001d4ca",
    "utdot;": "\u22f0",
    "utilde;": "\u0169",
    "utri;": "\u25b5",
    "utrif;": "\u25b4",
    "uuarr;": "\u21c8",
    "uuml": "\xfc",
    "uuml;": "\xfc",
    "uwangle;": "\u29a7",
    "vArr;": "\u21d5",
    "vBar;": "\u2ae8",
    "vBarv;": "\u2ae9",
    "vDash;": "\u22a8",
    "vangrt;": "\u299c",
    "varepsilon;": "\u03f5",
    "varkappa;": "\u03f0",
    "varnothing;": "\u2205",
    "varphi;": "\u03d5",
    "varpi;": "\u03d6",
    "varpropto;": "\u221d",
    "varr;": "\u2195",
    "varrho;": "\u03f1",
    "varsigma;": "\u03c2",
    "varsubsetneq;": "\u228a\ufe00",
    "varsubsetneqq;": "\u2acb\ufe00",
    "varsupsetneq;": "\u228b\ufe00",
    "varsupsetneqq;": "\u2acc\ufe00",
    "vartheta;": "\u03d1",
    "vartriangleleft;": "\u22b2",
    "vartriangleright;": "\u22b3",
    "vcy;": "\u0432",
    "vdash;": "\u22a2",
    "vee;": "\u2228",
    "veebar;": "\u22bb",
    "veeeq;": "\u225a",
    "vellip;": "\u22ee",
    "verbar;": "|",
    "vert;": "|",
    "vfr;": "\U0001d533",
    "vltri;": "\u22b2",
    "vnsub;": "\u2282\u20d2",
    "vnsup;": "\u2283\u20d2",
    "vopf;": "\U0001d567",
    "vprop;": "\u221d",
    "vrtri;": "\u22b3",
    "vscr;": "\U0001d4cb",
    "vsubnE;": "\u2acb\ufe00",
    "vsubne;": "\u228a\ufe00",
    "vsupnE;": "\u2acc\ufe00",
    "vsupne;": "\u228b\ufe00",
    "vzigzag;": "\u299a",
    "wcirc;": "\u0175",
    "wedbar;": "\u2a5f",
    "wedge;": "\u2227",
    "wedgeq;": "\u2259",
    "weierp;": "\u2118",
    "wfr;": "\U0001d534",
    "wopf;": "\U0001d568",
    "wp;": "\u2118",
    "wr;": "\u2240",
    "wreath;": "\u2240",
    "wscr;": "\U0001d4cc",
    "xcap;": "\u22c2",
    "xcirc;": "\u25ef",
    "xcup;": "\u22c3",
    "xdtri;": "\u25bd",
    "xfr;": "\U0001d535",
    "xhArr;": "\u27fa",
    "xharr;": "\u27f7",
    "xi;": "\u03be",
    "xlArr;": "\u27f8",
    "xlarr;": "\u27f5",
    "xmap;": "\u27fc",
    "xnis;": "\u22fb",
    "xodot;": "\u2a00",
    "xopf;": "\U0001d569",
    "xoplus;": "\u2a01",
    "xotime;": "\u2a02",
    "xrArr;": "\u27f9",
    "xrarr;": "\u27f6",
    "xscr;": "\U0001d4cd",
    "xsqcup;": "\u2a06",
    "xuplus;": "\u2a04",
    "xutri;": "\u25b3",
    "xvee;": "\u22c1",
    "xwedge;": "\u22c0",
    "yacute": "\xfd",
    "yacute;": "\xfd",
    "yacy;": "\u044f",
    "ycirc;": "\u0177",
    "ycy;": "\u044b",
    "yen": "\xa5",
    "yen;": "\xa5",
    "yfr;": "\U0001d536",
    "yicy;": "\u0457",
    "yopf;": "\U0001d56a",
    "yscr;": "\U0001d4ce",
    "yucy;": "\u044e",
    "yuml": "\xff",
    "yuml;": "\xff",
    "zacute;": "\u017a",
    "zcaron;": "\u017e",
    "zcy;": "\u0437",
    "zdot;": "\u017c",
    "zeetrf;": "\u2128",
    "zeta;": "\u03b6",
    "zfr;": "\U0001d537",
    "zhcy;": "\u0436",
    "zigrarr;": "\u21dd",
    "zopf;": "\U0001d56b",
    "zscr;": "\U0001d4cf",
    "zwj;": "\u200d",
    "zwnj;": "\u200c",
}

replacementCharacters = {
    0x0: "\uFFFD",
    0x0d: "\u000D",
    0x80: "\u20AC",
    0x81: "\u0081",
    0x81: "\u0081",
    0x82: "\u201A",
    0x83: "\u0192",
    0x84: "\u201E",
    0x85: "\u2026",
    0x86: "\u2020",
    0x87: "\u2021",
    0x88: "\u02C6",
    0x89: "\u2030",
    0x8A: "\u0160",
    0x8B: "\u2039",
    0x8C: "\u0152",
    0x8D: "\u008D",
    0x8E: "\u017D",
    0x8F: "\u008F",
    0x90: "\u0090",
    0x91: "\u2018",
    0x92: "\u2019",
    0x93: "\u201C",
    0x94: "\u201D",
    0x95: "\u2022",
    0x96: "\u2013",
    0x97: "\u2014",
    0x98: "\u02DC",
    0x99: "\u2122",
    0x9A: "\u0161",
    0x9B: "\u203A",
    0x9C: "\u0153",
    0x9D: "\u009D",
    0x9E: "\u017E",
    0x9F: "\u0178",
}

encodings = {
    '437': 'cp437',
    '850': 'cp850',
    '852': 'cp852',
    '855': 'cp855',
    '857': 'cp857',
    '860': 'cp860',
    '861': 'cp861',
    '862': 'cp862',
    '863': 'cp863',
    '865': 'cp865',
    '866': 'cp866',
    '869': 'cp869',
    'ansix341968': 'ascii',
    'ansix341986': 'ascii',
    'arabic': 'iso8859-6',
    'ascii': 'ascii',
    'asmo708': 'iso8859-6',
    'big5': 'big5',
    'big5hkscs': 'big5hkscs',
    'chinese': 'gbk',
    'cp037': 'cp037',
    'cp1026': 'cp1026',
    'cp154': 'ptcp154',
    'cp367': 'ascii',
    'cp424': 'cp424',
    'cp437': 'cp437',
    'cp500': 'cp500',
    'cp775': 'cp775',
    'cp819': 'windows-1252',
    'cp850': 'cp850',
    'cp852': 'cp852',
    'cp855': 'cp855',
    'cp857': 'cp857',
    'cp860': 'cp860',
    'cp861': 'cp861',
    'cp862': 'cp862',
    'cp863': 'cp863',
    'cp864': 'cp864',
    'cp865': 'cp865',
    'cp866': 'cp866',
    'cp869': 'cp869',
    'cp936': 'gbk',
    'cpgr': 'cp869',
    'cpis': 'cp861',
    'csascii': 'ascii',
    'csbig5': 'big5',
    'cseuckr': 'cp949',
    'cseucpkdfmtjapanese': 'euc_jp',
    'csgb2312': 'gbk',
    'cshproman8': 'hp-roman8',
    'csibm037': 'cp037',
    'csibm1026': 'cp1026',
    'csibm424': 'cp424',
    'csibm500': 'cp500',
    'csibm855': 'cp855',
    'csibm857': 'cp857',
    'csibm860': 'cp860',
    'csibm861': 'cp861',
    'csibm863': 'cp863',
    'csibm864': 'cp864',
    'csibm865': 'cp865',
    'csibm866': 'cp866',
    'csibm869': 'cp869',
    'csiso2022jp': 'iso2022_jp',
    'csiso2022jp2': 'iso2022_jp_2',
    'csiso2022kr': 'iso2022_kr',
    'csiso58gb231280': 'gbk',
    'csisolatin1': 'windows-1252',
    'csisolatin2': 'iso8859-2',
    'csisolatin3': 'iso8859-3',
    'csisolatin4': 'iso8859-4',
    'csisolatin5': 'windows-1254',
    'csisolatin6': 'iso8859-10',
    'csisolatinarabic': 'iso8859-6',
    'csisolatincyrillic': 'iso8859-5',
    'csisolatingreek': 'iso8859-7',
    'csisolatinhebrew': 'iso8859-8',
    'cskoi8r': 'koi8-r',
    'csksc56011987': 'cp949',
    'cspc775baltic': 'cp775',
    'cspc850multilingual': 'cp850',
    'cspc862latinhebrew': 'cp862',
    'cspc8codepage437': 'cp437',
    'cspcp852': 'cp852',
    'csptcp154': 'ptcp154',
    'csshiftjis': 'shift_jis',
    'csunicode11utf7': 'utf-7',
    'cyrillic': 'iso8859-5',
    'cyrillicasian': 'ptcp154',
    'ebcdiccpbe': 'cp500',
    'ebcdiccpca': 'cp037',
    'ebcdiccpch': 'cp500',
    'ebcdiccphe': 'cp424',
    'ebcdiccpnl': 'cp037',
    'ebcdiccpus': 'cp037',
    'ebcdiccpwt': 'cp037',
    'ecma114': 'iso8859-6',
    'ecma118': 'iso8859-7',
    'elot928': 'iso8859-7',
    'eucjp': 'euc_jp',
    'euckr': 'cp949',
    'extendedunixcodepackedformatforjapanese': 'euc_jp',
    'gb18030': 'gb18030',
    'gb2312': 'gbk',
    'gb231280': 'gbk',
    'gbk': 'gbk',
    'greek': 'iso8859-7',
    'greek8': 'iso8859-7',
    'hebrew': 'iso8859-8',
    'hproman8': 'hp-roman8',
    'hzgb2312': 'hz',
    'ibm037': 'cp037',
    'ibm1026': 'cp1026',
    'ibm367': 'ascii',
    'ibm424': 'cp424',
    'ibm437': 'cp437',
    'ibm500': 'cp500',
    'ibm775': 'cp775',
    'ibm819': 'windows-1252',
    'ibm850': 'cp850',
    'ibm852': 'cp852',
    'ibm855': 'cp855',
    'ibm857': 'cp857',
    'ibm860': 'cp860',
    'ibm861': 'cp861',
    'ibm862': 'cp862',
    'ibm863': 'cp863',
    'ibm864': 'cp864',
    'ibm865': 'cp865',
    'ibm866': 'cp866',
    'ibm869': 'cp869',
    'iso2022jp': 'iso2022_jp',
    'iso2022jp2': 'iso2022_jp_2',
    'iso2022kr': 'iso2022_kr',
    'iso646irv1991': 'ascii',
    'iso646us': 'ascii',
    'iso88591': 'windows-1252',
    'iso885910': 'iso8859-10',
    'iso8859101992': 'iso8859-10',
    'iso885911987': 'windows-1252',
    'iso885913': 'iso8859-13',
    'iso885914': 'iso8859-14',
    'iso8859141998': 'iso8859-14',
    'iso885915': 'iso8859-15',
    'iso885916': 'iso8859-16',
    'iso8859162001': 'iso8859-16',
    'iso88592': 'iso8859-2',
    'iso885921987': 'iso8859-2',
    'iso88593': 'iso8859-3',
    'iso885931988': 'iso8859-3',
    'iso88594': 'iso8859-4',
    'iso885941988': 'iso8859-4',
    'iso88595': 'iso8859-5',
    'iso885951988': 'iso8859-5',
    'iso88596': 'iso8859-6',
    'iso885961987': 'iso8859-6',
    'iso88597': 'iso8859-7',
    'iso885971987': 'iso8859-7',
    'iso88598': 'iso8859-8',
    'iso885981988': 'iso8859-8',
    'iso88599': 'windows-1254',
    'iso885991989': 'windows-1254',
    'isoceltic': 'iso8859-14',
    'isoir100': 'windows-1252',
    'isoir101': 'iso8859-2',
    'isoir109': 'iso8859-3',
    'isoir110': 'iso8859-4',
    'isoir126': 'iso8859-7',
    'isoir127': 'iso8859-6',
    'isoir138': 'iso8859-8',
    'isoir144': 'iso8859-5',
    'isoir148': 'windows-1254',
    'isoir149': 'cp949',
    'isoir157': 'iso8859-10',
    'isoir199': 'iso8859-14',
    'isoir226': 'iso8859-16',
    'isoir58': 'gbk',
    'isoir6': 'ascii',
    'koi8r': 'koi8-r',
    'koi8u': 'koi8-u',
    'korean': 'cp949',
    'ksc5601': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'l1': 'windows-1252',
    'l10': 'iso8859-16',
    'l2': 'iso8859-2',
    'l3': 'iso8859-3',
    'l4': 'iso8859-4',
    'l5': 'windows-1254',
    'l6': 'iso8859-10',
    'l8': 'iso8859-14',
    'latin1': 'windows-1252',
    'latin10': 'iso8859-16',
    'latin2': 'iso8859-2',
    'latin3': 'iso8859-3',
    'latin4': 'iso8859-4',
    'latin5': 'windows-1254',
    'latin6': 'iso8859-10',
    'latin8': 'iso8859-14',
    'latin9': 'iso8859-15',
    'ms936': 'gbk',
    'mskanji': 'shift_jis',
    'pt154': 'ptcp154',
    'ptcp154': 'ptcp154',
    'r8': 'hp-roman8',
    'roman8': 'hp-roman8',
    'shiftjis': 'shift_jis',
    'tis620': 'cp874',
    'unicode11utf7': 'utf-7',
    'us': 'ascii',
    'usascii': 'ascii',
    'utf16': 'utf-16',
    'utf16be': 'utf-16-be',
    'utf16le': 'utf-16-le',
    'utf8': 'utf-8',
    'windows1250': 'cp1250',
    'windows1251': 'cp1251',
    'windows1252': 'cp1252',
    'windows1253': 'cp1253',
    'windows1254': 'cp1254',
    'windows1255': 'cp1255',
    'windows1256': 'cp1256',
    'windows1257': 'cp1257',
    'windows1258': 'cp1258',
    'windows936': 'gbk',
    'x-x-big5': 'big5'}

tokenTypes = {
    "Doctype": 0,
    "Characters": 1,
    "SpaceCharacters": 2,
    "StartTag": 3,
    "EndTag": 4,
    "EmptyTag": 5,
    "Comment": 6,
    "ParseError": 7
}

tagTokenTypes = frozenset((tokenTypes["StartTag"], tokenTypes["EndTag"],
                           tokenTypes["EmptyTag"]))


prefixes = dict([(v, k) for k, v in namespaces.items()])
prefixes["http://www.w3.org/1998/Math/MathML"] = "math"


class DataLossWarning(UserWarning):
    pass


class ReparseException(Exception):
    pass

########NEW FILE########
__FILENAME__ = alphabeticalattributes
from __future__ import absolute_import, division, unicode_literals

from . import _base

try:
    from collections import OrderedDict
except ImportError:
    from ordereddict import OrderedDict


class Filter(_base.Filter):
    def __iter__(self):
        for token in _base.Filter.__iter__(self):
            if token["type"] in ("StartTag", "EmptyTag"):
                attrs = OrderedDict()
                for name, value in sorted(token["data"].items(),
                                          key=lambda x: x[0]):
                    attrs[name] = value
                token["data"] = attrs
            yield token

########NEW FILE########
__FILENAME__ = inject_meta_charset
from __future__ import absolute_import, division, unicode_literals

from . import _base


class Filter(_base.Filter):
    def __init__(self, source, encoding):
        _base.Filter.__init__(self, source)
        self.encoding = encoding

    def __iter__(self):
        state = "pre_head"
        meta_found = (self.encoding is None)
        pending = []

        for token in _base.Filter.__iter__(self):
            type = token["type"]
            if type == "StartTag":
                if token["name"].lower() == "head":
                    state = "in_head"

            elif type == "EmptyTag":
                if token["name"].lower() == "meta":
                    # replace charset with actual encoding
                    has_http_equiv_content_type = False
                    for (namespace, name), value in token["data"].items():
                        if namespace is not None:
                            continue
                        elif name.lower() == 'charset':
                            token["data"][(namespace, name)] = self.encoding
                            meta_found = True
                            break
                        elif name == 'http-equiv' and value.lower() == 'content-type':
                            has_http_equiv_content_type = True
                    else:
                        if has_http_equiv_content_type and (None, "content") in token["data"]:
                            token["data"][(None, "content")] = 'text/html; charset=%s' % self.encoding
                            meta_found = True

                elif token["name"].lower() == "head" and not meta_found:
                    # insert meta into empty head
                    yield {"type": "StartTag", "name": "head",
                           "data": token["data"]}
                    yield {"type": "EmptyTag", "name": "meta",
                           "data": {(None, "charset"): self.encoding}}
                    yield {"type": "EndTag", "name": "head"}
                    meta_found = True
                    continue

            elif type == "EndTag":
                if token["name"].lower() == "head" and pending:
                    # insert meta into head (if necessary) and flush pending queue
                    yield pending.pop(0)
                    if not meta_found:
                        yield {"type": "EmptyTag", "name": "meta",
                               "data": {(None, "charset"): self.encoding}}
                    while pending:
                        yield pending.pop(0)
                    meta_found = True
                    state = "post_head"

            if state == "in_head":
                pending.append(token)
            else:
                yield token

########NEW FILE########
__FILENAME__ = lint
from __future__ import absolute_import, division, unicode_literals

from gettext import gettext
_ = gettext

from . import _base
from ..constants import cdataElements, rcdataElements, voidElements

from ..constants import spaceCharacters
spaceCharacters = "".join(spaceCharacters)


class LintError(Exception):
    pass


class Filter(_base.Filter):
    def __iter__(self):
        open_elements = []
        contentModelFlag = "PCDATA"
        for token in _base.Filter.__iter__(self):
            type = token["type"]
            if type in ("StartTag", "EmptyTag"):
                name = token["name"]
                if contentModelFlag != "PCDATA":
                    raise LintError(_("StartTag not in PCDATA content model flag: %(tag)s") % {"tag": name})
                if not isinstance(name, str):
                    raise LintError(_("Tag name is not a string: %(tag)r") % {"tag": name})
                if not name:
                    raise LintError(_("Empty tag name"))
                if type == "StartTag" and name in voidElements:
                    raise LintError(_("Void element reported as StartTag token: %(tag)s") % {"tag": name})
                elif type == "EmptyTag" and name not in voidElements:
                    raise LintError(_("Non-void element reported as EmptyTag token: %(tag)s") % {"tag": token["name"]})
                if type == "StartTag":
                    open_elements.append(name)
                for name, value in token["data"]:
                    if not isinstance(name, str):
                        raise LintError(_("Attribute name is not a string: %(name)r") % {"name": name})
                    if not name:
                        raise LintError(_("Empty attribute name"))
                    if not isinstance(value, str):
                        raise LintError(_("Attribute value is not a string: %(value)r") % {"value": value})
                if name in cdataElements:
                    contentModelFlag = "CDATA"
                elif name in rcdataElements:
                    contentModelFlag = "RCDATA"
                elif name == "plaintext":
                    contentModelFlag = "PLAINTEXT"

            elif type == "EndTag":
                name = token["name"]
                if not isinstance(name, str):
                    raise LintError(_("Tag name is not a string: %(tag)r") % {"tag": name})
                if not name:
                    raise LintError(_("Empty tag name"))
                if name in voidElements:
                    raise LintError(_("Void element reported as EndTag token: %(tag)s") % {"tag": name})
                start_name = open_elements.pop()
                if start_name != name:
                    raise LintError(_("EndTag (%(end)s) does not match StartTag (%(start)s)") % {"end": name, "start": start_name})
                contentModelFlag = "PCDATA"

            elif type == "Comment":
                if contentModelFlag != "PCDATA":
                    raise LintError(_("Comment not in PCDATA content model flag"))

            elif type in ("Characters", "SpaceCharacters"):
                data = token["data"]
                if not isinstance(data, str):
                    raise LintError(_("Attribute name is not a string: %(name)r") % {"name": data})
                if not data:
                    raise LintError(_("%(type)s token with empty data") % {"type": type})
                if type == "SpaceCharacters":
                    data = data.strip(spaceCharacters)
                    if data:
                        raise LintError(_("Non-space character(s) found in SpaceCharacters token: %(token)r") % {"token": data})

            elif type == "Doctype":
                name = token["name"]
                if contentModelFlag != "PCDATA":
                    raise LintError(_("Doctype not in PCDATA content model flag: %(name)s") % {"name": name})
                if not isinstance(name, str):
                    raise LintError(_("Tag name is not a string: %(tag)r") % {"tag": name})
                # XXX: what to do with token["data"] ?

            elif type in ("ParseError", "SerializeError"):
                pass

            else:
                raise LintError(_("Unknown token type: %(type)s") % {"type": type})

            yield token

########NEW FILE########
__FILENAME__ = optionaltags
from __future__ import absolute_import, division, unicode_literals

from . import _base


class Filter(_base.Filter):
    def slider(self):
        previous1 = previous2 = None
        for token in self.source:
            if previous1 is not None:
                yield previous2, previous1, token
            previous2 = previous1
            previous1 = token
        yield previous2, previous1, None

    def __iter__(self):
        for previous, token, next in self.slider():
            type = token["type"]
            if type == "StartTag":
                if (token["data"] or
                        not self.is_optional_start(token["name"], previous, next)):
                    yield token
            elif type == "EndTag":
                if not self.is_optional_end(token["name"], next):
                    yield token
            else:
                yield token

    def is_optional_start(self, tagname, previous, next):
        type = next and next["type"] or None
        if tagname in 'html':
            # An html element's start tag may be omitted if the first thing
            # inside the html element is not a space character or a comment.
            return type not in ("Comment", "SpaceCharacters")
        elif tagname == 'head':
            # A head element's start tag may be omitted if the first thing
            # inside the head element is an element.
            # XXX: we also omit the start tag if the head element is empty
            if type in ("StartTag", "EmptyTag"):
                return True
            elif type == "EndTag":
                return next["name"] == "head"
        elif tagname == 'body':
            # A body element's start tag may be omitted if the first thing
            # inside the body element is not a space character or a comment,
            # except if the first thing inside the body element is a script
            # or style element and the node immediately preceding the body
            # element is a head element whose end tag has been omitted.
            if type in ("Comment", "SpaceCharacters"):
                return False
            elif type == "StartTag":
                # XXX: we do not look at the preceding event, so we never omit
                # the body element's start tag if it's followed by a script or
                # a style element.
                return next["name"] not in ('script', 'style')
            else:
                return True
        elif tagname == 'colgroup':
            # A colgroup element's start tag may be omitted if the first thing
            # inside the colgroup element is a col element, and if the element
            # is not immediately preceeded by another colgroup element whose
            # end tag has been omitted.
            if type in ("StartTag", "EmptyTag"):
                # XXX: we do not look at the preceding event, so instead we never
                # omit the colgroup element's end tag when it is immediately
                # followed by another colgroup element. See is_optional_end.
                return next["name"] == "col"
            else:
                return False
        elif tagname == 'tbody':
            # A tbody element's start tag may be omitted if the first thing
            # inside the tbody element is a tr element, and if the element is
            # not immediately preceeded by a tbody, thead, or tfoot element
            # whose end tag has been omitted.
            if type == "StartTag":
                # omit the thead and tfoot elements' end tag when they are
                # immediately followed by a tbody element. See is_optional_end.
                if previous and previous['type'] == 'EndTag' and \
                        previous['name'] in ('tbody', 'thead', 'tfoot'):
                    return False
                return next["name"] == 'tr'
            else:
                return False
        return False

    def is_optional_end(self, tagname, next):
        type = next and next["type"] or None
        if tagname in ('html', 'head', 'body'):
            # An html element's end tag may be omitted if the html element
            # is not immediately followed by a space character or a comment.
            return type not in ("Comment", "SpaceCharacters")
        elif tagname in ('li', 'optgroup', 'tr'):
            # A li element's end tag may be omitted if the li element is
            # immediately followed by another li element or if there is
            # no more content in the parent element.
            # An optgroup element's end tag may be omitted if the optgroup
            # element is immediately followed by another optgroup element,
            # or if there is no more content in the parent element.
            # A tr element's end tag may be omitted if the tr element is
            # immediately followed by another tr element, or if there is
            # no more content in the parent element.
            if type == "StartTag":
                return next["name"] == tagname
            else:
                return type == "EndTag" or type is None
        elif tagname in ('dt', 'dd'):
            # A dt element's end tag may be omitted if the dt element is
            # immediately followed by another dt element or a dd element.
            # A dd element's end tag may be omitted if the dd element is
            # immediately followed by another dd element or a dt element,
            # or if there is no more content in the parent element.
            if type == "StartTag":
                return next["name"] in ('dt', 'dd')
            elif tagname == 'dd':
                return type == "EndTag" or type is None
            else:
                return False
        elif tagname == 'p':
            # A p element's end tag may be omitted if the p element is
            # immediately followed by an address, article, aside,
            # blockquote, datagrid, dialog, dir, div, dl, fieldset,
            # footer, form, h1, h2, h3, h4, h5, h6, header, hr, menu,
            # nav, ol, p, pre, section, table, or ul, element, or if
            # there is no more content in the parent element.
            if type in ("StartTag", "EmptyTag"):
                return next["name"] in ('address', 'article', 'aside',
                                        'blockquote', 'datagrid', 'dialog',
                                        'dir', 'div', 'dl', 'fieldset', 'footer',
                                        'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6',
                                        'header', 'hr', 'menu', 'nav', 'ol',
                                        'p', 'pre', 'section', 'table', 'ul')
            else:
                return type == "EndTag" or type is None
        elif tagname == 'option':
            # An option element's end tag may be omitted if the option
            # element is immediately followed by another option element,
            # or if it is immediately followed by an <code>optgroup</code>
            # element, or if there is no more content in the parent
            # element.
            if type == "StartTag":
                return next["name"] in ('option', 'optgroup')
            else:
                return type == "EndTag" or type is None
        elif tagname in ('rt', 'rp'):
            # An rt element's end tag may be omitted if the rt element is
            # immediately followed by an rt or rp element, or if there is
            # no more content in the parent element.
            # An rp element's end tag may be omitted if the rp element is
            # immediately followed by an rt or rp element, or if there is
            # no more content in the parent element.
            if type == "StartTag":
                return next["name"] in ('rt', 'rp')
            else:
                return type == "EndTag" or type is None
        elif tagname == 'colgroup':
            # A colgroup element's end tag may be omitted if the colgroup
            # element is not immediately followed by a space character or
            # a comment.
            if type in ("Comment", "SpaceCharacters"):
                return False
            elif type == "StartTag":
                # XXX: we also look for an immediately following colgroup
                # element. See is_optional_start.
                return next["name"] != 'colgroup'
            else:
                return True
        elif tagname in ('thead', 'tbody'):
            # A thead element's end tag may be omitted if the thead element
            # is immediately followed by a tbody or tfoot element.
            # A tbody element's end tag may be omitted if the tbody element
            # is immediately followed by a tbody or tfoot element, or if
            # there is no more content in the parent element.
            # A tfoot element's end tag may be omitted if the tfoot element
            # is immediately followed by a tbody element, or if there is no
            # more content in the parent element.
            # XXX: we never omit the end tag when the following element is
            # a tbody. See is_optional_start.
            if type == "StartTag":
                return next["name"] in ['tbody', 'tfoot']
            elif tagname == 'tbody':
                return type == "EndTag" or type is None
            else:
                return False
        elif tagname == 'tfoot':
            # A tfoot element's end tag may be omitted if the tfoot element
            # is immediately followed by a tbody element, or if there is no
            # more content in the parent element.
            # XXX: we never omit the end tag when the following element is
            # a tbody. See is_optional_start.
            if type == "StartTag":
                return next["name"] == 'tbody'
            else:
                return type == "EndTag" or type is None
        elif tagname in ('td', 'th'):
            # A td element's end tag may be omitted if the td element is
            # immediately followed by a td or th element, or if there is
            # no more content in the parent element.
            # A th element's end tag may be omitted if the th element is
            # immediately followed by a td or th element, or if there is
            # no more content in the parent element.
            if type == "StartTag":
                return next["name"] in ('td', 'th')
            else:
                return type == "EndTag" or type is None
        return False

########NEW FILE########
__FILENAME__ = sanitizer
from __future__ import absolute_import, division, unicode_literals

from . import _base
from ..sanitizer import HTMLSanitizerMixin


class Filter(_base.Filter, HTMLSanitizerMixin):
    def __iter__(self):
        for token in _base.Filter.__iter__(self):
            token = self.sanitize_token(token)
            if token:
                yield token

########NEW FILE########
__FILENAME__ = whitespace
from __future__ import absolute_import, division, unicode_literals

import re

from . import _base
from ..constants import rcdataElements, spaceCharacters
spaceCharacters = "".join(spaceCharacters)

SPACES_REGEX = re.compile("[%s]+" % spaceCharacters)


class Filter(_base.Filter):

    spacePreserveElements = frozenset(["pre", "textarea"] + list(rcdataElements))

    def __iter__(self):
        preserve = 0
        for token in _base.Filter.__iter__(self):
            type = token["type"]
            if type == "StartTag" \
                    and (preserve or token["name"] in self.spacePreserveElements):
                preserve += 1

            elif type == "EndTag" and preserve:
                preserve -= 1

            elif not preserve and type == "SpaceCharacters" and token["data"]:
                # Test on token["data"] above to not introduce spaces where there were not
                token["data"] = " "

            elif not preserve and type == "Characters":
                token["data"] = collapse_spaces(token["data"])

            yield token


def collapse_spaces(text):
    return SPACES_REGEX.sub(' ', text)

########NEW FILE########
__FILENAME__ = _base
from __future__ import absolute_import, division, unicode_literals


class Filter(object):
    def __init__(self, source):
        self.source = source

    def __iter__(self):
        return iter(self.source)

    def __getattr__(self, name):
        return getattr(self.source, name)

########NEW FILE########
__FILENAME__ = html5parser
from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import with_metaclass

import types

from . import inputstream
from . import tokenizer

from . import treebuilders
from .treebuilders._base import Marker

from . import utils
from . import constants
from .constants import spaceCharacters, asciiUpper2Lower
from .constants import specialElements
from .constants import headingElements
from .constants import cdataElements, rcdataElements
from .constants import tokenTypes, ReparseException, namespaces
from .constants import htmlIntegrationPointElements, mathmlTextIntegrationPointElements
from .constants import adjustForeignAttributes as adjustForeignAttributesMap


def parse(doc, treebuilder="etree", encoding=None,
          namespaceHTMLElements=True):
    """Parse a string or file-like object into a tree"""
    tb = treebuilders.getTreeBuilder(treebuilder)
    p = HTMLParser(tb, namespaceHTMLElements=namespaceHTMLElements)
    return p.parse(doc, encoding=encoding)


def parseFragment(doc, container="div", treebuilder="etree", encoding=None,
                  namespaceHTMLElements=True):
    tb = treebuilders.getTreeBuilder(treebuilder)
    p = HTMLParser(tb, namespaceHTMLElements=namespaceHTMLElements)
    return p.parseFragment(doc, container=container, encoding=encoding)


def method_decorator_metaclass(function):
    class Decorated(type):
        def __new__(meta, classname, bases, classDict):
            for attributeName, attribute in classDict.items():
                if isinstance(attribute, types.FunctionType):
                    attribute = function(attribute)

                classDict[attributeName] = attribute
            return type.__new__(meta, classname, bases, classDict)
    return Decorated


class HTMLParser(object):
    """HTML parser. Generates a tree structure from a stream of (possibly
        malformed) HTML"""

    def __init__(self, tree=None, tokenizer=tokenizer.HTMLTokenizer,
                 strict=False, namespaceHTMLElements=True, debug=False):
        """
        strict - raise an exception when a parse error is encountered

        tree - a treebuilder class controlling the type of tree that will be
        returned. Built in treebuilders can be accessed through
        html5lib.treebuilders.getTreeBuilder(treeType)

        tokenizer - a class that provides a stream of tokens to the treebuilder.
        This may be replaced for e.g. a sanitizer which converts some tags to
        text
        """

        # Raise an exception on the first error encountered
        self.strict = strict

        if tree is None:
            tree = treebuilders.getTreeBuilder("etree")
        self.tree = tree(namespaceHTMLElements)
        self.tokenizer_class = tokenizer
        self.errors = []

        self.phases = dict([(name, cls(self, self.tree)) for name, cls in
                            getPhases(debug).items()])

    def _parse(self, stream, innerHTML=False, container="div",
               encoding=None, parseMeta=True, useChardet=True, **kwargs):

        self.innerHTMLMode = innerHTML
        self.container = container
        self.tokenizer = self.tokenizer_class(stream, encoding=encoding,
                                              parseMeta=parseMeta,
                                              useChardet=useChardet,
                                              parser=self, **kwargs)
        self.reset()

        while True:
            try:
                self.mainLoop()
                break
            except ReparseException:
                self.reset()

    def reset(self):
        self.tree.reset()
        self.firstStartTag = False
        self.errors = []
        self.log = []  # only used with debug mode
        # "quirks" / "limited quirks" / "no quirks"
        self.compatMode = "no quirks"

        if self.innerHTMLMode:
            self.innerHTML = self.container.lower()

            if self.innerHTML in cdataElements:
                self.tokenizer.state = self.tokenizer.rcdataState
            elif self.innerHTML in rcdataElements:
                self.tokenizer.state = self.tokenizer.rawtextState
            elif self.innerHTML == 'plaintext':
                self.tokenizer.state = self.tokenizer.plaintextState
            else:
                # state already is data state
                # self.tokenizer.state = self.tokenizer.dataState
                pass
            self.phase = self.phases["beforeHtml"]
            self.phase.insertHtmlElement()
            self.resetInsertionMode()
        else:
            self.innerHTML = False
            self.phase = self.phases["initial"]

        self.lastPhase = None

        self.beforeRCDataPhase = None

        self.framesetOK = True

    def isHTMLIntegrationPoint(self, element):
        if (element.name == "annotation-xml" and
                element.namespace == namespaces["mathml"]):
            return ("encoding" in element.attributes and
                    element.attributes["encoding"].translate(
                        asciiUpper2Lower) in
                    ("text/html", "application/xhtml+xml"))
        else:
            return (element.namespace, element.name) in htmlIntegrationPointElements

    def isMathMLTextIntegrationPoint(self, element):
        return (element.namespace, element.name) in mathmlTextIntegrationPointElements

    def mainLoop(self):
        CharactersToken = tokenTypes["Characters"]
        SpaceCharactersToken = tokenTypes["SpaceCharacters"]
        StartTagToken = tokenTypes["StartTag"]
        EndTagToken = tokenTypes["EndTag"]
        CommentToken = tokenTypes["Comment"]
        DoctypeToken = tokenTypes["Doctype"]
        ParseErrorToken = tokenTypes["ParseError"]

        for token in self.normalizedTokens():
            new_token = token
            while new_token is not None:
                currentNode = self.tree.openElements[-1] if self.tree.openElements else None
                currentNodeNamespace = currentNode.namespace if currentNode else None
                currentNodeName = currentNode.name if currentNode else None

                type = new_token["type"]

                if type == ParseErrorToken:
                    self.parseError(new_token["data"], new_token.get("datavars", {}))
                    new_token = None
                else:
                    if (len(self.tree.openElements) == 0 or
                        currentNodeNamespace == self.tree.defaultNamespace or
                        (self.isMathMLTextIntegrationPoint(currentNode) and
                         ((type == StartTagToken and
                           token["name"] not in frozenset(["mglyph", "malignmark"])) or
                          type in (CharactersToken, SpaceCharactersToken))) or
                        (currentNodeNamespace == namespaces["mathml"] and
                         currentNodeName == "annotation-xml" and
                         token["name"] == "svg") or
                        (self.isHTMLIntegrationPoint(currentNode) and
                         type in (StartTagToken, CharactersToken, SpaceCharactersToken))):
                        phase = self.phase
                    else:
                        phase = self.phases["inForeignContent"]

                    if type == CharactersToken:
                        new_token = phase.processCharacters(new_token)
                    elif type == SpaceCharactersToken:
                        new_token = phase.processSpaceCharacters(new_token)
                    elif type == StartTagToken:
                        new_token = phase.processStartTag(new_token)
                    elif type == EndTagToken:
                        new_token = phase.processEndTag(new_token)
                    elif type == CommentToken:
                        new_token = phase.processComment(new_token)
                    elif type == DoctypeToken:
                        new_token = phase.processDoctype(new_token)

            if (type == StartTagToken and token["selfClosing"]
                    and not token["selfClosingAcknowledged"]):
                self.parseError("non-void-element-with-trailing-solidus",
                                {"name": token["name"]})

        # When the loop finishes it's EOF
        reprocess = True
        phases = []
        while reprocess:
            phases.append(self.phase)
            reprocess = self.phase.processEOF()
            if reprocess:
                assert self.phase not in phases

    def normalizedTokens(self):
        for token in self.tokenizer:
            yield self.normalizeToken(token)

    def parse(self, stream, encoding=None, parseMeta=True, useChardet=True):
        """Parse a HTML document into a well-formed tree

        stream - a filelike object or string containing the HTML to be parsed

        The optional encoding parameter must be a string that indicates
        the encoding.  If specified, that encoding will be used,
        regardless of any BOM or later declaration (such as in a meta
        element)
        """
        self._parse(stream, innerHTML=False, encoding=encoding,
                    parseMeta=parseMeta, useChardet=useChardet)
        return self.tree.getDocument()

    def parseFragment(self, stream, container="div", encoding=None,
                      parseMeta=False, useChardet=True):
        """Parse a HTML fragment into a well-formed tree fragment

        container - name of the element we're setting the innerHTML property
        if set to None, default to 'div'

        stream - a filelike object or string containing the HTML to be parsed

        The optional encoding parameter must be a string that indicates
        the encoding.  If specified, that encoding will be used,
        regardless of any BOM or later declaration (such as in a meta
        element)
        """
        self._parse(stream, True, container=container, encoding=encoding)
        return self.tree.getFragment()

    def parseError(self, errorcode="XXX-undefined-error", datavars={}):
        # XXX The idea is to make errorcode mandatory.
        self.errors.append((self.tokenizer.stream.position(), errorcode, datavars))
        if self.strict:
            raise ParseError

    def normalizeToken(self, token):
        """ HTML5 specific normalizations to the token stream """

        if token["type"] == tokenTypes["StartTag"]:
            token["data"] = dict(token["data"][::-1])

        return token

    def adjustMathMLAttributes(self, token):
        replacements = {"definitionurl": "definitionURL"}
        for k, v in replacements.items():
            if k in token["data"]:
                token["data"][v] = token["data"][k]
                del token["data"][k]

    def adjustSVGAttributes(self, token):
        replacements = {
            "attributename": "attributeName",
            "attributetype": "attributeType",
            "basefrequency": "baseFrequency",
            "baseprofile": "baseProfile",
            "calcmode": "calcMode",
            "clippathunits": "clipPathUnits",
            "contentscripttype": "contentScriptType",
            "contentstyletype": "contentStyleType",
            "diffuseconstant": "diffuseConstant",
            "edgemode": "edgeMode",
            "externalresourcesrequired": "externalResourcesRequired",
            "filterres": "filterRes",
            "filterunits": "filterUnits",
            "glyphref": "glyphRef",
            "gradienttransform": "gradientTransform",
            "gradientunits": "gradientUnits",
            "kernelmatrix": "kernelMatrix",
            "kernelunitlength": "kernelUnitLength",
            "keypoints": "keyPoints",
            "keysplines": "keySplines",
            "keytimes": "keyTimes",
            "lengthadjust": "lengthAdjust",
            "limitingconeangle": "limitingConeAngle",
            "markerheight": "markerHeight",
            "markerunits": "markerUnits",
            "markerwidth": "markerWidth",
            "maskcontentunits": "maskContentUnits",
            "maskunits": "maskUnits",
            "numoctaves": "numOctaves",
            "pathlength": "pathLength",
            "patterncontentunits": "patternContentUnits",
            "patterntransform": "patternTransform",
            "patternunits": "patternUnits",
            "pointsatx": "pointsAtX",
            "pointsaty": "pointsAtY",
            "pointsatz": "pointsAtZ",
            "preservealpha": "preserveAlpha",
            "preserveaspectratio": "preserveAspectRatio",
            "primitiveunits": "primitiveUnits",
            "refx": "refX",
            "refy": "refY",
            "repeatcount": "repeatCount",
            "repeatdur": "repeatDur",
            "requiredextensions": "requiredExtensions",
            "requiredfeatures": "requiredFeatures",
            "specularconstant": "specularConstant",
            "specularexponent": "specularExponent",
            "spreadmethod": "spreadMethod",
            "startoffset": "startOffset",
            "stddeviation": "stdDeviation",
            "stitchtiles": "stitchTiles",
            "surfacescale": "surfaceScale",
            "systemlanguage": "systemLanguage",
            "tablevalues": "tableValues",
            "targetx": "targetX",
            "targety": "targetY",
            "textlength": "textLength",
            "viewbox": "viewBox",
            "viewtarget": "viewTarget",
            "xchannelselector": "xChannelSelector",
            "ychannelselector": "yChannelSelector",
            "zoomandpan": "zoomAndPan"
        }
        for originalName in list(token["data"].keys()):
            if originalName in replacements:
                svgName = replacements[originalName]
                token["data"][svgName] = token["data"][originalName]
                del token["data"][originalName]

    def adjustForeignAttributes(self, token):
        replacements = adjustForeignAttributesMap

        for originalName in token["data"].keys():
            if originalName in replacements:
                foreignName = replacements[originalName]
                token["data"][foreignName] = token["data"][originalName]
                del token["data"][originalName]

    def reparseTokenNormal(self, token):
        self.parser.phase()

    def resetInsertionMode(self):
        # The name of this method is mostly historical. (It's also used in the
        # specification.)
        last = False
        newModes = {
            "select": "inSelect",
            "td": "inCell",
            "th": "inCell",
            "tr": "inRow",
            "tbody": "inTableBody",
            "thead": "inTableBody",
            "tfoot": "inTableBody",
            "caption": "inCaption",
            "colgroup": "inColumnGroup",
            "table": "inTable",
            "head": "inBody",
            "body": "inBody",
            "frameset": "inFrameset",
            "html": "beforeHead"
        }
        for node in self.tree.openElements[::-1]:
            nodeName = node.name
            new_phase = None
            if node == self.tree.openElements[0]:
                assert self.innerHTML
                last = True
                nodeName = self.innerHTML
            # Check for conditions that should only happen in the innerHTML
            # case
            if nodeName in ("select", "colgroup", "head", "html"):
                assert self.innerHTML

            if not last and node.namespace != self.tree.defaultNamespace:
                continue

            if nodeName in newModes:
                new_phase = self.phases[newModes[nodeName]]
                break
            elif last:
                new_phase = self.phases["inBody"]
                break

        self.phase = new_phase

    def parseRCDataRawtext(self, token, contentType):
        """Generic RCDATA/RAWTEXT Parsing algorithm
        contentType - RCDATA or RAWTEXT
        """
        assert contentType in ("RAWTEXT", "RCDATA")

        self.tree.insertElement(token)

        if contentType == "RAWTEXT":
            self.tokenizer.state = self.tokenizer.rawtextState
        else:
            self.tokenizer.state = self.tokenizer.rcdataState

        self.originalPhase = self.phase

        self.phase = self.phases["text"]


def getPhases(debug):
    def log(function):
        """Logger that records which phase processes each token"""
        type_names = dict((value, key) for key, value in
                          constants.tokenTypes.items())

        def wrapped(self, *args, **kwargs):
            if function.__name__.startswith("process") and len(args) > 0:
                token = args[0]
                try:
                    info = {"type": type_names[token['type']]}
                except:
                    raise
                if token['type'] in constants.tagTokenTypes:
                    info["name"] = token['name']

                self.parser.log.append((self.parser.tokenizer.state.__name__,
                                        self.parser.phase.__class__.__name__,
                                        self.__class__.__name__,
                                        function.__name__,
                                        info))
                return function(self, *args, **kwargs)
            else:
                return function(self, *args, **kwargs)
        return wrapped

    def getMetaclass(use_metaclass, metaclass_func):
        if use_metaclass:
            return method_decorator_metaclass(metaclass_func)
        else:
            return type

    class Phase(with_metaclass(getMetaclass(debug, log))):
        """Base class for helper object that implements each phase of processing
        """

        def __init__(self, parser, tree):
            self.parser = parser
            self.tree = tree

        def processEOF(self):
            raise NotImplementedError

        def processComment(self, token):
            # For most phases the following is correct. Where it's not it will be
            # overridden.
            self.tree.insertComment(token, self.tree.openElements[-1])

        def processDoctype(self, token):
            self.parser.parseError("unexpected-doctype")

        def processCharacters(self, token):
            self.tree.insertText(token["data"])

        def processSpaceCharacters(self, token):
            self.tree.insertText(token["data"])

        def processStartTag(self, token):
            return self.startTagHandler[token["name"]](token)

        def startTagHtml(self, token):
            if not self.parser.firstStartTag and token["name"] == "html":
                self.parser.parseError("non-html-root")
            # XXX Need a check here to see if the first start tag token emitted is
            # this token... If it's not, invoke self.parser.parseError().
            for attr, value in token["data"].items():
                if attr not in self.tree.openElements[0].attributes:
                    self.tree.openElements[0].attributes[attr] = value
            self.parser.firstStartTag = False

        def processEndTag(self, token):
            return self.endTagHandler[token["name"]](token)

    class InitialPhase(Phase):
        def processSpaceCharacters(self, token):
            pass

        def processComment(self, token):
            self.tree.insertComment(token, self.tree.document)

        def processDoctype(self, token):
            name = token["name"]
            publicId = token["publicId"]
            systemId = token["systemId"]
            correct = token["correct"]

            if (name != "html" or publicId is not None or
                    systemId is not None and systemId != "about:legacy-compat"):
                self.parser.parseError("unknown-doctype")

            if publicId is None:
                publicId = ""

            self.tree.insertDoctype(token)

            if publicId != "":
                publicId = publicId.translate(asciiUpper2Lower)

            if (not correct or token["name"] != "html"
                or publicId.startswith(
                    ("+//silmaril//dtd html pro v0r11 19970101//",
                     "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
                     "-//as//dtd html 3.0 aswedit + extensions//",
                     "-//ietf//dtd html 2.0 level 1//",
                     "-//ietf//dtd html 2.0 level 2//",
                     "-//ietf//dtd html 2.0 strict level 1//",
                     "-//ietf//dtd html 2.0 strict level 2//",
                     "-//ietf//dtd html 2.0 strict//",
                     "-//ietf//dtd html 2.0//",
                     "-//ietf//dtd html 2.1e//",
                     "-//ietf//dtd html 3.0//",
                     "-//ietf//dtd html 3.2 final//",
                     "-//ietf//dtd html 3.2//",
                     "-//ietf//dtd html 3//",
                     "-//ietf//dtd html level 0//",
                     "-//ietf//dtd html level 1//",
                     "-//ietf//dtd html level 2//",
                     "-//ietf//dtd html level 3//",
                     "-//ietf//dtd html strict level 0//",
                     "-//ietf//dtd html strict level 1//",
                     "-//ietf//dtd html strict level 2//",
                     "-//ietf//dtd html strict level 3//",
                     "-//ietf//dtd html strict//",
                     "-//ietf//dtd html//",
                     "-//metrius//dtd metrius presentational//",
                     "-//microsoft//dtd internet explorer 2.0 html strict//",
                     "-//microsoft//dtd internet explorer 2.0 html//",
                     "-//microsoft//dtd internet explorer 2.0 tables//",
                     "-//microsoft//dtd internet explorer 3.0 html strict//",
                     "-//microsoft//dtd internet explorer 3.0 html//",
                     "-//microsoft//dtd internet explorer 3.0 tables//",
                     "-//netscape comm. corp.//dtd html//",
                     "-//netscape comm. corp.//dtd strict html//",
                     "-//o'reilly and associates//dtd html 2.0//",
                     "-//o'reilly and associates//dtd html extended 1.0//",
                     "-//o'reilly and associates//dtd html extended relaxed 1.0//",
                     "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
                     "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
                     "-//spyglass//dtd html 2.0 extended//",
                     "-//sq//dtd html 2.0 hotmetal + extensions//",
                     "-//sun microsystems corp.//dtd hotjava html//",
                     "-//sun microsystems corp.//dtd hotjava strict html//",
                     "-//w3c//dtd html 3 1995-03-24//",
                     "-//w3c//dtd html 3.2 draft//",
                     "-//w3c//dtd html 3.2 final//",
                     "-//w3c//dtd html 3.2//",
                     "-//w3c//dtd html 3.2s draft//",
                     "-//w3c//dtd html 4.0 frameset//",
                     "-//w3c//dtd html 4.0 transitional//",
                     "-//w3c//dtd html experimental 19960712//",
                     "-//w3c//dtd html experimental 970421//",
                     "-//w3c//dtd w3 html//",
                     "-//w3o//dtd w3 html 3.0//",
                     "-//webtechs//dtd mozilla html 2.0//",
                     "-//webtechs//dtd mozilla html//"))
                or publicId in
                    ("-//w3o//dtd w3 html strict 3.0//en//",
                     "-/w3c/dtd html 4.0 transitional/en",
                     "html")
                or publicId.startswith(
                    ("-//w3c//dtd html 4.01 frameset//",
                     "-//w3c//dtd html 4.01 transitional//")) and
                    systemId is None
                    or systemId and systemId.lower() == "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"):
                self.parser.compatMode = "quirks"
            elif (publicId.startswith(
                    ("-//w3c//dtd xhtml 1.0 frameset//",
                     "-//w3c//dtd xhtml 1.0 transitional//"))
                  or publicId.startswith(
                      ("-//w3c//dtd html 4.01 frameset//",
                       "-//w3c//dtd html 4.01 transitional//")) and
                  systemId is not None):
                self.parser.compatMode = "limited quirks"

            self.parser.phase = self.parser.phases["beforeHtml"]

        def anythingElse(self):
            self.parser.compatMode = "quirks"
            self.parser.phase = self.parser.phases["beforeHtml"]

        def processCharacters(self, token):
            self.parser.parseError("expected-doctype-but-got-chars")
            self.anythingElse()
            return token

        def processStartTag(self, token):
            self.parser.parseError("expected-doctype-but-got-start-tag",
                                   {"name": token["name"]})
            self.anythingElse()
            return token

        def processEndTag(self, token):
            self.parser.parseError("expected-doctype-but-got-end-tag",
                                   {"name": token["name"]})
            self.anythingElse()
            return token

        def processEOF(self):
            self.parser.parseError("expected-doctype-but-got-eof")
            self.anythingElse()
            return True

    class BeforeHtmlPhase(Phase):
        # helper methods
        def insertHtmlElement(self):
            self.tree.insertRoot(impliedTagToken("html", "StartTag"))
            self.parser.phase = self.parser.phases["beforeHead"]

        # other
        def processEOF(self):
            self.insertHtmlElement()
            return True

        def processComment(self, token):
            self.tree.insertComment(token, self.tree.document)

        def processSpaceCharacters(self, token):
            pass

        def processCharacters(self, token):
            self.insertHtmlElement()
            return token

        def processStartTag(self, token):
            if token["name"] == "html":
                self.parser.firstStartTag = True
            self.insertHtmlElement()
            return token

        def processEndTag(self, token):
            if token["name"] not in ("head", "body", "html", "br"):
                self.parser.parseError("unexpected-end-tag-before-html",
                                       {"name": token["name"]})
            else:
                self.insertHtmlElement()
                return token

    class BeforeHeadPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("head", self.startTagHead)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                (("head", "body", "html", "br"), self.endTagImplyHead)
            ])
            self.endTagHandler.default = self.endTagOther

        def processEOF(self):
            self.startTagHead(impliedTagToken("head", "StartTag"))
            return True

        def processSpaceCharacters(self, token):
            pass

        def processCharacters(self, token):
            self.startTagHead(impliedTagToken("head", "StartTag"))
            return token

        def startTagHtml(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagHead(self, token):
            self.tree.insertElement(token)
            self.tree.headPointer = self.tree.openElements[-1]
            self.parser.phase = self.parser.phases["inHead"]

        def startTagOther(self, token):
            self.startTagHead(impliedTagToken("head", "StartTag"))
            return token

        def endTagImplyHead(self, token):
            self.startTagHead(impliedTagToken("head", "StartTag"))
            return token

        def endTagOther(self, token):
            self.parser.parseError("end-tag-after-implied-root",
                                   {"name": token["name"]})

    class InHeadPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("title", self.startTagTitle),
                (("noscript", "noframes", "style"), self.startTagNoScriptNoFramesStyle),
                ("script", self.startTagScript),
                (("base", "basefont", "bgsound", "command", "link"),
                 self.startTagBaseLinkCommand),
                ("meta", self.startTagMeta),
                ("head", self.startTagHead)
            ])
            self.startTagHandler.default = self.startTagOther

            self. endTagHandler = utils.MethodDispatcher([
                ("head", self.endTagHead),
                (("br", "html", "body"), self.endTagHtmlBodyBr)
            ])
            self.endTagHandler.default = self.endTagOther

        # the real thing
        def processEOF(self):
            self.anythingElse()
            return True

        def processCharacters(self, token):
            self.anythingElse()
            return token

        def startTagHtml(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagHead(self, token):
            self.parser.parseError("two-heads-are-not-better-than-one")

        def startTagBaseLinkCommand(self, token):
            self.tree.insertElement(token)
            self.tree.openElements.pop()
            token["selfClosingAcknowledged"] = True

        def startTagMeta(self, token):
            self.tree.insertElement(token)
            self.tree.openElements.pop()
            token["selfClosingAcknowledged"] = True

            attributes = token["data"]
            if self.parser.tokenizer.stream.charEncoding[1] == "tentative":
                if "charset" in attributes:
                    self.parser.tokenizer.stream.changeEncoding(attributes["charset"])
                elif ("content" in attributes and
                      "http-equiv" in attributes and
                      attributes["http-equiv"].lower() == "content-type"):
                    # Encoding it as UTF-8 here is a hack, as really we should pass
                    # the abstract Unicode string, and just use the
                    # ContentAttrParser on that, but using UTF-8 allows all chars
                    # to be encoded and as a ASCII-superset works.
                    data = inputstream.EncodingBytes(attributes["content"].encode("utf-8"))
                    parser = inputstream.ContentAttrParser(data)
                    codec = parser.parse()
                    self.parser.tokenizer.stream.changeEncoding(codec)

        def startTagTitle(self, token):
            self.parser.parseRCDataRawtext(token, "RCDATA")

        def startTagNoScriptNoFramesStyle(self, token):
            # Need to decide whether to implement the scripting-disabled case
            self.parser.parseRCDataRawtext(token, "RAWTEXT")

        def startTagScript(self, token):
            self.tree.insertElement(token)
            self.parser.tokenizer.state = self.parser.tokenizer.scriptDataState
            self.parser.originalPhase = self.parser.phase
            self.parser.phase = self.parser.phases["text"]

        def startTagOther(self, token):
            self.anythingElse()
            return token

        def endTagHead(self, token):
            node = self.parser.tree.openElements.pop()
            assert node.name == "head", "Expected head got %s" % node.name
            self.parser.phase = self.parser.phases["afterHead"]

        def endTagHtmlBodyBr(self, token):
            self.anythingElse()
            return token

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag", {"name": token["name"]})

        def anythingElse(self):
            self.endTagHead(impliedTagToken("head"))

    # XXX If we implement a parser for which scripting is disabled we need to
    # implement this phase.
    #
    # class InHeadNoScriptPhase(Phase):
    class AfterHeadPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("body", self.startTagBody),
                ("frameset", self.startTagFrameset),
                (("base", "basefont", "bgsound", "link", "meta", "noframes", "script",
                  "style", "title"),
                 self.startTagFromHead),
                ("head", self.startTagHead)
            ])
            self.startTagHandler.default = self.startTagOther
            self.endTagHandler = utils.MethodDispatcher([(("body", "html", "br"),
                                                          self.endTagHtmlBodyBr)])
            self.endTagHandler.default = self.endTagOther

        def processEOF(self):
            self.anythingElse()
            return True

        def processCharacters(self, token):
            self.anythingElse()
            return token

        def startTagHtml(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagBody(self, token):
            self.parser.framesetOK = False
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inBody"]

        def startTagFrameset(self, token):
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inFrameset"]

        def startTagFromHead(self, token):
            self.parser.parseError("unexpected-start-tag-out-of-my-head",
                                   {"name": token["name"]})
            self.tree.openElements.append(self.tree.headPointer)
            self.parser.phases["inHead"].processStartTag(token)
            for node in self.tree.openElements[::-1]:
                if node.name == "head":
                    self.tree.openElements.remove(node)
                    break

        def startTagHead(self, token):
            self.parser.parseError("unexpected-start-tag", {"name": token["name"]})

        def startTagOther(self, token):
            self.anythingElse()
            return token

        def endTagHtmlBodyBr(self, token):
            self.anythingElse()
            return token

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag", {"name": token["name"]})

        def anythingElse(self):
            self.tree.insertElement(impliedTagToken("body", "StartTag"))
            self.parser.phase = self.parser.phases["inBody"]
            self.parser.framesetOK = True

    class InBodyPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#parsing-main-inbody
        # the really-really-really-very crazy mode
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            # Keep a ref to this for special handling of whitespace in <pre>
            self.processSpaceCharactersNonPre = self.processSpaceCharacters

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                (("base", "basefont", "bgsound", "command", "link", "meta",
                  "noframes", "script", "style", "title"),
                 self.startTagProcessInHead),
                ("body", self.startTagBody),
                ("frameset", self.startTagFrameset),
                (("address", "article", "aside", "blockquote", "center", "details",
                  "details", "dir", "div", "dl", "fieldset", "figcaption", "figure",
                  "footer", "header", "hgroup", "main", "menu", "nav", "ol", "p",
                  "section", "summary", "ul"),
                 self.startTagCloseP),
                (headingElements, self.startTagHeading),
                (("pre", "listing"), self.startTagPreListing),
                ("form", self.startTagForm),
                (("li", "dd", "dt"), self.startTagListItem),
                ("plaintext", self.startTagPlaintext),
                ("a", self.startTagA),
                (("b", "big", "code", "em", "font", "i", "s", "small", "strike",
                  "strong", "tt", "u"), self.startTagFormatting),
                ("nobr", self.startTagNobr),
                ("button", self.startTagButton),
                (("applet", "marquee", "object"), self.startTagAppletMarqueeObject),
                ("xmp", self.startTagXmp),
                ("table", self.startTagTable),
                (("area", "br", "embed", "img", "keygen", "wbr"),
                 self.startTagVoidFormatting),
                (("param", "source", "track"), self.startTagParamSource),
                ("input", self.startTagInput),
                ("hr", self.startTagHr),
                ("image", self.startTagImage),
                ("isindex", self.startTagIsIndex),
                ("textarea", self.startTagTextarea),
                ("iframe", self.startTagIFrame),
                (("noembed", "noframes", "noscript"), self.startTagRawtext),
                ("select", self.startTagSelect),
                (("rp", "rt"), self.startTagRpRt),
                (("option", "optgroup"), self.startTagOpt),
                (("math"), self.startTagMath),
                (("svg"), self.startTagSvg),
                (("caption", "col", "colgroup", "frame", "head",
                  "tbody", "td", "tfoot", "th", "thead",
                  "tr"), self.startTagMisplaced)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("body", self.endTagBody),
                ("html", self.endTagHtml),
                (("address", "article", "aside", "blockquote", "button", "center",
                  "details", "dialog", "dir", "div", "dl", "fieldset", "figcaption", "figure",
                  "footer", "header", "hgroup", "listing", "main", "menu", "nav", "ol", "pre",
                  "section", "summary", "ul"), self.endTagBlock),
                ("form", self.endTagForm),
                ("p", self.endTagP),
                (("dd", "dt", "li"), self.endTagListItem),
                (headingElements, self.endTagHeading),
                (("a", "b", "big", "code", "em", "font", "i", "nobr", "s", "small",
                  "strike", "strong", "tt", "u"), self.endTagFormatting),
                (("applet", "marquee", "object"), self.endTagAppletMarqueeObject),
                ("br", self.endTagBr),
            ])
            self.endTagHandler.default = self.endTagOther

        def isMatchingFormattingElement(self, node1, node2):
            if node1.name != node2.name or node1.namespace != node2.namespace:
                return False
            elif len(node1.attributes) != len(node2.attributes):
                return False
            else:
                attributes1 = sorted(node1.attributes.items())
                attributes2 = sorted(node2.attributes.items())
                for attr1, attr2 in zip(attributes1, attributes2):
                    if attr1 != attr2:
                        return False
            return True

        # helper
        def addFormattingElement(self, token):
            self.tree.insertElement(token)
            element = self.tree.openElements[-1]

            matchingElements = []
            for node in self.tree.activeFormattingElements[::-1]:
                if node is Marker:
                    break
                elif self.isMatchingFormattingElement(node, element):
                    matchingElements.append(node)

            assert len(matchingElements) <= 3
            if len(matchingElements) == 3:
                self.tree.activeFormattingElements.remove(matchingElements[-1])
            self.tree.activeFormattingElements.append(element)

        # the real deal
        def processEOF(self):
            allowed_elements = frozenset(("dd", "dt", "li", "p", "tbody", "td",
                                          "tfoot", "th", "thead", "tr", "body",
                                          "html"))
            for node in self.tree.openElements[::-1]:
                if node.name not in allowed_elements:
                    self.parser.parseError("expected-closing-tag-but-got-eof")
                    break
            # Stop parsing

        def processSpaceCharactersDropNewline(self, token):
            # Sometimes (start of <pre>, <listing>, and <textarea> blocks) we
            # want to drop leading newlines
            data = token["data"]
            self.processSpaceCharacters = self.processSpaceCharactersNonPre
            if (data.startswith("\n") and
                self.tree.openElements[-1].name in ("pre", "listing", "textarea")
                    and not self.tree.openElements[-1].hasContent()):
                data = data[1:]
            if data:
                self.tree.reconstructActiveFormattingElements()
                self.tree.insertText(data)

        def processCharacters(self, token):
            if token["data"] == "\u0000":
                # The tokenizer should always emit null on its own
                return
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertText(token["data"])
            # This must be bad for performance
            if (self.parser.framesetOK and
                any([char not in spaceCharacters
                     for char in token["data"]])):
                self.parser.framesetOK = False

        def processSpaceCharacters(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertText(token["data"])

        def startTagProcessInHead(self, token):
            return self.parser.phases["inHead"].processStartTag(token)

        def startTagBody(self, token):
            self.parser.parseError("unexpected-start-tag", {"name": "body"})
            if (len(self.tree.openElements) == 1
                    or self.tree.openElements[1].name != "body"):
                assert self.parser.innerHTML
            else:
                self.parser.framesetOK = False
                for attr, value in token["data"].items():
                    if attr not in self.tree.openElements[1].attributes:
                        self.tree.openElements[1].attributes[attr] = value

        def startTagFrameset(self, token):
            self.parser.parseError("unexpected-start-tag", {"name": "frameset"})
            if (len(self.tree.openElements) == 1 or self.tree.openElements[1].name != "body"):
                assert self.parser.innerHTML
            elif not self.parser.framesetOK:
                pass
            else:
                if self.tree.openElements[1].parent:
                    self.tree.openElements[1].parent.removeChild(self.tree.openElements[1])
                while self.tree.openElements[-1].name != "html":
                    self.tree.openElements.pop()
                self.tree.insertElement(token)
                self.parser.phase = self.parser.phases["inFrameset"]

        def startTagCloseP(self, token):
            if self.tree.elementInScope("p", variant="button"):
                self.endTagP(impliedTagToken("p"))
            self.tree.insertElement(token)

        def startTagPreListing(self, token):
            if self.tree.elementInScope("p", variant="button"):
                self.endTagP(impliedTagToken("p"))
            self.tree.insertElement(token)
            self.parser.framesetOK = False
            self.processSpaceCharacters = self.processSpaceCharactersDropNewline

        def startTagForm(self, token):
            if self.tree.formPointer:
                self.parser.parseError("unexpected-start-tag", {"name": "form"})
            else:
                if self.tree.elementInScope("p", variant="button"):
                    self.endTagP(impliedTagToken("p"))
                self.tree.insertElement(token)
                self.tree.formPointer = self.tree.openElements[-1]

        def startTagListItem(self, token):
            self.parser.framesetOK = False

            stopNamesMap = {"li": ["li"],
                            "dt": ["dt", "dd"],
                            "dd": ["dt", "dd"]}
            stopNames = stopNamesMap[token["name"]]
            for node in reversed(self.tree.openElements):
                if node.name in stopNames:
                    self.parser.phase.processEndTag(
                        impliedTagToken(node.name, "EndTag"))
                    break
                if (node.nameTuple in specialElements and
                        node.name not in ("address", "div", "p")):
                    break

            if self.tree.elementInScope("p", variant="button"):
                self.parser.phase.processEndTag(
                    impliedTagToken("p", "EndTag"))

            self.tree.insertElement(token)

        def startTagPlaintext(self, token):
            if self.tree.elementInScope("p", variant="button"):
                self.endTagP(impliedTagToken("p"))
            self.tree.insertElement(token)
            self.parser.tokenizer.state = self.parser.tokenizer.plaintextState

        def startTagHeading(self, token):
            if self.tree.elementInScope("p", variant="button"):
                self.endTagP(impliedTagToken("p"))
            if self.tree.openElements[-1].name in headingElements:
                self.parser.parseError("unexpected-start-tag", {"name": token["name"]})
                self.tree.openElements.pop()
            self.tree.insertElement(token)

        def startTagA(self, token):
            afeAElement = self.tree.elementInActiveFormattingElements("a")
            if afeAElement:
                self.parser.parseError("unexpected-start-tag-implies-end-tag",
                                       {"startName": "a", "endName": "a"})
                self.endTagFormatting(impliedTagToken("a"))
                if afeAElement in self.tree.openElements:
                    self.tree.openElements.remove(afeAElement)
                if afeAElement in self.tree.activeFormattingElements:
                    self.tree.activeFormattingElements.remove(afeAElement)
            self.tree.reconstructActiveFormattingElements()
            self.addFormattingElement(token)

        def startTagFormatting(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.addFormattingElement(token)

        def startTagNobr(self, token):
            self.tree.reconstructActiveFormattingElements()
            if self.tree.elementInScope("nobr"):
                self.parser.parseError("unexpected-start-tag-implies-end-tag",
                                       {"startName": "nobr", "endName": "nobr"})
                self.processEndTag(impliedTagToken("nobr"))
                # XXX Need tests that trigger the following
                self.tree.reconstructActiveFormattingElements()
            self.addFormattingElement(token)

        def startTagButton(self, token):
            if self.tree.elementInScope("button"):
                self.parser.parseError("unexpected-start-tag-implies-end-tag",
                                       {"startName": "button", "endName": "button"})
                self.processEndTag(impliedTagToken("button"))
                return token
            else:
                self.tree.reconstructActiveFormattingElements()
                self.tree.insertElement(token)
                self.parser.framesetOK = False

        def startTagAppletMarqueeObject(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertElement(token)
            self.tree.activeFormattingElements.append(Marker)
            self.parser.framesetOK = False

        def startTagXmp(self, token):
            if self.tree.elementInScope("p", variant="button"):
                self.endTagP(impliedTagToken("p"))
            self.tree.reconstructActiveFormattingElements()
            self.parser.framesetOK = False
            self.parser.parseRCDataRawtext(token, "RAWTEXT")

        def startTagTable(self, token):
            if self.parser.compatMode != "quirks":
                if self.tree.elementInScope("p", variant="button"):
                    self.processEndTag(impliedTagToken("p"))
            self.tree.insertElement(token)
            self.parser.framesetOK = False
            self.parser.phase = self.parser.phases["inTable"]

        def startTagVoidFormatting(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertElement(token)
            self.tree.openElements.pop()
            token["selfClosingAcknowledged"] = True
            self.parser.framesetOK = False

        def startTagInput(self, token):
            framesetOK = self.parser.framesetOK
            self.startTagVoidFormatting(token)
            if ("type" in token["data"] and
                    token["data"]["type"].translate(asciiUpper2Lower) == "hidden"):
                # input type=hidden doesn't change framesetOK
                self.parser.framesetOK = framesetOK

        def startTagParamSource(self, token):
            self.tree.insertElement(token)
            self.tree.openElements.pop()
            token["selfClosingAcknowledged"] = True

        def startTagHr(self, token):
            if self.tree.elementInScope("p", variant="button"):
                self.endTagP(impliedTagToken("p"))
            self.tree.insertElement(token)
            self.tree.openElements.pop()
            token["selfClosingAcknowledged"] = True
            self.parser.framesetOK = False

        def startTagImage(self, token):
            # No really...
            self.parser.parseError("unexpected-start-tag-treated-as",
                                   {"originalName": "image", "newName": "img"})
            self.processStartTag(impliedTagToken("img", "StartTag",
                                                 attributes=token["data"],
                                                 selfClosing=token["selfClosing"]))

        def startTagIsIndex(self, token):
            self.parser.parseError("deprecated-tag", {"name": "isindex"})
            if self.tree.formPointer:
                return
            form_attrs = {}
            if "action" in token["data"]:
                form_attrs["action"] = token["data"]["action"]
            self.processStartTag(impliedTagToken("form", "StartTag",
                                                 attributes=form_attrs))
            self.processStartTag(impliedTagToken("hr", "StartTag"))
            self.processStartTag(impliedTagToken("label", "StartTag"))
            # XXX Localization ...
            if "prompt" in token["data"]:
                prompt = token["data"]["prompt"]
            else:
                prompt = "This is a searchable index. Enter search keywords: "
            self.processCharacters(
                {"type": tokenTypes["Characters"], "data": prompt})
            attributes = token["data"].copy()
            if "action" in attributes:
                del attributes["action"]
            if "prompt" in attributes:
                del attributes["prompt"]
            attributes["name"] = "isindex"
            self.processStartTag(impliedTagToken("input", "StartTag",
                                                 attributes=attributes,
                                                 selfClosing=
                                                 token["selfClosing"]))
            self.processEndTag(impliedTagToken("label"))
            self.processStartTag(impliedTagToken("hr", "StartTag"))
            self.processEndTag(impliedTagToken("form"))

        def startTagTextarea(self, token):
            self.tree.insertElement(token)
            self.parser.tokenizer.state = self.parser.tokenizer.rcdataState
            self.processSpaceCharacters = self.processSpaceCharactersDropNewline
            self.parser.framesetOK = False

        def startTagIFrame(self, token):
            self.parser.framesetOK = False
            self.startTagRawtext(token)

        def startTagRawtext(self, token):
            """iframe, noembed noframes, noscript(if scripting enabled)"""
            self.parser.parseRCDataRawtext(token, "RAWTEXT")

        def startTagOpt(self, token):
            if self.tree.openElements[-1].name == "option":
                self.parser.phase.processEndTag(impliedTagToken("option"))
            self.tree.reconstructActiveFormattingElements()
            self.parser.tree.insertElement(token)

        def startTagSelect(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertElement(token)
            self.parser.framesetOK = False
            if self.parser.phase in (self.parser.phases["inTable"],
                                     self.parser.phases["inCaption"],
                                     self.parser.phases["inColumnGroup"],
                                     self.parser.phases["inTableBody"],
                                     self.parser.phases["inRow"],
                                     self.parser.phases["inCell"]):
                self.parser.phase = self.parser.phases["inSelectInTable"]
            else:
                self.parser.phase = self.parser.phases["inSelect"]

        def startTagRpRt(self, token):
            if self.tree.elementInScope("ruby"):
                self.tree.generateImpliedEndTags()
                if self.tree.openElements[-1].name != "ruby":
                    self.parser.parseError()
            self.tree.insertElement(token)

        def startTagMath(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.parser.adjustMathMLAttributes(token)
            self.parser.adjustForeignAttributes(token)
            token["namespace"] = namespaces["mathml"]
            self.tree.insertElement(token)
            # Need to get the parse error right for the case where the token
            # has a namespace not equal to the xmlns attribute
            if token["selfClosing"]:
                self.tree.openElements.pop()
                token["selfClosingAcknowledged"] = True

        def startTagSvg(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.parser.adjustSVGAttributes(token)
            self.parser.adjustForeignAttributes(token)
            token["namespace"] = namespaces["svg"]
            self.tree.insertElement(token)
            # Need to get the parse error right for the case where the token
            # has a namespace not equal to the xmlns attribute
            if token["selfClosing"]:
                self.tree.openElements.pop()
                token["selfClosingAcknowledged"] = True

        def startTagMisplaced(self, token):
            """ Elements that should be children of other elements that have a
            different insertion mode; here they are ignored
            "caption", "col", "colgroup", "frame", "frameset", "head",
            "option", "optgroup", "tbody", "td", "tfoot", "th", "thead",
            "tr", "noscript"
            """
            self.parser.parseError("unexpected-start-tag-ignored", {"name": token["name"]})

        def startTagOther(self, token):
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertElement(token)

        def endTagP(self, token):
            if not self.tree.elementInScope("p", variant="button"):
                self.startTagCloseP(impliedTagToken("p", "StartTag"))
                self.parser.parseError("unexpected-end-tag", {"name": "p"})
                self.endTagP(impliedTagToken("p", "EndTag"))
            else:
                self.tree.generateImpliedEndTags("p")
                if self.tree.openElements[-1].name != "p":
                    self.parser.parseError("unexpected-end-tag", {"name": "p"})
                node = self.tree.openElements.pop()
                while node.name != "p":
                    node = self.tree.openElements.pop()

        def endTagBody(self, token):
            if not self.tree.elementInScope("body"):
                self.parser.parseError()
                return
            elif self.tree.openElements[-1].name != "body":
                for node in self.tree.openElements[2:]:
                    if node.name not in frozenset(("dd", "dt", "li", "optgroup",
                                                   "option", "p", "rp", "rt",
                                                   "tbody", "td", "tfoot",
                                                   "th", "thead", "tr", "body",
                                                   "html")):
                        # Not sure this is the correct name for the parse error
                        self.parser.parseError(
                            "expected-one-end-tag-but-got-another",
                            {"expectedName": "body", "gotName": node.name})
                        break
            self.parser.phase = self.parser.phases["afterBody"]

        def endTagHtml(self, token):
            # We repeat the test for the body end tag token being ignored here
            if self.tree.elementInScope("body"):
                self.endTagBody(impliedTagToken("body"))
                return token

        def endTagBlock(self, token):
            # Put us back in the right whitespace handling mode
            if token["name"] == "pre":
                self.processSpaceCharacters = self.processSpaceCharactersNonPre
            inScope = self.tree.elementInScope(token["name"])
            if inScope:
                self.tree.generateImpliedEndTags()
            if self.tree.openElements[-1].name != token["name"]:
                self.parser.parseError("end-tag-too-early", {"name": token["name"]})
            if inScope:
                node = self.tree.openElements.pop()
                while node.name != token["name"]:
                    node = self.tree.openElements.pop()

        def endTagForm(self, token):
            node = self.tree.formPointer
            self.tree.formPointer = None
            if node is None or not self.tree.elementInScope(node):
                self.parser.parseError("unexpected-end-tag",
                                       {"name": "form"})
            else:
                self.tree.generateImpliedEndTags()
                if self.tree.openElements[-1] != node:
                    self.parser.parseError("end-tag-too-early-ignored",
                                           {"name": "form"})
                self.tree.openElements.remove(node)

        def endTagListItem(self, token):
            if token["name"] == "li":
                variant = "list"
            else:
                variant = None
            if not self.tree.elementInScope(token["name"], variant=variant):
                self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
            else:
                self.tree.generateImpliedEndTags(exclude=token["name"])
                if self.tree.openElements[-1].name != token["name"]:
                    self.parser.parseError(
                        "end-tag-too-early",
                        {"name": token["name"]})
                node = self.tree.openElements.pop()
                while node.name != token["name"]:
                    node = self.tree.openElements.pop()

        def endTagHeading(self, token):
            for item in headingElements:
                if self.tree.elementInScope(item):
                    self.tree.generateImpliedEndTags()
                    break
            if self.tree.openElements[-1].name != token["name"]:
                self.parser.parseError("end-tag-too-early", {"name": token["name"]})

            for item in headingElements:
                if self.tree.elementInScope(item):
                    item = self.tree.openElements.pop()
                    while item.name not in headingElements:
                        item = self.tree.openElements.pop()
                    break

        def endTagFormatting(self, token):
            """The much-feared adoption agency algorithm"""
            # http://svn.whatwg.org/webapps/complete.html#adoptionAgency revision 7867
            # XXX Better parseError messages appreciated.

            # Step 1
            outerLoopCounter = 0

            # Step 2
            while outerLoopCounter < 8:

                # Step 3
                outerLoopCounter += 1

                # Step 4:

                # Let the formatting element be the last element in
                # the list of active formatting elements that:
                # - is between the end of the list and the last scope
                # marker in the list, if any, or the start of the list
                # otherwise, and
                # - has the same tag name as the token.
                formattingElement = self.tree.elementInActiveFormattingElements(
                    token["name"])
                if (not formattingElement or
                    (formattingElement in self.tree.openElements and
                     not self.tree.elementInScope(formattingElement.name))):
                    # If there is no such node, then abort these steps
                    # and instead act as described in the "any other
                    # end tag" entry below.
                    self.endTagOther(token)
                    return

                # Otherwise, if there is such a node, but that node is
                # not in the stack of open elements, then this is a
                # parse error; remove the element from the list, and
                # abort these steps.
                elif formattingElement not in self.tree.openElements:
                    self.parser.parseError("adoption-agency-1.2", {"name": token["name"]})
                    self.tree.activeFormattingElements.remove(formattingElement)
                    return

                # Otherwise, if there is such a node, and that node is
                # also in the stack of open elements, but the element
                # is not in scope, then this is a parse error; ignore
                # the token, and abort these steps.
                elif not self.tree.elementInScope(formattingElement.name):
                    self.parser.parseError("adoption-agency-4.4", {"name": token["name"]})
                    return

                # Otherwise, there is a formatting element and that
                # element is in the stack and is in scope. If the
                # element is not the current node, this is a parse
                # error. In any case, proceed with the algorithm as
                # written in the following steps.
                else:
                    if formattingElement != self.tree.openElements[-1]:
                        self.parser.parseError("adoption-agency-1.3", {"name": token["name"]})

                # Step 5:

                # Let the furthest block be the topmost node in the
                # stack of open elements that is lower in the stack
                # than the formatting element, and is an element in
                # the special category. There might not be one.
                afeIndex = self.tree.openElements.index(formattingElement)
                furthestBlock = None
                for element in self.tree.openElements[afeIndex:]:
                    if element.nameTuple in specialElements:
                        furthestBlock = element
                        break

                # Step 6:

                # If there is no furthest block, then the UA must
                # first pop all the nodes from the bottom of the stack
                # of open elements, from the current node up to and
                # including the formatting element, then remove the
                # formatting element from the list of active
                # formatting elements, and finally abort these steps.
                if furthestBlock is None:
                    element = self.tree.openElements.pop()
                    while element != formattingElement:
                        element = self.tree.openElements.pop()
                    self.tree.activeFormattingElements.remove(element)
                    return

                # Step 7
                commonAncestor = self.tree.openElements[afeIndex - 1]

                # Step 8:
                # The bookmark is supposed to help us identify where to reinsert
                # nodes in step 15. We have to ensure that we reinsert nodes after
                # the node before the active formatting element. Note the bookmark
                # can move in step 9.7
                bookmark = self.tree.activeFormattingElements.index(formattingElement)

                # Step 9
                lastNode = node = furthestBlock
                innerLoopCounter = 0

                index = self.tree.openElements.index(node)
                while innerLoopCounter < 3:
                    innerLoopCounter += 1
                    # Node is element before node in open elements
                    index -= 1
                    node = self.tree.openElements[index]
                    if node not in self.tree.activeFormattingElements:
                        self.tree.openElements.remove(node)
                        continue
                    # Step 9.6
                    if node == formattingElement:
                        break
                    # Step 9.7
                    if lastNode == furthestBlock:
                        bookmark = self.tree.activeFormattingElements.index(node) + 1
                    # Step 9.8
                    clone = node.cloneNode()
                    # Replace node with clone
                    self.tree.activeFormattingElements[
                        self.tree.activeFormattingElements.index(node)] = clone
                    self.tree.openElements[
                        self.tree.openElements.index(node)] = clone
                    node = clone
                    # Step 9.9
                    # Remove lastNode from its parents, if any
                    if lastNode.parent:
                        lastNode.parent.removeChild(lastNode)
                    node.appendChild(lastNode)
                    # Step 9.10
                    lastNode = node

                # Step 10
                # Foster parent lastNode if commonAncestor is a
                # table, tbody, tfoot, thead, or tr we need to foster
                # parent the lastNode
                if lastNode.parent:
                    lastNode.parent.removeChild(lastNode)

                if commonAncestor.name in frozenset(("table", "tbody", "tfoot", "thead", "tr")):
                    parent, insertBefore = self.tree.getTableMisnestedNodePosition()
                    parent.insertBefore(lastNode, insertBefore)
                else:
                    commonAncestor.appendChild(lastNode)

                # Step 11
                clone = formattingElement.cloneNode()

                # Step 12
                furthestBlock.reparentChildren(clone)

                # Step 13
                furthestBlock.appendChild(clone)

                # Step 14
                self.tree.activeFormattingElements.remove(formattingElement)
                self.tree.activeFormattingElements.insert(bookmark, clone)

                # Step 15
                self.tree.openElements.remove(formattingElement)
                self.tree.openElements.insert(
                    self.tree.openElements.index(furthestBlock) + 1, clone)

        def endTagAppletMarqueeObject(self, token):
            if self.tree.elementInScope(token["name"]):
                self.tree.generateImpliedEndTags()
            if self.tree.openElements[-1].name != token["name"]:
                self.parser.parseError("end-tag-too-early", {"name": token["name"]})

            if self.tree.elementInScope(token["name"]):
                element = self.tree.openElements.pop()
                while element.name != token["name"]:
                    element = self.tree.openElements.pop()
                self.tree.clearActiveFormattingElements()

        def endTagBr(self, token):
            self.parser.parseError("unexpected-end-tag-treated-as",
                                   {"originalName": "br", "newName": "br element"})
            self.tree.reconstructActiveFormattingElements()
            self.tree.insertElement(impliedTagToken("br", "StartTag"))
            self.tree.openElements.pop()

        def endTagOther(self, token):
            for node in self.tree.openElements[::-1]:
                if node.name == token["name"]:
                    self.tree.generateImpliedEndTags(exclude=token["name"])
                    if self.tree.openElements[-1].name != token["name"]:
                        self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
                    while self.tree.openElements.pop() != node:
                        pass
                    break
                else:
                    if node.nameTuple in specialElements:
                        self.parser.parseError("unexpected-end-tag", {"name": token["name"]})
                        break

    class TextPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)
            self.startTagHandler = utils.MethodDispatcher([])
            self.startTagHandler.default = self.startTagOther
            self.endTagHandler = utils.MethodDispatcher([
                ("script", self.endTagScript)])
            self.endTagHandler.default = self.endTagOther

        def processCharacters(self, token):
            self.tree.insertText(token["data"])

        def processEOF(self):
            self.parser.parseError("expected-named-closing-tag-but-got-eof",
                                   {"name": self.tree.openElements[-1].name})
            self.tree.openElements.pop()
            self.parser.phase = self.parser.originalPhase
            return True

        def startTagOther(self, token):
            assert False, "Tried to process start tag %s in RCDATA/RAWTEXT mode" % token['name']

        def endTagScript(self, token):
            node = self.tree.openElements.pop()
            assert node.name == "script"
            self.parser.phase = self.parser.originalPhase
            # The rest of this method is all stuff that only happens if
            # document.write works

        def endTagOther(self, token):
            self.tree.openElements.pop()
            self.parser.phase = self.parser.originalPhase

    class InTablePhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-table
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)
            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("caption", self.startTagCaption),
                ("colgroup", self.startTagColgroup),
                ("col", self.startTagCol),
                (("tbody", "tfoot", "thead"), self.startTagRowGroup),
                (("td", "th", "tr"), self.startTagImplyTbody),
                ("table", self.startTagTable),
                (("style", "script"), self.startTagStyleScript),
                ("input", self.startTagInput),
                ("form", self.startTagForm)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("table", self.endTagTable),
                (("body", "caption", "col", "colgroup", "html", "tbody", "td",
                  "tfoot", "th", "thead", "tr"), self.endTagIgnore)
            ])
            self.endTagHandler.default = self.endTagOther

        # helper methods
        def clearStackToTableContext(self):
            # "clear the stack back to a table context"
            while self.tree.openElements[-1].name not in ("table", "html"):
                # self.parser.parseError("unexpected-implied-end-tag-in-table",
                #  {"name":  self.tree.openElements[-1].name})
                self.tree.openElements.pop()
            # When the current node is <html> it's an innerHTML case

        # processing methods
        def processEOF(self):
            if self.tree.openElements[-1].name != "html":
                self.parser.parseError("eof-in-table")
            else:
                assert self.parser.innerHTML
            # Stop parsing

        def processSpaceCharacters(self, token):
            originalPhase = self.parser.phase
            self.parser.phase = self.parser.phases["inTableText"]
            self.parser.phase.originalPhase = originalPhase
            self.parser.phase.processSpaceCharacters(token)

        def processCharacters(self, token):
            originalPhase = self.parser.phase
            self.parser.phase = self.parser.phases["inTableText"]
            self.parser.phase.originalPhase = originalPhase
            self.parser.phase.processCharacters(token)

        def insertText(self, token):
            # If we get here there must be at least one non-whitespace character
            # Do the table magic!
            self.tree.insertFromTable = True
            self.parser.phases["inBody"].processCharacters(token)
            self.tree.insertFromTable = False

        def startTagCaption(self, token):
            self.clearStackToTableContext()
            self.tree.activeFormattingElements.append(Marker)
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inCaption"]

        def startTagColgroup(self, token):
            self.clearStackToTableContext()
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inColumnGroup"]

        def startTagCol(self, token):
            self.startTagColgroup(impliedTagToken("colgroup", "StartTag"))
            return token

        def startTagRowGroup(self, token):
            self.clearStackToTableContext()
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inTableBody"]

        def startTagImplyTbody(self, token):
            self.startTagRowGroup(impliedTagToken("tbody", "StartTag"))
            return token

        def startTagTable(self, token):
            self.parser.parseError("unexpected-start-tag-implies-end-tag",
                                   {"startName": "table", "endName": "table"})
            self.parser.phase.processEndTag(impliedTagToken("table"))
            if not self.parser.innerHTML:
                return token

        def startTagStyleScript(self, token):
            return self.parser.phases["inHead"].processStartTag(token)

        def startTagInput(self, token):
            if ("type" in token["data"] and
                    token["data"]["type"].translate(asciiUpper2Lower) == "hidden"):
                self.parser.parseError("unexpected-hidden-input-in-table")
                self.tree.insertElement(token)
                # XXX associate with form
                self.tree.openElements.pop()
            else:
                self.startTagOther(token)

        def startTagForm(self, token):
            self.parser.parseError("unexpected-form-in-table")
            if self.tree.formPointer is None:
                self.tree.insertElement(token)
                self.tree.formPointer = self.tree.openElements[-1]
                self.tree.openElements.pop()

        def startTagOther(self, token):
            self.parser.parseError("unexpected-start-tag-implies-table-voodoo", {"name": token["name"]})
            # Do the table magic!
            self.tree.insertFromTable = True
            self.parser.phases["inBody"].processStartTag(token)
            self.tree.insertFromTable = False

        def endTagTable(self, token):
            if self.tree.elementInScope("table", variant="table"):
                self.tree.generateImpliedEndTags()
                if self.tree.openElements[-1].name != "table":
                    self.parser.parseError("end-tag-too-early-named",
                                           {"gotName": "table",
                                            "expectedName": self.tree.openElements[-1].name})
                while self.tree.openElements[-1].name != "table":
                    self.tree.openElements.pop()
                self.tree.openElements.pop()
                self.parser.resetInsertionMode()
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def endTagIgnore(self, token):
            self.parser.parseError("unexpected-end-tag", {"name": token["name"]})

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag-implies-table-voodoo", {"name": token["name"]})
            # Do the table magic!
            self.tree.insertFromTable = True
            self.parser.phases["inBody"].processEndTag(token)
            self.tree.insertFromTable = False

    class InTableTextPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)
            self.originalPhase = None
            self.characterTokens = []

        def flushCharacters(self):
            data = "".join([item["data"] for item in self.characterTokens])
            if any([item not in spaceCharacters for item in data]):
                token = {"type": tokenTypes["Characters"], "data": data}
                self.parser.phases["inTable"].insertText(token)
            elif data:
                self.tree.insertText(data)
            self.characterTokens = []

        def processComment(self, token):
            self.flushCharacters()
            self.parser.phase = self.originalPhase
            return token

        def processEOF(self):
            self.flushCharacters()
            self.parser.phase = self.originalPhase
            return True

        def processCharacters(self, token):
            if token["data"] == "\u0000":
                return
            self.characterTokens.append(token)

        def processSpaceCharacters(self, token):
            # pretty sure we should never reach here
            self.characterTokens.append(token)
    #        assert False

        def processStartTag(self, token):
            self.flushCharacters()
            self.parser.phase = self.originalPhase
            return token

        def processEndTag(self, token):
            self.flushCharacters()
            self.parser.phase = self.originalPhase
            return token

    class InCaptionPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-caption
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                (("caption", "col", "colgroup", "tbody", "td", "tfoot", "th",
                  "thead", "tr"), self.startTagTableElement)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("caption", self.endTagCaption),
                ("table", self.endTagTable),
                (("body", "col", "colgroup", "html", "tbody", "td", "tfoot", "th",
                  "thead", "tr"), self.endTagIgnore)
            ])
            self.endTagHandler.default = self.endTagOther

        def ignoreEndTagCaption(self):
            return not self.tree.elementInScope("caption", variant="table")

        def processEOF(self):
            self.parser.phases["inBody"].processEOF()

        def processCharacters(self, token):
            return self.parser.phases["inBody"].processCharacters(token)

        def startTagTableElement(self, token):
            self.parser.parseError()
            # XXX Have to duplicate logic here to find out if the tag is ignored
            ignoreEndTag = self.ignoreEndTagCaption()
            self.parser.phase.processEndTag(impliedTagToken("caption"))
            if not ignoreEndTag:
                return token

        def startTagOther(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def endTagCaption(self, token):
            if not self.ignoreEndTagCaption():
                # AT this code is quite similar to endTagTable in "InTable"
                self.tree.generateImpliedEndTags()
                if self.tree.openElements[-1].name != "caption":
                    self.parser.parseError("expected-one-end-tag-but-got-another",
                                           {"gotName": "caption",
                                            "expectedName": self.tree.openElements[-1].name})
                while self.tree.openElements[-1].name != "caption":
                    self.tree.openElements.pop()
                self.tree.openElements.pop()
                self.tree.clearActiveFormattingElements()
                self.parser.phase = self.parser.phases["inTable"]
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def endTagTable(self, token):
            self.parser.parseError()
            ignoreEndTag = self.ignoreEndTagCaption()
            self.parser.phase.processEndTag(impliedTagToken("caption"))
            if not ignoreEndTag:
                return token

        def endTagIgnore(self, token):
            self.parser.parseError("unexpected-end-tag", {"name": token["name"]})

        def endTagOther(self, token):
            return self.parser.phases["inBody"].processEndTag(token)

    class InColumnGroupPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-column

        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("col", self.startTagCol)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("colgroup", self.endTagColgroup),
                ("col", self.endTagCol)
            ])
            self.endTagHandler.default = self.endTagOther

        def ignoreEndTagColgroup(self):
            return self.tree.openElements[-1].name == "html"

        def processEOF(self):
            if self.tree.openElements[-1].name == "html":
                assert self.parser.innerHTML
                return
            else:
                ignoreEndTag = self.ignoreEndTagColgroup()
                self.endTagColgroup(impliedTagToken("colgroup"))
                if not ignoreEndTag:
                    return True

        def processCharacters(self, token):
            ignoreEndTag = self.ignoreEndTagColgroup()
            self.endTagColgroup(impliedTagToken("colgroup"))
            if not ignoreEndTag:
                return token

        def startTagCol(self, token):
            self.tree.insertElement(token)
            self.tree.openElements.pop()

        def startTagOther(self, token):
            ignoreEndTag = self.ignoreEndTagColgroup()
            self.endTagColgroup(impliedTagToken("colgroup"))
            if not ignoreEndTag:
                return token

        def endTagColgroup(self, token):
            if self.ignoreEndTagColgroup():
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()
            else:
                self.tree.openElements.pop()
                self.parser.phase = self.parser.phases["inTable"]

        def endTagCol(self, token):
            self.parser.parseError("no-end-tag", {"name": "col"})

        def endTagOther(self, token):
            ignoreEndTag = self.ignoreEndTagColgroup()
            self.endTagColgroup(impliedTagToken("colgroup"))
            if not ignoreEndTag:
                return token

    class InTableBodyPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-table0
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)
            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("tr", self.startTagTr),
                (("td", "th"), self.startTagTableCell),
                (("caption", "col", "colgroup", "tbody", "tfoot", "thead"),
                 self.startTagTableOther)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                (("tbody", "tfoot", "thead"), self.endTagTableRowGroup),
                ("table", self.endTagTable),
                (("body", "caption", "col", "colgroup", "html", "td", "th",
                  "tr"), self.endTagIgnore)
            ])
            self.endTagHandler.default = self.endTagOther

        # helper methods
        def clearStackToTableBodyContext(self):
            while self.tree.openElements[-1].name not in ("tbody", "tfoot",
                                                          "thead", "html"):
                # self.parser.parseError("unexpected-implied-end-tag-in-table",
                #  {"name": self.tree.openElements[-1].name})
                self.tree.openElements.pop()
            if self.tree.openElements[-1].name == "html":
                assert self.parser.innerHTML

        # the rest
        def processEOF(self):
            self.parser.phases["inTable"].processEOF()

        def processSpaceCharacters(self, token):
            return self.parser.phases["inTable"].processSpaceCharacters(token)

        def processCharacters(self, token):
            return self.parser.phases["inTable"].processCharacters(token)

        def startTagTr(self, token):
            self.clearStackToTableBodyContext()
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inRow"]

        def startTagTableCell(self, token):
            self.parser.parseError("unexpected-cell-in-table-body",
                                   {"name": token["name"]})
            self.startTagTr(impliedTagToken("tr", "StartTag"))
            return token

        def startTagTableOther(self, token):
            # XXX AT Any ideas on how to share this with endTagTable?
            if (self.tree.elementInScope("tbody", variant="table") or
                self.tree.elementInScope("thead", variant="table") or
                    self.tree.elementInScope("tfoot", variant="table")):
                self.clearStackToTableBodyContext()
                self.endTagTableRowGroup(
                    impliedTagToken(self.tree.openElements[-1].name))
                return token
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def startTagOther(self, token):
            return self.parser.phases["inTable"].processStartTag(token)

        def endTagTableRowGroup(self, token):
            if self.tree.elementInScope(token["name"], variant="table"):
                self.clearStackToTableBodyContext()
                self.tree.openElements.pop()
                self.parser.phase = self.parser.phases["inTable"]
            else:
                self.parser.parseError("unexpected-end-tag-in-table-body",
                                       {"name": token["name"]})

        def endTagTable(self, token):
            if (self.tree.elementInScope("tbody", variant="table") or
                self.tree.elementInScope("thead", variant="table") or
                    self.tree.elementInScope("tfoot", variant="table")):
                self.clearStackToTableBodyContext()
                self.endTagTableRowGroup(
                    impliedTagToken(self.tree.openElements[-1].name))
                return token
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def endTagIgnore(self, token):
            self.parser.parseError("unexpected-end-tag-in-table-body",
                                   {"name": token["name"]})

        def endTagOther(self, token):
            return self.parser.phases["inTable"].processEndTag(token)

    class InRowPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-row
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)
            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                (("td", "th"), self.startTagTableCell),
                (("caption", "col", "colgroup", "tbody", "tfoot", "thead",
                  "tr"), self.startTagTableOther)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("tr", self.endTagTr),
                ("table", self.endTagTable),
                (("tbody", "tfoot", "thead"), self.endTagTableRowGroup),
                (("body", "caption", "col", "colgroup", "html", "td", "th"),
                 self.endTagIgnore)
            ])
            self.endTagHandler.default = self.endTagOther

        # helper methods (XXX unify this with other table helper methods)
        def clearStackToTableRowContext(self):
            while self.tree.openElements[-1].name not in ("tr", "html"):
                self.parser.parseError("unexpected-implied-end-tag-in-table-row",
                                       {"name": self.tree.openElements[-1].name})
                self.tree.openElements.pop()

        def ignoreEndTagTr(self):
            return not self.tree.elementInScope("tr", variant="table")

        # the rest
        def processEOF(self):
            self.parser.phases["inTable"].processEOF()

        def processSpaceCharacters(self, token):
            return self.parser.phases["inTable"].processSpaceCharacters(token)

        def processCharacters(self, token):
            return self.parser.phases["inTable"].processCharacters(token)

        def startTagTableCell(self, token):
            self.clearStackToTableRowContext()
            self.tree.insertElement(token)
            self.parser.phase = self.parser.phases["inCell"]
            self.tree.activeFormattingElements.append(Marker)

        def startTagTableOther(self, token):
            ignoreEndTag = self.ignoreEndTagTr()
            self.endTagTr(impliedTagToken("tr"))
            # XXX how are we sure it's always ignored in the innerHTML case?
            if not ignoreEndTag:
                return token

        def startTagOther(self, token):
            return self.parser.phases["inTable"].processStartTag(token)

        def endTagTr(self, token):
            if not self.ignoreEndTagTr():
                self.clearStackToTableRowContext()
                self.tree.openElements.pop()
                self.parser.phase = self.parser.phases["inTableBody"]
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def endTagTable(self, token):
            ignoreEndTag = self.ignoreEndTagTr()
            self.endTagTr(impliedTagToken("tr"))
            # Reprocess the current tag if the tr end tag was not ignored
            # XXX how are we sure it's always ignored in the innerHTML case?
            if not ignoreEndTag:
                return token

        def endTagTableRowGroup(self, token):
            if self.tree.elementInScope(token["name"], variant="table"):
                self.endTagTr(impliedTagToken("tr"))
                return token
            else:
                self.parser.parseError()

        def endTagIgnore(self, token):
            self.parser.parseError("unexpected-end-tag-in-table-row",
                                   {"name": token["name"]})

        def endTagOther(self, token):
            return self.parser.phases["inTable"].processEndTag(token)

    class InCellPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-cell
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)
            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                (("caption", "col", "colgroup", "tbody", "td", "tfoot", "th",
                  "thead", "tr"), self.startTagTableOther)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                (("td", "th"), self.endTagTableCell),
                (("body", "caption", "col", "colgroup", "html"), self.endTagIgnore),
                (("table", "tbody", "tfoot", "thead", "tr"), self.endTagImply)
            ])
            self.endTagHandler.default = self.endTagOther

        # helper
        def closeCell(self):
            if self.tree.elementInScope("td", variant="table"):
                self.endTagTableCell(impliedTagToken("td"))
            elif self.tree.elementInScope("th", variant="table"):
                self.endTagTableCell(impliedTagToken("th"))

        # the rest
        def processEOF(self):
            self.parser.phases["inBody"].processEOF()

        def processCharacters(self, token):
            return self.parser.phases["inBody"].processCharacters(token)

        def startTagTableOther(self, token):
            if (self.tree.elementInScope("td", variant="table") or
                    self.tree.elementInScope("th", variant="table")):
                self.closeCell()
                return token
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def startTagOther(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def endTagTableCell(self, token):
            if self.tree.elementInScope(token["name"], variant="table"):
                self.tree.generateImpliedEndTags(token["name"])
                if self.tree.openElements[-1].name != token["name"]:
                    self.parser.parseError("unexpected-cell-end-tag",
                                           {"name": token["name"]})
                    while True:
                        node = self.tree.openElements.pop()
                        if node.name == token["name"]:
                            break
                else:
                    self.tree.openElements.pop()
                self.tree.clearActiveFormattingElements()
                self.parser.phase = self.parser.phases["inRow"]
            else:
                self.parser.parseError("unexpected-end-tag", {"name": token["name"]})

        def endTagIgnore(self, token):
            self.parser.parseError("unexpected-end-tag", {"name": token["name"]})

        def endTagImply(self, token):
            if self.tree.elementInScope(token["name"], variant="table"):
                self.closeCell()
                return token
            else:
                # sometimes innerHTML case
                self.parser.parseError()

        def endTagOther(self, token):
            return self.parser.phases["inBody"].processEndTag(token)

    class InSelectPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("option", self.startTagOption),
                ("optgroup", self.startTagOptgroup),
                ("select", self.startTagSelect),
                (("input", "keygen", "textarea"), self.startTagInput),
                ("script", self.startTagScript)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("option", self.endTagOption),
                ("optgroup", self.endTagOptgroup),
                ("select", self.endTagSelect)
            ])
            self.endTagHandler.default = self.endTagOther

        # http://www.whatwg.org/specs/web-apps/current-work/#in-select
        def processEOF(self):
            if self.tree.openElements[-1].name != "html":
                self.parser.parseError("eof-in-select")
            else:
                assert self.parser.innerHTML

        def processCharacters(self, token):
            if token["data"] == "\u0000":
                return
            self.tree.insertText(token["data"])

        def startTagOption(self, token):
            # We need to imply </option> if <option> is the current node.
            if self.tree.openElements[-1].name == "option":
                self.tree.openElements.pop()
            self.tree.insertElement(token)

        def startTagOptgroup(self, token):
            if self.tree.openElements[-1].name == "option":
                self.tree.openElements.pop()
            if self.tree.openElements[-1].name == "optgroup":
                self.tree.openElements.pop()
            self.tree.insertElement(token)

        def startTagSelect(self, token):
            self.parser.parseError("unexpected-select-in-select")
            self.endTagSelect(impliedTagToken("select"))

        def startTagInput(self, token):
            self.parser.parseError("unexpected-input-in-select")
            if self.tree.elementInScope("select", variant="select"):
                self.endTagSelect(impliedTagToken("select"))
                return token
            else:
                assert self.parser.innerHTML

        def startTagScript(self, token):
            return self.parser.phases["inHead"].processStartTag(token)

        def startTagOther(self, token):
            self.parser.parseError("unexpected-start-tag-in-select",
                                   {"name": token["name"]})

        def endTagOption(self, token):
            if self.tree.openElements[-1].name == "option":
                self.tree.openElements.pop()
            else:
                self.parser.parseError("unexpected-end-tag-in-select",
                                       {"name": "option"})

        def endTagOptgroup(self, token):
            # </optgroup> implicitly closes <option>
            if (self.tree.openElements[-1].name == "option" and
                    self.tree.openElements[-2].name == "optgroup"):
                self.tree.openElements.pop()
            # It also closes </optgroup>
            if self.tree.openElements[-1].name == "optgroup":
                self.tree.openElements.pop()
            # But nothing else
            else:
                self.parser.parseError("unexpected-end-tag-in-select",
                                       {"name": "optgroup"})

        def endTagSelect(self, token):
            if self.tree.elementInScope("select", variant="select"):
                node = self.tree.openElements.pop()
                while node.name != "select":
                    node = self.tree.openElements.pop()
                self.parser.resetInsertionMode()
            else:
                # innerHTML case
                assert self.parser.innerHTML
                self.parser.parseError()

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag-in-select",
                                   {"name": token["name"]})

    class InSelectInTablePhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                (("caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th"),
                 self.startTagTable)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                (("caption", "table", "tbody", "tfoot", "thead", "tr", "td", "th"),
                 self.endTagTable)
            ])
            self.endTagHandler.default = self.endTagOther

        def processEOF(self):
            self.parser.phases["inSelect"].processEOF()

        def processCharacters(self, token):
            return self.parser.phases["inSelect"].processCharacters(token)

        def startTagTable(self, token):
            self.parser.parseError("unexpected-table-element-start-tag-in-select-in-table", {"name": token["name"]})
            self.endTagOther(impliedTagToken("select"))
            return token

        def startTagOther(self, token):
            return self.parser.phases["inSelect"].processStartTag(token)

        def endTagTable(self, token):
            self.parser.parseError("unexpected-table-element-end-tag-in-select-in-table", {"name": token["name"]})
            if self.tree.elementInScope(token["name"], variant="table"):
                self.endTagOther(impliedTagToken("select"))
                return token

        def endTagOther(self, token):
            return self.parser.phases["inSelect"].processEndTag(token)

    class InForeignContentPhase(Phase):
        breakoutElements = frozenset(["b", "big", "blockquote", "body", "br",
                                      "center", "code", "dd", "div", "dl", "dt",
                                      "em", "embed", "h1", "h2", "h3",
                                      "h4", "h5", "h6", "head", "hr", "i", "img",
                                      "li", "listing", "menu", "meta", "nobr",
                                      "ol", "p", "pre", "ruby", "s", "small",
                                      "span", "strong", "strike", "sub", "sup",
                                      "table", "tt", "u", "ul", "var"])

        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

        def adjustSVGTagNames(self, token):
            replacements = {"altglyph": "altGlyph",
                            "altglyphdef": "altGlyphDef",
                            "altglyphitem": "altGlyphItem",
                            "animatecolor": "animateColor",
                            "animatemotion": "animateMotion",
                            "animatetransform": "animateTransform",
                            "clippath": "clipPath",
                            "feblend": "feBlend",
                            "fecolormatrix": "feColorMatrix",
                            "fecomponenttransfer": "feComponentTransfer",
                            "fecomposite": "feComposite",
                            "feconvolvematrix": "feConvolveMatrix",
                            "fediffuselighting": "feDiffuseLighting",
                            "fedisplacementmap": "feDisplacementMap",
                            "fedistantlight": "feDistantLight",
                            "feflood": "feFlood",
                            "fefunca": "feFuncA",
                            "fefuncb": "feFuncB",
                            "fefuncg": "feFuncG",
                            "fefuncr": "feFuncR",
                            "fegaussianblur": "feGaussianBlur",
                            "feimage": "feImage",
                            "femerge": "feMerge",
                            "femergenode": "feMergeNode",
                            "femorphology": "feMorphology",
                            "feoffset": "feOffset",
                            "fepointlight": "fePointLight",
                            "fespecularlighting": "feSpecularLighting",
                            "fespotlight": "feSpotLight",
                            "fetile": "feTile",
                            "feturbulence": "feTurbulence",
                            "foreignobject": "foreignObject",
                            "glyphref": "glyphRef",
                            "lineargradient": "linearGradient",
                            "radialgradient": "radialGradient",
                            "textpath": "textPath"}

            if token["name"] in replacements:
                token["name"] = replacements[token["name"]]

        def processCharacters(self, token):
            if token["data"] == "\u0000":
                token["data"] = "\uFFFD"
            elif (self.parser.framesetOK and
                  any(char not in spaceCharacters for char in token["data"])):
                self.parser.framesetOK = False
            Phase.processCharacters(self, token)

        def processStartTag(self, token):
            currentNode = self.tree.openElements[-1]
            if (token["name"] in self.breakoutElements or
                (token["name"] == "font" and
                 set(token["data"].keys()) & set(["color", "face", "size"]))):
                self.parser.parseError("unexpected-html-element-in-foreign-content",
                                       {"name": token["name"]})
                while (self.tree.openElements[-1].namespace !=
                       self.tree.defaultNamespace and
                       not self.parser.isHTMLIntegrationPoint(self.tree.openElements[-1]) and
                       not self.parser.isMathMLTextIntegrationPoint(self.tree.openElements[-1])):
                    self.tree.openElements.pop()
                return token

            else:
                if currentNode.namespace == namespaces["mathml"]:
                    self.parser.adjustMathMLAttributes(token)
                elif currentNode.namespace == namespaces["svg"]:
                    self.adjustSVGTagNames(token)
                    self.parser.adjustSVGAttributes(token)
                self.parser.adjustForeignAttributes(token)
                token["namespace"] = currentNode.namespace
                self.tree.insertElement(token)
                if token["selfClosing"]:
                    self.tree.openElements.pop()
                    token["selfClosingAcknowledged"] = True

        def processEndTag(self, token):
            nodeIndex = len(self.tree.openElements) - 1
            node = self.tree.openElements[-1]
            if node.name != token["name"]:
                self.parser.parseError("unexpected-end-tag", {"name": token["name"]})

            while True:
                if node.name.translate(asciiUpper2Lower) == token["name"]:
                    # XXX this isn't in the spec but it seems necessary
                    if self.parser.phase == self.parser.phases["inTableText"]:
                        self.parser.phase.flushCharacters()
                        self.parser.phase = self.parser.phase.originalPhase
                    while self.tree.openElements.pop() != node:
                        assert self.tree.openElements
                    new_token = None
                    break
                nodeIndex -= 1

                node = self.tree.openElements[nodeIndex]
                if node.namespace != self.tree.defaultNamespace:
                    continue
                else:
                    new_token = self.parser.phase.processEndTag(token)
                    break
            return new_token

    class AfterBodyPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([("html", self.endTagHtml)])
            self.endTagHandler.default = self.endTagOther

        def processEOF(self):
            # Stop parsing
            pass

        def processComment(self, token):
            # This is needed because data is to be appended to the <html> element
            # here and not to whatever is currently open.
            self.tree.insertComment(token, self.tree.openElements[0])

        def processCharacters(self, token):
            self.parser.parseError("unexpected-char-after-body")
            self.parser.phase = self.parser.phases["inBody"]
            return token

        def startTagHtml(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagOther(self, token):
            self.parser.parseError("unexpected-start-tag-after-body",
                                   {"name": token["name"]})
            self.parser.phase = self.parser.phases["inBody"]
            return token

        def endTagHtml(self, name):
            if self.parser.innerHTML:
                self.parser.parseError("unexpected-end-tag-after-body-innerhtml")
            else:
                self.parser.phase = self.parser.phases["afterAfterBody"]

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag-after-body",
                                   {"name": token["name"]})
            self.parser.phase = self.parser.phases["inBody"]
            return token

    class InFramesetPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#in-frameset
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("frameset", self.startTagFrameset),
                ("frame", self.startTagFrame),
                ("noframes", self.startTagNoframes)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("frameset", self.endTagFrameset)
            ])
            self.endTagHandler.default = self.endTagOther

        def processEOF(self):
            if self.tree.openElements[-1].name != "html":
                self.parser.parseError("eof-in-frameset")
            else:
                assert self.parser.innerHTML

        def processCharacters(self, token):
            self.parser.parseError("unexpected-char-in-frameset")

        def startTagFrameset(self, token):
            self.tree.insertElement(token)

        def startTagFrame(self, token):
            self.tree.insertElement(token)
            self.tree.openElements.pop()

        def startTagNoframes(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagOther(self, token):
            self.parser.parseError("unexpected-start-tag-in-frameset",
                                   {"name": token["name"]})

        def endTagFrameset(self, token):
            if self.tree.openElements[-1].name == "html":
                # innerHTML case
                self.parser.parseError("unexpected-frameset-in-frameset-innerhtml")
            else:
                self.tree.openElements.pop()
            if (not self.parser.innerHTML and
                    self.tree.openElements[-1].name != "frameset"):
                # If we're not in innerHTML mode and the the current node is not a
                # "frameset" element (anymore) then switch.
                self.parser.phase = self.parser.phases["afterFrameset"]

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag-in-frameset",
                                   {"name": token["name"]})

    class AfterFramesetPhase(Phase):
        # http://www.whatwg.org/specs/web-apps/current-work/#after3
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("noframes", self.startTagNoframes)
            ])
            self.startTagHandler.default = self.startTagOther

            self.endTagHandler = utils.MethodDispatcher([
                ("html", self.endTagHtml)
            ])
            self.endTagHandler.default = self.endTagOther

        def processEOF(self):
            # Stop parsing
            pass

        def processCharacters(self, token):
            self.parser.parseError("unexpected-char-after-frameset")

        def startTagNoframes(self, token):
            return self.parser.phases["inHead"].processStartTag(token)

        def startTagOther(self, token):
            self.parser.parseError("unexpected-start-tag-after-frameset",
                                   {"name": token["name"]})

        def endTagHtml(self, token):
            self.parser.phase = self.parser.phases["afterAfterFrameset"]

        def endTagOther(self, token):
            self.parser.parseError("unexpected-end-tag-after-frameset",
                                   {"name": token["name"]})

    class AfterAfterBodyPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml)
            ])
            self.startTagHandler.default = self.startTagOther

        def processEOF(self):
            pass

        def processComment(self, token):
            self.tree.insertComment(token, self.tree.document)

        def processSpaceCharacters(self, token):
            return self.parser.phases["inBody"].processSpaceCharacters(token)

        def processCharacters(self, token):
            self.parser.parseError("expected-eof-but-got-char")
            self.parser.phase = self.parser.phases["inBody"]
            return token

        def startTagHtml(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagOther(self, token):
            self.parser.parseError("expected-eof-but-got-start-tag",
                                   {"name": token["name"]})
            self.parser.phase = self.parser.phases["inBody"]
            return token

        def processEndTag(self, token):
            self.parser.parseError("expected-eof-but-got-end-tag",
                                   {"name": token["name"]})
            self.parser.phase = self.parser.phases["inBody"]
            return token

    class AfterAfterFramesetPhase(Phase):
        def __init__(self, parser, tree):
            Phase.__init__(self, parser, tree)

            self.startTagHandler = utils.MethodDispatcher([
                ("html", self.startTagHtml),
                ("noframes", self.startTagNoFrames)
            ])
            self.startTagHandler.default = self.startTagOther

        def processEOF(self):
            pass

        def processComment(self, token):
            self.tree.insertComment(token, self.tree.document)

        def processSpaceCharacters(self, token):
            return self.parser.phases["inBody"].processSpaceCharacters(token)

        def processCharacters(self, token):
            self.parser.parseError("expected-eof-but-got-char")

        def startTagHtml(self, token):
            return self.parser.phases["inBody"].processStartTag(token)

        def startTagNoFrames(self, token):
            return self.parser.phases["inHead"].processStartTag(token)

        def startTagOther(self, token):
            self.parser.parseError("expected-eof-but-got-start-tag",
                                   {"name": token["name"]})

        def processEndTag(self, token):
            self.parser.parseError("expected-eof-but-got-end-tag",
                                   {"name": token["name"]})

    return {
        "initial": InitialPhase,
        "beforeHtml": BeforeHtmlPhase,
        "beforeHead": BeforeHeadPhase,
        "inHead": InHeadPhase,
        # XXX "inHeadNoscript": InHeadNoScriptPhase,
        "afterHead": AfterHeadPhase,
        "inBody": InBodyPhase,
        "text": TextPhase,
        "inTable": InTablePhase,
        "inTableText": InTableTextPhase,
        "inCaption": InCaptionPhase,
        "inColumnGroup": InColumnGroupPhase,
        "inTableBody": InTableBodyPhase,
        "inRow": InRowPhase,
        "inCell": InCellPhase,
        "inSelect": InSelectPhase,
        "inSelectInTable": InSelectInTablePhase,
        "inForeignContent": InForeignContentPhase,
        "afterBody": AfterBodyPhase,
        "inFrameset": InFramesetPhase,
        "afterFrameset": AfterFramesetPhase,
        "afterAfterBody": AfterAfterBodyPhase,
        "afterAfterFrameset": AfterAfterFramesetPhase,
        # XXX after after frameset
    }


def impliedTagToken(name, type="EndTag", attributes=None,
                    selfClosing=False):
    if attributes is None:
        attributes = {}
    return {"type": tokenTypes[type], "name": name, "data": attributes,
            "selfClosing": selfClosing}


class ParseError(Exception):
    """Error in parsed document"""
    pass

########NEW FILE########
__FILENAME__ = ihatexml
from __future__ import absolute_import, division, unicode_literals

import re
import warnings

from .constants import DataLossWarning

baseChar = """
[#x0041-#x005A] | [#x0061-#x007A] | [#x00C0-#x00D6] | [#x00D8-#x00F6] |
[#x00F8-#x00FF] | [#x0100-#x0131] | [#x0134-#x013E] | [#x0141-#x0148] |
[#x014A-#x017E] | [#x0180-#x01C3] | [#x01CD-#x01F0] | [#x01F4-#x01F5] |
[#x01FA-#x0217] | [#x0250-#x02A8] | [#x02BB-#x02C1] | #x0386 |
[#x0388-#x038A] | #x038C | [#x038E-#x03A1] | [#x03A3-#x03CE] |
[#x03D0-#x03D6] | #x03DA | #x03DC | #x03DE | #x03E0 | [#x03E2-#x03F3] |
[#x0401-#x040C] | [#x040E-#x044F] | [#x0451-#x045C] | [#x045E-#x0481] |
[#x0490-#x04C4] | [#x04C7-#x04C8] | [#x04CB-#x04CC] | [#x04D0-#x04EB] |
[#x04EE-#x04F5] | [#x04F8-#x04F9] | [#x0531-#x0556] | #x0559 |
[#x0561-#x0586] | [#x05D0-#x05EA] | [#x05F0-#x05F2] | [#x0621-#x063A] |
[#x0641-#x064A] | [#x0671-#x06B7] | [#x06BA-#x06BE] | [#x06C0-#x06CE] |
[#x06D0-#x06D3] | #x06D5 | [#x06E5-#x06E6] | [#x0905-#x0939] | #x093D |
[#x0958-#x0961] | [#x0985-#x098C] | [#x098F-#x0990] | [#x0993-#x09A8] |
[#x09AA-#x09B0] | #x09B2 | [#x09B6-#x09B9] | [#x09DC-#x09DD] |
[#x09DF-#x09E1] | [#x09F0-#x09F1] | [#x0A05-#x0A0A] | [#x0A0F-#x0A10] |
[#x0A13-#x0A28] | [#x0A2A-#x0A30] | [#x0A32-#x0A33] | [#x0A35-#x0A36] |
[#x0A38-#x0A39] | [#x0A59-#x0A5C] | #x0A5E | [#x0A72-#x0A74] |
[#x0A85-#x0A8B] | #x0A8D | [#x0A8F-#x0A91] | [#x0A93-#x0AA8] |
[#x0AAA-#x0AB0] | [#x0AB2-#x0AB3] | [#x0AB5-#x0AB9] | #x0ABD | #x0AE0 |
[#x0B05-#x0B0C] | [#x0B0F-#x0B10] | [#x0B13-#x0B28] | [#x0B2A-#x0B30] |
[#x0B32-#x0B33] | [#x0B36-#x0B39] | #x0B3D | [#x0B5C-#x0B5D] |
[#x0B5F-#x0B61] | [#x0B85-#x0B8A] | [#x0B8E-#x0B90] | [#x0B92-#x0B95] |
[#x0B99-#x0B9A] | #x0B9C | [#x0B9E-#x0B9F] | [#x0BA3-#x0BA4] |
[#x0BA8-#x0BAA] | [#x0BAE-#x0BB5] | [#x0BB7-#x0BB9] | [#x0C05-#x0C0C] |
[#x0C0E-#x0C10] | [#x0C12-#x0C28] | [#x0C2A-#x0C33] | [#x0C35-#x0C39] |
[#x0C60-#x0C61] | [#x0C85-#x0C8C] | [#x0C8E-#x0C90] | [#x0C92-#x0CA8] |
[#x0CAA-#x0CB3] | [#x0CB5-#x0CB9] | #x0CDE | [#x0CE0-#x0CE1] |
[#x0D05-#x0D0C] | [#x0D0E-#x0D10] | [#x0D12-#x0D28] | [#x0D2A-#x0D39] |
[#x0D60-#x0D61] | [#x0E01-#x0E2E] | #x0E30 | [#x0E32-#x0E33] |
[#x0E40-#x0E45] | [#x0E81-#x0E82] | #x0E84 | [#x0E87-#x0E88] | #x0E8A |
#x0E8D | [#x0E94-#x0E97] | [#x0E99-#x0E9F] | [#x0EA1-#x0EA3] | #x0EA5 |
#x0EA7 | [#x0EAA-#x0EAB] | [#x0EAD-#x0EAE] | #x0EB0 | [#x0EB2-#x0EB3] |
#x0EBD | [#x0EC0-#x0EC4] | [#x0F40-#x0F47] | [#x0F49-#x0F69] |
[#x10A0-#x10C5] | [#x10D0-#x10F6] | #x1100 | [#x1102-#x1103] |
[#x1105-#x1107] | #x1109 | [#x110B-#x110C] | [#x110E-#x1112] | #x113C |
#x113E | #x1140 | #x114C | #x114E | #x1150 | [#x1154-#x1155] | #x1159 |
[#x115F-#x1161] | #x1163 | #x1165 | #x1167 | #x1169 | [#x116D-#x116E] |
[#x1172-#x1173] | #x1175 | #x119E | #x11A8 | #x11AB | [#x11AE-#x11AF] |
[#x11B7-#x11B8] | #x11BA | [#x11BC-#x11C2] | #x11EB | #x11F0 | #x11F9 |
[#x1E00-#x1E9B] | [#x1EA0-#x1EF9] | [#x1F00-#x1F15] | [#x1F18-#x1F1D] |
[#x1F20-#x1F45] | [#x1F48-#x1F4D] | [#x1F50-#x1F57] | #x1F59 | #x1F5B |
#x1F5D | [#x1F5F-#x1F7D] | [#x1F80-#x1FB4] | [#x1FB6-#x1FBC] | #x1FBE |
[#x1FC2-#x1FC4] | [#x1FC6-#x1FCC] | [#x1FD0-#x1FD3] | [#x1FD6-#x1FDB] |
[#x1FE0-#x1FEC] | [#x1FF2-#x1FF4] | [#x1FF6-#x1FFC] | #x2126 |
[#x212A-#x212B] | #x212E | [#x2180-#x2182] | [#x3041-#x3094] |
[#x30A1-#x30FA] | [#x3105-#x312C] | [#xAC00-#xD7A3]"""

ideographic = """[#x4E00-#x9FA5] | #x3007 | [#x3021-#x3029]"""

combiningCharacter = """
[#x0300-#x0345] | [#x0360-#x0361] | [#x0483-#x0486] | [#x0591-#x05A1] |
[#x05A3-#x05B9] | [#x05BB-#x05BD] | #x05BF | [#x05C1-#x05C2] | #x05C4 |
[#x064B-#x0652] | #x0670 | [#x06D6-#x06DC] | [#x06DD-#x06DF] |
[#x06E0-#x06E4] | [#x06E7-#x06E8] | [#x06EA-#x06ED] | [#x0901-#x0903] |
#x093C | [#x093E-#x094C] | #x094D | [#x0951-#x0954] | [#x0962-#x0963] |
[#x0981-#x0983] | #x09BC | #x09BE | #x09BF | [#x09C0-#x09C4] |
[#x09C7-#x09C8] | [#x09CB-#x09CD] | #x09D7 | [#x09E2-#x09E3] | #x0A02 |
#x0A3C | #x0A3E | #x0A3F | [#x0A40-#x0A42] | [#x0A47-#x0A48] |
[#x0A4B-#x0A4D] | [#x0A70-#x0A71] | [#x0A81-#x0A83] | #x0ABC |
[#x0ABE-#x0AC5] | [#x0AC7-#x0AC9] | [#x0ACB-#x0ACD] | [#x0B01-#x0B03] |
#x0B3C | [#x0B3E-#x0B43] | [#x0B47-#x0B48] | [#x0B4B-#x0B4D] |
[#x0B56-#x0B57] | [#x0B82-#x0B83] | [#x0BBE-#x0BC2] | [#x0BC6-#x0BC8] |
[#x0BCA-#x0BCD] | #x0BD7 | [#x0C01-#x0C03] | [#x0C3E-#x0C44] |
[#x0C46-#x0C48] | [#x0C4A-#x0C4D] | [#x0C55-#x0C56] | [#x0C82-#x0C83] |
[#x0CBE-#x0CC4] | [#x0CC6-#x0CC8] | [#x0CCA-#x0CCD] | [#x0CD5-#x0CD6] |
[#x0D02-#x0D03] | [#x0D3E-#x0D43] | [#x0D46-#x0D48] | [#x0D4A-#x0D4D] |
#x0D57 | #x0E31 | [#x0E34-#x0E3A] | [#x0E47-#x0E4E] | #x0EB1 |
[#x0EB4-#x0EB9] | [#x0EBB-#x0EBC] | [#x0EC8-#x0ECD] | [#x0F18-#x0F19] |
#x0F35 | #x0F37 | #x0F39 | #x0F3E | #x0F3F | [#x0F71-#x0F84] |
[#x0F86-#x0F8B] | [#x0F90-#x0F95] | #x0F97 | [#x0F99-#x0FAD] |
[#x0FB1-#x0FB7] | #x0FB9 | [#x20D0-#x20DC] | #x20E1 | [#x302A-#x302F] |
#x3099 | #x309A"""

digit = """
[#x0030-#x0039] | [#x0660-#x0669] | [#x06F0-#x06F9] | [#x0966-#x096F] |
[#x09E6-#x09EF] | [#x0A66-#x0A6F] | [#x0AE6-#x0AEF] | [#x0B66-#x0B6F] |
[#x0BE7-#x0BEF] | [#x0C66-#x0C6F] | [#x0CE6-#x0CEF] | [#x0D66-#x0D6F] |
[#x0E50-#x0E59] | [#x0ED0-#x0ED9] | [#x0F20-#x0F29]"""

extender = """
#x00B7 | #x02D0 | #x02D1 | #x0387 | #x0640 | #x0E46 | #x0EC6 | #x3005 |
#[#x3031-#x3035] | [#x309D-#x309E] | [#x30FC-#x30FE]"""

letter = " | ".join([baseChar, ideographic])

# Without the
name = " | ".join([letter, digit, ".", "-", "_", combiningCharacter,
                   extender])
nameFirst = " | ".join([letter, "_"])

reChar = re.compile(r"#x([\d|A-F]{4,4})")
reCharRange = re.compile(r"\[#x([\d|A-F]{4,4})-#x([\d|A-F]{4,4})\]")


def charStringToList(chars):
    charRanges = [item.strip() for item in chars.split(" | ")]
    rv = []
    for item in charRanges:
        foundMatch = False
        for regexp in (reChar, reCharRange):
            match = regexp.match(item)
            if match is not None:
                rv.append([hexToInt(item) for item in match.groups()])
                if len(rv[-1]) == 1:
                    rv[-1] = rv[-1] * 2
                foundMatch = True
                break
        if not foundMatch:
            assert len(item) == 1

            rv.append([ord(item)] * 2)
    rv = normaliseCharList(rv)
    return rv


def normaliseCharList(charList):
    charList = sorted(charList)
    for item in charList:
        assert item[1] >= item[0]
    rv = []
    i = 0
    while i < len(charList):
        j = 1
        rv.append(charList[i])
        while i + j < len(charList) and charList[i + j][0] <= rv[-1][1] + 1:
            rv[-1][1] = charList[i + j][1]
            j += 1
        i += j
    return rv

# We don't really support characters above the BMP :(
max_unicode = int("FFFF", 16)


def missingRanges(charList):
    rv = []
    if charList[0] != 0:
        rv.append([0, charList[0][0] - 1])
    for i, item in enumerate(charList[:-1]):
        rv.append([item[1] + 1, charList[i + 1][0] - 1])
    if charList[-1][1] != max_unicode:
        rv.append([charList[-1][1] + 1, max_unicode])
    return rv


def listToRegexpStr(charList):
    rv = []
    for item in charList:
        if item[0] == item[1]:
            rv.append(escapeRegexp(chr(item[0])))
        else:
            rv.append(escapeRegexp(chr(item[0])) + "-" +
                      escapeRegexp(chr(item[1])))
    return "[%s]" % "".join(rv)


def hexToInt(hex_str):
    return int(hex_str, 16)


def escapeRegexp(string):
    specialCharacters = (".", "^", "$", "*", "+", "?", "{", "}",
                         "[", "]", "|", "(", ")", "-")
    for char in specialCharacters:
        string = string.replace(char, "\\" + char)

    return string

# output from the above
nonXmlNameBMPRegexp = re.compile('[\x00-,/:-@\\[-\\^`\\{-\xb6\xb8-\xbf\xd7\xf7\u0132-\u0133\u013f-\u0140\u0149\u017f\u01c4-\u01cc\u01f1-\u01f3\u01f6-\u01f9\u0218-\u024f\u02a9-\u02ba\u02c2-\u02cf\u02d2-\u02ff\u0346-\u035f\u0362-\u0385\u038b\u038d\u03a2\u03cf\u03d7-\u03d9\u03db\u03dd\u03df\u03e1\u03f4-\u0400\u040d\u0450\u045d\u0482\u0487-\u048f\u04c5-\u04c6\u04c9-\u04ca\u04cd-\u04cf\u04ec-\u04ed\u04f6-\u04f7\u04fa-\u0530\u0557-\u0558\u055a-\u0560\u0587-\u0590\u05a2\u05ba\u05be\u05c0\u05c3\u05c5-\u05cf\u05eb-\u05ef\u05f3-\u0620\u063b-\u063f\u0653-\u065f\u066a-\u066f\u06b8-\u06b9\u06bf\u06cf\u06d4\u06e9\u06ee-\u06ef\u06fa-\u0900\u0904\u093a-\u093b\u094e-\u0950\u0955-\u0957\u0964-\u0965\u0970-\u0980\u0984\u098d-\u098e\u0991-\u0992\u09a9\u09b1\u09b3-\u09b5\u09ba-\u09bb\u09bd\u09c5-\u09c6\u09c9-\u09ca\u09ce-\u09d6\u09d8-\u09db\u09de\u09e4-\u09e5\u09f2-\u0a01\u0a03-\u0a04\u0a0b-\u0a0e\u0a11-\u0a12\u0a29\u0a31\u0a34\u0a37\u0a3a-\u0a3b\u0a3d\u0a43-\u0a46\u0a49-\u0a4a\u0a4e-\u0a58\u0a5d\u0a5f-\u0a65\u0a75-\u0a80\u0a84\u0a8c\u0a8e\u0a92\u0aa9\u0ab1\u0ab4\u0aba-\u0abb\u0ac6\u0aca\u0ace-\u0adf\u0ae1-\u0ae5\u0af0-\u0b00\u0b04\u0b0d-\u0b0e\u0b11-\u0b12\u0b29\u0b31\u0b34-\u0b35\u0b3a-\u0b3b\u0b44-\u0b46\u0b49-\u0b4a\u0b4e-\u0b55\u0b58-\u0b5b\u0b5e\u0b62-\u0b65\u0b70-\u0b81\u0b84\u0b8b-\u0b8d\u0b91\u0b96-\u0b98\u0b9b\u0b9d\u0ba0-\u0ba2\u0ba5-\u0ba7\u0bab-\u0bad\u0bb6\u0bba-\u0bbd\u0bc3-\u0bc5\u0bc9\u0bce-\u0bd6\u0bd8-\u0be6\u0bf0-\u0c00\u0c04\u0c0d\u0c11\u0c29\u0c34\u0c3a-\u0c3d\u0c45\u0c49\u0c4e-\u0c54\u0c57-\u0c5f\u0c62-\u0c65\u0c70-\u0c81\u0c84\u0c8d\u0c91\u0ca9\u0cb4\u0cba-\u0cbd\u0cc5\u0cc9\u0cce-\u0cd4\u0cd7-\u0cdd\u0cdf\u0ce2-\u0ce5\u0cf0-\u0d01\u0d04\u0d0d\u0d11\u0d29\u0d3a-\u0d3d\u0d44-\u0d45\u0d49\u0d4e-\u0d56\u0d58-\u0d5f\u0d62-\u0d65\u0d70-\u0e00\u0e2f\u0e3b-\u0e3f\u0e4f\u0e5a-\u0e80\u0e83\u0e85-\u0e86\u0e89\u0e8b-\u0e8c\u0e8e-\u0e93\u0e98\u0ea0\u0ea4\u0ea6\u0ea8-\u0ea9\u0eac\u0eaf\u0eba\u0ebe-\u0ebf\u0ec5\u0ec7\u0ece-\u0ecf\u0eda-\u0f17\u0f1a-\u0f1f\u0f2a-\u0f34\u0f36\u0f38\u0f3a-\u0f3d\u0f48\u0f6a-\u0f70\u0f85\u0f8c-\u0f8f\u0f96\u0f98\u0fae-\u0fb0\u0fb8\u0fba-\u109f\u10c6-\u10cf\u10f7-\u10ff\u1101\u1104\u1108\u110a\u110d\u1113-\u113b\u113d\u113f\u1141-\u114b\u114d\u114f\u1151-\u1153\u1156-\u1158\u115a-\u115e\u1162\u1164\u1166\u1168\u116a-\u116c\u116f-\u1171\u1174\u1176-\u119d\u119f-\u11a7\u11a9-\u11aa\u11ac-\u11ad\u11b0-\u11b6\u11b9\u11bb\u11c3-\u11ea\u11ec-\u11ef\u11f1-\u11f8\u11fa-\u1dff\u1e9c-\u1e9f\u1efa-\u1eff\u1f16-\u1f17\u1f1e-\u1f1f\u1f46-\u1f47\u1f4e-\u1f4f\u1f58\u1f5a\u1f5c\u1f5e\u1f7e-\u1f7f\u1fb5\u1fbd\u1fbf-\u1fc1\u1fc5\u1fcd-\u1fcf\u1fd4-\u1fd5\u1fdc-\u1fdf\u1fed-\u1ff1\u1ff5\u1ffd-\u20cf\u20dd-\u20e0\u20e2-\u2125\u2127-\u2129\u212c-\u212d\u212f-\u217f\u2183-\u3004\u3006\u3008-\u3020\u3030\u3036-\u3040\u3095-\u3098\u309b-\u309c\u309f-\u30a0\u30fb\u30ff-\u3104\u312d-\u4dff\u9fa6-\uabff\ud7a4-\uffff]')

nonXmlNameFirstBMPRegexp = re.compile('[\x00-@\\[-\\^`\\{-\xbf\xd7\xf7\u0132-\u0133\u013f-\u0140\u0149\u017f\u01c4-\u01cc\u01f1-\u01f3\u01f6-\u01f9\u0218-\u024f\u02a9-\u02ba\u02c2-\u0385\u0387\u038b\u038d\u03a2\u03cf\u03d7-\u03d9\u03db\u03dd\u03df\u03e1\u03f4-\u0400\u040d\u0450\u045d\u0482-\u048f\u04c5-\u04c6\u04c9-\u04ca\u04cd-\u04cf\u04ec-\u04ed\u04f6-\u04f7\u04fa-\u0530\u0557-\u0558\u055a-\u0560\u0587-\u05cf\u05eb-\u05ef\u05f3-\u0620\u063b-\u0640\u064b-\u0670\u06b8-\u06b9\u06bf\u06cf\u06d4\u06d6-\u06e4\u06e7-\u0904\u093a-\u093c\u093e-\u0957\u0962-\u0984\u098d-\u098e\u0991-\u0992\u09a9\u09b1\u09b3-\u09b5\u09ba-\u09db\u09de\u09e2-\u09ef\u09f2-\u0a04\u0a0b-\u0a0e\u0a11-\u0a12\u0a29\u0a31\u0a34\u0a37\u0a3a-\u0a58\u0a5d\u0a5f-\u0a71\u0a75-\u0a84\u0a8c\u0a8e\u0a92\u0aa9\u0ab1\u0ab4\u0aba-\u0abc\u0abe-\u0adf\u0ae1-\u0b04\u0b0d-\u0b0e\u0b11-\u0b12\u0b29\u0b31\u0b34-\u0b35\u0b3a-\u0b3c\u0b3e-\u0b5b\u0b5e\u0b62-\u0b84\u0b8b-\u0b8d\u0b91\u0b96-\u0b98\u0b9b\u0b9d\u0ba0-\u0ba2\u0ba5-\u0ba7\u0bab-\u0bad\u0bb6\u0bba-\u0c04\u0c0d\u0c11\u0c29\u0c34\u0c3a-\u0c5f\u0c62-\u0c84\u0c8d\u0c91\u0ca9\u0cb4\u0cba-\u0cdd\u0cdf\u0ce2-\u0d04\u0d0d\u0d11\u0d29\u0d3a-\u0d5f\u0d62-\u0e00\u0e2f\u0e31\u0e34-\u0e3f\u0e46-\u0e80\u0e83\u0e85-\u0e86\u0e89\u0e8b-\u0e8c\u0e8e-\u0e93\u0e98\u0ea0\u0ea4\u0ea6\u0ea8-\u0ea9\u0eac\u0eaf\u0eb1\u0eb4-\u0ebc\u0ebe-\u0ebf\u0ec5-\u0f3f\u0f48\u0f6a-\u109f\u10c6-\u10cf\u10f7-\u10ff\u1101\u1104\u1108\u110a\u110d\u1113-\u113b\u113d\u113f\u1141-\u114b\u114d\u114f\u1151-\u1153\u1156-\u1158\u115a-\u115e\u1162\u1164\u1166\u1168\u116a-\u116c\u116f-\u1171\u1174\u1176-\u119d\u119f-\u11a7\u11a9-\u11aa\u11ac-\u11ad\u11b0-\u11b6\u11b9\u11bb\u11c3-\u11ea\u11ec-\u11ef\u11f1-\u11f8\u11fa-\u1dff\u1e9c-\u1e9f\u1efa-\u1eff\u1f16-\u1f17\u1f1e-\u1f1f\u1f46-\u1f47\u1f4e-\u1f4f\u1f58\u1f5a\u1f5c\u1f5e\u1f7e-\u1f7f\u1fb5\u1fbd\u1fbf-\u1fc1\u1fc5\u1fcd-\u1fcf\u1fd4-\u1fd5\u1fdc-\u1fdf\u1fed-\u1ff1\u1ff5\u1ffd-\u2125\u2127-\u2129\u212c-\u212d\u212f-\u217f\u2183-\u3006\u3008-\u3020\u302a-\u3040\u3095-\u30a0\u30fb-\u3104\u312d-\u4dff\u9fa6-\uabff\ud7a4-\uffff]')

# Simpler things
nonPubidCharRegexp = re.compile("[^\x20\x0D\x0Aa-zA-Z0-9\-\'()+,./:=?;!*#@$_%]")


class InfosetFilter(object):
    replacementRegexp = re.compile(r"U[\dA-F]{5,5}")

    def __init__(self, replaceChars=None,
                 dropXmlnsLocalName=False,
                 dropXmlnsAttrNs=False,
                 preventDoubleDashComments=False,
                 preventDashAtCommentEnd=False,
                 replaceFormFeedCharacters=True,
                 preventSingleQuotePubid=False):

        self.dropXmlnsLocalName = dropXmlnsLocalName
        self.dropXmlnsAttrNs = dropXmlnsAttrNs

        self.preventDoubleDashComments = preventDoubleDashComments
        self.preventDashAtCommentEnd = preventDashAtCommentEnd

        self.replaceFormFeedCharacters = replaceFormFeedCharacters

        self.preventSingleQuotePubid = preventSingleQuotePubid

        self.replaceCache = {}

    def coerceAttribute(self, name, namespace=None):
        if self.dropXmlnsLocalName and name.startswith("xmlns:"):
            warnings.warn("Attributes cannot begin with xmlns", DataLossWarning)
            return None
        elif (self.dropXmlnsAttrNs and
              namespace == "http://www.w3.org/2000/xmlns/"):
            warnings.warn("Attributes cannot be in the xml namespace", DataLossWarning)
            return None
        else:
            return self.toXmlName(name)

    def coerceElement(self, name, namespace=None):
        return self.toXmlName(name)

    def coerceComment(self, data):
        if self.preventDoubleDashComments:
            while "--" in data:
                warnings.warn("Comments cannot contain adjacent dashes", DataLossWarning)
                data = data.replace("--", "- -")
        return data

    def coerceCharacters(self, data):
        if self.replaceFormFeedCharacters:
            for i in range(data.count("\x0C")):
                warnings.warn("Text cannot contain U+000C", DataLossWarning)
            data = data.replace("\x0C", " ")
        # Other non-xml characters
        return data

    def coercePubid(self, data):
        dataOutput = data
        for char in nonPubidCharRegexp.findall(data):
            warnings.warn("Coercing non-XML pubid", DataLossWarning)
            replacement = self.getReplacementCharacter(char)
            dataOutput = dataOutput.replace(char, replacement)
        if self.preventSingleQuotePubid and dataOutput.find("'") >= 0:
            warnings.warn("Pubid cannot contain single quote", DataLossWarning)
            dataOutput = dataOutput.replace("'", self.getReplacementCharacter("'"))
        return dataOutput

    def toXmlName(self, name):
        nameFirst = name[0]
        nameRest = name[1:]
        m = nonXmlNameFirstBMPRegexp.match(nameFirst)
        if m:
            warnings.warn("Coercing non-XML name", DataLossWarning)
            nameFirstOutput = self.getReplacementCharacter(nameFirst)
        else:
            nameFirstOutput = nameFirst

        nameRestOutput = nameRest
        replaceChars = set(nonXmlNameBMPRegexp.findall(nameRest))
        for char in replaceChars:
            warnings.warn("Coercing non-XML name", DataLossWarning)
            replacement = self.getReplacementCharacter(char)
            nameRestOutput = nameRestOutput.replace(char, replacement)
        return nameFirstOutput + nameRestOutput

    def getReplacementCharacter(self, char):
        if char in self.replaceCache:
            replacement = self.replaceCache[char]
        else:
            replacement = self.escapeChar(char)
        return replacement

    def fromXmlName(self, name):
        for item in set(self.replacementRegexp.findall(name)):
            name = name.replace(item, self.unescapeChar(item))
        return name

    def escapeChar(self, char):
        replacement = "U%05X" % ord(char)
        self.replaceCache[char] = replacement
        return replacement

    def unescapeChar(self, charcode):
        return chr(int(charcode[1:], 16))

########NEW FILE########
__FILENAME__ = inputstream
from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type

import codecs
import re

from .constants import EOF, spaceCharacters, asciiLetters, asciiUppercase
from .constants import encodings, ReparseException
from . import utils

from io import StringIO

try:
    from io import BytesIO
except ImportError:
    BytesIO = StringIO

try:
    from io import BufferedIOBase
except ImportError:
    class BufferedIOBase(object):
        pass

# Non-unicode versions of constants for use in the pre-parser
spaceCharactersBytes = frozenset([item.encode("ascii") for item in spaceCharacters])
asciiLettersBytes = frozenset([item.encode("ascii") for item in asciiLetters])
asciiUppercaseBytes = frozenset([item.encode("ascii") for item in asciiUppercase])
spacesAngleBrackets = spaceCharactersBytes | frozenset([b">", b"<"])

invalid_unicode_re = re.compile("[\u0001-\u0008\u000B\u000E-\u001F\u007F-\u009F\uD800-\uDFFF\uFDD0-\uFDEF\uFFFE\uFFFF\U0001FFFE\U0001FFFF\U0002FFFE\U0002FFFF\U0003FFFE\U0003FFFF\U0004FFFE\U0004FFFF\U0005FFFE\U0005FFFF\U0006FFFE\U0006FFFF\U0007FFFE\U0007FFFF\U0008FFFE\U0008FFFF\U0009FFFE\U0009FFFF\U000AFFFE\U000AFFFF\U000BFFFE\U000BFFFF\U000CFFFE\U000CFFFF\U000DFFFE\U000DFFFF\U000EFFFE\U000EFFFF\U000FFFFE\U000FFFFF\U0010FFFE\U0010FFFF]")

non_bmp_invalid_codepoints = set([0x1FFFE, 0x1FFFF, 0x2FFFE, 0x2FFFF, 0x3FFFE,
                                  0x3FFFF, 0x4FFFE, 0x4FFFF, 0x5FFFE, 0x5FFFF,
                                  0x6FFFE, 0x6FFFF, 0x7FFFE, 0x7FFFF, 0x8FFFE,
                                  0x8FFFF, 0x9FFFE, 0x9FFFF, 0xAFFFE, 0xAFFFF,
                                  0xBFFFE, 0xBFFFF, 0xCFFFE, 0xCFFFF, 0xDFFFE,
                                  0xDFFFF, 0xEFFFE, 0xEFFFF, 0xFFFFE, 0xFFFFF,
                                  0x10FFFE, 0x10FFFF])

ascii_punctuation_re = re.compile("[\u0009-\u000D\u0020-\u002F\u003A-\u0040\u005B-\u0060\u007B-\u007E]")

# Cache for charsUntil()
charsUntilRegEx = {}


class BufferedStream(object):
    """Buffering for streams that do not have buffering of their own

    The buffer is implemented as a list of chunks on the assumption that
    joining many strings will be slow since it is O(n**2)
    """

    def __init__(self, stream):
        self.stream = stream
        self.buffer = []
        self.position = [-1, 0]  # chunk number, offset

    def tell(self):
        pos = 0
        for chunk in self.buffer[:self.position[0]]:
            pos += len(chunk)
        pos += self.position[1]
        return pos

    def seek(self, pos):
        assert pos <= self._bufferedBytes()
        offset = pos
        i = 0
        while len(self.buffer[i]) < offset:
            offset -= len(self.buffer[i])
            i += 1
        self.position = [i, offset]

    def read(self, bytes):
        if not self.buffer:
            return self._readStream(bytes)
        elif (self.position[0] == len(self.buffer) and
              self.position[1] == len(self.buffer[-1])):
            return self._readStream(bytes)
        else:
            return self._readFromBuffer(bytes)

    def _bufferedBytes(self):
        return sum([len(item) for item in self.buffer])

    def _readStream(self, bytes):
        data = self.stream.read(bytes)
        self.buffer.append(data)
        self.position[0] += 1
        self.position[1] = len(data)
        return data

    def _readFromBuffer(self, bytes):
        remainingBytes = bytes
        rv = []
        bufferIndex = self.position[0]
        bufferOffset = self.position[1]
        while bufferIndex < len(self.buffer) and remainingBytes != 0:
            assert remainingBytes > 0
            bufferedData = self.buffer[bufferIndex]

            if remainingBytes <= len(bufferedData) - bufferOffset:
                bytesToRead = remainingBytes
                self.position = [bufferIndex, bufferOffset + bytesToRead]
            else:
                bytesToRead = len(bufferedData) - bufferOffset
                self.position = [bufferIndex, len(bufferedData)]
                bufferIndex += 1
            rv.append(bufferedData[bufferOffset:bufferOffset + bytesToRead])
            remainingBytes -= bytesToRead

            bufferOffset = 0

        if remainingBytes:
            rv.append(self._readStream(remainingBytes))

        return b"".join(rv)


def HTMLInputStream(source, encoding=None, parseMeta=True, chardet=True):
    if hasattr(source, "read"):
        isUnicode = isinstance(source.read(0), text_type)
    else:
        isUnicode = isinstance(source, text_type)

    if isUnicode:
        if encoding is not None:
            raise TypeError("Cannot explicitly set an encoding with a unicode string")

        return HTMLUnicodeInputStream(source)
    else:
        return HTMLBinaryInputStream(source, encoding, parseMeta, chardet)


class HTMLUnicodeInputStream(object):
    """Provides a unicode stream of characters to the HTMLTokenizer.

    This class takes care of character encoding and removing or replacing
    incorrect byte-sequences and also provides column and line tracking.

    """

    _defaultChunkSize = 10240

    def __init__(self, source):
        """Initialises the HTMLInputStream.

        HTMLInputStream(source, [encoding]) -> Normalized stream from source
        for use by html5lib.

        source can be either a file-object, local filename or a string.

        The optional encoding parameter must be a string that indicates
        the encoding.  If specified, that encoding will be used,
        regardless of any BOM or later declaration (such as in a meta
        element)

        parseMeta - Look for a <meta> element containing encoding information

        """

        # Craziness
        if len("\U0010FFFF") == 1:
            self.reportCharacterErrors = self.characterErrorsUCS4
            self.replaceCharactersRegexp = re.compile("[\uD800-\uDFFF]")
        else:
            self.reportCharacterErrors = self.characterErrorsUCS2
            self.replaceCharactersRegexp = re.compile("([\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?<![\uD800-\uDBFF])[\uDC00-\uDFFF])")

        # List of where new lines occur
        self.newLines = [0]

        self.charEncoding = ("utf-8", "certain")
        self.dataStream = self.openStream(source)

        self.reset()

    def reset(self):
        self.chunk = ""
        self.chunkSize = 0
        self.chunkOffset = 0
        self.errors = []

        # number of (complete) lines in previous chunks
        self.prevNumLines = 0
        # number of columns in the last line of the previous chunk
        self.prevNumCols = 0

        # Deal with CR LF and surrogates split over chunk boundaries
        self._bufferedCharacter = None

    def openStream(self, source):
        """Produces a file object from source.

        source can be either a file object, local filename or a string.

        """
        # Already a file object
        if hasattr(source, 'read'):
            stream = source
        else:
            stream = StringIO(source)

        return stream

    def _position(self, offset):
        chunk = self.chunk
        nLines = chunk.count('\n', 0, offset)
        positionLine = self.prevNumLines + nLines
        lastLinePos = chunk.rfind('\n', 0, offset)
        if lastLinePos == -1:
            positionColumn = self.prevNumCols + offset
        else:
            positionColumn = offset - (lastLinePos + 1)
        return (positionLine, positionColumn)

    def position(self):
        """Returns (line, col) of the current position in the stream."""
        line, col = self._position(self.chunkOffset)
        return (line + 1, col)

    def char(self):
        """ Read one character from the stream or queue if available. Return
            EOF when EOF is reached.
        """
        # Read a new chunk from the input stream if necessary
        if self.chunkOffset >= self.chunkSize:
            if not self.readChunk():
                return EOF

        chunkOffset = self.chunkOffset
        char = self.chunk[chunkOffset]
        self.chunkOffset = chunkOffset + 1

        return char

    def readChunk(self, chunkSize=None):
        if chunkSize is None:
            chunkSize = self._defaultChunkSize

        self.prevNumLines, self.prevNumCols = self._position(self.chunkSize)

        self.chunk = ""
        self.chunkSize = 0
        self.chunkOffset = 0

        data = self.dataStream.read(chunkSize)

        # Deal with CR LF and surrogates broken across chunks
        if self._bufferedCharacter:
            data = self._bufferedCharacter + data
            self._bufferedCharacter = None
        elif not data:
            # We have no more data, bye-bye stream
            return False

        if len(data) > 1:
            lastv = ord(data[-1])
            if lastv == 0x0D or 0xD800 <= lastv <= 0xDBFF:
                self._bufferedCharacter = data[-1]
                data = data[:-1]

        self.reportCharacterErrors(data)

        # Replace invalid characters
        # Note U+0000 is dealt with in the tokenizer
        data = self.replaceCharactersRegexp.sub("\ufffd", data)

        data = data.replace("\r\n", "\n")
        data = data.replace("\r", "\n")

        self.chunk = data
        self.chunkSize = len(data)

        return True

    def characterErrorsUCS4(self, data):
        for i in range(len(invalid_unicode_re.findall(data))):
            self.errors.append("invalid-codepoint")

    def characterErrorsUCS2(self, data):
        # Someone picked the wrong compile option
        # You lose
        skip = False
        for match in invalid_unicode_re.finditer(data):
            if skip:
                continue
            codepoint = ord(match.group())
            pos = match.start()
            # Pretty sure there should be endianness issues here
            if utils.isSurrogatePair(data[pos:pos + 2]):
                # We have a surrogate pair!
                char_val = utils.surrogatePairToCodepoint(data[pos:pos + 2])
                if char_val in non_bmp_invalid_codepoints:
                    self.errors.append("invalid-codepoint")
                skip = True
            elif (codepoint >= 0xD800 and codepoint <= 0xDFFF and
                  pos == len(data) - 1):
                self.errors.append("invalid-codepoint")
            else:
                skip = False
                self.errors.append("invalid-codepoint")

    def charsUntil(self, characters, opposite=False):
        """ Returns a string of characters from the stream up to but not
        including any character in 'characters' or EOF. 'characters' must be
        a container that supports the 'in' method and iteration over its
        characters.
        """

        # Use a cache of regexps to find the required characters
        try:
            chars = charsUntilRegEx[(characters, opposite)]
        except KeyError:
            if __debug__:
                for c in characters:
                    assert(ord(c) < 128)
            regex = "".join(["\\x%02x" % ord(c) for c in characters])
            if not opposite:
                regex = "^%s" % regex
            chars = charsUntilRegEx[(characters, opposite)] = re.compile("[%s]+" % regex)

        rv = []

        while True:
            # Find the longest matching prefix
            m = chars.match(self.chunk, self.chunkOffset)
            if m is None:
                # If nothing matched, and it wasn't because we ran out of chunk,
                # then stop
                if self.chunkOffset != self.chunkSize:
                    break
            else:
                end = m.end()
                # If not the whole chunk matched, return everything
                # up to the part that didn't match
                if end != self.chunkSize:
                    rv.append(self.chunk[self.chunkOffset:end])
                    self.chunkOffset = end
                    break
            # If the whole remainder of the chunk matched,
            # use it all and read the next chunk
            rv.append(self.chunk[self.chunkOffset:])
            if not self.readChunk():
                # Reached EOF
                break

        r = "".join(rv)
        return r

    def unget(self, char):
        # Only one character is allowed to be ungotten at once - it must
        # be consumed again before any further call to unget
        if char is not None:
            if self.chunkOffset == 0:
                # unget is called quite rarely, so it's a good idea to do
                # more work here if it saves a bit of work in the frequently
                # called char and charsUntil.
                # So, just prepend the ungotten character onto the current
                # chunk:
                self.chunk = char + self.chunk
                self.chunkSize += 1
            else:
                self.chunkOffset -= 1
                assert self.chunk[self.chunkOffset] == char


class HTMLBinaryInputStream(HTMLUnicodeInputStream):
    """Provides a unicode stream of characters to the HTMLTokenizer.

    This class takes care of character encoding and removing or replacing
    incorrect byte-sequences and also provides column and line tracking.

    """

    def __init__(self, source, encoding=None, parseMeta=True, chardet=True):
        """Initialises the HTMLInputStream.

        HTMLInputStream(source, [encoding]) -> Normalized stream from source
        for use by html5lib.

        source can be either a file-object, local filename or a string.

        The optional encoding parameter must be a string that indicates
        the encoding.  If specified, that encoding will be used,
        regardless of any BOM or later declaration (such as in a meta
        element)

        parseMeta - Look for a <meta> element containing encoding information

        """
        # Raw Stream - for unicode objects this will encode to utf-8 and set
        #              self.charEncoding as appropriate
        self.rawStream = self.openStream(source)

        HTMLUnicodeInputStream.__init__(self, self.rawStream)

        self.charEncoding = (codecName(encoding), "certain")

        # Encoding Information
        # Number of bytes to use when looking for a meta element with
        # encoding information
        self.numBytesMeta = 512
        # Number of bytes to use when using detecting encoding using chardet
        self.numBytesChardet = 100
        # Encoding to use if no other information can be found
        self.defaultEncoding = "windows-1252"

        # Detect encoding iff no explicit "transport level" encoding is supplied
        if (self.charEncoding[0] is None):
            self.charEncoding = self.detectEncoding(parseMeta, chardet)

        # Call superclass
        self.reset()

    def reset(self):
        self.dataStream = codecs.getreader(self.charEncoding[0])(self.rawStream,
                                                                 'replace')
        HTMLUnicodeInputStream.reset(self)

    def openStream(self, source):
        """Produces a file object from source.

        source can be either a file object, local filename or a string.

        """
        # Already a file object
        if hasattr(source, 'read'):
            stream = source
        else:
            stream = BytesIO(source)

        try:
            stream.seek(stream.tell())
        except:
            stream = BufferedStream(stream)

        return stream

    def detectEncoding(self, parseMeta=True, chardet=True):
        # First look for a BOM
        # This will also read past the BOM if present
        encoding = self.detectBOM()
        confidence = "certain"
        # If there is no BOM need to look for meta elements with encoding
        # information
        if encoding is None and parseMeta:
            encoding = self.detectEncodingMeta()
            confidence = "tentative"
        # Guess with chardet, if avaliable
        if encoding is None and chardet:
            confidence = "tentative"
            try:
                try:
                    from charade.universaldetector import UniversalDetector
                except ImportError:
                    from chardet.universaldetector import UniversalDetector
                buffers = []
                detector = UniversalDetector()
                while not detector.done:
                    buffer = self.rawStream.read(self.numBytesChardet)
                    assert isinstance(buffer, bytes)
                    if not buffer:
                        break
                    buffers.append(buffer)
                    detector.feed(buffer)
                detector.close()
                encoding = detector.result['encoding']
                self.rawStream.seek(0)
            except ImportError:
                pass
        # If all else fails use the default encoding
        if encoding is None:
            confidence = "tentative"
            encoding = self.defaultEncoding

        # Substitute for equivalent encodings:
        encodingSub = {"iso-8859-1": "windows-1252"}

        if encoding.lower() in encodingSub:
            encoding = encodingSub[encoding.lower()]

        return encoding, confidence

    def changeEncoding(self, newEncoding):
        assert self.charEncoding[1] != "certain"
        newEncoding = codecName(newEncoding)
        if newEncoding in ("utf-16", "utf-16-be", "utf-16-le"):
            newEncoding = "utf-8"
        if newEncoding is None:
            return
        elif newEncoding == self.charEncoding[0]:
            self.charEncoding = (self.charEncoding[0], "certain")
        else:
            self.rawStream.seek(0)
            self.reset()
            self.charEncoding = (newEncoding, "certain")
            raise ReparseException("Encoding changed from %s to %s" % (self.charEncoding[0], newEncoding))

    def detectBOM(self):
        """Attempts to detect at BOM at the start of the stream. If
        an encoding can be determined from the BOM return the name of the
        encoding otherwise return None"""
        bomDict = {
            codecs.BOM_UTF8: 'utf-8',
            codecs.BOM_UTF16_LE: 'utf-16-le', codecs.BOM_UTF16_BE: 'utf-16-be',
            codecs.BOM_UTF32_LE: 'utf-32-le', codecs.BOM_UTF32_BE: 'utf-32-be'
        }

        # Go to beginning of file and read in 4 bytes
        string = self.rawStream.read(4)
        assert isinstance(string, bytes)

        # Try detecting the BOM using bytes from the string
        encoding = bomDict.get(string[:3])         # UTF-8
        seek = 3
        if not encoding:
            # Need to detect UTF-32 before UTF-16
            encoding = bomDict.get(string)         # UTF-32
            seek = 4
            if not encoding:
                encoding = bomDict.get(string[:2])  # UTF-16
                seek = 2

        # Set the read position past the BOM if one was found, otherwise
        # set it to the start of the stream
        self.rawStream.seek(encoding and seek or 0)

        return encoding

    def detectEncodingMeta(self):
        """Report the encoding declared by the meta element
        """
        buffer = self.rawStream.read(self.numBytesMeta)
        assert isinstance(buffer, bytes)
        parser = EncodingParser(buffer)
        self.rawStream.seek(0)
        encoding = parser.getEncoding()

        if encoding in ("utf-16", "utf-16-be", "utf-16-le"):
            encoding = "utf-8"

        return encoding


class EncodingBytes(bytes):
    """String-like object with an associated position and various extra methods
    If the position is ever greater than the string length then an exception is
    raised"""
    def __new__(self, value):
        assert isinstance(value, bytes)
        return bytes.__new__(self, value.lower())

    def __init__(self, value):
        self._position = -1

    def __iter__(self):
        return self

    def __next__(self):
        p = self._position = self._position + 1
        if p >= len(self):
            raise StopIteration
        elif p < 0:
            raise TypeError
        return self[p:p + 1]

    def next(self):
        # Py2 compat
        return self.__next__()

    def previous(self):
        p = self._position
        if p >= len(self):
            raise StopIteration
        elif p < 0:
            raise TypeError
        self._position = p = p - 1
        return self[p:p + 1]

    def setPosition(self, position):
        if self._position >= len(self):
            raise StopIteration
        self._position = position

    def getPosition(self):
        if self._position >= len(self):
            raise StopIteration
        if self._position >= 0:
            return self._position
        else:
            return None

    position = property(getPosition, setPosition)

    def getCurrentByte(self):
        return self[self.position:self.position + 1]

    currentByte = property(getCurrentByte)

    def skip(self, chars=spaceCharactersBytes):
        """Skip past a list of characters"""
        p = self.position               # use property for the error-checking
        while p < len(self):
            c = self[p:p + 1]
            if c not in chars:
                self._position = p
                return c
            p += 1
        self._position = p
        return None

    def skipUntil(self, chars):
        p = self.position
        while p < len(self):
            c = self[p:p + 1]
            if c in chars:
                self._position = p
                return c
            p += 1
        self._position = p
        return None

    def matchBytes(self, bytes):
        """Look for a sequence of bytes at the start of a string. If the bytes
        are found return True and advance the position to the byte after the
        match. Otherwise return False and leave the position alone"""
        p = self.position
        data = self[p:p + len(bytes)]
        rv = data.startswith(bytes)
        if rv:
            self.position += len(bytes)
        return rv

    def jumpTo(self, bytes):
        """Look for the next sequence of bytes matching a given sequence. If
        a match is found advance the position to the last byte of the match"""
        newPosition = self[self.position:].find(bytes)
        if newPosition > -1:
            # XXX: This is ugly, but I can't see a nicer way to fix this.
            if self._position == -1:
                self._position = 0
            self._position += (newPosition + len(bytes) - 1)
            return True
        else:
            raise StopIteration


class EncodingParser(object):
    """Mini parser for detecting character encoding from meta elements"""

    def __init__(self, data):
        """string - the data to work on for encoding detection"""
        self.data = EncodingBytes(data)
        self.encoding = None

    def getEncoding(self):
        methodDispatch = (
            (b"<!--", self.handleComment),
            (b"<meta", self.handleMeta),
            (b"</", self.handlePossibleEndTag),
            (b"<!", self.handleOther),
            (b"<?", self.handleOther),
            (b"<", self.handlePossibleStartTag))
        for byte in self.data:
            keepParsing = True
            for key, method in methodDispatch:
                if self.data.matchBytes(key):
                    try:
                        keepParsing = method()
                        break
                    except StopIteration:
                        keepParsing = False
                        break
            if not keepParsing:
                break

        return self.encoding

    def handleComment(self):
        """Skip over comments"""
        return self.data.jumpTo(b"-->")

    def handleMeta(self):
        if self.data.currentByte not in spaceCharactersBytes:
            # if we have <meta not followed by a space so just keep going
            return True
        # We have a valid meta element we want to search for attributes
        hasPragma = False
        pendingEncoding = None
        while True:
            # Try to find the next attribute after the current position
            attr = self.getAttribute()
            if attr is None:
                return True
            else:
                if attr[0] == b"http-equiv":
                    hasPragma = attr[1] == b"content-type"
                    if hasPragma and pendingEncoding is not None:
                        self.encoding = pendingEncoding
                        return False
                elif attr[0] == b"charset":
                    tentativeEncoding = attr[1]
                    codec = codecName(tentativeEncoding)
                    if codec is not None:
                        self.encoding = codec
                        return False
                elif attr[0] == b"content":
                    contentParser = ContentAttrParser(EncodingBytes(attr[1]))
                    tentativeEncoding = contentParser.parse()
                    if tentativeEncoding is not None:
                        codec = codecName(tentativeEncoding)
                        if codec is not None:
                            if hasPragma:
                                self.encoding = codec
                                return False
                            else:
                                pendingEncoding = codec

    def handlePossibleStartTag(self):
        return self.handlePossibleTag(False)

    def handlePossibleEndTag(self):
        next(self.data)
        return self.handlePossibleTag(True)

    def handlePossibleTag(self, endTag):
        data = self.data
        if data.currentByte not in asciiLettersBytes:
            # If the next byte is not an ascii letter either ignore this
            # fragment (possible start tag case) or treat it according to
            # handleOther
            if endTag:
                data.previous()
                self.handleOther()
            return True

        c = data.skipUntil(spacesAngleBrackets)
        if c == b"<":
            # return to the first step in the overall "two step" algorithm
            # reprocessing the < byte
            data.previous()
        else:
            # Read all attributes
            attr = self.getAttribute()
            while attr is not None:
                attr = self.getAttribute()
        return True

    def handleOther(self):
        return self.data.jumpTo(b">")

    def getAttribute(self):
        """Return a name,value pair for the next attribute in the stream,
        if one is found, or None"""
        data = self.data
        # Step 1 (skip chars)
        c = data.skip(spaceCharactersBytes | frozenset([b"/"]))
        assert c is None or len(c) == 1
        # Step 2
        if c in (b">", None):
            return None
        # Step 3
        attrName = []
        attrValue = []
        # Step 4 attribute name
        while True:
            if c == b"=" and attrName:
                break
            elif c in spaceCharactersBytes:
                # Step 6!
                c = data.skip()
                break
            elif c in (b"/", b">"):
                return b"".join(attrName), b""
            elif c in asciiUppercaseBytes:
                attrName.append(c.lower())
            elif c is None:
                return None
            else:
                attrName.append(c)
            # Step 5
            c = next(data)
        # Step 7
        if c != b"=":
            data.previous()
            return b"".join(attrName), b""
        # Step 8
        next(data)
        # Step 9
        c = data.skip()
        # Step 10
        if c in (b"'", b'"'):
            # 10.1
            quoteChar = c
            while True:
                # 10.2
                c = next(data)
                # 10.3
                if c == quoteChar:
                    next(data)
                    return b"".join(attrName), b"".join(attrValue)
                # 10.4
                elif c in asciiUppercaseBytes:
                    attrValue.append(c.lower())
                # 10.5
                else:
                    attrValue.append(c)
        elif c == b">":
            return b"".join(attrName), b""
        elif c in asciiUppercaseBytes:
            attrValue.append(c.lower())
        elif c is None:
            return None
        else:
            attrValue.append(c)
        # Step 11
        while True:
            c = next(data)
            if c in spacesAngleBrackets:
                return b"".join(attrName), b"".join(attrValue)
            elif c in asciiUppercaseBytes:
                attrValue.append(c.lower())
            elif c is None:
                return None
            else:
                attrValue.append(c)


class ContentAttrParser(object):
    def __init__(self, data):
        assert isinstance(data, bytes)
        self.data = data

    def parse(self):
        try:
            # Check if the attr name is charset
            # otherwise return
            self.data.jumpTo(b"charset")
            self.data.position += 1
            self.data.skip()
            if not self.data.currentByte == b"=":
                # If there is no = sign keep looking for attrs
                return None
            self.data.position += 1
            self.data.skip()
            # Look for an encoding between matching quote marks
            if self.data.currentByte in (b'"', b"'"):
                quoteMark = self.data.currentByte
                self.data.position += 1
                oldPosition = self.data.position
                if self.data.jumpTo(quoteMark):
                    return self.data[oldPosition:self.data.position]
                else:
                    return None
            else:
                # Unquoted value
                oldPosition = self.data.position
                try:
                    self.data.skipUntil(spaceCharactersBytes)
                    return self.data[oldPosition:self.data.position]
                except StopIteration:
                    # Return the whole remaining value
                    return self.data[oldPosition:]
        except StopIteration:
            return None


def codecName(encoding):
    """Return the python codec name corresponding to an encoding or None if the
    string doesn't correspond to a valid encoding."""
    if isinstance(encoding, bytes):
        try:
            encoding = encoding.decode("ascii")
        except UnicodeDecodeError:
            return None
    if encoding:
        canonicalName = ascii_punctuation_re.sub("", encoding).lower()
        return encodings.get(canonicalName, None)
    else:
        return None

########NEW FILE########
__FILENAME__ = sanitizer
from __future__ import absolute_import, division, unicode_literals

import re
from xml.sax.saxutils import escape, unescape

from .tokenizer import HTMLTokenizer
from .constants import tokenTypes


class HTMLSanitizerMixin(object):
    """ sanitization of XHTML+MathML+SVG and of inline style attributes."""

    acceptable_elements = ['a', 'abbr', 'acronym', 'address', 'area',
                           'article', 'aside', 'audio', 'b', 'big', 'blockquote', 'br', 'button',
                           'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup',
                           'command', 'datagrid', 'datalist', 'dd', 'del', 'details', 'dfn',
                           'dialog', 'dir', 'div', 'dl', 'dt', 'em', 'event-source', 'fieldset',
                           'figcaption', 'figure', 'footer', 'font', 'form', 'header', 'h1',
                           'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'input', 'ins',
                           'keygen', 'kbd', 'label', 'legend', 'li', 'm', 'map', 'menu', 'meter',
                           'multicol', 'nav', 'nextid', 'ol', 'output', 'optgroup', 'option',
                           'p', 'pre', 'progress', 'q', 's', 'samp', 'section', 'select',
                           'small', 'sound', 'source', 'spacer', 'span', 'strike', 'strong',
                           'sub', 'sup', 'table', 'tbody', 'td', 'textarea', 'time', 'tfoot',
                           'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'video']

    mathml_elements = ['maction', 'math', 'merror', 'mfrac', 'mi',
                       'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom',
                       'mprescripts', 'mroot', 'mrow', 'mspace', 'msqrt', 'mstyle', 'msub',
                       'msubsup', 'msup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder',
                       'munderover', 'none']

    svg_elements = ['a', 'animate', 'animateColor', 'animateMotion',
                    'animateTransform', 'clipPath', 'circle', 'defs', 'desc', 'ellipse',
                    'font-face', 'font-face-name', 'font-face-src', 'g', 'glyph', 'hkern',
                    'linearGradient', 'line', 'marker', 'metadata', 'missing-glyph',
                    'mpath', 'path', 'polygon', 'polyline', 'radialGradient', 'rect',
                    'set', 'stop', 'svg', 'switch', 'text', 'title', 'tspan', 'use']

    acceptable_attributes = ['abbr', 'accept', 'accept-charset', 'accesskey',
                             'action', 'align', 'alt', 'autocomplete', 'autofocus', 'axis',
                             'background', 'balance', 'bgcolor', 'bgproperties', 'border',
                             'bordercolor', 'bordercolordark', 'bordercolorlight', 'bottompadding',
                             'cellpadding', 'cellspacing', 'ch', 'challenge', 'char', 'charoff',
                             'choff', 'charset', 'checked', 'cite', 'class', 'clear', 'color',
                             'cols', 'colspan', 'compact', 'contenteditable', 'controls', 'coords',
                             'data', 'datafld', 'datapagesize', 'datasrc', 'datetime', 'default',
                             'delay', 'dir', 'disabled', 'draggable', 'dynsrc', 'enctype', 'end',
                             'face', 'for', 'form', 'frame', 'galleryimg', 'gutter', 'headers',
                             'height', 'hidefocus', 'hidden', 'high', 'href', 'hreflang', 'hspace',
                             'icon', 'id', 'inputmode', 'ismap', 'keytype', 'label', 'leftspacing',
                             'lang', 'list', 'longdesc', 'loop', 'loopcount', 'loopend',
                             'loopstart', 'low', 'lowsrc', 'max', 'maxlength', 'media', 'method',
                             'min', 'multiple', 'name', 'nohref', 'noshade', 'nowrap', 'open',
                             'optimum', 'pattern', 'ping', 'point-size', 'poster', 'pqg', 'preload',
                             'prompt', 'radiogroup', 'readonly', 'rel', 'repeat-max', 'repeat-min',
                             'replace', 'required', 'rev', 'rightspacing', 'rows', 'rowspan',
                             'rules', 'scope', 'selected', 'shape', 'size', 'span', 'src', 'start',
                             'step', 'style', 'summary', 'suppress', 'tabindex', 'target',
                             'template', 'title', 'toppadding', 'type', 'unselectable', 'usemap',
                             'urn', 'valign', 'value', 'variable', 'volume', 'vspace', 'vrml',
                             'width', 'wrap', 'xml:lang']

    mathml_attributes = ['actiontype', 'align', 'columnalign', 'columnalign',
                         'columnalign', 'columnlines', 'columnspacing', 'columnspan', 'depth',
                         'display', 'displaystyle', 'equalcolumns', 'equalrows', 'fence',
                         'fontstyle', 'fontweight', 'frame', 'height', 'linethickness', 'lspace',
                         'mathbackground', 'mathcolor', 'mathvariant', 'mathvariant', 'maxsize',
                         'minsize', 'other', 'rowalign', 'rowalign', 'rowalign', 'rowlines',
                         'rowspacing', 'rowspan', 'rspace', 'scriptlevel', 'selection',
                         'separator', 'stretchy', 'width', 'width', 'xlink:href', 'xlink:show',
                         'xlink:type', 'xmlns', 'xmlns:xlink']

    svg_attributes = ['accent-height', 'accumulate', 'additive', 'alphabetic',
                      'arabic-form', 'ascent', 'attributeName', 'attributeType',
                      'baseProfile', 'bbox', 'begin', 'by', 'calcMode', 'cap-height',
                      'class', 'clip-path', 'color', 'color-rendering', 'content', 'cx',
                      'cy', 'd', 'dx', 'dy', 'descent', 'display', 'dur', 'end', 'fill',
                      'fill-opacity', 'fill-rule', 'font-family', 'font-size',
                      'font-stretch', 'font-style', 'font-variant', 'font-weight', 'from',
                      'fx', 'fy', 'g1', 'g2', 'glyph-name', 'gradientUnits', 'hanging',
                      'height', 'horiz-adv-x', 'horiz-origin-x', 'id', 'ideographic', 'k',
                      'keyPoints', 'keySplines', 'keyTimes', 'lang', 'marker-end',
                      'marker-mid', 'marker-start', 'markerHeight', 'markerUnits',
                      'markerWidth', 'mathematical', 'max', 'min', 'name', 'offset',
                      'opacity', 'orient', 'origin', 'overline-position',
                      'overline-thickness', 'panose-1', 'path', 'pathLength', 'points',
                      'preserveAspectRatio', 'r', 'refX', 'refY', 'repeatCount',
                      'repeatDur', 'requiredExtensions', 'requiredFeatures', 'restart',
                      'rotate', 'rx', 'ry', 'slope', 'stemh', 'stemv', 'stop-color',
                      'stop-opacity', 'strikethrough-position', 'strikethrough-thickness',
                      'stroke', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap',
                      'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity',
                      'stroke-width', 'systemLanguage', 'target', 'text-anchor', 'to',
                      'transform', 'type', 'u1', 'u2', 'underline-position',
                      'underline-thickness', 'unicode', 'unicode-range', 'units-per-em',
                      'values', 'version', 'viewBox', 'visibility', 'width', 'widths', 'x',
                      'x-height', 'x1', 'x2', 'xlink:actuate', 'xlink:arcrole',
                      'xlink:href', 'xlink:role', 'xlink:show', 'xlink:title', 'xlink:type',
                      'xml:base', 'xml:lang', 'xml:space', 'xmlns', 'xmlns:xlink', 'y',
                      'y1', 'y2', 'zoomAndPan']

    attr_val_is_uri = ['href', 'src', 'cite', 'action', 'longdesc', 'poster',
                       'xlink:href', 'xml:base']

    svg_attr_val_allows_ref = ['clip-path', 'color-profile', 'cursor', 'fill',
                               'filter', 'marker', 'marker-start', 'marker-mid', 'marker-end',
                               'mask', 'stroke']

    svg_allow_local_href = ['altGlyph', 'animate', 'animateColor',
                            'animateMotion', 'animateTransform', 'cursor', 'feImage', 'filter',
                            'linearGradient', 'pattern', 'radialGradient', 'textpath', 'tref',
                            'set', 'use']

    acceptable_css_properties = ['azimuth', 'background-color',
                                 'border-bottom-color', 'border-collapse', 'border-color',
                                 'border-left-color', 'border-right-color', 'border-top-color', 'clear',
                                 'color', 'cursor', 'direction', 'display', 'elevation', 'float', 'font',
                                 'font-family', 'font-size', 'font-style', 'font-variant', 'font-weight',
                                 'height', 'letter-spacing', 'line-height', 'overflow', 'pause',
                                 'pause-after', 'pause-before', 'pitch', 'pitch-range', 'richness',
                                 'speak', 'speak-header', 'speak-numeral', 'speak-punctuation',
                                 'speech-rate', 'stress', 'text-align', 'text-decoration', 'text-indent',
                                 'unicode-bidi', 'vertical-align', 'voice-family', 'volume',
                                 'white-space', 'width']

    acceptable_css_keywords = ['auto', 'aqua', 'black', 'block', 'blue',
                               'bold', 'both', 'bottom', 'brown', 'center', 'collapse', 'dashed',
                               'dotted', 'fuchsia', 'gray', 'green', '!important', 'italic', 'left',
                               'lime', 'maroon', 'medium', 'none', 'navy', 'normal', 'nowrap', 'olive',
                               'pointer', 'purple', 'red', 'right', 'solid', 'silver', 'teal', 'top',
                               'transparent', 'underline', 'white', 'yellow']

    acceptable_svg_properties = ['fill', 'fill-opacity', 'fill-rule',
                                 'stroke', 'stroke-width', 'stroke-linecap', 'stroke-linejoin',
                                 'stroke-opacity']

    acceptable_protocols = ['ed2k', 'ftp', 'http', 'https', 'irc',
                            'mailto', 'news', 'gopher', 'nntp', 'telnet', 'webcal',
                            'xmpp', 'callto', 'feed', 'urn', 'aim', 'rsync', 'tag',
                            'ssh', 'sftp', 'rtsp', 'afs']

    # subclasses may define their own versions of these constants
    allowed_elements = acceptable_elements + mathml_elements + svg_elements
    allowed_attributes = acceptable_attributes + mathml_attributes + svg_attributes
    allowed_css_properties = acceptable_css_properties
    allowed_css_keywords = acceptable_css_keywords
    allowed_svg_properties = acceptable_svg_properties
    allowed_protocols = acceptable_protocols

    # Sanitize the +html+, escaping all elements not in ALLOWED_ELEMENTS, and
    # stripping out all # attributes not in ALLOWED_ATTRIBUTES. Style
    # attributes are parsed, and a restricted set, # specified by
    # ALLOWED_CSS_PROPERTIES and ALLOWED_CSS_KEYWORDS, are allowed through.
    # attributes in ATTR_VAL_IS_URI are scanned, and only URI schemes specified
    # in ALLOWED_PROTOCOLS are allowed.
    #
    #   sanitize_html('<script> do_nasty_stuff() </script>')
    #    => &lt;script> do_nasty_stuff() &lt;/script>
    #   sanitize_html('<a href="javascript: sucker();">Click here for $100</a>')
    #    => <a>Click here for $100</a>
    def sanitize_token(self, token):

        # accommodate filters which use token_type differently
        token_type = token["type"]
        if token_type in list(tokenTypes.keys()):
            token_type = tokenTypes[token_type]

        if token_type in (tokenTypes["StartTag"], tokenTypes["EndTag"],
                          tokenTypes["EmptyTag"]):
            if token["name"] in self.allowed_elements:
                return self.allowed_token(token, token_type)
            else:
                return self.disallowed_token(token, token_type)
        elif token_type == tokenTypes["Comment"]:
            pass
        else:
            return token

    def allowed_token(self, token, token_type):
        if "data" in token:
            attrs = dict([(name, val) for name, val in
                          token["data"][::-1]
                          if name in self.allowed_attributes])
            for attr in self.attr_val_is_uri:
                if attr not in attrs:
                    continue
                val_unescaped = re.sub("[`\000-\040\177-\240\s]+", '',
                                       unescape(attrs[attr])).lower()
                # remove replacement characters from unescaped characters
                val_unescaped = val_unescaped.replace("\ufffd", "")
                if (re.match("^[a-z0-9][-+.a-z0-9]*:", val_unescaped) and
                    (val_unescaped.split(':')[0] not in
                     self.allowed_protocols)):
                    del attrs[attr]
            for attr in self.svg_attr_val_allows_ref:
                if attr in attrs:
                    attrs[attr] = re.sub(r'url\s*\(\s*[^#\s][^)]+?\)',
                                         ' ',
                                         unescape(attrs[attr]))
            if (token["name"] in self.svg_allow_local_href and
                'xlink:href' in attrs and re.search('^\s*[^#\s].*',
                                                    attrs['xlink:href'])):
                del attrs['xlink:href']
            if 'style' in attrs:
                attrs['style'] = self.sanitize_css(attrs['style'])
            token["data"] = [[name, val] for name, val in list(attrs.items())]
        return token

    def disallowed_token(self, token, token_type):
        if token_type == tokenTypes["EndTag"]:
            token["data"] = "</%s>" % token["name"]
        elif token["data"]:
            attrs = ''.join([' %s="%s"' % (k, escape(v)) for k, v in token["data"]])
            token["data"] = "<%s%s>" % (token["name"], attrs)
        else:
            token["data"] = "<%s>" % token["name"]
        if token.get("selfClosing"):
            token["data"] = token["data"][:-1] + "/>"

        if token["type"] in list(tokenTypes.keys()):
            token["type"] = "Characters"
        else:
            token["type"] = tokenTypes["Characters"]

        del token["name"]
        return token

    def sanitize_css(self, style):
        # disallow urls
        style = re.compile('url\s*\(\s*[^\s)]+?\s*\)\s*').sub(' ', style)

        # gauntlet
        if not re.match("""^([:,;#%.\sa-zA-Z0-9!]|\w-\w|'[\s\w]+'|"[\s\w]+"|\([\d,\s]+\))*$""", style):
            return ''
        if not re.match("^\s*([-\w]+\s*:[^:;]*(;\s*|$))*$", style):
            return ''

        clean = []
        for prop, value in re.findall("([-\w]+)\s*:\s*([^:;]*)", style):
            if not value:
                continue
            if prop.lower() in self.allowed_css_properties:
                clean.append(prop + ': ' + value + ';')
            elif prop.split('-')[0].lower() in ['background', 'border', 'margin',
                                                'padding']:
                for keyword in value.split():
                    if not keyword in self.acceptable_css_keywords and \
                            not re.match("^(#[0-9a-f]+|rgb\(\d+%?,\d*%?,?\d*%?\)?|\d{0,2}\.?\d{0,2}(cm|em|ex|in|mm|pc|pt|px|%|,|\))?)$", keyword):
                        break
                else:
                    clean.append(prop + ': ' + value + ';')
            elif prop.lower() in self.allowed_svg_properties:
                clean.append(prop + ': ' + value + ';')

        return ' '.join(clean)


class HTMLSanitizer(HTMLTokenizer, HTMLSanitizerMixin):
    def __init__(self, stream, encoding=None, parseMeta=True, useChardet=True,
                 lowercaseElementName=False, lowercaseAttrName=False, parser=None):
        # Change case matching defaults as we only output lowercase html anyway
        # This solution doesn't seem ideal...
        HTMLTokenizer.__init__(self, stream, encoding, parseMeta, useChardet,
                               lowercaseElementName, lowercaseAttrName, parser=parser)

    def __iter__(self):
        for token in HTMLTokenizer.__iter__(self):
            token = self.sanitize_token(token)
            if token:
                yield token

########NEW FILE########
__FILENAME__ = htmlserializer
from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type

import gettext
_ = gettext.gettext

try:
    from functools import reduce
except ImportError:
    pass

from ..constants import voidElements, booleanAttributes, spaceCharacters
from ..constants import rcdataElements, entities, xmlEntities
from .. import utils
from xml.sax.saxutils import escape

spaceCharacters = "".join(spaceCharacters)

try:
    from codecs import register_error, xmlcharrefreplace_errors
except ImportError:
    unicode_encode_errors = "strict"
else:
    unicode_encode_errors = "htmlentityreplace"

    encode_entity_map = {}
    is_ucs4 = len("\U0010FFFF") == 1
    for k, v in list(entities.items()):
        # skip multi-character entities
        if ((is_ucs4 and len(v) > 1) or
                (not is_ucs4 and len(v) > 2)):
            continue
        if v != "&":
            if len(v) == 2:
                v = utils.surrogatePairToCodepoint(v)
            else:
                v = ord(v)
            if not v in encode_entity_map or k.islower():
                # prefer &lt; over &LT; and similarly for &amp;, &gt;, etc.
                encode_entity_map[v] = k

    def htmlentityreplace_errors(exc):
        if isinstance(exc, (UnicodeEncodeError, UnicodeTranslateError)):
            res = []
            codepoints = []
            skip = False
            for i, c in enumerate(exc.object[exc.start:exc.end]):
                if skip:
                    skip = False
                    continue
                index = i + exc.start
                if utils.isSurrogatePair(exc.object[index:min([exc.end, index + 2])]):
                    codepoint = utils.surrogatePairToCodepoint(exc.object[index:index + 2])
                    skip = True
                else:
                    codepoint = ord(c)
                codepoints.append(codepoint)
            for cp in codepoints:
                e = encode_entity_map.get(cp)
                if e:
                    res.append("&")
                    res.append(e)
                    if not e.endswith(";"):
                        res.append(";")
                else:
                    res.append("&#x%s;" % (hex(cp)[2:]))
            return ("".join(res), exc.end)
        else:
            return xmlcharrefreplace_errors(exc)

    register_error(unicode_encode_errors, htmlentityreplace_errors)

    del register_error


class HTMLSerializer(object):

    # attribute quoting options
    quote_attr_values = False
    quote_char = '"'
    use_best_quote_char = True

    # tag syntax options
    omit_optional_tags = True
    minimize_boolean_attributes = True
    use_trailing_solidus = False
    space_before_trailing_solidus = True

    # escaping options
    escape_lt_in_attrs = False
    escape_rcdata = False
    resolve_entities = True

    # miscellaneous options
    alphabetical_attributes = False
    inject_meta_charset = True
    strip_whitespace = False
    sanitize = False

    options = ("quote_attr_values", "quote_char", "use_best_quote_char",
               "omit_optional_tags", "minimize_boolean_attributes",
               "use_trailing_solidus", "space_before_trailing_solidus",
               "escape_lt_in_attrs", "escape_rcdata", "resolve_entities",
               "alphabetical_attributes", "inject_meta_charset",
               "strip_whitespace", "sanitize")

    def __init__(self, **kwargs):
        """Initialize HTMLSerializer.

        Keyword options (default given first unless specified) include:

        inject_meta_charset=True|False
          Whether it insert a meta element to define the character set of the
          document.
        quote_attr_values=True|False
          Whether to quote attribute values that don't require quoting
          per HTML5 parsing rules.
        quote_char=u'"'|u"'"
          Use given quote character for attribute quoting. Default is to
          use double quote unless attribute value contains a double quote,
          in which case single quotes are used instead.
        escape_lt_in_attrs=False|True
          Whether to escape < in attribute values.
        escape_rcdata=False|True
          Whether to escape characters that need to be escaped within normal
          elements within rcdata elements such as style.
        resolve_entities=True|False
          Whether to resolve named character entities that appear in the
          source tree. The XML predefined entities &lt; &gt; &amp; &quot; &apos;
          are unaffected by this setting.
        strip_whitespace=False|True
          Whether to remove semantically meaningless whitespace. (This
          compresses all whitespace to a single space except within pre.)
        minimize_boolean_attributes=True|False
          Shortens boolean attributes to give just the attribute value,
          for example <input disabled="disabled"> becomes <input disabled>.
        use_trailing_solidus=False|True
          Includes a close-tag slash at the end of the start tag of void
          elements (empty elements whose end tag is forbidden). E.g. <hr/>.
        space_before_trailing_solidus=True|False
          Places a space immediately before the closing slash in a tag
          using a trailing solidus. E.g. <hr />. Requires use_trailing_solidus.
        sanitize=False|True
          Strip all unsafe or unknown constructs from output.
          See `html5lib user documentation`_
        omit_optional_tags=True|False
          Omit start/end tags that are optional.
        alphabetical_attributes=False|True
          Reorder attributes to be in alphabetical order.

        .. _html5lib user documentation: http://code.google.com/p/html5lib/wiki/UserDocumentation
        """
        if 'quote_char' in kwargs:
            self.use_best_quote_char = False
        for attr in self.options:
            setattr(self, attr, kwargs.get(attr, getattr(self, attr)))
        self.errors = []
        self.strict = False

    def encode(self, string):
        assert(isinstance(string, text_type))
        if self.encoding:
            return string.encode(self.encoding, unicode_encode_errors)
        else:
            return string

    def encodeStrict(self, string):
        assert(isinstance(string, text_type))
        if self.encoding:
            return string.encode(self.encoding, "strict")
        else:
            return string

    def serialize(self, treewalker, encoding=None):
        self.encoding = encoding
        in_cdata = False
        self.errors = []

        if encoding and self.inject_meta_charset:
            from ..filters.inject_meta_charset import Filter
            treewalker = Filter(treewalker, encoding)
        # WhitespaceFilter should be used before OptionalTagFilter
        # for maximum efficiently of this latter filter
        if self.strip_whitespace:
            from ..filters.whitespace import Filter
            treewalker = Filter(treewalker)
        if self.sanitize:
            from ..filters.sanitizer import Filter
            treewalker = Filter(treewalker)
        if self.omit_optional_tags:
            from ..filters.optionaltags import Filter
            treewalker = Filter(treewalker)
        # Alphabetical attributes must be last, as other filters
        # could add attributes and alter the order
        if self.alphabetical_attributes:
            from ..filters.alphabeticalattributes import Filter
            treewalker = Filter(treewalker)

        for token in treewalker:
            type = token["type"]
            if type == "Doctype":
                doctype = "<!DOCTYPE %s" % token["name"]

                if token["publicId"]:
                    doctype += ' PUBLIC "%s"' % token["publicId"]
                elif token["systemId"]:
                    doctype += " SYSTEM"
                if token["systemId"]:
                    if token["systemId"].find('"') >= 0:
                        if token["systemId"].find("'") >= 0:
                            self.serializeError(_("System identifer contains both single and double quote characters"))
                        quote_char = "'"
                    else:
                        quote_char = '"'
                    doctype += " %s%s%s" % (quote_char, token["systemId"], quote_char)

                doctype += ">"
                yield self.encodeStrict(doctype)

            elif type in ("Characters", "SpaceCharacters"):
                if type == "SpaceCharacters" or in_cdata:
                    if in_cdata and token["data"].find("</") >= 0:
                        self.serializeError(_("Unexpected </ in CDATA"))
                    yield self.encode(token["data"])
                else:
                    yield self.encode(escape(token["data"]))

            elif type in ("StartTag", "EmptyTag"):
                name = token["name"]
                yield self.encodeStrict("<%s" % name)
                if name in rcdataElements and not self.escape_rcdata:
                    in_cdata = True
                elif in_cdata:
                    self.serializeError(_("Unexpected child element of a CDATA element"))
                for (attr_namespace, attr_name), attr_value in token["data"].items():
                    # TODO: Add namespace support here
                    k = attr_name
                    v = attr_value
                    yield self.encodeStrict(' ')

                    yield self.encodeStrict(k)
                    if not self.minimize_boolean_attributes or \
                        (k not in booleanAttributes.get(name, tuple())
                         and k not in booleanAttributes.get("", tuple())):
                        yield self.encodeStrict("=")
                        if self.quote_attr_values or not v:
                            quote_attr = True
                        else:
                            quote_attr = reduce(lambda x, y: x or (y in v),
                                                spaceCharacters + ">\"'=", False)
                        v = v.replace("&", "&amp;")
                        if self.escape_lt_in_attrs:
                            v = v.replace("<", "&lt;")
                        if quote_attr:
                            quote_char = self.quote_char
                            if self.use_best_quote_char:
                                if "'" in v and '"' not in v:
                                    quote_char = '"'
                                elif '"' in v and "'" not in v:
                                    quote_char = "'"
                            if quote_char == "'":
                                v = v.replace("'", "&#39;")
                            else:
                                v = v.replace('"', "&quot;")
                            yield self.encodeStrict(quote_char)
                            yield self.encode(v)
                            yield self.encodeStrict(quote_char)
                        else:
                            yield self.encode(v)
                if name in voidElements and self.use_trailing_solidus:
                    if self.space_before_trailing_solidus:
                        yield self.encodeStrict(" /")
                    else:
                        yield self.encodeStrict("/")
                yield self.encode(">")

            elif type == "EndTag":
                name = token["name"]
                if name in rcdataElements:
                    in_cdata = False
                elif in_cdata:
                    self.serializeError(_("Unexpected child element of a CDATA element"))
                yield self.encodeStrict("</%s>" % name)

            elif type == "Comment":
                data = token["data"]
                if data.find("--") >= 0:
                    self.serializeError(_("Comment contains --"))
                yield self.encodeStrict("<!--%s-->" % token["data"])

            elif type == "Entity":
                name = token["name"]
                key = name + ";"
                if not key in entities:
                    self.serializeError(_("Entity %s not recognized" % name))
                if self.resolve_entities and key not in xmlEntities:
                    data = entities[key]
                else:
                    data = "&%s;" % name
                yield self.encodeStrict(data)

            else:
                self.serializeError(token["data"])

    def render(self, treewalker, encoding=None):
        if encoding:
            return b"".join(list(self.serialize(treewalker, encoding)))
        else:
            return "".join(list(self.serialize(treewalker)))

    def serializeError(self, data="XXX ERROR MESSAGE NEEDED"):
        # XXX The idea is to make data mandatory.
        self.errors.append(data)
        if self.strict:
            raise SerializeError


def SerializeError(Exception):
    """Error in serialized tree"""
    pass

########NEW FILE########
__FILENAME__ = tokenizer
from __future__ import absolute_import, division, unicode_literals

try:
    chr = unichr # flake8: noqa
except NameError:
    pass

from collections import deque

from .constants import spaceCharacters
from .constants import entities
from .constants import asciiLetters, asciiUpper2Lower
from .constants import digits, hexDigits, EOF
from .constants import tokenTypes, tagTokenTypes
from .constants import replacementCharacters

from .inputstream import HTMLInputStream

from .trie import Trie

entitiesTrie = Trie(entities)


class HTMLTokenizer(object):
    """ This class takes care of tokenizing HTML.

    * self.currentToken
      Holds the token that is currently being processed.

    * self.state
      Holds a reference to the method to be invoked... XXX

    * self.stream
      Points to HTMLInputStream object.
    """

    def __init__(self, stream, encoding=None, parseMeta=True, useChardet=True,
                 lowercaseElementName=True, lowercaseAttrName=True, parser=None):

        self.stream = HTMLInputStream(stream, encoding, parseMeta, useChardet)
        self.parser = parser

        # Perform case conversions?
        self.lowercaseElementName = lowercaseElementName
        self.lowercaseAttrName = lowercaseAttrName

        # Setup the initial tokenizer state
        self.escapeFlag = False
        self.lastFourChars = []
        self.state = self.dataState
        self.escape = False

        # The current token being created
        self.currentToken = None
        super(HTMLTokenizer, self).__init__()

    def __iter__(self):
        """ This is where the magic happens.

        We do our usually processing through the states and when we have a token
        to return we yield the token which pauses processing until the next token
        is requested.
        """
        self.tokenQueue = deque([])
        # Start processing. When EOF is reached self.state will return False
        # instead of True and the loop will terminate.
        while self.state():
            while self.stream.errors:
                yield {"type": tokenTypes["ParseError"], "data": self.stream.errors.pop(0)}
            while self.tokenQueue:
                yield self.tokenQueue.popleft()

    def consumeNumberEntity(self, isHex):
        """This function returns either U+FFFD or the character based on the
        decimal or hexadecimal representation. It also discards ";" if present.
        If not present self.tokenQueue.append({"type": tokenTypes["ParseError"]}) is invoked.
        """

        allowed = digits
        radix = 10
        if isHex:
            allowed = hexDigits
            radix = 16

        charStack = []

        # Consume all the characters that are in range while making sure we
        # don't hit an EOF.
        c = self.stream.char()
        while c in allowed and c is not EOF:
            charStack.append(c)
            c = self.stream.char()

        # Convert the set of characters consumed to an int.
        charAsInt = int("".join(charStack), radix)

        # Certain characters get replaced with others
        if charAsInt in replacementCharacters:
            char = replacementCharacters[charAsInt]
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "illegal-codepoint-for-numeric-entity",
                                    "datavars": {"charAsInt": charAsInt}})
        elif ((0xD800 <= charAsInt <= 0xDFFF) or
              (charAsInt > 0x10FFFF)):
            char = "\uFFFD"
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "illegal-codepoint-for-numeric-entity",
                                    "datavars": {"charAsInt": charAsInt}})
        else:
            # Should speed up this check somehow (e.g. move the set to a constant)
            if ((0x0001 <= charAsInt <= 0x0008) or
                (0x000E <= charAsInt <= 0x001F) or
                (0x007F <= charAsInt <= 0x009F) or
                (0xFDD0 <= charAsInt <= 0xFDEF) or
                charAsInt in frozenset([0x000B, 0xFFFE, 0xFFFF, 0x1FFFE,
                                        0x1FFFF, 0x2FFFE, 0x2FFFF, 0x3FFFE,
                                        0x3FFFF, 0x4FFFE, 0x4FFFF, 0x5FFFE,
                                        0x5FFFF, 0x6FFFE, 0x6FFFF, 0x7FFFE,
                                        0x7FFFF, 0x8FFFE, 0x8FFFF, 0x9FFFE,
                                        0x9FFFF, 0xAFFFE, 0xAFFFF, 0xBFFFE,
                                        0xBFFFF, 0xCFFFE, 0xCFFFF, 0xDFFFE,
                                        0xDFFFF, 0xEFFFE, 0xEFFFF, 0xFFFFE,
                                        0xFFFFF, 0x10FFFE, 0x10FFFF])):
                self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                        "data":
                                        "illegal-codepoint-for-numeric-entity",
                                        "datavars": {"charAsInt": charAsInt}})
            try:
                # Try/except needed as UCS-2 Python builds' unichar only works
                # within the BMP.
                char = chr(charAsInt)
            except ValueError:
                v = charAsInt - 0x10000
                char = chr(0xD800 | (v >> 10)) + chr(0xDC00 | (v & 0x3FF))

        # Discard the ; if present. Otherwise, put it back on the queue and
        # invoke parseError on parser.
        if c != ";":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "numeric-entity-without-semicolon"})
            self.stream.unget(c)

        return char

    def consumeEntity(self, allowedChar=None, fromAttribute=False):
        # Initialise to the default output for when no entity is matched
        output = "&"

        charStack = [self.stream.char()]
        if (charStack[0] in spaceCharacters or charStack[0] in (EOF, "<", "&")
                or (allowedChar is not None and allowedChar == charStack[0])):
            self.stream.unget(charStack[0])

        elif charStack[0] == "#":
            # Read the next character to see if it's hex or decimal
            hex = False
            charStack.append(self.stream.char())
            if charStack[-1] in ("x", "X"):
                hex = True
                charStack.append(self.stream.char())

            # charStack[-1] should be the first digit
            if (hex and charStack[-1] in hexDigits) \
                    or (not hex and charStack[-1] in digits):
                # At least one digit found, so consume the whole number
                self.stream.unget(charStack[-1])
                output = self.consumeNumberEntity(hex)
            else:
                # No digits found
                self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                        "data": "expected-numeric-entity"})
                self.stream.unget(charStack.pop())
                output = "&" + "".join(charStack)

        else:
            # At this point in the process might have named entity. Entities
            # are stored in the global variable "entities".
            #
            # Consume characters and compare to these to a substring of the
            # entity names in the list until the substring no longer matches.
            while (charStack[-1] is not EOF):
                if not entitiesTrie.has_keys_with_prefix("".join(charStack)):
                    break
                charStack.append(self.stream.char())

            # At this point we have a string that starts with some characters
            # that may match an entity
            # Try to find the longest entity the string will match to take care
            # of &noti for instance.
            try:
                entityName = entitiesTrie.longest_prefix("".join(charStack[:-1]))
                entityLength = len(entityName)
            except KeyError:
                entityName = None

            if entityName is not None:
                if entityName[-1] != ";":
                    self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                            "named-entity-without-semicolon"})
                if (entityName[-1] != ";" and fromAttribute and
                    (charStack[entityLength] in asciiLetters or
                     charStack[entityLength] in digits or
                     charStack[entityLength] == "=")):
                    self.stream.unget(charStack.pop())
                    output = "&" + "".join(charStack)
                else:
                    output = entities[entityName]
                    self.stream.unget(charStack.pop())
                    output += "".join(charStack[entityLength:])
            else:
                self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                        "expected-named-entity"})
                self.stream.unget(charStack.pop())
                output = "&" + "".join(charStack)

        if fromAttribute:
            self.currentToken["data"][-1][1] += output
        else:
            if output in spaceCharacters:
                tokenType = "SpaceCharacters"
            else:
                tokenType = "Characters"
            self.tokenQueue.append({"type": tokenTypes[tokenType], "data": output})

    def processEntityInAttribute(self, allowedChar):
        """This method replaces the need for "entityInAttributeValueState".
        """
        self.consumeEntity(allowedChar=allowedChar, fromAttribute=True)

    def emitCurrentToken(self):
        """This method is a generic handler for emitting the tags. It also sets
        the state to "data" because that's what's needed after a token has been
        emitted.
        """
        token = self.currentToken
        # Add token to the queue to be yielded
        if (token["type"] in tagTokenTypes):
            if self.lowercaseElementName:
                token["name"] = token["name"].translate(asciiUpper2Lower)
            if token["type"] == tokenTypes["EndTag"]:
                if token["data"]:
                    self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                            "data": "attributes-in-end-tag"})
                if token["selfClosing"]:
                    self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                            "data": "self-closing-flag-on-end-tag"})
        self.tokenQueue.append(token)
        self.state = self.dataState

    # Below are the various tokenizer states worked out.
    def dataState(self):
        data = self.stream.char()
        if data == "&":
            self.state = self.entityDataState
        elif data == "<":
            self.state = self.tagOpenState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\u0000"})
        elif data is EOF:
            # Tokenization ends.
            return False
        elif data in spaceCharacters:
            # Directly after emitting a token you switch back to the "data
            # state". At that point spaceCharacters are important so they are
            # emitted separately.
            self.tokenQueue.append({"type": tokenTypes["SpaceCharacters"], "data":
                                    data + self.stream.charsUntil(spaceCharacters, True)})
            # No need to update lastFourChars here, since the first space will
            # have already been appended to lastFourChars and will have broken
            # any <!-- or --> sequences
        else:
            chars = self.stream.charsUntil(("&", "<", "\u0000"))
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data":
                                    data + chars})
        return True

    def entityDataState(self):
        self.consumeEntity()
        self.state = self.dataState
        return True

    def rcdataState(self):
        data = self.stream.char()
        if data == "&":
            self.state = self.characterReferenceInRcdata
        elif data == "<":
            self.state = self.rcdataLessThanSignState
        elif data == EOF:
            # Tokenization ends.
            return False
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
        elif data in spaceCharacters:
            # Directly after emitting a token you switch back to the "data
            # state". At that point spaceCharacters are important so they are
            # emitted separately.
            self.tokenQueue.append({"type": tokenTypes["SpaceCharacters"], "data":
                                    data + self.stream.charsUntil(spaceCharacters, True)})
            # No need to update lastFourChars here, since the first space will
            # have already been appended to lastFourChars and will have broken
            # any <!-- or --> sequences
        else:
            chars = self.stream.charsUntil(("&", "<", "\u0000"))
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data":
                                    data + chars})
        return True

    def characterReferenceInRcdata(self):
        self.consumeEntity()
        self.state = self.rcdataState
        return True

    def rawtextState(self):
        data = self.stream.char()
        if data == "<":
            self.state = self.rawtextLessThanSignState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
        elif data == EOF:
            # Tokenization ends.
            return False
        else:
            chars = self.stream.charsUntil(("<", "\u0000"))
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data":
                                    data + chars})
        return True

    def scriptDataState(self):
        data = self.stream.char()
        if data == "<":
            self.state = self.scriptDataLessThanSignState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
        elif data == EOF:
            # Tokenization ends.
            return False
        else:
            chars = self.stream.charsUntil(("<", "\u0000"))
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data":
                                    data + chars})
        return True

    def plaintextState(self):
        data = self.stream.char()
        if data == EOF:
            # Tokenization ends.
            return False
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data":
                                    data + self.stream.charsUntil("\u0000")})
        return True

    def tagOpenState(self):
        data = self.stream.char()
        if data == "!":
            self.state = self.markupDeclarationOpenState
        elif data == "/":
            self.state = self.closeTagOpenState
        elif data in asciiLetters:
            self.currentToken = {"type": tokenTypes["StartTag"],
                                 "name": data, "data": [],
                                 "selfClosing": False,
                                 "selfClosingAcknowledged": False}
            self.state = self.tagNameState
        elif data == ">":
            # XXX In theory it could be something besides a tag name. But
            # do we really care?
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-tag-name-but-got-right-bracket"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<>"})
            self.state = self.dataState
        elif data == "?":
            # XXX In theory it could be something besides a tag name. But
            # do we really care?
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-tag-name-but-got-question-mark"})
            self.stream.unget(data)
            self.state = self.bogusCommentState
        else:
            # XXX
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-tag-name"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.stream.unget(data)
            self.state = self.dataState
        return True

    def closeTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.currentToken = {"type": tokenTypes["EndTag"], "name": data,
                                 "data": [], "selfClosing": False}
            self.state = self.tagNameState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-closing-tag-but-got-right-bracket"})
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-closing-tag-but-got-eof"})
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "</"})
            self.state = self.dataState
        else:
            # XXX data can be _'_...
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-closing-tag-but-got-char",
                                    "datavars": {"data": data}})
            self.stream.unget(data)
            self.state = self.bogusCommentState
        return True

    def tagNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeAttributeNameState
        elif data == ">":
            self.emitCurrentToken()
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-tag-name"})
            self.state = self.dataState
        elif data == "/":
            self.state = self.selfClosingStartTagState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["name"] += "\uFFFD"
        else:
            self.currentToken["name"] += data
            # (Don't use charsUntil here, because tag names are
            # very short and it's faster to not do anything fancy)
        return True

    def rcdataLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.temporaryBuffer = ""
            self.state = self.rcdataEndTagOpenState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.stream.unget(data)
            self.state = self.rcdataState
        return True

    def rcdataEndTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.temporaryBuffer += data
            self.state = self.rcdataEndTagNameState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "</"})
            self.stream.unget(data)
            self.state = self.rcdataState
        return True

    def rcdataEndTagNameState(self):
        appropriate = self.currentToken and self.currentToken["name"].lower() == self.temporaryBuffer.lower()
        data = self.stream.char()
        if data in spaceCharacters and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.beforeAttributeNameState
        elif data == "/" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.selfClosingStartTagState
        elif data == ">" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.emitCurrentToken()
            self.state = self.dataState
        elif data in asciiLetters:
            self.temporaryBuffer += data
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "</" + self.temporaryBuffer})
            self.stream.unget(data)
            self.state = self.rcdataState
        return True

    def rawtextLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.temporaryBuffer = ""
            self.state = self.rawtextEndTagOpenState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.stream.unget(data)
            self.state = self.rawtextState
        return True

    def rawtextEndTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.temporaryBuffer += data
            self.state = self.rawtextEndTagNameState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "</"})
            self.stream.unget(data)
            self.state = self.rawtextState
        return True

    def rawtextEndTagNameState(self):
        appropriate = self.currentToken and self.currentToken["name"].lower() == self.temporaryBuffer.lower()
        data = self.stream.char()
        if data in spaceCharacters and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.beforeAttributeNameState
        elif data == "/" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.selfClosingStartTagState
        elif data == ">" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.emitCurrentToken()
            self.state = self.dataState
        elif data in asciiLetters:
            self.temporaryBuffer += data
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "</" + self.temporaryBuffer})
            self.stream.unget(data)
            self.state = self.rawtextState
        return True

    def scriptDataLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.temporaryBuffer = ""
            self.state = self.scriptDataEndTagOpenState
        elif data == "!":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<!"})
            self.state = self.scriptDataEscapeStartState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True

    def scriptDataEndTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.temporaryBuffer += data
            self.state = self.scriptDataEndTagNameState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "</"})
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True

    def scriptDataEndTagNameState(self):
        appropriate = self.currentToken and self.currentToken["name"].lower() == self.temporaryBuffer.lower()
        data = self.stream.char()
        if data in spaceCharacters and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.beforeAttributeNameState
        elif data == "/" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.selfClosingStartTagState
        elif data == ">" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.emitCurrentToken()
            self.state = self.dataState
        elif data in asciiLetters:
            self.temporaryBuffer += data
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "</" + self.temporaryBuffer})
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True

    def scriptDataEscapeStartState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
            self.state = self.scriptDataEscapeStartDashState
        else:
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True

    def scriptDataEscapeStartDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
            self.state = self.scriptDataEscapedDashDashState
        else:
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True

    def scriptDataEscapedState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
            self.state = self.scriptDataEscapedDashState
        elif data == "<":
            self.state = self.scriptDataEscapedLessThanSignState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
        elif data == EOF:
            self.state = self.dataState
        else:
            chars = self.stream.charsUntil(("<", "-", "\u0000"))
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data":
                                    data + chars})
        return True

    def scriptDataEscapedDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
            self.state = self.scriptDataEscapedDashDashState
        elif data == "<":
            self.state = self.scriptDataEscapedLessThanSignState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
            self.state = self.scriptDataEscapedState
        elif data == EOF:
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.state = self.scriptDataEscapedState
        return True

    def scriptDataEscapedDashDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
        elif data == "<":
            self.state = self.scriptDataEscapedLessThanSignState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": ">"})
            self.state = self.scriptDataState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
            self.state = self.scriptDataEscapedState
        elif data == EOF:
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.state = self.scriptDataEscapedState
        return True

    def scriptDataEscapedLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.temporaryBuffer = ""
            self.state = self.scriptDataEscapedEndTagOpenState
        elif data in asciiLetters:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<" + data})
            self.temporaryBuffer = data
            self.state = self.scriptDataDoubleEscapeStartState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.stream.unget(data)
            self.state = self.scriptDataEscapedState
        return True

    def scriptDataEscapedEndTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.temporaryBuffer = data
            self.state = self.scriptDataEscapedEndTagNameState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "</"})
            self.stream.unget(data)
            self.state = self.scriptDataEscapedState
        return True

    def scriptDataEscapedEndTagNameState(self):
        appropriate = self.currentToken and self.currentToken["name"].lower() == self.temporaryBuffer.lower()
        data = self.stream.char()
        if data in spaceCharacters and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.beforeAttributeNameState
        elif data == "/" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.selfClosingStartTagState
        elif data == ">" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.emitCurrentToken()
            self.state = self.dataState
        elif data in asciiLetters:
            self.temporaryBuffer += data
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "</" + self.temporaryBuffer})
            self.stream.unget(data)
            self.state = self.scriptDataEscapedState
        return True

    def scriptDataDoubleEscapeStartState(self):
        data = self.stream.char()
        if data in (spaceCharacters | frozenset(("/", ">"))):
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            if self.temporaryBuffer.lower() == "script":
                self.state = self.scriptDataDoubleEscapedState
            else:
                self.state = self.scriptDataEscapedState
        elif data in asciiLetters:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.temporaryBuffer += data
        else:
            self.stream.unget(data)
            self.state = self.scriptDataEscapedState
        return True

    def scriptDataDoubleEscapedState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
            self.state = self.scriptDataDoubleEscapedDashState
        elif data == "<":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.state = self.scriptDataDoubleEscapedLessThanSignState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
        elif data == EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-script-in-script"})
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
        return True

    def scriptDataDoubleEscapedDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
            self.state = self.scriptDataDoubleEscapedDashDashState
        elif data == "<":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.state = self.scriptDataDoubleEscapedLessThanSignState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
            self.state = self.scriptDataDoubleEscapedState
        elif data == EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-script-in-script"})
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.state = self.scriptDataDoubleEscapedState
        return True

    def scriptDataDoubleEscapedDashDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
        elif data == "<":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.state = self.scriptDataDoubleEscapedLessThanSignState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": ">"})
            self.state = self.scriptDataState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
            self.state = self.scriptDataDoubleEscapedState
        elif data == EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-script-in-script"})
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.state = self.scriptDataDoubleEscapedState
        return True

    def scriptDataDoubleEscapedLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "/"})
            self.temporaryBuffer = ""
            self.state = self.scriptDataDoubleEscapeEndState
        else:
            self.stream.unget(data)
            self.state = self.scriptDataDoubleEscapedState
        return True

    def scriptDataDoubleEscapeEndState(self):
        data = self.stream.char()
        if data in (spaceCharacters | frozenset(("/", ">"))):
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            if self.temporaryBuffer.lower() == "script":
                self.state = self.scriptDataEscapedState
            else:
                self.state = self.scriptDataDoubleEscapedState
        elif data in asciiLetters:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.temporaryBuffer += data
        else:
            self.stream.unget(data)
            self.state = self.scriptDataDoubleEscapedState
        return True

    def beforeAttributeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.stream.charsUntil(spaceCharacters, True)
        elif data in asciiLetters:
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        elif data == ">":
            self.emitCurrentToken()
        elif data == "/":
            self.state = self.selfClosingStartTagState
        elif data in ("'", '"', "=", "<"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "invalid-character-in-attribute-name"})
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"].append(["\uFFFD", ""])
            self.state = self.attributeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-attribute-name-but-got-eof"})
            self.state = self.dataState
        else:
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        return True

    def attributeNameState(self):
        data = self.stream.char()
        leavingThisState = True
        emitToken = False
        if data == "=":
            self.state = self.beforeAttributeValueState
        elif data in asciiLetters:
            self.currentToken["data"][-1][0] += data +\
                self.stream.charsUntil(asciiLetters, True)
            leavingThisState = False
        elif data == ">":
            # XXX If we emit here the attributes are converted to a dict
            # without being checked and when the code below runs we error
            # because data is a dict not a list
            emitToken = True
        elif data in spaceCharacters:
            self.state = self.afterAttributeNameState
        elif data == "/":
            self.state = self.selfClosingStartTagState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][0] += "\uFFFD"
            leavingThisState = False
        elif data in ("'", '"', "<"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data":
                                    "invalid-character-in-attribute-name"})
            self.currentToken["data"][-1][0] += data
            leavingThisState = False
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "eof-in-attribute-name"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][0] += data
            leavingThisState = False

        if leavingThisState:
            # Attributes are not dropped at this stage. That happens when the
            # start tag token is emitted so values can still be safely appended
            # to attributes, but we do want to report the parse error in time.
            if self.lowercaseAttrName:
                self.currentToken["data"][-1][0] = (
                    self.currentToken["data"][-1][0].translate(asciiUpper2Lower))
            for name, value in self.currentToken["data"][:-1]:
                if self.currentToken["data"][-1][0] == name:
                    self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                            "duplicate-attribute"})
                    break
            # XXX Fix for above XXX
            if emitToken:
                self.emitCurrentToken()
        return True

    def afterAttributeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.stream.charsUntil(spaceCharacters, True)
        elif data == "=":
            self.state = self.beforeAttributeValueState
        elif data == ">":
            self.emitCurrentToken()
        elif data in asciiLetters:
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        elif data == "/":
            self.state = self.selfClosingStartTagState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"].append(["\uFFFD", ""])
            self.state = self.attributeNameState
        elif data in ("'", '"', "<"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "invalid-character-after-attribute-name"})
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-end-of-tag-but-got-eof"})
            self.state = self.dataState
        else:
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        return True

    def beforeAttributeValueState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.stream.charsUntil(spaceCharacters, True)
        elif data == "\"":
            self.state = self.attributeValueDoubleQuotedState
        elif data == "&":
            self.state = self.attributeValueUnQuotedState
            self.stream.unget(data)
        elif data == "'":
            self.state = self.attributeValueSingleQuotedState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-attribute-value-but-got-right-bracket"})
            self.emitCurrentToken()
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][1] += "\uFFFD"
            self.state = self.attributeValueUnQuotedState
        elif data in ("=", "<", "`"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "equals-in-unquoted-attribute-value"})
            self.currentToken["data"][-1][1] += data
            self.state = self.attributeValueUnQuotedState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-attribute-value-but-got-eof"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][1] += data
            self.state = self.attributeValueUnQuotedState
        return True

    def attributeValueDoubleQuotedState(self):
        data = self.stream.char()
        if data == "\"":
            self.state = self.afterAttributeValueState
        elif data == "&":
            self.processEntityInAttribute('"')
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][1] += "\uFFFD"
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-attribute-value-double-quote"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][1] += data +\
                self.stream.charsUntil(("\"", "&", "\u0000"))
        return True

    def attributeValueSingleQuotedState(self):
        data = self.stream.char()
        if data == "'":
            self.state = self.afterAttributeValueState
        elif data == "&":
            self.processEntityInAttribute("'")
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][1] += "\uFFFD"
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-attribute-value-single-quote"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][1] += data +\
                self.stream.charsUntil(("'", "&", "\u0000"))
        return True

    def attributeValueUnQuotedState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeAttributeNameState
        elif data == "&":
            self.processEntityInAttribute(">")
        elif data == ">":
            self.emitCurrentToken()
        elif data in ('"', "'", "=", "<", "`"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-character-in-unquoted-attribute-value"})
            self.currentToken["data"][-1][1] += data
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][1] += "\uFFFD"
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-attribute-value-no-quotes"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][1] += data + self.stream.charsUntil(
                frozenset(("&", ">", '"', "'", "=", "<", "`", "\u0000")) | spaceCharacters)
        return True

    def afterAttributeValueState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeAttributeNameState
        elif data == ">":
            self.emitCurrentToken()
        elif data == "/":
            self.state = self.selfClosingStartTagState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-EOF-after-attribute-value"})
            self.stream.unget(data)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-character-after-attribute-value"})
            self.stream.unget(data)
            self.state = self.beforeAttributeNameState
        return True

    def selfClosingStartTagState(self):
        data = self.stream.char()
        if data == ">":
            self.currentToken["selfClosing"] = True
            self.emitCurrentToken()
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data":
                                    "unexpected-EOF-after-solidus-in-tag"})
            self.stream.unget(data)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-character-after-solidus-in-tag"})
            self.stream.unget(data)
            self.state = self.beforeAttributeNameState
        return True

    def bogusCommentState(self):
        # Make a new comment token and give it as value all the characters
        # until the first > or EOF (charsUntil checks for EOF automatically)
        # and emit it.
        data = self.stream.charsUntil(">")
        data = data.replace("\u0000", "\uFFFD")
        self.tokenQueue.append(
            {"type": tokenTypes["Comment"], "data": data})

        # Eat the character directly after the bogus comment which is either a
        # ">" or an EOF.
        self.stream.char()
        self.state = self.dataState
        return True

    def markupDeclarationOpenState(self):
        charStack = [self.stream.char()]
        if charStack[-1] == "-":
            charStack.append(self.stream.char())
            if charStack[-1] == "-":
                self.currentToken = {"type": tokenTypes["Comment"], "data": ""}
                self.state = self.commentStartState
                return True
        elif charStack[-1] in ('d', 'D'):
            matched = True
            for expected in (('o', 'O'), ('c', 'C'), ('t', 'T'),
                             ('y', 'Y'), ('p', 'P'), ('e', 'E')):
                charStack.append(self.stream.char())
                if charStack[-1] not in expected:
                    matched = False
                    break
            if matched:
                self.currentToken = {"type": tokenTypes["Doctype"],
                                     "name": "",
                                     "publicId": None, "systemId": None,
                                     "correct": True}
                self.state = self.doctypeState
                return True
        elif (charStack[-1] == "[" and
              self.parser is not None and
              self.parser.tree.openElements and
              self.parser.tree.openElements[-1].namespace != self.parser.tree.defaultNamespace):
            matched = True
            for expected in ["C", "D", "A", "T", "A", "["]:
                charStack.append(self.stream.char())
                if charStack[-1] != expected:
                    matched = False
                    break
            if matched:
                self.state = self.cdataSectionState
                return True

        self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                "expected-dashes-or-doctype"})

        while charStack:
            self.stream.unget(charStack.pop())
        self.state = self.bogusCommentState
        return True

    def commentStartState(self):
        data = self.stream.char()
        if data == "-":
            self.state = self.commentStartDashState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += "\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "incorrect-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += data
            self.state = self.commentState
        return True

    def commentStartDashState(self):
        data = self.stream.char()
        if data == "-":
            self.state = self.commentEndState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += "-\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "incorrect-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += "-" + data
            self.state = self.commentState
        return True

    def commentState(self):
        data = self.stream.char()
        if data == "-":
            self.state = self.commentEndDashState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += "\uFFFD"
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "eof-in-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += data + \
                self.stream.charsUntil(("-", "\u0000"))
        return True

    def commentEndDashState(self):
        data = self.stream.char()
        if data == "-":
            self.state = self.commentEndState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += "-\uFFFD"
            self.state = self.commentState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-comment-end-dash"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += "-" + data
            self.state = self.commentState
        return True

    def commentEndState(self):
        data = self.stream.char()
        if data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += "--\uFFFD"
            self.state = self.commentState
        elif data == "!":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-bang-after-double-dash-in-comment"})
            self.state = self.commentEndBangState
        elif data == "-":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-dash-after-double-dash-in-comment"})
            self.currentToken["data"] += data
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-comment-double-dash"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            # XXX
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-comment"})
            self.currentToken["data"] += "--" + data
            self.state = self.commentState
        return True

    def commentEndBangState(self):
        data = self.stream.char()
        if data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == "-":
            self.currentToken["data"] += "--!"
            self.state = self.commentEndDashState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += "--!\uFFFD"
            self.state = self.commentState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-comment-end-bang-state"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += "--!" + data
            self.state = self.commentState
        return True

    def doctypeState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeDoctypeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-doctype-name-but-got-eof"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "need-space-after-doctype"})
            self.stream.unget(data)
            self.state = self.beforeDoctypeNameState
        return True

    def beforeDoctypeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-doctype-name-but-got-right-bracket"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["name"] = "\uFFFD"
            self.state = self.doctypeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-doctype-name-but-got-eof"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["name"] = data
            self.state = self.doctypeNameState
        return True

    def doctypeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.currentToken["name"] = self.currentToken["name"].translate(asciiUpper2Lower)
            self.state = self.afterDoctypeNameState
        elif data == ">":
            self.currentToken["name"] = self.currentToken["name"].translate(asciiUpper2Lower)
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["name"] += "\uFFFD"
            self.state = self.doctypeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype-name"})
            self.currentToken["correct"] = False
            self.currentToken["name"] = self.currentToken["name"].translate(asciiUpper2Lower)
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["name"] += data
        return True

    def afterDoctypeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.currentToken["correct"] = False
            self.stream.unget(data)
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            if data in ("p", "P"):
                matched = True
                for expected in (("u", "U"), ("b", "B"), ("l", "L"),
                                 ("i", "I"), ("c", "C")):
                    data = self.stream.char()
                    if data not in expected:
                        matched = False
                        break
                if matched:
                    self.state = self.afterDoctypePublicKeywordState
                    return True
            elif data in ("s", "S"):
                matched = True
                for expected in (("y", "Y"), ("s", "S"), ("t", "T"),
                                 ("e", "E"), ("m", "M")):
                    data = self.stream.char()
                    if data not in expected:
                        matched = False
                        break
                if matched:
                    self.state = self.afterDoctypeSystemKeywordState
                    return True

            # All the characters read before the current 'data' will be
            # [a-zA-Z], so they're garbage in the bogus doctype and can be
            # discarded; only the latest character might be '>' or EOF
            # and needs to be ungetted
            self.stream.unget(data)
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-space-or-right-bracket-in-doctype", "datavars":
                                    {"data": data}})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState

        return True

    def afterDoctypePublicKeywordState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeDoctypePublicIdentifierState
        elif data in ("'", '"'):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.stream.unget(data)
            self.state = self.beforeDoctypePublicIdentifierState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.stream.unget(data)
            self.state = self.beforeDoctypePublicIdentifierState
        return True

    def beforeDoctypePublicIdentifierState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == "\"":
            self.currentToken["publicId"] = ""
            self.state = self.doctypePublicIdentifierDoubleQuotedState
        elif data == "'":
            self.currentToken["publicId"] = ""
            self.state = self.doctypePublicIdentifierSingleQuotedState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState
        return True

    def doctypePublicIdentifierDoubleQuotedState(self):
        data = self.stream.char()
        if data == "\"":
            self.state = self.afterDoctypePublicIdentifierState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["publicId"] += "\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["publicId"] += data
        return True

    def doctypePublicIdentifierSingleQuotedState(self):
        data = self.stream.char()
        if data == "'":
            self.state = self.afterDoctypePublicIdentifierState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["publicId"] += "\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["publicId"] += data
        return True

    def afterDoctypePublicIdentifierState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.betweenDoctypePublicAndSystemIdentifiersState
        elif data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == '"':
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["systemId"] = ""
            self.state = self.doctypeSystemIdentifierDoubleQuotedState
        elif data == "'":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["systemId"] = ""
            self.state = self.doctypeSystemIdentifierSingleQuotedState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState
        return True

    def betweenDoctypePublicAndSystemIdentifiersState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == '"':
            self.currentToken["systemId"] = ""
            self.state = self.doctypeSystemIdentifierDoubleQuotedState
        elif data == "'":
            self.currentToken["systemId"] = ""
            self.state = self.doctypeSystemIdentifierSingleQuotedState
        elif data == EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState
        return True

    def afterDoctypeSystemKeywordState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeDoctypeSystemIdentifierState
        elif data in ("'", '"'):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.stream.unget(data)
            self.state = self.beforeDoctypeSystemIdentifierState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.stream.unget(data)
            self.state = self.beforeDoctypeSystemIdentifierState
        return True

    def beforeDoctypeSystemIdentifierState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == "\"":
            self.currentToken["systemId"] = ""
            self.state = self.doctypeSystemIdentifierDoubleQuotedState
        elif data == "'":
            self.currentToken["systemId"] = ""
            self.state = self.doctypeSystemIdentifierSingleQuotedState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState
        return True

    def doctypeSystemIdentifierDoubleQuotedState(self):
        data = self.stream.char()
        if data == "\"":
            self.state = self.afterDoctypeSystemIdentifierState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["systemId"] += "\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["systemId"] += data
        return True

    def doctypeSystemIdentifierSingleQuotedState(self):
        data = self.stream.char()
        if data == "'":
            self.state = self.afterDoctypeSystemIdentifierState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["systemId"] += "\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["systemId"] += data
        return True

    def afterDoctypeSystemIdentifierState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.state = self.bogusDoctypeState
        return True

    def bogusDoctypeState(self):
        data = self.stream.char()
        if data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            # XXX EMIT
            self.stream.unget(data)
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            pass
        return True

    def cdataSectionState(self):
        data = []
        while True:
            data.append(self.stream.charsUntil("]"))
            data.append(self.stream.charsUntil(">"))
            char = self.stream.char()
            if char == EOF:
                break
            else:
                assert char == ">"
                if data[-1][-2:] == "]]":
                    data[-1] = data[-1][:-2]
                    break
                else:
                    data.append(char)

        data = "".join(data)
        # Deal with null here rather than in the parser
        nullCount = data.count("\u0000")
        if nullCount > 0:
            for i in range(nullCount):
                self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                        "data": "invalid-codepoint"})
            data = data.replace("\u0000", "\uFFFD")
        if data:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": data})
        self.state = self.dataState
        return True

########NEW FILE########
__FILENAME__ = sax
from __future__ import absolute_import, division, unicode_literals

from xml.sax.xmlreader import AttributesNSImpl

from ..constants import adjustForeignAttributes, unadjustForeignAttributes

prefix_mapping = {}
for prefix, localName, namespace in adjustForeignAttributes.values():
    if prefix is not None:
        prefix_mapping[prefix] = namespace


def to_sax(walker, handler):
    """Call SAX-like content handler based on treewalker walker"""
    handler.startDocument()
    for prefix, namespace in prefix_mapping.items():
        handler.startPrefixMapping(prefix, namespace)

    for token in walker:
        type = token["type"]
        if type == "Doctype":
            continue
        elif type in ("StartTag", "EmptyTag"):
            attrs = AttributesNSImpl(token["data"],
                                     unadjustForeignAttributes)
            handler.startElementNS((token["namespace"], token["name"]),
                                   token["name"],
                                   attrs)
            if type == "EmptyTag":
                handler.endElementNS((token["namespace"], token["name"]),
                                     token["name"])
        elif type == "EndTag":
            handler.endElementNS((token["namespace"], token["name"]),
                                 token["name"])
        elif type in ("Characters", "SpaceCharacters"):
            handler.characters(token["data"])
        elif type == "Comment":
            pass
        else:
            assert False, "Unknown token type"

    for prefix, namespace in prefix_mapping.items():
        handler.endPrefixMapping(prefix)
    handler.endDocument()

########NEW FILE########
__FILENAME__ = dom
from __future__ import absolute_import, division, unicode_literals


from xml.dom import minidom, Node
import weakref

from . import _base
from .. import constants
from ..constants import namespaces
from ..utils import moduleFactoryFactory


def getDomBuilder(DomImplementation):
    Dom = DomImplementation

    class AttrList(object):
        def __init__(self, element):
            self.element = element

        def __iter__(self):
            return list(self.element.attributes.items()).__iter__()

        def __setitem__(self, name, value):
            self.element.setAttribute(name, value)

        def __len__(self):
            return len(list(self.element.attributes.items()))

        def items(self):
            return [(item[0], item[1]) for item in
                    list(self.element.attributes.items())]

        def keys(self):
            return list(self.element.attributes.keys())

        def __getitem__(self, name):
            return self.element.getAttribute(name)

        def __contains__(self, name):
            if isinstance(name, tuple):
                raise NotImplementedError
            else:
                return self.element.hasAttribute(name)

    class NodeBuilder(_base.Node):
        def __init__(self, element):
            _base.Node.__init__(self, element.nodeName)
            self.element = element

        namespace = property(lambda self: hasattr(self.element, "namespaceURI")
                             and self.element.namespaceURI or None)

        def appendChild(self, node):
            node.parent = self
            self.element.appendChild(node.element)

        def insertText(self, data, insertBefore=None):
            text = self.element.ownerDocument.createTextNode(data)
            if insertBefore:
                self.element.insertBefore(text, insertBefore.element)
            else:
                self.element.appendChild(text)

        def insertBefore(self, node, refNode):
            self.element.insertBefore(node.element, refNode.element)
            node.parent = self

        def removeChild(self, node):
            if node.element.parentNode == self.element:
                self.element.removeChild(node.element)
            node.parent = None

        def reparentChildren(self, newParent):
            while self.element.hasChildNodes():
                child = self.element.firstChild
                self.element.removeChild(child)
                newParent.element.appendChild(child)
            self.childNodes = []

        def getAttributes(self):
            return AttrList(self.element)

        def setAttributes(self, attributes):
            if attributes:
                for name, value in list(attributes.items()):
                    if isinstance(name, tuple):
                        if name[0] is not None:
                            qualifiedName = (name[0] + ":" + name[1])
                        else:
                            qualifiedName = name[1]
                        self.element.setAttributeNS(name[2], qualifiedName,
                                                    value)
                    else:
                        self.element.setAttribute(
                            name, value)
        attributes = property(getAttributes, setAttributes)

        def cloneNode(self):
            return NodeBuilder(self.element.cloneNode(False))

        def hasContent(self):
            return self.element.hasChildNodes()

        def getNameTuple(self):
            if self.namespace is None:
                return namespaces["html"], self.name
            else:
                return self.namespace, self.name

        nameTuple = property(getNameTuple)

    class TreeBuilder(_base.TreeBuilder):
        def documentClass(self):
            self.dom = Dom.getDOMImplementation().createDocument(None, None, None)
            return weakref.proxy(self)

        def insertDoctype(self, token):
            name = token["name"]
            publicId = token["publicId"]
            systemId = token["systemId"]

            domimpl = Dom.getDOMImplementation()
            doctype = domimpl.createDocumentType(name, publicId, systemId)
            self.document.appendChild(NodeBuilder(doctype))
            if Dom == minidom:
                doctype.ownerDocument = self.dom

        def elementClass(self, name, namespace=None):
            if namespace is None and self.defaultNamespace is None:
                node = self.dom.createElement(name)
            else:
                node = self.dom.createElementNS(namespace, name)

            return NodeBuilder(node)

        def commentClass(self, data):
            return NodeBuilder(self.dom.createComment(data))

        def fragmentClass(self):
            return NodeBuilder(self.dom.createDocumentFragment())

        def appendChild(self, node):
            self.dom.appendChild(node.element)

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            return self.dom

        def getFragment(self):
            return _base.TreeBuilder.getFragment(self).element

        def insertText(self, data, parent=None):
            data = data
            if parent != self:
                _base.TreeBuilder.insertText(self, data, parent)
            else:
                # HACK: allow text nodes as children of the document node
                if hasattr(self.dom, '_child_node_types'):
                    if not Node.TEXT_NODE in self.dom._child_node_types:
                        self.dom._child_node_types = list(self.dom._child_node_types)
                        self.dom._child_node_types.append(Node.TEXT_NODE)
                self.dom.appendChild(self.dom.createTextNode(data))

        implementation = DomImplementation
        name = None

    def testSerializer(element):
        element.normalize()
        rv = []

        def serializeElement(element, indent=0):
            if element.nodeType == Node.DOCUMENT_TYPE_NODE:
                if element.name:
                    if element.publicId or element.systemId:
                        publicId = element.publicId or ""
                        systemId = element.systemId or ""
                        rv.append("""|%s<!DOCTYPE %s "%s" "%s">""" %
                                  (' ' * indent, element.name, publicId, systemId))
                    else:
                        rv.append("|%s<!DOCTYPE %s>" % (' ' * indent, element.name))
                else:
                    rv.append("|%s<!DOCTYPE >" % (' ' * indent,))
            elif element.nodeType == Node.DOCUMENT_NODE:
                rv.append("#document")
            elif element.nodeType == Node.DOCUMENT_FRAGMENT_NODE:
                rv.append("#document-fragment")
            elif element.nodeType == Node.COMMENT_NODE:
                rv.append("|%s<!-- %s -->" % (' ' * indent, element.nodeValue))
            elif element.nodeType == Node.TEXT_NODE:
                rv.append("|%s\"%s\"" % (' ' * indent, element.nodeValue))
            else:
                if (hasattr(element, "namespaceURI") and
                        element.namespaceURI is not None):
                    name = "%s %s" % (constants.prefixes[element.namespaceURI],
                                      element.nodeName)
                else:
                    name = element.nodeName
                rv.append("|%s<%s>" % (' ' * indent, name))
                if element.hasAttributes():
                    attributes = []
                    for i in range(len(element.attributes)):
                        attr = element.attributes.item(i)
                        name = attr.nodeName
                        value = attr.value
                        ns = attr.namespaceURI
                        if ns:
                            name = "%s %s" % (constants.prefixes[ns], attr.localName)
                        else:
                            name = attr.nodeName
                        attributes.append((name, value))

                    for name, value in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
            indent += 2
            for child in element.childNodes:
                serializeElement(child, indent)
        serializeElement(element, 0)

        return "\n".join(rv)

    return locals()


# The actual means to get a module!
getDomModule = moduleFactoryFactory(getDomBuilder)

########NEW FILE########
__FILENAME__ = etree
from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type

import re

from . import _base
from .. import ihatexml
from .. import constants
from ..constants import namespaces
from ..utils import moduleFactoryFactory

tag_regexp = re.compile("{([^}]*)}(.*)")


def getETreeBuilder(ElementTreeImplementation, fullTree=False):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment("asd").tag

    class Element(_base.Node):
        def __init__(self, name, namespace=None):
            self._name = name
            self._namespace = namespace
            self._element = ElementTree.Element(self._getETreeTag(name,
                                                                  namespace))
            if namespace is None:
                self.nameTuple = namespaces["html"], self._name
            else:
                self.nameTuple = self._namespace, self._name
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getETreeTag(self, name, namespace):
            if namespace is None:
                etree_tag = name
            else:
                etree_tag = "{%s}%s" % (namespace, name)
            return etree_tag

        def _setName(self, name):
            self._name = name
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getName(self):
            return self._name

        name = property(_getName, _setName)

        def _setNamespace(self, namespace):
            self._namespace = namespace
            self._element.tag = self._getETreeTag(self._name, self._namespace)

        def _getNamespace(self):
            return self._namespace

        namespace = property(_getNamespace, _setNamespace)

        def _getAttributes(self):
            return self._element.attrib

        def _setAttributes(self, attributes):
            # Delete existing attributes first
            # XXX - there may be a better way to do this...
            for key in list(self._element.attrib.keys()):
                del self._element.attrib[key]
            for key, value in attributes.items():
                if isinstance(key, tuple):
                    name = "{%s}%s" % (key[2], key[1])
                else:
                    name = key
                self._element.set(name, value)

        attributes = property(_getAttributes, _setAttributes)

        def _getChildNodes(self):
            return self._childNodes

        def _setChildNodes(self, value):
            del self._element[:]
            self._childNodes = []
            for element in value:
                self.insertChild(element)

        childNodes = property(_getChildNodes, _setChildNodes)

        def hasContent(self):
            """Return true if the node has children or text"""
            return bool(self._element.text or len(self._element))

        def appendChild(self, node):
            self._childNodes.append(node)
            self._element.append(node._element)
            node.parent = self

        def insertBefore(self, node, refNode):
            index = list(self._element).index(refNode._element)
            self._element.insert(index, node._element)
            node.parent = self

        def removeChild(self, node):
            self._element.remove(node._element)
            node.parent = None

        def insertText(self, data, insertBefore=None):
            if not(len(self._element)):
                if not self._element.text:
                    self._element.text = ""
                self._element.text += data
            elif insertBefore is None:
                # Insert the text as the tail of the last child element
                if not self._element[-1].tail:
                    self._element[-1].tail = ""
                self._element[-1].tail += data
            else:
                # Insert the text before the specified node
                children = list(self._element)
                index = children.index(insertBefore._element)
                if index > 0:
                    if not self._element[index - 1].tail:
                        self._element[index - 1].tail = ""
                    self._element[index - 1].tail += data
                else:
                    if not self._element.text:
                        self._element.text = ""
                    self._element.text += data

        def cloneNode(self):
            element = type(self)(self.name, self.namespace)
            for name, value in self.attributes.items():
                element.attributes[name] = value
            return element

        def reparentChildren(self, newParent):
            if newParent.childNodes:
                newParent.childNodes[-1]._element.tail += self._element.text
            else:
                if not newParent._element.text:
                    newParent._element.text = ""
                if self._element.text is not None:
                    newParent._element.text += self._element.text
            self._element.text = ""
            _base.Node.reparentChildren(self, newParent)

    class Comment(Element):
        def __init__(self, data):
            # Use the superclass constructor to set all properties on the
            # wrapper element
            self._element = ElementTree.Comment(data)
            self.parent = None
            self._childNodes = []
            self._flags = []

        def _getData(self):
            return self._element.text

        def _setData(self, value):
            self._element.text = value

        data = property(_getData, _setData)

    class DocumentType(Element):
        def __init__(self, name, publicId, systemId):
            Element.__init__(self, "<!DOCTYPE>")
            self._element.text = name
            self.publicId = publicId
            self.systemId = systemId

        def _getPublicId(self):
            return self._element.get("publicId", "")

        def _setPublicId(self, value):
            if value is not None:
                self._element.set("publicId", value)

        publicId = property(_getPublicId, _setPublicId)

        def _getSystemId(self):
            return self._element.get("systemId", "")

        def _setSystemId(self, value):
            if value is not None:
                self._element.set("systemId", value)

        systemId = property(_getSystemId, _setSystemId)

    class Document(Element):
        def __init__(self):
            Element.__init__(self, "DOCUMENT_ROOT")

    class DocumentFragment(Element):
        def __init__(self):
            Element.__init__(self, "DOCUMENT_FRAGMENT")

    def testSerializer(element):
        rv = []

        def serializeElement(element, indent=0):
            if not(hasattr(element, "tag")):
                element = element.getroot()
            if element.tag == "<!DOCTYPE>":
                if element.get("publicId") or element.get("systemId"):
                    publicId = element.get("publicId") or ""
                    systemId = element.get("systemId") or ""
                    rv.append("""<!DOCTYPE %s "%s" "%s">""" %
                              (element.text, publicId, systemId))
                else:
                    rv.append("<!DOCTYPE %s>" % (element.text,))
            elif element.tag == "DOCUMENT_ROOT":
                rv.append("#document")
                if element.text is not None:
                    rv.append("|%s\"%s\"" % (' ' * (indent + 2), element.text))
                if element.tail is not None:
                    raise TypeError("Document node cannot have tail")
                if hasattr(element, "attrib") and len(element.attrib):
                    raise TypeError("Document node cannot have attributes")
            elif element.tag == ElementTreeCommentType:
                rv.append("|%s<!-- %s -->" % (' ' * indent, element.text))
            else:
                assert isinstance(element.tag, text_type), \
                    "Expected unicode, got %s, %s" % (type(element.tag), element.tag)
                nsmatch = tag_regexp.match(element.tag)

                if nsmatch is None:
                    name = element.tag
                else:
                    ns, name = nsmatch.groups()
                    prefix = constants.prefixes[ns]
                    name = "%s %s" % (prefix, name)
                rv.append("|%s<%s>" % (' ' * indent, name))

                if hasattr(element, "attrib"):
                    attributes = []
                    for name, value in element.attrib.items():
                        nsmatch = tag_regexp.match(name)
                        if nsmatch is not None:
                            ns, name = nsmatch.groups()
                            prefix = constants.prefixes[ns]
                            attr_string = "%s %s" % (prefix, name)
                        else:
                            attr_string = name
                        attributes.append((attr_string, value))

                    for name, value in sorted(attributes):
                        rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))
                if element.text:
                    rv.append("|%s\"%s\"" % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if element.tail:
                rv.append("|%s\"%s\"" % (' ' * (indent - 2), element.tail))
        serializeElement(element, 0)

        return "\n".join(rv)

    def tostring(element):
        """Serialize an element and its child nodes to a string"""
        rv = []
        filter = ihatexml.InfosetFilter()

        def serializeElement(element):
            if isinstance(element, ElementTree.ElementTree):
                element = element.getroot()

            if element.tag == "<!DOCTYPE>":
                if element.get("publicId") or element.get("systemId"):
                    publicId = element.get("publicId") or ""
                    systemId = element.get("systemId") or ""
                    rv.append("""<!DOCTYPE %s PUBLIC "%s" "%s">""" %
                              (element.text, publicId, systemId))
                else:
                    rv.append("<!DOCTYPE %s>" % (element.text,))
            elif element.tag == "DOCUMENT_ROOT":
                if element.text is not None:
                    rv.append(element.text)
                if element.tail is not None:
                    raise TypeError("Document node cannot have tail")
                if hasattr(element, "attrib") and len(element.attrib):
                    raise TypeError("Document node cannot have attributes")

                for child in element:
                    serializeElement(child)

            elif element.tag == ElementTreeCommentType:
                rv.append("<!--%s-->" % (element.text,))
            else:
                # This is assumed to be an ordinary element
                if not element.attrib:
                    rv.append("<%s>" % (filter.fromXmlName(element.tag),))
                else:
                    attr = " ".join(["%s=\"%s\"" % (
                        filter.fromXmlName(name), value)
                        for name, value in element.attrib.items()])
                    rv.append("<%s %s>" % (element.tag, attr))
                if element.text:
                    rv.append(element.text)

                for child in element:
                    serializeElement(child)

                rv.append("</%s>" % (element.tag,))

            if element.tail:
                rv.append(element.tail)

        serializeElement(element)

        return "".join(rv)

    class TreeBuilder(_base.TreeBuilder):
        documentClass = Document
        doctypeClass = DocumentType
        elementClass = Element
        commentClass = Comment
        fragmentClass = DocumentFragment
        implementation = ElementTreeImplementation

        def testSerializer(self, element):
            return testSerializer(element)

        def getDocument(self):
            if fullTree:
                return self.document._element
            else:
                if self.defaultNamespace is not None:
                    return self.document._element.find(
                        "{%s}html" % self.defaultNamespace)
                else:
                    return self.document._element.find("html")

        def getFragment(self):
            return _base.TreeBuilder.getFragment(self)._element

    return locals()


getETreeModule = moduleFactoryFactory(getETreeBuilder)

########NEW FILE########
__FILENAME__ = etree_lxml
"""Module for supporting the lxml.etree library. The idea here is to use as much
of the native library as possible, without using fragile hacks like custom element
names that break between releases. The downside of this is that we cannot represent
all possible trees; specifically the following are known to cause problems:

Text or comments as siblings of the root element
Docypes with no name

When any of these things occur, we emit a DataLossWarning
"""

from __future__ import absolute_import, division, unicode_literals

import warnings
import re
import sys

from . import _base
from ..constants import DataLossWarning
from .. import constants
from . import etree as etree_builders
from .. import ihatexml

import lxml.etree as etree


fullTree = True
tag_regexp = re.compile("{([^}]*)}(.*)")

comment_type = etree.Comment("asd").tag


class DocumentType(object):
    def __init__(self, name, publicId, systemId):
        self.name = name
        self.publicId = publicId
        self.systemId = systemId


class Document(object):
    def __init__(self):
        self._elementTree = None
        self._childNodes = []

    def appendChild(self, element):
        self._elementTree.getroot().addnext(element._element)

    def _getChildNodes(self):
        return self._childNodes

    childNodes = property(_getChildNodes)


def testSerializer(element):
    rv = []
    finalText = None
    infosetFilter = ihatexml.InfosetFilter()

    def serializeElement(element, indent=0):
        if not hasattr(element, "tag"):
            if hasattr(element, "getroot"):
                # Full tree case
                rv.append("#document")
                if element.docinfo.internalDTD:
                    if not (element.docinfo.public_id or
                            element.docinfo.system_url):
                        dtd_str = "<!DOCTYPE %s>" % element.docinfo.root_name
                    else:
                        dtd_str = """<!DOCTYPE %s "%s" "%s">""" % (
                            element.docinfo.root_name,
                            element.docinfo.public_id,
                            element.docinfo.system_url)
                    rv.append("|%s%s" % (' ' * (indent + 2), dtd_str))
                next_element = element.getroot()
                while next_element.getprevious() is not None:
                    next_element = next_element.getprevious()
                while next_element is not None:
                    serializeElement(next_element, indent + 2)
                    next_element = next_element.getnext()
            elif isinstance(element, str) or isinstance(element, bytes):
                # Text in a fragment
                assert isinstance(element, str) or sys.version_info.major == 2
                rv.append("|%s\"%s\"" % (' ' * indent, element))
            else:
                # Fragment case
                rv.append("#document-fragment")
                for next_element in element:
                    serializeElement(next_element, indent + 2)
        elif element.tag == comment_type:
            rv.append("|%s<!-- %s -->" % (' ' * indent, element.text))
            if hasattr(element, "tail") and element.tail:
                rv.append("|%s\"%s\"" % (' ' * indent, element.tail))
        else:
            assert isinstance(element, etree._Element)
            nsmatch = etree_builders.tag_regexp.match(element.tag)
            if nsmatch is not None:
                ns = nsmatch.group(1)
                tag = nsmatch.group(2)
                prefix = constants.prefixes[ns]
                rv.append("|%s<%s %s>" % (' ' * indent, prefix,
                                          infosetFilter.fromXmlName(tag)))
            else:
                rv.append("|%s<%s>" % (' ' * indent,
                                       infosetFilter.fromXmlName(element.tag)))

            if hasattr(element, "attrib"):
                attributes = []
                for name, value in element.attrib.items():
                    nsmatch = tag_regexp.match(name)
                    if nsmatch is not None:
                        ns, name = nsmatch.groups()
                        name = infosetFilter.fromXmlName(name)
                        prefix = constants.prefixes[ns]
                        attr_string = "%s %s" % (prefix, name)
                    else:
                        attr_string = infosetFilter.fromXmlName(name)
                    attributes.append((attr_string, value))

                for name, value in sorted(attributes):
                    rv.append('|%s%s="%s"' % (' ' * (indent + 2), name, value))

            if element.text:
                rv.append("|%s\"%s\"" % (' ' * (indent + 2), element.text))
            indent += 2
            for child in element:
                serializeElement(child, indent)
            if hasattr(element, "tail") and element.tail:
                rv.append("|%s\"%s\"" % (' ' * (indent - 2), element.tail))
    serializeElement(element, 0)

    if finalText is not None:
        rv.append("|%s\"%s\"" % (' ' * 2, finalText))

    return "\n".join(rv)


def tostring(element):
    """Serialize an element and its child nodes to a string"""
    rv = []
    finalText = None

    def serializeElement(element):
        if not hasattr(element, "tag"):
            if element.docinfo.internalDTD:
                if element.docinfo.doctype:
                    dtd_str = element.docinfo.doctype
                else:
                    dtd_str = "<!DOCTYPE %s>" % element.docinfo.root_name
                rv.append(dtd_str)
            serializeElement(element.getroot())

        elif element.tag == comment_type:
            rv.append("<!--%s-->" % (element.text,))

        else:
            # This is assumed to be an ordinary element
            if not element.attrib:
                rv.append("<%s>" % (element.tag,))
            else:
                attr = " ".join(["%s=\"%s\"" % (name, value)
                                 for name, value in element.attrib.items()])
                rv.append("<%s %s>" % (element.tag, attr))
            if element.text:
                rv.append(element.text)

            for child in element:
                serializeElement(child)

            rv.append("</%s>" % (element.tag,))

        if hasattr(element, "tail") and element.tail:
            rv.append(element.tail)

    serializeElement(element)

    if finalText is not None:
        rv.append("%s\"" % (' ' * 2, finalText))

    return "".join(rv)


class TreeBuilder(_base.TreeBuilder):
    documentClass = Document
    doctypeClass = DocumentType
    elementClass = None
    commentClass = None
    fragmentClass = Document
    implementation = etree

    def __init__(self, namespaceHTMLElements, fullTree=False):
        builder = etree_builders.getETreeModule(etree, fullTree=fullTree)
        infosetFilter = self.infosetFilter = ihatexml.InfosetFilter()
        self.namespaceHTMLElements = namespaceHTMLElements

        class Attributes(dict):
            def __init__(self, element, value={}):
                self._element = element
                dict.__init__(self, value)
                for key, value in self.items():
                    if isinstance(key, tuple):
                        name = "{%s}%s" % (key[2], infosetFilter.coerceAttribute(key[1]))
                    else:
                        name = infosetFilter.coerceAttribute(key)
                    self._element._element.attrib[name] = value

            def __setitem__(self, key, value):
                dict.__setitem__(self, key, value)
                if isinstance(key, tuple):
                    name = "{%s}%s" % (key[2], infosetFilter.coerceAttribute(key[1]))
                else:
                    name = infosetFilter.coerceAttribute(key)
                self._element._element.attrib[name] = value

        class Element(builder.Element):
            def __init__(self, name, namespace):
                name = infosetFilter.coerceElement(name)
                builder.Element.__init__(self, name, namespace=namespace)
                self._attributes = Attributes(self)

            def _setName(self, name):
                self._name = infosetFilter.coerceElement(name)
                self._element.tag = self._getETreeTag(
                    self._name, self._namespace)

            def _getName(self):
                return infosetFilter.fromXmlName(self._name)

            name = property(_getName, _setName)

            def _getAttributes(self):
                return self._attributes

            def _setAttributes(self, attributes):
                self._attributes = Attributes(self, attributes)

            attributes = property(_getAttributes, _setAttributes)

            def insertText(self, data, insertBefore=None):
                data = infosetFilter.coerceCharacters(data)
                builder.Element.insertText(self, data, insertBefore)

            def appendChild(self, child):
                builder.Element.appendChild(self, child)

        class Comment(builder.Comment):
            def __init__(self, data):
                data = infosetFilter.coerceComment(data)
                builder.Comment.__init__(self, data)

            def _setData(self, data):
                data = infosetFilter.coerceComment(data)
                self._element.text = data

            def _getData(self):
                return self._element.text

            data = property(_getData, _setData)

        self.elementClass = Element
        self.commentClass = builder.Comment
        # self.fragmentClass = builder.DocumentFragment
        _base.TreeBuilder.__init__(self, namespaceHTMLElements)

    def reset(self):
        _base.TreeBuilder.reset(self)
        self.insertComment = self.insertCommentInitial
        self.initial_comments = []
        self.doctype = None

    def testSerializer(self, element):
        return testSerializer(element)

    def getDocument(self):
        if fullTree:
            return self.document._elementTree
        else:
            return self.document._elementTree.getroot()

    def getFragment(self):
        fragment = []
        element = self.openElements[0]._element
        if element.text:
            fragment.append(element.text)
        fragment.extend(list(element))
        if element.tail:
            fragment.append(element.tail)
        return fragment

    def insertDoctype(self, token):
        name = token["name"]
        publicId = token["publicId"]
        systemId = token["systemId"]

        if not name:
            warnings.warn("lxml cannot represent empty doctype", DataLossWarning)
            self.doctype = None
        else:
            coercedName = self.infosetFilter.coerceElement(name)
            if coercedName != name:
                warnings.warn("lxml cannot represent non-xml doctype", DataLossWarning)

            doctype = self.doctypeClass(coercedName, publicId, systemId)
            self.doctype = doctype

    def insertCommentInitial(self, data, parent=None):
        self.initial_comments.append(data)

    def insertCommentMain(self, data, parent=None):
        if (parent == self.document and
                self.document._elementTree.getroot()[-1].tag == comment_type):
                warnings.warn("lxml cannot represent adjacent comments beyond the root elements", DataLossWarning)
        super(TreeBuilder, self).insertComment(data, parent)

    def insertRoot(self, token):
        """Create the document root"""
        # Because of the way libxml2 works, it doesn't seem to be possible to
        # alter information like the doctype after the tree has been parsed.
        # Therefore we need to use the built-in parser to create our iniial
        # tree, after which we can add elements like normal
        docStr = ""
        if self.doctype:
            assert self.doctype.name
            docStr += "<!DOCTYPE %s" % self.doctype.name
            if (self.doctype.publicId is not None or
                    self.doctype.systemId is not None):
                docStr += (' PUBLIC "%s" ' %
                           (self.infosetFilter.coercePubid(self.doctype.publicId or "")))
                if self.doctype.systemId:
                    sysid = self.doctype.systemId
                    if sysid.find("'") >= 0 and sysid.find('"') >= 0:
                        warnings.warn("DOCTYPE system cannot contain single and double quotes", DataLossWarning)
                        sysid = sysid.replace("'", 'U00027')
                    if sysid.find("'") >= 0:
                        docStr += '"%s"' % sysid
                    else:
                        docStr += "'%s'" % sysid
                else:
                    docStr += "''"
            docStr += ">"
            if self.doctype.name != token["name"]:
                warnings.warn("lxml cannot represent doctype with a different name to the root element", DataLossWarning)
        docStr += "<THIS_SHOULD_NEVER_APPEAR_PUBLICLY/>"
        root = etree.fromstring(docStr)

        # Append the initial comments:
        for comment_token in self.initial_comments:
            root.addprevious(etree.Comment(comment_token["data"]))

        # Create the root document and add the ElementTree to it
        self.document = self.documentClass()
        self.document._elementTree = root.getroottree()

        # Give the root element the right name
        name = token["name"]
        namespace = token.get("namespace", self.defaultNamespace)
        if namespace is None:
            etree_tag = name
        else:
            etree_tag = "{%s}%s" % (namespace, name)
        root.tag = etree_tag

        # Add the root element to the internal child/open data structures
        root_element = self.elementClass(name, namespace)
        root_element._element = root
        self.document._childNodes.append(root_element)
        self.openElements.append(root_element)

        # Reset to the default insert comment function
        self.insertComment = self.insertCommentMain

########NEW FILE########
__FILENAME__ = _base
from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type

from ..constants import scopingElements, tableInsertModeElements, namespaces

# The scope markers are inserted when entering object elements,
# marquees, table cells, and table captions, and are used to prevent formatting
# from "leaking" into tables, object elements, and marquees.
Marker = None

listElementsMap = {
    None: (frozenset(scopingElements), False),
    "button": (frozenset(scopingElements | set([(namespaces["html"], "button")])), False),
    "list": (frozenset(scopingElements | set([(namespaces["html"], "ol"),
                                              (namespaces["html"], "ul")])), False),
    "table": (frozenset([(namespaces["html"], "html"),
                         (namespaces["html"], "table")]), False),
    "select": (frozenset([(namespaces["html"], "optgroup"),
                          (namespaces["html"], "option")]), True)
}


class Node(object):
    def __init__(self, name):
        """Node representing an item in the tree.
        name - The tag name associated with the node
        parent - The parent of the current node (or None for the document node)
        value - The value of the current node (applies to text nodes and
        comments
        attributes - a dict holding name, value pairs for attributes of the node
        childNodes - a list of child nodes of the current node. This must
        include all elements but not necessarily other node types
        _flags - A list of miscellaneous flags that can be set on the node
        """
        self.name = name
        self.parent = None
        self.value = None
        self.attributes = {}
        self.childNodes = []
        self._flags = []

    def __str__(self):
        attributesStr = " ".join(["%s=\"%s\"" % (name, value)
                                  for name, value in
                                  self.attributes.items()])
        if attributesStr:
            return "<%s %s>" % (self.name, attributesStr)
        else:
            return "<%s>" % (self.name)

    def __repr__(self):
        return "<%s>" % (self.name)

    def appendChild(self, node):
        """Insert node as a child of the current node
        """
        raise NotImplementedError

    def insertText(self, data, insertBefore=None):
        """Insert data as text in the current node, positioned before the
        start of node insertBefore or to the end of the node's text.
        """
        raise NotImplementedError

    def insertBefore(self, node, refNode):
        """Insert node as a child of the current node, before refNode in the
        list of child nodes. Raises ValueError if refNode is not a child of
        the current node"""
        raise NotImplementedError

    def removeChild(self, node):
        """Remove node from the children of the current node
        """
        raise NotImplementedError

    def reparentChildren(self, newParent):
        """Move all the children of the current node to newParent.
        This is needed so that trees that don't store text as nodes move the
        text in the correct way
        """
        # XXX - should this method be made more general?
        for child in self.childNodes:
            newParent.appendChild(child)
        self.childNodes = []

    def cloneNode(self):
        """Return a shallow copy of the current node i.e. a node with the same
        name and attributes but with no parent or child nodes
        """
        raise NotImplementedError

    def hasContent(self):
        """Return true if the node has children or text, false otherwise
        """
        raise NotImplementedError


class ActiveFormattingElements(list):
    def append(self, node):
        equalCount = 0
        if node != Marker:
            for element in self[::-1]:
                if element == Marker:
                    break
                if self.nodesEqual(element, node):
                    equalCount += 1
                if equalCount == 3:
                    self.remove(element)
                    break
        list.append(self, node)

    def nodesEqual(self, node1, node2):
        if not node1.nameTuple == node2.nameTuple:
            return False

        if not node1.attributes == node2.attributes:
            return False

        return True


class TreeBuilder(object):
    """Base treebuilder implementation
    documentClass - the class to use for the bottommost node of a document
    elementClass - the class to use for HTML Elements
    commentClass - the class to use for comments
    doctypeClass - the class to use for doctypes
    """

    # Document class
    documentClass = None

    # The class to use for creating a node
    elementClass = None

    # The class to use for creating comments
    commentClass = None

    # The class to use for creating doctypes
    doctypeClass = None

    # Fragment class
    fragmentClass = None

    def __init__(self, namespaceHTMLElements):
        if namespaceHTMLElements:
            self.defaultNamespace = "http://www.w3.org/1999/xhtml"
        else:
            self.defaultNamespace = None
        self.reset()

    def reset(self):
        self.openElements = []
        self.activeFormattingElements = ActiveFormattingElements()

        # XXX - rename these to headElement, formElement
        self.headPointer = None
        self.formPointer = None

        self.insertFromTable = False

        self.document = self.documentClass()

    def elementInScope(self, target, variant=None):

        # If we pass a node in we match that. if we pass a string
        # match any node with that name
        exactNode = hasattr(target, "nameTuple")

        listElements, invert = listElementsMap[variant]

        for node in reversed(self.openElements):
            if (node.name == target and not exactNode or
                    node == target and exactNode):
                return True
            elif (invert ^ (node.nameTuple in listElements)):
                return False

        assert False  # We should never reach this point

    def reconstructActiveFormattingElements(self):
        # Within this algorithm the order of steps described in the
        # specification is not quite the same as the order of steps in the
        # code. It should still do the same though.

        # Step 1: stop the algorithm when there's nothing to do.
        if not self.activeFormattingElements:
            return

        # Step 2 and step 3: we start with the last element. So i is -1.
        i = len(self.activeFormattingElements) - 1
        entry = self.activeFormattingElements[i]
        if entry == Marker or entry in self.openElements:
            return

        # Step 6
        while entry != Marker and entry not in self.openElements:
            if i == 0:
                # This will be reset to 0 below
                i = -1
                break
            i -= 1
            # Step 5: let entry be one earlier in the list.
            entry = self.activeFormattingElements[i]

        while True:
            # Step 7
            i += 1

            # Step 8
            entry = self.activeFormattingElements[i]
            clone = entry.cloneNode()  # Mainly to get a new copy of the attributes

            # Step 9
            element = self.insertElement({"type": "StartTag",
                                          "name": clone.name,
                                          "namespace": clone.namespace,
                                          "data": clone.attributes})

            # Step 10
            self.activeFormattingElements[i] = element

            # Step 11
            if element == self.activeFormattingElements[-1]:
                break

    def clearActiveFormattingElements(self):
        entry = self.activeFormattingElements.pop()
        while self.activeFormattingElements and entry != Marker:
            entry = self.activeFormattingElements.pop()

    def elementInActiveFormattingElements(self, name):
        """Check if an element exists between the end of the active
        formatting elements and the last marker. If it does, return it, else
        return false"""

        for item in self.activeFormattingElements[::-1]:
            # Check for Marker first because if it's a Marker it doesn't have a
            # name attribute.
            if item == Marker:
                break
            elif item.name == name:
                return item
        return False

    def insertRoot(self, token):
        element = self.createElement(token)
        self.openElements.append(element)
        self.document.appendChild(element)

    def insertDoctype(self, token):
        name = token["name"]
        publicId = token["publicId"]
        systemId = token["systemId"]

        doctype = self.doctypeClass(name, publicId, systemId)
        self.document.appendChild(doctype)

    def insertComment(self, token, parent=None):
        if parent is None:
            parent = self.openElements[-1]
        parent.appendChild(self.commentClass(token["data"]))

    def createElement(self, token):
        """Create an element but don't insert it anywhere"""
        name = token["name"]
        namespace = token.get("namespace", self.defaultNamespace)
        element = self.elementClass(name, namespace)
        element.attributes = token["data"]
        return element

    def _getInsertFromTable(self):
        return self._insertFromTable

    def _setInsertFromTable(self, value):
        """Switch the function used to insert an element from the
        normal one to the misnested table one and back again"""
        self._insertFromTable = value
        if value:
            self.insertElement = self.insertElementTable
        else:
            self.insertElement = self.insertElementNormal

    insertFromTable = property(_getInsertFromTable, _setInsertFromTable)

    def insertElementNormal(self, token):
        name = token["name"]
        assert isinstance(name, text_type), "Element %s not unicode" % name
        namespace = token.get("namespace", self.defaultNamespace)
        element = self.elementClass(name, namespace)
        element.attributes = token["data"]
        self.openElements[-1].appendChild(element)
        self.openElements.append(element)
        return element

    def insertElementTable(self, token):
        """Create an element and insert it into the tree"""
        element = self.createElement(token)
        if self.openElements[-1].name not in tableInsertModeElements:
            return self.insertElementNormal(token)
        else:
            # We should be in the InTable mode. This means we want to do
            # special magic element rearranging
            parent, insertBefore = self.getTableMisnestedNodePosition()
            if insertBefore is None:
                parent.appendChild(element)
            else:
                parent.insertBefore(element, insertBefore)
            self.openElements.append(element)
        return element

    def insertText(self, data, parent=None):
        """Insert text data."""
        if parent is None:
            parent = self.openElements[-1]

        if (not self.insertFromTable or (self.insertFromTable and
                                         self.openElements[-1].name
                                         not in tableInsertModeElements)):
            parent.insertText(data)
        else:
            # We should be in the InTable mode. This means we want to do
            # special magic element rearranging
            parent, insertBefore = self.getTableMisnestedNodePosition()
            parent.insertText(data, insertBefore)

    def getTableMisnestedNodePosition(self):
        """Get the foster parent element, and sibling to insert before
        (or None) when inserting a misnested table node"""
        # The foster parent element is the one which comes before the most
        # recently opened table element
        # XXX - this is really inelegant
        lastTable = None
        fosterParent = None
        insertBefore = None
        for elm in self.openElements[::-1]:
            if elm.name == "table":
                lastTable = elm
                break
        if lastTable:
            # XXX - we should really check that this parent is actually a
            # node here
            if lastTable.parent:
                fosterParent = lastTable.parent
                insertBefore = lastTable
            else:
                fosterParent = self.openElements[
                    self.openElements.index(lastTable) - 1]
        else:
            fosterParent = self.openElements[0]
        return fosterParent, insertBefore

    def generateImpliedEndTags(self, exclude=None):
        name = self.openElements[-1].name
        # XXX td, th and tr are not actually needed
        if (name in frozenset(("dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"))
                and name != exclude):
            self.openElements.pop()
            # XXX This is not entirely what the specification says. We should
            # investigate it more closely.
            self.generateImpliedEndTags(exclude)

    def getDocument(self):
        "Return the final tree"
        return self.document

    def getFragment(self):
        "Return the final fragment"
        # assert self.innerHTML
        fragment = self.fragmentClass()
        self.openElements[0].reparentChildren(fragment)
        return fragment

    def testSerializer(self, node):
        """Serialize the subtree of node in the format required by unit tests
        node - the node from which to start serializing"""
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = dom
from __future__ import absolute_import, division, unicode_literals

from xml.dom import Node

import gettext
_ = gettext.gettext

from . import _base


class TreeWalker(_base.NonRecursiveTreeWalker):
    def getNodeDetails(self, node):
        if node.nodeType == Node.DOCUMENT_TYPE_NODE:
            return _base.DOCTYPE, node.name, node.publicId, node.systemId

        elif node.nodeType in (Node.TEXT_NODE, Node.CDATA_SECTION_NODE):
            return _base.TEXT, node.nodeValue

        elif node.nodeType == Node.ELEMENT_NODE:
            attrs = {}
            for attr in list(node.attributes.keys()):
                attr = node.getAttributeNode(attr)
                if attr.namespaceURI:
                    attrs[(attr.namespaceURI, attr.localName)] = attr.value
                else:
                    attrs[(None, attr.name)] = attr.value
            return (_base.ELEMENT, node.namespaceURI, node.nodeName,
                    attrs, node.hasChildNodes())

        elif node.nodeType == Node.COMMENT_NODE:
            return _base.COMMENT, node.nodeValue

        elif node.nodeType in (Node.DOCUMENT_NODE, Node.DOCUMENT_FRAGMENT_NODE):
            return (_base.DOCUMENT,)

        else:
            return _base.UNKNOWN, node.nodeType

    def getFirstChild(self, node):
        return node.firstChild

    def getNextSibling(self, node):
        return node.nextSibling

    def getParentNode(self, node):
        return node.parentNode

########NEW FILE########
__FILENAME__ = etree
from __future__ import absolute_import, division, unicode_literals

try:
    from collections import OrderedDict
except ImportError:
    try:
        from ordereddict import OrderedDict
    except ImportError:
        OrderedDict = dict
import gettext
_ = gettext.gettext

import re

from pip._vendor.six import text_type

from . import _base
from ..utils import moduleFactoryFactory

tag_regexp = re.compile("{([^}]*)}(.*)")


def getETreeBuilder(ElementTreeImplementation):
    ElementTree = ElementTreeImplementation
    ElementTreeCommentType = ElementTree.Comment("asd").tag

    class TreeWalker(_base.NonRecursiveTreeWalker):
        """Given the particular ElementTree representation, this implementation,
        to avoid using recursion, returns "nodes" as tuples with the following
        content:

        1. The current element

        2. The index of the element relative to its parent

        3. A stack of ancestor elements

        4. A flag "text", "tail" or None to indicate if the current node is a
           text node; either the text or tail of the current element (1)
        """
        def getNodeDetails(self, node):
            if isinstance(node, tuple):  # It might be the root Element
                elt, key, parents, flag = node
                if flag in ("text", "tail"):
                    return _base.TEXT, getattr(elt, flag)
                else:
                    node = elt

            if not(hasattr(node, "tag")):
                node = node.getroot()

            if node.tag in ("DOCUMENT_ROOT", "DOCUMENT_FRAGMENT"):
                return (_base.DOCUMENT,)

            elif node.tag == "<!DOCTYPE>":
                return (_base.DOCTYPE, node.text,
                        node.get("publicId"), node.get("systemId"))

            elif node.tag == ElementTreeCommentType:
                return _base.COMMENT, node.text

            else:
                assert type(node.tag) == text_type, type(node.tag)
                # This is assumed to be an ordinary element
                match = tag_regexp.match(node.tag)
                if match:
                    namespace, tag = match.groups()
                else:
                    namespace = None
                    tag = node.tag
                attrs = OrderedDict()
                for name, value in list(node.attrib.items()):
                    match = tag_regexp.match(name)
                    if match:
                        attrs[(match.group(1), match.group(2))] = value
                    else:
                        attrs[(None, name)] = value
                return (_base.ELEMENT, namespace, tag,
                        attrs, len(node) or node.text)

        def getFirstChild(self, node):
            if isinstance(node, tuple):
                element, key, parents, flag = node
            else:
                element, key, parents, flag = node, None, [], None

            if flag in ("text", "tail"):
                return None
            else:
                if element.text:
                    return element, key, parents, "text"
                elif len(element):
                    parents.append(element)
                    return element[0], 0, parents, None
                else:
                    return None

        def getNextSibling(self, node):
            if isinstance(node, tuple):
                element, key, parents, flag = node
            else:
                return None

            if flag == "text":
                if len(element):
                    parents.append(element)
                    return element[0], 0, parents, None
                else:
                    return None
            else:
                if element.tail and flag != "tail":
                    return element, key, parents, "tail"
                elif key < len(parents[-1]) - 1:
                    return parents[-1][key + 1], key + 1, parents, None
                else:
                    return None

        def getParentNode(self, node):
            if isinstance(node, tuple):
                element, key, parents, flag = node
            else:
                return None

            if flag == "text":
                if not parents:
                    return element
                else:
                    return element, key, parents, None
            else:
                parent = parents.pop()
                if not parents:
                    return parent
                else:
                    return parent, list(parents[-1]).index(parent), parents, None

    return locals()

getETreeModule = moduleFactoryFactory(getETreeBuilder)

########NEW FILE########
__FILENAME__ = genshistream
from __future__ import absolute_import, division, unicode_literals

from genshi.core import QName
from genshi.core import START, END, XML_NAMESPACE, DOCTYPE, TEXT
from genshi.core import START_NS, END_NS, START_CDATA, END_CDATA, PI, COMMENT

from . import _base

from ..constants import voidElements, namespaces


class TreeWalker(_base.TreeWalker):
    def __iter__(self):
        # Buffer the events so we can pass in the following one
        previous = None
        for event in self.tree:
            if previous is not None:
                for token in self.tokens(previous, event):
                    yield token
            previous = event

        # Don't forget the final event!
        if previous is not None:
            for token in self.tokens(previous, None):
                yield token

    def tokens(self, event, next):
        kind, data, pos = event
        if kind == START:
            tag, attribs = data
            name = tag.localname
            namespace = tag.namespace
            converted_attribs = {}
            for k, v in attribs:
                if isinstance(k, QName):
                    converted_attribs[(k.namespace, k.localname)] = v
                else:
                    converted_attribs[(None, k)] = v

            if namespace == namespaces["html"] and name in voidElements:
                for token in self.emptyTag(namespace, name, converted_attribs,
                                           not next or next[0] != END
                                           or next[1] != tag):
                    yield token
            else:
                yield self.startTag(namespace, name, converted_attribs)

        elif kind == END:
            name = data.localname
            namespace = data.namespace
            if name not in voidElements:
                yield self.endTag(namespace, name)

        elif kind == COMMENT:
            yield self.comment(data)

        elif kind == TEXT:
            for token in self.text(data):
                yield token

        elif kind == DOCTYPE:
            yield self.doctype(*data)

        elif kind in (XML_NAMESPACE, DOCTYPE, START_NS, END_NS,
                      START_CDATA, END_CDATA, PI):
            pass

        else:
            yield self.unknown(kind)

########NEW FILE########
__FILENAME__ = lxmletree
from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type

from lxml import etree
from ..treebuilders.etree import tag_regexp

from gettext import gettext
_ = gettext

from . import _base

from .. import ihatexml


def ensure_str(s):
    if s is None:
        return None
    elif isinstance(s, text_type):
        return s
    else:
        return s.decode("utf-8", "strict")


class Root(object):
    def __init__(self, et):
        self.elementtree = et
        self.children = []
        if et.docinfo.internalDTD:
            self.children.append(Doctype(self,
                                         ensure_str(et.docinfo.root_name),
                                         ensure_str(et.docinfo.public_id),
                                         ensure_str(et.docinfo.system_url)))
        root = et.getroot()
        node = root

        while node.getprevious() is not None:
            node = node.getprevious()
        while node is not None:
            self.children.append(node)
            node = node.getnext()

        self.text = None
        self.tail = None

    def __getitem__(self, key):
        return self.children[key]

    def getnext(self):
        return None

    def __len__(self):
        return 1


class Doctype(object):
    def __init__(self, root_node, name, public_id, system_id):
        self.root_node = root_node
        self.name = name
        self.public_id = public_id
        self.system_id = system_id

        self.text = None
        self.tail = None

    def getnext(self):
        return self.root_node.children[1]


class FragmentRoot(Root):
    def __init__(self, children):
        self.children = [FragmentWrapper(self, child) for child in children]
        self.text = self.tail = None

    def getnext(self):
        return None


class FragmentWrapper(object):
    def __init__(self, fragment_root, obj):
        self.root_node = fragment_root
        self.obj = obj
        if hasattr(self.obj, 'text'):
            self.text = ensure_str(self.obj.text)
        else:
            self.text = None
        if hasattr(self.obj, 'tail'):
            self.tail = ensure_str(self.obj.tail)
        else:
            self.tail = None
        self.isstring = isinstance(obj, str) or isinstance(obj, bytes)
        # Support for bytes here is Py2
        if self.isstring:
            self.obj = ensure_str(self.obj)

    def __getattr__(self, name):
        return getattr(self.obj, name)

    def getnext(self):
        siblings = self.root_node.children
        idx = siblings.index(self)
        if idx < len(siblings) - 1:
            return siblings[idx + 1]
        else:
            return None

    def __getitem__(self, key):
        return self.obj[key]

    def __bool__(self):
        return bool(self.obj)

    def getparent(self):
        return None

    def __str__(self):
        return str(self.obj)

    def __unicode__(self):
        return str(self.obj)

    def __len__(self):
        return len(self.obj)


class TreeWalker(_base.NonRecursiveTreeWalker):
    def __init__(self, tree):
        if hasattr(tree, "getroot"):
            tree = Root(tree)
        elif isinstance(tree, list):
            tree = FragmentRoot(tree)
        _base.NonRecursiveTreeWalker.__init__(self, tree)
        self.filter = ihatexml.InfosetFilter()

    def getNodeDetails(self, node):
        if isinstance(node, tuple):  # Text node
            node, key = node
            assert key in ("text", "tail"), _("Text nodes are text or tail, found %s") % key
            return _base.TEXT, ensure_str(getattr(node, key))

        elif isinstance(node, Root):
            return (_base.DOCUMENT,)

        elif isinstance(node, Doctype):
            return _base.DOCTYPE, node.name, node.public_id, node.system_id

        elif isinstance(node, FragmentWrapper) and node.isstring:
            return _base.TEXT, node.obj

        elif node.tag == etree.Comment:
            return _base.COMMENT, ensure_str(node.text)

        elif node.tag == etree.Entity:
            return _base.ENTITY, ensure_str(node.text)[1:-1]  # strip &;

        else:
            # This is assumed to be an ordinary element
            match = tag_regexp.match(ensure_str(node.tag))
            if match:
                namespace, tag = match.groups()
            else:
                namespace = None
                tag = ensure_str(node.tag)
            attrs = {}
            for name, value in list(node.attrib.items()):
                name = ensure_str(name)
                value = ensure_str(value)
                match = tag_regexp.match(name)
                if match:
                    attrs[(match.group(1), match.group(2))] = value
                else:
                    attrs[(None, name)] = value
            return (_base.ELEMENT, namespace, self.filter.fromXmlName(tag),
                    attrs, len(node) > 0 or node.text)

    def getFirstChild(self, node):
        assert not isinstance(node, tuple), _("Text nodes have no children")

        assert len(node) or node.text, "Node has no children"
        if node.text:
            return (node, "text")
        else:
            return node[0]

    def getNextSibling(self, node):
        if isinstance(node, tuple):  # Text node
            node, key = node
            assert key in ("text", "tail"), _("Text nodes are text or tail, found %s") % key
            if key == "text":
                # XXX: we cannot use a "bool(node) and node[0] or None" construct here
                # because node[0] might evaluate to False if it has no child element
                if len(node):
                    return node[0]
                else:
                    return None
            else:  # tail
                return node.getnext()

        return (node, "tail") if node.tail else node.getnext()

    def getParentNode(self, node):
        if isinstance(node, tuple):  # Text node
            node, key = node
            assert key in ("text", "tail"), _("Text nodes are text or tail, found %s") % key
            if key == "text":
                return node
            # else: fallback to "normal" processing

        return node.getparent()

########NEW FILE########
__FILENAME__ = pulldom
from __future__ import absolute_import, division, unicode_literals

from xml.dom.pulldom import START_ELEMENT, END_ELEMENT, \
    COMMENT, IGNORABLE_WHITESPACE, CHARACTERS

from . import _base

from ..constants import voidElements


class TreeWalker(_base.TreeWalker):
    def __iter__(self):
        ignore_until = None
        previous = None
        for event in self.tree:
            if previous is not None and \
                    (ignore_until is None or previous[1] is ignore_until):
                if previous[1] is ignore_until:
                    ignore_until = None
                for token in self.tokens(previous, event):
                    yield token
                    if token["type"] == "EmptyTag":
                        ignore_until = previous[1]
            previous = event
        if ignore_until is None or previous[1] is ignore_until:
            for token in self.tokens(previous, None):
                yield token
        elif ignore_until is not None:
            raise ValueError("Illformed DOM event stream: void element without END_ELEMENT")

    def tokens(self, event, next):
        type, node = event
        if type == START_ELEMENT:
            name = node.nodeName
            namespace = node.namespaceURI
            attrs = {}
            for attr in list(node.attributes.keys()):
                attr = node.getAttributeNode(attr)
                attrs[(attr.namespaceURI, attr.localName)] = attr.value
            if name in voidElements:
                for token in self.emptyTag(namespace,
                                           name,
                                           attrs,
                                           not next or next[1] is not node):
                    yield token
            else:
                yield self.startTag(namespace, name, attrs)

        elif type == END_ELEMENT:
            name = node.nodeName
            namespace = node.namespaceURI
            if name not in voidElements:
                yield self.endTag(namespace, name)

        elif type == COMMENT:
            yield self.comment(node.nodeValue)

        elif type in (IGNORABLE_WHITESPACE, CHARACTERS):
            for token in self.text(node.nodeValue):
                yield token

        else:
            yield self.unknown(type)

########NEW FILE########
__FILENAME__ = _base
from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type, string_types

import gettext
_ = gettext.gettext

from xml.dom import Node

DOCUMENT = Node.DOCUMENT_NODE
DOCTYPE = Node.DOCUMENT_TYPE_NODE
TEXT = Node.TEXT_NODE
ELEMENT = Node.ELEMENT_NODE
COMMENT = Node.COMMENT_NODE
ENTITY = Node.ENTITY_NODE
UNKNOWN = "<#UNKNOWN#>"

from ..constants import voidElements, spaceCharacters
spaceCharacters = "".join(spaceCharacters)


def to_text(s, blank_if_none=True):
    """Wrapper around six.text_type to convert None to empty string"""
    if s is None:
        if blank_if_none:
            return ""
        else:
            return None
    elif isinstance(s, text_type):
        return s
    else:
        return text_type(s)


def is_text_or_none(string):
    """Wrapper around isinstance(string_types) or is None"""
    return string is None or isinstance(string, string_types)


class TreeWalker(object):
    def __init__(self, tree):
        self.tree = tree

    def __iter__(self):
        raise NotImplementedError

    def error(self, msg):
        return {"type": "SerializeError", "data": msg}

    def emptyTag(self, namespace, name, attrs, hasChildren=False):
        assert namespace is None or isinstance(namespace, string_types), type(namespace)
        assert isinstance(name, string_types), type(name)
        assert all((namespace is None or isinstance(namespace, string_types)) and
                   isinstance(name, string_types) and
                   isinstance(value, string_types)
                   for (namespace, name), value in attrs.items())

        yield {"type": "EmptyTag", "name": to_text(name, False),
               "namespace": to_text(namespace),
               "data": attrs}
        if hasChildren:
            yield self.error(_("Void element has children"))

    def startTag(self, namespace, name, attrs):
        assert namespace is None or isinstance(namespace, string_types), type(namespace)
        assert isinstance(name, string_types), type(name)
        assert all((namespace is None or isinstance(namespace, string_types)) and
                   isinstance(name, string_types) and
                   isinstance(value, string_types)
                   for (namespace, name), value in attrs.items())

        return {"type": "StartTag",
                "name": text_type(name),
                "namespace": to_text(namespace),
                "data": dict(((to_text(namespace, False), to_text(name)),
                              to_text(value, False))
                             for (namespace, name), value in attrs.items())}

    def endTag(self, namespace, name):
        assert namespace is None or isinstance(namespace, string_types), type(namespace)
        assert isinstance(name, string_types), type(namespace)

        return {"type": "EndTag",
                "name": to_text(name, False),
                "namespace": to_text(namespace),
                "data": {}}

    def text(self, data):
        assert isinstance(data, string_types), type(data)

        data = to_text(data)
        middle = data.lstrip(spaceCharacters)
        left = data[:len(data) - len(middle)]
        if left:
            yield {"type": "SpaceCharacters", "data": left}
        data = middle
        middle = data.rstrip(spaceCharacters)
        right = data[len(middle):]
        if middle:
            yield {"type": "Characters", "data": middle}
        if right:
            yield {"type": "SpaceCharacters", "data": right}

    def comment(self, data):
        assert isinstance(data, string_types), type(data)

        return {"type": "Comment", "data": text_type(data)}

    def doctype(self, name, publicId=None, systemId=None, correct=True):
        assert is_text_or_none(name), type(name)
        assert is_text_or_none(publicId), type(publicId)
        assert is_text_or_none(systemId), type(systemId)

        return {"type": "Doctype",
                "name": to_text(name),
                "publicId": to_text(publicId),
                "systemId": to_text(systemId),
                "correct": to_text(correct)}

    def entity(self, name):
        assert isinstance(name, string_types), type(name)

        return {"type": "Entity", "name": text_type(name)}

    def unknown(self, nodeType):
        return self.error(_("Unknown node type: ") + nodeType)


class NonRecursiveTreeWalker(TreeWalker):
    def getNodeDetails(self, node):
        raise NotImplementedError

    def getFirstChild(self, node):
        raise NotImplementedError

    def getNextSibling(self, node):
        raise NotImplementedError

    def getParentNode(self, node):
        raise NotImplementedError

    def __iter__(self):
        currentNode = self.tree
        while currentNode is not None:
            details = self.getNodeDetails(currentNode)
            type, details = details[0], details[1:]
            hasChildren = False

            if type == DOCTYPE:
                yield self.doctype(*details)

            elif type == TEXT:
                for token in self.text(*details):
                    yield token

            elif type == ELEMENT:
                namespace, name, attributes, hasChildren = details
                if name in voidElements:
                    for token in self.emptyTag(namespace, name, attributes,
                                               hasChildren):
                        yield token
                    hasChildren = False
                else:
                    yield self.startTag(namespace, name, attributes)

            elif type == COMMENT:
                yield self.comment(details[0])

            elif type == ENTITY:
                yield self.entity(details[0])

            elif type == DOCUMENT:
                hasChildren = True

            else:
                yield self.unknown(details[0])

            if hasChildren:
                firstChild = self.getFirstChild(currentNode)
            else:
                firstChild = None

            if firstChild is not None:
                currentNode = firstChild
            else:
                while currentNode is not None:
                    details = self.getNodeDetails(currentNode)
                    type, details = details[0], details[1:]
                    if type == ELEMENT:
                        namespace, name, attributes, hasChildren = details
                        if name not in voidElements:
                            yield self.endTag(namespace, name)
                    if self.tree is currentNode:
                        currentNode = None
                        break
                    nextSibling = self.getNextSibling(currentNode)
                    if nextSibling is not None:
                        currentNode = nextSibling
                        break
                    else:
                        currentNode = self.getParentNode(currentNode)

########NEW FILE########
__FILENAME__ = datrie
from __future__ import absolute_import, division, unicode_literals

from datrie import Trie as DATrie
from pip._vendor.six import text_type

from ._base import Trie as ABCTrie


class Trie(ABCTrie):
    def __init__(self, data):
        chars = set()
        for key in data.keys():
            if not isinstance(key, text_type):
                raise TypeError("All keys must be strings")
            for char in key:
                chars.add(char)

        self._data = DATrie("".join(chars))
        for key, value in data.items():
            self._data[key] = value

    def __contains__(self, key):
        return key in self._data

    def __len__(self):
        return len(self._data)

    def __iter__(self):
        raise NotImplementedError()

    def __getitem__(self, key):
        return self._data[key]

    def keys(self, prefix=None):
        return self._data.keys(prefix)

    def has_keys_with_prefix(self, prefix):
        return self._data.has_keys_with_prefix(prefix)

    def longest_prefix(self, prefix):
        return self._data.longest_prefix(prefix)

    def longest_prefix_item(self, prefix):
        return self._data.longest_prefix_item(prefix)

########NEW FILE########
__FILENAME__ = py
from __future__ import absolute_import, division, unicode_literals
from pip._vendor.six import text_type

from bisect import bisect_left

from ._base import Trie as ABCTrie


class Trie(ABCTrie):
    def __init__(self, data):
        if not all(isinstance(x, text_type) for x in data.keys()):
            raise TypeError("All keys must be strings")

        self._data = data
        self._keys = sorted(data.keys())
        self._cachestr = ""
        self._cachepoints = (0, len(data))

    def __contains__(self, key):
        return key in self._data

    def __len__(self):
        return len(self._data)

    def __iter__(self):
        return iter(self._data)

    def __getitem__(self, key):
        return self._data[key]

    def keys(self, prefix=None):
        if prefix is None or prefix == "" or not self._keys:
            return set(self._keys)

        if prefix.startswith(self._cachestr):
            lo, hi = self._cachepoints
            start = i = bisect_left(self._keys, prefix, lo, hi)
        else:
            start = i = bisect_left(self._keys, prefix)

        keys = set()
        if start == len(self._keys):
            return keys

        while self._keys[i].startswith(prefix):
            keys.add(self._keys[i])
            i += 1

        self._cachestr = prefix
        self._cachepoints = (start, i)

        return keys

    def has_keys_with_prefix(self, prefix):
        if prefix in self._data:
            return True

        if prefix.startswith(self._cachestr):
            lo, hi = self._cachepoints
            i = bisect_left(self._keys, prefix, lo, hi)
        else:
            i = bisect_left(self._keys, prefix)

        if i == len(self._keys):
            return False

        return self._keys[i].startswith(prefix)

########NEW FILE########
__FILENAME__ = _base
from __future__ import absolute_import, division, unicode_literals

from collections import Mapping


class Trie(Mapping):
    """Abstract base class for tries"""

    def keys(self, prefix=None):
        keys = super().keys()

        if prefix is None:
            return set(keys)

        # Python 2.6: no set comprehensions
        return set([x for x in keys if x.startswith(prefix)])

    def has_keys_with_prefix(self, prefix):
        for key in self.keys():
            if key.startswith(prefix):
                return True

        return False

    def longest_prefix(self, prefix):
        if prefix in self:
            return prefix

        for i in range(1, len(prefix) + 1):
            if prefix[:-i] in self:
                return prefix[:-i]

        raise KeyError(prefix)

    def longest_prefix_item(self, prefix):
        lprefix = self.longest_prefix(prefix)
        return (lprefix, self[lprefix])

########NEW FILE########
__FILENAME__ = utils
from __future__ import absolute_import, division, unicode_literals

from types import ModuleType

try:
    import xml.etree.cElementTree as default_etree
except ImportError:
    import xml.etree.ElementTree as default_etree


__all__ = ["default_etree", "MethodDispatcher", "isSurrogatePair",
           "surrogatePairToCodepoint", "moduleFactoryFactory"]


class MethodDispatcher(dict):
    """Dict with 2 special properties:

    On initiation, keys that are lists, sets or tuples are converted to
    multiple keys so accessing any one of the items in the original
    list-like object returns the matching value

    md = MethodDispatcher({("foo", "bar"):"baz"})
    md["foo"] == "baz"

    A default value which can be set through the default attribute.
    """

    def __init__(self, items=()):
        # Using _dictEntries instead of directly assigning to self is about
        # twice as fast. Please do careful performance testing before changing
        # anything here.
        _dictEntries = []
        for name, value in items:
            if type(name) in (list, tuple, frozenset, set):
                for item in name:
                    _dictEntries.append((item, value))
            else:
                _dictEntries.append((name, value))
        dict.__init__(self, _dictEntries)
        self.default = None

    def __getitem__(self, key):
        return dict.get(self, key, self.default)


# Some utility functions to dal with weirdness around UCS2 vs UCS4
# python builds

def isSurrogatePair(data):
    return (len(data) == 2 and
            ord(data[0]) >= 0xD800 and ord(data[0]) <= 0xDBFF and
            ord(data[1]) >= 0xDC00 and ord(data[1]) <= 0xDFFF)


def surrogatePairToCodepoint(data):
    char_val = (0x10000 + (ord(data[0]) - 0xD800) * 0x400 +
                (ord(data[1]) - 0xDC00))
    return char_val

# Module Factory Factory (no, this isn't Java, I know)
# Here to stop this being duplicated all over the place.


def moduleFactoryFactory(factory):
    moduleCache = {}

    def moduleFactory(baseModule, *args, **kwargs):
        if isinstance(ModuleType.__name__, type("")):
            name = "_%s_factory" % baseModule.__name__
        else:
            name = b"_%s_factory" % baseModule.__name__

        if name in moduleCache:
            return moduleCache[name]
        else:
            mod = ModuleType(name)
            objs = factory(baseModule, *args, **kwargs)
            mod.__dict__.update(objs)
            moduleCache[name] = mod
            return mod

    return moduleFactory

########NEW FILE########
__FILENAME__ = linklockfile
from __future__ import absolute_import

import time
import os

from . import (LockBase, LockFailed, NotLocked, NotMyLock, LockTimeout,
               AlreadyLocked)

class LinkLockFile(LockBase):
    """Lock access to a file using atomic property of link(2).

    >>> lock = LinkLockFile('somefile')
    >>> lock = LinkLockFile('somefile', threaded=False)
    """

    def acquire(self, timeout=None):
        try:
            open(self.unique_name, "wb").close()
        except IOError:
            raise LockFailed("failed to create %s" % self.unique_name)

        timeout = timeout or self.timeout
        end_time = time.time()
        if timeout is not None and timeout > 0:
            end_time += timeout

        while True:
            # Try and create a hard link to it.
            try:
                os.link(self.unique_name, self.lock_file)
            except OSError:
                # Link creation failed.  Maybe we've double-locked?
                nlinks = os.stat(self.unique_name).st_nlink
                if nlinks == 2:
                    # The original link plus the one I created == 2.  We're
                    # good to go.
                    return
                else:
                    # Otherwise the lock creation failed.
                    if timeout is not None and time.time() > end_time:
                        os.unlink(self.unique_name)
                        if timeout > 0:
                            raise LockTimeout("Timeout waiting to acquire"
                                              " lock for %s" %
                                              self.path)
                        else:
                            raise AlreadyLocked("%s is already locked" %
                                                self.path)
                    time.sleep(timeout is not None and timeout/10 or 0.1)
            else:
                # Link creation succeeded.  We're good to go.
                return

    def release(self):
        if not self.is_locked():
            raise NotLocked("%s is not locked" % self.path)
        elif not os.path.exists(self.unique_name):
            raise NotMyLock("%s is locked, but not by me" % self.path)
        os.unlink(self.unique_name)
        os.unlink(self.lock_file)

    def is_locked(self):
        return os.path.exists(self.lock_file)

    def i_am_locking(self):
        return (self.is_locked() and
                os.path.exists(self.unique_name) and
                os.stat(self.unique_name).st_nlink == 2)

    def break_lock(self):
        if os.path.exists(self.lock_file):
            os.unlink(self.lock_file)


########NEW FILE########
__FILENAME__ = mkdirlockfile
from __future__ import absolute_import, division

import time
import os
import sys
import errno

from . import (LockBase, LockFailed, NotLocked, NotMyLock, LockTimeout,
               AlreadyLocked)

class MkdirLockFile(LockBase):
    """Lock file by creating a directory."""
    def __init__(self, path, threaded=True, timeout=None):
        """
        >>> lock = MkdirLockFile('somefile')
        >>> lock = MkdirLockFile('somefile', threaded=False)
        """
        LockBase.__init__(self, path, threaded, timeout)
        # Lock file itself is a directory.  Place the unique file name into
        # it.
        self.unique_name  = os.path.join(self.lock_file,
                                         "%s.%s%s" % (self.hostname,
                                                      self.tname,
                                                      self.pid))

    def acquire(self, timeout=None):
        timeout = timeout or self.timeout
        end_time = time.time()
        if timeout is not None and timeout > 0:
            end_time += timeout

        if timeout is None:
            wait = 0.1
        else:
            wait = max(0, timeout / 10)

        while True:
            try:
                os.mkdir(self.lock_file)
            except OSError:
                err = sys.exc_info()[1]
                if err.errno == errno.EEXIST:
                    # Already locked.
                    if os.path.exists(self.unique_name):
                        # Already locked by me.
                        return
                    if timeout is not None and time.time() > end_time:
                        if timeout > 0:
                            raise LockTimeout("Timeout waiting to acquire"
                                              " lock for %s" %
                                              self.path)
                        else:
                            # Someone else has the lock.
                            raise AlreadyLocked("%s is already locked" %
                                                self.path)
                    time.sleep(wait)
                else:
                    # Couldn't create the lock for some other reason
                    raise LockFailed("failed to create %s" % self.lock_file)
            else:
                open(self.unique_name, "wb").close()
                return

    def release(self):
        if not self.is_locked():
            raise NotLocked("%s is not locked" % self.path)
        elif not os.path.exists(self.unique_name):
            raise NotMyLock("%s is locked, but not by me" % self.path)
        os.unlink(self.unique_name)
        os.rmdir(self.lock_file)

    def is_locked(self):
        return os.path.exists(self.lock_file)

    def i_am_locking(self):
        return (self.is_locked() and
                os.path.exists(self.unique_name))

    def break_lock(self):
        if os.path.exists(self.lock_file):
            for name in os.listdir(self.lock_file):
                os.unlink(os.path.join(self.lock_file, name))
            os.rmdir(self.lock_file)

########NEW FILE########
__FILENAME__ = pidlockfile
# -*- coding: utf-8 -*-

# pidlockfile.py
#
# Copyright © 2008–2009 Ben Finney <ben+python@benfinney.id.au>
#
# This is free software: you may copy, modify, and/or distribute this work
# under the terms of the Python Software Foundation License, version 2 or
# later as published by the Python Software Foundation.
# No warranty expressed or implied. See the file LICENSE.PSF-2 for details.

""" Lockfile behaviour implemented via Unix PID files.
    """

from __future__ import absolute_import

import os
import sys
import errno
import time

from . import (LockBase, AlreadyLocked, LockFailed, NotLocked, NotMyLock,
               LockTimeout)


class PIDLockFile(LockBase):
    """ Lockfile implemented as a Unix PID file.

    The lock file is a normal file named by the attribute `path`.
    A lock's PID file contains a single line of text, containing
    the process ID (PID) of the process that acquired the lock.

    >>> lock = PIDLockFile('somefile')
    >>> lock = PIDLockFile('somefile')
    """

    def __init__(self, path, threaded=False, timeout=None):
        # pid lockfiles don't support threaded operation, so always force
        # False as the threaded arg.
        LockBase.__init__(self, path, False, timeout)
        dirname = os.path.dirname(self.lock_file)
        basename = os.path.split(self.path)[-1]
        self.unique_name = self.path

    def read_pid(self):
        """ Get the PID from the lock file.
            """
        return read_pid_from_pidfile(self.path)

    def is_locked(self):
        """ Test if the lock is currently held.

            The lock is held if the PID file for this lock exists.

            """
        return os.path.exists(self.path)

    def i_am_locking(self):
        """ Test if the lock is held by the current process.

        Returns ``True`` if the current process ID matches the
        number stored in the PID file.
        """
        return self.is_locked() and os.getpid() == self.read_pid()

    def acquire(self, timeout=None):
        """ Acquire the lock.

        Creates the PID file for this lock, or raises an error if
        the lock could not be acquired.
        """

        timeout = timeout or self.timeout
        end_time = time.time()
        if timeout is not None and timeout > 0:
            end_time += timeout

        while True:
            try:
                write_pid_to_pidfile(self.path)
            except OSError as exc:
                if exc.errno == errno.EEXIST:
                    # The lock creation failed.  Maybe sleep a bit.
                    if timeout is not None and time.time() > end_time:
                        if timeout > 0:
                            raise LockTimeout("Timeout waiting to acquire"
                                              " lock for %s" %
                                              self.path)
                        else:
                            raise AlreadyLocked("%s is already locked" %
                                                self.path)
                    time.sleep(timeout is not None and timeout/10 or 0.1)
                else:
                    raise LockFailed("failed to create %s" % self.path)
            else:
                return

    def release(self):
        """ Release the lock.

            Removes the PID file to release the lock, or raises an
            error if the current process does not hold the lock.

            """
        if not self.is_locked():
            raise NotLocked("%s is not locked" % self.path)
        if not self.i_am_locking():
            raise NotMyLock("%s is locked, but not by me" % self.path)
        remove_existing_pidfile(self.path)

    def break_lock(self):
        """ Break an existing lock.

            Removes the PID file if it already exists, otherwise does
            nothing.

            """
        remove_existing_pidfile(self.path)

def read_pid_from_pidfile(pidfile_path):
    """ Read the PID recorded in the named PID file.

        Read and return the numeric PID recorded as text in the named
        PID file. If the PID file cannot be read, or if the content is
        not a valid PID, return ``None``.

        """
    pid = None
    try:
        pidfile = open(pidfile_path, 'r')
    except IOError:
        pass
    else:
        # According to the FHS 2.3 section on PID files in /var/run:
        # 
        #   The file must consist of the process identifier in
        #   ASCII-encoded decimal, followed by a newline character.
        # 
        #   Programs that read PID files should be somewhat flexible
        #   in what they accept; i.e., they should ignore extra
        #   whitespace, leading zeroes, absence of the trailing
        #   newline, or additional lines in the PID file.

        line = pidfile.readline().strip()
        try:
            pid = int(line)
        except ValueError:
            pass
        pidfile.close()

    return pid


def write_pid_to_pidfile(pidfile_path):
    """ Write the PID in the named PID file.

        Get the numeric process ID (“PID”) of the current process
        and write it to the named file as a line of text.

        """
    open_flags = (os.O_CREAT | os.O_EXCL | os.O_WRONLY)
    open_mode = 0o644
    pidfile_fd = os.open(pidfile_path, open_flags, open_mode)
    pidfile = os.fdopen(pidfile_fd, 'w')

    # According to the FHS 2.3 section on PID files in /var/run:
    #
    #   The file must consist of the process identifier in
    #   ASCII-encoded decimal, followed by a newline character. For
    #   example, if crond was process number 25, /var/run/crond.pid
    #   would contain three characters: two, five, and newline.

    pid = os.getpid()
    line = "%(pid)d\n" % vars()
    pidfile.write(line)
    pidfile.close()


def remove_existing_pidfile(pidfile_path):
    """ Remove the named PID file if it exists.

        Removing a PID file that doesn't already exist puts us in the
        desired state, so we ignore the condition if the file does not
        exist.

        """
    try:
        os.remove(pidfile_path)
    except OSError as exc:
        if exc.errno == errno.ENOENT:
            pass
        else:
            raise

########NEW FILE########
__FILENAME__ = sqlitelockfile
from __future__ import absolute_import, division

import time
import os

try:
    unicode
except NameError:
    unicode = str

from . import LockBase, NotLocked, NotMyLock, LockTimeout, AlreadyLocked

class SQLiteLockFile(LockBase):
    "Demonstrate SQL-based locking."

    testdb = None

    def __init__(self, path, threaded=True, timeout=None):
        """
        >>> lock = SQLiteLockFile('somefile')
        >>> lock = SQLiteLockFile('somefile', threaded=False)
        """
        LockBase.__init__(self, path, threaded, timeout)
        self.lock_file = unicode(self.lock_file)
        self.unique_name = unicode(self.unique_name)

        if SQLiteLockFile.testdb is None:
            import tempfile
            _fd, testdb = tempfile.mkstemp()
            os.close(_fd)
            os.unlink(testdb)
            del _fd, tempfile
            SQLiteLockFile.testdb = testdb

        import sqlite3
        self.connection = sqlite3.connect(SQLiteLockFile.testdb)
        
        c = self.connection.cursor()
        try:
            c.execute("create table locks"
                      "("
                      "   lock_file varchar(32),"
                      "   unique_name varchar(32)"
                      ")")
        except sqlite3.OperationalError:
            pass
        else:
            self.connection.commit()
            import atexit
            atexit.register(os.unlink, SQLiteLockFile.testdb)

    def acquire(self, timeout=None):
        timeout = timeout or self.timeout
        end_time = time.time()
        if timeout is not None and timeout > 0:
            end_time += timeout

        if timeout is None:
            wait = 0.1
        elif timeout <= 0:
            wait = 0
        else:
            wait = timeout / 10

        cursor = self.connection.cursor()

        while True:
            if not self.is_locked():
                # Not locked.  Try to lock it.
                cursor.execute("insert into locks"
                               "  (lock_file, unique_name)"
                               "  values"
                               "  (?, ?)",
                               (self.lock_file, self.unique_name))
                self.connection.commit()

                # Check to see if we are the only lock holder.
                cursor.execute("select * from locks"
                               "  where unique_name = ?",
                               (self.unique_name,))
                rows = cursor.fetchall()
                if len(rows) > 1:
                    # Nope.  Someone else got there.  Remove our lock.
                    cursor.execute("delete from locks"
                                   "  where unique_name = ?",
                                   (self.unique_name,))
                    self.connection.commit()
                else:
                    # Yup.  We're done, so go home.
                    return
            else:
                # Check to see if we are the only lock holder.
                cursor.execute("select * from locks"
                               "  where unique_name = ?",
                               (self.unique_name,))
                rows = cursor.fetchall()
                if len(rows) == 1:
                    # We're the locker, so go home.
                    return
                    
            # Maybe we should wait a bit longer.
            if timeout is not None and time.time() > end_time:
                if timeout > 0:
                    # No more waiting.
                    raise LockTimeout("Timeout waiting to acquire"
                                      " lock for %s" %
                                      self.path)
                else:
                    # Someone else has the lock and we are impatient..
                    raise AlreadyLocked("%s is already locked" % self.path)

            # Well, okay.  We'll give it a bit longer.
            time.sleep(wait)

    def release(self):
        if not self.is_locked():
            raise NotLocked("%s is not locked" % self.path)
        if not self.i_am_locking():
            raise NotMyLock("%s is locked, but not by me (by %s)" %
                            (self.unique_name, self._who_is_locking()))
        cursor = self.connection.cursor()
        cursor.execute("delete from locks"
                       "  where unique_name = ?",
                       (self.unique_name,))
        self.connection.commit()

    def _who_is_locking(self):
        cursor = self.connection.cursor()
        cursor.execute("select unique_name from locks"
                       "  where lock_file = ?",
                       (self.lock_file,))
        return cursor.fetchone()[0]
        
    def is_locked(self):
        cursor = self.connection.cursor()
        cursor.execute("select * from locks"
                       "  where lock_file = ?",
                       (self.lock_file,))
        rows = cursor.fetchall()
        return not not rows

    def i_am_locking(self):
        cursor = self.connection.cursor()
        cursor.execute("select * from locks"
                       "  where lock_file = ?"
                       "    and unique_name = ?",
                       (self.lock_file, self.unique_name))
        return not not cursor.fetchall()

    def break_lock(self):
        cursor = self.connection.cursor()
        cursor.execute("delete from locks"
                       "  where lock_file = ?",
                       (self.lock_file,))
        self.connection.commit()

########NEW FILE########
__FILENAME__ = symlinklockfile
from __future__ import absolute_import

import time
import os

from . import (LockBase, LockFailed, NotLocked, NotMyLock, LockTimeout,
               AlreadyLocked)

class SymlinkLockFile(LockBase):
    """Lock access to a file using symlink(2)."""

    def __init__(self, path, threaded=True, timeout=None):
        # super(SymlinkLockFile).__init(...)
        LockBase.__init__(self, path, threaded, timeout)
        # split it back!
        self.unique_name = os.path.split(self.unique_name)[1]

    def acquire(self, timeout=None):
        # Hopefully unnecessary for symlink.
        #try:
        #    open(self.unique_name, "wb").close()
        #except IOError:
        #    raise LockFailed("failed to create %s" % self.unique_name)
        timeout = timeout or self.timeout
        end_time = time.time()
        if timeout is not None and timeout > 0:
            end_time += timeout

        while True:
            # Try and create a symbolic link to it.
            try:
                os.symlink(self.unique_name, self.lock_file)
            except OSError:
                # Link creation failed.  Maybe we've double-locked?
                if self.i_am_locking():
                    # Linked to out unique name. Proceed.
                    return
                else:
                    # Otherwise the lock creation failed.
                    if timeout is not None and time.time() > end_time:
                        if timeout > 0:
                            raise LockTimeout("Timeout waiting to acquire"
                                              " lock for %s" %
                                              self.path)
                        else:
                            raise AlreadyLocked("%s is already locked" %
                                                self.path)
                    time.sleep(timeout/10 if timeout is not None else 0.1)
            else:
                # Link creation succeeded.  We're good to go.
                return

    def release(self):
        if not self.is_locked():
            raise NotLocked("%s is not locked" % self.path)
        elif not self.i_am_locking():
            raise NotMyLock("%s is locked, but not by me" % self.path)
        os.unlink(self.lock_file)

    def is_locked(self):
        return os.path.islink(self.lock_file)

    def i_am_locking(self):
        return os.path.islink(self.lock_file) and \
         os.readlink(self.lock_file) == self.unique_name

    def break_lock(self):
        if os.path.islink(self.lock_file):  # exists && link
            os.unlink(self.lock_file)

########NEW FILE########
__FILENAME__ = pkg_resources
"""
Package resource API
--------------------

A resource is a logical file contained within a package, or a logical
subdirectory thereof.  The package resource API expects resource names
to have their path parts separated with ``/``, *not* whatever the local
path separator is.  Do not use os.path operations to manipulate resource
names being passed into the API.

The package resource API is designed to work with normal filesystem packages,
.egg files, and unpacked .egg files.  It can also work in a limited way with
.zip files and with custom PEP 302 loaders that support the ``get_data()``
method.
"""

import sys
import os
import time
import re
import imp
import zipfile
import zipimport
import warnings
import stat
import functools
import pkgutil
import token
import symbol
import operator
import platform
from pkgutil import get_importer

try:
    from urlparse import urlparse, urlunparse
except ImportError:
    from urllib.parse import urlparse, urlunparse

try:
    frozenset
except NameError:
    from sets import ImmutableSet as frozenset
try:
    basestring
    next = lambda o: o.next()
    from cStringIO import StringIO as BytesIO
except NameError:
    basestring = str
    from io import BytesIO
    def execfile(fn, globs=None, locs=None):
        if globs is None:
            globs = globals()
        if locs is None:
            locs = globs
        exec(compile(open(fn).read(), fn, 'exec'), globs, locs)

# capture these to bypass sandboxing
from os import utime
try:
    from os import mkdir, rename, unlink
    WRITE_SUPPORT = True
except ImportError:
    # no write support, probably under GAE
    WRITE_SUPPORT = False

from os import open as os_open
from os.path import isdir, split

# Avoid try/except due to potential problems with delayed import mechanisms.
if sys.version_info >= (3, 3) and sys.implementation.name == "cpython":
    import importlib._bootstrap as importlib_bootstrap
else:
    importlib_bootstrap = None

try:
    import parser
except ImportError:
    pass

def _bypass_ensure_directory(name, mode=0x1FF):  # 0777
    # Sandbox-bypassing version of ensure_directory()
    if not WRITE_SUPPORT:
        raise IOError('"os.mkdir" not supported on this platform.')
    dirname, filename = split(name)
    if dirname and filename and not isdir(dirname):
        _bypass_ensure_directory(dirname)
        mkdir(dirname, mode)


_state_vars = {}

def _declare_state(vartype, **kw):
    globals().update(kw)
    _state_vars.update(dict.fromkeys(kw, vartype))

def __getstate__():
    state = {}
    g = globals()
    for k, v in _state_vars.items():
        state[k] = g['_sget_'+v](g[k])
    return state

def __setstate__(state):
    g = globals()
    for k, v in state.items():
        g['_sset_'+_state_vars[k]](k, g[k], v)
    return state

def _sget_dict(val):
    return val.copy()

def _sset_dict(key, ob, state):
    ob.clear()
    ob.update(state)

def _sget_object(val):
    return val.__getstate__()

def _sset_object(key, ob, state):
    ob.__setstate__(state)

_sget_none = _sset_none = lambda *args: None


def get_supported_platform():
    """Return this platform's maximum compatible version.

    distutils.util.get_platform() normally reports the minimum version
    of Mac OS X that would be required to *use* extensions produced by
    distutils.  But what we want when checking compatibility is to know the
    version of Mac OS X that we are *running*.  To allow usage of packages that
    explicitly require a newer version of Mac OS X, we must also know the
    current version of the OS.

    If this condition occurs for any other platform with a version in its
    platform strings, this function should be extended accordingly.
    """
    plat = get_build_platform()
    m = macosVersionString.match(plat)
    if m is not None and sys.platform == "darwin":
        try:
            plat = 'macosx-%s-%s' % ('.'.join(_macosx_vers()[:2]), m.group(3))
        except ValueError:
            pass    # not Mac OS X
    return plat

__all__ = [
    # Basic resource access and distribution/entry point discovery
    'require', 'run_script', 'get_provider',  'get_distribution',
    'load_entry_point', 'get_entry_map', 'get_entry_info', 'iter_entry_points',
    'resource_string', 'resource_stream', 'resource_filename',
    'resource_listdir', 'resource_exists', 'resource_isdir',

    # Environmental control
    'declare_namespace', 'working_set', 'add_activation_listener',
    'find_distributions', 'set_extraction_path', 'cleanup_resources',
    'get_default_cache',

    # Primary implementation classes
    'Environment', 'WorkingSet', 'ResourceManager',
    'Distribution', 'Requirement', 'EntryPoint',

    # Exceptions
    'ResolutionError','VersionConflict','DistributionNotFound','UnknownExtra',
    'ExtractionError',

    # Parsing functions and string utilities
    'parse_requirements', 'parse_version', 'safe_name', 'safe_version',
    'get_platform', 'compatible_platforms', 'yield_lines', 'split_sections',
    'safe_extra', 'to_filename', 'invalid_marker', 'evaluate_marker',

    # filesystem utilities
    'ensure_directory', 'normalize_path',

    # Distribution "precedence" constants
    'EGG_DIST', 'BINARY_DIST', 'SOURCE_DIST', 'CHECKOUT_DIST', 'DEVELOP_DIST',

    # "Provider" interfaces, implementations, and registration/lookup APIs
    'IMetadataProvider', 'IResourceProvider', 'FileMetadata',
    'PathMetadata', 'EggMetadata', 'EmptyProvider', 'empty_provider',
    'NullProvider', 'EggProvider', 'DefaultProvider', 'ZipProvider',
    'register_finder', 'register_namespace_handler', 'register_loader_type',
    'fixup_namespace_packages', 'get_importer',

    # Deprecated/backward compatibility only
    'run_main', 'AvailableDistributions',
]

class ResolutionError(Exception):
    """Abstract base for dependency resolution errors"""
    def __repr__(self):
        return self.__class__.__name__+repr(self.args)

class VersionConflict(ResolutionError):
    """An already-installed version conflicts with the requested version"""

class DistributionNotFound(ResolutionError):
    """A requested distribution was not found"""

class UnknownExtra(ResolutionError):
    """Distribution doesn't have an "extra feature" of the given name"""
_provider_factories = {}

PY_MAJOR = sys.version[:3]
EGG_DIST = 3
BINARY_DIST = 2
SOURCE_DIST = 1
CHECKOUT_DIST = 0
DEVELOP_DIST = -1

def register_loader_type(loader_type, provider_factory):
    """Register `provider_factory` to make providers for `loader_type`

    `loader_type` is the type or class of a PEP 302 ``module.__loader__``,
    and `provider_factory` is a function that, passed a *module* object,
    returns an ``IResourceProvider`` for that module.
    """
    _provider_factories[loader_type] = provider_factory

def get_provider(moduleOrReq):
    """Return an IResourceProvider for the named module or requirement"""
    if isinstance(moduleOrReq,Requirement):
        return working_set.find(moduleOrReq) or require(str(moduleOrReq))[0]
    try:
        module = sys.modules[moduleOrReq]
    except KeyError:
        __import__(moduleOrReq)
        module = sys.modules[moduleOrReq]
    loader = getattr(module, '__loader__', None)
    return _find_adapter(_provider_factories, loader)(module)

def _macosx_vers(_cache=[]):
    if not _cache:
        import platform
        version = platform.mac_ver()[0]
        # fallback for MacPorts
        if version == '':
            import plistlib
            plist = '/System/Library/CoreServices/SystemVersion.plist'
            if os.path.exists(plist):
                if hasattr(plistlib, 'readPlist'):
                    plist_content = plistlib.readPlist(plist)
                    if 'ProductVersion' in plist_content:
                        version = plist_content['ProductVersion']

        _cache.append(version.split('.'))
    return _cache[0]

def _macosx_arch(machine):
    return {'PowerPC':'ppc', 'Power_Macintosh':'ppc'}.get(machine,machine)

def get_build_platform():
    """Return this platform's string for platform-specific distributions

    XXX Currently this is the same as ``distutils.util.get_platform()``, but it
    needs some hacks for Linux and Mac OS X.
    """
    try:
        # Python 2.7 or >=3.2
        from sysconfig import get_platform
    except ImportError:
        from distutils.util import get_platform

    plat = get_platform()
    if sys.platform == "darwin" and not plat.startswith('macosx-'):
        try:
            version = _macosx_vers()
            machine = os.uname()[4].replace(" ", "_")
            return "macosx-%d.%d-%s" % (int(version[0]), int(version[1]),
                _macosx_arch(machine))
        except ValueError:
            # if someone is running a non-Mac darwin system, this will fall
            # through to the default implementation
            pass
    return plat

macosVersionString = re.compile(r"macosx-(\d+)\.(\d+)-(.*)")
darwinVersionString = re.compile(r"darwin-(\d+)\.(\d+)\.(\d+)-(.*)")
get_platform = get_build_platform   # XXX backward compat


def compatible_platforms(provided,required):
    """Can code for the `provided` platform run on the `required` platform?

    Returns true if either platform is ``None``, or the platforms are equal.

    XXX Needs compatibility checks for Linux and other unixy OSes.
    """
    if provided is None or required is None or provided==required:
        return True     # easy case

    # Mac OS X special cases
    reqMac = macosVersionString.match(required)
    if reqMac:
        provMac = macosVersionString.match(provided)

        # is this a Mac package?
        if not provMac:
            # this is backwards compatibility for packages built before
            # setuptools 0.6. All packages built after this point will
            # use the new macosx designation.
            provDarwin = darwinVersionString.match(provided)
            if provDarwin:
                dversion = int(provDarwin.group(1))
                macosversion = "%s.%s" % (reqMac.group(1), reqMac.group(2))
                if dversion == 7 and macosversion >= "10.3" or \
                        dversion == 8 and macosversion >= "10.4":

                    #import warnings
                    #warnings.warn("Mac eggs should be rebuilt to "
                    #    "use the macosx designation instead of darwin.",
                    #    category=DeprecationWarning)
                    return True
            return False    # egg isn't macosx or legacy darwin

        # are they the same major version and machine type?
        if provMac.group(1) != reqMac.group(1) or \
                provMac.group(3) != reqMac.group(3):
            return False

        # is the required OS major update >= the provided one?
        if int(provMac.group(2)) > int(reqMac.group(2)):
            return False

        return True

    # XXX Linux and other platforms' special cases should go here
    return False


def run_script(dist_spec, script_name):
    """Locate distribution `dist_spec` and run its `script_name` script"""
    ns = sys._getframe(1).f_globals
    name = ns['__name__']
    ns.clear()
    ns['__name__'] = name
    require(dist_spec)[0].run_script(script_name, ns)

run_main = run_script   # backward compatibility

def get_distribution(dist):
    """Return a current distribution object for a Requirement or string"""
    if isinstance(dist,basestring): dist = Requirement.parse(dist)
    if isinstance(dist,Requirement): dist = get_provider(dist)
    if not isinstance(dist,Distribution):
        raise TypeError("Expected string, Requirement, or Distribution", dist)
    return dist

def load_entry_point(dist, group, name):
    """Return `name` entry point of `group` for `dist` or raise ImportError"""
    return get_distribution(dist).load_entry_point(group, name)

def get_entry_map(dist, group=None):
    """Return the entry point map for `group`, or the full entry map"""
    return get_distribution(dist).get_entry_map(group)

def get_entry_info(dist, group, name):
    """Return the EntryPoint object for `group`+`name`, or ``None``"""
    return get_distribution(dist).get_entry_info(group, name)


class IMetadataProvider:

    def has_metadata(name):
        """Does the package's distribution contain the named metadata?"""

    def get_metadata(name):
        """The named metadata resource as a string"""

    def get_metadata_lines(name):
        """Yield named metadata resource as list of non-blank non-comment lines

       Leading and trailing whitespace is stripped from each line, and lines
       with ``#`` as the first non-blank character are omitted."""

    def metadata_isdir(name):
        """Is the named metadata a directory?  (like ``os.path.isdir()``)"""

    def metadata_listdir(name):
        """List of metadata names in the directory (like ``os.listdir()``)"""

    def run_script(script_name, namespace):
        """Execute the named script in the supplied namespace dictionary"""


class IResourceProvider(IMetadataProvider):
    """An object that provides access to package resources"""

    def get_resource_filename(manager, resource_name):
        """Return a true filesystem path for `resource_name`

        `manager` must be an ``IResourceManager``"""

    def get_resource_stream(manager, resource_name):
        """Return a readable file-like object for `resource_name`

        `manager` must be an ``IResourceManager``"""

    def get_resource_string(manager, resource_name):
        """Return a string containing the contents of `resource_name`

        `manager` must be an ``IResourceManager``"""

    def has_resource(resource_name):
        """Does the package contain the named resource?"""

    def resource_isdir(resource_name):
        """Is the named resource a directory?  (like ``os.path.isdir()``)"""

    def resource_listdir(resource_name):
        """List of resource names in the directory (like ``os.listdir()``)"""


class WorkingSet(object):
    """A collection of active distributions on sys.path (or a similar list)"""

    def __init__(self, entries=None):
        """Create working set from list of path entries (default=sys.path)"""
        self.entries = []
        self.entry_keys = {}
        self.by_key = {}
        self.callbacks = []

        if entries is None:
            entries = sys.path

        for entry in entries:
            self.add_entry(entry)

    @classmethod
    def _build_master(cls):
        """
        Prepare the master working set.
        """
        ws = cls()
        try:
            from __main__ import __requires__
        except ImportError:
            # The main program does not list any requirements
            return ws

        # ensure the requirements are met
        try:
            ws.require(__requires__)
        except VersionConflict:
            return cls._build_from_requirements(__requires__)

        return ws

    @classmethod
    def _build_from_requirements(cls, req_spec):
        """
        Build a working set from a requirement spec. Rewrites sys.path.
        """
        # try it without defaults already on sys.path
        # by starting with an empty path
        ws = cls([])
        reqs = parse_requirements(req_spec)
        dists = ws.resolve(reqs, Environment())
        for dist in dists:
            ws.add(dist)

        # add any missing entries from sys.path
        for entry in sys.path:
            if entry not in ws.entries:
                ws.add_entry(entry)

        # then copy back to sys.path
        sys.path[:] = ws.entries
        return ws

    def add_entry(self, entry):
        """Add a path item to ``.entries``, finding any distributions on it

        ``find_distributions(entry, True)`` is used to find distributions
        corresponding to the path entry, and they are added.  `entry` is
        always appended to ``.entries``, even if it is already present.
        (This is because ``sys.path`` can contain the same value more than
        once, and the ``.entries`` of the ``sys.path`` WorkingSet should always
        equal ``sys.path``.)
        """
        self.entry_keys.setdefault(entry, [])
        self.entries.append(entry)
        for dist in find_distributions(entry, True):
            self.add(dist, entry, False)

    def __contains__(self,dist):
        """True if `dist` is the active distribution for its project"""
        return self.by_key.get(dist.key) == dist

    def find(self, req):
        """Find a distribution matching requirement `req`

        If there is an active distribution for the requested project, this
        returns it as long as it meets the version requirement specified by
        `req`.  But, if there is an active distribution for the project and it
        does *not* meet the `req` requirement, ``VersionConflict`` is raised.
        If there is no active distribution for the requested project, ``None``
        is returned.
        """
        dist = self.by_key.get(req.key)
        if dist is not None and dist not in req:
            raise VersionConflict(dist,req)     # XXX add more info
        else:
            return dist

    def iter_entry_points(self, group, name=None):
        """Yield entry point objects from `group` matching `name`

        If `name` is None, yields all entry points in `group` from all
        distributions in the working set, otherwise only ones matching
        both `group` and `name` are yielded (in distribution order).
        """
        for dist in self:
            entries = dist.get_entry_map(group)
            if name is None:
                for ep in entries.values():
                    yield ep
            elif name in entries:
                yield entries[name]

    def run_script(self, requires, script_name):
        """Locate distribution for `requires` and run `script_name` script"""
        ns = sys._getframe(1).f_globals
        name = ns['__name__']
        ns.clear()
        ns['__name__'] = name
        self.require(requires)[0].run_script(script_name, ns)

    def __iter__(self):
        """Yield distributions for non-duplicate projects in the working set

        The yield order is the order in which the items' path entries were
        added to the working set.
        """
        seen = {}
        for item in self.entries:
            if item not in self.entry_keys:
                # workaround a cache issue
                continue

            for key in self.entry_keys[item]:
                if key not in seen:
                    seen[key]=1
                    yield self.by_key[key]

    def add(self, dist, entry=None, insert=True, replace=False):
        """Add `dist` to working set, associated with `entry`

        If `entry` is unspecified, it defaults to the ``.location`` of `dist`.
        On exit from this routine, `entry` is added to the end of the working
        set's ``.entries`` (if it wasn't already present).

        `dist` is only added to the working set if it's for a project that
        doesn't already have a distribution in the set, unless `replace=True`.
        If it's added, any callbacks registered with the ``subscribe()`` method
        will be called.
        """
        if insert:
            dist.insert_on(self.entries, entry)

        if entry is None:
            entry = dist.location
        keys = self.entry_keys.setdefault(entry,[])
        keys2 = self.entry_keys.setdefault(dist.location,[])
        if not replace and dist.key in self.by_key:
            return      # ignore hidden distros

        self.by_key[dist.key] = dist
        if dist.key not in keys:
            keys.append(dist.key)
        if dist.key not in keys2:
            keys2.append(dist.key)
        self._added_new(dist)

    def resolve(self, requirements, env=None, installer=None,
            replace_conflicting=False):
        """List all distributions needed to (recursively) meet `requirements`

        `requirements` must be a sequence of ``Requirement`` objects.  `env`,
        if supplied, should be an ``Environment`` instance.  If
        not supplied, it defaults to all distributions available within any
        entry or distribution in the working set.  `installer`, if supplied,
        will be invoked with each requirement that cannot be met by an
        already-installed distribution; it should return a ``Distribution`` or
        ``None``.

        Unless `replace_conflicting=True`, raises a VersionConflict exception if
        any requirements are found on the path that have the correct name but
        the wrong version.  Otherwise, if an `installer` is supplied it will be
        invoked to obtain the correct version of the requirement and activate
        it.
        """

        requirements = list(requirements)[::-1]  # set up the stack
        processed = {}  # set of processed requirements
        best = {}  # key -> dist
        to_activate = []

        while requirements:
            req = requirements.pop(0)   # process dependencies breadth-first
            if req in processed:
                # Ignore cyclic or redundant dependencies
                continue
            dist = best.get(req.key)
            if dist is None:
                # Find the best distribution and add it to the map
                dist = self.by_key.get(req.key)
                if dist is None or (dist not in req and replace_conflicting):
                    ws = self
                    if env is None:
                        if dist is None:
                            env = Environment(self.entries)
                        else:
                            # Use an empty environment and workingset to avoid
                            # any further conflicts with the conflicting
                            # distribution
                            env = Environment([])
                            ws = WorkingSet([])
                    dist = best[req.key] = env.best_match(req, ws, installer)
                    if dist is None:
                        #msg = ("The '%s' distribution was not found on this "
                        #       "system, and is required by this application.")
                        #raise DistributionNotFound(msg % req)

                        # unfortunately, zc.buildout uses a str(err)
                        # to get the name of the distribution here..
                        raise DistributionNotFound(req)
                to_activate.append(dist)
            if dist not in req:
                # Oops, the "best" so far conflicts with a dependency
                raise VersionConflict(dist,req) # XXX put more info here
            requirements.extend(dist.requires(req.extras)[::-1])
            processed[req] = True

        return to_activate    # return list of distros to activate

    def find_plugins(self, plugin_env, full_env=None, installer=None,
            fallback=True):
        """Find all activatable distributions in `plugin_env`

        Example usage::

            distributions, errors = working_set.find_plugins(
                Environment(plugin_dirlist)
            )
            map(working_set.add, distributions)  # add plugins+libs to sys.path
            print 'Could not load', errors        # display errors

        The `plugin_env` should be an ``Environment`` instance that contains
        only distributions that are in the project's "plugin directory" or
        directories. The `full_env`, if supplied, should be an ``Environment``
        contains all currently-available distributions.  If `full_env` is not
        supplied, one is created automatically from the ``WorkingSet`` this
        method is called on, which will typically mean that every directory on
        ``sys.path`` will be scanned for distributions.

        `installer` is a standard installer callback as used by the
        ``resolve()`` method. The `fallback` flag indicates whether we should
        attempt to resolve older versions of a plugin if the newest version
        cannot be resolved.

        This method returns a 2-tuple: (`distributions`, `error_info`), where
        `distributions` is a list of the distributions found in `plugin_env`
        that were loadable, along with any other distributions that are needed
        to resolve their dependencies.  `error_info` is a dictionary mapping
        unloadable plugin distributions to an exception instance describing the
        error that occurred. Usually this will be a ``DistributionNotFound`` or
        ``VersionConflict`` instance.
        """

        plugin_projects = list(plugin_env)
        plugin_projects.sort()  # scan project names in alphabetic order

        error_info = {}
        distributions = {}

        if full_env is None:
            env = Environment(self.entries)
            env += plugin_env
        else:
            env = full_env + plugin_env

        shadow_set = self.__class__([])
        list(map(shadow_set.add, self))   # put all our entries in shadow_set

        for project_name in plugin_projects:

            for dist in plugin_env[project_name]:

                req = [dist.as_requirement()]

                try:
                    resolvees = shadow_set.resolve(req, env, installer)

                except ResolutionError:
                    v = sys.exc_info()[1]
                    error_info[dist] = v    # save error info
                    if fallback:
                        continue    # try the next older version of project
                    else:
                        break       # give up on this project, keep going

                else:
                    list(map(shadow_set.add, resolvees))
                    distributions.update(dict.fromkeys(resolvees))

                    # success, no need to try any more versions of this project
                    break

        distributions = list(distributions)
        distributions.sort()

        return distributions, error_info

    def require(self, *requirements):
        """Ensure that distributions matching `requirements` are activated

        `requirements` must be a string or a (possibly-nested) sequence
        thereof, specifying the distributions and versions required.  The
        return value is a sequence of the distributions that needed to be
        activated to fulfill the requirements; all relevant distributions are
        included, even if they were already activated in this working set.
        """
        needed = self.resolve(parse_requirements(requirements))

        for dist in needed:
            self.add(dist)

        return needed

    def subscribe(self, callback):
        """Invoke `callback` for all distributions (including existing ones)"""
        if callback in self.callbacks:
            return
        self.callbacks.append(callback)
        for dist in self:
            callback(dist)

    def _added_new(self, dist):
        for callback in self.callbacks:
            callback(dist)

    def __getstate__(self):
        return (
            self.entries[:], self.entry_keys.copy(), self.by_key.copy(),
            self.callbacks[:]
        )

    def __setstate__(self, e_k_b_c):
        entries, keys, by_key, callbacks = e_k_b_c
        self.entries = entries[:]
        self.entry_keys = keys.copy()
        self.by_key = by_key.copy()
        self.callbacks = callbacks[:]


class Environment(object):
    """Searchable snapshot of distributions on a search path"""

    def __init__(self, search_path=None, platform=get_supported_platform(), python=PY_MAJOR):
        """Snapshot distributions available on a search path

        Any distributions found on `search_path` are added to the environment.
        `search_path` should be a sequence of ``sys.path`` items.  If not
        supplied, ``sys.path`` is used.

        `platform` is an optional string specifying the name of the platform
        that platform-specific distributions must be compatible with.  If
        unspecified, it defaults to the current platform.  `python` is an
        optional string naming the desired version of Python (e.g. ``'3.3'``);
        it defaults to the current version.

        You may explicitly set `platform` (and/or `python`) to ``None`` if you
        wish to map *all* distributions, not just those compatible with the
        running platform or Python version.
        """
        self._distmap = {}
        self._cache = {}
        self.platform = platform
        self.python = python
        self.scan(search_path)

    def can_add(self, dist):
        """Is distribution `dist` acceptable for this environment?

        The distribution must match the platform and python version
        requirements specified when this environment was created, or False
        is returned.
        """
        return (self.python is None or dist.py_version is None
            or dist.py_version==self.python) \
            and compatible_platforms(dist.platform,self.platform)

    def remove(self, dist):
        """Remove `dist` from the environment"""
        self._distmap[dist.key].remove(dist)

    def scan(self, search_path=None):
        """Scan `search_path` for distributions usable in this environment

        Any distributions found are added to the environment.
        `search_path` should be a sequence of ``sys.path`` items.  If not
        supplied, ``sys.path`` is used.  Only distributions conforming to
        the platform/python version defined at initialization are added.
        """
        if search_path is None:
            search_path = sys.path

        for item in search_path:
            for dist in find_distributions(item):
                self.add(dist)

    def __getitem__(self,project_name):
        """Return a newest-to-oldest list of distributions for `project_name`
        """
        try:
            return self._cache[project_name]
        except KeyError:
            project_name = project_name.lower()
            if project_name not in self._distmap:
                return []

        if project_name not in self._cache:
            dists = self._cache[project_name] = self._distmap[project_name]
            _sort_dists(dists)

        return self._cache[project_name]

    def add(self,dist):
        """Add `dist` if we ``can_add()`` it and it isn't already added"""
        if self.can_add(dist) and dist.has_version():
            dists = self._distmap.setdefault(dist.key,[])
            if dist not in dists:
                dists.append(dist)
                if dist.key in self._cache:
                    _sort_dists(self._cache[dist.key])

    def best_match(self, req, working_set, installer=None):
        """Find distribution best matching `req` and usable on `working_set`

        This calls the ``find(req)`` method of the `working_set` to see if a
        suitable distribution is already active.  (This may raise
        ``VersionConflict`` if an unsuitable version of the project is already
        active in the specified `working_set`.)  If a suitable distribution
        isn't active, this method returns the newest distribution in the
        environment that meets the ``Requirement`` in `req`.  If no suitable
        distribution is found, and `installer` is supplied, then the result of
        calling the environment's ``obtain(req, installer)`` method will be
        returned.
        """
        dist = working_set.find(req)
        if dist is not None:
            return dist
        for dist in self[req.key]:
            if dist in req:
                return dist
        return self.obtain(req, installer) # try and download/install

    def obtain(self, requirement, installer=None):
        """Obtain a distribution matching `requirement` (e.g. via download)

        Obtain a distro that matches requirement (e.g. via download).  In the
        base ``Environment`` class, this routine just returns
        ``installer(requirement)``, unless `installer` is None, in which case
        None is returned instead.  This method is a hook that allows subclasses
        to attempt other ways of obtaining a distribution before falling back
        to the `installer` argument."""
        if installer is not None:
            return installer(requirement)

    def __iter__(self):
        """Yield the unique project names of the available distributions"""
        for key in self._distmap.keys():
            if self[key]: yield key

    def __iadd__(self, other):
        """In-place addition of a distribution or environment"""
        if isinstance(other,Distribution):
            self.add(other)
        elif isinstance(other,Environment):
            for project in other:
                for dist in other[project]:
                    self.add(dist)
        else:
            raise TypeError("Can't add %r to environment" % (other,))
        return self

    def __add__(self, other):
        """Add an environment or distribution to an environment"""
        new = self.__class__([], platform=None, python=None)
        for env in self, other:
            new += env
        return new


AvailableDistributions = Environment    # XXX backward compatibility


class ExtractionError(RuntimeError):
    """An error occurred extracting a resource

    The following attributes are available from instances of this exception:

    manager
        The resource manager that raised this exception

    cache_path
        The base directory for resource extraction

    original_error
        The exception instance that caused extraction to fail
    """


class ResourceManager:
    """Manage resource extraction and packages"""
    extraction_path = None

    def __init__(self):
        self.cached_files = {}

    def resource_exists(self, package_or_requirement, resource_name):
        """Does the named resource exist?"""
        return get_provider(package_or_requirement).has_resource(resource_name)

    def resource_isdir(self, package_or_requirement, resource_name):
        """Is the named resource an existing directory?"""
        return get_provider(package_or_requirement).resource_isdir(
            resource_name
        )

    def resource_filename(self, package_or_requirement, resource_name):
        """Return a true filesystem path for specified resource"""
        return get_provider(package_or_requirement).get_resource_filename(
            self, resource_name
        )

    def resource_stream(self, package_or_requirement, resource_name):
        """Return a readable file-like object for specified resource"""
        return get_provider(package_or_requirement).get_resource_stream(
            self, resource_name
        )

    def resource_string(self, package_or_requirement, resource_name):
        """Return specified resource as a string"""
        return get_provider(package_or_requirement).get_resource_string(
            self, resource_name
        )

    def resource_listdir(self, package_or_requirement, resource_name):
        """List the contents of the named resource directory"""
        return get_provider(package_or_requirement).resource_listdir(
            resource_name
        )

    def extraction_error(self):
        """Give an error message for problems extracting file(s)"""

        old_exc = sys.exc_info()[1]
        cache_path = self.extraction_path or get_default_cache()

        err = ExtractionError("""Can't extract file(s) to egg cache

The following error occurred while trying to extract file(s) to the Python egg
cache:

  %s

The Python egg cache directory is currently set to:

  %s

Perhaps your account does not have write access to this directory?  You can
change the cache directory by setting the PYTHON_EGG_CACHE environment
variable to point to an accessible directory.
""" % (old_exc, cache_path)
        )
        err.manager = self
        err.cache_path = cache_path
        err.original_error = old_exc
        raise err

    def get_cache_path(self, archive_name, names=()):
        """Return absolute location in cache for `archive_name` and `names`

        The parent directory of the resulting path will be created if it does
        not already exist.  `archive_name` should be the base filename of the
        enclosing egg (which may not be the name of the enclosing zipfile!),
        including its ".egg" extension.  `names`, if provided, should be a
        sequence of path name parts "under" the egg's extraction location.

        This method should only be called by resource providers that need to
        obtain an extraction location, and only for names they intend to
        extract, as it tracks the generated names for possible cleanup later.
        """
        extract_path = self.extraction_path or get_default_cache()
        target_path = os.path.join(extract_path, archive_name+'-tmp', *names)
        try:
            _bypass_ensure_directory(target_path)
        except:
            self.extraction_error()

        self._warn_unsafe_extraction_path(extract_path)

        self.cached_files[target_path] = 1
        return target_path

    @staticmethod
    def _warn_unsafe_extraction_path(path):
        """
        If the default extraction path is overridden and set to an insecure
        location, such as /tmp, it opens up an opportunity for an attacker to
        replace an extracted file with an unauthorized payload. Warn the user
        if a known insecure location is used.

        See Distribute #375 for more details.
        """
        if os.name == 'nt' and not path.startswith(os.environ['windir']):
            # On Windows, permissions are generally restrictive by default
            #  and temp directories are not writable by other users, so
            #  bypass the warning.
            return
        mode = os.stat(path).st_mode
        if mode & stat.S_IWOTH or mode & stat.S_IWGRP:
            msg = ("%s is writable by group/others and vulnerable to attack "
                "when "
                "used with get_resource_filename. Consider a more secure "
                "location (set with .set_extraction_path or the "
                "PYTHON_EGG_CACHE environment variable)." % path)
            warnings.warn(msg, UserWarning)

    def postprocess(self, tempname, filename):
        """Perform any platform-specific postprocessing of `tempname`

        This is where Mac header rewrites should be done; other platforms don't
        have anything special they should do.

        Resource providers should call this method ONLY after successfully
        extracting a compressed resource.  They must NOT call it on resources
        that are already in the filesystem.

        `tempname` is the current (temporary) name of the file, and `filename`
        is the name it will be renamed to by the caller after this routine
        returns.
        """

        if os.name == 'posix':
            # Make the resource executable
            mode = ((os.stat(tempname).st_mode) | 0x16D) & 0xFFF # 0555, 07777
            os.chmod(tempname, mode)

    def set_extraction_path(self, path):
        """Set the base path where resources will be extracted to, if needed.

        If you do not call this routine before any extractions take place, the
        path defaults to the return value of ``get_default_cache()``.  (Which
        is based on the ``PYTHON_EGG_CACHE`` environment variable, with various
        platform-specific fallbacks.  See that routine's documentation for more
        details.)

        Resources are extracted to subdirectories of this path based upon
        information given by the ``IResourceProvider``.  You may set this to a
        temporary directory, but then you must call ``cleanup_resources()`` to
        delete the extracted files when done.  There is no guarantee that
        ``cleanup_resources()`` will be able to remove all extracted files.

        (Note: you may not change the extraction path for a given resource
        manager once resources have been extracted, unless you first call
        ``cleanup_resources()``.)
        """
        if self.cached_files:
            raise ValueError(
                "Can't change extraction path, files already extracted"
            )

        self.extraction_path = path

    def cleanup_resources(self, force=False):
        """
        Delete all extracted resource files and directories, returning a list
        of the file and directory names that could not be successfully removed.
        This function does not have any concurrency protection, so it should
        generally only be called when the extraction path is a temporary
        directory exclusive to a single process.  This method is not
        automatically called; you must call it explicitly or register it as an
        ``atexit`` function if you wish to ensure cleanup of a temporary
        directory used for extractions.
        """
        # XXX

def get_default_cache():
    """Determine the default cache location

    This returns the ``PYTHON_EGG_CACHE`` environment variable, if set.
    Otherwise, on Windows, it returns a "Python-Eggs" subdirectory of the
    "Application Data" directory.  On all other systems, it's "~/.python-eggs".
    """
    try:
        return os.environ['PYTHON_EGG_CACHE']
    except KeyError:
        pass

    if os.name!='nt':
        return os.path.expanduser('~/.python-eggs')

    app_data = 'Application Data'   # XXX this may be locale-specific!
    app_homes = [
        (('APPDATA',), None),       # best option, should be locale-safe
        (('USERPROFILE',), app_data),
        (('HOMEDRIVE','HOMEPATH'), app_data),
        (('HOMEPATH',), app_data),
        (('HOME',), None),
        (('WINDIR',), app_data),    # 95/98/ME
    ]

    for keys, subdir in app_homes:
        dirname = ''
        for key in keys:
            if key in os.environ:
                dirname = os.path.join(dirname, os.environ[key])
            else:
                break
        else:
            if subdir:
                dirname = os.path.join(dirname,subdir)
            return os.path.join(dirname, 'Python-Eggs')
    else:
        raise RuntimeError(
            "Please set the PYTHON_EGG_CACHE enviroment variable"
        )

def safe_name(name):
    """Convert an arbitrary string to a standard distribution name

    Any runs of non-alphanumeric/. characters are replaced with a single '-'.
    """
    return re.sub('[^A-Za-z0-9.]+', '-', name)


def safe_version(version):
    """Convert an arbitrary string to a standard version string

    Spaces become dots, and all other non-alphanumeric characters become
    dashes, with runs of multiple dashes condensed to a single dash.
    """
    version = version.replace(' ','.')
    return re.sub('[^A-Za-z0-9.]+', '-', version)


def safe_extra(extra):
    """Convert an arbitrary string to a standard 'extra' name

    Any runs of non-alphanumeric characters are replaced with a single '_',
    and the result is always lowercased.
    """
    return re.sub('[^A-Za-z0-9.]+', '_', extra).lower()


def to_filename(name):
    """Convert a project or version name to its filename-escaped form

    Any '-' characters are currently replaced with '_'.
    """
    return name.replace('-','_')


class MarkerEvaluation(object):
    values = {
        'os_name': lambda: os.name,
        'sys_platform': lambda: sys.platform,
        'python_full_version': lambda: sys.version.split()[0],
        'python_version': lambda:'%s.%s' % (sys.version_info[0], sys.version_info[1]),
        'platform_version': platform.version,
        'platform_machine': platform.machine,
        'python_implementation': platform.python_implementation,
    }

    @classmethod
    def is_invalid_marker(cls, text):
        """
        Validate text as a PEP 426 environment marker; return an exception
        if invalid or False otherwise.
        """
        try:
            cls.evaluate_marker(text)
        except SyntaxError:
            return cls.normalize_exception(sys.exc_info()[1])
        return False

    @staticmethod
    def normalize_exception(exc):
        """
        Given a SyntaxError from a marker evaluation, normalize the error message:
         - Remove indications of filename and line number.
         - Replace platform-specific error messages with standard error messages.
        """
        subs = {
            'unexpected EOF while parsing': 'invalid syntax',
            'parenthesis is never closed': 'invalid syntax',
        }
        exc.filename = None
        exc.lineno = None
        exc.msg = subs.get(exc.msg, exc.msg)
        return exc

    @classmethod
    def and_test(cls, nodelist):
        # MUST NOT short-circuit evaluation, or invalid syntax can be skipped!
        return functools.reduce(operator.and_, [cls.interpret(nodelist[i]) for i in range(1,len(nodelist),2)])

    @classmethod
    def test(cls, nodelist):
        # MUST NOT short-circuit evaluation, or invalid syntax can be skipped!
        return functools.reduce(operator.or_, [cls.interpret(nodelist[i]) for i in range(1,len(nodelist),2)])

    @classmethod
    def atom(cls, nodelist):
        t = nodelist[1][0]
        if t == token.LPAR:
            if nodelist[2][0] == token.RPAR:
                raise SyntaxError("Empty parentheses")
            return cls.interpret(nodelist[2])
        raise SyntaxError("Language feature not supported in environment markers")

    @classmethod
    def comparison(cls, nodelist):
        if len(nodelist)>4:
            raise SyntaxError("Chained comparison not allowed in environment markers")
        comp = nodelist[2][1]
        cop = comp[1]
        if comp[0] == token.NAME:
            if len(nodelist[2]) == 3:
                if cop == 'not':
                    cop = 'not in'
                else:
                    cop = 'is not'
        try:
            cop = cls.get_op(cop)
        except KeyError:
            raise SyntaxError(repr(cop)+" operator not allowed in environment markers")
        return cop(cls.evaluate(nodelist[1]), cls.evaluate(nodelist[3]))

    @classmethod
    def get_op(cls, op):
        ops = {
            symbol.test: cls.test,
            symbol.and_test: cls.and_test,
            symbol.atom: cls.atom,
            symbol.comparison: cls.comparison,
            'not in': lambda x, y: x not in y,
            'in': lambda x, y: x in y,
            '==': operator.eq,
            '!=': operator.ne,
        }
        if hasattr(symbol, 'or_test'):
            ops[symbol.or_test] = cls.test
        return ops[op]

    @classmethod
    def evaluate_marker(cls, text, extra=None):
        """
        Evaluate a PEP 426 environment marker on CPython 2.4+.
        Return a boolean indicating the marker result in this environment.
        Raise SyntaxError if marker is invalid.

        This implementation uses the 'parser' module, which is not implemented on
        Jython and has been superseded by the 'ast' module in Python 2.6 and
        later.
        """
        return cls.interpret(parser.expr(text).totuple(1)[1])

    @classmethod
    def _markerlib_evaluate(cls, text):
        """
        Evaluate a PEP 426 environment marker using markerlib.
        Return a boolean indicating the marker result in this environment.
        Raise SyntaxError if marker is invalid.
        """
        from pip._vendor import _markerlib
        # markerlib implements Metadata 1.2 (PEP 345) environment markers.
        # Translate the variables to Metadata 2.0 (PEP 426).
        env = _markerlib.default_environment()
        for key in env.keys():
            new_key = key.replace('.', '_')
            env[new_key] = env.pop(key)
        try:
            result = _markerlib.interpret(text, env)
        except NameError:
            e = sys.exc_info()[1]
            raise SyntaxError(e.args[0])
        return result

    if 'parser' not in globals():
        # Fall back to less-complete _markerlib implementation if 'parser' module
        # is not available.
        evaluate_marker = _markerlib_evaluate

    @classmethod
    def interpret(cls, nodelist):
        while len(nodelist)==2: nodelist = nodelist[1]
        try:
            op = cls.get_op(nodelist[0])
        except KeyError:
            raise SyntaxError("Comparison or logical expression expected")
        return op(nodelist)

    @classmethod
    def evaluate(cls, nodelist):
        while len(nodelist)==2: nodelist = nodelist[1]
        kind = nodelist[0]
        name = nodelist[1]
        if kind==token.NAME:
            try:
                op = cls.values[name]
            except KeyError:
                raise SyntaxError("Unknown name %r" % name)
            return op()
        if kind==token.STRING:
            s = nodelist[1]
            if s[:1] not in "'\"" or s.startswith('"""') or s.startswith("'''") \
                    or '\\' in s:
                raise SyntaxError(
                    "Only plain strings allowed in environment markers")
            return s[1:-1]
        raise SyntaxError("Language feature not supported in environment markers")

invalid_marker = MarkerEvaluation.is_invalid_marker
evaluate_marker = MarkerEvaluation.evaluate_marker

class NullProvider:
    """Try to implement resources and metadata for arbitrary PEP 302 loaders"""

    egg_name = None
    egg_info = None
    loader = None

    def __init__(self, module):
        self.loader = getattr(module, '__loader__', None)
        self.module_path = os.path.dirname(getattr(module, '__file__', ''))

    def get_resource_filename(self, manager, resource_name):
        return self._fn(self.module_path, resource_name)

    def get_resource_stream(self, manager, resource_name):
        return BytesIO(self.get_resource_string(manager, resource_name))

    def get_resource_string(self, manager, resource_name):
        return self._get(self._fn(self.module_path, resource_name))

    def has_resource(self, resource_name):
        return self._has(self._fn(self.module_path, resource_name))

    def has_metadata(self, name):
        return self.egg_info and self._has(self._fn(self.egg_info,name))

    if sys.version_info <= (3,):
        def get_metadata(self, name):
            if not self.egg_info:
                return ""
            return self._get(self._fn(self.egg_info,name))
    else:
        def get_metadata(self, name):
            if not self.egg_info:
                return ""
            return self._get(self._fn(self.egg_info,name)).decode("utf-8")

    def get_metadata_lines(self, name):
        return yield_lines(self.get_metadata(name))

    def resource_isdir(self,resource_name):
        return self._isdir(self._fn(self.module_path, resource_name))

    def metadata_isdir(self,name):
        return self.egg_info and self._isdir(self._fn(self.egg_info,name))

    def resource_listdir(self,resource_name):
        return self._listdir(self._fn(self.module_path,resource_name))

    def metadata_listdir(self,name):
        if self.egg_info:
            return self._listdir(self._fn(self.egg_info,name))
        return []

    def run_script(self,script_name,namespace):
        script = 'scripts/'+script_name
        if not self.has_metadata(script):
            raise ResolutionError("No script named %r" % script_name)
        script_text = self.get_metadata(script).replace('\r\n','\n')
        script_text = script_text.replace('\r','\n')
        script_filename = self._fn(self.egg_info,script)
        namespace['__file__'] = script_filename
        if os.path.exists(script_filename):
            execfile(script_filename, namespace, namespace)
        else:
            from linecache import cache
            cache[script_filename] = (
                len(script_text), 0, script_text.split('\n'), script_filename
            )
            script_code = compile(script_text,script_filename,'exec')
            exec(script_code, namespace, namespace)

    def _has(self, path):
        raise NotImplementedError(
            "Can't perform this operation for unregistered loader type"
        )

    def _isdir(self, path):
        raise NotImplementedError(
            "Can't perform this operation for unregistered loader type"
        )

    def _listdir(self, path):
        raise NotImplementedError(
            "Can't perform this operation for unregistered loader type"
        )

    def _fn(self, base, resource_name):
        if resource_name:
            return os.path.join(base, *resource_name.split('/'))
        return base

    def _get(self, path):
        if hasattr(self.loader, 'get_data'):
            return self.loader.get_data(path)
        raise NotImplementedError(
            "Can't perform this operation for loaders without 'get_data()'"
        )

register_loader_type(object, NullProvider)


class EggProvider(NullProvider):
    """Provider based on a virtual filesystem"""

    def __init__(self,module):
        NullProvider.__init__(self,module)
        self._setup_prefix()

    def _setup_prefix(self):
        # we assume here that our metadata may be nested inside a "basket"
        # of multiple eggs; that's why we use module_path instead of .archive
        path = self.module_path
        old = None
        while path!=old:
            if path.lower().endswith('.egg'):
                self.egg_name = os.path.basename(path)
                self.egg_info = os.path.join(path, 'EGG-INFO')
                self.egg_root = path
                break
            old = path
            path, base = os.path.split(path)

class DefaultProvider(EggProvider):
    """Provides access to package resources in the filesystem"""

    def _has(self, path):
        return os.path.exists(path)

    def _isdir(self,path):
        return os.path.isdir(path)

    def _listdir(self,path):
        return os.listdir(path)

    def get_resource_stream(self, manager, resource_name):
        return open(self._fn(self.module_path, resource_name), 'rb')

    def _get(self, path):
        stream = open(path, 'rb')
        try:
            return stream.read()
        finally:
            stream.close()

register_loader_type(type(None), DefaultProvider)

if importlib_bootstrap is not None:
    register_loader_type(importlib_bootstrap.SourceFileLoader, DefaultProvider)


class EmptyProvider(NullProvider):
    """Provider that returns nothing for all requests"""

    _isdir = _has = lambda self,path: False
    _get = lambda self,path: ''
    _listdir = lambda self,path: []
    module_path = None

    def __init__(self):
        pass

empty_provider = EmptyProvider()


def build_zipmanifest(path):
    """
    This builds a similar dictionary to the zipimport directory
    caches.  However instead of tuples, ZipInfo objects are stored.

    The translation of the tuple is as follows:
      * [0] - zipinfo.filename on stock pythons this needs "/" --> os.sep
              on pypy it is the same (one reason why distribute did work
              in some cases on pypy and win32).
      * [1] - zipinfo.compress_type
      * [2] - zipinfo.compress_size
      * [3] - zipinfo.file_size
      * [4] - len(utf-8 encoding of filename) if zipinfo & 0x800
              len(ascii encoding of filename) otherwise
      * [5] - (zipinfo.date_time[0] - 1980) << 9 |
               zipinfo.date_time[1] << 5 | zipinfo.date_time[2]
      * [6] - (zipinfo.date_time[3] - 1980) << 11 |
               zipinfo.date_time[4] << 5 | (zipinfo.date_time[5] // 2)
      * [7] - zipinfo.CRC
    """
    zipinfo = dict()
    zfile = zipfile.ZipFile(path)
    #Got ZipFile has not __exit__ on python 3.1
    try:
        for zitem in zfile.namelist():
            zpath = zitem.replace('/', os.sep)
            zipinfo[zpath] = zfile.getinfo(zitem)
            assert zipinfo[zpath] is not None
    finally:
        zfile.close()
    return zipinfo


class ZipProvider(EggProvider):
    """Resource support for zips and eggs"""

    eagers = None

    def __init__(self, module):
        EggProvider.__init__(self,module)
        self.zipinfo = build_zipmanifest(self.loader.archive)
        self.zip_pre = self.loader.archive+os.sep

    def _zipinfo_name(self, fspath):
        # Convert a virtual filename (full path to file) into a zipfile subpath
        # usable with the zipimport directory cache for our target archive
        if fspath.startswith(self.zip_pre):
            return fspath[len(self.zip_pre):]
        raise AssertionError(
            "%s is not a subpath of %s" % (fspath,self.zip_pre)
        )

    def _parts(self,zip_path):
        # Convert a zipfile subpath into an egg-relative path part list
        fspath = self.zip_pre+zip_path  # pseudo-fs path
        if fspath.startswith(self.egg_root+os.sep):
            return fspath[len(self.egg_root)+1:].split(os.sep)
        raise AssertionError(
            "%s is not a subpath of %s" % (fspath,self.egg_root)
        )

    def get_resource_filename(self, manager, resource_name):
        if not self.egg_name:
            raise NotImplementedError(
                "resource_filename() only supported for .egg, not .zip"
            )
        # no need to lock for extraction, since we use temp names
        zip_path = self._resource_to_zip(resource_name)
        eagers = self._get_eager_resources()
        if '/'.join(self._parts(zip_path)) in eagers:
            for name in eagers:
                self._extract_resource(manager, self._eager_to_zip(name))
        return self._extract_resource(manager, zip_path)

    @staticmethod
    def _get_date_and_size(zip_stat):
        size = zip_stat.file_size
        date_time = zip_stat.date_time + (0, 0, -1)  # ymdhms+wday, yday, dst
        #1980 offset already done
        timestamp = time.mktime(date_time)
        return timestamp, size

    def _extract_resource(self, manager, zip_path):

        if zip_path in self._index():
            for name in self._index()[zip_path]:
                last = self._extract_resource(
                    manager, os.path.join(zip_path, name)
                )
            return os.path.dirname(last)  # return the extracted directory name

        timestamp, size = self._get_date_and_size(self.zipinfo[zip_path])

        if not WRITE_SUPPORT:
            raise IOError('"os.rename" and "os.unlink" are not supported '
                          'on this platform')
        try:

            real_path = manager.get_cache_path(
                self.egg_name, self._parts(zip_path)
            )

            if self._is_current(real_path, zip_path):
                return real_path

            outf, tmpnam = _mkstemp(".$extract", dir=os.path.dirname(real_path))
            os.write(outf, self.loader.get_data(zip_path))
            os.close(outf)
            utime(tmpnam, (timestamp,timestamp))
            manager.postprocess(tmpnam, real_path)

            try:
                rename(tmpnam, real_path)

            except os.error:
                if os.path.isfile(real_path):
                    if self._is_current(real_path, zip_path):
                        # the file became current since it was checked above,
                        #  so proceed.
                        return real_path
                    elif os.name=='nt':     # Windows, del old file and retry
                        unlink(real_path)
                        rename(tmpnam, real_path)
                        return real_path
                raise

        except os.error:
            manager.extraction_error()  # report a user-friendly error

        return real_path

    def _is_current(self, file_path, zip_path):
        """
        Return True if the file_path is current for this zip_path
        """
        timestamp, size = self._get_date_and_size(self.zipinfo[zip_path])
        if not os.path.isfile(file_path):
            return False
        stat = os.stat(file_path)
        if stat.st_size!=size or stat.st_mtime!=timestamp:
            return False
        # check that the contents match
        zip_contents = self.loader.get_data(zip_path)
        f = open(file_path, 'rb')
        file_contents = f.read()
        f.close()
        return zip_contents == file_contents

    def _get_eager_resources(self):
        if self.eagers is None:
            eagers = []
            for name in ('native_libs.txt', 'eager_resources.txt'):
                if self.has_metadata(name):
                    eagers.extend(self.get_metadata_lines(name))
            self.eagers = eagers
        return self.eagers

    def _index(self):
        try:
            return self._dirindex
        except AttributeError:
            ind = {}
            for path in self.zipinfo:
                parts = path.split(os.sep)
                while parts:
                    parent = os.sep.join(parts[:-1])
                    if parent in ind:
                        ind[parent].append(parts[-1])
                        break
                    else:
                        ind[parent] = [parts.pop()]
            self._dirindex = ind
            return ind

    def _has(self, fspath):
        zip_path = self._zipinfo_name(fspath)
        return zip_path in self.zipinfo or zip_path in self._index()

    def _isdir(self,fspath):
        return self._zipinfo_name(fspath) in self._index()

    def _listdir(self,fspath):
        return list(self._index().get(self._zipinfo_name(fspath), ()))

    def _eager_to_zip(self,resource_name):
        return self._zipinfo_name(self._fn(self.egg_root,resource_name))

    def _resource_to_zip(self,resource_name):
        return self._zipinfo_name(self._fn(self.module_path,resource_name))

register_loader_type(zipimport.zipimporter, ZipProvider)


class FileMetadata(EmptyProvider):
    """Metadata handler for standalone PKG-INFO files

    Usage::

        metadata = FileMetadata("/path/to/PKG-INFO")

    This provider rejects all data and metadata requests except for PKG-INFO,
    which is treated as existing, and will be the contents of the file at
    the provided location.
    """

    def __init__(self,path):
        self.path = path

    def has_metadata(self,name):
        return name=='PKG-INFO'

    def get_metadata(self,name):
        if name=='PKG-INFO':
            f = open(self.path,'rU')
            metadata = f.read()
            f.close()
            return metadata
        raise KeyError("No metadata except PKG-INFO is available")

    def get_metadata_lines(self,name):
        return yield_lines(self.get_metadata(name))


class PathMetadata(DefaultProvider):
    """Metadata provider for egg directories

    Usage::

        # Development eggs:

        egg_info = "/path/to/PackageName.egg-info"
        base_dir = os.path.dirname(egg_info)
        metadata = PathMetadata(base_dir, egg_info)
        dist_name = os.path.splitext(os.path.basename(egg_info))[0]
        dist = Distribution(basedir,project_name=dist_name,metadata=metadata)

        # Unpacked egg directories:

        egg_path = "/path/to/PackageName-ver-pyver-etc.egg"
        metadata = PathMetadata(egg_path, os.path.join(egg_path,'EGG-INFO'))
        dist = Distribution.from_filename(egg_path, metadata=metadata)
    """

    def __init__(self, path, egg_info):
        self.module_path = path
        self.egg_info = egg_info


class EggMetadata(ZipProvider):
    """Metadata provider for .egg files"""

    def __init__(self, importer):
        """Create a metadata provider from a zipimporter"""

        self.zipinfo = build_zipmanifest(importer.archive)
        self.zip_pre = importer.archive+os.sep
        self.loader = importer
        if importer.prefix:
            self.module_path = os.path.join(importer.archive, importer.prefix)
        else:
            self.module_path = importer.archive
        self._setup_prefix()

_declare_state('dict', _distribution_finders = {})

def register_finder(importer_type, distribution_finder):
    """Register `distribution_finder` to find distributions in sys.path items

    `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item
    handler), and `distribution_finder` is a callable that, passed a path
    item and the importer instance, yields ``Distribution`` instances found on
    that path item.  See ``pkg_resources.find_on_path`` for an example."""
    _distribution_finders[importer_type] = distribution_finder


def find_distributions(path_item, only=False):
    """Yield distributions accessible via `path_item`"""
    importer = get_importer(path_item)
    finder = _find_adapter(_distribution_finders, importer)
    return finder(importer, path_item, only)

def find_eggs_in_zip(importer, path_item, only=False):
    """
    Find eggs in zip files; possibly multiple nested eggs.
    """
    if importer.archive.endswith('.whl'):
        # wheels are not supported with this finder
        # they don't have PKG-INFO metadata, and won't ever contain eggs
        return
    metadata = EggMetadata(importer)
    if metadata.has_metadata('PKG-INFO'):
        yield Distribution.from_filename(path_item, metadata=metadata)
    if only:
        return  # don't yield nested distros
    for subitem in metadata.resource_listdir('/'):
        if subitem.endswith('.egg'):
            subpath = os.path.join(path_item, subitem)
            for dist in find_eggs_in_zip(zipimport.zipimporter(subpath), subpath):
                yield dist

register_finder(zipimport.zipimporter, find_eggs_in_zip)

def find_nothing(importer, path_item, only=False):
    return ()
register_finder(object,find_nothing)

def find_on_path(importer, path_item, only=False):
    """Yield distributions accessible on a sys.path directory"""
    path_item = _normalize_cached(path_item)

    if os.path.isdir(path_item) and os.access(path_item, os.R_OK):
        if path_item.lower().endswith('.egg'):
            # unpacked egg
            yield Distribution.from_filename(
                path_item, metadata=PathMetadata(
                    path_item, os.path.join(path_item,'EGG-INFO')
                )
            )
        else:
            # scan for .egg and .egg-info in directory
            for entry in os.listdir(path_item):
                lower = entry.lower()
                if lower.endswith('.egg-info') or lower.endswith('.dist-info'):
                    fullpath = os.path.join(path_item, entry)
                    if os.path.isdir(fullpath):
                        # egg-info directory, allow getting metadata
                        metadata = PathMetadata(path_item, fullpath)
                    else:
                        metadata = FileMetadata(fullpath)
                    yield Distribution.from_location(
                        path_item,entry,metadata,precedence=DEVELOP_DIST
                    )
                elif not only and lower.endswith('.egg'):
                    for dist in find_distributions(os.path.join(path_item, entry)):
                        yield dist
                elif not only and lower.endswith('.egg-link'):
                    entry_file = open(os.path.join(path_item, entry))
                    try:
                        entry_lines = entry_file.readlines()
                    finally:
                        entry_file.close()
                    for line in entry_lines:
                        if not line.strip(): continue
                        for item in find_distributions(os.path.join(path_item,line.rstrip())):
                            yield item
                        break
register_finder(pkgutil.ImpImporter,find_on_path)

if importlib_bootstrap is not None:
    register_finder(importlib_bootstrap.FileFinder, find_on_path)

_declare_state('dict', _namespace_handlers={})
_declare_state('dict', _namespace_packages={})


def register_namespace_handler(importer_type, namespace_handler):
    """Register `namespace_handler` to declare namespace packages

    `importer_type` is the type or class of a PEP 302 "Importer" (sys.path item
    handler), and `namespace_handler` is a callable like this::

        def namespace_handler(importer,path_entry,moduleName,module):
            # return a path_entry to use for child packages

    Namespace handlers are only called if the importer object has already
    agreed that it can handle the relevant path item, and they should only
    return a subpath if the module __path__ does not already contain an
    equivalent subpath.  For an example namespace handler, see
    ``pkg_resources.file_ns_handler``.
    """
    _namespace_handlers[importer_type] = namespace_handler

def _handle_ns(packageName, path_item):
    """Ensure that named package includes a subpath of path_item (if needed)"""

    importer = get_importer(path_item)
    if importer is None:
        return None
    loader = importer.find_module(packageName)
    if loader is None:
        return None
    module = sys.modules.get(packageName)
    if module is None:
        module = sys.modules[packageName] = imp.new_module(packageName)
        module.__path__ = []
        _set_parent_ns(packageName)
    elif not hasattr(module,'__path__'):
        raise TypeError("Not a package:", packageName)
    handler = _find_adapter(_namespace_handlers, importer)
    subpath = handler(importer, path_item, packageName, module)
    if subpath is not None:
        path = module.__path__
        path.append(subpath)
        loader.load_module(packageName)
        for path_item in path:
            if path_item not in module.__path__:
                module.__path__.append(path_item)
    return subpath

def declare_namespace(packageName):
    """Declare that package 'packageName' is a namespace package"""

    imp.acquire_lock()
    try:
        if packageName in _namespace_packages:
            return

        path, parent = sys.path, None
        if '.' in packageName:
            parent = '.'.join(packageName.split('.')[:-1])
            declare_namespace(parent)
            if parent not in _namespace_packages:
                __import__(parent)
            try:
                path = sys.modules[parent].__path__
            except AttributeError:
                raise TypeError("Not a package:", parent)

        # Track what packages are namespaces, so when new path items are added,
        # they can be updated
        _namespace_packages.setdefault(parent,[]).append(packageName)
        _namespace_packages.setdefault(packageName,[])

        for path_item in path:
            # Ensure all the parent's path items are reflected in the child,
            # if they apply
            _handle_ns(packageName, path_item)

    finally:
        imp.release_lock()

def fixup_namespace_packages(path_item, parent=None):
    """Ensure that previously-declared namespace packages include path_item"""
    imp.acquire_lock()
    try:
        for package in _namespace_packages.get(parent,()):
            subpath = _handle_ns(package, path_item)
            if subpath: fixup_namespace_packages(subpath,package)
    finally:
        imp.release_lock()

def file_ns_handler(importer, path_item, packageName, module):
    """Compute an ns-package subpath for a filesystem or zipfile importer"""

    subpath = os.path.join(path_item, packageName.split('.')[-1])
    normalized = _normalize_cached(subpath)
    for item in module.__path__:
        if _normalize_cached(item)==normalized:
            break
    else:
        # Only return the path if it's not already there
        return subpath

register_namespace_handler(pkgutil.ImpImporter,file_ns_handler)
register_namespace_handler(zipimport.zipimporter,file_ns_handler)

if importlib_bootstrap is not None:
    register_namespace_handler(importlib_bootstrap.FileFinder, file_ns_handler)


def null_ns_handler(importer, path_item, packageName, module):
    return None

register_namespace_handler(object,null_ns_handler)


def normalize_path(filename):
    """Normalize a file/dir name for comparison purposes"""
    return os.path.normcase(os.path.realpath(filename))

def _normalize_cached(filename,_cache={}):
    try:
        return _cache[filename]
    except KeyError:
        _cache[filename] = result = normalize_path(filename)
        return result

def _set_parent_ns(packageName):
    parts = packageName.split('.')
    name = parts.pop()
    if parts:
        parent = '.'.join(parts)
        setattr(sys.modules[parent], name, sys.modules[packageName])


def yield_lines(strs):
    """Yield non-empty/non-comment lines of a ``basestring`` or sequence"""
    if isinstance(strs,basestring):
        for s in strs.splitlines():
            s = s.strip()
            if s and not s.startswith('#'):     # skip blank lines/comments
                yield s
    else:
        for ss in strs:
            for s in yield_lines(ss):
                yield s

LINE_END = re.compile(r"\s*(#.*)?$").match         # whitespace and comment
CONTINUE = re.compile(r"\s*\\\s*(#.*)?$").match    # line continuation
DISTRO = re.compile(r"\s*((\w|[-.])+)").match    # Distribution or extra
VERSION = re.compile(r"\s*(<=?|>=?|==|!=)\s*((\w|[-.])+)").match  # ver. info
COMMA = re.compile(r"\s*,").match               # comma between items
OBRACKET = re.compile(r"\s*\[").match
CBRACKET = re.compile(r"\s*\]").match
MODULE = re.compile(r"\w+(\.\w+)*$").match
EGG_NAME = re.compile(
    r"(?P<name>[^-]+)"
    r"( -(?P<ver>[^-]+) (-py(?P<pyver>[^-]+) (-(?P<plat>.+))? )? )?",
    re.VERBOSE | re.IGNORECASE
).match

component_re = re.compile(r'(\d+ | [a-z]+ | \.| -)', re.VERBOSE)
replace = {'pre':'c', 'preview':'c','-':'final-','rc':'c','dev':'@'}.get

def _parse_version_parts(s):
    for part in component_re.split(s):
        part = replace(part,part)
        if not part or part=='.':
            continue
        if part[:1] in '0123456789':
            yield part.zfill(8)    # pad for numeric comparison
        else:
            yield '*'+part

    yield '*final'  # ensure that alpha/beta/candidate are before final

def parse_version(s):
    """Convert a version string to a chronologically-sortable key

    This is a rough cross between distutils' StrictVersion and LooseVersion;
    if you give it versions that would work with StrictVersion, then it behaves
    the same; otherwise it acts like a slightly-smarter LooseVersion. It is
    *possible* to create pathological version coding schemes that will fool
    this parser, but they should be very rare in practice.

    The returned value will be a tuple of strings.  Numeric portions of the
    version are padded to 8 digits so they will compare numerically, but
    without relying on how numbers compare relative to strings.  Dots are
    dropped, but dashes are retained.  Trailing zeros between alpha segments
    or dashes are suppressed, so that e.g. "2.4.0" is considered the same as
    "2.4". Alphanumeric parts are lower-cased.

    The algorithm assumes that strings like "-" and any alpha string that
    alphabetically follows "final"  represents a "patch level".  So, "2.4-1"
    is assumed to be a branch or patch of "2.4", and therefore "2.4.1" is
    considered newer than "2.4-1", which in turn is newer than "2.4".

    Strings like "a", "b", "c", "alpha", "beta", "candidate" and so on (that
    come before "final" alphabetically) are assumed to be pre-release versions,
    so that the version "2.4" is considered newer than "2.4a1".

    Finally, to handle miscellaneous cases, the strings "pre", "preview", and
    "rc" are treated as if they were "c", i.e. as though they were release
    candidates, and therefore are not as new as a version string that does not
    contain them, and "dev" is replaced with an '@' so that it sorts lower than
    than any other pre-release tag.
    """
    parts = []
    for part in _parse_version_parts(s.lower()):
        if part.startswith('*'):
            if part<'*final':   # remove '-' before a prerelease tag
                while parts and parts[-1]=='*final-': parts.pop()
            # remove trailing zeros from each series of numeric parts
            while parts and parts[-1]=='00000000':
                parts.pop()
        parts.append(part)
    return tuple(parts)
class EntryPoint(object):
    """Object representing an advertised importable object"""

    def __init__(self, name, module_name, attrs=(), extras=(), dist=None):
        if not MODULE(module_name):
            raise ValueError("Invalid module name", module_name)
        self.name = name
        self.module_name = module_name
        self.attrs = tuple(attrs)
        self.extras = Requirement.parse(("x[%s]" % ','.join(extras))).extras
        self.dist = dist

    def __str__(self):
        s = "%s = %s" % (self.name, self.module_name)
        if self.attrs:
            s += ':' + '.'.join(self.attrs)
        if self.extras:
            s += ' [%s]' % ','.join(self.extras)
        return s

    def __repr__(self):
        return "EntryPoint.parse(%r)" % str(self)

    def load(self, require=True, env=None, installer=None):
        if require: self.require(env, installer)
        entry = __import__(self.module_name, globals(),globals(), ['__name__'])
        for attr in self.attrs:
            try:
                entry = getattr(entry,attr)
            except AttributeError:
                raise ImportError("%r has no %r attribute" % (entry,attr))
        return entry

    def require(self, env=None, installer=None):
        if self.extras and not self.dist:
            raise UnknownExtra("Can't require() without a distribution", self)
        list(map(working_set.add,
            working_set.resolve(self.dist.requires(self.extras),env,installer)))

    @classmethod
    def parse(cls, src, dist=None):
        """Parse a single entry point from string `src`

        Entry point syntax follows the form::

            name = some.module:some.attr [extra1,extra2]

        The entry name and module name are required, but the ``:attrs`` and
        ``[extras]`` parts are optional
        """
        try:
            attrs = extras = ()
            name,value = src.split('=',1)
            if '[' in value:
                value,extras = value.split('[',1)
                req = Requirement.parse("x["+extras)
                if req.specs: raise ValueError
                extras = req.extras
            if ':' in value:
                value,attrs = value.split(':',1)
                if not MODULE(attrs.rstrip()):
                    raise ValueError
                attrs = attrs.rstrip().split('.')
        except ValueError:
            raise ValueError(
                "EntryPoint must be in 'name=module:attrs [extras]' format",
                src
            )
        else:
            return cls(name.strip(), value.strip(), attrs, extras, dist)

    @classmethod
    def parse_group(cls, group, lines, dist=None):
        """Parse an entry point group"""
        if not MODULE(group):
            raise ValueError("Invalid group name", group)
        this = {}
        for line in yield_lines(lines):
            ep = cls.parse(line, dist)
            if ep.name in this:
                raise ValueError("Duplicate entry point", group, ep.name)
            this[ep.name]=ep
        return this

    @classmethod
    def parse_map(cls, data, dist=None):
        """Parse a map of entry point groups"""
        if isinstance(data,dict):
            data = data.items()
        else:
            data = split_sections(data)
        maps = {}
        for group, lines in data:
            if group is None:
                if not lines:
                    continue
                raise ValueError("Entry points must be listed in groups")
            group = group.strip()
            if group in maps:
                raise ValueError("Duplicate group name", group)
            maps[group] = cls.parse_group(group, lines, dist)
        return maps


def _remove_md5_fragment(location):
    if not location:
        return ''
    parsed = urlparse(location)
    if parsed[-1].startswith('md5='):
        return urlunparse(parsed[:-1] + ('',))
    return location


class Distribution(object):
    """Wrap an actual or potential sys.path entry w/metadata"""
    PKG_INFO = 'PKG-INFO'

    def __init__(self, location=None, metadata=None, project_name=None,
            version=None, py_version=PY_MAJOR, platform=None,
            precedence=EGG_DIST):
        self.project_name = safe_name(project_name or 'Unknown')
        if version is not None:
            self._version = safe_version(version)
        self.py_version = py_version
        self.platform = platform
        self.location = location
        self.precedence = precedence
        self._provider = metadata or empty_provider

    @classmethod
    def from_location(cls,location,basename,metadata=None,**kw):
        project_name, version, py_version, platform = [None]*4
        basename, ext = os.path.splitext(basename)
        if ext.lower() in _distributionImpl:
            # .dist-info gets much metadata differently
            match = EGG_NAME(basename)
            if match:
                project_name, version, py_version, platform = match.group(
                    'name','ver','pyver','plat'
                )
            cls = _distributionImpl[ext.lower()]
        return cls(
            location, metadata, project_name=project_name, version=version,
            py_version=py_version, platform=platform, **kw
        )

    hashcmp = property(
        lambda self: (
            getattr(self,'parsed_version',()),
            self.precedence,
            self.key,
            _remove_md5_fragment(self.location),
            self.py_version,
            self.platform
        )
    )
    def __hash__(self): return hash(self.hashcmp)
    def __lt__(self, other):
        return self.hashcmp < other.hashcmp
    def __le__(self, other):
        return self.hashcmp <= other.hashcmp
    def __gt__(self, other):
        return self.hashcmp > other.hashcmp
    def __ge__(self, other):
        return self.hashcmp >= other.hashcmp
    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            # It's not a Distribution, so they are not equal
            return False
        return self.hashcmp == other.hashcmp
    def __ne__(self, other):
        return not self == other

    # These properties have to be lazy so that we don't have to load any
    # metadata until/unless it's actually needed.  (i.e., some distributions
    # may not know their name or version without loading PKG-INFO)

    @property
    def key(self):
        try:
            return self._key
        except AttributeError:
            self._key = key = self.project_name.lower()
            return key

    @property
    def parsed_version(self):
        try:
            return self._parsed_version
        except AttributeError:
            self._parsed_version = pv = parse_version(self.version)
            return pv

    @property
    def version(self):
        try:
            return self._version
        except AttributeError:
            for line in self._get_metadata(self.PKG_INFO):
                if line.lower().startswith('version:'):
                    self._version = safe_version(line.split(':',1)[1].strip())
                    return self._version
            else:
                raise ValueError(
                    "Missing 'Version:' header and/or %s file" % self.PKG_INFO, self
                )

    @property
    def _dep_map(self):
        try:
            return self.__dep_map
        except AttributeError:
            dm = self.__dep_map = {None: []}
            for name in 'requires.txt', 'depends.txt':
                for extra,reqs in split_sections(self._get_metadata(name)):
                    if extra:
                        if ':' in extra:
                            extra, marker = extra.split(':',1)
                            if invalid_marker(marker):
                                reqs=[] # XXX warn
                            elif not evaluate_marker(marker):
                                reqs=[]
                        extra = safe_extra(extra) or None
                    dm.setdefault(extra,[]).extend(parse_requirements(reqs))
            return dm

    def requires(self,extras=()):
        """List of Requirements needed for this distro if `extras` are used"""
        dm = self._dep_map
        deps = []
        deps.extend(dm.get(None,()))
        for ext in extras:
            try:
                deps.extend(dm[safe_extra(ext)])
            except KeyError:
                raise UnknownExtra(
                    "%s has no such extra feature %r" % (self, ext)
                )
        return deps

    def _get_metadata(self,name):
        if self.has_metadata(name):
            for line in self.get_metadata_lines(name):
                yield line

    def activate(self,path=None):
        """Ensure distribution is importable on `path` (default=sys.path)"""
        if path is None: path = sys.path
        self.insert_on(path)
        if path is sys.path:
            fixup_namespace_packages(self.location)
            for pkg in self._get_metadata('namespace_packages.txt'):
                if pkg in sys.modules:
                    declare_namespace(pkg)

    def egg_name(self):
        """Return what this distribution's standard .egg filename should be"""
        filename = "%s-%s-py%s" % (
            to_filename(self.project_name), to_filename(self.version),
            self.py_version or PY_MAJOR
        )

        if self.platform:
            filename += '-'+self.platform
        return filename

    def __repr__(self):
        if self.location:
            return "%s (%s)" % (self,self.location)
        else:
            return str(self)

    def __str__(self):
        try: version = getattr(self,'version',None)
        except ValueError: version = None
        version = version or "[unknown version]"
        return "%s %s" % (self.project_name,version)

    def __getattr__(self,attr):
        """Delegate all unrecognized public attributes to .metadata provider"""
        if attr.startswith('_'):
            raise AttributeError(attr)
        return getattr(self._provider, attr)

    @classmethod
    def from_filename(cls,filename,metadata=None, **kw):
        return cls.from_location(
            _normalize_cached(filename), os.path.basename(filename), metadata,
            **kw
        )

    def as_requirement(self):
        """Return a ``Requirement`` that matches this distribution exactly"""
        return Requirement.parse('%s==%s' % (self.project_name, self.version))

    def load_entry_point(self, group, name):
        """Return the `name` entry point of `group` or raise ImportError"""
        ep = self.get_entry_info(group,name)
        if ep is None:
            raise ImportError("Entry point %r not found" % ((group,name),))
        return ep.load()

    def get_entry_map(self, group=None):
        """Return the entry point map for `group`, or the full entry map"""
        try:
            ep_map = self._ep_map
        except AttributeError:
            ep_map = self._ep_map = EntryPoint.parse_map(
                self._get_metadata('entry_points.txt'), self
            )
        if group is not None:
            return ep_map.get(group,{})
        return ep_map

    def get_entry_info(self, group, name):
        """Return the EntryPoint object for `group`+`name`, or ``None``"""
        return self.get_entry_map(group).get(name)

    def insert_on(self, path, loc = None):
        """Insert self.location in path before its nearest parent directory"""

        loc = loc or self.location
        if not loc:
            return

        nloc = _normalize_cached(loc)
        bdir = os.path.dirname(nloc)
        npath= [(p and _normalize_cached(p) or p) for p in path]

        for p, item in enumerate(npath):
            if item==nloc:
                break
            elif item==bdir and self.precedence==EGG_DIST:
                # if it's an .egg, give it precedence over its directory
                if path is sys.path:
                    self.check_version_conflict()
                path.insert(p, loc)
                npath.insert(p, nloc)
                break
        else:
            if path is sys.path:
                self.check_version_conflict()
            path.append(loc)
            return

        # p is the spot where we found or inserted loc; now remove duplicates
        while 1:
            try:
                np = npath.index(nloc, p+1)
            except ValueError:
                break
            else:
                del npath[np], path[np]
                p = np  # ha!

        return

    def check_version_conflict(self):
        if self.key=='setuptools':
            return      # ignore the inevitable setuptools self-conflicts  :(

        nsp = dict.fromkeys(self._get_metadata('namespace_packages.txt'))
        loc = normalize_path(self.location)
        for modname in self._get_metadata('top_level.txt'):
            if (modname not in sys.modules or modname in nsp
                    or modname in _namespace_packages):
                continue
            if modname in ('pkg_resources', 'setuptools', 'site'):
                continue
            fn = getattr(sys.modules[modname], '__file__', None)
            if fn and (normalize_path(fn).startswith(loc) or
                       fn.startswith(self.location)):
                continue
            issue_warning(
                "Module %s was already imported from %s, but %s is being added"
                " to sys.path" % (modname, fn, self.location),
            )

    def has_version(self):
        try:
            self.version
        except ValueError:
            issue_warning("Unbuilt egg for "+repr(self))
            return False
        return True

    def clone(self,**kw):
        """Copy this distribution, substituting in any changed keyword args"""
        for attr in (
            'project_name', 'version', 'py_version', 'platform', 'location',
            'precedence'
        ):
            kw.setdefault(attr, getattr(self,attr,None))
        kw.setdefault('metadata', self._provider)
        return self.__class__(**kw)

    @property
    def extras(self):
        return [dep for dep in self._dep_map if dep]


class DistInfoDistribution(Distribution):
    """Wrap an actual or potential sys.path entry w/metadata, .dist-info style"""
    PKG_INFO = 'METADATA'
    EQEQ = re.compile(r"([\(,])\s*(\d.*?)\s*([,\)])")

    @property
    def _parsed_pkg_info(self):
        """Parse and cache metadata"""
        try:
            return self._pkg_info
        except AttributeError:
            from email.parser import Parser
            self._pkg_info = Parser().parsestr(self.get_metadata(self.PKG_INFO))
            return self._pkg_info

    @property
    def _dep_map(self):
        try:
            return self.__dep_map
        except AttributeError:
            self.__dep_map = self._compute_dependencies()
            return self.__dep_map

    def _preparse_requirement(self, requires_dist):
        """Convert 'Foobar (1); baz' to ('Foobar ==1', 'baz')
        Split environment marker, add == prefix to version specifiers as
        necessary, and remove parenthesis.
        """
        parts = requires_dist.split(';', 1) + ['']
        distvers = parts[0].strip()
        mark = parts[1].strip()
        distvers = re.sub(self.EQEQ, r"\1==\2\3", distvers)
        distvers = distvers.replace('(', '').replace(')', '')
        return (distvers, mark)

    def _compute_dependencies(self):
        """Recompute this distribution's dependencies."""
        from pip._vendor._markerlib import compile as compile_marker
        dm = self.__dep_map = {None: []}

        reqs = []
        # Including any condition expressions
        for req in self._parsed_pkg_info.get_all('Requires-Dist') or []:
            distvers, mark = self._preparse_requirement(req)
            parsed = next(parse_requirements(distvers))
            parsed.marker_fn = compile_marker(mark)
            reqs.append(parsed)

        def reqs_for_extra(extra):
            for req in reqs:
                if req.marker_fn(override={'extra':extra}):
                    yield req

        common = frozenset(reqs_for_extra(None))
        dm[None].extend(common)

        for extra in self._parsed_pkg_info.get_all('Provides-Extra') or []:
            extra = safe_extra(extra.strip())
            dm[extra] = list(frozenset(reqs_for_extra(extra)) - common)

        return dm


_distributionImpl = {
    '.egg': Distribution,
    '.egg-info': Distribution,
    '.dist-info': DistInfoDistribution,
    }


def issue_warning(*args,**kw):
    level = 1
    g = globals()
    try:
        # find the first stack frame that is *not* code in
        # the pkg_resources module, to use for the warning
        while sys._getframe(level).f_globals is g:
            level += 1
    except ValueError:
        pass
    from warnings import warn
    warn(stacklevel = level+1, *args, **kw)


def parse_requirements(strs):
    """Yield ``Requirement`` objects for each specification in `strs`

    `strs` must be an instance of ``basestring``, or a (possibly-nested)
    iterable thereof.
    """
    # create a steppable iterator, so we can handle \-continuations
    lines = iter(yield_lines(strs))

    def scan_list(ITEM,TERMINATOR,line,p,groups,item_name):

        items = []

        while not TERMINATOR(line,p):
            if CONTINUE(line,p):
                try:
                    line = next(lines)
                    p = 0
                except StopIteration:
                    raise ValueError(
                        "\\ must not appear on the last nonblank line"
                    )

            match = ITEM(line,p)
            if not match:
                raise ValueError("Expected "+item_name+" in",line,"at",line[p:])

            items.append(match.group(*groups))
            p = match.end()

            match = COMMA(line,p)
            if match:
                p = match.end() # skip the comma
            elif not TERMINATOR(line,p):
                raise ValueError(
                    "Expected ',' or end-of-list in",line,"at",line[p:]
                )

        match = TERMINATOR(line,p)
        if match: p = match.end()   # skip the terminator, if any
        return line, p, items

    for line in lines:
        match = DISTRO(line)
        if not match:
            raise ValueError("Missing distribution spec", line)
        project_name = match.group(1)
        p = match.end()
        extras = []

        match = OBRACKET(line,p)
        if match:
            p = match.end()
            line, p, extras = scan_list(
                DISTRO, CBRACKET, line, p, (1,), "'extra' name"
            )

        line, p, specs = scan_list(VERSION,LINE_END,line,p,(1,2),"version spec")
        specs = [(op,safe_version(val)) for op,val in specs]
        yield Requirement(project_name, specs, extras)


def _sort_dists(dists):
    tmp = [(dist.hashcmp,dist) for dist in dists]
    tmp.sort()
    dists[::-1] = [d for hc,d in tmp]


class Requirement:
    def __init__(self, project_name, specs, extras):
        """DO NOT CALL THIS UNDOCUMENTED METHOD; use Requirement.parse()!"""
        self.unsafe_name, project_name = project_name, safe_name(project_name)
        self.project_name, self.key = project_name, project_name.lower()
        index = [(parse_version(v),state_machine[op],op,v) for op,v in specs]
        index.sort()
        self.specs = [(op,ver) for parsed,trans,op,ver in index]
        self.index, self.extras = index, tuple(map(safe_extra,extras))
        self.hashCmp = (
            self.key, tuple([(op,parsed) for parsed,trans,op,ver in index]),
            frozenset(self.extras)
        )
        self.__hash = hash(self.hashCmp)

    def __str__(self):
        specs = ','.join([''.join(s) for s in self.specs])
        extras = ','.join(self.extras)
        if extras: extras = '[%s]' % extras
        return '%s%s%s' % (self.project_name, extras, specs)

    def __eq__(self,other):
        return isinstance(other,Requirement) and self.hashCmp==other.hashCmp

    def __contains__(self,item):
        if isinstance(item,Distribution):
            if item.key != self.key: return False
            if self.index: item = item.parsed_version  # only get if we need it
        elif isinstance(item,basestring):
            item = parse_version(item)
        last = None
        compare = lambda a, b: (a > b) - (a < b) # -1, 0, 1
        for parsed,trans,op,ver in self.index:
            action = trans[compare(item,parsed)] # Indexing: 0, 1, -1
            if action=='F':
                return False
            elif action=='T':
                return True
            elif action=='+':
                last = True
            elif action=='-' or last is None:   last = False
        if last is None: last = True    # no rules encountered
        return last

    def __hash__(self):
        return self.__hash

    def __repr__(self): return "Requirement.parse(%r)" % str(self)

    @staticmethod
    def parse(s):
        reqs = list(parse_requirements(s))
        if reqs:
            if len(reqs)==1:
                return reqs[0]
            raise ValueError("Expected only one requirement", s)
        raise ValueError("No requirements found", s)

state_machine = {
    #       =><
    '<': '--T',
    '<=': 'T-T',
    '>': 'F+F',
    '>=': 'T+F',
    '==': 'T..',
    '!=': 'F++',
}


def _get_mro(cls):
    """Get an mro for a type or classic class"""
    if not isinstance(cls,type):
        class cls(cls,object): pass
        return cls.__mro__[1:]
    return cls.__mro__

def _find_adapter(registry, ob):
    """Return an adapter factory for `ob` from `registry`"""
    for t in _get_mro(getattr(ob, '__class__', type(ob))):
        if t in registry:
            return registry[t]


def ensure_directory(path):
    """Ensure that the parent directory of `path` exists"""
    dirname = os.path.dirname(path)
    if not os.path.isdir(dirname):
        os.makedirs(dirname)

def split_sections(s):
    """Split a string or iterable thereof into (section,content) pairs

    Each ``section`` is a stripped version of the section header ("[section]")
    and each ``content`` is a list of stripped lines excluding blank lines and
    comment-only lines.  If there are any such lines before the first section
    header, they're returned in a first ``section`` of ``None``.
    """
    section = None
    content = []
    for line in yield_lines(s):
        if line.startswith("["):
            if line.endswith("]"):
                if section or content:
                    yield section, content
                section = line[1:-1].strip()
                content = []
            else:
                raise ValueError("Invalid section heading", line)
        else:
            content.append(line)

    # wrap up last segment
    yield section, content

def _mkstemp(*args,**kw):
    from tempfile import mkstemp
    old_open = os.open
    try:
        os.open = os_open   # temporarily bypass sandboxing
        return mkstemp(*args,**kw)
    finally:
        os.open = old_open  # and then put it back


# Set up global resource manager (deliberately not state-saved)
_manager = ResourceManager()
def _initialize(g):
    for name in dir(_manager):
        if not name.startswith('_'):
            g[name] = getattr(_manager, name)
_initialize(globals())

# Prepare the master working set and make the ``require()`` API available
working_set = WorkingSet._build_master()
_declare_state('object', working_set=working_set)

require = working_set.require
iter_entry_points = working_set.iter_entry_points
add_activation_listener = working_set.subscribe
run_script = working_set.run_script
run_main = run_script   # backward compatibility
# Activate all distributions already on sys.path, and ensure that
# all distributions added to the working set in the future (e.g. by
# calling ``require()``) will get activated as well.
add_activation_listener(lambda dist: dist.activate())
working_set.entries=[]
list(map(working_set.add_entry,sys.path)) # match order

########NEW FILE########
__FILENAME__ = re-vendor
import os
import sys
import pip
import glob
import shutil

here = os.path.abspath(os.path.dirname(__file__))

def usage():
    print("Usage: re-vendor.py [clean|vendor]")
    sys.exit(1)

def clean():
    for fn in os.listdir(here):
        dirname = os.path.join(here, fn)
        if os.path.isdir(dirname):
            shutil.rmtree(dirname)
    # six is a single file, not a package
    os.unlink(os.path.join(here, 'six.py'))

def vendor():
    pip.main(['install', '-t', here, '-r', 'vendor.txt'])
    for dirname in glob.glob('*.egg-info'):
        shutil.rmtree(dirname)

if __name__ == '__main__':
    if len(sys.argv) != 2:
        usage()
    if sys.argv[1] == 'clean':
        clean()
    elif sys.argv[1] == 'vendor':
        vendor()
    else:
        usage()

########NEW FILE########
__FILENAME__ = adapters
# -*- coding: utf-8 -*-

"""
requests.adapters
~~~~~~~~~~~~~~~~~

This module contains the transport adapters that Requests uses to define
and maintain connections.
"""

import socket

from .models import Response
from .packages.urllib3.poolmanager import PoolManager, proxy_from_url
from .packages.urllib3.response import HTTPResponse
from .packages.urllib3.util import Timeout as TimeoutSauce
from .compat import urlparse, basestring, urldefrag, unquote
from .utils import (DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers,
                    prepend_scheme_if_needed, get_auth_from_url)
from .structures import CaseInsensitiveDict
from .packages.urllib3.exceptions import MaxRetryError
from .packages.urllib3.exceptions import TimeoutError
from .packages.urllib3.exceptions import SSLError as _SSLError
from .packages.urllib3.exceptions import HTTPError as _HTTPError
from .packages.urllib3.exceptions import ProxyError as _ProxyError
from .cookies import extract_cookies_to_jar
from .exceptions import ConnectionError, Timeout, SSLError, ProxyError
from .auth import _basic_auth_str

DEFAULT_POOLBLOCK = False
DEFAULT_POOLSIZE = 10
DEFAULT_RETRIES = 0


class BaseAdapter(object):
    """The Base Transport Adapter"""

    def __init__(self):
        super(BaseAdapter, self).__init__()

    def send(self):
        raise NotImplementedError

    def close(self):
        raise NotImplementedError


class HTTPAdapter(BaseAdapter):
    """The built-in HTTP Adapter for urllib3.

    Provides a general-case interface for Requests sessions to contact HTTP and
    HTTPS urls by implementing the Transport Adapter interface. This class will
    usually be created by the :class:`Session <Session>` class under the
    covers.

    :param pool_connections: The number of urllib3 connection pools to cache.
    :param pool_maxsize: The maximum number of connections to save in the pool.
    :param int max_retries: The maximum number of retries each connection
        should attempt. Note, this applies only to failed connections and
        timeouts, never to requests where the server returns a response.
    :param pool_block: Whether the connection pool should block for connections.

    Usage::

      >>> import requests
      >>> s = requests.Session()
      >>> a = requests.adapters.HTTPAdapter(max_retries=3)
      >>> s.mount('http://', a)
    """
    __attrs__ = ['max_retries', 'config', '_pool_connections', '_pool_maxsize',
                 '_pool_block']

    def __init__(self, pool_connections=DEFAULT_POOLSIZE,
                 pool_maxsize=DEFAULT_POOLSIZE, max_retries=DEFAULT_RETRIES,
                 pool_block=DEFAULT_POOLBLOCK):
        self.max_retries = max_retries
        self.config = {}
        self.proxy_manager = {}

        super(HTTPAdapter, self).__init__()

        self._pool_connections = pool_connections
        self._pool_maxsize = pool_maxsize
        self._pool_block = pool_block

        self.init_poolmanager(pool_connections, pool_maxsize, block=pool_block)

    def __getstate__(self):
        return dict((attr, getattr(self, attr, None)) for attr in
                    self.__attrs__)

    def __setstate__(self, state):
        # Can't handle by adding 'proxy_manager' to self.__attrs__ because
        # because self.poolmanager uses a lambda function, which isn't pickleable.
        self.proxy_manager = {}
        self.config = {}

        for attr, value in state.items():
            setattr(self, attr, value)

        self.init_poolmanager(self._pool_connections, self._pool_maxsize,
                              block=self._pool_block)

    def init_poolmanager(self, connections, maxsize, block=DEFAULT_POOLBLOCK):
        """Initializes a urllib3 PoolManager. This method should not be called
        from user code, and is only exposed for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param connections: The number of urllib3 connection pools to cache.
        :param maxsize: The maximum number of connections to save in the pool.
        :param block: Block when no free connections are available.
        """
        # save these values for pickling
        self._pool_connections = connections
        self._pool_maxsize = maxsize
        self._pool_block = block

        self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize,
                                       block=block)

    def cert_verify(self, conn, url, verify, cert):
        """Verify a SSL certificate. This method should not be called from user
        code, and is only exposed for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param conn: The urllib3 connection object associated with the cert.
        :param url: The requested URL.
        :param verify: Whether we should actually verify the certificate.
        :param cert: The SSL certificate to verify.
        """
        if url.lower().startswith('https') and verify:

            cert_loc = None

            # Allow self-specified cert location.
            if verify is not True:
                cert_loc = verify

            if not cert_loc:
                cert_loc = DEFAULT_CA_BUNDLE_PATH

            if not cert_loc:
                raise Exception("Could not find a suitable SSL CA certificate bundle.")

            conn.cert_reqs = 'CERT_REQUIRED'
            conn.ca_certs = cert_loc
        else:
            conn.cert_reqs = 'CERT_NONE'
            conn.ca_certs = None

        if cert:
            if not isinstance(cert, basestring):
                conn.cert_file = cert[0]
                conn.key_file = cert[1]
            else:
                conn.cert_file = cert

    def build_response(self, req, resp):
        """Builds a :class:`Response <requests.Response>` object from a urllib3
        response. This should not be called from user code, and is only exposed
        for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`

        :param req: The :class:`PreparedRequest <PreparedRequest>` used to generate the response.
        :param resp: The urllib3 response object.
        """
        response = Response()

        # Fallback to None if there's no status_code, for whatever reason.
        response.status_code = getattr(resp, 'status', None)

        # Make headers case-insensitive.
        response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))

        # Set encoding.
        response.encoding = get_encoding_from_headers(response.headers)
        response.raw = resp
        response.reason = response.raw.reason

        if isinstance(req.url, bytes):
            response.url = req.url.decode('utf-8')
        else:
            response.url = req.url

        # Add new cookies from the server.
        extract_cookies_to_jar(response.cookies, req, resp)

        # Give the Response some context.
        response.request = req
        response.connection = self

        return response

    def get_connection(self, url, proxies=None):
        """Returns a urllib3 connection for the given URL. This should not be
        called from user code, and is only exposed for use when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param url: The URL to connect to.
        :param proxies: (optional) A Requests-style dictionary of proxies used on this request.
        """
        proxies = proxies or {}
        proxy = proxies.get(urlparse(url.lower()).scheme)

        if proxy:
            proxy = prepend_scheme_if_needed(proxy, 'http')
            proxy_headers = self.proxy_headers(proxy)

            if not proxy in self.proxy_manager:
                self.proxy_manager[proxy] = proxy_from_url(
                                                proxy,
                                                proxy_headers=proxy_headers,
                                                num_pools=self._pool_connections,
                                                maxsize=self._pool_maxsize,
                                                block=self._pool_block)

            conn = self.proxy_manager[proxy].connection_from_url(url)
        else:
            # Only scheme should be lower case
            parsed = urlparse(url)
            url = parsed.geturl()
            conn = self.poolmanager.connection_from_url(url)

        return conn

    def close(self):
        """Disposes of any internal state.

        Currently, this just closes the PoolManager, which closes pooled
        connections.
        """
        self.poolmanager.clear()

    def request_url(self, request, proxies):
        """Obtain the url to use when making the final request.

        If the message is being sent through a HTTP proxy, the full URL has to
        be used. Otherwise, we should only use the path portion of the URL.

        This should not be called from user code, and is only exposed for use
        when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param proxies: A dictionary of schemes to proxy URLs.
        """
        proxies = proxies or {}
        scheme = urlparse(request.url).scheme
        proxy = proxies.get(scheme)

        if proxy and scheme != 'https':
            url, _ = urldefrag(request.url)
        else:
            url = request.path_url

        return url

    def add_headers(self, request, **kwargs):
        """Add any headers needed by the connection. As of v2.0 this does
        nothing by default, but is left for overriding by users that subclass
        the :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        This should not be called from user code, and is only exposed for use
        when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param request: The :class:`PreparedRequest <PreparedRequest>` to add headers to.
        :param kwargs: The keyword arguments from the call to send().
        """
        pass

    def proxy_headers(self, proxy):
        """Returns a dictionary of the headers to add to any request sent
        through a proxy. This works with urllib3 magic to ensure that they are
        correctly sent to the proxy, rather than in a tunnelled request if
        CONNECT is being used.

        This should not be called from user code, and is only exposed for use
        when subclassing the
        :class:`HTTPAdapter <requests.adapters.HTTPAdapter>`.

        :param proxies: The url of the proxy being used for this request.
        :param kwargs: Optional additional keyword arguments.
        """
        headers = {}
        username, password = get_auth_from_url(proxy)

        if username and password:
            headers['Proxy-Authorization'] = _basic_auth_str(username,
                                                             password)

        return headers

    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
        """Sends PreparedRequest object. Returns Response object.

        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) The timeout on the request.
        :param verify: (optional) Whether to verify SSL certificates.
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        """

        conn = self.get_connection(request.url, proxies)

        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(request)

        chunked = not (request.body is None or 'Content-Length' in request.headers)

        timeout = TimeoutSauce(connect=timeout, read=timeout)

        try:
            if not chunked:
                resp = conn.urlopen(
                    method=request.method,
                    url=url,
                    body=request.body,
                    headers=request.headers,
                    redirect=False,
                    assert_same_host=False,
                    preload_content=False,
                    decode_content=False,
                    retries=self.max_retries,
                    timeout=timeout
                )

            # Send the request.
            else:
                if hasattr(conn, 'proxy_pool'):
                    conn = conn.proxy_pool

                low_conn = conn._get_conn(timeout=timeout)

                try:
                    low_conn.putrequest(request.method,
                                        url,
                                        skip_accept_encoding=True)

                    for header, value in request.headers.items():
                        low_conn.putheader(header, value)

                    low_conn.endheaders()

                    for i in request.body:
                        low_conn.send(hex(len(i))[2:].encode('utf-8'))
                        low_conn.send(b'\r\n')
                        low_conn.send(i)
                        low_conn.send(b'\r\n')
                    low_conn.send(b'0\r\n\r\n')

                    r = low_conn.getresponse()
                    resp = HTTPResponse.from_httplib(
                        r,
                        pool=conn,
                        connection=low_conn,
                        preload_content=False,
                        decode_content=False
                    )
                except:
                    # If we hit any problems here, clean up the connection.
                    # Then, reraise so that we can handle the actual exception.
                    low_conn.close()
                    raise
                else:
                    # All is well, return the connection to the pool.
                    conn._put_conn(low_conn)

        except socket.error as sockerr:
            raise ConnectionError(sockerr, request=request)

        except MaxRetryError as e:
            raise ConnectionError(e, request=request)

        except _ProxyError as e:
            raise ProxyError(e)

        except (_SSLError, _HTTPError) as e:
            if isinstance(e, _SSLError):
                raise SSLError(e, request=request)
            elif isinstance(e, TimeoutError):
                raise Timeout(e, request=request)
            else:
                raise

        return self.build_response(request, resp)

########NEW FILE########
__FILENAME__ = api
# -*- coding: utf-8 -*-

"""
requests.api
~~~~~~~~~~~~

This module implements the Requests API.

:copyright: (c) 2012 by Kenneth Reitz.
:license: Apache2, see LICENSE for more details.

"""

from . import sessions


def request(method, url, **kwargs):
    """Constructs and sends a :class:`Request <Request>`.
    Returns :class:`Response <Response>` object.

    :param method: method for the new :class:`Request` object.
    :param url: URL for the new :class:`Request` object.
    :param params: (optional) Dictionary or bytes to be sent in the query string for the :class:`Request`.
    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
    :param headers: (optional) Dictionary of HTTP Headers to send with the :class:`Request`.
    :param cookies: (optional) Dict or CookieJar object to send with the :class:`Request`.
    :param files: (optional) Dictionary of 'name': file-like-objects (or {'name': ('filename', fileobj)}) for multipart encoding upload.
    :param auth: (optional) Auth tuple to enable Basic/Digest/Custom HTTP Auth.
    :param timeout: (optional) Float describing the timeout of the request in seconds.
    :param allow_redirects: (optional) Boolean. Set to True if POST/PUT/DELETE redirect following is allowed.
    :param proxies: (optional) Dictionary mapping protocol to the URL of the proxy.
    :param verify: (optional) if ``True``, the SSL cert will be verified. A CA_BUNDLE path can also be provided.
    :param stream: (optional) if ``False``, the response content will be immediately downloaded.
    :param cert: (optional) if String, path to ssl client cert file (.pem). If Tuple, ('cert', 'key') pair.

    Usage::

      >>> import requests
      >>> req = requests.request('GET', 'http://httpbin.org/get')
      <Response [200]>
    """

    session = sessions.Session()
    return session.request(method=method, url=url, **kwargs)


def get(url, **kwargs):
    """Sends a GET request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    """

    kwargs.setdefault('allow_redirects', True)
    return request('get', url, **kwargs)


def options(url, **kwargs):
    """Sends a OPTIONS request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    """

    kwargs.setdefault('allow_redirects', True)
    return request('options', url, **kwargs)


def head(url, **kwargs):
    """Sends a HEAD request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    """

    kwargs.setdefault('allow_redirects', False)
    return request('head', url, **kwargs)


def post(url, data=None, **kwargs):
    """Sends a POST request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    """

    return request('post', url, data=data, **kwargs)


def put(url, data=None, **kwargs):
    """Sends a PUT request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    """

    return request('put', url, data=data, **kwargs)


def patch(url, data=None, **kwargs):
    """Sends a PATCH request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    """

    return request('patch', url,  data=data, **kwargs)


def delete(url, **kwargs):
    """Sends a DELETE request. Returns :class:`Response` object.

    :param url: URL for the new :class:`Request` object.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    """

    return request('delete', url, **kwargs)

########NEW FILE########
__FILENAME__ = auth
# -*- coding: utf-8 -*-

"""
requests.auth
~~~~~~~~~~~~~

This module contains the authentication handlers for Requests.
"""

import os
import re
import time
import hashlib

from base64 import b64encode

from .compat import urlparse, str
from .cookies import extract_cookies_to_jar
from .utils import parse_dict_header

CONTENT_TYPE_FORM_URLENCODED = 'application/x-www-form-urlencoded'
CONTENT_TYPE_MULTI_PART = 'multipart/form-data'


def _basic_auth_str(username, password):
    """Returns a Basic Auth string."""

    return 'Basic ' + b64encode(('%s:%s' % (username, password)).encode('latin1')).strip().decode('latin1')


class AuthBase(object):
    """Base class that all auth implementations derive from"""

    def __call__(self, r):
        raise NotImplementedError('Auth hooks must be callable.')


class HTTPBasicAuth(AuthBase):
    """Attaches HTTP Basic Authentication to the given Request object."""
    def __init__(self, username, password):
        self.username = username
        self.password = password

    def __call__(self, r):
        r.headers['Authorization'] = _basic_auth_str(self.username, self.password)
        return r


class HTTPProxyAuth(HTTPBasicAuth):
    """Attaches HTTP Proxy Authentication to a given Request object."""
    def __call__(self, r):
        r.headers['Proxy-Authorization'] = _basic_auth_str(self.username, self.password)
        return r


class HTTPDigestAuth(AuthBase):
    """Attaches HTTP Digest Authentication to the given Request object."""
    def __init__(self, username, password):
        self.username = username
        self.password = password
        self.last_nonce = ''
        self.nonce_count = 0
        self.chal = {}
        self.pos = None

    def build_digest_header(self, method, url):

        realm = self.chal['realm']
        nonce = self.chal['nonce']
        qop = self.chal.get('qop')
        algorithm = self.chal.get('algorithm')
        opaque = self.chal.get('opaque')

        if algorithm is None:
            _algorithm = 'MD5'
        else:
            _algorithm = algorithm.upper()
        # lambdas assume digest modules are imported at the top level
        if _algorithm == 'MD5' or _algorithm == 'MD5-SESS':
            def md5_utf8(x):
                if isinstance(x, str):
                    x = x.encode('utf-8')
                return hashlib.md5(x).hexdigest()
            hash_utf8 = md5_utf8
        elif _algorithm == 'SHA':
            def sha_utf8(x):
                if isinstance(x, str):
                    x = x.encode('utf-8')
                return hashlib.sha1(x).hexdigest()
            hash_utf8 = sha_utf8

        KD = lambda s, d: hash_utf8("%s:%s" % (s, d))

        if hash_utf8 is None:
            return None

        # XXX not implemented yet
        entdig = None
        p_parsed = urlparse(url)
        path = p_parsed.path
        if p_parsed.query:
            path += '?' + p_parsed.query

        A1 = '%s:%s:%s' % (self.username, realm, self.password)
        A2 = '%s:%s' % (method, path)

        HA1 = hash_utf8(A1)
        HA2 = hash_utf8(A2)

        if nonce == self.last_nonce:
            self.nonce_count += 1
        else:
            self.nonce_count = 1
        ncvalue = '%08x' % self.nonce_count
        s = str(self.nonce_count).encode('utf-8')
        s += nonce.encode('utf-8')
        s += time.ctime().encode('utf-8')
        s += os.urandom(8)

        cnonce = (hashlib.sha1(s).hexdigest()[:16])
        noncebit = "%s:%s:%s:%s:%s" % (nonce, ncvalue, cnonce, qop, HA2)
        if _algorithm == 'MD5-SESS':
            HA1 = hash_utf8('%s:%s:%s' % (HA1, nonce, cnonce))

        if qop is None:
            respdig = KD(HA1, "%s:%s" % (nonce, HA2))
        elif qop == 'auth' or 'auth' in qop.split(','):
            respdig = KD(HA1, noncebit)
        else:
            # XXX handle auth-int.
            return None

        self.last_nonce = nonce

        # XXX should the partial digests be encoded too?
        base = 'username="%s", realm="%s", nonce="%s", uri="%s", ' \
               'response="%s"' % (self.username, realm, nonce, path, respdig)
        if opaque:
            base += ', opaque="%s"' % opaque
        if algorithm:
            base += ', algorithm="%s"' % algorithm
        if entdig:
            base += ', digest="%s"' % entdig
        if qop:
            base += ', qop="auth", nc=%s, cnonce="%s"' % (ncvalue, cnonce)

        return 'Digest %s' % (base)

    def handle_401(self, r, **kwargs):
        """Takes the given response and tries digest-auth, if needed."""

        if self.pos is not None:
            # Rewind the file position indicator of the body to where
            # it was to resend the request.
            r.request.body.seek(self.pos)
        num_401_calls = getattr(self, 'num_401_calls', 1)
        s_auth = r.headers.get('www-authenticate', '')

        if 'digest' in s_auth.lower() and num_401_calls < 2:

            setattr(self, 'num_401_calls', num_401_calls + 1)
            pat = re.compile(r'digest ', flags=re.IGNORECASE)
            self.chal = parse_dict_header(pat.sub('', s_auth, count=1))

            # Consume content and release the original connection
            # to allow our new request to reuse the same one.
            r.content
            r.raw.release_conn()
            prep = r.request.copy()
            extract_cookies_to_jar(prep._cookies, r.request, r.raw)
            prep.prepare_cookies(prep._cookies)

            prep.headers['Authorization'] = self.build_digest_header(
                prep.method, prep.url)
            _r = r.connection.send(prep, **kwargs)
            _r.history.append(r)
            _r.request = prep

            return _r

        setattr(self, 'num_401_calls', 1)
        return r

    def __call__(self, r):
        # If we have a saved nonce, skip the 401
        if self.last_nonce:
            r.headers['Authorization'] = self.build_digest_header(r.method, r.url)
        try:
            self.pos = r.body.tell()
        except AttributeError:
            pass
        r.register_hook('response', self.handle_401)
        return r

########NEW FILE########
__FILENAME__ = certs
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
certs.py
~~~~~~~~

This module returns the preferred default CA certificate bundle.

If you are packaging Requests, e.g., for a Linux distribution or a managed
environment, you can change the definition of where() to return a separately
packaged CA bundle.
"""

import os.path


def where():
    """Return the preferred certificate bundle."""
    # vendored bundle inside Requests
    return os.path.join(os.path.dirname(__file__), 'cacert.pem')

if __name__ == '__main__':
    print(where())

########NEW FILE########
__FILENAME__ = compat
# -*- coding: utf-8 -*-

"""
pythoncompat
"""

from .packages import chardet

import sys

# -------
# Pythons
# -------

# Syntax sugar.
_ver = sys.version_info

#: Python 2.x?
is_py2 = (_ver[0] == 2)

#: Python 3.x?
is_py3 = (_ver[0] == 3)

#: Python 3.0.x
is_py30 = (is_py3 and _ver[1] == 0)

#: Python 3.1.x
is_py31 = (is_py3 and _ver[1] == 1)

#: Python 3.2.x
is_py32 = (is_py3 and _ver[1] == 2)

#: Python 3.3.x
is_py33 = (is_py3 and _ver[1] == 3)

#: Python 3.4.x
is_py34 = (is_py3 and _ver[1] == 4)

#: Python 2.7.x
is_py27 = (is_py2 and _ver[1] == 7)

#: Python 2.6.x
is_py26 = (is_py2 and _ver[1] == 6)

#: Python 2.5.x
is_py25 = (is_py2 and _ver[1] == 5)

#: Python 2.4.x
is_py24 = (is_py2 and _ver[1] == 4)   # I'm assuming this is not by choice.


# ---------
# Platforms
# ---------


# Syntax sugar.
_ver = sys.version.lower()

is_pypy = ('pypy' in _ver)
is_jython = ('jython' in _ver)
is_ironpython = ('iron' in _ver)

# Assume CPython, if nothing else.
is_cpython = not any((is_pypy, is_jython, is_ironpython))

# Windows-based system.
is_windows = 'win32' in str(sys.platform).lower()

# Standard Linux 2+ system.
is_linux = ('linux' in str(sys.platform).lower())
is_osx = ('darwin' in str(sys.platform).lower())
is_hpux = ('hpux' in str(sys.platform).lower())   # Complete guess.
is_solaris = ('solar==' in str(sys.platform).lower())   # Complete guess.

try:
    import simplejson as json
except ImportError:
    import json

# ---------
# Specifics
# ---------

if is_py2:
    from urllib import quote, unquote, quote_plus, unquote_plus, urlencode, getproxies, proxy_bypass
    from urlparse import urlparse, urlunparse, urljoin, urlsplit, urldefrag
    from urllib2 import parse_http_list
    import cookielib
    from Cookie import Morsel
    from StringIO import StringIO
    from .packages.urllib3.packages.ordered_dict import OrderedDict
    from httplib import IncompleteRead

    builtin_str = str
    bytes = str
    str = unicode
    basestring = basestring
    numeric_types = (int, long, float)


elif is_py3:
    from urllib.parse import urlparse, urlunparse, urljoin, urlsplit, urlencode, quote, unquote, quote_plus, unquote_plus, urldefrag
    from urllib.request import parse_http_list, getproxies, proxy_bypass
    from http import cookiejar as cookielib
    from http.cookies import Morsel
    from io import StringIO
    from collections import OrderedDict
    from http.client import IncompleteRead

    builtin_str = str
    str = str
    bytes = bytes
    basestring = (str, bytes)
    numeric_types = (int, float)

########NEW FILE########
__FILENAME__ = cookies
# -*- coding: utf-8 -*-

"""
Compatibility code to be able to use `cookielib.CookieJar` with requests.

requests.utils imports from here, so be careful with imports.
"""

import time
import collections
from .compat import cookielib, urlparse, urlunparse, Morsel

try:
    import threading
    # grr, pyflakes: this fixes "redefinition of unused 'threading'"
    threading
except ImportError:
    import dummy_threading as threading


class MockRequest(object):
    """Wraps a `requests.Request` to mimic a `urllib2.Request`.

    The code in `cookielib.CookieJar` expects this interface in order to correctly
    manage cookie policies, i.e., determine whether a cookie can be set, given the
    domains of the request and the cookie.

    The original request object is read-only. The client is responsible for collecting
    the new headers via `get_new_headers()` and interpreting them appropriately. You
    probably want `get_cookie_header`, defined below.
    """

    def __init__(self, request):
        self._r = request
        self._new_headers = {}
        self.type = urlparse(self._r.url).scheme

    def get_type(self):
        return self.type

    def get_host(self):
        return urlparse(self._r.url).netloc

    def get_origin_req_host(self):
        return self.get_host()

    def get_full_url(self):
        # Only return the response's URL if the user hadn't set the Host
        # header
        if not self._r.headers.get('Host'):
            return self._r.url
        # If they did set it, retrieve it and reconstruct the expected domain
        host = self._r.headers['Host']
        parsed = urlparse(self._r.url)
        # Reconstruct the URL as we expect it
        return urlunparse([
            parsed.scheme, host, parsed.path, parsed.params, parsed.query,
            parsed.fragment
        ])

    def is_unverifiable(self):
        return True

    def has_header(self, name):
        return name in self._r.headers or name in self._new_headers

    def get_header(self, name, default=None):
        return self._r.headers.get(name, self._new_headers.get(name, default))

    def add_header(self, key, val):
        """cookielib has no legitimate use for this method; add it back if you find one."""
        raise NotImplementedError("Cookie headers should be added with add_unredirected_header()")

    def add_unredirected_header(self, name, value):
        self._new_headers[name] = value

    def get_new_headers(self):
        return self._new_headers

    @property
    def unverifiable(self):
        return self.is_unverifiable()

    @property
    def origin_req_host(self):
        return self.get_origin_req_host()

    @property
    def host(self):
        return self.get_host()


class MockResponse(object):
    """Wraps a `httplib.HTTPMessage` to mimic a `urllib.addinfourl`.

    ...what? Basically, expose the parsed HTTP headers from the server response
    the way `cookielib` expects to see them.
    """

    def __init__(self, headers):
        """Make a MockResponse for `cookielib` to read.

        :param headers: a httplib.HTTPMessage or analogous carrying the headers
        """
        self._headers = headers

    def info(self):
        return self._headers

    def getheaders(self, name):
        self._headers.getheaders(name)


def extract_cookies_to_jar(jar, request, response):
    """Extract the cookies from the response into a CookieJar.

    :param jar: cookielib.CookieJar (not necessarily a RequestsCookieJar)
    :param request: our own requests.Request object
    :param response: urllib3.HTTPResponse object
    """
    if not (hasattr(response, '_original_response') and
            response._original_response):
        return
    # the _original_response field is the wrapped httplib.HTTPResponse object,
    req = MockRequest(request)
    # pull out the HTTPMessage with the headers and put it in the mock:
    res = MockResponse(response._original_response.msg)
    jar.extract_cookies(res, req)


def get_cookie_header(jar, request):
    """Produce an appropriate Cookie header string to be sent with `request`, or None."""
    r = MockRequest(request)
    jar.add_cookie_header(r)
    return r.get_new_headers().get('Cookie')


def remove_cookie_by_name(cookiejar, name, domain=None, path=None):
    """Unsets a cookie by name, by default over all domains and paths.

    Wraps CookieJar.clear(), is O(n).
    """
    clearables = []
    for cookie in cookiejar:
        if cookie.name == name:
            if domain is None or domain == cookie.domain:
                if path is None or path == cookie.path:
                    clearables.append((cookie.domain, cookie.path, cookie.name))

    for domain, path, name in clearables:
        cookiejar.clear(domain, path, name)


class CookieConflictError(RuntimeError):
    """There are two cookies that meet the criteria specified in the cookie jar.
    Use .get and .set and include domain and path args in order to be more specific."""


class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):
    """Compatibility class; is a cookielib.CookieJar, but exposes a dict interface.

    This is the CookieJar we create by default for requests and sessions that
    don't specify one, since some clients may expect response.cookies and
    session.cookies to support dict operations.

    Don't use the dict interface internally; it's just for compatibility with
    with external client code. All `requests` code should work out of the box
    with externally provided instances of CookieJar, e.g., LWPCookieJar and
    FileCookieJar.

    Caution: dictionary operations that are normally O(1) may be O(n).

    Unlike a regular CookieJar, this class is pickleable.
    """

    def get(self, name, default=None, domain=None, path=None):
        """Dict-like get() that also supports optional domain and path args in
        order to resolve naming collisions from using one cookie jar over
        multiple domains. Caution: operation is O(n), not O(1)."""
        try:
            return self._find_no_duplicates(name, domain, path)
        except KeyError:
            return default

    def set(self, name, value, **kwargs):
        """Dict-like set() that also supports optional domain and path args in
        order to resolve naming collisions from using one cookie jar over
        multiple domains."""
        # support client code that unsets cookies by assignment of a None value:
        if value is None:
            remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))
            return

        if isinstance(value, Morsel):
            c = morsel_to_cookie(value)
        else:
            c = create_cookie(name, value, **kwargs)
        self.set_cookie(c)
        return c

    def iterkeys(self):
        """Dict-like iterkeys() that returns an iterator of names of cookies from the jar.
        See itervalues() and iteritems()."""
        for cookie in iter(self):
            yield cookie.name

    def keys(self):
        """Dict-like keys() that returns a list of names of cookies from the jar.
        See values() and items()."""
        return list(self.iterkeys())

    def itervalues(self):
        """Dict-like itervalues() that returns an iterator of values of cookies from the jar.
        See iterkeys() and iteritems()."""
        for cookie in iter(self):
            yield cookie.value

    def values(self):
        """Dict-like values() that returns a list of values of cookies from the jar.
        See keys() and items()."""
        return list(self.itervalues())

    def iteritems(self):
        """Dict-like iteritems() that returns an iterator of name-value tuples from the jar.
        See iterkeys() and itervalues()."""
        for cookie in iter(self):
            yield cookie.name, cookie.value

    def items(self):
        """Dict-like items() that returns a list of name-value tuples from the jar.
        See keys() and values(). Allows client-code to call "dict(RequestsCookieJar)
        and get a vanilla python dict of key value pairs."""
        return list(self.iteritems())

    def list_domains(self):
        """Utility method to list all the domains in the jar."""
        domains = []
        for cookie in iter(self):
            if cookie.domain not in domains:
                domains.append(cookie.domain)
        return domains

    def list_paths(self):
        """Utility method to list all the paths in the jar."""
        paths = []
        for cookie in iter(self):
            if cookie.path not in paths:
                paths.append(cookie.path)
        return paths

    def multiple_domains(self):
        """Returns True if there are multiple domains in the jar.
        Returns False otherwise."""
        domains = []
        for cookie in iter(self):
            if cookie.domain is not None and cookie.domain in domains:
                return True
            domains.append(cookie.domain)
        return False  # there is only one domain in jar

    def get_dict(self, domain=None, path=None):
        """Takes as an argument an optional domain and path and returns a plain old
        Python dict of name-value pairs of cookies that meet the requirements."""
        dictionary = {}
        for cookie in iter(self):
            if (domain is None or cookie.domain == domain) and (path is None
                                                or cookie.path == path):
                dictionary[cookie.name] = cookie.value
        return dictionary

    def __getitem__(self, name):
        """Dict-like __getitem__() for compatibility with client code. Throws exception
        if there are more than one cookie with name. In that case, use the more
        explicit get() method instead. Caution: operation is O(n), not O(1)."""

        return self._find_no_duplicates(name)

    def __setitem__(self, name, value):
        """Dict-like __setitem__ for compatibility with client code. Throws exception
        if there is already a cookie of that name in the jar. In that case, use the more
        explicit set() method instead."""

        self.set(name, value)

    def __delitem__(self, name):
        """Deletes a cookie given a name. Wraps cookielib.CookieJar's remove_cookie_by_name()."""
        remove_cookie_by_name(self, name)

    def set_cookie(self, cookie, *args, **kwargs):
        if hasattr(cookie.value, 'startswith') and cookie.value.startswith('"') and cookie.value.endswith('"'):
            cookie.value = cookie.value.replace('\\"', '')
        return super(RequestsCookieJar, self).set_cookie(cookie, *args, **kwargs)

    def update(self, other):
        """Updates this jar with cookies from another CookieJar or dict-like"""
        if isinstance(other, cookielib.CookieJar):
            for cookie in other:
                self.set_cookie(cookie)
        else:
            super(RequestsCookieJar, self).update(other)

    def _find(self, name, domain=None, path=None):
        """Requests uses this method internally to get cookie values. Takes as args name
        and optional domain and path. Returns a cookie.value. If there are conflicting cookies,
        _find arbitrarily chooses one. See _find_no_duplicates if you want an exception thrown
        if there are conflicting cookies."""
        for cookie in iter(self):
            if cookie.name == name:
                if domain is None or cookie.domain == domain:
                    if path is None or cookie.path == path:
                        return cookie.value

        raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))

    def _find_no_duplicates(self, name, domain=None, path=None):
        """__get_item__ and get call _find_no_duplicates -- never used in Requests internally.
        Takes as args name and optional domain and path. Returns a cookie.value.
        Throws KeyError if cookie is not found and CookieConflictError if there are
        multiple cookies that match name and optionally domain and path."""
        toReturn = None
        for cookie in iter(self):
            if cookie.name == name:
                if domain is None or cookie.domain == domain:
                    if path is None or cookie.path == path:
                        if toReturn is not None:  # if there are multiple cookies that meet passed in criteria
                            raise CookieConflictError('There are multiple cookies with name, %r' % (name))
                        toReturn = cookie.value  # we will eventually return this as long as no cookie conflict

        if toReturn:
            return toReturn
        raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))

    def __getstate__(self):
        """Unlike a normal CookieJar, this class is pickleable."""
        state = self.__dict__.copy()
        # remove the unpickleable RLock object
        state.pop('_cookies_lock')
        return state

    def __setstate__(self, state):
        """Unlike a normal CookieJar, this class is pickleable."""
        self.__dict__.update(state)
        if '_cookies_lock' not in self.__dict__:
            self._cookies_lock = threading.RLock()

    def copy(self):
        """Return a copy of this RequestsCookieJar."""
        new_cj = RequestsCookieJar()
        new_cj.update(self)
        return new_cj


def create_cookie(name, value, **kwargs):
    """Make a cookie from underspecified parameters.

    By default, the pair of `name` and `value` will be set for the domain ''
    and sent on every request (this is sometimes called a "supercookie").
    """
    result = dict(
        version=0,
        name=name,
        value=value,
        port=None,
        domain='',
        path='/',
        secure=False,
        expires=None,
        discard=True,
        comment=None,
        comment_url=None,
        rest={'HttpOnly': None},
        rfc2109=False,)

    badargs = set(kwargs) - set(result)
    if badargs:
        err = 'create_cookie() got unexpected keyword arguments: %s'
        raise TypeError(err % list(badargs))

    result.update(kwargs)
    result['port_specified'] = bool(result['port'])
    result['domain_specified'] = bool(result['domain'])
    result['domain_initial_dot'] = result['domain'].startswith('.')
    result['path_specified'] = bool(result['path'])

    return cookielib.Cookie(**result)


def morsel_to_cookie(morsel):
    """Convert a Morsel object into a Cookie containing the one k/v pair."""

    expires = None
    if morsel['max-age']:
        expires = time.time() + morsel['max-age']
    elif morsel['expires']:
        time_template = '%a, %d-%b-%Y %H:%M:%S GMT'
        expires = time.mktime(
            time.strptime(morsel['expires'], time_template)) - time.timezone
    return create_cookie(
        comment=morsel['comment'],
        comment_url=bool(morsel['comment']),
        discard=False,
        domain=morsel['domain'],
        expires=expires,
        name=morsel.key,
        path=morsel['path'],
        port=None,
        rest={'HttpOnly': morsel['httponly']},
        rfc2109=False,
        secure=bool(morsel['secure']),
        value=morsel.value,
        version=morsel['version'] or 0,
    )


def cookiejar_from_dict(cookie_dict, cookiejar=None, overwrite=True):
    """Returns a CookieJar from a key/value dictionary.

    :param cookie_dict: Dict of key/values to insert into CookieJar.
    :param cookiejar: (optional) A cookiejar to add the cookies to.
    :param overwrite: (optional) If False, will not replace cookies
        already in the jar with new ones.
    """
    if cookiejar is None:
        cookiejar = RequestsCookieJar()

    if cookie_dict is not None:
        names_from_jar = [cookie.name for cookie in cookiejar]
        for name in cookie_dict:
            if overwrite or (name not in names_from_jar):
                cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))

    return cookiejar


def merge_cookies(cookiejar, cookies):
    """Add cookies to cookiejar and returns a merged CookieJar.

    :param cookiejar: CookieJar object to add the cookies to.
    :param cookies: Dictionary or CookieJar object to be added.
    """
    if not isinstance(cookiejar, cookielib.CookieJar):
        raise ValueError('You can only merge into CookieJar')
    
    if isinstance(cookies, dict):
        cookiejar = cookiejar_from_dict(
            cookies, cookiejar=cookiejar, overwrite=False)
    elif isinstance(cookies, cookielib.CookieJar):
        try:
            cookiejar.update(cookies)
        except AttributeError:
            for cookie_in_jar in cookies:
                cookiejar.set_cookie(cookie_in_jar)

    return cookiejar

########NEW FILE########
__FILENAME__ = exceptions
# -*- coding: utf-8 -*-

"""
requests.exceptions
~~~~~~~~~~~~~~~~~~~

This module contains the set of Requests' exceptions.

"""
from .packages.urllib3.exceptions import HTTPError as BaseHTTPError


class RequestException(IOError):
    """There was an ambiguous exception that occurred while handling your
    request."""

    def __init__(self, *args, **kwargs):
        """
        Initialize RequestException with `request` and `response` objects.
        """
        response = kwargs.pop('response', None)
        self.response = response
        self.request = kwargs.pop('request', None)
        if (response is not None and not self.request and
                hasattr(response, 'request')):
            self.request = self.response.request
        super(RequestException, self).__init__(*args, **kwargs)


class HTTPError(RequestException):
    """An HTTP error occurred."""


class ConnectionError(RequestException):
    """A Connection error occurred."""


class ProxyError(ConnectionError):
    """A proxy error occurred."""


class SSLError(ConnectionError):
    """An SSL error occurred."""


class Timeout(RequestException):
    """The request timed out."""


class URLRequired(RequestException):
    """A valid URL is required to make a request."""


class TooManyRedirects(RequestException):
    """Too many redirects."""


class MissingSchema(RequestException, ValueError):
    """The URL schema (e.g. http or https) is missing."""


class InvalidSchema(RequestException, ValueError):
    """See defaults.py for valid schemas."""


class InvalidURL(RequestException, ValueError):
    """ The URL provided was somehow invalid. """


class ChunkedEncodingError(RequestException):
    """The server declared chunked encoding but sent an invalid chunk."""


class ContentDecodingError(RequestException, BaseHTTPError):
    """Failed to decode response content"""

########NEW FILE########
__FILENAME__ = hooks
# -*- coding: utf-8 -*-

"""
requests.hooks
~~~~~~~~~~~~~~

This module provides the capabilities for the Requests hooks system.

Available hooks:

``response``:
    The response generated from a Request.

"""


HOOKS = ['response']


def default_hooks():
    hooks = {}
    for event in HOOKS:
        hooks[event] = []
    return hooks

# TODO: response is the only one


def dispatch_hook(key, hooks, hook_data, **kwargs):
    """Dispatches a hook dictionary on a given piece of data."""

    hooks = hooks or dict()

    if key in hooks:
        hooks = hooks.get(key)

        if hasattr(hooks, '__call__'):
            hooks = [hooks]

        for hook in hooks:
            _hook_data = hook(hook_data, **kwargs)
            if _hook_data is not None:
                hook_data = _hook_data

    return hook_data

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-

"""
requests.models
~~~~~~~~~~~~~~~

This module contains the primary objects that power Requests.
"""

import collections
import datetime

from io import BytesIO, UnsupportedOperation
from .hooks import default_hooks
from .structures import CaseInsensitiveDict

from .auth import HTTPBasicAuth
from .cookies import cookiejar_from_dict, get_cookie_header
from .packages.urllib3.fields import RequestField
from .packages.urllib3.filepost import encode_multipart_formdata
from .packages.urllib3.util import parse_url
from .packages.urllib3.exceptions import DecodeError
from .exceptions import (
    HTTPError, RequestException, MissingSchema, InvalidURL,
    ChunkedEncodingError, ContentDecodingError)
from .utils import (
    guess_filename, get_auth_from_url, requote_uri,
    stream_decode_response_unicode, to_key_val_list, parse_header_links,
    iter_slices, guess_json_utf, super_len, to_native_string)
from .compat import (
    cookielib, urlunparse, urlsplit, urlencode, str, bytes, StringIO,
    is_py2, chardet, json, builtin_str, basestring, IncompleteRead)
from .status_codes import codes

#: The set of HTTP status codes that indicate an automatically
#: processable redirect.
REDIRECT_STATI = (
    codes.moved,  # 301
    codes.found,  # 302
    codes.other,  # 303
    codes.temporary_moved,  # 307
)
DEFAULT_REDIRECT_LIMIT = 30
CONTENT_CHUNK_SIZE = 10 * 1024
ITER_CHUNK_SIZE = 512


class RequestEncodingMixin(object):
    @property
    def path_url(self):
        """Build the path URL to use."""

        url = []

        p = urlsplit(self.url)

        path = p.path
        if not path:
            path = '/'

        url.append(path)

        query = p.query
        if query:
            url.append('?')
            url.append(query)

        return ''.join(url)

    @staticmethod
    def _encode_params(data):
        """Encode parameters in a piece of data.

        Will successfully encode parameters when passed as a dict or a list of
        2-tuples. Order is retained if data is a list of 2-tuples but arbitrary
        if parameters are supplied as a dict.
        """

        if isinstance(data, (str, bytes)):
            return data
        elif hasattr(data, 'read'):
            return data
        elif hasattr(data, '__iter__'):
            result = []
            for k, vs in to_key_val_list(data):
                if isinstance(vs, basestring) or not hasattr(vs, '__iter__'):
                    vs = [vs]
                for v in vs:
                    if v is not None:
                        result.append(
                            (k.encode('utf-8') if isinstance(k, str) else k,
                             v.encode('utf-8') if isinstance(v, str) else v))
            return urlencode(result, doseq=True)
        else:
            return data

    @staticmethod
    def _encode_files(files, data):
        """Build the body for a multipart/form-data request.

        Will successfully encode files when passed as a dict or a list of
        2-tuples. Order is retained if data is a list of 2-tuples but arbitrary
        if parameters are supplied as a dict.

        """
        if (not files):
            raise ValueError("Files must be provided.")
        elif isinstance(data, basestring):
            raise ValueError("Data must not be a string.")

        new_fields = []
        fields = to_key_val_list(data or {})
        files = to_key_val_list(files or {})

        for field, val in fields:
            if isinstance(val, basestring) or not hasattr(val, '__iter__'):
                val = [val]
            for v in val:
                if v is not None:
                    # Don't call str() on bytestrings: in Py3 it all goes wrong.
                    if not isinstance(v, bytes):
                        v = str(v)

                    new_fields.append(
                        (field.decode('utf-8') if isinstance(field, bytes) else field,
                         v.encode('utf-8') if isinstance(v, str) else v))

        for (k, v) in files:
            # support for explicit filename
            ft = None
            fh = None
            if isinstance(v, (tuple, list)):
                if len(v) == 2:
                    fn, fp = v
                elif len(v) == 3:
                    fn, fp, ft = v
                else:
                    fn, fp, ft, fh = v
            else:
                fn = guess_filename(v) or k
                fp = v
            if isinstance(fp, str):
                fp = StringIO(fp)
            if isinstance(fp, bytes):
                fp = BytesIO(fp)

            rf = RequestField(name=k, data=fp.read(),
                              filename=fn, headers=fh)
            rf.make_multipart(content_type=ft)
            new_fields.append(rf)

        body, content_type = encode_multipart_formdata(new_fields)

        return body, content_type


class RequestHooksMixin(object):
    def register_hook(self, event, hook):
        """Properly register a hook."""

        if event not in self.hooks:
            raise ValueError('Unsupported event specified, with event name "%s"' % (event))

        if isinstance(hook, collections.Callable):
            self.hooks[event].append(hook)
        elif hasattr(hook, '__iter__'):
            self.hooks[event].extend(h for h in hook if isinstance(h, collections.Callable))

    def deregister_hook(self, event, hook):
        """Deregister a previously registered hook.
        Returns True if the hook existed, False if not.
        """

        try:
            self.hooks[event].remove(hook)
            return True
        except ValueError:
            return False


class Request(RequestHooksMixin):
    """A user-created :class:`Request <Request>` object.

    Used to prepare a :class:`PreparedRequest <PreparedRequest>`, which is sent to the server.

    :param method: HTTP method to use.
    :param url: URL to send.
    :param headers: dictionary of headers to send.
    :param files: dictionary of {filename: fileobject} files to multipart upload.
    :param data: the body to attach the request. If a dictionary is provided, form-encoding will take place.
    :param params: dictionary of URL parameters to append to the URL.
    :param auth: Auth handler or (user, pass) tuple.
    :param cookies: dictionary or CookieJar of cookies to attach to this request.
    :param hooks: dictionary of callback hooks, for internal usage.

    Usage::

      >>> import requests
      >>> req = requests.Request('GET', 'http://httpbin.org/get')
      >>> req.prepare()
      <PreparedRequest [GET]>

    """
    def __init__(self,
        method=None,
        url=None,
        headers=None,
        files=None,
        data=None,
        params=None,
        auth=None,
        cookies=None,
        hooks=None):

        # Default empty dicts for dict params.
        data = [] if data is None else data
        files = [] if files is None else files
        headers = {} if headers is None else headers
        params = {} if params is None else params
        hooks = {} if hooks is None else hooks

        self.hooks = default_hooks()
        for (k, v) in list(hooks.items()):
            self.register_hook(event=k, hook=v)

        self.method = method
        self.url = url
        self.headers = headers
        self.files = files
        self.data = data
        self.params = params
        self.auth = auth
        self.cookies = cookies

    def __repr__(self):
        return '<Request [%s]>' % (self.method)

    def prepare(self):
        """Constructs a :class:`PreparedRequest <PreparedRequest>` for transmission and returns it."""
        p = PreparedRequest()
        p.prepare(
            method=self.method,
            url=self.url,
            headers=self.headers,
            files=self.files,
            data=self.data,
            params=self.params,
            auth=self.auth,
            cookies=self.cookies,
            hooks=self.hooks,
        )
        return p


class PreparedRequest(RequestEncodingMixin, RequestHooksMixin):
    """The fully mutable :class:`PreparedRequest <PreparedRequest>` object,
    containing the exact bytes that will be sent to the server.

    Generated from either a :class:`Request <Request>` object or manually.

    Usage::

      >>> import requests
      >>> req = requests.Request('GET', 'http://httpbin.org/get')
      >>> r = req.prepare()
      <PreparedRequest [GET]>

      >>> s = requests.Session()
      >>> s.send(r)
      <Response [200]>

    """

    def __init__(self):
        #: HTTP verb to send to the server.
        self.method = None
        #: HTTP URL to send the request to.
        self.url = None
        #: dictionary of HTTP headers.
        self.headers = None
        # The `CookieJar` used to create the Cookie header will be stored here
        # after prepare_cookies is called
        self._cookies = None
        #: request body to send to the server.
        self.body = None
        #: dictionary of callback hooks, for internal usage.
        self.hooks = default_hooks()

    def prepare(self, method=None, url=None, headers=None, files=None,
                data=None, params=None, auth=None, cookies=None, hooks=None):
        """Prepares the entire request with the given parameters."""

        self.prepare_method(method)
        self.prepare_url(url, params)
        self.prepare_headers(headers)
        self.prepare_cookies(cookies)
        self.prepare_body(data, files)
        self.prepare_auth(auth, url)
        # Note that prepare_auth must be last to enable authentication schemes
        # such as OAuth to work on a fully prepared request.

        # This MUST go after prepare_auth. Authenticators could add a hook
        self.prepare_hooks(hooks)

    def __repr__(self):
        return '<PreparedRequest [%s]>' % (self.method)

    def copy(self):
        p = PreparedRequest()
        p.method = self.method
        p.url = self.url
        p.headers = self.headers.copy()
        p._cookies = self._cookies.copy()
        p.body = self.body
        p.hooks = self.hooks
        return p

    def prepare_method(self, method):
        """Prepares the given HTTP method."""
        self.method = method
        if self.method is not None:
            self.method = self.method.upper()

    def prepare_url(self, url, params):
        """Prepares the given HTTP URL."""
        #: Accept objects that have string representations.
        try:
            url = unicode(url)
        except NameError:
            # We're on Python 3.
            url = str(url)
        except UnicodeDecodeError:
            pass

        # Don't do any URL preparation for oddball schemes
        if ':' in url and not url.lower().startswith('http'):
            self.url = url
            return

        # Support for unicode domain names and paths.
        scheme, auth, host, port, path, query, fragment = parse_url(url)

        if not scheme:
            raise MissingSchema("Invalid URL {0!r}: No schema supplied. "
                                "Perhaps you meant http://{0}?".format(url))

        if not host:
            raise InvalidURL("Invalid URL %r: No host supplied" % url)

        # Only want to apply IDNA to the hostname
        try:
            host = host.encode('idna').decode('utf-8')
        except UnicodeError:
            raise InvalidURL('URL has an invalid label.')

        # Carefully reconstruct the network location
        netloc = auth or ''
        if netloc:
            netloc += '@'
        netloc += host
        if port:
            netloc += ':' + str(port)

        # Bare domains aren't valid URLs.
        if not path:
            path = '/'

        if is_py2:
            if isinstance(scheme, str):
                scheme = scheme.encode('utf-8')
            if isinstance(netloc, str):
                netloc = netloc.encode('utf-8')
            if isinstance(path, str):
                path = path.encode('utf-8')
            if isinstance(query, str):
                query = query.encode('utf-8')
            if isinstance(fragment, str):
                fragment = fragment.encode('utf-8')

        enc_params = self._encode_params(params)
        if enc_params:
            if query:
                query = '%s&%s' % (query, enc_params)
            else:
                query = enc_params

        url = requote_uri(urlunparse([scheme, netloc, path, None, query, fragment]))
        self.url = url

    def prepare_headers(self, headers):
        """Prepares the given HTTP headers."""

        if headers:
            self.headers = CaseInsensitiveDict((to_native_string(name), value) for name, value in headers.items())
        else:
            self.headers = CaseInsensitiveDict()

    def prepare_body(self, data, files):
        """Prepares the given HTTP body data."""

        # Check if file, fo, generator, iterator.
        # If not, run through normal process.

        # Nottin' on you.
        body = None
        content_type = None
        length = None

        is_stream = all([
            hasattr(data, '__iter__'),
            not isinstance(data, (basestring, list, tuple, dict))
        ])

        try:
            length = super_len(data)
        except (TypeError, AttributeError, UnsupportedOperation):
            length = None

        if is_stream:
            body = data

            if files:
                raise NotImplementedError('Streamed bodies and files are mutually exclusive.')

            if length is not None:
                self.headers['Content-Length'] = builtin_str(length)
            else:
                self.headers['Transfer-Encoding'] = 'chunked'
        else:
            # Multi-part file uploads.
            if files:
                (body, content_type) = self._encode_files(files, data)
            else:
                if data:
                    body = self._encode_params(data)
                    if isinstance(data, str) or isinstance(data, builtin_str) or hasattr(data, 'read'):
                        content_type = None
                    else:
                        content_type = 'application/x-www-form-urlencoded'

            self.prepare_content_length(body)

            # Add content-type if it wasn't explicitly provided.
            if (content_type) and (not 'content-type' in self.headers):
                self.headers['Content-Type'] = content_type

        self.body = body

    def prepare_content_length(self, body):
        if hasattr(body, 'seek') and hasattr(body, 'tell'):
            body.seek(0, 2)
            self.headers['Content-Length'] = builtin_str(body.tell())
            body.seek(0, 0)
        elif body is not None:
            l = super_len(body)
            if l:
                self.headers['Content-Length'] = builtin_str(l)
        elif self.method not in ('GET', 'HEAD'):
            self.headers['Content-Length'] = '0'

    def prepare_auth(self, auth, url=''):
        """Prepares the given HTTP auth data."""

        # If no Auth is explicitly provided, extract it from the URL first.
        if auth is None:
            url_auth = get_auth_from_url(self.url)
            auth = url_auth if any(url_auth) else None

        if auth:
            if isinstance(auth, tuple) and len(auth) == 2:
                # special-case basic HTTP auth
                auth = HTTPBasicAuth(*auth)

            # Allow auth to make its changes.
            r = auth(self)

            # Update self to reflect the auth changes.
            self.__dict__.update(r.__dict__)

            # Recompute Content-Length
            self.prepare_content_length(self.body)

    def prepare_cookies(self, cookies):
        """Prepares the given HTTP cookie data."""

        if isinstance(cookies, cookielib.CookieJar):
            self._cookies = cookies
        else:
            self._cookies = cookiejar_from_dict(cookies)

        cookie_header = get_cookie_header(self._cookies, self)
        if cookie_header is not None:
            self.headers['Cookie'] = cookie_header

    def prepare_hooks(self, hooks):
        """Prepares the given hooks."""
        for event in hooks:
            self.register_hook(event, hooks[event])


class Response(object):
    """The :class:`Response <Response>` object, which contains a
    server's response to an HTTP request.
    """

    __attrs__ = [
        '_content',
        'status_code',
        'headers',
        'url',
        'history',
        'encoding',
        'reason',
        'cookies',
        'elapsed',
        'request',
    ]

    def __init__(self):
        super(Response, self).__init__()

        self._content = False
        self._content_consumed = False

        #: Integer Code of responded HTTP Status, e.g. 404 or 200.
        self.status_code = None

        #: Case-insensitive Dictionary of Response Headers.
        #: For example, ``headers['content-encoding']`` will return the
        #: value of a ``'Content-Encoding'`` response header.
        self.headers = CaseInsensitiveDict()

        #: File-like object representation of response (for advanced usage).
        #: Use of ``raw`` requires that ``stream=True`` be set on the request.
        # This requirement does not apply for use internally to Requests.
        self.raw = None

        #: Final URL location of Response.
        self.url = None

        #: Encoding to decode with when accessing r.text.
        self.encoding = None

        #: A list of :class:`Response <Response>` objects from
        #: the history of the Request. Any redirect responses will end
        #: up here. The list is sorted from the oldest to the most recent request.
        self.history = []

        #: Textual reason of responded HTTP Status, e.g. "Not Found" or "OK".
        self.reason = None

        #: A CookieJar of Cookies the server sent back.
        self.cookies = cookiejar_from_dict({})

        #: The amount of time elapsed between sending the request
        #: and the arrival of the response (as a timedelta)
        self.elapsed = datetime.timedelta(0)

    def __getstate__(self):
        # Consume everything; accessing the content attribute makes
        # sure the content has been fully read.
        if not self._content_consumed:
            self.content

        return dict(
            (attr, getattr(self, attr, None))
            for attr in self.__attrs__
        )

    def __setstate__(self, state):
        for name, value in state.items():
            setattr(self, name, value)

        # pickled objects do not have .raw
        setattr(self, '_content_consumed', True)
        setattr(self, 'raw', None)

    def __repr__(self):
        return '<Response [%s]>' % (self.status_code)

    def __bool__(self):
        """Returns true if :attr:`status_code` is 'OK'."""
        return self.ok

    def __nonzero__(self):
        """Returns true if :attr:`status_code` is 'OK'."""
        return self.ok

    def __iter__(self):
        """Allows you to use a response as an iterator."""
        return self.iter_content(128)

    @property
    def ok(self):
        try:
            self.raise_for_status()
        except RequestException:
            return False
        return True

    @property
    def is_redirect(self):
        """True if this Response is a well-formed HTTP redirect that could have
        been processed automatically (by :meth:`Session.resolve_redirects`).
        """
        return ('location' in self.headers and self.status_code in REDIRECT_STATI)

    @property
    def apparent_encoding(self):
        """The apparent encoding, provided by the chardet library"""
        return chardet.detect(self.content)['encoding']

    def iter_content(self, chunk_size=1, decode_unicode=False):
        """Iterates over the response data.  When stream=True is set on the
        request, this avoids reading the content at once into memory for
        large responses.  The chunk size is the number of bytes it should
        read into memory.  This is not necessarily the length of each item
        returned as decoding can take place.

        If decode_unicode is True, content will be decoded using the best
        available encoding based on the response.
        """
        def generate():
            try:
                # Special case for urllib3.
                try:
                    for chunk in self.raw.stream(chunk_size, decode_content=True):
                        yield chunk
                except IncompleteRead as e:
                    raise ChunkedEncodingError(e)
                except DecodeError as e:
                    raise ContentDecodingError(e)
            except AttributeError:
                # Standard file-like object.
                while True:
                    chunk = self.raw.read(chunk_size)
                    if not chunk:
                        break
                    yield chunk

            self._content_consumed = True

        # simulate reading small chunks of the content
        reused_chunks = iter_slices(self._content, chunk_size)

        stream_chunks = generate()

        chunks = reused_chunks if self._content_consumed else stream_chunks

        if decode_unicode:
            chunks = stream_decode_response_unicode(chunks, self)

        return chunks

    def iter_lines(self, chunk_size=ITER_CHUNK_SIZE, decode_unicode=None):
        """Iterates over the response data, one line at a time.  When
        stream=True is set on the request, this avoids reading the
        content at once into memory for large responses.
        """

        pending = None

        for chunk in self.iter_content(chunk_size=chunk_size, decode_unicode=decode_unicode):

            if pending is not None:
                chunk = pending + chunk
            lines = chunk.splitlines()

            if lines and lines[-1] and chunk and lines[-1][-1] == chunk[-1]:
                pending = lines.pop()
            else:
                pending = None

            for line in lines:
                yield line

        if pending is not None:
            yield pending

    @property
    def content(self):
        """Content of the response, in bytes."""

        if self._content is False:
            # Read the contents.
            try:
                if self._content_consumed:
                    raise RuntimeError(
                        'The content for this response was already consumed')

                if self.status_code == 0:
                    self._content = None
                else:
                    self._content = bytes().join(self.iter_content(CONTENT_CHUNK_SIZE)) or bytes()

            except AttributeError:
                self._content = None

        self._content_consumed = True
        # don't need to release the connection; that's been handled by urllib3
        # since we exhausted the data.
        return self._content

    @property
    def text(self):
        """Content of the response, in unicode.

        If Response.encoding is None, encoding will be guessed using
        ``chardet``.

        The encoding of the response content is determined based solely on HTTP
        headers, following RFC 2616 to the letter. If you can take advantage of
        non-HTTP knowledge to make a better guess at the encoding, you should
        set ``r.encoding`` appropriately before accessing this property.
        """

        # Try charset from content-type
        content = None
        encoding = self.encoding

        if not self.content:
            return str('')

        # Fallback to auto-detected encoding.
        if self.encoding is None:
            encoding = self.apparent_encoding

        # Decode unicode from given encoding.
        try:
            content = str(self.content, encoding, errors='replace')
        except (LookupError, TypeError):
            # A LookupError is raised if the encoding was not found which could
            # indicate a misspelling or similar mistake.
            #
            # A TypeError can be raised if encoding is None
            #
            # So we try blindly encoding.
            content = str(self.content, errors='replace')

        return content

    def json(self, **kwargs):
        """Returns the json-encoded content of a response, if any.

        :param \*\*kwargs: Optional arguments that ``json.loads`` takes.
        """

        if not self.encoding and len(self.content) > 3:
            # No encoding set. JSON RFC 4627 section 3 states we should expect
            # UTF-8, -16 or -32. Detect which one to use; If the detection or
            # decoding fails, fall back to `self.text` (using chardet to make
            # a best guess).
            encoding = guess_json_utf(self.content)
            if encoding is not None:
                try:
                    return json.loads(self.content.decode(encoding), **kwargs)
                except UnicodeDecodeError:
                    # Wrong UTF codec detected; usually because it's not UTF-8
                    # but some other 8-bit codec.  This is an RFC violation,
                    # and the server didn't bother to tell us what codec *was*
                    # used.
                    pass
        return json.loads(self.text, **kwargs)

    @property
    def links(self):
        """Returns the parsed header links of the response, if any."""

        header = self.headers.get('link')

        # l = MultiDict()
        l = {}

        if header:
            links = parse_header_links(header)

            for link in links:
                key = link.get('rel') or link.get('url')
                l[key] = link

        return l

    def raise_for_status(self):
        """Raises stored :class:`HTTPError`, if one occurred."""

        http_error_msg = ''

        if 400 <= self.status_code < 500:
            http_error_msg = '%s Client Error: %s' % (self.status_code, self.reason)

        elif 500 <= self.status_code < 600:
            http_error_msg = '%s Server Error: %s' % (self.status_code, self.reason)

        if http_error_msg:
            raise HTTPError(http_error_msg, response=self)

    def close(self):
        """Releases the connection back to the pool. Once this method has been
        called the underlying ``raw`` object must not be accessed again.

        *Note: Should not normally need to be called explicitly.*
        """
        return self.raw.release_conn()

########NEW FILE########
__FILENAME__ = big5freq
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# Big5 frequency table
# by Taiwan's Mandarin Promotion Council
# <http://www.edu.tw:81/mandr/>
#
# 128  --> 0.42261
# 256  --> 0.57851
# 512  --> 0.74851
# 1024 --> 0.89384
# 2048 --> 0.97583
#
# Ideal Distribution Ratio = 0.74851/(1-0.74851) =2.98
# Random Distribution Ration = 512/(5401-512)=0.105
#
# Typical Distribution Ratio about 25% of Ideal one, still much higher than RDR

BIG5_TYPICAL_DISTRIBUTION_RATIO = 0.75

#Char to FreqOrder table
BIG5_TABLE_SIZE = 5376

Big5CharToFreqOrder = (
   1,1801,1506, 255,1431, 198,   9,  82,   6,5008, 177, 202,3681,1256,2821, 110, #   16
3814,  33,3274, 261,  76,  44,2114,  16,2946,2187,1176, 659,3971,  26,3451,2653, #   32
1198,3972,3350,4202, 410,2215, 302, 590, 361,1964,   8, 204,  58,4510,5009,1932, #   48
  63,5010,5011, 317,1614,  75, 222, 159,4203,2417,1480,5012,3555,3091, 224,2822, #   64
3682,   3,  10,3973,1471,  29,2787,1135,2866,1940, 873, 130,3275,1123, 312,5013, #   80
4511,2052, 507, 252, 682,5014, 142,1915, 124, 206,2947,  34,3556,3204,  64, 604, #   96
5015,2501,1977,1978, 155,1991, 645, 641,1606,5016,3452, 337,  72, 406,5017,  80, #  112
 630, 238,3205,1509, 263, 939,1092,2654, 756,1440,1094,3453, 449,  69,2987, 591, #  128
 179,2096, 471, 115,2035,1844,  60,  50,2988, 134, 806,1869, 734,2036,3454, 180, #  144
 995,1607, 156, 537,2907, 688,5018, 319,1305, 779,2145, 514,2379, 298,4512, 359, #  160
2502,  90,2716,1338, 663,  11, 906,1099,2553,  20,2441, 182, 532,1716,5019, 732, #  176
1376,4204,1311,1420,3206,  25,2317,1056, 113, 399, 382,1950, 242,3455,2474, 529, #  192
3276, 475,1447,3683,5020, 117,  21, 656, 810,1297,2300,2334,3557,5021, 126,4205, #  208
 706, 456, 150, 613,4513,  71,1118,2037,4206, 145,3092,  85, 835, 486,2115,1246, #  224
1426, 428, 727,1285,1015, 800, 106, 623, 303,1281,5022,2128,2359, 347,3815, 221, #  240
3558,3135,5023,1956,1153,4207,  83, 296,1199,3093, 192, 624,  93,5024, 822,1898, #  256
2823,3136, 795,2065, 991,1554,1542,1592,  27,  43,2867, 859, 139,1456, 860,4514, #  272
 437, 712,3974, 164,2397,3137, 695, 211,3037,2097, 195,3975,1608,3559,3560,3684, #  288
3976, 234, 811,2989,2098,3977,2233,1441,3561,1615,2380, 668,2077,1638, 305, 228, #  304
1664,4515, 467, 415,5025, 262,2099,1593, 239, 108, 300, 200,1033, 512,1247,2078, #  320
5026,5027,2176,3207,3685,2682, 593, 845,1062,3277,  88,1723,2038,3978,1951, 212, #  336
 266, 152, 149, 468,1899,4208,4516,  77, 187,5028,3038,  37,   5,2990,5029,3979, #  352
5030,5031,  39,2524,4517,2908,3208,2079,  55, 148,  74,4518, 545, 483,1474,1029, #  368
1665, 217,1870,1531,3138,1104,2655,4209,  24, 172,3562, 900,3980,3563,3564,4519, #  384
  32,1408,2824,1312, 329, 487,2360,2251,2717, 784,2683,   4,3039,3351,1427,1789, #  400
 188, 109, 499,5032,3686,1717,1790, 888,1217,3040,4520,5033,3565,5034,3352,1520, #  416
3687,3981, 196,1034, 775,5035,5036, 929,1816, 249, 439,  38,5037,1063,5038, 794, #  432
3982,1435,2301,  46, 178,3278,2066,5039,2381,5040, 214,1709,4521, 804,  35, 707, #  448
 324,3688,1601,2554, 140, 459,4210,5041,5042,1365, 839, 272, 978,2262,2580,3456, #  464
2129,1363,3689,1423, 697, 100,3094,  48,  70,1231, 495,3139,2196,5043,1294,5044, #  480
2080, 462, 586,1042,3279, 853, 256, 988, 185,2382,3457,1698, 434,1084,5045,3458, #  496
 314,2625,2788,4522,2335,2336, 569,2285, 637,1817,2525, 757,1162,1879,1616,3459, #  512
 287,1577,2116, 768,4523,1671,2868,3566,2526,1321,3816, 909,2418,5046,4211, 933, #  528
3817,4212,2053,2361,1222,4524, 765,2419,1322, 786,4525,5047,1920,1462,1677,2909, #  544
1699,5048,4526,1424,2442,3140,3690,2600,3353,1775,1941,3460,3983,4213, 309,1369, #  560
1130,2825, 364,2234,1653,1299,3984,3567,3985,3986,2656, 525,1085,3041, 902,2001, #  576
1475, 964,4527, 421,1845,1415,1057,2286, 940,1364,3141, 376,4528,4529,1381,   7, #  592
2527, 983,2383, 336,1710,2684,1846, 321,3461, 559,1131,3042,2752,1809,1132,1313, #  608
 265,1481,1858,5049, 352,1203,2826,3280, 167,1089, 420,2827, 776, 792,1724,3568, #  624
4214,2443,3281,5050,4215,5051, 446, 229, 333,2753, 901,3818,1200,1557,4530,2657, #  640
1921, 395,2754,2685,3819,4216,1836, 125, 916,3209,2626,4531,5052,5053,3820,5054, #  656
5055,5056,4532,3142,3691,1133,2555,1757,3462,1510,2318,1409,3569,5057,2146, 438, #  672
2601,2910,2384,3354,1068, 958,3043, 461, 311,2869,2686,4217,1916,3210,4218,1979, #  688
 383, 750,2755,2627,4219, 274, 539, 385,1278,1442,5058,1154,1965, 384, 561, 210, #  704
  98,1295,2556,3570,5059,1711,2420,1482,3463,3987,2911,1257, 129,5060,3821, 642, #  720
 523,2789,2790,2658,5061, 141,2235,1333,  68, 176, 441, 876, 907,4220, 603,2602, #  736
 710, 171,3464, 404, 549,  18,3143,2398,1410,3692,1666,5062,3571,4533,2912,4534, #  752
5063,2991, 368,5064, 146, 366,  99, 871,3693,1543, 748, 807,1586,1185,  22,2263, #  768
 379,3822,3211,5065,3212, 505,1942,2628,1992,1382,2319,5066, 380,2362, 218, 702, #  784
1818,1248,3465,3044,3572,3355,3282,5067,2992,3694, 930,3283,3823,5068,  59,5069, #  800
 585, 601,4221, 497,3466,1112,1314,4535,1802,5070,1223,1472,2177,5071, 749,1837, #  816
 690,1900,3824,1773,3988,1476, 429,1043,1791,2236,2117, 917,4222, 447,1086,1629, #  832
5072, 556,5073,5074,2021,1654, 844,1090, 105, 550, 966,1758,2828,1008,1783, 686, #  848
1095,5075,2287, 793,1602,5076,3573,2603,4536,4223,2948,2302,4537,3825, 980,2503, #  864
 544, 353, 527,4538, 908,2687,2913,5077, 381,2629,1943,1348,5078,1341,1252, 560, #  880
3095,5079,3467,2870,5080,2054, 973, 886,2081, 143,4539,5081,5082, 157,3989, 496, #  896
4224,  57, 840, 540,2039,4540,4541,3468,2118,1445, 970,2264,1748,1966,2082,4225, #  912
3144,1234,1776,3284,2829,3695, 773,1206,2130,1066,2040,1326,3990,1738,1725,4226, #  928
 279,3145,  51,1544,2604, 423,1578,2131,2067, 173,4542,1880,5083,5084,1583, 264, #  944
 610,3696,4543,2444, 280, 154,5085,5086,5087,1739, 338,1282,3096, 693,2871,1411, #  960
1074,3826,2445,5088,4544,5089,5090,1240, 952,2399,5091,2914,1538,2688, 685,1483, #  976
4227,2475,1436, 953,4228,2055,4545, 671,2400,  79,4229,2446,3285, 608, 567,2689, #  992
3469,4230,4231,1691, 393,1261,1792,2401,5092,4546,5093,5094,5095,5096,1383,1672, # 1008
3827,3213,1464, 522,1119, 661,1150, 216, 675,4547,3991,1432,3574, 609,4548,2690, # 1024
2402,5097,5098,5099,4232,3045,   0,5100,2476, 315, 231,2447, 301,3356,4549,2385, # 1040
5101, 233,4233,3697,1819,4550,4551,5102,  96,1777,1315,2083,5103, 257,5104,1810, # 1056
3698,2718,1139,1820,4234,2022,1124,2164,2791,1778,2659,5105,3097, 363,1655,3214, # 1072
5106,2993,5107,5108,5109,3992,1567,3993, 718, 103,3215, 849,1443, 341,3357,2949, # 1088
1484,5110,1712, 127,  67, 339,4235,2403, 679,1412, 821,5111,5112, 834, 738, 351, # 1104
2994,2147, 846, 235,1497,1881, 418,1993,3828,2719, 186,1100,2148,2756,3575,1545, # 1120
1355,2950,2872,1377, 583,3994,4236,2581,2995,5113,1298,3699,1078,2557,3700,2363, # 1136
  78,3829,3830, 267,1289,2100,2002,1594,4237, 348, 369,1274,2197,2178,1838,4552, # 1152
1821,2830,3701,2757,2288,2003,4553,2951,2758, 144,3358, 882,4554,3995,2759,3470, # 1168
4555,2915,5114,4238,1726, 320,5115,3996,3046, 788,2996,5116,2831,1774,1327,2873, # 1184
3997,2832,5117,1306,4556,2004,1700,3831,3576,2364,2660, 787,2023, 506, 824,3702, # 1200
 534, 323,4557,1044,3359,2024,1901, 946,3471,5118,1779,1500,1678,5119,1882,4558, # 1216
 165, 243,4559,3703,2528, 123, 683,4239, 764,4560,  36,3998,1793, 589,2916, 816, # 1232
 626,1667,3047,2237,1639,1555,1622,3832,3999,5120,4000,2874,1370,1228,1933, 891, # 1248
2084,2917, 304,4240,5121, 292,2997,2720,3577, 691,2101,4241,1115,4561, 118, 662, # 1264
5122, 611,1156, 854,2386,1316,2875,   2, 386, 515,2918,5123,5124,3286, 868,2238, # 1280
1486, 855,2661, 785,2216,3048,5125,1040,3216,3578,5126,3146, 448,5127,1525,5128, # 1296
2165,4562,5129,3833,5130,4242,2833,3579,3147, 503, 818,4001,3148,1568, 814, 676, # 1312
1444, 306,1749,5131,3834,1416,1030, 197,1428, 805,2834,1501,4563,5132,5133,5134, # 1328
1994,5135,4564,5136,5137,2198,  13,2792,3704,2998,3149,1229,1917,5138,3835,2132, # 1344
5139,4243,4565,2404,3580,5140,2217,1511,1727,1120,5141,5142, 646,3836,2448, 307, # 1360
5143,5144,1595,3217,5145,5146,5147,3705,1113,1356,4002,1465,2529,2530,5148, 519, # 1376
5149, 128,2133,  92,2289,1980,5150,4003,1512, 342,3150,2199,5151,2793,2218,1981, # 1392
3360,4244, 290,1656,1317, 789, 827,2365,5152,3837,4566, 562, 581,4004,5153, 401, # 1408
4567,2252,  94,4568,5154,1399,2794,5155,1463,2025,4569,3218,1944,5156, 828,1105, # 1424
4245,1262,1394,5157,4246, 605,4570,5158,1784,2876,5159,2835, 819,2102, 578,2200, # 1440
2952,5160,1502, 436,3287,4247,3288,2836,4005,2919,3472,3473,5161,2721,2320,5162, # 1456
5163,2337,2068,  23,4571, 193, 826,3838,2103, 699,1630,4248,3098, 390,1794,1064, # 1472
3581,5164,1579,3099,3100,1400,5165,4249,1839,1640,2877,5166,4572,4573, 137,4250, # 1488
 598,3101,1967, 780, 104, 974,2953,5167, 278, 899, 253, 402, 572, 504, 493,1339, # 1504
5168,4006,1275,4574,2582,2558,5169,3706,3049,3102,2253, 565,1334,2722, 863,  41, # 1520
5170,5171,4575,5172,1657,2338,  19, 463,2760,4251, 606,5173,2999,3289,1087,2085, # 1536
1323,2662,3000,5174,1631,1623,1750,4252,2691,5175,2878, 791,2723,2663,2339, 232, # 1552
2421,5176,3001,1498,5177,2664,2630, 755,1366,3707,3290,3151,2026,1609, 119,1918, # 1568
3474, 862,1026,4253,5178,4007,3839,4576,4008,4577,2265,1952,2477,5179,1125, 817, # 1584
4254,4255,4009,1513,1766,2041,1487,4256,3050,3291,2837,3840,3152,5180,5181,1507, # 1600
5182,2692, 733,  40,1632,1106,2879, 345,4257, 841,2531, 230,4578,3002,1847,3292, # 1616
3475,5183,1263, 986,3476,5184, 735, 879, 254,1137, 857, 622,1300,1180,1388,1562, # 1632
4010,4011,2954, 967,2761,2665,1349, 592,2134,1692,3361,3003,1995,4258,1679,4012, # 1648
1902,2188,5185, 739,3708,2724,1296,1290,5186,4259,2201,2202,1922,1563,2605,2559, # 1664
1871,2762,3004,5187, 435,5188, 343,1108, 596,  17,1751,4579,2239,3477,3709,5189, # 1680
4580, 294,3582,2955,1693, 477, 979, 281,2042,3583, 643,2043,3710,2631,2795,2266, # 1696
1031,2340,2135,2303,3584,4581, 367,1249,2560,5190,3585,5191,4582,1283,3362,2005, # 1712
 240,1762,3363,4583,4584, 836,1069,3153, 474,5192,2149,2532, 268,3586,5193,3219, # 1728
1521,1284,5194,1658,1546,4260,5195,3587,3588,5196,4261,3364,2693,1685,4262, 961, # 1744
1673,2632, 190,2006,2203,3841,4585,4586,5197, 570,2504,3711,1490,5198,4587,2633, # 1760
3293,1957,4588, 584,1514, 396,1045,1945,5199,4589,1968,2449,5200,5201,4590,4013, # 1776
 619,5202,3154,3294, 215,2007,2796,2561,3220,4591,3221,4592, 763,4263,3842,4593, # 1792
5203,5204,1958,1767,2956,3365,3712,1174, 452,1477,4594,3366,3155,5205,2838,1253, # 1808
2387,2189,1091,2290,4264, 492,5206, 638,1169,1825,2136,1752,4014, 648, 926,1021, # 1824
1324,4595, 520,4596, 997, 847,1007, 892,4597,3843,2267,1872,3713,2405,1785,4598, # 1840
1953,2957,3103,3222,1728,4265,2044,3714,4599,2008,1701,3156,1551,  30,2268,4266, # 1856
5207,2027,4600,3589,5208, 501,5209,4267, 594,3478,2166,1822,3590,3479,3591,3223, # 1872
 829,2839,4268,5210,1680,3157,1225,4269,5211,3295,4601,4270,3158,2341,5212,4602, # 1888
4271,5213,4015,4016,5214,1848,2388,2606,3367,5215,4603, 374,4017, 652,4272,4273, # 1904
 375,1140, 798,5216,5217,5218,2366,4604,2269, 546,1659, 138,3051,2450,4605,5219, # 1920
2254, 612,1849, 910, 796,3844,1740,1371, 825,3845,3846,5220,2920,2562,5221, 692, # 1936
 444,3052,2634, 801,4606,4274,5222,1491, 244,1053,3053,4275,4276, 340,5223,4018, # 1952
1041,3005, 293,1168,  87,1357,5224,1539, 959,5225,2240, 721, 694,4277,3847, 219, # 1968
1478, 644,1417,3368,2666,1413,1401,1335,1389,4019,5226,5227,3006,2367,3159,1826, # 1984
 730,1515, 184,2840,  66,4607,5228,1660,2958, 246,3369, 378,1457, 226,3480, 975, # 2000
4020,2959,1264,3592, 674, 696,5229, 163,5230,1141,2422,2167, 713,3593,3370,4608, # 2016
4021,5231,5232,1186,  15,5233,1079,1070,5234,1522,3224,3594, 276,1050,2725, 758, # 2032
1126, 653,2960,3296,5235,2342, 889,3595,4022,3104,3007, 903,1250,4609,4023,3481, # 2048
3596,1342,1681,1718, 766,3297, 286,  89,2961,3715,5236,1713,5237,2607,3371,3008, # 2064
5238,2962,2219,3225,2880,5239,4610,2505,2533, 181, 387,1075,4024, 731,2190,3372, # 2080
5240,3298, 310, 313,3482,2304, 770,4278,  54,3054, 189,4611,3105,3848,4025,5241, # 2096
1230,1617,1850, 355,3597,4279,4612,3373, 111,4280,3716,1350,3160,3483,3055,4281, # 2112
2150,3299,3598,5242,2797,4026,4027,3009, 722,2009,5243,1071, 247,1207,2343,2478, # 2128
1378,4613,2010, 864,1437,1214,4614, 373,3849,1142,2220, 667,4615, 442,2763,2563, # 2144
3850,4028,1969,4282,3300,1840, 837, 170,1107, 934,1336,1883,5244,5245,2119,4283, # 2160
2841, 743,1569,5246,4616,4284, 582,2389,1418,3484,5247,1803,5248, 357,1395,1729, # 2176
3717,3301,2423,1564,2241,5249,3106,3851,1633,4617,1114,2086,4285,1532,5250, 482, # 2192
2451,4618,5251,5252,1492, 833,1466,5253,2726,3599,1641,2842,5254,1526,1272,3718, # 2208
4286,1686,1795, 416,2564,1903,1954,1804,5255,3852,2798,3853,1159,2321,5256,2881, # 2224
4619,1610,1584,3056,2424,2764, 443,3302,1163,3161,5257,5258,4029,5259,4287,2506, # 2240
3057,4620,4030,3162,2104,1647,3600,2011,1873,4288,5260,4289, 431,3485,5261, 250, # 2256
  97,  81,4290,5262,1648,1851,1558, 160, 848,5263, 866, 740,1694,5264,2204,2843, # 2272
3226,4291,4621,3719,1687, 950,2479, 426, 469,3227,3720,3721,4031,5265,5266,1188, # 2288
 424,1996, 861,3601,4292,3854,2205,2694, 168,1235,3602,4293,5267,2087,1674,4622, # 2304
3374,3303, 220,2565,1009,5268,3855, 670,3010, 332,1208, 717,5269,5270,3603,2452, # 2320
4032,3375,5271, 513,5272,1209,2882,3376,3163,4623,1080,5273,5274,5275,5276,2534, # 2336
3722,3604, 815,1587,4033,4034,5277,3605,3486,3856,1254,4624,1328,3058,1390,4035, # 2352
1741,4036,3857,4037,5278, 236,3858,2453,3304,5279,5280,3723,3859,1273,3860,4625, # 2368
5281, 308,5282,4626, 245,4627,1852,2480,1307,2583, 430, 715,2137,2454,5283, 270, # 2384
 199,2883,4038,5284,3606,2727,1753, 761,1754, 725,1661,1841,4628,3487,3724,5285, # 2400
5286, 587,  14,3305, 227,2608, 326, 480,2270, 943,2765,3607, 291, 650,1884,5287, # 2416
1702,1226, 102,1547,  62,3488, 904,4629,3489,1164,4294,5288,5289,1224,1548,2766, # 2432
 391, 498,1493,5290,1386,1419,5291,2056,1177,4630, 813, 880,1081,2368, 566,1145, # 2448
4631,2291,1001,1035,2566,2609,2242, 394,1286,5292,5293,2069,5294,  86,1494,1730, # 2464
4039, 491,1588, 745, 897,2963, 843,3377,4040,2767,2884,3306,1768, 998,2221,2070, # 2480
 397,1827,1195,1970,3725,3011,3378, 284,5295,3861,2507,2138,2120,1904,5296,4041, # 2496
2151,4042,4295,1036,3490,1905, 114,2567,4296, 209,1527,5297,5298,2964,2844,2635, # 2512
2390,2728,3164, 812,2568,5299,3307,5300,1559, 737,1885,3726,1210, 885,  28,2695, # 2528
3608,3862,5301,4297,1004,1780,4632,5302, 346,1982,2222,2696,4633,3863,1742, 797, # 2544
1642,4043,1934,1072,1384,2152, 896,4044,3308,3727,3228,2885,3609,5303,2569,1959, # 2560
4634,2455,1786,5304,5305,5306,4045,4298,1005,1308,3728,4299,2729,4635,4636,1528, # 2576
2610, 161,1178,4300,1983, 987,4637,1101,4301, 631,4046,1157,3229,2425,1343,1241, # 2592
1016,2243,2570, 372, 877,2344,2508,1160, 555,1935, 911,4047,5307, 466,1170, 169, # 2608
1051,2921,2697,3729,2481,3012,1182,2012,2571,1251,2636,5308, 992,2345,3491,1540, # 2624
2730,1201,2071,2406,1997,2482,5309,4638, 528,1923,2191,1503,1874,1570,2369,3379, # 2640
3309,5310, 557,1073,5311,1828,3492,2088,2271,3165,3059,3107, 767,3108,2799,4639, # 2656
1006,4302,4640,2346,1267,2179,3730,3230, 778,4048,3231,2731,1597,2667,5312,4641, # 2672
5313,3493,5314,5315,5316,3310,2698,1433,3311, 131,  95,1504,4049, 723,4303,3166, # 2688
1842,3610,2768,2192,4050,2028,2105,3731,5317,3013,4051,1218,5318,3380,3232,4052, # 2704
4304,2584, 248,1634,3864, 912,5319,2845,3732,3060,3865, 654,  53,5320,3014,5321, # 2720
1688,4642, 777,3494,1032,4053,1425,5322, 191, 820,2121,2846, 971,4643, 931,3233, # 2736
 135, 664, 783,3866,1998, 772,2922,1936,4054,3867,4644,2923,3234, 282,2732, 640, # 2752
1372,3495,1127, 922, 325,3381,5323,5324, 711,2045,5325,5326,4055,2223,2800,1937, # 2768
4056,3382,2224,2255,3868,2305,5327,4645,3869,1258,3312,4057,3235,2139,2965,4058, # 2784
4059,5328,2225, 258,3236,4646, 101,1227,5329,3313,1755,5330,1391,3314,5331,2924, # 2800
2057, 893,5332,5333,5334,1402,4305,2347,5335,5336,3237,3611,5337,5338, 878,1325, # 2816
1781,2801,4647, 259,1385,2585, 744,1183,2272,4648,5339,4060,2509,5340, 684,1024, # 2832
4306,5341, 472,3612,3496,1165,3315,4061,4062, 322,2153, 881, 455,1695,1152,1340, # 2848
 660, 554,2154,4649,1058,4650,4307, 830,1065,3383,4063,4651,1924,5342,1703,1919, # 2864
5343, 932,2273, 122,5344,4652, 947, 677,5345,3870,2637, 297,1906,1925,2274,4653, # 2880
2322,3316,5346,5347,4308,5348,4309,  84,4310, 112, 989,5349, 547,1059,4064, 701, # 2896
3613,1019,5350,4311,5351,3497, 942, 639, 457,2306,2456, 993,2966, 407, 851, 494, # 2912
4654,3384, 927,5352,1237,5353,2426,3385, 573,4312, 680, 921,2925,1279,1875, 285, # 2928
 790,1448,1984, 719,2168,5354,5355,4655,4065,4066,1649,5356,1541, 563,5357,1077, # 2944
5358,3386,3061,3498, 511,3015,4067,4068,3733,4069,1268,2572,3387,3238,4656,4657, # 2960
5359, 535,1048,1276,1189,2926,2029,3167,1438,1373,2847,2967,1134,2013,5360,4313, # 2976
1238,2586,3109,1259,5361, 700,5362,2968,3168,3734,4314,5363,4315,1146,1876,1907, # 2992
4658,2611,4070, 781,2427, 132,1589, 203, 147, 273,2802,2407, 898,1787,2155,4071, # 3008
4072,5364,3871,2803,5365,5366,4659,4660,5367,3239,5368,1635,3872, 965,5369,1805, # 3024
2699,1516,3614,1121,1082,1329,3317,4073,1449,3873,  65,1128,2848,2927,2769,1590, # 3040
3874,5370,5371,  12,2668,  45, 976,2587,3169,4661, 517,2535,1013,1037,3240,5372, # 3056
3875,2849,5373,3876,5374,3499,5375,2612, 614,1999,2323,3877,3110,2733,2638,5376, # 3072
2588,4316, 599,1269,5377,1811,3735,5378,2700,3111, 759,1060, 489,1806,3388,3318, # 3088
1358,5379,5380,2391,1387,1215,2639,2256, 490,5381,5382,4317,1759,2392,2348,5383, # 3104
4662,3878,1908,4074,2640,1807,3241,4663,3500,3319,2770,2349, 874,5384,5385,3501, # 3120
3736,1859,  91,2928,3737,3062,3879,4664,5386,3170,4075,2669,5387,3502,1202,1403, # 3136
3880,2969,2536,1517,2510,4665,3503,2511,5388,4666,5389,2701,1886,1495,1731,4076, # 3152
2370,4667,5390,2030,5391,5392,4077,2702,1216, 237,2589,4318,2324,4078,3881,4668, # 3168
4669,2703,3615,3504, 445,4670,5393,5394,5395,5396,2771,  61,4079,3738,1823,4080, # 3184
5397, 687,2046, 935, 925, 405,2670, 703,1096,1860,2734,4671,4081,1877,1367,2704, # 3200
3389, 918,2106,1782,2483, 334,3320,1611,1093,4672, 564,3171,3505,3739,3390, 945, # 3216
2641,2058,4673,5398,1926, 872,4319,5399,3506,2705,3112, 349,4320,3740,4082,4674, # 3232
3882,4321,3741,2156,4083,4675,4676,4322,4677,2408,2047, 782,4084, 400, 251,4323, # 3248
1624,5400,5401, 277,3742, 299,1265, 476,1191,3883,2122,4324,4325,1109, 205,5402, # 3264
2590,1000,2157,3616,1861,5403,5404,5405,4678,5406,4679,2573, 107,2484,2158,4085, # 3280
3507,3172,5407,1533, 541,1301, 158, 753,4326,2886,3617,5408,1696, 370,1088,4327, # 3296
4680,3618, 579, 327, 440, 162,2244, 269,1938,1374,3508, 968,3063,  56,1396,3113, # 3312
2107,3321,3391,5409,1927,2159,4681,3016,5410,3619,5411,5412,3743,4682,2485,5413, # 3328
2804,5414,1650,4683,5415,2613,5416,5417,4086,2671,3392,1149,3393,4087,3884,4088, # 3344
5418,1076,  49,5419, 951,3242,3322,3323, 450,2850, 920,5420,1812,2805,2371,4328, # 3360
1909,1138,2372,3885,3509,5421,3243,4684,1910,1147,1518,2428,4685,3886,5422,4686, # 3376
2393,2614, 260,1796,3244,5423,5424,3887,3324, 708,5425,3620,1704,5426,3621,1351, # 3392
1618,3394,3017,1887, 944,4329,3395,4330,3064,3396,4331,5427,3744, 422, 413,1714, # 3408
3325, 500,2059,2350,4332,2486,5428,1344,1911, 954,5429,1668,5430,5431,4089,2409, # 3424
4333,3622,3888,4334,5432,2307,1318,2512,3114, 133,3115,2887,4687, 629,  31,2851, # 3440
2706,3889,4688, 850, 949,4689,4090,2970,1732,2089,4335,1496,1853,5433,4091, 620, # 3456
3245, 981,1242,3745,3397,1619,3746,1643,3326,2140,2457,1971,1719,3510,2169,5434, # 3472
3246,5435,5436,3398,1829,5437,1277,4690,1565,2048,5438,1636,3623,3116,5439, 869, # 3488
2852, 655,3890,3891,3117,4092,3018,3892,1310,3624,4691,5440,5441,5442,1733, 558, # 3504
4692,3747, 335,1549,3065,1756,4336,3748,1946,3511,1830,1291,1192, 470,2735,2108, # 3520
2806, 913,1054,4093,5443,1027,5444,3066,4094,4693, 982,2672,3399,3173,3512,3247, # 3536
3248,1947,2807,5445, 571,4694,5446,1831,5447,3625,2591,1523,2429,5448,2090, 984, # 3552
4695,3749,1960,5449,3750, 852, 923,2808,3513,3751, 969,1519, 999,2049,2325,1705, # 3568
5450,3118, 615,1662, 151, 597,4095,2410,2326,1049, 275,4696,3752,4337, 568,3753, # 3584
3626,2487,4338,3754,5451,2430,2275, 409,3249,5452,1566,2888,3514,1002, 769,2853, # 3600
 194,2091,3174,3755,2226,3327,4339, 628,1505,5453,5454,1763,2180,3019,4096, 521, # 3616
1161,2592,1788,2206,2411,4697,4097,1625,4340,4341, 412,  42,3119, 464,5455,2642, # 3632
4698,3400,1760,1571,2889,3515,2537,1219,2207,3893,2643,2141,2373,4699,4700,3328, # 3648
1651,3401,3627,5456,5457,3628,2488,3516,5458,3756,5459,5460,2276,2092, 460,5461, # 3664
4701,5462,3020, 962, 588,3629, 289,3250,2644,1116,  52,5463,3067,1797,5464,5465, # 3680
5466,1467,5467,1598,1143,3757,4342,1985,1734,1067,4702,1280,3402, 465,4703,1572, # 3696
 510,5468,1928,2245,1813,1644,3630,5469,4704,3758,5470,5471,2673,1573,1534,5472, # 3712
5473, 536,1808,1761,3517,3894,3175,2645,5474,5475,5476,4705,3518,2929,1912,2809, # 3728
5477,3329,1122, 377,3251,5478, 360,5479,5480,4343,1529, 551,5481,2060,3759,1769, # 3744
2431,5482,2930,4344,3330,3120,2327,2109,2031,4706,1404, 136,1468,1479, 672,1171, # 3760
3252,2308, 271,3176,5483,2772,5484,2050, 678,2736, 865,1948,4707,5485,2014,4098, # 3776
2971,5486,2737,2227,1397,3068,3760,4708,4709,1735,2931,3403,3631,5487,3895, 509, # 3792
2854,2458,2890,3896,5488,5489,3177,3178,4710,4345,2538,4711,2309,1166,1010, 552, # 3808
 681,1888,5490,5491,2972,2973,4099,1287,1596,1862,3179, 358, 453, 736, 175, 478, # 3824
1117, 905,1167,1097,5492,1854,1530,5493,1706,5494,2181,3519,2292,3761,3520,3632, # 3840
4346,2093,4347,5495,3404,1193,2489,4348,1458,2193,2208,1863,1889,1421,3331,2932, # 3856
3069,2182,3521, 595,2123,5496,4100,5497,5498,4349,1707,2646, 223,3762,1359, 751, # 3872
3121, 183,3522,5499,2810,3021, 419,2374, 633, 704,3897,2394, 241,5500,5501,5502, # 3888
 838,3022,3763,2277,2773,2459,3898,1939,2051,4101,1309,3122,2246,1181,5503,1136, # 3904
2209,3899,2375,1446,4350,2310,4712,5504,5505,4351,1055,2615, 484,3764,5506,4102, # 3920
 625,4352,2278,3405,1499,4353,4103,5507,4104,4354,3253,2279,2280,3523,5508,5509, # 3936
2774, 808,2616,3765,3406,4105,4355,3123,2539, 526,3407,3900,4356, 955,5510,1620, # 3952
4357,2647,2432,5511,1429,3766,1669,1832, 994, 928,5512,3633,1260,5513,5514,5515, # 3968
1949,2293, 741,2933,1626,4358,2738,2460, 867,1184, 362,3408,1392,5516,5517,4106, # 3984
4359,1770,1736,3254,2934,4713,4714,1929,2707,1459,1158,5518,3070,3409,2891,1292, # 4000
1930,2513,2855,3767,1986,1187,2072,2015,2617,4360,5519,2574,2514,2170,3768,2490, # 4016
3332,5520,3769,4715,5521,5522, 666,1003,3023,1022,3634,4361,5523,4716,1814,2257, # 4032
 574,3901,1603, 295,1535, 705,3902,4362, 283, 858, 417,5524,5525,3255,4717,4718, # 4048
3071,1220,1890,1046,2281,2461,4107,1393,1599, 689,2575, 388,4363,5526,2491, 802, # 4064
5527,2811,3903,2061,1405,2258,5528,4719,3904,2110,1052,1345,3256,1585,5529, 809, # 4080
5530,5531,5532, 575,2739,3524, 956,1552,1469,1144,2328,5533,2329,1560,2462,3635, # 4096
3257,4108, 616,2210,4364,3180,2183,2294,5534,1833,5535,3525,4720,5536,1319,3770, # 4112
3771,1211,3636,1023,3258,1293,2812,5537,5538,5539,3905, 607,2311,3906, 762,2892, # 4128
1439,4365,1360,4721,1485,3072,5540,4722,1038,4366,1450,2062,2648,4367,1379,4723, # 4144
2593,5541,5542,4368,1352,1414,2330,2935,1172,5543,5544,3907,3908,4724,1798,1451, # 4160
5545,5546,5547,5548,2936,4109,4110,2492,2351, 411,4111,4112,3637,3333,3124,4725, # 4176
1561,2674,1452,4113,1375,5549,5550,  47,2974, 316,5551,1406,1591,2937,3181,5552, # 4192
1025,2142,3125,3182, 354,2740, 884,2228,4369,2412, 508,3772, 726,3638, 996,2433, # 4208
3639, 729,5553, 392,2194,1453,4114,4726,3773,5554,5555,2463,3640,2618,1675,2813, # 4224
 919,2352,2975,2353,1270,4727,4115,  73,5556,5557, 647,5558,3259,2856,2259,1550, # 4240
1346,3024,5559,1332, 883,3526,5560,5561,5562,5563,3334,2775,5564,1212, 831,1347, # 4256
4370,4728,2331,3909,1864,3073, 720,3910,4729,4730,3911,5565,4371,5566,5567,4731, # 4272
5568,5569,1799,4732,3774,2619,4733,3641,1645,2376,4734,5570,2938, 669,2211,2675, # 4288
2434,5571,2893,5572,5573,1028,3260,5574,4372,2413,5575,2260,1353,5576,5577,4735, # 4304
3183, 518,5578,4116,5579,4373,1961,5580,2143,4374,5581,5582,3025,2354,2355,3912, # 4320
 516,1834,1454,4117,2708,4375,4736,2229,2620,1972,1129,3642,5583,2776,5584,2976, # 4336
1422, 577,1470,3026,1524,3410,5585,5586, 432,4376,3074,3527,5587,2594,1455,2515, # 4352
2230,1973,1175,5588,1020,2741,4118,3528,4737,5589,2742,5590,1743,1361,3075,3529, # 4368
2649,4119,4377,4738,2295, 895, 924,4378,2171, 331,2247,3076, 166,1627,3077,1098, # 4384
5591,1232,2894,2231,3411,4739, 657, 403,1196,2377, 542,3775,3412,1600,4379,3530, # 4400
5592,4740,2777,3261, 576, 530,1362,4741,4742,2540,2676,3776,4120,5593, 842,3913, # 4416
5594,2814,2032,1014,4121, 213,2709,3413, 665, 621,4380,5595,3777,2939,2435,5596, # 4432
2436,3335,3643,3414,4743,4381,2541,4382,4744,3644,1682,4383,3531,1380,5597, 724, # 4448
2282, 600,1670,5598,1337,1233,4745,3126,2248,5599,1621,4746,5600, 651,4384,5601, # 4464
1612,4385,2621,5602,2857,5603,2743,2312,3078,5604, 716,2464,3079, 174,1255,2710, # 4480
4122,3645, 548,1320,1398, 728,4123,1574,5605,1891,1197,3080,4124,5606,3081,3082, # 4496
3778,3646,3779, 747,5607, 635,4386,4747,5608,5609,5610,4387,5611,5612,4748,5613, # 4512
3415,4749,2437, 451,5614,3780,2542,2073,4388,2744,4389,4125,5615,1764,4750,5616, # 4528
4390, 350,4751,2283,2395,2493,5617,4391,4126,2249,1434,4127, 488,4752, 458,4392, # 4544
4128,3781, 771,1330,2396,3914,2576,3184,2160,2414,1553,2677,3185,4393,5618,2494, # 4560
2895,2622,1720,2711,4394,3416,4753,5619,2543,4395,5620,3262,4396,2778,5621,2016, # 4576
2745,5622,1155,1017,3782,3915,5623,3336,2313, 201,1865,4397,1430,5624,4129,5625, # 4592
5626,5627,5628,5629,4398,1604,5630, 414,1866, 371,2595,4754,4755,3532,2017,3127, # 4608
4756,1708, 960,4399, 887, 389,2172,1536,1663,1721,5631,2232,4130,2356,2940,1580, # 4624
5632,5633,1744,4757,2544,4758,4759,5634,4760,5635,2074,5636,4761,3647,3417,2896, # 4640
4400,5637,4401,2650,3418,2815, 673,2712,2465, 709,3533,4131,3648,4402,5638,1148, # 4656
 502, 634,5639,5640,1204,4762,3649,1575,4763,2623,3783,5641,3784,3128, 948,3263, # 4672
 121,1745,3916,1110,5642,4403,3083,2516,3027,4132,3785,1151,1771,3917,1488,4133, # 4688
1987,5643,2438,3534,5644,5645,2094,5646,4404,3918,1213,1407,2816, 531,2746,2545, # 4704
3264,1011,1537,4764,2779,4405,3129,1061,5647,3786,3787,1867,2897,5648,2018, 120, # 4720
4406,4407,2063,3650,3265,2314,3919,2678,3419,1955,4765,4134,5649,3535,1047,2713, # 4736
1266,5650,1368,4766,2858, 649,3420,3920,2546,2747,1102,2859,2679,5651,5652,2000, # 4752
5653,1111,3651,2977,5654,2495,3921,3652,2817,1855,3421,3788,5655,5656,3422,2415, # 4768
2898,3337,3266,3653,5657,2577,5658,3654,2818,4135,1460, 856,5659,3655,5660,2899, # 4784
2978,5661,2900,3922,5662,4408, 632,2517, 875,3923,1697,3924,2296,5663,5664,4767, # 4800
3028,1239, 580,4768,4409,5665, 914, 936,2075,1190,4136,1039,2124,5666,5667,5668, # 4816
5669,3423,1473,5670,1354,4410,3925,4769,2173,3084,4137, 915,3338,4411,4412,3339, # 4832
1605,1835,5671,2748, 398,3656,4413,3926,4138, 328,1913,2860,4139,3927,1331,4414, # 4848
3029, 937,4415,5672,3657,4140,4141,3424,2161,4770,3425, 524, 742, 538,3085,1012, # 4864
5673,5674,3928,2466,5675, 658,1103, 225,3929,5676,5677,4771,5678,4772,5679,3267, # 4880
1243,5680,4142, 963,2250,4773,5681,2714,3658,3186,5682,5683,2596,2332,5684,4774, # 4896
5685,5686,5687,3536, 957,3426,2547,2033,1931,2941,2467, 870,2019,3659,1746,2780, # 4912
2781,2439,2468,5688,3930,5689,3789,3130,3790,3537,3427,3791,5690,1179,3086,5691, # 4928
3187,2378,4416,3792,2548,3188,3131,2749,4143,5692,3428,1556,2549,2297, 977,2901, # 4944
2034,4144,1205,3429,5693,1765,3430,3189,2125,1271, 714,1689,4775,3538,5694,2333, # 4960
3931, 533,4417,3660,2184, 617,5695,2469,3340,3539,2315,5696,5697,3190,5698,5699, # 4976
3932,1988, 618, 427,2651,3540,3431,5700,5701,1244,1690,5702,2819,4418,4776,5703, # 4992
3541,4777,5704,2284,1576, 473,3661,4419,3432, 972,5705,3662,5706,3087,5707,5708, # 5008
4778,4779,5709,3793,4145,4146,5710, 153,4780, 356,5711,1892,2902,4420,2144, 408, # 5024
 803,2357,5712,3933,5713,4421,1646,2578,2518,4781,4782,3934,5714,3935,4422,5715, # 5040
2416,3433, 752,5716,5717,1962,3341,2979,5718, 746,3030,2470,4783,4423,3794, 698, # 5056
4784,1893,4424,3663,2550,4785,3664,3936,5719,3191,3434,5720,1824,1302,4147,2715, # 5072
3937,1974,4425,5721,4426,3192, 823,1303,1288,1236,2861,3542,4148,3435, 774,3938, # 5088
5722,1581,4786,1304,2862,3939,4787,5723,2440,2162,1083,3268,4427,4149,4428, 344, # 5104
1173, 288,2316, 454,1683,5724,5725,1461,4788,4150,2597,5726,5727,4789, 985, 894, # 5120
5728,3436,3193,5729,1914,2942,3795,1989,5730,2111,1975,5731,4151,5732,2579,1194, # 5136
 425,5733,4790,3194,1245,3796,4429,5734,5735,2863,5736, 636,4791,1856,3940, 760, # 5152
1800,5737,4430,2212,1508,4792,4152,1894,1684,2298,5738,5739,4793,4431,4432,2213, # 5168
 479,5740,5741, 832,5742,4153,2496,5743,2980,2497,3797, 990,3132, 627,1815,2652, # 5184
4433,1582,4434,2126,2112,3543,4794,5744, 799,4435,3195,5745,4795,2113,1737,3031, # 5200
1018, 543, 754,4436,3342,1676,4796,4797,4154,4798,1489,5746,3544,5747,2624,2903, # 5216
4155,5748,5749,2981,5750,5751,5752,5753,3196,4799,4800,2185,1722,5754,3269,3270, # 5232
1843,3665,1715, 481, 365,1976,1857,5755,5756,1963,2498,4801,5757,2127,3666,3271, # 5248
 433,1895,2064,2076,5758, 602,2750,5759,5760,5761,5762,5763,3032,1628,3437,5764, # 5264
3197,4802,4156,2904,4803,2519,5765,2551,2782,5766,5767,5768,3343,4804,2905,5769, # 5280
4805,5770,2864,4806,4807,1221,2982,4157,2520,5771,5772,5773,1868,1990,5774,5775, # 5296
5776,1896,5777,5778,4808,1897,4158, 318,5779,2095,4159,4437,5780,5781, 485,5782, # 5312
 938,3941, 553,2680, 116,5783,3942,3667,5784,3545,2681,2783,3438,3344,2820,5785, # 5328
3668,2943,4160,1747,2944,2983,5786,5787, 207,5788,4809,5789,4810,2521,5790,3033, # 5344
 890,3669,3943,5791,1878,3798,3439,5792,2186,2358,3440,1652,5793,5794,5795, 941, # 5360
2299, 208,3546,4161,2020, 330,4438,3944,2906,2499,3799,4439,4811,5796,5797,5798, # 5376  #last 512
#Everything below is of no interest for detection purpose
2522,1613,4812,5799,3345,3945,2523,5800,4162,5801,1637,4163,2471,4813,3946,5802, # 5392
2500,3034,3800,5803,5804,2195,4814,5805,2163,5806,5807,5808,5809,5810,5811,5812, # 5408
5813,5814,5815,5816,5817,5818,5819,5820,5821,5822,5823,5824,5825,5826,5827,5828, # 5424
5829,5830,5831,5832,5833,5834,5835,5836,5837,5838,5839,5840,5841,5842,5843,5844, # 5440
5845,5846,5847,5848,5849,5850,5851,5852,5853,5854,5855,5856,5857,5858,5859,5860, # 5456
5861,5862,5863,5864,5865,5866,5867,5868,5869,5870,5871,5872,5873,5874,5875,5876, # 5472
5877,5878,5879,5880,5881,5882,5883,5884,5885,5886,5887,5888,5889,5890,5891,5892, # 5488
5893,5894,5895,5896,5897,5898,5899,5900,5901,5902,5903,5904,5905,5906,5907,5908, # 5504
5909,5910,5911,5912,5913,5914,5915,5916,5917,5918,5919,5920,5921,5922,5923,5924, # 5520
5925,5926,5927,5928,5929,5930,5931,5932,5933,5934,5935,5936,5937,5938,5939,5940, # 5536
5941,5942,5943,5944,5945,5946,5947,5948,5949,5950,5951,5952,5953,5954,5955,5956, # 5552
5957,5958,5959,5960,5961,5962,5963,5964,5965,5966,5967,5968,5969,5970,5971,5972, # 5568
5973,5974,5975,5976,5977,5978,5979,5980,5981,5982,5983,5984,5985,5986,5987,5988, # 5584
5989,5990,5991,5992,5993,5994,5995,5996,5997,5998,5999,6000,6001,6002,6003,6004, # 5600
6005,6006,6007,6008,6009,6010,6011,6012,6013,6014,6015,6016,6017,6018,6019,6020, # 5616
6021,6022,6023,6024,6025,6026,6027,6028,6029,6030,6031,6032,6033,6034,6035,6036, # 5632
6037,6038,6039,6040,6041,6042,6043,6044,6045,6046,6047,6048,6049,6050,6051,6052, # 5648
6053,6054,6055,6056,6057,6058,6059,6060,6061,6062,6063,6064,6065,6066,6067,6068, # 5664
6069,6070,6071,6072,6073,6074,6075,6076,6077,6078,6079,6080,6081,6082,6083,6084, # 5680
6085,6086,6087,6088,6089,6090,6091,6092,6093,6094,6095,6096,6097,6098,6099,6100, # 5696
6101,6102,6103,6104,6105,6106,6107,6108,6109,6110,6111,6112,6113,6114,6115,6116, # 5712
6117,6118,6119,6120,6121,6122,6123,6124,6125,6126,6127,6128,6129,6130,6131,6132, # 5728
6133,6134,6135,6136,6137,6138,6139,6140,6141,6142,6143,6144,6145,6146,6147,6148, # 5744
6149,6150,6151,6152,6153,6154,6155,6156,6157,6158,6159,6160,6161,6162,6163,6164, # 5760
6165,6166,6167,6168,6169,6170,6171,6172,6173,6174,6175,6176,6177,6178,6179,6180, # 5776
6181,6182,6183,6184,6185,6186,6187,6188,6189,6190,6191,6192,6193,6194,6195,6196, # 5792
6197,6198,6199,6200,6201,6202,6203,6204,6205,6206,6207,6208,6209,6210,6211,6212, # 5808
6213,6214,6215,6216,6217,6218,6219,6220,6221,6222,6223,3670,6224,6225,6226,6227, # 5824
6228,6229,6230,6231,6232,6233,6234,6235,6236,6237,6238,6239,6240,6241,6242,6243, # 5840
6244,6245,6246,6247,6248,6249,6250,6251,6252,6253,6254,6255,6256,6257,6258,6259, # 5856
6260,6261,6262,6263,6264,6265,6266,6267,6268,6269,6270,6271,6272,6273,6274,6275, # 5872
6276,6277,6278,6279,6280,6281,6282,6283,6284,6285,4815,6286,6287,6288,6289,6290, # 5888
6291,6292,4816,6293,6294,6295,6296,6297,6298,6299,6300,6301,6302,6303,6304,6305, # 5904
6306,6307,6308,6309,6310,6311,4817,4818,6312,6313,6314,6315,6316,6317,6318,4819, # 5920
6319,6320,6321,6322,6323,6324,6325,6326,6327,6328,6329,6330,6331,6332,6333,6334, # 5936
6335,6336,6337,4820,6338,6339,6340,6341,6342,6343,6344,6345,6346,6347,6348,6349, # 5952
6350,6351,6352,6353,6354,6355,6356,6357,6358,6359,6360,6361,6362,6363,6364,6365, # 5968
6366,6367,6368,6369,6370,6371,6372,6373,6374,6375,6376,6377,6378,6379,6380,6381, # 5984
6382,6383,6384,6385,6386,6387,6388,6389,6390,6391,6392,6393,6394,6395,6396,6397, # 6000
6398,6399,6400,6401,6402,6403,6404,6405,6406,6407,6408,6409,6410,3441,6411,6412, # 6016
6413,6414,6415,6416,6417,6418,6419,6420,6421,6422,6423,6424,6425,4440,6426,6427, # 6032
6428,6429,6430,6431,6432,6433,6434,6435,6436,6437,6438,6439,6440,6441,6442,6443, # 6048
6444,6445,6446,6447,6448,6449,6450,6451,6452,6453,6454,4821,6455,6456,6457,6458, # 6064
6459,6460,6461,6462,6463,6464,6465,6466,6467,6468,6469,6470,6471,6472,6473,6474, # 6080
6475,6476,6477,3947,3948,6478,6479,6480,6481,3272,4441,6482,6483,6484,6485,4442, # 6096
6486,6487,6488,6489,6490,6491,6492,6493,6494,6495,6496,4822,6497,6498,6499,6500, # 6112
6501,6502,6503,6504,6505,6506,6507,6508,6509,6510,6511,6512,6513,6514,6515,6516, # 6128
6517,6518,6519,6520,6521,6522,6523,6524,6525,6526,6527,6528,6529,6530,6531,6532, # 6144
6533,6534,6535,6536,6537,6538,6539,6540,6541,6542,6543,6544,6545,6546,6547,6548, # 6160
6549,6550,6551,6552,6553,6554,6555,6556,2784,6557,4823,6558,6559,6560,6561,6562, # 6176
6563,6564,6565,6566,6567,6568,6569,3949,6570,6571,6572,4824,6573,6574,6575,6576, # 6192
6577,6578,6579,6580,6581,6582,6583,4825,6584,6585,6586,3950,2785,6587,6588,6589, # 6208
6590,6591,6592,6593,6594,6595,6596,6597,6598,6599,6600,6601,6602,6603,6604,6605, # 6224
6606,6607,6608,6609,6610,6611,6612,4826,6613,6614,6615,4827,6616,6617,6618,6619, # 6240
6620,6621,6622,6623,6624,6625,4164,6626,6627,6628,6629,6630,6631,6632,6633,6634, # 6256
3547,6635,4828,6636,6637,6638,6639,6640,6641,6642,3951,2984,6643,6644,6645,6646, # 6272
6647,6648,6649,4165,6650,4829,6651,6652,4830,6653,6654,6655,6656,6657,6658,6659, # 6288
6660,6661,6662,4831,6663,6664,6665,6666,6667,6668,6669,6670,6671,4166,6672,4832, # 6304
3952,6673,6674,6675,6676,4833,6677,6678,6679,4167,6680,6681,6682,3198,6683,6684, # 6320
6685,6686,6687,6688,6689,6690,6691,6692,6693,6694,6695,6696,6697,4834,6698,6699, # 6336
6700,6701,6702,6703,6704,6705,6706,6707,6708,6709,6710,6711,6712,6713,6714,6715, # 6352
6716,6717,6718,6719,6720,6721,6722,6723,6724,6725,6726,6727,6728,6729,6730,6731, # 6368
6732,6733,6734,4443,6735,6736,6737,6738,6739,6740,6741,6742,6743,6744,6745,4444, # 6384
6746,6747,6748,6749,6750,6751,6752,6753,6754,6755,6756,6757,6758,6759,6760,6761, # 6400
6762,6763,6764,6765,6766,6767,6768,6769,6770,6771,6772,6773,6774,6775,6776,6777, # 6416
6778,6779,6780,6781,4168,6782,6783,3442,6784,6785,6786,6787,6788,6789,6790,6791, # 6432
4169,6792,6793,6794,6795,6796,6797,6798,6799,6800,6801,6802,6803,6804,6805,6806, # 6448
6807,6808,6809,6810,6811,4835,6812,6813,6814,4445,6815,6816,4446,6817,6818,6819, # 6464
6820,6821,6822,6823,6824,6825,6826,6827,6828,6829,6830,6831,6832,6833,6834,6835, # 6480
3548,6836,6837,6838,6839,6840,6841,6842,6843,6844,6845,6846,4836,6847,6848,6849, # 6496
6850,6851,6852,6853,6854,3953,6855,6856,6857,6858,6859,6860,6861,6862,6863,6864, # 6512
6865,6866,6867,6868,6869,6870,6871,6872,6873,6874,6875,6876,6877,3199,6878,6879, # 6528
6880,6881,6882,4447,6883,6884,6885,6886,6887,6888,6889,6890,6891,6892,6893,6894, # 6544
6895,6896,6897,6898,6899,6900,6901,6902,6903,6904,4170,6905,6906,6907,6908,6909, # 6560
6910,6911,6912,6913,6914,6915,6916,6917,6918,6919,6920,6921,6922,6923,6924,6925, # 6576
6926,6927,4837,6928,6929,6930,6931,6932,6933,6934,6935,6936,3346,6937,6938,4838, # 6592
6939,6940,6941,4448,6942,6943,6944,6945,6946,4449,6947,6948,6949,6950,6951,6952, # 6608
6953,6954,6955,6956,6957,6958,6959,6960,6961,6962,6963,6964,6965,6966,6967,6968, # 6624
6969,6970,6971,6972,6973,6974,6975,6976,6977,6978,6979,6980,6981,6982,6983,6984, # 6640
6985,6986,6987,6988,6989,6990,6991,6992,6993,6994,3671,6995,6996,6997,6998,4839, # 6656
6999,7000,7001,7002,3549,7003,7004,7005,7006,7007,7008,7009,7010,7011,7012,7013, # 6672
7014,7015,7016,7017,7018,7019,7020,7021,7022,7023,7024,7025,7026,7027,7028,7029, # 6688
7030,4840,7031,7032,7033,7034,7035,7036,7037,7038,4841,7039,7040,7041,7042,7043, # 6704
7044,7045,7046,7047,7048,7049,7050,7051,7052,7053,7054,7055,7056,7057,7058,7059, # 6720
7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,2985,7071,7072,7073,7074, # 6736
7075,7076,7077,7078,7079,7080,4842,7081,7082,7083,7084,7085,7086,7087,7088,7089, # 6752
7090,7091,7092,7093,7094,7095,7096,7097,7098,7099,7100,7101,7102,7103,7104,7105, # 6768
7106,7107,7108,7109,7110,7111,7112,7113,7114,7115,7116,7117,7118,4450,7119,7120, # 6784
7121,7122,7123,7124,7125,7126,7127,7128,7129,7130,7131,7132,7133,7134,7135,7136, # 6800
7137,7138,7139,7140,7141,7142,7143,4843,7144,7145,7146,7147,7148,7149,7150,7151, # 6816
7152,7153,7154,7155,7156,7157,7158,7159,7160,7161,7162,7163,7164,7165,7166,7167, # 6832
7168,7169,7170,7171,7172,7173,7174,7175,7176,7177,7178,7179,7180,7181,7182,7183, # 6848
7184,7185,7186,7187,7188,4171,4172,7189,7190,7191,7192,7193,7194,7195,7196,7197, # 6864
7198,7199,7200,7201,7202,7203,7204,7205,7206,7207,7208,7209,7210,7211,7212,7213, # 6880
7214,7215,7216,7217,7218,7219,7220,7221,7222,7223,7224,7225,7226,7227,7228,7229, # 6896
7230,7231,7232,7233,7234,7235,7236,7237,7238,7239,7240,7241,7242,7243,7244,7245, # 6912
7246,7247,7248,7249,7250,7251,7252,7253,7254,7255,7256,7257,7258,7259,7260,7261, # 6928
7262,7263,7264,7265,7266,7267,7268,7269,7270,7271,7272,7273,7274,7275,7276,7277, # 6944
7278,7279,7280,7281,7282,7283,7284,7285,7286,7287,7288,7289,7290,7291,7292,7293, # 6960
7294,7295,7296,4844,7297,7298,7299,7300,7301,7302,7303,7304,7305,7306,7307,7308, # 6976
7309,7310,7311,7312,7313,7314,7315,7316,4451,7317,7318,7319,7320,7321,7322,7323, # 6992
7324,7325,7326,7327,7328,7329,7330,7331,7332,7333,7334,7335,7336,7337,7338,7339, # 7008
7340,7341,7342,7343,7344,7345,7346,7347,7348,7349,7350,7351,7352,7353,4173,7354, # 7024
7355,4845,7356,7357,7358,7359,7360,7361,7362,7363,7364,7365,7366,7367,7368,7369, # 7040
7370,7371,7372,7373,7374,7375,7376,7377,7378,7379,7380,7381,7382,7383,7384,7385, # 7056
7386,7387,7388,4846,7389,7390,7391,7392,7393,7394,7395,7396,7397,7398,7399,7400, # 7072
7401,7402,7403,7404,7405,3672,7406,7407,7408,7409,7410,7411,7412,7413,7414,7415, # 7088
7416,7417,7418,7419,7420,7421,7422,7423,7424,7425,7426,7427,7428,7429,7430,7431, # 7104
7432,7433,7434,7435,7436,7437,7438,7439,7440,7441,7442,7443,7444,7445,7446,7447, # 7120
7448,7449,7450,7451,7452,7453,4452,7454,3200,7455,7456,7457,7458,7459,7460,7461, # 7136
7462,7463,7464,7465,7466,7467,7468,7469,7470,7471,7472,7473,7474,4847,7475,7476, # 7152
7477,3133,7478,7479,7480,7481,7482,7483,7484,7485,7486,7487,7488,7489,7490,7491, # 7168
7492,7493,7494,7495,7496,7497,7498,7499,7500,7501,7502,3347,7503,7504,7505,7506, # 7184
7507,7508,7509,7510,7511,7512,7513,7514,7515,7516,7517,7518,7519,7520,7521,4848, # 7200
7522,7523,7524,7525,7526,7527,7528,7529,7530,7531,7532,7533,7534,7535,7536,7537, # 7216
7538,7539,7540,7541,7542,7543,7544,7545,7546,7547,7548,7549,3801,4849,7550,7551, # 7232
7552,7553,7554,7555,7556,7557,7558,7559,7560,7561,7562,7563,7564,7565,7566,7567, # 7248
7568,7569,3035,7570,7571,7572,7573,7574,7575,7576,7577,7578,7579,7580,7581,7582, # 7264
7583,7584,7585,7586,7587,7588,7589,7590,7591,7592,7593,7594,7595,7596,7597,7598, # 7280
7599,7600,7601,7602,7603,7604,7605,7606,7607,7608,7609,7610,7611,7612,7613,7614, # 7296
7615,7616,4850,7617,7618,3802,7619,7620,7621,7622,7623,7624,7625,7626,7627,7628, # 7312
7629,7630,7631,7632,4851,7633,7634,7635,7636,7637,7638,7639,7640,7641,7642,7643, # 7328
7644,7645,7646,7647,7648,7649,7650,7651,7652,7653,7654,7655,7656,7657,7658,7659, # 7344
7660,7661,7662,7663,7664,7665,7666,7667,7668,7669,7670,4453,7671,7672,7673,7674, # 7360
7675,7676,7677,7678,7679,7680,7681,7682,7683,7684,7685,7686,7687,7688,7689,7690, # 7376
7691,7692,7693,7694,7695,7696,7697,3443,7698,7699,7700,7701,7702,4454,7703,7704, # 7392
7705,7706,7707,7708,7709,7710,7711,7712,7713,2472,7714,7715,7716,7717,7718,7719, # 7408
7720,7721,7722,7723,7724,7725,7726,7727,7728,7729,7730,7731,3954,7732,7733,7734, # 7424
7735,7736,7737,7738,7739,7740,7741,7742,7743,7744,7745,7746,7747,7748,7749,7750, # 7440
3134,7751,7752,4852,7753,7754,7755,4853,7756,7757,7758,7759,7760,4174,7761,7762, # 7456
7763,7764,7765,7766,7767,7768,7769,7770,7771,7772,7773,7774,7775,7776,7777,7778, # 7472
7779,7780,7781,7782,7783,7784,7785,7786,7787,7788,7789,7790,7791,7792,7793,7794, # 7488
7795,7796,7797,7798,7799,7800,7801,7802,7803,7804,7805,4854,7806,7807,7808,7809, # 7504
7810,7811,7812,7813,7814,7815,7816,7817,7818,7819,7820,7821,7822,7823,7824,7825, # 7520
4855,7826,7827,7828,7829,7830,7831,7832,7833,7834,7835,7836,7837,7838,7839,7840, # 7536
7841,7842,7843,7844,7845,7846,7847,3955,7848,7849,7850,7851,7852,7853,7854,7855, # 7552
7856,7857,7858,7859,7860,3444,7861,7862,7863,7864,7865,7866,7867,7868,7869,7870, # 7568
7871,7872,7873,7874,7875,7876,7877,7878,7879,7880,7881,7882,7883,7884,7885,7886, # 7584
7887,7888,7889,7890,7891,4175,7892,7893,7894,7895,7896,4856,4857,7897,7898,7899, # 7600
7900,2598,7901,7902,7903,7904,7905,7906,7907,7908,4455,7909,7910,7911,7912,7913, # 7616
7914,3201,7915,7916,7917,7918,7919,7920,7921,4858,7922,7923,7924,7925,7926,7927, # 7632
7928,7929,7930,7931,7932,7933,7934,7935,7936,7937,7938,7939,7940,7941,7942,7943, # 7648
7944,7945,7946,7947,7948,7949,7950,7951,7952,7953,7954,7955,7956,7957,7958,7959, # 7664
7960,7961,7962,7963,7964,7965,7966,7967,7968,7969,7970,7971,7972,7973,7974,7975, # 7680
7976,7977,7978,7979,7980,7981,4859,7982,7983,7984,7985,7986,7987,7988,7989,7990, # 7696
7991,7992,7993,7994,7995,7996,4860,7997,7998,7999,8000,8001,8002,8003,8004,8005, # 7712
8006,8007,8008,8009,8010,8011,8012,8013,8014,8015,8016,4176,8017,8018,8019,8020, # 7728
8021,8022,8023,4861,8024,8025,8026,8027,8028,8029,8030,8031,8032,8033,8034,8035, # 7744
8036,4862,4456,8037,8038,8039,8040,4863,8041,8042,8043,8044,8045,8046,8047,8048, # 7760
8049,8050,8051,8052,8053,8054,8055,8056,8057,8058,8059,8060,8061,8062,8063,8064, # 7776
8065,8066,8067,8068,8069,8070,8071,8072,8073,8074,8075,8076,8077,8078,8079,8080, # 7792
8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,8096, # 7808
8097,8098,8099,4864,4177,8100,8101,8102,8103,8104,8105,8106,8107,8108,8109,8110, # 7824
8111,8112,8113,8114,8115,8116,8117,8118,8119,8120,4178,8121,8122,8123,8124,8125, # 7840
8126,8127,8128,8129,8130,8131,8132,8133,8134,8135,8136,8137,8138,8139,8140,8141, # 7856
8142,8143,8144,8145,4865,4866,8146,8147,8148,8149,8150,8151,8152,8153,8154,8155, # 7872
8156,8157,8158,8159,8160,8161,8162,8163,8164,8165,4179,8166,8167,8168,8169,8170, # 7888
8171,8172,8173,8174,8175,8176,8177,8178,8179,8180,8181,4457,8182,8183,8184,8185, # 7904
8186,8187,8188,8189,8190,8191,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201, # 7920
8202,8203,8204,8205,8206,8207,8208,8209,8210,8211,8212,8213,8214,8215,8216,8217, # 7936
8218,8219,8220,8221,8222,8223,8224,8225,8226,8227,8228,8229,8230,8231,8232,8233, # 7952
8234,8235,8236,8237,8238,8239,8240,8241,8242,8243,8244,8245,8246,8247,8248,8249, # 7968
8250,8251,8252,8253,8254,8255,8256,3445,8257,8258,8259,8260,8261,8262,4458,8263, # 7984
8264,8265,8266,8267,8268,8269,8270,8271,8272,4459,8273,8274,8275,8276,3550,8277, # 8000
8278,8279,8280,8281,8282,8283,8284,8285,8286,8287,8288,8289,4460,8290,8291,8292, # 8016
8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,8304,8305,8306,8307,4867, # 8032
8308,8309,8310,8311,8312,3551,8313,8314,8315,8316,8317,8318,8319,8320,8321,8322, # 8048
8323,8324,8325,8326,4868,8327,8328,8329,8330,8331,8332,8333,8334,8335,8336,8337, # 8064
8338,8339,8340,8341,8342,8343,8344,8345,8346,8347,8348,8349,8350,8351,8352,8353, # 8080
8354,8355,8356,8357,8358,8359,8360,8361,8362,8363,4869,4461,8364,8365,8366,8367, # 8096
8368,8369,8370,4870,8371,8372,8373,8374,8375,8376,8377,8378,8379,8380,8381,8382, # 8112
8383,8384,8385,8386,8387,8388,8389,8390,8391,8392,8393,8394,8395,8396,8397,8398, # 8128
8399,8400,8401,8402,8403,8404,8405,8406,8407,8408,8409,8410,4871,8411,8412,8413, # 8144
8414,8415,8416,8417,8418,8419,8420,8421,8422,4462,8423,8424,8425,8426,8427,8428, # 8160
8429,8430,8431,8432,8433,2986,8434,8435,8436,8437,8438,8439,8440,8441,8442,8443, # 8176
8444,8445,8446,8447,8448,8449,8450,8451,8452,8453,8454,8455,8456,8457,8458,8459, # 8192
8460,8461,8462,8463,8464,8465,8466,8467,8468,8469,8470,8471,8472,8473,8474,8475, # 8208
8476,8477,8478,4180,8479,8480,8481,8482,8483,8484,8485,8486,8487,8488,8489,8490, # 8224
8491,8492,8493,8494,8495,8496,8497,8498,8499,8500,8501,8502,8503,8504,8505,8506, # 8240
8507,8508,8509,8510,8511,8512,8513,8514,8515,8516,8517,8518,8519,8520,8521,8522, # 8256
8523,8524,8525,8526,8527,8528,8529,8530,8531,8532,8533,8534,8535,8536,8537,8538, # 8272
8539,8540,8541,8542,8543,8544,8545,8546,8547,8548,8549,8550,8551,8552,8553,8554, # 8288
8555,8556,8557,8558,8559,8560,8561,8562,8563,8564,4872,8565,8566,8567,8568,8569, # 8304
8570,8571,8572,8573,4873,8574,8575,8576,8577,8578,8579,8580,8581,8582,8583,8584, # 8320
8585,8586,8587,8588,8589,8590,8591,8592,8593,8594,8595,8596,8597,8598,8599,8600, # 8336
8601,8602,8603,8604,8605,3803,8606,8607,8608,8609,8610,8611,8612,8613,4874,3804, # 8352
8614,8615,8616,8617,8618,8619,8620,8621,3956,8622,8623,8624,8625,8626,8627,8628, # 8368
8629,8630,8631,8632,8633,8634,8635,8636,8637,8638,2865,8639,8640,8641,8642,8643, # 8384
8644,8645,8646,8647,8648,8649,8650,8651,8652,8653,8654,8655,8656,4463,8657,8658, # 8400
8659,4875,4876,8660,8661,8662,8663,8664,8665,8666,8667,8668,8669,8670,8671,8672, # 8416
8673,8674,8675,8676,8677,8678,8679,8680,8681,4464,8682,8683,8684,8685,8686,8687, # 8432
8688,8689,8690,8691,8692,8693,8694,8695,8696,8697,8698,8699,8700,8701,8702,8703, # 8448
8704,8705,8706,8707,8708,8709,2261,8710,8711,8712,8713,8714,8715,8716,8717,8718, # 8464
8719,8720,8721,8722,8723,8724,8725,8726,8727,8728,8729,8730,8731,8732,8733,4181, # 8480
8734,8735,8736,8737,8738,8739,8740,8741,8742,8743,8744,8745,8746,8747,8748,8749, # 8496
8750,8751,8752,8753,8754,8755,8756,8757,8758,8759,8760,8761,8762,8763,4877,8764, # 8512
8765,8766,8767,8768,8769,8770,8771,8772,8773,8774,8775,8776,8777,8778,8779,8780, # 8528
8781,8782,8783,8784,8785,8786,8787,8788,4878,8789,4879,8790,8791,8792,4880,8793, # 8544
8794,8795,8796,8797,8798,8799,8800,8801,4881,8802,8803,8804,8805,8806,8807,8808, # 8560
8809,8810,8811,8812,8813,8814,8815,3957,8816,8817,8818,8819,8820,8821,8822,8823, # 8576
8824,8825,8826,8827,8828,8829,8830,8831,8832,8833,8834,8835,8836,8837,8838,8839, # 8592
8840,8841,8842,8843,8844,8845,8846,8847,4882,8848,8849,8850,8851,8852,8853,8854, # 8608
8855,8856,8857,8858,8859,8860,8861,8862,8863,8864,8865,8866,8867,8868,8869,8870, # 8624
8871,8872,8873,8874,8875,8876,8877,8878,8879,8880,8881,8882,8883,8884,3202,8885, # 8640
8886,8887,8888,8889,8890,8891,8892,8893,8894,8895,8896,8897,8898,8899,8900,8901, # 8656
8902,8903,8904,8905,8906,8907,8908,8909,8910,8911,8912,8913,8914,8915,8916,8917, # 8672
8918,8919,8920,8921,8922,8923,8924,4465,8925,8926,8927,8928,8929,8930,8931,8932, # 8688
4883,8933,8934,8935,8936,8937,8938,8939,8940,8941,8942,8943,2214,8944,8945,8946, # 8704
8947,8948,8949,8950,8951,8952,8953,8954,8955,8956,8957,8958,8959,8960,8961,8962, # 8720
8963,8964,8965,4884,8966,8967,8968,8969,8970,8971,8972,8973,8974,8975,8976,8977, # 8736
8978,8979,8980,8981,8982,8983,8984,8985,8986,8987,8988,8989,8990,8991,8992,4885, # 8752
8993,8994,8995,8996,8997,8998,8999,9000,9001,9002,9003,9004,9005,9006,9007,9008, # 8768
9009,9010,9011,9012,9013,9014,9015,9016,9017,9018,9019,9020,9021,4182,9022,9023, # 8784
9024,9025,9026,9027,9028,9029,9030,9031,9032,9033,9034,9035,9036,9037,9038,9039, # 8800
9040,9041,9042,9043,9044,9045,9046,9047,9048,9049,9050,9051,9052,9053,9054,9055, # 8816
9056,9057,9058,9059,9060,9061,9062,9063,4886,9064,9065,9066,9067,9068,9069,4887, # 8832
9070,9071,9072,9073,9074,9075,9076,9077,9078,9079,9080,9081,9082,9083,9084,9085, # 8848
9086,9087,9088,9089,9090,9091,9092,9093,9094,9095,9096,9097,9098,9099,9100,9101, # 8864
9102,9103,9104,9105,9106,9107,9108,9109,9110,9111,9112,9113,9114,9115,9116,9117, # 8880
9118,9119,9120,9121,9122,9123,9124,9125,9126,9127,9128,9129,9130,9131,9132,9133, # 8896
9134,9135,9136,9137,9138,9139,9140,9141,3958,9142,9143,9144,9145,9146,9147,9148, # 8912
9149,9150,9151,4888,9152,9153,9154,9155,9156,9157,9158,9159,9160,9161,9162,9163, # 8928
9164,9165,9166,9167,9168,9169,9170,9171,9172,9173,9174,9175,4889,9176,9177,9178, # 8944
9179,9180,9181,9182,9183,9184,9185,9186,9187,9188,9189,9190,9191,9192,9193,9194, # 8960
9195,9196,9197,9198,9199,9200,9201,9202,9203,4890,9204,9205,9206,9207,9208,9209, # 8976
9210,9211,9212,9213,9214,9215,9216,9217,9218,9219,9220,9221,9222,4466,9223,9224, # 8992
9225,9226,9227,9228,9229,9230,9231,9232,9233,9234,9235,9236,9237,9238,9239,9240, # 9008
9241,9242,9243,9244,9245,4891,9246,9247,9248,9249,9250,9251,9252,9253,9254,9255, # 9024
9256,9257,4892,9258,9259,9260,9261,4893,4894,9262,9263,9264,9265,9266,9267,9268, # 9040
9269,9270,9271,9272,9273,4467,9274,9275,9276,9277,9278,9279,9280,9281,9282,9283, # 9056
9284,9285,3673,9286,9287,9288,9289,9290,9291,9292,9293,9294,9295,9296,9297,9298, # 9072
9299,9300,9301,9302,9303,9304,9305,9306,9307,9308,9309,9310,9311,9312,9313,9314, # 9088
9315,9316,9317,9318,9319,9320,9321,9322,4895,9323,9324,9325,9326,9327,9328,9329, # 9104
9330,9331,9332,9333,9334,9335,9336,9337,9338,9339,9340,9341,9342,9343,9344,9345, # 9120
9346,9347,4468,9348,9349,9350,9351,9352,9353,9354,9355,9356,9357,9358,9359,9360, # 9136
9361,9362,9363,9364,9365,9366,9367,9368,9369,9370,9371,9372,9373,4896,9374,4469, # 9152
9375,9376,9377,9378,9379,4897,9380,9381,9382,9383,9384,9385,9386,9387,9388,9389, # 9168
9390,9391,9392,9393,9394,9395,9396,9397,9398,9399,9400,9401,9402,9403,9404,9405, # 9184
9406,4470,9407,2751,9408,9409,3674,3552,9410,9411,9412,9413,9414,9415,9416,9417, # 9200
9418,9419,9420,9421,4898,9422,9423,9424,9425,9426,9427,9428,9429,3959,9430,9431, # 9216
9432,9433,9434,9435,9436,4471,9437,9438,9439,9440,9441,9442,9443,9444,9445,9446, # 9232
9447,9448,9449,9450,3348,9451,9452,9453,9454,9455,9456,9457,9458,9459,9460,9461, # 9248
9462,9463,9464,9465,9466,9467,9468,9469,9470,9471,9472,4899,9473,9474,9475,9476, # 9264
9477,4900,9478,9479,9480,9481,9482,9483,9484,9485,9486,9487,9488,3349,9489,9490, # 9280
9491,9492,9493,9494,9495,9496,9497,9498,9499,9500,9501,9502,9503,9504,9505,9506, # 9296
9507,9508,9509,9510,9511,9512,9513,9514,9515,9516,9517,9518,9519,9520,4901,9521, # 9312
9522,9523,9524,9525,9526,4902,9527,9528,9529,9530,9531,9532,9533,9534,9535,9536, # 9328
9537,9538,9539,9540,9541,9542,9543,9544,9545,9546,9547,9548,9549,9550,9551,9552, # 9344
9553,9554,9555,9556,9557,9558,9559,9560,9561,9562,9563,9564,9565,9566,9567,9568, # 9360
9569,9570,9571,9572,9573,9574,9575,9576,9577,9578,9579,9580,9581,9582,9583,9584, # 9376
3805,9585,9586,9587,9588,9589,9590,9591,9592,9593,9594,9595,9596,9597,9598,9599, # 9392
9600,9601,9602,4903,9603,9604,9605,9606,9607,4904,9608,9609,9610,9611,9612,9613, # 9408
9614,4905,9615,9616,9617,9618,9619,9620,9621,9622,9623,9624,9625,9626,9627,9628, # 9424
9629,9630,9631,9632,4906,9633,9634,9635,9636,9637,9638,9639,9640,9641,9642,9643, # 9440
4907,9644,9645,9646,9647,9648,9649,9650,9651,9652,9653,9654,9655,9656,9657,9658, # 9456
9659,9660,9661,9662,9663,9664,9665,9666,9667,9668,9669,9670,9671,9672,4183,9673, # 9472
9674,9675,9676,9677,4908,9678,9679,9680,9681,4909,9682,9683,9684,9685,9686,9687, # 9488
9688,9689,9690,4910,9691,9692,9693,3675,9694,9695,9696,2945,9697,9698,9699,9700, # 9504
9701,9702,9703,9704,9705,4911,9706,9707,9708,9709,9710,9711,9712,9713,9714,9715, # 9520
9716,9717,9718,9719,9720,9721,9722,9723,9724,9725,9726,9727,9728,9729,9730,9731, # 9536
9732,9733,9734,9735,4912,9736,9737,9738,9739,9740,4913,9741,9742,9743,9744,9745, # 9552
9746,9747,9748,9749,9750,9751,9752,9753,9754,9755,9756,9757,9758,4914,9759,9760, # 9568
9761,9762,9763,9764,9765,9766,9767,9768,9769,9770,9771,9772,9773,9774,9775,9776, # 9584
9777,9778,9779,9780,9781,9782,4915,9783,9784,9785,9786,9787,9788,9789,9790,9791, # 9600
9792,9793,4916,9794,9795,9796,9797,9798,9799,9800,9801,9802,9803,9804,9805,9806, # 9616
9807,9808,9809,9810,9811,9812,9813,9814,9815,9816,9817,9818,9819,9820,9821,9822, # 9632
9823,9824,9825,9826,9827,9828,9829,9830,9831,9832,9833,9834,9835,9836,9837,9838, # 9648
9839,9840,9841,9842,9843,9844,9845,9846,9847,9848,9849,9850,9851,9852,9853,9854, # 9664
9855,9856,9857,9858,9859,9860,9861,9862,9863,9864,9865,9866,9867,9868,4917,9869, # 9680
9870,9871,9872,9873,9874,9875,9876,9877,9878,9879,9880,9881,9882,9883,9884,9885, # 9696
9886,9887,9888,9889,9890,9891,9892,4472,9893,9894,9895,9896,9897,3806,9898,9899, # 9712
9900,9901,9902,9903,9904,9905,9906,9907,9908,9909,9910,9911,9912,9913,9914,4918, # 9728
9915,9916,9917,4919,9918,9919,9920,9921,4184,9922,9923,9924,9925,9926,9927,9928, # 9744
9929,9930,9931,9932,9933,9934,9935,9936,9937,9938,9939,9940,9941,9942,9943,9944, # 9760
9945,9946,4920,9947,9948,9949,9950,9951,9952,9953,9954,9955,4185,9956,9957,9958, # 9776
9959,9960,9961,9962,9963,9964,9965,4921,9966,9967,9968,4473,9969,9970,9971,9972, # 9792
9973,9974,9975,9976,9977,4474,9978,9979,9980,9981,9982,9983,9984,9985,9986,9987, # 9808
9988,9989,9990,9991,9992,9993,9994,9995,9996,9997,9998,9999,10000,10001,10002,10003, # 9824
10004,10005,10006,10007,10008,10009,10010,10011,10012,10013,10014,10015,10016,10017,10018,10019, # 9840
10020,10021,4922,10022,4923,10023,10024,10025,10026,10027,10028,10029,10030,10031,10032,10033, # 9856
10034,10035,10036,10037,10038,10039,10040,10041,10042,10043,10044,10045,10046,10047,10048,4924, # 9872
10049,10050,10051,10052,10053,10054,10055,10056,10057,10058,10059,10060,10061,10062,10063,10064, # 9888
10065,10066,10067,10068,10069,10070,10071,10072,10073,10074,10075,10076,10077,10078,10079,10080, # 9904
10081,10082,10083,10084,10085,10086,10087,4475,10088,10089,10090,10091,10092,10093,10094,10095, # 9920
10096,10097,4476,10098,10099,10100,10101,10102,10103,10104,10105,10106,10107,10108,10109,10110, # 9936
10111,2174,10112,10113,10114,10115,10116,10117,10118,10119,10120,10121,10122,10123,10124,10125, # 9952
10126,10127,10128,10129,10130,10131,10132,10133,10134,10135,10136,10137,10138,10139,10140,3807, # 9968
4186,4925,10141,10142,10143,10144,10145,10146,10147,4477,4187,10148,10149,10150,10151,10152, # 9984
10153,4188,10154,10155,10156,10157,10158,10159,10160,10161,4926,10162,10163,10164,10165,10166, #10000
10167,10168,10169,10170,10171,10172,10173,10174,10175,10176,10177,10178,10179,10180,10181,10182, #10016
10183,10184,10185,10186,10187,10188,10189,10190,10191,10192,3203,10193,10194,10195,10196,10197, #10032
10198,10199,10200,4478,10201,10202,10203,10204,4479,10205,10206,10207,10208,10209,10210,10211, #10048
10212,10213,10214,10215,10216,10217,10218,10219,10220,10221,10222,10223,10224,10225,10226,10227, #10064
10228,10229,10230,10231,10232,10233,10234,4927,10235,10236,10237,10238,10239,10240,10241,10242, #10080
10243,10244,10245,10246,10247,10248,10249,10250,10251,10252,10253,10254,10255,10256,10257,10258, #10096
10259,10260,10261,10262,10263,10264,10265,10266,10267,10268,10269,10270,10271,10272,10273,4480, #10112
4928,4929,10274,10275,10276,10277,10278,10279,10280,10281,10282,10283,10284,10285,10286,10287, #10128
10288,10289,10290,10291,10292,10293,10294,10295,10296,10297,10298,10299,10300,10301,10302,10303, #10144
10304,10305,10306,10307,10308,10309,10310,10311,10312,10313,10314,10315,10316,10317,10318,10319, #10160
10320,10321,10322,10323,10324,10325,10326,10327,10328,10329,10330,10331,10332,10333,10334,4930, #10176
10335,10336,10337,10338,10339,10340,10341,10342,4931,10343,10344,10345,10346,10347,10348,10349, #10192
10350,10351,10352,10353,10354,10355,3088,10356,2786,10357,10358,10359,10360,4189,10361,10362, #10208
10363,10364,10365,10366,10367,10368,10369,10370,10371,10372,10373,10374,10375,4932,10376,10377, #10224
10378,10379,10380,10381,10382,10383,10384,10385,10386,10387,10388,10389,10390,10391,10392,4933, #10240
10393,10394,10395,4934,10396,10397,10398,10399,10400,10401,10402,10403,10404,10405,10406,10407, #10256
10408,10409,10410,10411,10412,3446,10413,10414,10415,10416,10417,10418,10419,10420,10421,10422, #10272
10423,4935,10424,10425,10426,10427,10428,10429,10430,4936,10431,10432,10433,10434,10435,10436, #10288
10437,10438,10439,10440,10441,10442,10443,4937,10444,10445,10446,10447,4481,10448,10449,10450, #10304
10451,10452,10453,10454,10455,10456,10457,10458,10459,10460,10461,10462,10463,10464,10465,10466, #10320
10467,10468,10469,10470,10471,10472,10473,10474,10475,10476,10477,10478,10479,10480,10481,10482, #10336
10483,10484,10485,10486,10487,10488,10489,10490,10491,10492,10493,10494,10495,10496,10497,10498, #10352
10499,10500,10501,10502,10503,10504,10505,4938,10506,10507,10508,10509,10510,2552,10511,10512, #10368
10513,10514,10515,10516,3447,10517,10518,10519,10520,10521,10522,10523,10524,10525,10526,10527, #10384
10528,10529,10530,10531,10532,10533,10534,10535,10536,10537,10538,10539,10540,10541,10542,10543, #10400
4482,10544,4939,10545,10546,10547,10548,10549,10550,10551,10552,10553,10554,10555,10556,10557, #10416
10558,10559,10560,10561,10562,10563,10564,10565,10566,10567,3676,4483,10568,10569,10570,10571, #10432
10572,3448,10573,10574,10575,10576,10577,10578,10579,10580,10581,10582,10583,10584,10585,10586, #10448
10587,10588,10589,10590,10591,10592,10593,10594,10595,10596,10597,10598,10599,10600,10601,10602, #10464
10603,10604,10605,10606,10607,10608,10609,10610,10611,10612,10613,10614,10615,10616,10617,10618, #10480
10619,10620,10621,10622,10623,10624,10625,10626,10627,4484,10628,10629,10630,10631,10632,4940, #10496
10633,10634,10635,10636,10637,10638,10639,10640,10641,10642,10643,10644,10645,10646,10647,10648, #10512
10649,10650,10651,10652,10653,10654,10655,10656,4941,10657,10658,10659,2599,10660,10661,10662, #10528
10663,10664,10665,10666,3089,10667,10668,10669,10670,10671,10672,10673,10674,10675,10676,10677, #10544
10678,10679,10680,4942,10681,10682,10683,10684,10685,10686,10687,10688,10689,10690,10691,10692, #10560
10693,10694,10695,10696,10697,4485,10698,10699,10700,10701,10702,10703,10704,4943,10705,3677, #10576
10706,10707,10708,10709,10710,10711,10712,4944,10713,10714,10715,10716,10717,10718,10719,10720, #10592
10721,10722,10723,10724,10725,10726,10727,10728,4945,10729,10730,10731,10732,10733,10734,10735, #10608
10736,10737,10738,10739,10740,10741,10742,10743,10744,10745,10746,10747,10748,10749,10750,10751, #10624
10752,10753,10754,10755,10756,10757,10758,10759,10760,10761,4946,10762,10763,10764,10765,10766, #10640
10767,4947,4948,10768,10769,10770,10771,10772,10773,10774,10775,10776,10777,10778,10779,10780, #10656
10781,10782,10783,10784,10785,10786,10787,10788,10789,10790,10791,10792,10793,10794,10795,10796, #10672
10797,10798,10799,10800,10801,10802,10803,10804,10805,10806,10807,10808,10809,10810,10811,10812, #10688
10813,10814,10815,10816,10817,10818,10819,10820,10821,10822,10823,10824,10825,10826,10827,10828, #10704
10829,10830,10831,10832,10833,10834,10835,10836,10837,10838,10839,10840,10841,10842,10843,10844, #10720
10845,10846,10847,10848,10849,10850,10851,10852,10853,10854,10855,10856,10857,10858,10859,10860, #10736
10861,10862,10863,10864,10865,10866,10867,10868,10869,10870,10871,10872,10873,10874,10875,10876, #10752
10877,10878,4486,10879,10880,10881,10882,10883,10884,10885,4949,10886,10887,10888,10889,10890, #10768
10891,10892,10893,10894,10895,10896,10897,10898,10899,10900,10901,10902,10903,10904,10905,10906, #10784
10907,10908,10909,10910,10911,10912,10913,10914,10915,10916,10917,10918,10919,4487,10920,10921, #10800
10922,10923,10924,10925,10926,10927,10928,10929,10930,10931,10932,4950,10933,10934,10935,10936, #10816
10937,10938,10939,10940,10941,10942,10943,10944,10945,10946,10947,10948,10949,4488,10950,10951, #10832
10952,10953,10954,10955,10956,10957,10958,10959,4190,10960,10961,10962,10963,10964,10965,10966, #10848
10967,10968,10969,10970,10971,10972,10973,10974,10975,10976,10977,10978,10979,10980,10981,10982, #10864
10983,10984,10985,10986,10987,10988,10989,10990,10991,10992,10993,10994,10995,10996,10997,10998, #10880
10999,11000,11001,11002,11003,11004,11005,11006,3960,11007,11008,11009,11010,11011,11012,11013, #10896
11014,11015,11016,11017,11018,11019,11020,11021,11022,11023,11024,11025,11026,11027,11028,11029, #10912
11030,11031,11032,4951,11033,11034,11035,11036,11037,11038,11039,11040,11041,11042,11043,11044, #10928
11045,11046,11047,4489,11048,11049,11050,11051,4952,11052,11053,11054,11055,11056,11057,11058, #10944
4953,11059,11060,11061,11062,11063,11064,11065,11066,11067,11068,11069,11070,11071,4954,11072, #10960
11073,11074,11075,11076,11077,11078,11079,11080,11081,11082,11083,11084,11085,11086,11087,11088, #10976
11089,11090,11091,11092,11093,11094,11095,11096,11097,11098,11099,11100,11101,11102,11103,11104, #10992
11105,11106,11107,11108,11109,11110,11111,11112,11113,11114,11115,3808,11116,11117,11118,11119, #11008
11120,11121,11122,11123,11124,11125,11126,11127,11128,11129,11130,11131,11132,11133,11134,4955, #11024
11135,11136,11137,11138,11139,11140,11141,11142,11143,11144,11145,11146,11147,11148,11149,11150, #11040
11151,11152,11153,11154,11155,11156,11157,11158,11159,11160,11161,4956,11162,11163,11164,11165, #11056
11166,11167,11168,11169,11170,11171,11172,11173,11174,11175,11176,11177,11178,11179,11180,4957, #11072
11181,11182,11183,11184,11185,11186,4958,11187,11188,11189,11190,11191,11192,11193,11194,11195, #11088
11196,11197,11198,11199,11200,3678,11201,11202,11203,11204,11205,11206,4191,11207,11208,11209, #11104
11210,11211,11212,11213,11214,11215,11216,11217,11218,11219,11220,11221,11222,11223,11224,11225, #11120
11226,11227,11228,11229,11230,11231,11232,11233,11234,11235,11236,11237,11238,11239,11240,11241, #11136
11242,11243,11244,11245,11246,11247,11248,11249,11250,11251,4959,11252,11253,11254,11255,11256, #11152
11257,11258,11259,11260,11261,11262,11263,11264,11265,11266,11267,11268,11269,11270,11271,11272, #11168
11273,11274,11275,11276,11277,11278,11279,11280,11281,11282,11283,11284,11285,11286,11287,11288, #11184
11289,11290,11291,11292,11293,11294,11295,11296,11297,11298,11299,11300,11301,11302,11303,11304, #11200
11305,11306,11307,11308,11309,11310,11311,11312,11313,11314,3679,11315,11316,11317,11318,4490, #11216
11319,11320,11321,11322,11323,11324,11325,11326,11327,11328,11329,11330,11331,11332,11333,11334, #11232
11335,11336,11337,11338,11339,11340,11341,11342,11343,11344,11345,11346,11347,4960,11348,11349, #11248
11350,11351,11352,11353,11354,11355,11356,11357,11358,11359,11360,11361,11362,11363,11364,11365, #11264
11366,11367,11368,11369,11370,11371,11372,11373,11374,11375,11376,11377,3961,4961,11378,11379, #11280
11380,11381,11382,11383,11384,11385,11386,11387,11388,11389,11390,11391,11392,11393,11394,11395, #11296
11396,11397,4192,11398,11399,11400,11401,11402,11403,11404,11405,11406,11407,11408,11409,11410, #11312
11411,4962,11412,11413,11414,11415,11416,11417,11418,11419,11420,11421,11422,11423,11424,11425, #11328
11426,11427,11428,11429,11430,11431,11432,11433,11434,11435,11436,11437,11438,11439,11440,11441, #11344
11442,11443,11444,11445,11446,11447,11448,11449,11450,11451,11452,11453,11454,11455,11456,11457, #11360
11458,11459,11460,11461,11462,11463,11464,11465,11466,11467,11468,11469,4963,11470,11471,4491, #11376
11472,11473,11474,11475,4964,11476,11477,11478,11479,11480,11481,11482,11483,11484,11485,11486, #11392
11487,11488,11489,11490,11491,11492,4965,11493,11494,11495,11496,11497,11498,11499,11500,11501, #11408
11502,11503,11504,11505,11506,11507,11508,11509,11510,11511,11512,11513,11514,11515,11516,11517, #11424
11518,11519,11520,11521,11522,11523,11524,11525,11526,11527,11528,11529,3962,11530,11531,11532, #11440
11533,11534,11535,11536,11537,11538,11539,11540,11541,11542,11543,11544,11545,11546,11547,11548, #11456
11549,11550,11551,11552,11553,11554,11555,11556,11557,11558,11559,11560,11561,11562,11563,11564, #11472
4193,4194,11565,11566,11567,11568,11569,11570,11571,11572,11573,11574,11575,11576,11577,11578, #11488
11579,11580,11581,11582,11583,11584,11585,11586,11587,11588,11589,11590,11591,4966,4195,11592, #11504
11593,11594,11595,11596,11597,11598,11599,11600,11601,11602,11603,11604,3090,11605,11606,11607, #11520
11608,11609,11610,4967,11611,11612,11613,11614,11615,11616,11617,11618,11619,11620,11621,11622, #11536
11623,11624,11625,11626,11627,11628,11629,11630,11631,11632,11633,11634,11635,11636,11637,11638, #11552
11639,11640,11641,11642,11643,11644,11645,11646,11647,11648,11649,11650,11651,11652,11653,11654, #11568
11655,11656,11657,11658,11659,11660,11661,11662,11663,11664,11665,11666,11667,11668,11669,11670, #11584
11671,11672,11673,11674,4968,11675,11676,11677,11678,11679,11680,11681,11682,11683,11684,11685, #11600
11686,11687,11688,11689,11690,11691,11692,11693,3809,11694,11695,11696,11697,11698,11699,11700, #11616
11701,11702,11703,11704,11705,11706,11707,11708,11709,11710,11711,11712,11713,11714,11715,11716, #11632
11717,11718,3553,11719,11720,11721,11722,11723,11724,11725,11726,11727,11728,11729,11730,4969, #11648
11731,11732,11733,11734,11735,11736,11737,11738,11739,11740,4492,11741,11742,11743,11744,11745, #11664
11746,11747,11748,11749,11750,11751,11752,4970,11753,11754,11755,11756,11757,11758,11759,11760, #11680
11761,11762,11763,11764,11765,11766,11767,11768,11769,11770,11771,11772,11773,11774,11775,11776, #11696
11777,11778,11779,11780,11781,11782,11783,11784,11785,11786,11787,11788,11789,11790,4971,11791, #11712
11792,11793,11794,11795,11796,11797,4972,11798,11799,11800,11801,11802,11803,11804,11805,11806, #11728
11807,11808,11809,11810,4973,11811,11812,11813,11814,11815,11816,11817,11818,11819,11820,11821, #11744
11822,11823,11824,11825,11826,11827,11828,11829,11830,11831,11832,11833,11834,3680,3810,11835, #11760
11836,4974,11837,11838,11839,11840,11841,11842,11843,11844,11845,11846,11847,11848,11849,11850, #11776
11851,11852,11853,11854,11855,11856,11857,11858,11859,11860,11861,11862,11863,11864,11865,11866, #11792
11867,11868,11869,11870,11871,11872,11873,11874,11875,11876,11877,11878,11879,11880,11881,11882, #11808
11883,11884,4493,11885,11886,11887,11888,11889,11890,11891,11892,11893,11894,11895,11896,11897, #11824
11898,11899,11900,11901,11902,11903,11904,11905,11906,11907,11908,11909,11910,11911,11912,11913, #11840
11914,11915,4975,11916,11917,11918,11919,11920,11921,11922,11923,11924,11925,11926,11927,11928, #11856
11929,11930,11931,11932,11933,11934,11935,11936,11937,11938,11939,11940,11941,11942,11943,11944, #11872
11945,11946,11947,11948,11949,4976,11950,11951,11952,11953,11954,11955,11956,11957,11958,11959, #11888
11960,11961,11962,11963,11964,11965,11966,11967,11968,11969,11970,11971,11972,11973,11974,11975, #11904
11976,11977,11978,11979,11980,11981,11982,11983,11984,11985,11986,11987,4196,11988,11989,11990, #11920
11991,11992,4977,11993,11994,11995,11996,11997,11998,11999,12000,12001,12002,12003,12004,12005, #11936
12006,12007,12008,12009,12010,12011,12012,12013,12014,12015,12016,12017,12018,12019,12020,12021, #11952
12022,12023,12024,12025,12026,12027,12028,12029,12030,12031,12032,12033,12034,12035,12036,12037, #11968
12038,12039,12040,12041,12042,12043,12044,12045,12046,12047,12048,12049,12050,12051,12052,12053, #11984
12054,12055,12056,12057,12058,12059,12060,12061,4978,12062,12063,12064,12065,12066,12067,12068, #12000
12069,12070,12071,12072,12073,12074,12075,12076,12077,12078,12079,12080,12081,12082,12083,12084, #12016
12085,12086,12087,12088,12089,12090,12091,12092,12093,12094,12095,12096,12097,12098,12099,12100, #12032
12101,12102,12103,12104,12105,12106,12107,12108,12109,12110,12111,12112,12113,12114,12115,12116, #12048
12117,12118,12119,12120,12121,12122,12123,4979,12124,12125,12126,12127,12128,4197,12129,12130, #12064
12131,12132,12133,12134,12135,12136,12137,12138,12139,12140,12141,12142,12143,12144,12145,12146, #12080
12147,12148,12149,12150,12151,12152,12153,12154,4980,12155,12156,12157,12158,12159,12160,4494, #12096
12161,12162,12163,12164,3811,12165,12166,12167,12168,12169,4495,12170,12171,4496,12172,12173, #12112
12174,12175,12176,3812,12177,12178,12179,12180,12181,12182,12183,12184,12185,12186,12187,12188, #12128
12189,12190,12191,12192,12193,12194,12195,12196,12197,12198,12199,12200,12201,12202,12203,12204, #12144
12205,12206,12207,12208,12209,12210,12211,12212,12213,12214,12215,12216,12217,12218,12219,12220, #12160
12221,4981,12222,12223,12224,12225,12226,12227,12228,12229,12230,12231,12232,12233,12234,12235, #12176
4982,12236,12237,12238,12239,12240,12241,12242,12243,12244,12245,4983,12246,12247,12248,12249, #12192
4984,12250,12251,12252,12253,12254,12255,12256,12257,12258,12259,12260,12261,12262,12263,12264, #12208
4985,12265,4497,12266,12267,12268,12269,12270,12271,12272,12273,12274,12275,12276,12277,12278, #12224
12279,12280,12281,12282,12283,12284,12285,12286,12287,4986,12288,12289,12290,12291,12292,12293, #12240
12294,12295,12296,2473,12297,12298,12299,12300,12301,12302,12303,12304,12305,12306,12307,12308, #12256
12309,12310,12311,12312,12313,12314,12315,12316,12317,12318,12319,3963,12320,12321,12322,12323, #12272
12324,12325,12326,12327,12328,12329,12330,12331,12332,4987,12333,12334,12335,12336,12337,12338, #12288
12339,12340,12341,12342,12343,12344,12345,12346,12347,12348,12349,12350,12351,12352,12353,12354, #12304
12355,12356,12357,12358,12359,3964,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369, #12320
12370,3965,12371,12372,12373,12374,12375,12376,12377,12378,12379,12380,12381,12382,12383,12384, #12336
12385,12386,12387,12388,12389,12390,12391,12392,12393,12394,12395,12396,12397,12398,12399,12400, #12352
12401,12402,12403,12404,12405,12406,12407,12408,4988,12409,12410,12411,12412,12413,12414,12415, #12368
12416,12417,12418,12419,12420,12421,12422,12423,12424,12425,12426,12427,12428,12429,12430,12431, #12384
12432,12433,12434,12435,12436,12437,12438,3554,12439,12440,12441,12442,12443,12444,12445,12446, #12400
12447,12448,12449,12450,12451,12452,12453,12454,12455,12456,12457,12458,12459,12460,12461,12462, #12416
12463,12464,4989,12465,12466,12467,12468,12469,12470,12471,12472,12473,12474,12475,12476,12477, #12432
12478,12479,12480,4990,12481,12482,12483,12484,12485,12486,12487,12488,12489,4498,12490,12491, #12448
12492,12493,12494,12495,12496,12497,12498,12499,12500,12501,12502,12503,12504,12505,12506,12507, #12464
12508,12509,12510,12511,12512,12513,12514,12515,12516,12517,12518,12519,12520,12521,12522,12523, #12480
12524,12525,12526,12527,12528,12529,12530,12531,12532,12533,12534,12535,12536,12537,12538,12539, #12496
12540,12541,12542,12543,12544,12545,12546,12547,12548,12549,12550,12551,4991,12552,12553,12554, #12512
12555,12556,12557,12558,12559,12560,12561,12562,12563,12564,12565,12566,12567,12568,12569,12570, #12528
12571,12572,12573,12574,12575,12576,12577,12578,3036,12579,12580,12581,12582,12583,3966,12584, #12544
12585,12586,12587,12588,12589,12590,12591,12592,12593,12594,12595,12596,12597,12598,12599,12600, #12560
12601,12602,12603,12604,12605,12606,12607,12608,12609,12610,12611,12612,12613,12614,12615,12616, #12576
12617,12618,12619,12620,12621,12622,12623,12624,12625,12626,12627,12628,12629,12630,12631,12632, #12592
12633,12634,12635,12636,12637,12638,12639,12640,12641,12642,12643,12644,12645,12646,4499,12647, #12608
12648,12649,12650,12651,12652,12653,12654,12655,12656,12657,12658,12659,12660,12661,12662,12663, #12624
12664,12665,12666,12667,12668,12669,12670,12671,12672,12673,12674,12675,12676,12677,12678,12679, #12640
12680,12681,12682,12683,12684,12685,12686,12687,12688,12689,12690,12691,12692,12693,12694,12695, #12656
12696,12697,12698,4992,12699,12700,12701,12702,12703,12704,12705,12706,12707,12708,12709,12710, #12672
12711,12712,12713,12714,12715,12716,12717,12718,12719,12720,12721,12722,12723,12724,12725,12726, #12688
12727,12728,12729,12730,12731,12732,12733,12734,12735,12736,12737,12738,12739,12740,12741,12742, #12704
12743,12744,12745,12746,12747,12748,12749,12750,12751,12752,12753,12754,12755,12756,12757,12758, #12720
12759,12760,12761,12762,12763,12764,12765,12766,12767,12768,12769,12770,12771,12772,12773,12774, #12736
12775,12776,12777,12778,4993,2175,12779,12780,12781,12782,12783,12784,12785,12786,4500,12787, #12752
12788,12789,12790,12791,12792,12793,12794,12795,12796,12797,12798,12799,12800,12801,12802,12803, #12768
12804,12805,12806,12807,12808,12809,12810,12811,12812,12813,12814,12815,12816,12817,12818,12819, #12784
12820,12821,12822,12823,12824,12825,12826,4198,3967,12827,12828,12829,12830,12831,12832,12833, #12800
12834,12835,12836,12837,12838,12839,12840,12841,12842,12843,12844,12845,12846,12847,12848,12849, #12816
12850,12851,12852,12853,12854,12855,12856,12857,12858,12859,12860,12861,4199,12862,12863,12864, #12832
12865,12866,12867,12868,12869,12870,12871,12872,12873,12874,12875,12876,12877,12878,12879,12880, #12848
12881,12882,12883,12884,12885,12886,12887,4501,12888,12889,12890,12891,12892,12893,12894,12895, #12864
12896,12897,12898,12899,12900,12901,12902,12903,12904,12905,12906,12907,12908,12909,12910,12911, #12880
12912,4994,12913,12914,12915,12916,12917,12918,12919,12920,12921,12922,12923,12924,12925,12926, #12896
12927,12928,12929,12930,12931,12932,12933,12934,12935,12936,12937,12938,12939,12940,12941,12942, #12912
12943,12944,12945,12946,12947,12948,12949,12950,12951,12952,12953,12954,12955,12956,1772,12957, #12928
12958,12959,12960,12961,12962,12963,12964,12965,12966,12967,12968,12969,12970,12971,12972,12973, #12944
12974,12975,12976,12977,12978,12979,12980,12981,12982,12983,12984,12985,12986,12987,12988,12989, #12960
12990,12991,12992,12993,12994,12995,12996,12997,4502,12998,4503,12999,13000,13001,13002,13003, #12976
4504,13004,13005,13006,13007,13008,13009,13010,13011,13012,13013,13014,13015,13016,13017,13018, #12992
13019,13020,13021,13022,13023,13024,13025,13026,13027,13028,13029,3449,13030,13031,13032,13033, #13008
13034,13035,13036,13037,13038,13039,13040,13041,13042,13043,13044,13045,13046,13047,13048,13049, #13024
13050,13051,13052,13053,13054,13055,13056,13057,13058,13059,13060,13061,13062,13063,13064,13065, #13040
13066,13067,13068,13069,13070,13071,13072,13073,13074,13075,13076,13077,13078,13079,13080,13081, #13056
13082,13083,13084,13085,13086,13087,13088,13089,13090,13091,13092,13093,13094,13095,13096,13097, #13072
13098,13099,13100,13101,13102,13103,13104,13105,13106,13107,13108,13109,13110,13111,13112,13113, #13088
13114,13115,13116,13117,13118,3968,13119,4995,13120,13121,13122,13123,13124,13125,13126,13127, #13104
4505,13128,13129,13130,13131,13132,13133,13134,4996,4506,13135,13136,13137,13138,13139,4997, #13120
13140,13141,13142,13143,13144,13145,13146,13147,13148,13149,13150,13151,13152,13153,13154,13155, #13136
13156,13157,13158,13159,4998,13160,13161,13162,13163,13164,13165,13166,13167,13168,13169,13170, #13152
13171,13172,13173,13174,13175,13176,4999,13177,13178,13179,13180,13181,13182,13183,13184,13185, #13168
13186,13187,13188,13189,13190,13191,13192,13193,13194,13195,13196,13197,13198,13199,13200,13201, #13184
13202,13203,13204,13205,13206,5000,13207,13208,13209,13210,13211,13212,13213,13214,13215,13216, #13200
13217,13218,13219,13220,13221,13222,13223,13224,13225,13226,13227,4200,5001,13228,13229,13230, #13216
13231,13232,13233,13234,13235,13236,13237,13238,13239,13240,3969,13241,13242,13243,13244,3970, #13232
13245,13246,13247,13248,13249,13250,13251,13252,13253,13254,13255,13256,13257,13258,13259,13260, #13248
13261,13262,13263,13264,13265,13266,13267,13268,3450,13269,13270,13271,13272,13273,13274,13275, #13264
13276,5002,13277,13278,13279,13280,13281,13282,13283,13284,13285,13286,13287,13288,13289,13290, #13280
13291,13292,13293,13294,13295,13296,13297,13298,13299,13300,13301,13302,3813,13303,13304,13305, #13296
13306,13307,13308,13309,13310,13311,13312,13313,13314,13315,13316,13317,13318,13319,13320,13321, #13312
13322,13323,13324,13325,13326,13327,13328,4507,13329,13330,13331,13332,13333,13334,13335,13336, #13328
13337,13338,13339,13340,13341,5003,13342,13343,13344,13345,13346,13347,13348,13349,13350,13351, #13344
13352,13353,13354,13355,13356,13357,13358,13359,13360,13361,13362,13363,13364,13365,13366,13367, #13360
5004,13368,13369,13370,13371,13372,13373,13374,13375,13376,13377,13378,13379,13380,13381,13382, #13376
13383,13384,13385,13386,13387,13388,13389,13390,13391,13392,13393,13394,13395,13396,13397,13398, #13392
13399,13400,13401,13402,13403,13404,13405,13406,13407,13408,13409,13410,13411,13412,13413,13414, #13408
13415,13416,13417,13418,13419,13420,13421,13422,13423,13424,13425,13426,13427,13428,13429,13430, #13424
13431,13432,4508,13433,13434,13435,4201,13436,13437,13438,13439,13440,13441,13442,13443,13444, #13440
13445,13446,13447,13448,13449,13450,13451,13452,13453,13454,13455,13456,13457,5005,13458,13459, #13456
13460,13461,13462,13463,13464,13465,13466,13467,13468,13469,13470,4509,13471,13472,13473,13474, #13472
13475,13476,13477,13478,13479,13480,13481,13482,13483,13484,13485,13486,13487,13488,13489,13490, #13488
13491,13492,13493,13494,13495,13496,13497,13498,13499,13500,13501,13502,13503,13504,13505,13506, #13504
13507,13508,13509,13510,13511,13512,13513,13514,13515,13516,13517,13518,13519,13520,13521,13522, #13520
13523,13524,13525,13526,13527,13528,13529,13530,13531,13532,13533,13534,13535,13536,13537,13538, #13536
13539,13540,13541,13542,13543,13544,13545,13546,13547,13548,13549,13550,13551,13552,13553,13554, #13552
13555,13556,13557,13558,13559,13560,13561,13562,13563,13564,13565,13566,13567,13568,13569,13570, #13568
13571,13572,13573,13574,13575,13576,13577,13578,13579,13580,13581,13582,13583,13584,13585,13586, #13584
13587,13588,13589,13590,13591,13592,13593,13594,13595,13596,13597,13598,13599,13600,13601,13602, #13600
13603,13604,13605,13606,13607,13608,13609,13610,13611,13612,13613,13614,13615,13616,13617,13618, #13616
13619,13620,13621,13622,13623,13624,13625,13626,13627,13628,13629,13630,13631,13632,13633,13634, #13632
13635,13636,13637,13638,13639,13640,13641,13642,5006,13643,13644,13645,13646,13647,13648,13649, #13648
13650,13651,5007,13652,13653,13654,13655,13656,13657,13658,13659,13660,13661,13662,13663,13664, #13664
13665,13666,13667,13668,13669,13670,13671,13672,13673,13674,13675,13676,13677,13678,13679,13680, #13680
13681,13682,13683,13684,13685,13686,13687,13688,13689,13690,13691,13692,13693,13694,13695,13696, #13696
13697,13698,13699,13700,13701,13702,13703,13704,13705,13706,13707,13708,13709,13710,13711,13712, #13712
13713,13714,13715,13716,13717,13718,13719,13720,13721,13722,13723,13724,13725,13726,13727,13728, #13728
13729,13730,13731,13732,13733,13734,13735,13736,13737,13738,13739,13740,13741,13742,13743,13744, #13744
13745,13746,13747,13748,13749,13750,13751,13752,13753,13754,13755,13756,13757,13758,13759,13760, #13760
13761,13762,13763,13764,13765,13766,13767,13768,13769,13770,13771,13772,13773,13774,3273,13775, #13776
13776,13777,13778,13779,13780,13781,13782,13783,13784,13785,13786,13787,13788,13789,13790,13791, #13792
13792,13793,13794,13795,13796,13797,13798,13799,13800,13801,13802,13803,13804,13805,13806,13807, #13808
13808,13809,13810,13811,13812,13813,13814,13815,13816,13817,13818,13819,13820,13821,13822,13823, #13824
13824,13825,13826,13827,13828,13829,13830,13831,13832,13833,13834,13835,13836,13837,13838,13839, #13840
13840,13841,13842,13843,13844,13845,13846,13847,13848,13849,13850,13851,13852,13853,13854,13855, #13856
13856,13857,13858,13859,13860,13861,13862,13863,13864,13865,13866,13867,13868,13869,13870,13871, #13872
13872,13873,13874,13875,13876,13877,13878,13879,13880,13881,13882,13883,13884,13885,13886,13887, #13888
13888,13889,13890,13891,13892,13893,13894,13895,13896,13897,13898,13899,13900,13901,13902,13903, #13904
13904,13905,13906,13907,13908,13909,13910,13911,13912,13913,13914,13915,13916,13917,13918,13919, #13920
13920,13921,13922,13923,13924,13925,13926,13927,13928,13929,13930,13931,13932,13933,13934,13935, #13936
13936,13937,13938,13939,13940,13941,13942,13943,13944,13945,13946,13947,13948,13949,13950,13951, #13952
13952,13953,13954,13955,13956,13957,13958,13959,13960,13961,13962,13963,13964,13965,13966,13967, #13968
13968,13969,13970,13971,13972) #13973

# flake8: noqa

########NEW FILE########
__FILENAME__ = big5prober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import Big5DistributionAnalysis
from .mbcssm import Big5SMModel


class Big5Prober(MultiByteCharSetProber):
    def __init__(self):
        MultiByteCharSetProber.__init__(self)
        self._mCodingSM = CodingStateMachine(Big5SMModel)
        self._mDistributionAnalyzer = Big5DistributionAnalysis()
        self.reset()

    def get_charset_name(self):
        return "Big5"

########NEW FILE########
__FILENAME__ = chardetect
#!/usr/bin/env python
"""
Script which takes one or more file paths and reports on their detected
encodings

Example::

    % chardetect somefile someotherfile
    somefile: windows-1252 with confidence 0.5
    someotherfile: ascii with confidence 1.0

If no paths are provided, it takes its input from stdin.

"""
from io import open
from sys import argv, stdin

from chardet.universaldetector import UniversalDetector


def description_of(file, name='stdin'):
    """Return a string describing the probable encoding of a file."""
    u = UniversalDetector()
    for line in file:
        u.feed(line)
    u.close()
    result = u.result
    if result['encoding']:
        return '%s: %s with confidence %s' % (name,
                                              result['encoding'],
                                              result['confidence'])
    else:
        return '%s: no result' % name


def main():
    if len(argv) <= 1:
        print(description_of(stdin))
    else:
        for path in argv[1:]:
            with open(path, 'rb') as f:
                print(description_of(f, path))


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = chardistribution
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .euctwfreq import (EUCTWCharToFreqOrder, EUCTW_TABLE_SIZE,
                        EUCTW_TYPICAL_DISTRIBUTION_RATIO)
from .euckrfreq import (EUCKRCharToFreqOrder, EUCKR_TABLE_SIZE,
                        EUCKR_TYPICAL_DISTRIBUTION_RATIO)
from .gb2312freq import (GB2312CharToFreqOrder, GB2312_TABLE_SIZE,
                         GB2312_TYPICAL_DISTRIBUTION_RATIO)
from .big5freq import (Big5CharToFreqOrder, BIG5_TABLE_SIZE,
                       BIG5_TYPICAL_DISTRIBUTION_RATIO)
from .jisfreq import (JISCharToFreqOrder, JIS_TABLE_SIZE,
                      JIS_TYPICAL_DISTRIBUTION_RATIO)
from .compat import wrap_ord

ENOUGH_DATA_THRESHOLD = 1024
SURE_YES = 0.99
SURE_NO = 0.01
MINIMUM_DATA_THRESHOLD = 3


class CharDistributionAnalysis:
    def __init__(self):
        # Mapping table to get frequency order from char order (get from
        # GetOrder())
        self._mCharToFreqOrder = None
        self._mTableSize = None  # Size of above table
        # This is a constant value which varies from language to language,
        # used in calculating confidence.  See
        # http://www.mozilla.org/projects/intl/UniversalCharsetDetection.html
        # for further detail.
        self._mTypicalDistributionRatio = None
        self.reset()

    def reset(self):
        """reset analyser, clear any state"""
        # If this flag is set to True, detection is done and conclusion has
        # been made
        self._mDone = False
        self._mTotalChars = 0  # Total characters encountered
        # The number of characters whose frequency order is less than 512
        self._mFreqChars = 0

    def feed(self, aBuf, aCharLen):
        """feed a character with known length"""
        if aCharLen == 2:
            # we only care about 2-bytes character in our distribution analysis
            order = self.get_order(aBuf)
        else:
            order = -1
        if order >= 0:
            self._mTotalChars += 1
            # order is valid
            if order < self._mTableSize:
                if 512 > self._mCharToFreqOrder[order]:
                    self._mFreqChars += 1

    def get_confidence(self):
        """return confidence based on existing data"""
        # if we didn't receive any character in our consideration range,
        # return negative answer
        if self._mTotalChars <= 0 or self._mFreqChars <= MINIMUM_DATA_THRESHOLD:
            return SURE_NO

        if self._mTotalChars != self._mFreqChars:
            r = (self._mFreqChars / ((self._mTotalChars - self._mFreqChars)
                 * self._mTypicalDistributionRatio))
            if r < SURE_YES:
                return r

        # normalize confidence (we don't want to be 100% sure)
        return SURE_YES

    def got_enough_data(self):
        # It is not necessary to receive all data to draw conclusion.
        # For charset detection, certain amount of data is enough
        return self._mTotalChars > ENOUGH_DATA_THRESHOLD

    def get_order(self, aBuf):
        # We do not handle characters based on the original encoding string,
        # but convert this encoding string to a number, here called order.
        # This allows multiple encodings of a language to share one frequency
        # table.
        return -1


class EUCTWDistributionAnalysis(CharDistributionAnalysis):
    def __init__(self):
        CharDistributionAnalysis.__init__(self)
        self._mCharToFreqOrder = EUCTWCharToFreqOrder
        self._mTableSize = EUCTW_TABLE_SIZE
        self._mTypicalDistributionRatio = EUCTW_TYPICAL_DISTRIBUTION_RATIO

    def get_order(self, aBuf):
        # for euc-TW encoding, we are interested
        #   first  byte range: 0xc4 -- 0xfe
        #   second byte range: 0xa1 -- 0xfe
        # no validation needed here. State machine has done that
        first_char = wrap_ord(aBuf[0])
        if first_char >= 0xC4:
            return 94 * (first_char - 0xC4) + wrap_ord(aBuf[1]) - 0xA1
        else:
            return -1


class EUCKRDistributionAnalysis(CharDistributionAnalysis):
    def __init__(self):
        CharDistributionAnalysis.__init__(self)
        self._mCharToFreqOrder = EUCKRCharToFreqOrder
        self._mTableSize = EUCKR_TABLE_SIZE
        self._mTypicalDistributionRatio = EUCKR_TYPICAL_DISTRIBUTION_RATIO

    def get_order(self, aBuf):
        # for euc-KR encoding, we are interested
        #   first  byte range: 0xb0 -- 0xfe
        #   second byte range: 0xa1 -- 0xfe
        # no validation needed here. State machine has done that
        first_char = wrap_ord(aBuf[0])
        if first_char >= 0xB0:
            return 94 * (first_char - 0xB0) + wrap_ord(aBuf[1]) - 0xA1
        else:
            return -1


class GB2312DistributionAnalysis(CharDistributionAnalysis):
    def __init__(self):
        CharDistributionAnalysis.__init__(self)
        self._mCharToFreqOrder = GB2312CharToFreqOrder
        self._mTableSize = GB2312_TABLE_SIZE
        self._mTypicalDistributionRatio = GB2312_TYPICAL_DISTRIBUTION_RATIO

    def get_order(self, aBuf):
        # for GB2312 encoding, we are interested
        #  first  byte range: 0xb0 -- 0xfe
        #  second byte range: 0xa1 -- 0xfe
        # no validation needed here. State machine has done that
        first_char, second_char = wrap_ord(aBuf[0]), wrap_ord(aBuf[1])
        if (first_char >= 0xB0) and (second_char >= 0xA1):
            return 94 * (first_char - 0xB0) + second_char - 0xA1
        else:
            return -1


class Big5DistributionAnalysis(CharDistributionAnalysis):
    def __init__(self):
        CharDistributionAnalysis.__init__(self)
        self._mCharToFreqOrder = Big5CharToFreqOrder
        self._mTableSize = BIG5_TABLE_SIZE
        self._mTypicalDistributionRatio = BIG5_TYPICAL_DISTRIBUTION_RATIO

    def get_order(self, aBuf):
        # for big5 encoding, we are interested
        #   first  byte range: 0xa4 -- 0xfe
        #   second byte range: 0x40 -- 0x7e , 0xa1 -- 0xfe
        # no validation needed here. State machine has done that
        first_char, second_char = wrap_ord(aBuf[0]), wrap_ord(aBuf[1])
        if first_char >= 0xA4:
            if second_char >= 0xA1:
                return 157 * (first_char - 0xA4) + second_char - 0xA1 + 63
            else:
                return 157 * (first_char - 0xA4) + second_char - 0x40
        else:
            return -1


class SJISDistributionAnalysis(CharDistributionAnalysis):
    def __init__(self):
        CharDistributionAnalysis.__init__(self)
        self._mCharToFreqOrder = JISCharToFreqOrder
        self._mTableSize = JIS_TABLE_SIZE
        self._mTypicalDistributionRatio = JIS_TYPICAL_DISTRIBUTION_RATIO

    def get_order(self, aBuf):
        # for sjis encoding, we are interested
        #   first  byte range: 0x81 -- 0x9f , 0xe0 -- 0xfe
        #   second byte range: 0x40 -- 0x7e,  0x81 -- oxfe
        # no validation needed here. State machine has done that
        first_char, second_char = wrap_ord(aBuf[0]), wrap_ord(aBuf[1])
        if (first_char >= 0x81) and (first_char <= 0x9F):
            order = 188 * (first_char - 0x81)
        elif (first_char >= 0xE0) and (first_char <= 0xEF):
            order = 188 * (first_char - 0xE0 + 31)
        else:
            return -1
        order = order + second_char - 0x40
        if second_char > 0x7F:
            order = -1
        return order


class EUCJPDistributionAnalysis(CharDistributionAnalysis):
    def __init__(self):
        CharDistributionAnalysis.__init__(self)
        self._mCharToFreqOrder = JISCharToFreqOrder
        self._mTableSize = JIS_TABLE_SIZE
        self._mTypicalDistributionRatio = JIS_TYPICAL_DISTRIBUTION_RATIO

    def get_order(self, aBuf):
        # for euc-JP encoding, we are interested
        #   first  byte range: 0xa0 -- 0xfe
        #   second byte range: 0xa1 -- 0xfe
        # no validation needed here. State machine has done that
        char = wrap_ord(aBuf[0])
        if char >= 0xA0:
            return 94 * (char - 0xA1) + wrap_ord(aBuf[1]) - 0xa1
        else:
            return -1

########NEW FILE########
__FILENAME__ = charsetgroupprober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
# 
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
# 
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from . import constants
import sys
from .charsetprober import CharSetProber


class CharSetGroupProber(CharSetProber):
    def __init__(self):
        CharSetProber.__init__(self)
        self._mActiveNum = 0
        self._mProbers = []
        self._mBestGuessProber = None

    def reset(self):
        CharSetProber.reset(self)
        self._mActiveNum = 0
        for prober in self._mProbers:
            if prober:
                prober.reset()
                prober.active = True
                self._mActiveNum += 1
        self._mBestGuessProber = None

    def get_charset_name(self):
        if not self._mBestGuessProber:
            self.get_confidence()
            if not self._mBestGuessProber:
                return None
#                self._mBestGuessProber = self._mProbers[0]
        return self._mBestGuessProber.get_charset_name()

    def feed(self, aBuf):
        for prober in self._mProbers:
            if not prober:
                continue
            if not prober.active:
                continue
            st = prober.feed(aBuf)
            if not st:
                continue
            if st == constants.eFoundIt:
                self._mBestGuessProber = prober
                return self.get_state()
            elif st == constants.eNotMe:
                prober.active = False
                self._mActiveNum -= 1
                if self._mActiveNum <= 0:
                    self._mState = constants.eNotMe
                    return self.get_state()
        return self.get_state()

    def get_confidence(self):
        st = self.get_state()
        if st == constants.eFoundIt:
            return 0.99
        elif st == constants.eNotMe:
            return 0.01
        bestConf = 0.0
        self._mBestGuessProber = None
        for prober in self._mProbers:
            if not prober:
                continue
            if not prober.active:
                if constants._debug:
                    sys.stderr.write(prober.get_charset_name()
                                     + ' not active\n')
                continue
            cf = prober.get_confidence()
            if constants._debug:
                sys.stderr.write('%s confidence = %s\n' %
                                 (prober.get_charset_name(), cf))
            if bestConf < cf:
                bestConf = cf
                self._mBestGuessProber = prober
        if not self._mBestGuessProber:
            return 0.0
        return bestConf
#        else:
#            self._mBestGuessProber = self._mProbers[0]
#            return self._mBestGuessProber.get_confidence()

########NEW FILE########
__FILENAME__ = charsetprober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from . import constants
import re


class CharSetProber:
    def __init__(self):
        pass

    def reset(self):
        self._mState = constants.eDetecting

    def get_charset_name(self):
        return None

    def feed(self, aBuf):
        pass

    def get_state(self):
        return self._mState

    def get_confidence(self):
        return 0.0

    def filter_high_bit_only(self, aBuf):
        aBuf = re.sub(b'([\x00-\x7F])+', b' ', aBuf)
        return aBuf

    def filter_without_english_letters(self, aBuf):
        aBuf = re.sub(b'([A-Za-z])+', b' ', aBuf)
        return aBuf

    def filter_with_english_letters(self, aBuf):
        # TODO
        return aBuf

########NEW FILE########
__FILENAME__ = codingstatemachine
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .constants import eStart
from .compat import wrap_ord


class CodingStateMachine:
    def __init__(self, sm):
        self._mModel = sm
        self._mCurrentBytePos = 0
        self._mCurrentCharLen = 0
        self.reset()

    def reset(self):
        self._mCurrentState = eStart

    def next_state(self, c):
        # for each byte we get its class
        # if it is first byte, we also get byte length
        # PY3K: aBuf is a byte stream, so c is an int, not a byte
        byteCls = self._mModel['classTable'][wrap_ord(c)]
        if self._mCurrentState == eStart:
            self._mCurrentBytePos = 0
            self._mCurrentCharLen = self._mModel['charLenTable'][byteCls]
        # from byte's class and stateTable, we get its next state
        curr_state = (self._mCurrentState * self._mModel['classFactor']
                      + byteCls)
        self._mCurrentState = self._mModel['stateTable'][curr_state]
        self._mCurrentBytePos += 1
        return self._mCurrentState

    def get_current_charlen(self):
        return self._mCurrentCharLen

    def get_coding_state_machine(self):
        return self._mModel['name']

########NEW FILE########
__FILENAME__ = compat
######################## BEGIN LICENSE BLOCK ########################
# Contributor(s):
#   Ian Cordasco - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

import sys


if sys.version_info < (3, 0):
    base_str = (str, unicode)
else:
    base_str = (bytes, str)


def wrap_ord(a):
    if sys.version_info < (3, 0) and isinstance(a, base_str):
        return ord(a)
    else:
        return a

########NEW FILE########
__FILENAME__ = constants
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

_debug = 0

eDetecting = 0
eFoundIt = 1
eNotMe = 2

eStart = 0
eError = 1
eItsMe = 2

SHORTCUT_THRESHOLD = 0.95

########NEW FILE########
__FILENAME__ = cp949prober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import EUCKRDistributionAnalysis
from .mbcssm import CP949SMModel


class CP949Prober(MultiByteCharSetProber):
    def __init__(self):
        MultiByteCharSetProber.__init__(self)
        self._mCodingSM = CodingStateMachine(CP949SMModel)
        # NOTE: CP949 is a superset of EUC-KR, so the distribution should be
        #       not different.
        self._mDistributionAnalyzer = EUCKRDistributionAnalysis()
        self.reset()

    def get_charset_name(self):
        return "CP949"

########NEW FILE########
__FILENAME__ = escprober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from . import constants
from .escsm import (HZSMModel, ISO2022CNSMModel, ISO2022JPSMModel,
                    ISO2022KRSMModel)
from .charsetprober import CharSetProber
from .codingstatemachine import CodingStateMachine
from .compat import wrap_ord


class EscCharSetProber(CharSetProber):
    def __init__(self):
        CharSetProber.__init__(self)
        self._mCodingSM = [
            CodingStateMachine(HZSMModel),
            CodingStateMachine(ISO2022CNSMModel),
            CodingStateMachine(ISO2022JPSMModel),
            CodingStateMachine(ISO2022KRSMModel)
        ]
        self.reset()

    def reset(self):
        CharSetProber.reset(self)
        for codingSM in self._mCodingSM:
            if not codingSM:
                continue
            codingSM.active = True
            codingSM.reset()
        self._mActiveSM = len(self._mCodingSM)
        self._mDetectedCharset = None

    def get_charset_name(self):
        return self._mDetectedCharset

    def get_confidence(self):
        if self._mDetectedCharset:
            return 0.99
        else:
            return 0.00

    def feed(self, aBuf):
        for c in aBuf:
            # PY3K: aBuf is a byte array, so c is an int, not a byte
            for codingSM in self._mCodingSM:
                if not codingSM:
                    continue
                if not codingSM.active:
                    continue
                codingState = codingSM.next_state(wrap_ord(c))
                if codingState == constants.eError:
                    codingSM.active = False
                    self._mActiveSM -= 1
                    if self._mActiveSM <= 0:
                        self._mState = constants.eNotMe
                        return self.get_state()
                elif codingState == constants.eItsMe:
                    self._mState = constants.eFoundIt
                    self._mDetectedCharset = codingSM.get_coding_state_machine()  # nopep8
                    return self.get_state()

        return self.get_state()

########NEW FILE########
__FILENAME__ = escsm
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .constants import eStart, eError, eItsMe

HZ_cls = (
1,0,0,0,0,0,0,0,  # 00 - 07
0,0,0,0,0,0,0,0,  # 08 - 0f
0,0,0,0,0,0,0,0,  # 10 - 17
0,0,0,1,0,0,0,0,  # 18 - 1f
0,0,0,0,0,0,0,0,  # 20 - 27
0,0,0,0,0,0,0,0,  # 28 - 2f
0,0,0,0,0,0,0,0,  # 30 - 37
0,0,0,0,0,0,0,0,  # 38 - 3f
0,0,0,0,0,0,0,0,  # 40 - 47
0,0,0,0,0,0,0,0,  # 48 - 4f
0,0,0,0,0,0,0,0,  # 50 - 57
0,0,0,0,0,0,0,0,  # 58 - 5f
0,0,0,0,0,0,0,0,  # 60 - 67
0,0,0,0,0,0,0,0,  # 68 - 6f
0,0,0,0,0,0,0,0,  # 70 - 77
0,0,0,4,0,5,2,0,  # 78 - 7f
1,1,1,1,1,1,1,1,  # 80 - 87
1,1,1,1,1,1,1,1,  # 88 - 8f
1,1,1,1,1,1,1,1,  # 90 - 97
1,1,1,1,1,1,1,1,  # 98 - 9f
1,1,1,1,1,1,1,1,  # a0 - a7
1,1,1,1,1,1,1,1,  # a8 - af
1,1,1,1,1,1,1,1,  # b0 - b7
1,1,1,1,1,1,1,1,  # b8 - bf
1,1,1,1,1,1,1,1,  # c0 - c7
1,1,1,1,1,1,1,1,  # c8 - cf
1,1,1,1,1,1,1,1,  # d0 - d7
1,1,1,1,1,1,1,1,  # d8 - df
1,1,1,1,1,1,1,1,  # e0 - e7
1,1,1,1,1,1,1,1,  # e8 - ef
1,1,1,1,1,1,1,1,  # f0 - f7
1,1,1,1,1,1,1,1,  # f8 - ff
)

HZ_st = (
eStart,eError,     3,eStart,eStart,eStart,eError,eError,# 00-07
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,# 08-0f
eItsMe,eItsMe,eError,eError,eStart,eStart,     4,eError,# 10-17
     5,eError,     6,eError,     5,     5,     4,eError,# 18-1f
     4,eError,     4,     4,     4,eError,     4,eError,# 20-27
     4,eItsMe,eStart,eStart,eStart,eStart,eStart,eStart,# 28-2f
)

HZCharLenTable = (0, 0, 0, 0, 0, 0)

HZSMModel = {'classTable': HZ_cls,
             'classFactor': 6,
             'stateTable': HZ_st,
             'charLenTable': HZCharLenTable,
             'name': "HZ-GB-2312"}

ISO2022CN_cls = (
2,0,0,0,0,0,0,0,  # 00 - 07
0,0,0,0,0,0,0,0,  # 08 - 0f
0,0,0,0,0,0,0,0,  # 10 - 17
0,0,0,1,0,0,0,0,  # 18 - 1f
0,0,0,0,0,0,0,0,  # 20 - 27
0,3,0,0,0,0,0,0,  # 28 - 2f
0,0,0,0,0,0,0,0,  # 30 - 37
0,0,0,0,0,0,0,0,  # 38 - 3f
0,0,0,4,0,0,0,0,  # 40 - 47
0,0,0,0,0,0,0,0,  # 48 - 4f
0,0,0,0,0,0,0,0,  # 50 - 57
0,0,0,0,0,0,0,0,  # 58 - 5f
0,0,0,0,0,0,0,0,  # 60 - 67
0,0,0,0,0,0,0,0,  # 68 - 6f
0,0,0,0,0,0,0,0,  # 70 - 77
0,0,0,0,0,0,0,0,  # 78 - 7f
2,2,2,2,2,2,2,2,  # 80 - 87
2,2,2,2,2,2,2,2,  # 88 - 8f
2,2,2,2,2,2,2,2,  # 90 - 97
2,2,2,2,2,2,2,2,  # 98 - 9f
2,2,2,2,2,2,2,2,  # a0 - a7
2,2,2,2,2,2,2,2,  # a8 - af
2,2,2,2,2,2,2,2,  # b0 - b7
2,2,2,2,2,2,2,2,  # b8 - bf
2,2,2,2,2,2,2,2,  # c0 - c7
2,2,2,2,2,2,2,2,  # c8 - cf
2,2,2,2,2,2,2,2,  # d0 - d7
2,2,2,2,2,2,2,2,  # d8 - df
2,2,2,2,2,2,2,2,  # e0 - e7
2,2,2,2,2,2,2,2,  # e8 - ef
2,2,2,2,2,2,2,2,  # f0 - f7
2,2,2,2,2,2,2,2,  # f8 - ff
)

ISO2022CN_st = (
eStart,     3,eError,eStart,eStart,eStart,eStart,eStart,# 00-07
eStart,eError,eError,eError,eError,eError,eError,eError,# 08-0f
eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,# 10-17
eItsMe,eItsMe,eItsMe,eError,eError,eError,     4,eError,# 18-1f
eError,eError,eError,eItsMe,eError,eError,eError,eError,# 20-27
     5,     6,eError,eError,eError,eError,eError,eError,# 28-2f
eError,eError,eError,eItsMe,eError,eError,eError,eError,# 30-37
eError,eError,eError,eError,eError,eItsMe,eError,eStart,# 38-3f
)

ISO2022CNCharLenTable = (0, 0, 0, 0, 0, 0, 0, 0, 0)

ISO2022CNSMModel = {'classTable': ISO2022CN_cls,
                    'classFactor': 9,
                    'stateTable': ISO2022CN_st,
                    'charLenTable': ISO2022CNCharLenTable,
                    'name': "ISO-2022-CN"}

ISO2022JP_cls = (
2,0,0,0,0,0,0,0,  # 00 - 07
0,0,0,0,0,0,2,2,  # 08 - 0f
0,0,0,0,0,0,0,0,  # 10 - 17
0,0,0,1,0,0,0,0,  # 18 - 1f
0,0,0,0,7,0,0,0,  # 20 - 27
3,0,0,0,0,0,0,0,  # 28 - 2f
0,0,0,0,0,0,0,0,  # 30 - 37
0,0,0,0,0,0,0,0,  # 38 - 3f
6,0,4,0,8,0,0,0,  # 40 - 47
0,9,5,0,0,0,0,0,  # 48 - 4f
0,0,0,0,0,0,0,0,  # 50 - 57
0,0,0,0,0,0,0,0,  # 58 - 5f
0,0,0,0,0,0,0,0,  # 60 - 67
0,0,0,0,0,0,0,0,  # 68 - 6f
0,0,0,0,0,0,0,0,  # 70 - 77
0,0,0,0,0,0,0,0,  # 78 - 7f
2,2,2,2,2,2,2,2,  # 80 - 87
2,2,2,2,2,2,2,2,  # 88 - 8f
2,2,2,2,2,2,2,2,  # 90 - 97
2,2,2,2,2,2,2,2,  # 98 - 9f
2,2,2,2,2,2,2,2,  # a0 - a7
2,2,2,2,2,2,2,2,  # a8 - af
2,2,2,2,2,2,2,2,  # b0 - b7
2,2,2,2,2,2,2,2,  # b8 - bf
2,2,2,2,2,2,2,2,  # c0 - c7
2,2,2,2,2,2,2,2,  # c8 - cf
2,2,2,2,2,2,2,2,  # d0 - d7
2,2,2,2,2,2,2,2,  # d8 - df
2,2,2,2,2,2,2,2,  # e0 - e7
2,2,2,2,2,2,2,2,  # e8 - ef
2,2,2,2,2,2,2,2,  # f0 - f7
2,2,2,2,2,2,2,2,  # f8 - ff
)

ISO2022JP_st = (
eStart,     3,eError,eStart,eStart,eStart,eStart,eStart,# 00-07
eStart,eStart,eError,eError,eError,eError,eError,eError,# 08-0f
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,# 10-17
eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eError,eError,# 18-1f
eError,     5,eError,eError,eError,     4,eError,eError,# 20-27
eError,eError,eError,     6,eItsMe,eError,eItsMe,eError,# 28-2f
eError,eError,eError,eError,eError,eError,eItsMe,eItsMe,# 30-37
eError,eError,eError,eItsMe,eError,eError,eError,eError,# 38-3f
eError,eError,eError,eError,eItsMe,eError,eStart,eStart,# 40-47
)

ISO2022JPCharLenTable = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0)

ISO2022JPSMModel = {'classTable': ISO2022JP_cls,
                    'classFactor': 10,
                    'stateTable': ISO2022JP_st,
                    'charLenTable': ISO2022JPCharLenTable,
                    'name': "ISO-2022-JP"}

ISO2022KR_cls = (
2,0,0,0,0,0,0,0,  # 00 - 07
0,0,0,0,0,0,0,0,  # 08 - 0f
0,0,0,0,0,0,0,0,  # 10 - 17
0,0,0,1,0,0,0,0,  # 18 - 1f
0,0,0,0,3,0,0,0,  # 20 - 27
0,4,0,0,0,0,0,0,  # 28 - 2f
0,0,0,0,0,0,0,0,  # 30 - 37
0,0,0,0,0,0,0,0,  # 38 - 3f
0,0,0,5,0,0,0,0,  # 40 - 47
0,0,0,0,0,0,0,0,  # 48 - 4f
0,0,0,0,0,0,0,0,  # 50 - 57
0,0,0,0,0,0,0,0,  # 58 - 5f
0,0,0,0,0,0,0,0,  # 60 - 67
0,0,0,0,0,0,0,0,  # 68 - 6f
0,0,0,0,0,0,0,0,  # 70 - 77
0,0,0,0,0,0,0,0,  # 78 - 7f
2,2,2,2,2,2,2,2,  # 80 - 87
2,2,2,2,2,2,2,2,  # 88 - 8f
2,2,2,2,2,2,2,2,  # 90 - 97
2,2,2,2,2,2,2,2,  # 98 - 9f
2,2,2,2,2,2,2,2,  # a0 - a7
2,2,2,2,2,2,2,2,  # a8 - af
2,2,2,2,2,2,2,2,  # b0 - b7
2,2,2,2,2,2,2,2,  # b8 - bf
2,2,2,2,2,2,2,2,  # c0 - c7
2,2,2,2,2,2,2,2,  # c8 - cf
2,2,2,2,2,2,2,2,  # d0 - d7
2,2,2,2,2,2,2,2,  # d8 - df
2,2,2,2,2,2,2,2,  # e0 - e7
2,2,2,2,2,2,2,2,  # e8 - ef
2,2,2,2,2,2,2,2,  # f0 - f7
2,2,2,2,2,2,2,2,  # f8 - ff
)

ISO2022KR_st = (
eStart,     3,eError,eStart,eStart,eStart,eError,eError,# 00-07
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,# 08-0f
eItsMe,eItsMe,eError,eError,eError,     4,eError,eError,# 10-17
eError,eError,eError,eError,     5,eError,eError,eError,# 18-1f
eError,eError,eError,eItsMe,eStart,eStart,eStart,eStart,# 20-27
)

ISO2022KRCharLenTable = (0, 0, 0, 0, 0, 0)

ISO2022KRSMModel = {'classTable': ISO2022KR_cls,
                    'classFactor': 6,
                    'stateTable': ISO2022KR_st,
                    'charLenTable': ISO2022KRCharLenTable,
                    'name': "ISO-2022-KR"}

# flake8: noqa

########NEW FILE########
__FILENAME__ = eucjpprober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

import sys
from . import constants
from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import EUCJPDistributionAnalysis
from .jpcntx import EUCJPContextAnalysis
from .mbcssm import EUCJPSMModel


class EUCJPProber(MultiByteCharSetProber):
    def __init__(self):
        MultiByteCharSetProber.__init__(self)
        self._mCodingSM = CodingStateMachine(EUCJPSMModel)
        self._mDistributionAnalyzer = EUCJPDistributionAnalysis()
        self._mContextAnalyzer = EUCJPContextAnalysis()
        self.reset()

    def reset(self):
        MultiByteCharSetProber.reset(self)
        self._mContextAnalyzer.reset()

    def get_charset_name(self):
        return "EUC-JP"

    def feed(self, aBuf):
        aLen = len(aBuf)
        for i in range(0, aLen):
            # PY3K: aBuf is a byte array, so aBuf[i] is an int, not a byte
            codingState = self._mCodingSM.next_state(aBuf[i])
            if codingState == constants.eError:
                if constants._debug:
                    sys.stderr.write(self.get_charset_name()
                                     + ' prober hit error at byte ' + str(i)
                                     + '\n')
                self._mState = constants.eNotMe
                break
            elif codingState == constants.eItsMe:
                self._mState = constants.eFoundIt
                break
            elif codingState == constants.eStart:
                charLen = self._mCodingSM.get_current_charlen()
                if i == 0:
                    self._mLastChar[1] = aBuf[0]
                    self._mContextAnalyzer.feed(self._mLastChar, charLen)
                    self._mDistributionAnalyzer.feed(self._mLastChar, charLen)
                else:
                    self._mContextAnalyzer.feed(aBuf[i - 1:i + 1], charLen)
                    self._mDistributionAnalyzer.feed(aBuf[i - 1:i + 1],
                                                     charLen)

        self._mLastChar[0] = aBuf[aLen - 1]

        if self.get_state() == constants.eDetecting:
            if (self._mContextAnalyzer.got_enough_data() and
               (self.get_confidence() > constants.SHORTCUT_THRESHOLD)):
                self._mState = constants.eFoundIt

        return self.get_state()

    def get_confidence(self):
        contxtCf = self._mContextAnalyzer.get_confidence()
        distribCf = self._mDistributionAnalyzer.get_confidence()
        return max(contxtCf, distribCf)

########NEW FILE########
__FILENAME__ = euckrfreq
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# Sampling from about 20M text materials include literature and computer technology

# 128  --> 0.79
# 256  --> 0.92
# 512  --> 0.986
# 1024 --> 0.99944
# 2048 --> 0.99999
#
# Idea Distribution Ratio = 0.98653 / (1-0.98653) = 73.24
# Random Distribution Ration = 512 / (2350-512) = 0.279.
# 
# Typical Distribution Ratio  

EUCKR_TYPICAL_DISTRIBUTION_RATIO = 6.0

EUCKR_TABLE_SIZE = 2352

# Char to FreqOrder table , 
EUCKRCharToFreqOrder = ( \
  13, 130, 120,1396, 481,1719,1720, 328, 609, 212,1721, 707, 400, 299,1722,  87,
1397,1723, 104, 536,1117,1203,1724,1267, 685,1268, 508,1725,1726,1727,1728,1398,
1399,1729,1730,1731, 141, 621, 326,1057, 368,1732, 267, 488,  20,1733,1269,1734,
 945,1400,1735,  47, 904,1270,1736,1737, 773, 248,1738, 409, 313, 786, 429,1739,
 116, 987, 813,1401, 683,  75,1204, 145,1740,1741,1742,1743,  16, 847, 667, 622,
 708,1744,1745,1746, 966, 787, 304, 129,1747,  60, 820, 123, 676,1748,1749,1750,
1751, 617,1752, 626,1753,1754,1755,1756, 653,1757,1758,1759,1760,1761,1762, 856,
 344,1763,1764,1765,1766,  89, 401, 418, 806, 905, 848,1767,1768,1769, 946,1205,
 709,1770,1118,1771, 241,1772,1773,1774,1271,1775, 569,1776, 999,1777,1778,1779,
1780, 337, 751,1058,  28, 628, 254,1781, 177, 906, 270, 349, 891,1079,1782,  19,
1783, 379,1784, 315,1785, 629, 754,1402, 559,1786, 636, 203,1206,1787, 710, 567,
1788, 935, 814,1789,1790,1207, 766, 528,1791,1792,1208,1793,1794,1795,1796,1797,
1403,1798,1799, 533,1059,1404,1405,1156,1406, 936, 884,1080,1800, 351,1801,1802,
1803,1804,1805, 801,1806,1807,1808,1119,1809,1157, 714, 474,1407,1810, 298, 899,
 885,1811,1120, 802,1158,1812, 892,1813,1814,1408, 659,1815,1816,1121,1817,1818,
1819,1820,1821,1822, 319,1823, 594, 545,1824, 815, 937,1209,1825,1826, 573,1409,
1022,1827,1210,1828,1829,1830,1831,1832,1833, 556, 722, 807,1122,1060,1834, 697,
1835, 900, 557, 715,1836,1410, 540,1411, 752,1159, 294, 597,1211, 976, 803, 770,
1412,1837,1838,  39, 794,1413, 358,1839, 371, 925,1840, 453, 661, 788, 531, 723,
 544,1023,1081, 869,  91,1841, 392, 430, 790, 602,1414, 677,1082, 457,1415,1416,
1842,1843, 475, 327,1024,1417, 795, 121,1844, 733, 403,1418,1845,1846,1847, 300,
 119, 711,1212, 627,1848,1272, 207,1849,1850, 796,1213, 382,1851, 519,1852,1083,
 893,1853,1854,1855, 367, 809, 487, 671,1856, 663,1857,1858, 956, 471, 306, 857,
1859,1860,1160,1084,1861,1862,1863,1864,1865,1061,1866,1867,1868,1869,1870,1871,
 282,  96, 574,1872, 502,1085,1873,1214,1874, 907,1875,1876, 827, 977,1419,1420,
1421, 268,1877,1422,1878,1879,1880, 308,1881,   2, 537,1882,1883,1215,1884,1885,
 127, 791,1886,1273,1423,1887,  34, 336, 404, 643,1888, 571, 654, 894, 840,1889,
   0, 886,1274, 122, 575, 260, 908, 938,1890,1275, 410, 316,1891,1892, 100,1893,
1894,1123,  48,1161,1124,1025,1895, 633, 901,1276,1896,1897, 115, 816,1898, 317,
1899, 694,1900, 909, 734,1424, 572, 866,1425, 691,  85, 524,1010, 543, 394, 841,
1901,1902,1903,1026,1904,1905,1906,1907,1908,1909,  30, 451, 651, 988, 310,1910,
1911,1426, 810,1216,  93,1912,1913,1277,1217,1914, 858, 759,  45,  58, 181, 610,
 269,1915,1916, 131,1062, 551, 443,1000, 821,1427, 957, 895,1086,1917,1918, 375,
1919, 359,1920, 687,1921, 822,1922, 293,1923,1924,  40, 662, 118, 692,  29, 939,
 887, 640, 482, 174,1925,  69,1162, 728,1428, 910,1926,1278,1218,1279, 386, 870,
 217, 854,1163, 823,1927,1928,1929,1930, 834,1931,  78,1932, 859,1933,1063,1934,
1935,1936,1937, 438,1164, 208, 595,1938,1939,1940,1941,1219,1125,1942, 280, 888,
1429,1430,1220,1431,1943,1944,1945,1946,1947,1280, 150, 510,1432,1948,1949,1950,
1951,1952,1953,1954,1011,1087,1955,1433,1043,1956, 881,1957, 614, 958,1064,1065,
1221,1958, 638,1001, 860, 967, 896,1434, 989, 492, 553,1281,1165,1959,1282,1002,
1283,1222,1960,1961,1962,1963,  36, 383, 228, 753, 247, 454,1964, 876, 678,1965,
1966,1284, 126, 464, 490, 835, 136, 672, 529, 940,1088,1435, 473,1967,1968, 467,
  50, 390, 227, 587, 279, 378, 598, 792, 968, 240, 151, 160, 849, 882,1126,1285,
 639,1044, 133, 140, 288, 360, 811, 563,1027, 561, 142, 523,1969,1970,1971,   7,
 103, 296, 439, 407, 506, 634, 990,1972,1973,1974,1975, 645,1976,1977,1978,1979,
1980,1981, 236,1982,1436,1983,1984,1089, 192, 828, 618, 518,1166, 333,1127,1985,
 818,1223,1986,1987,1988,1989,1990,1991,1992,1993, 342,1128,1286, 746, 842,1994,
1995, 560, 223,1287,  98,   8, 189, 650, 978,1288,1996,1437,1997,  17, 345, 250,
 423, 277, 234, 512, 226,  97, 289,  42, 167,1998, 201,1999,2000, 843, 836, 824,
 532, 338, 783,1090, 182, 576, 436,1438,1439, 527, 500,2001, 947, 889,2002,2003,
2004,2005, 262, 600, 314, 447,2006, 547,2007, 693, 738,1129,2008,  71,1440, 745,
 619, 688,2009, 829,2010,2011, 147,2012,  33, 948,2013,2014,  74, 224,2015,  61,
 191, 918, 399, 637,2016,1028,1130, 257, 902,2017,2018,2019,2020,2021,2022,2023,
2024,2025,2026, 837,2027,2028,2029,2030, 179, 874, 591,  52, 724, 246,2031,2032,
2033,2034,1167, 969,2035,1289, 630, 605, 911,1091,1168,2036,2037,2038,1441, 912,
2039, 623,2040,2041, 253,1169,1290,2042,1442, 146, 620, 611, 577, 433,2043,1224,
 719,1170, 959, 440, 437, 534,  84, 388, 480,1131, 159, 220, 198, 679,2044,1012,
 819,1066,1443, 113,1225, 194, 318,1003,1029,2045,2046,2047,2048,1067,2049,2050,
2051,2052,2053,  59, 913, 112,2054, 632,2055, 455, 144, 739,1291,2056, 273, 681,
 499,2057, 448,2058,2059, 760,2060,2061, 970, 384, 169, 245,1132,2062,2063, 414,
1444,2064,2065,  41, 235,2066, 157, 252, 877, 568, 919, 789, 580,2067, 725,2068,
2069,1292,2070,2071,1445,2072,1446,2073,2074,  55, 588,  66,1447, 271,1092,2075,
1226,2076, 960,1013, 372,2077,2078,2079,2080,2081,1293,2082,2083,2084,2085, 850,
2086,2087,2088,2089,2090, 186,2091,1068, 180,2092,2093,2094, 109,1227, 522, 606,
2095, 867,1448,1093, 991,1171, 926, 353,1133,2096, 581,2097,2098,2099,1294,1449,
1450,2100, 596,1172,1014,1228,2101,1451,1295,1173,1229,2102,2103,1296,1134,1452,
 949,1135,2104,2105,1094,1453,1454,1455,2106,1095,2107,2108,2109,2110,2111,2112,
2113,2114,2115,2116,2117, 804,2118,2119,1230,1231, 805,1456, 405,1136,2120,2121,
2122,2123,2124, 720, 701,1297, 992,1457, 927,1004,2125,2126,2127,2128,2129,2130,
  22, 417,2131, 303,2132, 385,2133, 971, 520, 513,2134,1174,  73,1096, 231, 274,
 962,1458, 673,2135,1459,2136, 152,1137,2137,2138,2139,2140,1005,1138,1460,1139,
2141,2142,2143,2144,  11, 374, 844,2145, 154,1232,  46,1461,2146, 838, 830, 721,
1233, 106,2147,  90, 428, 462, 578, 566,1175, 352,2148,2149, 538,1234, 124,1298,
2150,1462, 761, 565,2151, 686,2152, 649,2153,  72, 173,2154, 460, 415,2155,1463,
2156,1235, 305,2157,2158,2159,2160,2161,2162, 579,2163,2164,2165,2166,2167, 747,
2168,2169,2170,2171,1464, 669,2172,2173,2174,2175,2176,1465,2177,  23, 530, 285,
2178, 335, 729,2179, 397,2180,2181,2182,1030,2183,2184, 698,2185,2186, 325,2187,
2188, 369,2189, 799,1097,1015, 348,2190,1069, 680,2191, 851,1466,2192,2193,  10,
2194, 613, 424,2195, 979, 108, 449, 589,  27, 172,  81,1031,  80, 774, 281, 350,
1032, 525, 301, 582,1176,2196, 674,1045,2197,2198,1467, 730, 762,2199,2200,2201,
2202,1468,2203, 993,2204,2205, 266,1070, 963,1140,2206,2207,2208, 664,1098, 972,
2209,2210,2211,1177,1469,1470, 871,2212,2213,2214,2215,2216,1471,2217,2218,2219,
2220,2221,2222,2223,2224,2225,2226,2227,1472,1236,2228,2229,2230,2231,2232,2233,
2234,2235,1299,2236,2237, 200,2238, 477, 373,2239,2240, 731, 825, 777,2241,2242,
2243, 521, 486, 548,2244,2245,2246,1473,1300,  53, 549, 137, 875,  76, 158,2247,
1301,1474, 469, 396,1016, 278, 712,2248, 321, 442, 503, 767, 744, 941,1237,1178,
1475,2249,  82, 178,1141,1179, 973,2250,1302,2251, 297,2252,2253, 570,2254,2255,
2256,  18, 450, 206,2257, 290, 292,1142,2258, 511, 162,  99, 346, 164, 735,2259,
1476,1477,   4, 554, 343, 798,1099,2260,1100,2261,  43, 171,1303, 139, 215,2262,
2263, 717, 775,2264,1033, 322, 216,2265, 831,2266, 149,2267,1304,2268,2269, 702,
1238, 135, 845, 347, 309,2270, 484,2271, 878, 655, 238,1006,1478,2272,  67,2273,
 295,2274,2275, 461,2276, 478, 942, 412,2277,1034,2278,2279,2280, 265,2281, 541,
2282,2283,2284,2285,2286,  70, 852,1071,2287,2288,2289,2290,  21,  56, 509, 117,
 432,2291,2292, 331, 980, 552,1101, 148, 284, 105, 393,1180,1239, 755,2293, 187,
2294,1046,1479,2295, 340,2296,  63,1047, 230,2297,2298,1305, 763,1306, 101, 800,
 808, 494,2299,2300,2301, 903,2302,  37,1072,  14,   5,2303,  79, 675,2304, 312,
2305,2306,2307,2308,2309,1480,   6,1307,2310,2311,2312,   1, 470,  35,  24, 229,
2313, 695, 210,  86, 778,  15, 784, 592, 779,  32,  77, 855, 964,2314, 259,2315,
 501, 380,2316,2317,  83, 981, 153, 689,1308,1481,1482,1483,2318,2319, 716,1484,
2320,2321,2322,2323,2324,2325,1485,2326,2327, 128,  57,  68, 261,1048, 211, 170,
1240,  31,2328,  51, 435, 742,2329,2330,2331, 635,2332, 264, 456,2333,2334,2335,
 425,2336,1486, 143, 507, 263, 943,2337, 363, 920,1487, 256,1488,1102, 243, 601,
1489,2338,2339,2340,2341,2342,2343,2344, 861,2345,2346,2347,2348,2349,2350, 395,
2351,1490,1491,  62, 535, 166, 225,2352,2353, 668, 419,1241, 138, 604, 928,2354,
1181,2355,1492,1493,2356,2357,2358,1143,2359, 696,2360, 387, 307,1309, 682, 476,
2361,2362, 332,  12, 222, 156,2363, 232,2364, 641, 276, 656, 517,1494,1495,1035,
 416, 736,1496,2365,1017, 586,2366,2367,2368,1497,2369, 242,2370,2371,2372,1498,
2373, 965, 713,2374,2375,2376,2377, 740, 982,1499, 944,1500,1007,2378,2379,1310,
1501,2380,2381,2382, 785, 329,2383,2384,1502,2385,2386,2387, 932,2388,1503,2389,
2390,2391,2392,1242,2393,2394,2395,2396,2397, 994, 950,2398,2399,2400,2401,1504,
1311,2402,2403,2404,2405,1049, 749,2406,2407, 853, 718,1144,1312,2408,1182,1505,
2409,2410, 255, 516, 479, 564, 550, 214,1506,1507,1313, 413, 239, 444, 339,1145,
1036,1508,1509,1314,1037,1510,1315,2411,1511,2412,2413,2414, 176, 703, 497, 624,
 593, 921, 302,2415, 341, 165,1103,1512,2416,1513,2417,2418,2419, 376,2420, 700,
2421,2422,2423, 258, 768,1316,2424,1183,2425, 995, 608,2426,2427,2428,2429, 221,
2430,2431,2432,2433,2434,2435,2436,2437, 195, 323, 726, 188, 897, 983,1317, 377,
 644,1050, 879,2438, 452,2439,2440,2441,2442,2443,2444, 914,2445,2446,2447,2448,
 915, 489,2449,1514,1184,2450,2451, 515,  64, 427, 495,2452, 583,2453, 483, 485,
1038, 562, 213,1515, 748, 666,2454,2455,2456,2457, 334,2458, 780, 996,1008, 705,
1243,2459,2460,2461,2462,2463, 114,2464, 493,1146, 366, 163,1516, 961,1104,2465,
 291,2466,1318,1105,2467,1517, 365,2468, 355, 951,1244,2469,1319,2470, 631,2471,
2472, 218,1320, 364, 320, 756,1518,1519,1321,1520,1322,2473,2474,2475,2476, 997,
2477,2478,2479,2480, 665,1185,2481, 916,1521,2482,2483,2484, 584, 684,2485,2486,
 797,2487,1051,1186,2488,2489,2490,1522,2491,2492, 370,2493,1039,1187,  65,2494,
 434, 205, 463,1188,2495, 125, 812, 391, 402, 826, 699, 286, 398, 155, 781, 771,
 585,2496, 590, 505,1073,2497, 599, 244, 219, 917,1018, 952, 646,1523,2498,1323,
2499,2500,  49, 984, 354, 741,2501, 625,2502,1324,2503,1019, 190, 357, 757, 491,
  95, 782, 868,2504,2505,2506,2507,2508,2509, 134,1524,1074, 422,1525, 898,2510,
 161,2511,2512,2513,2514, 769,2515,1526,2516,2517, 411,1325,2518, 472,1527,2519,
2520,2521,2522,2523,2524, 985,2525,2526,2527,2528,2529,2530, 764,2531,1245,2532,
2533,  25, 204, 311,2534, 496,2535,1052,2536,2537,2538,2539,2540,2541,2542, 199,
 704, 504, 468, 758, 657,1528, 196,  44, 839,1246, 272, 750,2543, 765, 862,2544,
2545,1326,2546, 132, 615, 933,2547, 732,2548,2549,2550,1189,1529,2551, 283,1247,
1053, 607, 929,2552,2553,2554, 930, 183, 872, 616,1040,1147,2555,1148,1020, 441,
 249,1075,2556,2557,2558, 466, 743,2559,2560,2561,  92, 514, 426, 420, 526,2562,
2563,2564,2565,2566,2567,2568, 185,2569,2570,2571,2572, 776,1530, 658,2573, 362,
2574, 361, 922,1076, 793,2575,2576,2577,2578,2579,2580,1531, 251,2581,2582,2583,
2584,1532,  54, 612, 237,1327,2585,2586, 275, 408, 647, 111,2587,1533,1106, 465,
   3, 458,   9,  38,2588, 107, 110, 890, 209,  26, 737, 498,2589,1534,2590, 431,
 202,  88,1535, 356, 287,1107, 660,1149,2591, 381,1536, 986,1150, 445,1248,1151,
 974,2592,2593, 846,2594, 446, 953, 184,1249,1250, 727,2595, 923, 193, 883,2596,
2597,2598, 102, 324, 539, 817,2599, 421,1041,2600, 832,2601,  94, 175, 197, 406,
2602, 459,2603,2604,2605,2606,2607, 330, 555,2608,2609,2610, 706,1108, 389,2611,
2612,2613,2614, 233,2615, 833, 558, 931, 954,1251,2616,2617,1537, 546,2618,2619,
1009,2620,2621,2622,1538, 690,1328,2623, 955,2624,1539,2625,2626, 772,2627,2628,
2629,2630,2631, 924, 648, 863, 603,2632,2633, 934,1540, 864, 865,2634, 642,1042,
 670,1190,2635,2636,2637,2638, 168,2639, 652, 873, 542,1054,1541,2640,2641,2642,  # 512, 256
#Everything below is of no interest for detection purpose
2643,2644,2645,2646,2647,2648,2649,2650,2651,2652,2653,2654,2655,2656,2657,2658,
2659,2660,2661,2662,2663,2664,2665,2666,2667,2668,2669,2670,2671,2672,2673,2674,
2675,2676,2677,2678,2679,2680,2681,2682,2683,2684,2685,2686,2687,2688,2689,2690,
2691,2692,2693,2694,2695,2696,2697,2698,2699,1542, 880,2700,2701,2702,2703,2704,
2705,2706,2707,2708,2709,2710,2711,2712,2713,2714,2715,2716,2717,2718,2719,2720,
2721,2722,2723,2724,2725,1543,2726,2727,2728,2729,2730,2731,2732,1544,2733,2734,
2735,2736,2737,2738,2739,2740,2741,2742,2743,2744,2745,2746,2747,2748,2749,2750,
2751,2752,2753,2754,1545,2755,2756,2757,2758,2759,2760,2761,2762,2763,2764,2765,
2766,1546,2767,1547,2768,2769,2770,2771,2772,2773,2774,2775,2776,2777,2778,2779,
2780,2781,2782,2783,2784,2785,2786,1548,2787,2788,2789,1109,2790,2791,2792,2793,
2794,2795,2796,2797,2798,2799,2800,2801,2802,2803,2804,2805,2806,2807,2808,2809,
2810,2811,2812,1329,2813,2814,2815,2816,2817,2818,2819,2820,2821,2822,2823,2824,
2825,2826,2827,2828,2829,2830,2831,2832,2833,2834,2835,2836,2837,2838,2839,2840,
2841,2842,2843,2844,2845,2846,2847,2848,2849,2850,2851,2852,2853,2854,2855,2856,
1549,2857,2858,2859,2860,1550,2861,2862,1551,2863,2864,2865,2866,2867,2868,2869,
2870,2871,2872,2873,2874,1110,1330,2875,2876,2877,2878,2879,2880,2881,2882,2883,
2884,2885,2886,2887,2888,2889,2890,2891,2892,2893,2894,2895,2896,2897,2898,2899,
2900,2901,2902,2903,2904,2905,2906,2907,2908,2909,2910,2911,2912,2913,2914,2915,
2916,2917,2918,2919,2920,2921,2922,2923,2924,2925,2926,2927,2928,2929,2930,1331,
2931,2932,2933,2934,2935,2936,2937,2938,2939,2940,2941,2942,2943,1552,2944,2945,
2946,2947,2948,2949,2950,2951,2952,2953,2954,2955,2956,2957,2958,2959,2960,2961,
2962,2963,2964,1252,2965,2966,2967,2968,2969,2970,2971,2972,2973,2974,2975,2976,
2977,2978,2979,2980,2981,2982,2983,2984,2985,2986,2987,2988,2989,2990,2991,2992,
2993,2994,2995,2996,2997,2998,2999,3000,3001,3002,3003,3004,3005,3006,3007,3008,
3009,3010,3011,3012,1553,3013,3014,3015,3016,3017,1554,3018,1332,3019,3020,3021,
3022,3023,3024,3025,3026,3027,3028,3029,3030,3031,3032,3033,3034,3035,3036,3037,
3038,3039,3040,3041,3042,3043,3044,3045,3046,3047,3048,3049,3050,1555,3051,3052,
3053,1556,1557,3054,3055,3056,3057,3058,3059,3060,3061,3062,3063,3064,3065,3066,
3067,1558,3068,3069,3070,3071,3072,3073,3074,3075,3076,1559,3077,3078,3079,3080,
3081,3082,3083,1253,3084,3085,3086,3087,3088,3089,3090,3091,3092,3093,3094,3095,
3096,3097,3098,3099,3100,3101,3102,3103,3104,3105,3106,3107,3108,1152,3109,3110,
3111,3112,3113,1560,3114,3115,3116,3117,1111,3118,3119,3120,3121,3122,3123,3124,
3125,3126,3127,3128,3129,3130,3131,3132,3133,3134,3135,3136,3137,3138,3139,3140,
3141,3142,3143,3144,3145,3146,3147,3148,3149,3150,3151,3152,3153,3154,3155,3156,
3157,3158,3159,3160,3161,3162,3163,3164,3165,3166,3167,3168,3169,3170,3171,3172,
3173,3174,3175,3176,1333,3177,3178,3179,3180,3181,3182,3183,3184,3185,3186,3187,
3188,3189,1561,3190,3191,1334,3192,3193,3194,3195,3196,3197,3198,3199,3200,3201,
3202,3203,3204,3205,3206,3207,3208,3209,3210,3211,3212,3213,3214,3215,3216,3217,
3218,3219,3220,3221,3222,3223,3224,3225,3226,3227,3228,3229,3230,3231,3232,3233,
3234,1562,3235,3236,3237,3238,3239,3240,3241,3242,3243,3244,3245,3246,3247,3248,
3249,3250,3251,3252,3253,3254,3255,3256,3257,3258,3259,3260,3261,3262,3263,3264,
3265,3266,3267,3268,3269,3270,3271,3272,3273,3274,3275,3276,3277,1563,3278,3279,
3280,3281,3282,3283,3284,3285,3286,3287,3288,3289,3290,3291,3292,3293,3294,3295,
3296,3297,3298,3299,3300,3301,3302,3303,3304,3305,3306,3307,3308,3309,3310,3311,
3312,3313,3314,3315,3316,3317,3318,3319,3320,3321,3322,3323,3324,3325,3326,3327,
3328,3329,3330,3331,3332,3333,3334,3335,3336,3337,3338,3339,3340,3341,3342,3343,
3344,3345,3346,3347,3348,3349,3350,3351,3352,3353,3354,3355,3356,3357,3358,3359,
3360,3361,3362,3363,3364,1335,3365,3366,3367,3368,3369,3370,3371,3372,3373,3374,
3375,3376,3377,3378,3379,3380,3381,3382,3383,3384,3385,3386,3387,1336,3388,3389,
3390,3391,3392,3393,3394,3395,3396,3397,3398,3399,3400,3401,3402,3403,3404,3405,
3406,3407,3408,3409,3410,3411,3412,3413,3414,1337,3415,3416,3417,3418,3419,1338,
3420,3421,3422,1564,1565,3423,3424,3425,3426,3427,3428,3429,3430,3431,1254,3432,
3433,3434,1339,3435,3436,3437,3438,3439,1566,3440,3441,3442,3443,3444,3445,3446,
3447,3448,3449,3450,3451,3452,3453,3454,1255,3455,3456,3457,3458,3459,1567,1191,
3460,1568,1569,3461,3462,3463,1570,3464,3465,3466,3467,3468,1571,3469,3470,3471,
3472,3473,1572,3474,3475,3476,3477,3478,3479,3480,3481,3482,3483,3484,3485,3486,
1340,3487,3488,3489,3490,3491,3492,1021,3493,3494,3495,3496,3497,3498,1573,3499,
1341,3500,3501,3502,3503,3504,3505,3506,3507,3508,3509,3510,3511,1342,3512,3513,
3514,3515,3516,1574,1343,3517,3518,3519,1575,3520,1576,3521,3522,3523,3524,3525,
3526,3527,3528,3529,3530,3531,3532,3533,3534,3535,3536,3537,3538,3539,3540,3541,
3542,3543,3544,3545,3546,3547,3548,3549,3550,3551,3552,3553,3554,3555,3556,3557,
3558,3559,3560,3561,3562,3563,3564,3565,3566,3567,3568,3569,3570,3571,3572,3573,
3574,3575,3576,3577,3578,3579,3580,1577,3581,3582,1578,3583,3584,3585,3586,3587,
3588,3589,3590,3591,3592,3593,3594,3595,3596,3597,3598,3599,3600,3601,3602,3603,
3604,1579,3605,3606,3607,3608,3609,3610,3611,3612,3613,3614,3615,3616,3617,3618,
3619,3620,3621,3622,3623,3624,3625,3626,3627,3628,3629,1580,3630,3631,1581,3632,
3633,3634,3635,3636,3637,3638,3639,3640,3641,3642,3643,3644,3645,3646,3647,3648,
3649,3650,3651,3652,3653,3654,3655,3656,1582,3657,3658,3659,3660,3661,3662,3663,
3664,3665,3666,3667,3668,3669,3670,3671,3672,3673,3674,3675,3676,3677,3678,3679,
3680,3681,3682,3683,3684,3685,3686,3687,3688,3689,3690,3691,3692,3693,3694,3695,
3696,3697,3698,3699,3700,1192,3701,3702,3703,3704,1256,3705,3706,3707,3708,1583,
1257,3709,3710,3711,3712,3713,3714,3715,3716,1584,3717,3718,3719,3720,3721,3722,
3723,3724,3725,3726,3727,3728,3729,3730,3731,3732,3733,3734,3735,3736,3737,3738,
3739,3740,3741,3742,3743,3744,3745,1344,3746,3747,3748,3749,3750,3751,3752,3753,
3754,3755,3756,1585,3757,3758,3759,3760,3761,3762,3763,3764,3765,3766,1586,3767,
3768,3769,3770,3771,3772,3773,3774,3775,3776,3777,3778,1345,3779,3780,3781,3782,
3783,3784,3785,3786,3787,3788,3789,3790,3791,3792,3793,3794,3795,1346,1587,3796,
3797,1588,3798,3799,3800,3801,3802,3803,3804,3805,3806,1347,3807,3808,3809,3810,
3811,1589,3812,3813,3814,3815,3816,3817,3818,3819,3820,3821,1590,3822,3823,1591,
1348,3824,3825,3826,3827,3828,3829,3830,1592,3831,3832,1593,3833,3834,3835,3836,
3837,3838,3839,3840,3841,3842,3843,3844,1349,3845,3846,3847,3848,3849,3850,3851,
3852,3853,3854,3855,3856,3857,3858,1594,3859,3860,3861,3862,3863,3864,3865,3866,
3867,3868,3869,1595,3870,3871,3872,3873,1596,3874,3875,3876,3877,3878,3879,3880,
3881,3882,3883,3884,3885,3886,1597,3887,3888,3889,3890,3891,3892,3893,3894,3895,
1598,3896,3897,3898,1599,1600,3899,1350,3900,1351,3901,3902,1352,3903,3904,3905,
3906,3907,3908,3909,3910,3911,3912,3913,3914,3915,3916,3917,3918,3919,3920,3921,
3922,3923,3924,1258,3925,3926,3927,3928,3929,3930,3931,1193,3932,1601,3933,3934,
3935,3936,3937,3938,3939,3940,3941,3942,3943,1602,3944,3945,3946,3947,3948,1603,
3949,3950,3951,3952,3953,3954,3955,3956,3957,3958,3959,3960,3961,3962,3963,3964,
3965,1604,3966,3967,3968,3969,3970,3971,3972,3973,3974,3975,3976,3977,1353,3978,
3979,3980,3981,3982,3983,3984,3985,3986,3987,3988,3989,3990,3991,1354,3992,3993,
3994,3995,3996,3997,3998,3999,4000,4001,4002,4003,4004,4005,4006,4007,4008,4009,
4010,4011,4012,4013,4014,4015,4016,4017,4018,4019,4020,4021,4022,4023,1355,4024,
4025,4026,4027,4028,4029,4030,4031,4032,4033,4034,4035,4036,4037,4038,4039,4040,
1605,4041,4042,4043,4044,4045,4046,4047,4048,4049,4050,4051,4052,4053,4054,4055,
4056,4057,4058,4059,4060,1606,4061,4062,4063,4064,1607,4065,4066,4067,4068,4069,
4070,4071,4072,4073,4074,4075,4076,1194,4077,4078,1608,4079,4080,4081,4082,4083,
4084,4085,4086,4087,1609,4088,4089,4090,4091,4092,4093,4094,4095,4096,4097,4098,
4099,4100,4101,4102,4103,4104,4105,4106,4107,4108,1259,4109,4110,4111,4112,4113,
4114,4115,4116,4117,4118,4119,4120,4121,4122,4123,4124,1195,4125,4126,4127,1610,
4128,4129,4130,4131,4132,4133,4134,4135,4136,4137,1356,4138,4139,4140,4141,4142,
4143,4144,1611,4145,4146,4147,4148,4149,4150,4151,4152,4153,4154,4155,4156,4157,
4158,4159,4160,4161,4162,4163,4164,4165,4166,4167,4168,4169,4170,4171,4172,4173,
4174,4175,4176,4177,4178,4179,4180,4181,4182,4183,4184,4185,4186,4187,4188,4189,
4190,4191,4192,4193,4194,4195,4196,4197,4198,4199,4200,4201,4202,4203,4204,4205,
4206,4207,4208,4209,4210,4211,4212,4213,4214,4215,4216,4217,4218,4219,1612,4220,
4221,4222,4223,4224,4225,4226,4227,1357,4228,1613,4229,4230,4231,4232,4233,4234,
4235,4236,4237,4238,4239,4240,4241,4242,4243,1614,4244,4245,4246,4247,4248,4249,
4250,4251,4252,4253,4254,4255,4256,4257,4258,4259,4260,4261,4262,4263,4264,4265,
4266,4267,4268,4269,4270,1196,1358,4271,4272,4273,4274,4275,4276,4277,4278,4279,
4280,4281,4282,4283,4284,4285,4286,4287,1615,4288,4289,4290,4291,4292,4293,4294,
4295,4296,4297,4298,4299,4300,4301,4302,4303,4304,4305,4306,4307,4308,4309,4310,
4311,4312,4313,4314,4315,4316,4317,4318,4319,4320,4321,4322,4323,4324,4325,4326,
4327,4328,4329,4330,4331,4332,4333,4334,1616,4335,4336,4337,4338,4339,4340,4341,
4342,4343,4344,4345,4346,4347,4348,4349,4350,4351,4352,4353,4354,4355,4356,4357,
4358,4359,4360,1617,4361,4362,4363,4364,4365,1618,4366,4367,4368,4369,4370,4371,
4372,4373,4374,4375,4376,4377,4378,4379,4380,4381,4382,4383,4384,4385,4386,4387,
4388,4389,4390,4391,4392,4393,4394,4395,4396,4397,4398,4399,4400,4401,4402,4403,
4404,4405,4406,4407,4408,4409,4410,4411,4412,4413,4414,4415,4416,1619,4417,4418,
4419,4420,4421,4422,4423,4424,4425,1112,4426,4427,4428,4429,4430,1620,4431,4432,
4433,4434,4435,4436,4437,4438,4439,4440,4441,4442,1260,1261,4443,4444,4445,4446,
4447,4448,4449,4450,4451,4452,4453,4454,4455,1359,4456,4457,4458,4459,4460,4461,
4462,4463,4464,4465,1621,4466,4467,4468,4469,4470,4471,4472,4473,4474,4475,4476,
4477,4478,4479,4480,4481,4482,4483,4484,4485,4486,4487,4488,4489,1055,4490,4491,
4492,4493,4494,4495,4496,4497,4498,4499,4500,4501,4502,4503,4504,4505,4506,4507,
4508,4509,4510,4511,4512,4513,4514,4515,4516,4517,4518,1622,4519,4520,4521,1623,
4522,4523,4524,4525,4526,4527,4528,4529,4530,4531,4532,4533,4534,4535,1360,4536,
4537,4538,4539,4540,4541,4542,4543, 975,4544,4545,4546,4547,4548,4549,4550,4551,
4552,4553,4554,4555,4556,4557,4558,4559,4560,4561,4562,4563,4564,4565,4566,4567,
4568,4569,4570,4571,1624,4572,4573,4574,4575,4576,1625,4577,4578,4579,4580,4581,
4582,4583,4584,1626,4585,4586,4587,4588,4589,4590,4591,4592,4593,4594,4595,1627,
4596,4597,4598,4599,4600,4601,4602,4603,4604,4605,4606,4607,4608,4609,4610,4611,
4612,4613,4614,4615,1628,4616,4617,4618,4619,4620,4621,4622,4623,4624,4625,4626,
4627,4628,4629,4630,4631,4632,4633,4634,4635,4636,4637,4638,4639,4640,4641,4642,
4643,4644,4645,4646,4647,4648,4649,1361,4650,4651,4652,4653,4654,4655,4656,4657,
4658,4659,4660,4661,1362,4662,4663,4664,4665,4666,4667,4668,4669,4670,4671,4672,
4673,4674,4675,4676,4677,4678,4679,4680,4681,4682,1629,4683,4684,4685,4686,4687,
1630,4688,4689,4690,4691,1153,4692,4693,4694,1113,4695,4696,4697,4698,4699,4700,
4701,4702,4703,4704,4705,4706,4707,4708,4709,4710,4711,1197,4712,4713,4714,4715,
4716,4717,4718,4719,4720,4721,4722,4723,4724,4725,4726,4727,4728,4729,4730,4731,
4732,4733,4734,4735,1631,4736,1632,4737,4738,4739,4740,4741,4742,4743,4744,1633,
4745,4746,4747,4748,4749,1262,4750,4751,4752,4753,4754,1363,4755,4756,4757,4758,
4759,4760,4761,4762,4763,4764,4765,4766,4767,4768,1634,4769,4770,4771,4772,4773,
4774,4775,4776,4777,4778,1635,4779,4780,4781,4782,4783,4784,4785,4786,4787,4788,
4789,1636,4790,4791,4792,4793,4794,4795,4796,4797,4798,4799,4800,4801,4802,4803,
4804,4805,4806,1637,4807,4808,4809,1638,4810,4811,4812,4813,4814,4815,4816,4817,
4818,1639,4819,4820,4821,4822,4823,4824,4825,4826,4827,4828,4829,4830,4831,4832,
4833,1077,4834,4835,4836,4837,4838,4839,4840,4841,4842,4843,4844,4845,4846,4847,
4848,4849,4850,4851,4852,4853,4854,4855,4856,4857,4858,4859,4860,4861,4862,4863,
4864,4865,4866,4867,4868,4869,4870,4871,4872,4873,4874,4875,4876,4877,4878,4879,
4880,4881,4882,4883,1640,4884,4885,1641,4886,4887,4888,4889,4890,4891,4892,4893,
4894,4895,4896,4897,4898,4899,4900,4901,4902,4903,4904,4905,4906,4907,4908,4909,
4910,4911,1642,4912,4913,4914,1364,4915,4916,4917,4918,4919,4920,4921,4922,4923,
4924,4925,4926,4927,4928,4929,4930,4931,1643,4932,4933,4934,4935,4936,4937,4938,
4939,4940,4941,4942,4943,4944,4945,4946,4947,4948,4949,4950,4951,4952,4953,4954,
4955,4956,4957,4958,4959,4960,4961,4962,4963,4964,4965,4966,4967,4968,4969,4970,
4971,4972,4973,4974,4975,4976,4977,4978,4979,4980,1644,4981,4982,4983,4984,1645,
4985,4986,1646,4987,4988,4989,4990,4991,4992,4993,4994,4995,4996,4997,4998,4999,
5000,5001,5002,5003,5004,5005,1647,5006,1648,5007,5008,5009,5010,5011,5012,1078,
5013,5014,5015,5016,5017,5018,5019,5020,5021,5022,5023,5024,5025,5026,5027,5028,
1365,5029,5030,5031,5032,5033,5034,5035,5036,5037,5038,5039,1649,5040,5041,5042,
5043,5044,5045,1366,5046,5047,5048,5049,5050,5051,5052,5053,5054,5055,1650,5056,
5057,5058,5059,5060,5061,5062,5063,5064,5065,5066,5067,5068,5069,5070,5071,5072,
5073,5074,5075,5076,5077,1651,5078,5079,5080,5081,5082,5083,5084,5085,5086,5087,
5088,5089,5090,5091,5092,5093,5094,5095,5096,5097,5098,5099,5100,5101,5102,5103,
5104,5105,5106,5107,5108,5109,5110,1652,5111,5112,5113,5114,5115,5116,5117,5118,
1367,5119,5120,5121,5122,5123,5124,5125,5126,5127,5128,5129,1653,5130,5131,5132,
5133,5134,5135,5136,5137,5138,5139,5140,5141,5142,5143,5144,5145,5146,5147,5148,
5149,1368,5150,1654,5151,1369,5152,5153,5154,5155,5156,5157,5158,5159,5160,5161,
5162,5163,5164,5165,5166,5167,5168,5169,5170,5171,5172,5173,5174,5175,5176,5177,
5178,1370,5179,5180,5181,5182,5183,5184,5185,5186,5187,5188,5189,5190,5191,5192,
5193,5194,5195,5196,5197,5198,1655,5199,5200,5201,5202,1656,5203,5204,5205,5206,
1371,5207,1372,5208,5209,5210,5211,1373,5212,5213,1374,5214,5215,5216,5217,5218,
5219,5220,5221,5222,5223,5224,5225,5226,5227,5228,5229,5230,5231,5232,5233,5234,
5235,5236,5237,5238,5239,5240,5241,5242,5243,5244,5245,5246,5247,1657,5248,5249,
5250,5251,1658,1263,5252,5253,5254,5255,5256,1375,5257,5258,5259,5260,5261,5262,
5263,5264,5265,5266,5267,5268,5269,5270,5271,5272,5273,5274,5275,5276,5277,5278,
5279,5280,5281,5282,5283,1659,5284,5285,5286,5287,5288,5289,5290,5291,5292,5293,
5294,5295,5296,5297,5298,5299,5300,1660,5301,5302,5303,5304,5305,5306,5307,5308,
5309,5310,5311,5312,5313,5314,5315,5316,5317,5318,5319,5320,5321,1376,5322,5323,
5324,5325,5326,5327,5328,5329,5330,5331,5332,5333,1198,5334,5335,5336,5337,5338,
5339,5340,5341,5342,5343,1661,5344,5345,5346,5347,5348,5349,5350,5351,5352,5353,
5354,5355,5356,5357,5358,5359,5360,5361,5362,5363,5364,5365,5366,5367,5368,5369,
5370,5371,5372,5373,5374,5375,5376,5377,5378,5379,5380,5381,5382,5383,5384,5385,
5386,5387,5388,5389,5390,5391,5392,5393,5394,5395,5396,5397,5398,1264,5399,5400,
5401,5402,5403,5404,5405,5406,5407,5408,5409,5410,5411,5412,1662,5413,5414,5415,
5416,1663,5417,5418,5419,5420,5421,5422,5423,5424,5425,5426,5427,5428,5429,5430,
5431,5432,5433,5434,5435,5436,5437,5438,1664,5439,5440,5441,5442,5443,5444,5445,
5446,5447,5448,5449,5450,5451,5452,5453,5454,5455,5456,5457,5458,5459,5460,5461,
5462,5463,5464,5465,5466,5467,5468,5469,5470,5471,5472,5473,5474,5475,5476,5477,
5478,1154,5479,5480,5481,5482,5483,5484,5485,1665,5486,5487,5488,5489,5490,5491,
5492,5493,5494,5495,5496,5497,5498,5499,5500,5501,5502,5503,5504,5505,5506,5507,
5508,5509,5510,5511,5512,5513,5514,5515,5516,5517,5518,5519,5520,5521,5522,5523,
5524,5525,5526,5527,5528,5529,5530,5531,5532,5533,5534,5535,5536,5537,5538,5539,
5540,5541,5542,5543,5544,5545,5546,5547,5548,1377,5549,5550,5551,5552,5553,5554,
5555,5556,5557,5558,5559,5560,5561,5562,5563,5564,5565,5566,5567,5568,5569,5570,
1114,5571,5572,5573,5574,5575,5576,5577,5578,5579,5580,5581,5582,5583,5584,5585,
5586,5587,5588,5589,5590,5591,5592,1378,5593,5594,5595,5596,5597,5598,5599,5600,
5601,5602,5603,5604,5605,5606,5607,5608,5609,5610,5611,5612,5613,5614,1379,5615,
5616,5617,5618,5619,5620,5621,5622,5623,5624,5625,5626,5627,5628,5629,5630,5631,
5632,5633,5634,1380,5635,5636,5637,5638,5639,5640,5641,5642,5643,5644,5645,5646,
5647,5648,5649,1381,1056,5650,5651,5652,5653,5654,5655,5656,5657,5658,5659,5660,
1666,5661,5662,5663,5664,5665,5666,5667,5668,1667,5669,1668,5670,5671,5672,5673,
5674,5675,5676,5677,5678,1155,5679,5680,5681,5682,5683,5684,5685,5686,5687,5688,
5689,5690,5691,5692,5693,5694,5695,5696,5697,5698,1669,5699,5700,5701,5702,5703,
5704,5705,1670,5706,5707,5708,5709,5710,1671,5711,5712,5713,5714,1382,5715,5716,
5717,5718,5719,5720,5721,5722,5723,5724,5725,1672,5726,5727,1673,1674,5728,5729,
5730,5731,5732,5733,5734,5735,5736,1675,5737,5738,5739,5740,5741,5742,5743,5744,
1676,5745,5746,5747,5748,5749,5750,5751,1383,5752,5753,5754,5755,5756,5757,5758,
5759,5760,5761,5762,5763,5764,5765,5766,5767,5768,1677,5769,5770,5771,5772,5773,
1678,5774,5775,5776, 998,5777,5778,5779,5780,5781,5782,5783,5784,5785,1384,5786,
5787,5788,5789,5790,5791,5792,5793,5794,5795,5796,5797,5798,5799,5800,1679,5801,
5802,5803,1115,1116,5804,5805,5806,5807,5808,5809,5810,5811,5812,5813,5814,5815,
5816,5817,5818,5819,5820,5821,5822,5823,5824,5825,5826,5827,5828,5829,5830,5831,
5832,5833,5834,5835,5836,5837,5838,5839,5840,5841,5842,5843,5844,5845,5846,5847,
5848,5849,5850,5851,5852,5853,5854,5855,1680,5856,5857,5858,5859,5860,5861,5862,
5863,5864,1681,5865,5866,5867,1682,5868,5869,5870,5871,5872,5873,5874,5875,5876,
5877,5878,5879,1683,5880,1684,5881,5882,5883,5884,1685,5885,5886,5887,5888,5889,
5890,5891,5892,5893,5894,5895,5896,5897,5898,5899,5900,5901,5902,5903,5904,5905,
5906,5907,1686,5908,5909,5910,5911,5912,5913,5914,5915,5916,5917,5918,5919,5920,
5921,5922,5923,5924,5925,5926,5927,5928,5929,5930,5931,5932,5933,5934,5935,1687,
5936,5937,5938,5939,5940,5941,5942,5943,5944,5945,5946,5947,5948,5949,5950,5951,
5952,1688,1689,5953,1199,5954,5955,5956,5957,5958,5959,5960,5961,1690,5962,5963,
5964,5965,5966,5967,5968,5969,5970,5971,5972,5973,5974,5975,5976,5977,5978,5979,
5980,5981,1385,5982,1386,5983,5984,5985,5986,5987,5988,5989,5990,5991,5992,5993,
5994,5995,5996,5997,5998,5999,6000,6001,6002,6003,6004,6005,6006,6007,6008,6009,
6010,6011,6012,6013,6014,6015,6016,6017,6018,6019,6020,6021,6022,6023,6024,6025,
6026,6027,1265,6028,6029,1691,6030,6031,6032,6033,6034,6035,6036,6037,6038,6039,
6040,6041,6042,6043,6044,6045,6046,6047,6048,6049,6050,6051,6052,6053,6054,6055,
6056,6057,6058,6059,6060,6061,6062,6063,6064,6065,6066,6067,6068,6069,6070,6071,
6072,6073,6074,6075,6076,6077,6078,6079,6080,6081,6082,6083,6084,1692,6085,6086,
6087,6088,6089,6090,6091,6092,6093,6094,6095,6096,6097,6098,6099,6100,6101,6102,
6103,6104,6105,6106,6107,6108,6109,6110,6111,6112,6113,6114,6115,6116,6117,6118,
6119,6120,6121,6122,6123,6124,6125,6126,6127,6128,6129,6130,6131,1693,6132,6133,
6134,6135,6136,1694,6137,6138,6139,6140,6141,1695,6142,6143,6144,6145,6146,6147,
6148,6149,6150,6151,6152,6153,6154,6155,6156,6157,6158,6159,6160,6161,6162,6163,
6164,6165,6166,6167,6168,6169,6170,6171,6172,6173,6174,6175,6176,6177,6178,6179,
6180,6181,6182,6183,6184,6185,1696,6186,6187,6188,6189,6190,6191,6192,6193,6194,
6195,6196,6197,6198,6199,6200,6201,6202,6203,6204,6205,6206,6207,6208,6209,6210,
6211,6212,6213,6214,6215,6216,6217,6218,6219,1697,6220,6221,6222,6223,6224,6225,
6226,6227,6228,6229,6230,6231,6232,6233,6234,6235,6236,6237,6238,6239,6240,6241,
6242,6243,6244,6245,6246,6247,6248,6249,6250,6251,6252,6253,1698,6254,6255,6256,
6257,6258,6259,6260,6261,6262,6263,1200,6264,6265,6266,6267,6268,6269,6270,6271,  #1024
6272,6273,6274,6275,6276,6277,6278,6279,6280,6281,6282,6283,6284,6285,6286,6287,
6288,6289,6290,6291,6292,6293,6294,6295,6296,6297,6298,6299,6300,6301,6302,1699,
6303,6304,1700,6305,6306,6307,6308,6309,6310,6311,6312,6313,6314,6315,6316,6317,
6318,6319,6320,6321,6322,6323,6324,6325,6326,6327,6328,6329,6330,6331,6332,6333,
6334,6335,6336,6337,6338,6339,1701,6340,6341,6342,6343,6344,1387,6345,6346,6347,
6348,6349,6350,6351,6352,6353,6354,6355,6356,6357,6358,6359,6360,6361,6362,6363,
6364,6365,6366,6367,6368,6369,6370,6371,6372,6373,6374,6375,6376,6377,6378,6379,
6380,6381,6382,6383,6384,6385,6386,6387,6388,6389,6390,6391,6392,6393,6394,6395,
6396,6397,6398,6399,6400,6401,6402,6403,6404,6405,6406,6407,6408,6409,6410,6411,
6412,6413,1702,6414,6415,6416,6417,6418,6419,6420,6421,6422,1703,6423,6424,6425,
6426,6427,6428,6429,6430,6431,6432,6433,6434,6435,6436,6437,6438,1704,6439,6440,
6441,6442,6443,6444,6445,6446,6447,6448,6449,6450,6451,6452,6453,6454,6455,6456,
6457,6458,6459,6460,6461,6462,6463,6464,6465,6466,6467,6468,6469,6470,6471,6472,
6473,6474,6475,6476,6477,6478,6479,6480,6481,6482,6483,6484,6485,6486,6487,6488,
6489,6490,6491,6492,6493,6494,6495,6496,6497,6498,6499,6500,6501,6502,6503,1266,
6504,6505,6506,6507,6508,6509,6510,6511,6512,6513,6514,6515,6516,6517,6518,6519,
6520,6521,6522,6523,6524,6525,6526,6527,6528,6529,6530,6531,6532,6533,6534,6535,
6536,6537,6538,6539,6540,6541,6542,6543,6544,6545,6546,6547,6548,6549,6550,6551,
1705,1706,6552,6553,6554,6555,6556,6557,6558,6559,6560,6561,6562,6563,6564,6565,
6566,6567,6568,6569,6570,6571,6572,6573,6574,6575,6576,6577,6578,6579,6580,6581,
6582,6583,6584,6585,6586,6587,6588,6589,6590,6591,6592,6593,6594,6595,6596,6597,
6598,6599,6600,6601,6602,6603,6604,6605,6606,6607,6608,6609,6610,6611,6612,6613,
6614,6615,6616,6617,6618,6619,6620,6621,6622,6623,6624,6625,6626,6627,6628,6629,
6630,6631,6632,6633,6634,6635,6636,6637,1388,6638,6639,6640,6641,6642,6643,6644,
1707,6645,6646,6647,6648,6649,6650,6651,6652,6653,6654,6655,6656,6657,6658,6659,
6660,6661,6662,6663,1708,6664,6665,6666,6667,6668,6669,6670,6671,6672,6673,6674,
1201,6675,6676,6677,6678,6679,6680,6681,6682,6683,6684,6685,6686,6687,6688,6689,
6690,6691,6692,6693,6694,6695,6696,6697,6698,6699,6700,6701,6702,6703,6704,6705,
6706,6707,6708,6709,6710,6711,6712,6713,6714,6715,6716,6717,6718,6719,6720,6721,
6722,6723,6724,6725,1389,6726,6727,6728,6729,6730,6731,6732,6733,6734,6735,6736,
1390,1709,6737,6738,6739,6740,6741,6742,1710,6743,6744,6745,6746,1391,6747,6748,
6749,6750,6751,6752,6753,6754,6755,6756,6757,1392,6758,6759,6760,6761,6762,6763,
6764,6765,6766,6767,6768,6769,6770,6771,6772,6773,6774,6775,6776,6777,6778,6779,
6780,1202,6781,6782,6783,6784,6785,6786,6787,6788,6789,6790,6791,6792,6793,6794,
6795,6796,6797,6798,6799,6800,6801,6802,6803,6804,6805,6806,6807,6808,6809,1711,
6810,6811,6812,6813,6814,6815,6816,6817,6818,6819,6820,6821,6822,6823,6824,6825,
6826,6827,6828,6829,6830,6831,6832,6833,6834,6835,6836,1393,6837,6838,6839,6840,
6841,6842,6843,6844,6845,6846,6847,6848,6849,6850,6851,6852,6853,6854,6855,6856,
6857,6858,6859,6860,6861,6862,6863,6864,6865,6866,6867,6868,6869,6870,6871,6872,
6873,6874,6875,6876,6877,6878,6879,6880,6881,6882,6883,6884,6885,6886,6887,6888,
6889,6890,6891,6892,6893,6894,6895,6896,6897,6898,6899,6900,6901,6902,1712,6903,
6904,6905,6906,6907,6908,6909,6910,1713,6911,6912,6913,6914,6915,6916,6917,6918,
6919,6920,6921,6922,6923,6924,6925,6926,6927,6928,6929,6930,6931,6932,6933,6934,
6935,6936,6937,6938,6939,6940,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,
6951,6952,6953,6954,6955,6956,6957,6958,6959,6960,6961,6962,6963,6964,6965,6966,
6967,6968,6969,6970,6971,6972,6973,6974,1714,6975,6976,6977,6978,6979,6980,6981,
6982,6983,6984,6985,6986,6987,6988,1394,6989,6990,6991,6992,6993,6994,6995,6996,
6997,6998,6999,7000,1715,7001,7002,7003,7004,7005,7006,7007,7008,7009,7010,7011,
7012,7013,7014,7015,7016,7017,7018,7019,7020,7021,7022,7023,7024,7025,7026,7027,
7028,1716,7029,7030,7031,7032,7033,7034,7035,7036,7037,7038,7039,7040,7041,7042,
7043,7044,7045,7046,7047,7048,7049,7050,7051,7052,7053,7054,7055,7056,7057,7058,
7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,
7075,7076,7077,7078,7079,7080,7081,7082,7083,7084,7085,7086,7087,7088,7089,7090,
7091,7092,7093,7094,7095,7096,7097,7098,7099,7100,7101,7102,7103,7104,7105,7106,
7107,7108,7109,7110,7111,7112,7113,7114,7115,7116,7117,7118,7119,7120,7121,7122,
7123,7124,7125,7126,7127,7128,7129,7130,7131,7132,7133,7134,7135,7136,7137,7138,
7139,7140,7141,7142,7143,7144,7145,7146,7147,7148,7149,7150,7151,7152,7153,7154,
7155,7156,7157,7158,7159,7160,7161,7162,7163,7164,7165,7166,7167,7168,7169,7170,
7171,7172,7173,7174,7175,7176,7177,7178,7179,7180,7181,7182,7183,7184,7185,7186,
7187,7188,7189,7190,7191,7192,7193,7194,7195,7196,7197,7198,7199,7200,7201,7202,
7203,7204,7205,7206,7207,1395,7208,7209,7210,7211,7212,7213,1717,7214,7215,7216,
7217,7218,7219,7220,7221,7222,7223,7224,7225,7226,7227,7228,7229,7230,7231,7232,
7233,7234,7235,7236,7237,7238,7239,7240,7241,7242,7243,7244,7245,7246,7247,7248,
7249,7250,7251,7252,7253,7254,7255,7256,7257,7258,7259,7260,7261,7262,7263,7264,
7265,7266,7267,7268,7269,7270,7271,7272,7273,7274,7275,7276,7277,7278,7279,7280,
7281,7282,7283,7284,7285,7286,7287,7288,7289,7290,7291,7292,7293,7294,7295,7296,
7297,7298,7299,7300,7301,7302,7303,7304,7305,7306,7307,7308,7309,7310,7311,7312,
7313,1718,7314,7315,7316,7317,7318,7319,7320,7321,7322,7323,7324,7325,7326,7327,
7328,7329,7330,7331,7332,7333,7334,7335,7336,7337,7338,7339,7340,7341,7342,7343,
7344,7345,7346,7347,7348,7349,7350,7351,7352,7353,7354,7355,7356,7357,7358,7359,
7360,7361,7362,7363,7364,7365,7366,7367,7368,7369,7370,7371,7372,7373,7374,7375,
7376,7377,7378,7379,7380,7381,7382,7383,7384,7385,7386,7387,7388,7389,7390,7391,
7392,7393,7394,7395,7396,7397,7398,7399,7400,7401,7402,7403,7404,7405,7406,7407,
7408,7409,7410,7411,7412,7413,7414,7415,7416,7417,7418,7419,7420,7421,7422,7423,
7424,7425,7426,7427,7428,7429,7430,7431,7432,7433,7434,7435,7436,7437,7438,7439,
7440,7441,7442,7443,7444,7445,7446,7447,7448,7449,7450,7451,7452,7453,7454,7455,
7456,7457,7458,7459,7460,7461,7462,7463,7464,7465,7466,7467,7468,7469,7470,7471,
7472,7473,7474,7475,7476,7477,7478,7479,7480,7481,7482,7483,7484,7485,7486,7487,
7488,7489,7490,7491,7492,7493,7494,7495,7496,7497,7498,7499,7500,7501,7502,7503,
7504,7505,7506,7507,7508,7509,7510,7511,7512,7513,7514,7515,7516,7517,7518,7519,
7520,7521,7522,7523,7524,7525,7526,7527,7528,7529,7530,7531,7532,7533,7534,7535,
7536,7537,7538,7539,7540,7541,7542,7543,7544,7545,7546,7547,7548,7549,7550,7551,
7552,7553,7554,7555,7556,7557,7558,7559,7560,7561,7562,7563,7564,7565,7566,7567,
7568,7569,7570,7571,7572,7573,7574,7575,7576,7577,7578,7579,7580,7581,7582,7583,
7584,7585,7586,7587,7588,7589,7590,7591,7592,7593,7594,7595,7596,7597,7598,7599,
7600,7601,7602,7603,7604,7605,7606,7607,7608,7609,7610,7611,7612,7613,7614,7615,
7616,7617,7618,7619,7620,7621,7622,7623,7624,7625,7626,7627,7628,7629,7630,7631,
7632,7633,7634,7635,7636,7637,7638,7639,7640,7641,7642,7643,7644,7645,7646,7647,
7648,7649,7650,7651,7652,7653,7654,7655,7656,7657,7658,7659,7660,7661,7662,7663,
7664,7665,7666,7667,7668,7669,7670,7671,7672,7673,7674,7675,7676,7677,7678,7679,
7680,7681,7682,7683,7684,7685,7686,7687,7688,7689,7690,7691,7692,7693,7694,7695,
7696,7697,7698,7699,7700,7701,7702,7703,7704,7705,7706,7707,7708,7709,7710,7711,
7712,7713,7714,7715,7716,7717,7718,7719,7720,7721,7722,7723,7724,7725,7726,7727,
7728,7729,7730,7731,7732,7733,7734,7735,7736,7737,7738,7739,7740,7741,7742,7743,
7744,7745,7746,7747,7748,7749,7750,7751,7752,7753,7754,7755,7756,7757,7758,7759,
7760,7761,7762,7763,7764,7765,7766,7767,7768,7769,7770,7771,7772,7773,7774,7775,
7776,7777,7778,7779,7780,7781,7782,7783,7784,7785,7786,7787,7788,7789,7790,7791,
7792,7793,7794,7795,7796,7797,7798,7799,7800,7801,7802,7803,7804,7805,7806,7807,
7808,7809,7810,7811,7812,7813,7814,7815,7816,7817,7818,7819,7820,7821,7822,7823,
7824,7825,7826,7827,7828,7829,7830,7831,7832,7833,7834,7835,7836,7837,7838,7839,
7840,7841,7842,7843,7844,7845,7846,7847,7848,7849,7850,7851,7852,7853,7854,7855,
7856,7857,7858,7859,7860,7861,7862,7863,7864,7865,7866,7867,7868,7869,7870,7871,
7872,7873,7874,7875,7876,7877,7878,7879,7880,7881,7882,7883,7884,7885,7886,7887,
7888,7889,7890,7891,7892,7893,7894,7895,7896,7897,7898,7899,7900,7901,7902,7903,
7904,7905,7906,7907,7908,7909,7910,7911,7912,7913,7914,7915,7916,7917,7918,7919,
7920,7921,7922,7923,7924,7925,7926,7927,7928,7929,7930,7931,7932,7933,7934,7935,
7936,7937,7938,7939,7940,7941,7942,7943,7944,7945,7946,7947,7948,7949,7950,7951,
7952,7953,7954,7955,7956,7957,7958,7959,7960,7961,7962,7963,7964,7965,7966,7967,
7968,7969,7970,7971,7972,7973,7974,7975,7976,7977,7978,7979,7980,7981,7982,7983,
7984,7985,7986,7987,7988,7989,7990,7991,7992,7993,7994,7995,7996,7997,7998,7999,
8000,8001,8002,8003,8004,8005,8006,8007,8008,8009,8010,8011,8012,8013,8014,8015,
8016,8017,8018,8019,8020,8021,8022,8023,8024,8025,8026,8027,8028,8029,8030,8031,
8032,8033,8034,8035,8036,8037,8038,8039,8040,8041,8042,8043,8044,8045,8046,8047,
8048,8049,8050,8051,8052,8053,8054,8055,8056,8057,8058,8059,8060,8061,8062,8063,
8064,8065,8066,8067,8068,8069,8070,8071,8072,8073,8074,8075,8076,8077,8078,8079,
8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,
8096,8097,8098,8099,8100,8101,8102,8103,8104,8105,8106,8107,8108,8109,8110,8111,
8112,8113,8114,8115,8116,8117,8118,8119,8120,8121,8122,8123,8124,8125,8126,8127,
8128,8129,8130,8131,8132,8133,8134,8135,8136,8137,8138,8139,8140,8141,8142,8143,
8144,8145,8146,8147,8148,8149,8150,8151,8152,8153,8154,8155,8156,8157,8158,8159,
8160,8161,8162,8163,8164,8165,8166,8167,8168,8169,8170,8171,8172,8173,8174,8175,
8176,8177,8178,8179,8180,8181,8182,8183,8184,8185,8186,8187,8188,8189,8190,8191,
8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,
8208,8209,8210,8211,8212,8213,8214,8215,8216,8217,8218,8219,8220,8221,8222,8223,
8224,8225,8226,8227,8228,8229,8230,8231,8232,8233,8234,8235,8236,8237,8238,8239,
8240,8241,8242,8243,8244,8245,8246,8247,8248,8249,8250,8251,8252,8253,8254,8255,
8256,8257,8258,8259,8260,8261,8262,8263,8264,8265,8266,8267,8268,8269,8270,8271,
8272,8273,8274,8275,8276,8277,8278,8279,8280,8281,8282,8283,8284,8285,8286,8287,
8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,
8304,8305,8306,8307,8308,8309,8310,8311,8312,8313,8314,8315,8316,8317,8318,8319,
8320,8321,8322,8323,8324,8325,8326,8327,8328,8329,8330,8331,8332,8333,8334,8335,
8336,8337,8338,8339,8340,8341,8342,8343,8344,8345,8346,8347,8348,8349,8350,8351,
8352,8353,8354,8355,8356,8357,8358,8359,8360,8361,8362,8363,8364,8365,8366,8367,
8368,8369,8370,8371,8372,8373,8374,8375,8376,8377,8378,8379,8380,8381,8382,8383,
8384,8385,8386,8387,8388,8389,8390,8391,8392,8393,8394,8395,8396,8397,8398,8399,
8400,8401,8402,8403,8404,8405,8406,8407,8408,8409,8410,8411,8412,8413,8414,8415,
8416,8417,8418,8419,8420,8421,8422,8423,8424,8425,8426,8427,8428,8429,8430,8431,
8432,8433,8434,8435,8436,8437,8438,8439,8440,8441,8442,8443,8444,8445,8446,8447,
8448,8449,8450,8451,8452,8453,8454,8455,8456,8457,8458,8459,8460,8461,8462,8463,
8464,8465,8466,8467,8468,8469,8470,8471,8472,8473,8474,8475,8476,8477,8478,8479,
8480,8481,8482,8483,8484,8485,8486,8487,8488,8489,8490,8491,8492,8493,8494,8495,
8496,8497,8498,8499,8500,8501,8502,8503,8504,8505,8506,8507,8508,8509,8510,8511,
8512,8513,8514,8515,8516,8517,8518,8519,8520,8521,8522,8523,8524,8525,8526,8527,
8528,8529,8530,8531,8532,8533,8534,8535,8536,8537,8538,8539,8540,8541,8542,8543,
8544,8545,8546,8547,8548,8549,8550,8551,8552,8553,8554,8555,8556,8557,8558,8559,
8560,8561,8562,8563,8564,8565,8566,8567,8568,8569,8570,8571,8572,8573,8574,8575,
8576,8577,8578,8579,8580,8581,8582,8583,8584,8585,8586,8587,8588,8589,8590,8591,
8592,8593,8594,8595,8596,8597,8598,8599,8600,8601,8602,8603,8604,8605,8606,8607,
8608,8609,8610,8611,8612,8613,8614,8615,8616,8617,8618,8619,8620,8621,8622,8623,
8624,8625,8626,8627,8628,8629,8630,8631,8632,8633,8634,8635,8636,8637,8638,8639,
8640,8641,8642,8643,8644,8645,8646,8647,8648,8649,8650,8651,8652,8653,8654,8655,
8656,8657,8658,8659,8660,8661,8662,8663,8664,8665,8666,8667,8668,8669,8670,8671,
8672,8673,8674,8675,8676,8677,8678,8679,8680,8681,8682,8683,8684,8685,8686,8687,
8688,8689,8690,8691,8692,8693,8694,8695,8696,8697,8698,8699,8700,8701,8702,8703,
8704,8705,8706,8707,8708,8709,8710,8711,8712,8713,8714,8715,8716,8717,8718,8719,
8720,8721,8722,8723,8724,8725,8726,8727,8728,8729,8730,8731,8732,8733,8734,8735,
8736,8737,8738,8739,8740,8741)

# flake8: noqa

########NEW FILE########
__FILENAME__ = euckrprober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import EUCKRDistributionAnalysis
from .mbcssm import EUCKRSMModel


class EUCKRProber(MultiByteCharSetProber):
    def __init__(self):
        MultiByteCharSetProber.__init__(self)
        self._mCodingSM = CodingStateMachine(EUCKRSMModel)
        self._mDistributionAnalyzer = EUCKRDistributionAnalysis()
        self.reset()

    def get_charset_name(self):
        return "EUC-KR"

########NEW FILE########
__FILENAME__ = euctwfreq
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# EUCTW frequency table
# Converted from big5 work
# by Taiwan's Mandarin Promotion Council
# <http:#www.edu.tw:81/mandr/>

# 128  --> 0.42261
# 256  --> 0.57851
# 512  --> 0.74851
# 1024 --> 0.89384
# 2048 --> 0.97583
#
# Idea Distribution Ratio = 0.74851/(1-0.74851) =2.98
# Random Distribution Ration = 512/(5401-512)=0.105
#
# Typical Distribution Ratio about 25% of Ideal one, still much higher than RDR

EUCTW_TYPICAL_DISTRIBUTION_RATIO = 0.75

# Char to FreqOrder table ,
EUCTW_TABLE_SIZE = 8102

EUCTWCharToFreqOrder = (
   1,1800,1506, 255,1431, 198,   9,  82,   6,7310, 177, 202,3615,1256,2808, 110, # 2742
3735,  33,3241, 261,  76,  44,2113,  16,2931,2184,1176, 659,3868,  26,3404,2643, # 2758
1198,3869,3313,4060, 410,2211, 302, 590, 361,1963,   8, 204,  58,4296,7311,1931, # 2774
  63,7312,7313, 317,1614,  75, 222, 159,4061,2412,1480,7314,3500,3068, 224,2809, # 2790
3616,   3,  10,3870,1471,  29,2774,1135,2852,1939, 873, 130,3242,1123, 312,7315, # 2806
4297,2051, 507, 252, 682,7316, 142,1914, 124, 206,2932,  34,3501,3173,  64, 604, # 2822
7317,2494,1976,1977, 155,1990, 645, 641,1606,7318,3405, 337,  72, 406,7319,  80, # 2838
 630, 238,3174,1509, 263, 939,1092,2644, 756,1440,1094,3406, 449,  69,2969, 591, # 2854
 179,2095, 471, 115,2034,1843,  60,  50,2970, 134, 806,1868, 734,2035,3407, 180, # 2870
 995,1607, 156, 537,2893, 688,7320, 319,1305, 779,2144, 514,2374, 298,4298, 359, # 2886
2495,  90,2707,1338, 663,  11, 906,1099,2545,  20,2436, 182, 532,1716,7321, 732, # 2902
1376,4062,1311,1420,3175,  25,2312,1056, 113, 399, 382,1949, 242,3408,2467, 529, # 2918
3243, 475,1447,3617,7322, 117,  21, 656, 810,1297,2295,2329,3502,7323, 126,4063, # 2934
 706, 456, 150, 613,4299,  71,1118,2036,4064, 145,3069,  85, 835, 486,2114,1246, # 2950
1426, 428, 727,1285,1015, 800, 106, 623, 303,1281,7324,2127,2354, 347,3736, 221, # 2966
3503,3110,7325,1955,1153,4065,  83, 296,1199,3070, 192, 624,  93,7326, 822,1897, # 2982
2810,3111, 795,2064, 991,1554,1542,1592,  27,  43,2853, 859, 139,1456, 860,4300, # 2998
 437, 712,3871, 164,2392,3112, 695, 211,3017,2096, 195,3872,1608,3504,3505,3618, # 3014
3873, 234, 811,2971,2097,3874,2229,1441,3506,1615,2375, 668,2076,1638, 305, 228, # 3030
1664,4301, 467, 415,7327, 262,2098,1593, 239, 108, 300, 200,1033, 512,1247,2077, # 3046
7328,7329,2173,3176,3619,2673, 593, 845,1062,3244,  88,1723,2037,3875,1950, 212, # 3062
 266, 152, 149, 468,1898,4066,4302,  77, 187,7330,3018,  37,   5,2972,7331,3876, # 3078
7332,7333,  39,2517,4303,2894,3177,2078,  55, 148,  74,4304, 545, 483,1474,1029, # 3094
1665, 217,1869,1531,3113,1104,2645,4067,  24, 172,3507, 900,3877,3508,3509,4305, # 3110
  32,1408,2811,1312, 329, 487,2355,2247,2708, 784,2674,   4,3019,3314,1427,1788, # 3126
 188, 109, 499,7334,3620,1717,1789, 888,1217,3020,4306,7335,3510,7336,3315,1520, # 3142
3621,3878, 196,1034, 775,7337,7338, 929,1815, 249, 439,  38,7339,1063,7340, 794, # 3158
3879,1435,2296,  46, 178,3245,2065,7341,2376,7342, 214,1709,4307, 804,  35, 707, # 3174
 324,3622,1601,2546, 140, 459,4068,7343,7344,1365, 839, 272, 978,2257,2572,3409, # 3190
2128,1363,3623,1423, 697, 100,3071,  48,  70,1231, 495,3114,2193,7345,1294,7346, # 3206
2079, 462, 586,1042,3246, 853, 256, 988, 185,2377,3410,1698, 434,1084,7347,3411, # 3222
 314,2615,2775,4308,2330,2331, 569,2280, 637,1816,2518, 757,1162,1878,1616,3412, # 3238
 287,1577,2115, 768,4309,1671,2854,3511,2519,1321,3737, 909,2413,7348,4069, 933, # 3254
3738,7349,2052,2356,1222,4310, 765,2414,1322, 786,4311,7350,1919,1462,1677,2895, # 3270
1699,7351,4312,1424,2437,3115,3624,2590,3316,1774,1940,3413,3880,4070, 309,1369, # 3286
1130,2812, 364,2230,1653,1299,3881,3512,3882,3883,2646, 525,1085,3021, 902,2000, # 3302
1475, 964,4313, 421,1844,1415,1057,2281, 940,1364,3116, 376,4314,4315,1381,   7, # 3318
2520, 983,2378, 336,1710,2675,1845, 321,3414, 559,1131,3022,2742,1808,1132,1313, # 3334
 265,1481,1857,7352, 352,1203,2813,3247, 167,1089, 420,2814, 776, 792,1724,3513, # 3350
4071,2438,3248,7353,4072,7354, 446, 229, 333,2743, 901,3739,1200,1557,4316,2647, # 3366
1920, 395,2744,2676,3740,4073,1835, 125, 916,3178,2616,4317,7355,7356,3741,7357, # 3382
7358,7359,4318,3117,3625,1133,2547,1757,3415,1510,2313,1409,3514,7360,2145, 438, # 3398
2591,2896,2379,3317,1068, 958,3023, 461, 311,2855,2677,4074,1915,3179,4075,1978, # 3414
 383, 750,2745,2617,4076, 274, 539, 385,1278,1442,7361,1154,1964, 384, 561, 210, # 3430
  98,1295,2548,3515,7362,1711,2415,1482,3416,3884,2897,1257, 129,7363,3742, 642, # 3446
 523,2776,2777,2648,7364, 141,2231,1333,  68, 176, 441, 876, 907,4077, 603,2592, # 3462
 710, 171,3417, 404, 549,  18,3118,2393,1410,3626,1666,7365,3516,4319,2898,4320, # 3478
7366,2973, 368,7367, 146, 366,  99, 871,3627,1543, 748, 807,1586,1185,  22,2258, # 3494
 379,3743,3180,7368,3181, 505,1941,2618,1991,1382,2314,7369, 380,2357, 218, 702, # 3510
1817,1248,3418,3024,3517,3318,3249,7370,2974,3628, 930,3250,3744,7371,  59,7372, # 3526
 585, 601,4078, 497,3419,1112,1314,4321,1801,7373,1223,1472,2174,7374, 749,1836, # 3542
 690,1899,3745,1772,3885,1476, 429,1043,1790,2232,2116, 917,4079, 447,1086,1629, # 3558
7375, 556,7376,7377,2020,1654, 844,1090, 105, 550, 966,1758,2815,1008,1782, 686, # 3574
1095,7378,2282, 793,1602,7379,3518,2593,4322,4080,2933,2297,4323,3746, 980,2496, # 3590
 544, 353, 527,4324, 908,2678,2899,7380, 381,2619,1942,1348,7381,1341,1252, 560, # 3606
3072,7382,3420,2856,7383,2053, 973, 886,2080, 143,4325,7384,7385, 157,3886, 496, # 3622
4081,  57, 840, 540,2038,4326,4327,3421,2117,1445, 970,2259,1748,1965,2081,4082, # 3638
3119,1234,1775,3251,2816,3629, 773,1206,2129,1066,2039,1326,3887,1738,1725,4083, # 3654
 279,3120,  51,1544,2594, 423,1578,2130,2066, 173,4328,1879,7386,7387,1583, 264, # 3670
 610,3630,4329,2439, 280, 154,7388,7389,7390,1739, 338,1282,3073, 693,2857,1411, # 3686
1074,3747,2440,7391,4330,7392,7393,1240, 952,2394,7394,2900,1538,2679, 685,1483, # 3702
4084,2468,1436, 953,4085,2054,4331, 671,2395,  79,4086,2441,3252, 608, 567,2680, # 3718
3422,4087,4088,1691, 393,1261,1791,2396,7395,4332,7396,7397,7398,7399,1383,1672, # 3734
3748,3182,1464, 522,1119, 661,1150, 216, 675,4333,3888,1432,3519, 609,4334,2681, # 3750
2397,7400,7401,7402,4089,3025,   0,7403,2469, 315, 231,2442, 301,3319,4335,2380, # 3766
7404, 233,4090,3631,1818,4336,4337,7405,  96,1776,1315,2082,7406, 257,7407,1809, # 3782
3632,2709,1139,1819,4091,2021,1124,2163,2778,1777,2649,7408,3074, 363,1655,3183, # 3798
7409,2975,7410,7411,7412,3889,1567,3890, 718, 103,3184, 849,1443, 341,3320,2934, # 3814
1484,7413,1712, 127,  67, 339,4092,2398, 679,1412, 821,7414,7415, 834, 738, 351, # 3830
2976,2146, 846, 235,1497,1880, 418,1992,3749,2710, 186,1100,2147,2746,3520,1545, # 3846
1355,2935,2858,1377, 583,3891,4093,2573,2977,7416,1298,3633,1078,2549,3634,2358, # 3862
  78,3750,3751, 267,1289,2099,2001,1594,4094, 348, 369,1274,2194,2175,1837,4338, # 3878
1820,2817,3635,2747,2283,2002,4339,2936,2748, 144,3321, 882,4340,3892,2749,3423, # 3894
4341,2901,7417,4095,1726, 320,7418,3893,3026, 788,2978,7419,2818,1773,1327,2859, # 3910
3894,2819,7420,1306,4342,2003,1700,3752,3521,2359,2650, 787,2022, 506, 824,3636, # 3926
 534, 323,4343,1044,3322,2023,1900, 946,3424,7421,1778,1500,1678,7422,1881,4344, # 3942
 165, 243,4345,3637,2521, 123, 683,4096, 764,4346,  36,3895,1792, 589,2902, 816, # 3958
 626,1667,3027,2233,1639,1555,1622,3753,3896,7423,3897,2860,1370,1228,1932, 891, # 3974
2083,2903, 304,4097,7424, 292,2979,2711,3522, 691,2100,4098,1115,4347, 118, 662, # 3990
7425, 611,1156, 854,2381,1316,2861,   2, 386, 515,2904,7426,7427,3253, 868,2234, # 4006
1486, 855,2651, 785,2212,3028,7428,1040,3185,3523,7429,3121, 448,7430,1525,7431, # 4022
2164,4348,7432,3754,7433,4099,2820,3524,3122, 503, 818,3898,3123,1568, 814, 676, # 4038
1444, 306,1749,7434,3755,1416,1030, 197,1428, 805,2821,1501,4349,7435,7436,7437, # 4054
1993,7438,4350,7439,7440,2195,  13,2779,3638,2980,3124,1229,1916,7441,3756,2131, # 4070
7442,4100,4351,2399,3525,7443,2213,1511,1727,1120,7444,7445, 646,3757,2443, 307, # 4086
7446,7447,1595,3186,7448,7449,7450,3639,1113,1356,3899,1465,2522,2523,7451, 519, # 4102
7452, 128,2132,  92,2284,1979,7453,3900,1512, 342,3125,2196,7454,2780,2214,1980, # 4118
3323,7455, 290,1656,1317, 789, 827,2360,7456,3758,4352, 562, 581,3901,7457, 401, # 4134
4353,2248,  94,4354,1399,2781,7458,1463,2024,4355,3187,1943,7459, 828,1105,4101, # 4150
1262,1394,7460,4102, 605,4356,7461,1783,2862,7462,2822, 819,2101, 578,2197,2937, # 4166
7463,1502, 436,3254,4103,3255,2823,3902,2905,3425,3426,7464,2712,2315,7465,7466, # 4182
2332,2067,  23,4357, 193, 826,3759,2102, 699,1630,4104,3075, 390,1793,1064,3526, # 4198
7467,1579,3076,3077,1400,7468,4105,1838,1640,2863,7469,4358,4359, 137,4106, 598, # 4214
3078,1966, 780, 104, 974,2938,7470, 278, 899, 253, 402, 572, 504, 493,1339,7471, # 4230
3903,1275,4360,2574,2550,7472,3640,3029,3079,2249, 565,1334,2713, 863,  41,7473, # 4246
7474,4361,7475,1657,2333,  19, 463,2750,4107, 606,7476,2981,3256,1087,2084,1323, # 4262
2652,2982,7477,1631,1623,1750,4108,2682,7478,2864, 791,2714,2653,2334, 232,2416, # 4278
7479,2983,1498,7480,2654,2620, 755,1366,3641,3257,3126,2025,1609, 119,1917,3427, # 4294
 862,1026,4109,7481,3904,3760,4362,3905,4363,2260,1951,2470,7482,1125, 817,4110, # 4310
4111,3906,1513,1766,2040,1487,4112,3030,3258,2824,3761,3127,7483,7484,1507,7485, # 4326
2683, 733,  40,1632,1106,2865, 345,4113, 841,2524, 230,4364,2984,1846,3259,3428, # 4342
7486,1263, 986,3429,7487, 735, 879, 254,1137, 857, 622,1300,1180,1388,1562,3907, # 4358
3908,2939, 967,2751,2655,1349, 592,2133,1692,3324,2985,1994,4114,1679,3909,1901, # 4374
2185,7488, 739,3642,2715,1296,1290,7489,4115,2198,2199,1921,1563,2595,2551,1870, # 4390
2752,2986,7490, 435,7491, 343,1108, 596,  17,1751,4365,2235,3430,3643,7492,4366, # 4406
 294,3527,2940,1693, 477, 979, 281,2041,3528, 643,2042,3644,2621,2782,2261,1031, # 4422
2335,2134,2298,3529,4367, 367,1249,2552,7493,3530,7494,4368,1283,3325,2004, 240, # 4438
1762,3326,4369,4370, 836,1069,3128, 474,7495,2148,2525, 268,3531,7496,3188,1521, # 4454
1284,7497,1658,1546,4116,7498,3532,3533,7499,4117,3327,2684,1685,4118, 961,1673, # 4470
2622, 190,2005,2200,3762,4371,4372,7500, 570,2497,3645,1490,7501,4373,2623,3260, # 4486
1956,4374, 584,1514, 396,1045,1944,7502,4375,1967,2444,7503,7504,4376,3910, 619, # 4502
7505,3129,3261, 215,2006,2783,2553,3189,4377,3190,4378, 763,4119,3763,4379,7506, # 4518
7507,1957,1767,2941,3328,3646,1174, 452,1477,4380,3329,3130,7508,2825,1253,2382, # 4534
2186,1091,2285,4120, 492,7509, 638,1169,1824,2135,1752,3911, 648, 926,1021,1324, # 4550
4381, 520,4382, 997, 847,1007, 892,4383,3764,2262,1871,3647,7510,2400,1784,4384, # 4566
1952,2942,3080,3191,1728,4121,2043,3648,4385,2007,1701,3131,1551,  30,2263,4122, # 4582
7511,2026,4386,3534,7512, 501,7513,4123, 594,3431,2165,1821,3535,3432,3536,3192, # 4598
 829,2826,4124,7514,1680,3132,1225,4125,7515,3262,4387,4126,3133,2336,7516,4388, # 4614
4127,7517,3912,3913,7518,1847,2383,2596,3330,7519,4389, 374,3914, 652,4128,4129, # 4630
 375,1140, 798,7520,7521,7522,2361,4390,2264, 546,1659, 138,3031,2445,4391,7523, # 4646
2250, 612,1848, 910, 796,3765,1740,1371, 825,3766,3767,7524,2906,2554,7525, 692, # 4662
 444,3032,2624, 801,4392,4130,7526,1491, 244,1053,3033,4131,4132, 340,7527,3915, # 4678
1041,2987, 293,1168,  87,1357,7528,1539, 959,7529,2236, 721, 694,4133,3768, 219, # 4694
1478, 644,1417,3331,2656,1413,1401,1335,1389,3916,7530,7531,2988,2362,3134,1825, # 4710
 730,1515, 184,2827,  66,4393,7532,1660,2943, 246,3332, 378,1457, 226,3433, 975, # 4726
3917,2944,1264,3537, 674, 696,7533, 163,7534,1141,2417,2166, 713,3538,3333,4394, # 4742
3918,7535,7536,1186,  15,7537,1079,1070,7538,1522,3193,3539, 276,1050,2716, 758, # 4758
1126, 653,2945,3263,7539,2337, 889,3540,3919,3081,2989, 903,1250,4395,3920,3434, # 4774
3541,1342,1681,1718, 766,3264, 286,  89,2946,3649,7540,1713,7541,2597,3334,2990, # 4790
7542,2947,2215,3194,2866,7543,4396,2498,2526, 181, 387,1075,3921, 731,2187,3335, # 4806
7544,3265, 310, 313,3435,2299, 770,4134,  54,3034, 189,4397,3082,3769,3922,7545, # 4822
1230,1617,1849, 355,3542,4135,4398,3336, 111,4136,3650,1350,3135,3436,3035,4137, # 4838
2149,3266,3543,7546,2784,3923,3924,2991, 722,2008,7547,1071, 247,1207,2338,2471, # 4854
1378,4399,2009, 864,1437,1214,4400, 373,3770,1142,2216, 667,4401, 442,2753,2555, # 4870
3771,3925,1968,4138,3267,1839, 837, 170,1107, 934,1336,1882,7548,7549,2118,4139, # 4886
2828, 743,1569,7550,4402,4140, 582,2384,1418,3437,7551,1802,7552, 357,1395,1729, # 4902
3651,3268,2418,1564,2237,7553,3083,3772,1633,4403,1114,2085,4141,1532,7554, 482, # 4918
2446,4404,7555,7556,1492, 833,1466,7557,2717,3544,1641,2829,7558,1526,1272,3652, # 4934
4142,1686,1794, 416,2556,1902,1953,1803,7559,3773,2785,3774,1159,2316,7560,2867, # 4950
4405,1610,1584,3036,2419,2754, 443,3269,1163,3136,7561,7562,3926,7563,4143,2499, # 4966
3037,4406,3927,3137,2103,1647,3545,2010,1872,4144,7564,4145, 431,3438,7565, 250, # 4982
  97,  81,4146,7566,1648,1850,1558, 160, 848,7567, 866, 740,1694,7568,2201,2830, # 4998
3195,4147,4407,3653,1687, 950,2472, 426, 469,3196,3654,3655,3928,7569,7570,1188, # 5014
 424,1995, 861,3546,4148,3775,2202,2685, 168,1235,3547,4149,7571,2086,1674,4408, # 5030
3337,3270, 220,2557,1009,7572,3776, 670,2992, 332,1208, 717,7573,7574,3548,2447, # 5046
3929,3338,7575, 513,7576,1209,2868,3339,3138,4409,1080,7577,7578,7579,7580,2527, # 5062
3656,3549, 815,1587,3930,3931,7581,3550,3439,3777,1254,4410,1328,3038,1390,3932, # 5078
1741,3933,3778,3934,7582, 236,3779,2448,3271,7583,7584,3657,3780,1273,3781,4411, # 5094
7585, 308,7586,4412, 245,4413,1851,2473,1307,2575, 430, 715,2136,2449,7587, 270, # 5110
 199,2869,3935,7588,3551,2718,1753, 761,1754, 725,1661,1840,4414,3440,3658,7589, # 5126
7590, 587,  14,3272, 227,2598, 326, 480,2265, 943,2755,3552, 291, 650,1883,7591, # 5142
1702,1226, 102,1547,  62,3441, 904,4415,3442,1164,4150,7592,7593,1224,1548,2756, # 5158
 391, 498,1493,7594,1386,1419,7595,2055,1177,4416, 813, 880,1081,2363, 566,1145, # 5174
4417,2286,1001,1035,2558,2599,2238, 394,1286,7596,7597,2068,7598,  86,1494,1730, # 5190
3936, 491,1588, 745, 897,2948, 843,3340,3937,2757,2870,3273,1768, 998,2217,2069, # 5206
 397,1826,1195,1969,3659,2993,3341, 284,7599,3782,2500,2137,2119,1903,7600,3938, # 5222
2150,3939,4151,1036,3443,1904, 114,2559,4152, 209,1527,7601,7602,2949,2831,2625, # 5238
2385,2719,3139, 812,2560,7603,3274,7604,1559, 737,1884,3660,1210, 885,  28,2686, # 5254
3553,3783,7605,4153,1004,1779,4418,7606, 346,1981,2218,2687,4419,3784,1742, 797, # 5270
1642,3940,1933,1072,1384,2151, 896,3941,3275,3661,3197,2871,3554,7607,2561,1958, # 5286
4420,2450,1785,7608,7609,7610,3942,4154,1005,1308,3662,4155,2720,4421,4422,1528, # 5302
2600, 161,1178,4156,1982, 987,4423,1101,4157, 631,3943,1157,3198,2420,1343,1241, # 5318
1016,2239,2562, 372, 877,2339,2501,1160, 555,1934, 911,3944,7611, 466,1170, 169, # 5334
1051,2907,2688,3663,2474,2994,1182,2011,2563,1251,2626,7612, 992,2340,3444,1540, # 5350
2721,1201,2070,2401,1996,2475,7613,4424, 528,1922,2188,1503,1873,1570,2364,3342, # 5366
3276,7614, 557,1073,7615,1827,3445,2087,2266,3140,3039,3084, 767,3085,2786,4425, # 5382
1006,4158,4426,2341,1267,2176,3664,3199, 778,3945,3200,2722,1597,2657,7616,4427, # 5398
7617,3446,7618,7619,7620,3277,2689,1433,3278, 131,  95,1504,3946, 723,4159,3141, # 5414
1841,3555,2758,2189,3947,2027,2104,3665,7621,2995,3948,1218,7622,3343,3201,3949, # 5430
4160,2576, 248,1634,3785, 912,7623,2832,3666,3040,3786, 654,  53,7624,2996,7625, # 5446
1688,4428, 777,3447,1032,3950,1425,7626, 191, 820,2120,2833, 971,4429, 931,3202, # 5462
 135, 664, 783,3787,1997, 772,2908,1935,3951,3788,4430,2909,3203, 282,2723, 640, # 5478
1372,3448,1127, 922, 325,3344,7627,7628, 711,2044,7629,7630,3952,2219,2787,1936, # 5494
3953,3345,2220,2251,3789,2300,7631,4431,3790,1258,3279,3954,3204,2138,2950,3955, # 5510
3956,7632,2221, 258,3205,4432, 101,1227,7633,3280,1755,7634,1391,3281,7635,2910, # 5526
2056, 893,7636,7637,7638,1402,4161,2342,7639,7640,3206,3556,7641,7642, 878,1325, # 5542
1780,2788,4433, 259,1385,2577, 744,1183,2267,4434,7643,3957,2502,7644, 684,1024, # 5558
4162,7645, 472,3557,3449,1165,3282,3958,3959, 322,2152, 881, 455,1695,1152,1340, # 5574
 660, 554,2153,4435,1058,4436,4163, 830,1065,3346,3960,4437,1923,7646,1703,1918, # 5590
7647, 932,2268, 122,7648,4438, 947, 677,7649,3791,2627, 297,1905,1924,2269,4439, # 5606
2317,3283,7650,7651,4164,7652,4165,  84,4166, 112, 989,7653, 547,1059,3961, 701, # 5622
3558,1019,7654,4167,7655,3450, 942, 639, 457,2301,2451, 993,2951, 407, 851, 494, # 5638
4440,3347, 927,7656,1237,7657,2421,3348, 573,4168, 680, 921,2911,1279,1874, 285, # 5654
 790,1448,1983, 719,2167,7658,7659,4441,3962,3963,1649,7660,1541, 563,7661,1077, # 5670
7662,3349,3041,3451, 511,2997,3964,3965,3667,3966,1268,2564,3350,3207,4442,4443, # 5686
7663, 535,1048,1276,1189,2912,2028,3142,1438,1373,2834,2952,1134,2012,7664,4169, # 5702
1238,2578,3086,1259,7665, 700,7666,2953,3143,3668,4170,7667,4171,1146,1875,1906, # 5718
4444,2601,3967, 781,2422, 132,1589, 203, 147, 273,2789,2402, 898,1786,2154,3968, # 5734
3969,7668,3792,2790,7669,7670,4445,4446,7671,3208,7672,1635,3793, 965,7673,1804, # 5750
2690,1516,3559,1121,1082,1329,3284,3970,1449,3794,  65,1128,2835,2913,2759,1590, # 5766
3795,7674,7675,  12,2658,  45, 976,2579,3144,4447, 517,2528,1013,1037,3209,7676, # 5782
3796,2836,7677,3797,7678,3452,7679,2602, 614,1998,2318,3798,3087,2724,2628,7680, # 5798
2580,4172, 599,1269,7681,1810,3669,7682,2691,3088, 759,1060, 489,1805,3351,3285, # 5814
1358,7683,7684,2386,1387,1215,2629,2252, 490,7685,7686,4173,1759,2387,2343,7687, # 5830
4448,3799,1907,3971,2630,1806,3210,4449,3453,3286,2760,2344, 874,7688,7689,3454, # 5846
3670,1858,  91,2914,3671,3042,3800,4450,7690,3145,3972,2659,7691,3455,1202,1403, # 5862
3801,2954,2529,1517,2503,4451,3456,2504,7692,4452,7693,2692,1885,1495,1731,3973, # 5878
2365,4453,7694,2029,7695,7696,3974,2693,1216, 237,2581,4174,2319,3975,3802,4454, # 5894
4455,2694,3560,3457, 445,4456,7697,7698,7699,7700,2761,  61,3976,3672,1822,3977, # 5910
7701, 687,2045, 935, 925, 405,2660, 703,1096,1859,2725,4457,3978,1876,1367,2695, # 5926
3352, 918,2105,1781,2476, 334,3287,1611,1093,4458, 564,3146,3458,3673,3353, 945, # 5942
2631,2057,4459,7702,1925, 872,4175,7703,3459,2696,3089, 349,4176,3674,3979,4460, # 5958
3803,4177,3675,2155,3980,4461,4462,4178,4463,2403,2046, 782,3981, 400, 251,4179, # 5974
1624,7704,7705, 277,3676, 299,1265, 476,1191,3804,2121,4180,4181,1109, 205,7706, # 5990
2582,1000,2156,3561,1860,7707,7708,7709,4464,7710,4465,2565, 107,2477,2157,3982, # 6006
3460,3147,7711,1533, 541,1301, 158, 753,4182,2872,3562,7712,1696, 370,1088,4183, # 6022
4466,3563, 579, 327, 440, 162,2240, 269,1937,1374,3461, 968,3043,  56,1396,3090, # 6038
2106,3288,3354,7713,1926,2158,4467,2998,7714,3564,7715,7716,3677,4468,2478,7717, # 6054
2791,7718,1650,4469,7719,2603,7720,7721,3983,2661,3355,1149,3356,3984,3805,3985, # 6070
7722,1076,  49,7723, 951,3211,3289,3290, 450,2837, 920,7724,1811,2792,2366,4184, # 6086
1908,1138,2367,3806,3462,7725,3212,4470,1909,1147,1518,2423,4471,3807,7726,4472, # 6102
2388,2604, 260,1795,3213,7727,7728,3808,3291, 708,7729,3565,1704,7730,3566,1351, # 6118
1618,3357,2999,1886, 944,4185,3358,4186,3044,3359,4187,7731,3678, 422, 413,1714, # 6134
3292, 500,2058,2345,4188,2479,7732,1344,1910, 954,7733,1668,7734,7735,3986,2404, # 6150
4189,3567,3809,4190,7736,2302,1318,2505,3091, 133,3092,2873,4473, 629,  31,2838, # 6166
2697,3810,4474, 850, 949,4475,3987,2955,1732,2088,4191,1496,1852,7737,3988, 620, # 6182
3214, 981,1242,3679,3360,1619,3680,1643,3293,2139,2452,1970,1719,3463,2168,7738, # 6198
3215,7739,7740,3361,1828,7741,1277,4476,1565,2047,7742,1636,3568,3093,7743, 869, # 6214
2839, 655,3811,3812,3094,3989,3000,3813,1310,3569,4477,7744,7745,7746,1733, 558, # 6230
4478,3681, 335,1549,3045,1756,4192,3682,1945,3464,1829,1291,1192, 470,2726,2107, # 6246
2793, 913,1054,3990,7747,1027,7748,3046,3991,4479, 982,2662,3362,3148,3465,3216, # 6262
3217,1946,2794,7749, 571,4480,7750,1830,7751,3570,2583,1523,2424,7752,2089, 984, # 6278
4481,3683,1959,7753,3684, 852, 923,2795,3466,3685, 969,1519, 999,2048,2320,1705, # 6294
7754,3095, 615,1662, 151, 597,3992,2405,2321,1049, 275,4482,3686,4193, 568,3687, # 6310
3571,2480,4194,3688,7755,2425,2270, 409,3218,7756,1566,2874,3467,1002, 769,2840, # 6326
 194,2090,3149,3689,2222,3294,4195, 628,1505,7757,7758,1763,2177,3001,3993, 521, # 6342
1161,2584,1787,2203,2406,4483,3994,1625,4196,4197, 412,  42,3096, 464,7759,2632, # 6358
4484,3363,1760,1571,2875,3468,2530,1219,2204,3814,2633,2140,2368,4485,4486,3295, # 6374
1651,3364,3572,7760,7761,3573,2481,3469,7762,3690,7763,7764,2271,2091, 460,7765, # 6390
4487,7766,3002, 962, 588,3574, 289,3219,2634,1116,  52,7767,3047,1796,7768,7769, # 6406
7770,1467,7771,1598,1143,3691,4198,1984,1734,1067,4488,1280,3365, 465,4489,1572, # 6422
 510,7772,1927,2241,1812,1644,3575,7773,4490,3692,7774,7775,2663,1573,1534,7776, # 6438
7777,4199, 536,1807,1761,3470,3815,3150,2635,7778,7779,7780,4491,3471,2915,1911, # 6454
2796,7781,3296,1122, 377,3220,7782, 360,7783,7784,4200,1529, 551,7785,2059,3693, # 6470
1769,2426,7786,2916,4201,3297,3097,2322,2108,2030,4492,1404, 136,1468,1479, 672, # 6486
1171,3221,2303, 271,3151,7787,2762,7788,2049, 678,2727, 865,1947,4493,7789,2013, # 6502
3995,2956,7790,2728,2223,1397,3048,3694,4494,4495,1735,2917,3366,3576,7791,3816, # 6518
 509,2841,2453,2876,3817,7792,7793,3152,3153,4496,4202,2531,4497,2304,1166,1010, # 6534
 552, 681,1887,7794,7795,2957,2958,3996,1287,1596,1861,3154, 358, 453, 736, 175, # 6550
 478,1117, 905,1167,1097,7796,1853,1530,7797,1706,7798,2178,3472,2287,3695,3473, # 6566
3577,4203,2092,4204,7799,3367,1193,2482,4205,1458,2190,2205,1862,1888,1421,3298, # 6582
2918,3049,2179,3474, 595,2122,7800,3997,7801,7802,4206,1707,2636, 223,3696,1359, # 6598
 751,3098, 183,3475,7803,2797,3003, 419,2369, 633, 704,3818,2389, 241,7804,7805, # 6614
7806, 838,3004,3697,2272,2763,2454,3819,1938,2050,3998,1309,3099,2242,1181,7807, # 6630
1136,2206,3820,2370,1446,4207,2305,4498,7808,7809,4208,1055,2605, 484,3698,7810, # 6646
3999, 625,4209,2273,3368,1499,4210,4000,7811,4001,4211,3222,2274,2275,3476,7812, # 6662
7813,2764, 808,2606,3699,3369,4002,4212,3100,2532, 526,3370,3821,4213, 955,7814, # 6678
1620,4214,2637,2427,7815,1429,3700,1669,1831, 994, 928,7816,3578,1260,7817,7818, # 6694
7819,1948,2288, 741,2919,1626,4215,2729,2455, 867,1184, 362,3371,1392,7820,7821, # 6710
4003,4216,1770,1736,3223,2920,4499,4500,1928,2698,1459,1158,7822,3050,3372,2877, # 6726
1292,1929,2506,2842,3701,1985,1187,2071,2014,2607,4217,7823,2566,2507,2169,3702, # 6742
2483,3299,7824,3703,4501,7825,7826, 666,1003,3005,1022,3579,4218,7827,4502,1813, # 6758
2253, 574,3822,1603, 295,1535, 705,3823,4219, 283, 858, 417,7828,7829,3224,4503, # 6774
4504,3051,1220,1889,1046,2276,2456,4004,1393,1599, 689,2567, 388,4220,7830,2484, # 6790
 802,7831,2798,3824,2060,1405,2254,7832,4505,3825,2109,1052,1345,3225,1585,7833, # 6806
 809,7834,7835,7836, 575,2730,3477, 956,1552,1469,1144,2323,7837,2324,1560,2457, # 6822
3580,3226,4005, 616,2207,3155,2180,2289,7838,1832,7839,3478,4506,7840,1319,3704, # 6838
3705,1211,3581,1023,3227,1293,2799,7841,7842,7843,3826, 607,2306,3827, 762,2878, # 6854
1439,4221,1360,7844,1485,3052,7845,4507,1038,4222,1450,2061,2638,4223,1379,4508, # 6870
2585,7846,7847,4224,1352,1414,2325,2921,1172,7848,7849,3828,3829,7850,1797,1451, # 6886
7851,7852,7853,7854,2922,4006,4007,2485,2346, 411,4008,4009,3582,3300,3101,4509, # 6902
1561,2664,1452,4010,1375,7855,7856,  47,2959, 316,7857,1406,1591,2923,3156,7858, # 6918
1025,2141,3102,3157, 354,2731, 884,2224,4225,2407, 508,3706, 726,3583, 996,2428, # 6934
3584, 729,7859, 392,2191,1453,4011,4510,3707,7860,7861,2458,3585,2608,1675,2800, # 6950
 919,2347,2960,2348,1270,4511,4012,  73,7862,7863, 647,7864,3228,2843,2255,1550, # 6966
1346,3006,7865,1332, 883,3479,7866,7867,7868,7869,3301,2765,7870,1212, 831,1347, # 6982
4226,4512,2326,3830,1863,3053, 720,3831,4513,4514,3832,7871,4227,7872,7873,4515, # 6998
7874,7875,1798,4516,3708,2609,4517,3586,1645,2371,7876,7877,2924, 669,2208,2665, # 7014
2429,7878,2879,7879,7880,1028,3229,7881,4228,2408,7882,2256,1353,7883,7884,4518, # 7030
3158, 518,7885,4013,7886,4229,1960,7887,2142,4230,7888,7889,3007,2349,2350,3833, # 7046
 516,1833,1454,4014,2699,4231,4519,2225,2610,1971,1129,3587,7890,2766,7891,2961, # 7062
1422, 577,1470,3008,1524,3373,7892,7893, 432,4232,3054,3480,7894,2586,1455,2508, # 7078
2226,1972,1175,7895,1020,2732,4015,3481,4520,7896,2733,7897,1743,1361,3055,3482, # 7094
2639,4016,4233,4521,2290, 895, 924,4234,2170, 331,2243,3056, 166,1627,3057,1098, # 7110
7898,1232,2880,2227,3374,4522, 657, 403,1196,2372, 542,3709,3375,1600,4235,3483, # 7126
7899,4523,2767,3230, 576, 530,1362,7900,4524,2533,2666,3710,4017,7901, 842,3834, # 7142
7902,2801,2031,1014,4018, 213,2700,3376, 665, 621,4236,7903,3711,2925,2430,7904, # 7158
2431,3302,3588,3377,7905,4237,2534,4238,4525,3589,1682,4239,3484,1380,7906, 724, # 7174
2277, 600,1670,7907,1337,1233,4526,3103,2244,7908,1621,4527,7909, 651,4240,7910, # 7190
1612,4241,2611,7911,2844,7912,2734,2307,3058,7913, 716,2459,3059, 174,1255,2701, # 7206
4019,3590, 548,1320,1398, 728,4020,1574,7914,1890,1197,3060,4021,7915,3061,3062, # 7222
3712,3591,3713, 747,7916, 635,4242,4528,7917,7918,7919,4243,7920,7921,4529,7922, # 7238
3378,4530,2432, 451,7923,3714,2535,2072,4244,2735,4245,4022,7924,1764,4531,7925, # 7254
4246, 350,7926,2278,2390,2486,7927,4247,4023,2245,1434,4024, 488,4532, 458,4248, # 7270
4025,3715, 771,1330,2391,3835,2568,3159,2159,2409,1553,2667,3160,4249,7928,2487, # 7286
2881,2612,1720,2702,4250,3379,4533,7929,2536,4251,7930,3231,4252,2768,7931,2015, # 7302
2736,7932,1155,1017,3716,3836,7933,3303,2308, 201,1864,4253,1430,7934,4026,7935, # 7318
7936,7937,7938,7939,4254,1604,7940, 414,1865, 371,2587,4534,4535,3485,2016,3104, # 7334
4536,1708, 960,4255, 887, 389,2171,1536,1663,1721,7941,2228,4027,2351,2926,1580, # 7350
7942,7943,7944,1744,7945,2537,4537,4538,7946,4539,7947,2073,7948,7949,3592,3380, # 7366
2882,4256,7950,4257,2640,3381,2802, 673,2703,2460, 709,3486,4028,3593,4258,7951, # 7382
1148, 502, 634,7952,7953,1204,4540,3594,1575,4541,2613,3717,7954,3718,3105, 948, # 7398
3232, 121,1745,3837,1110,7955,4259,3063,2509,3009,4029,3719,1151,1771,3838,1488, # 7414
4030,1986,7956,2433,3487,7957,7958,2093,7959,4260,3839,1213,1407,2803, 531,2737, # 7430
2538,3233,1011,1537,7960,2769,4261,3106,1061,7961,3720,3721,1866,2883,7962,2017, # 7446
 120,4262,4263,2062,3595,3234,2309,3840,2668,3382,1954,4542,7963,7964,3488,1047, # 7462
2704,1266,7965,1368,4543,2845, 649,3383,3841,2539,2738,1102,2846,2669,7966,7967, # 7478
1999,7968,1111,3596,2962,7969,2488,3842,3597,2804,1854,3384,3722,7970,7971,3385, # 7494
2410,2884,3304,3235,3598,7972,2569,7973,3599,2805,4031,1460, 856,7974,3600,7975, # 7510
2885,2963,7976,2886,3843,7977,4264, 632,2510, 875,3844,1697,3845,2291,7978,7979, # 7526
4544,3010,1239, 580,4545,4265,7980, 914, 936,2074,1190,4032,1039,2123,7981,7982, # 7542
7983,3386,1473,7984,1354,4266,3846,7985,2172,3064,4033, 915,3305,4267,4268,3306, # 7558
1605,1834,7986,2739, 398,3601,4269,3847,4034, 328,1912,2847,4035,3848,1331,4270, # 7574
3011, 937,4271,7987,3602,4036,4037,3387,2160,4546,3388, 524, 742, 538,3065,1012, # 7590
7988,7989,3849,2461,7990, 658,1103, 225,3850,7991,7992,4547,7993,4548,7994,3236, # 7606
1243,7995,4038, 963,2246,4549,7996,2705,3603,3161,7997,7998,2588,2327,7999,4550, # 7622
8000,8001,8002,3489,3307, 957,3389,2540,2032,1930,2927,2462, 870,2018,3604,1746, # 7638
2770,2771,2434,2463,8003,3851,8004,3723,3107,3724,3490,3390,3725,8005,1179,3066, # 7654
8006,3162,2373,4272,3726,2541,3163,3108,2740,4039,8007,3391,1556,2542,2292, 977, # 7670
2887,2033,4040,1205,3392,8008,1765,3393,3164,2124,1271,1689, 714,4551,3491,8009, # 7686
2328,3852, 533,4273,3605,2181, 617,8010,2464,3308,3492,2310,8011,8012,3165,8013, # 7702
8014,3853,1987, 618, 427,2641,3493,3394,8015,8016,1244,1690,8017,2806,4274,4552, # 7718
8018,3494,8019,8020,2279,1576, 473,3606,4275,3395, 972,8021,3607,8022,3067,8023, # 7734
8024,4553,4554,8025,3727,4041,4042,8026, 153,4555, 356,8027,1891,2888,4276,2143, # 7750
 408, 803,2352,8028,3854,8029,4277,1646,2570,2511,4556,4557,3855,8030,3856,4278, # 7766
8031,2411,3396, 752,8032,8033,1961,2964,8034, 746,3012,2465,8035,4279,3728, 698, # 7782
4558,1892,4280,3608,2543,4559,3609,3857,8036,3166,3397,8037,1823,1302,4043,2706, # 7798
3858,1973,4281,8038,4282,3167, 823,1303,1288,1236,2848,3495,4044,3398, 774,3859, # 7814
8039,1581,4560,1304,2849,3860,4561,8040,2435,2161,1083,3237,4283,4045,4284, 344, # 7830
1173, 288,2311, 454,1683,8041,8042,1461,4562,4046,2589,8043,8044,4563, 985, 894, # 7846
8045,3399,3168,8046,1913,2928,3729,1988,8047,2110,1974,8048,4047,8049,2571,1194, # 7862
 425,8050,4564,3169,1245,3730,4285,8051,8052,2850,8053, 636,4565,1855,3861, 760, # 7878
1799,8054,4286,2209,1508,4566,4048,1893,1684,2293,8055,8056,8057,4287,4288,2210, # 7894
 479,8058,8059, 832,8060,4049,2489,8061,2965,2490,3731, 990,3109, 627,1814,2642, # 7910
4289,1582,4290,2125,2111,3496,4567,8062, 799,4291,3170,8063,4568,2112,1737,3013, # 7926
1018, 543, 754,4292,3309,1676,4569,4570,4050,8064,1489,8065,3497,8066,2614,2889, # 7942
4051,8067,8068,2966,8069,8070,8071,8072,3171,4571,4572,2182,1722,8073,3238,3239, # 7958
1842,3610,1715, 481, 365,1975,1856,8074,8075,1962,2491,4573,8076,2126,3611,3240, # 7974
 433,1894,2063,2075,8077, 602,2741,8078,8079,8080,8081,8082,3014,1628,3400,8083, # 7990
3172,4574,4052,2890,4575,2512,8084,2544,2772,8085,8086,8087,3310,4576,2891,8088, # 8006
4577,8089,2851,4578,4579,1221,2967,4053,2513,8090,8091,8092,1867,1989,8093,8094, # 8022
8095,1895,8096,8097,4580,1896,4054, 318,8098,2094,4055,4293,8099,8100, 485,8101, # 8038
 938,3862, 553,2670, 116,8102,3863,3612,8103,3498,2671,2773,3401,3311,2807,8104, # 8054
3613,2929,4056,1747,2930,2968,8105,8106, 207,8107,8108,2672,4581,2514,8109,3015, # 8070
 890,3614,3864,8110,1877,3732,3402,8111,2183,2353,3403,1652,8112,8113,8114, 941, # 8086
2294, 208,3499,4057,2019, 330,4294,3865,2892,2492,3733,4295,8115,8116,8117,8118, # 8102
#Everything below is of no interest for detection purpose
2515,1613,4582,8119,3312,3866,2516,8120,4058,8121,1637,4059,2466,4583,3867,8122, # 8118
2493,3016,3734,8123,8124,2192,8125,8126,2162,8127,8128,8129,8130,8131,8132,8133, # 8134
8134,8135,8136,8137,8138,8139,8140,8141,8142,8143,8144,8145,8146,8147,8148,8149, # 8150
8150,8151,8152,8153,8154,8155,8156,8157,8158,8159,8160,8161,8162,8163,8164,8165, # 8166
8166,8167,8168,8169,8170,8171,8172,8173,8174,8175,8176,8177,8178,8179,8180,8181, # 8182
8182,8183,8184,8185,8186,8187,8188,8189,8190,8191,8192,8193,8194,8195,8196,8197, # 8198
8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8208,8209,8210,8211,8212,8213, # 8214
8214,8215,8216,8217,8218,8219,8220,8221,8222,8223,8224,8225,8226,8227,8228,8229, # 8230
8230,8231,8232,8233,8234,8235,8236,8237,8238,8239,8240,8241,8242,8243,8244,8245, # 8246
8246,8247,8248,8249,8250,8251,8252,8253,8254,8255,8256,8257,8258,8259,8260,8261, # 8262
8262,8263,8264,8265,8266,8267,8268,8269,8270,8271,8272,8273,8274,8275,8276,8277, # 8278
8278,8279,8280,8281,8282,8283,8284,8285,8286,8287,8288,8289,8290,8291,8292,8293, # 8294
8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,8304,8305,8306,8307,8308,8309, # 8310
8310,8311,8312,8313,8314,8315,8316,8317,8318,8319,8320,8321,8322,8323,8324,8325, # 8326
8326,8327,8328,8329,8330,8331,8332,8333,8334,8335,8336,8337,8338,8339,8340,8341, # 8342
8342,8343,8344,8345,8346,8347,8348,8349,8350,8351,8352,8353,8354,8355,8356,8357, # 8358
8358,8359,8360,8361,8362,8363,8364,8365,8366,8367,8368,8369,8370,8371,8372,8373, # 8374
8374,8375,8376,8377,8378,8379,8380,8381,8382,8383,8384,8385,8386,8387,8388,8389, # 8390
8390,8391,8392,8393,8394,8395,8396,8397,8398,8399,8400,8401,8402,8403,8404,8405, # 8406
8406,8407,8408,8409,8410,8411,8412,8413,8414,8415,8416,8417,8418,8419,8420,8421, # 8422
8422,8423,8424,8425,8426,8427,8428,8429,8430,8431,8432,8433,8434,8435,8436,8437, # 8438
8438,8439,8440,8441,8442,8443,8444,8445,8446,8447,8448,8449,8450,8451,8452,8453, # 8454
8454,8455,8456,8457,8458,8459,8460,8461,8462,8463,8464,8465,8466,8467,8468,8469, # 8470
8470,8471,8472,8473,8474,8475,8476,8477,8478,8479,8480,8481,8482,8483,8484,8485, # 8486
8486,8487,8488,8489,8490,8491,8492,8493,8494,8495,8496,8497,8498,8499,8500,8501, # 8502
8502,8503,8504,8505,8506,8507,8508,8509,8510,8511,8512,8513,8514,8515,8516,8517, # 8518
8518,8519,8520,8521,8522,8523,8524,8525,8526,8527,8528,8529,8530,8531,8532,8533, # 8534
8534,8535,8536,8537,8538,8539,8540,8541,8542,8543,8544,8545,8546,8547,8548,8549, # 8550
8550,8551,8552,8553,8554,8555,8556,8557,8558,8559,8560,8561,8562,8563,8564,8565, # 8566
8566,8567,8568,8569,8570,8571,8572,8573,8574,8575,8576,8577,8578,8579,8580,8581, # 8582
8582,8583,8584,8585,8586,8587,8588,8589,8590,8591,8592,8593,8594,8595,8596,8597, # 8598
8598,8599,8600,8601,8602,8603,8604,8605,8606,8607,8608,8609,8610,8611,8612,8613, # 8614
8614,8615,8616,8617,8618,8619,8620,8621,8622,8623,8624,8625,8626,8627,8628,8629, # 8630
8630,8631,8632,8633,8634,8635,8636,8637,8638,8639,8640,8641,8642,8643,8644,8645, # 8646
8646,8647,8648,8649,8650,8651,8652,8653,8654,8655,8656,8657,8658,8659,8660,8661, # 8662
8662,8663,8664,8665,8666,8667,8668,8669,8670,8671,8672,8673,8674,8675,8676,8677, # 8678
8678,8679,8680,8681,8682,8683,8684,8685,8686,8687,8688,8689,8690,8691,8692,8693, # 8694
8694,8695,8696,8697,8698,8699,8700,8701,8702,8703,8704,8705,8706,8707,8708,8709, # 8710
8710,8711,8712,8713,8714,8715,8716,8717,8718,8719,8720,8721,8722,8723,8724,8725, # 8726
8726,8727,8728,8729,8730,8731,8732,8733,8734,8735,8736,8737,8738,8739,8740,8741) # 8742

# flake8: noqa

########NEW FILE########
__FILENAME__ = euctwprober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import EUCTWDistributionAnalysis
from .mbcssm import EUCTWSMModel

class EUCTWProber(MultiByteCharSetProber):
    def __init__(self):
        MultiByteCharSetProber.__init__(self)
        self._mCodingSM = CodingStateMachine(EUCTWSMModel)
        self._mDistributionAnalyzer = EUCTWDistributionAnalysis()
        self.reset()

    def get_charset_name(self):
        return "EUC-TW"

########NEW FILE########
__FILENAME__ = gb2312freq
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# GB2312 most frequently used character table
#
# Char to FreqOrder table , from hz6763

# 512  --> 0.79  -- 0.79
# 1024 --> 0.92  -- 0.13
# 2048 --> 0.98  -- 0.06
# 6768 --> 1.00  -- 0.02
#
# Ideal Distribution Ratio = 0.79135/(1-0.79135) = 3.79
# Random Distribution Ration = 512 / (3755 - 512) = 0.157
#
# Typical Distribution Ratio about 25% of Ideal one, still much higher that RDR

GB2312_TYPICAL_DISTRIBUTION_RATIO = 0.9

GB2312_TABLE_SIZE = 3760

GB2312CharToFreqOrder = (
1671, 749,1443,2364,3924,3807,2330,3921,1704,3463,2691,1511,1515, 572,3191,2205,
2361, 224,2558, 479,1711, 963,3162, 440,4060,1905,2966,2947,3580,2647,3961,3842,
2204, 869,4207, 970,2678,5626,2944,2956,1479,4048, 514,3595, 588,1346,2820,3409,
 249,4088,1746,1873,2047,1774, 581,1813, 358,1174,3590,1014,1561,4844,2245, 670,
1636,3112, 889,1286, 953, 556,2327,3060,1290,3141, 613, 185,3477,1367, 850,3820,
1715,2428,2642,2303,2732,3041,2562,2648,3566,3946,1349, 388,3098,2091,1360,3585,
 152,1687,1539, 738,1559,  59,1232,2925,2267,1388,1249,1741,1679,2960, 151,1566,
1125,1352,4271, 924,4296, 385,3166,4459, 310,1245,2850,  70,3285,2729,3534,3575,
2398,3298,3466,1960,2265, 217,3647, 864,1909,2084,4401,2773,1010,3269,5152, 853,
3051,3121,1244,4251,1895, 364,1499,1540,2313,1180,3655,2268, 562, 715,2417,3061,
 544, 336,3768,2380,1752,4075, 950, 280,2425,4382, 183,2759,3272, 333,4297,2155,
1688,2356,1444,1039,4540, 736,1177,3349,2443,2368,2144,2225, 565, 196,1482,3406,
 927,1335,4147, 692, 878,1311,1653,3911,3622,1378,4200,1840,2969,3149,2126,1816,
2534,1546,2393,2760, 737,2494,  13, 447, 245,2747,  38,2765,2129,2589,1079, 606,
 360, 471,3755,2890, 404, 848, 699,1785,1236, 370,2221,1023,3746,2074,2026,2023,
2388,1581,2119, 812,1141,3091,2536,1519, 804,2053, 406,1596,1090, 784, 548,4414,
1806,2264,2936,1100, 343,4114,5096, 622,3358, 743,3668,1510,1626,5020,3567,2513,
3195,4115,5627,2489,2991,  24,2065,2697,1087,2719,  48,1634, 315,  68, 985,2052,
 198,2239,1347,1107,1439, 597,2366,2172, 871,3307, 919,2487,2790,1867, 236,2570,
1413,3794, 906,3365,3381,1701,1982,1818,1524,2924,1205, 616,2586,2072,2004, 575,
 253,3099,  32,1365,1182, 197,1714,2454,1201, 554,3388,3224,2748, 756,2587, 250,
2567,1507,1517,3529,1922,2761,2337,3416,1961,1677,2452,2238,3153, 615, 911,1506,
1474,2495,1265,1906,2749,3756,3280,2161, 898,2714,1759,3450,2243,2444, 563,  26,
3286,2266,3769,3344,2707,3677, 611,1402, 531,1028,2871,4548,1375, 261,2948, 835,
1190,4134, 353, 840,2684,1900,3082,1435,2109,1207,1674, 329,1872,2781,4055,2686,
2104, 608,3318,2423,2957,2768,1108,3739,3512,3271,3985,2203,1771,3520,1418,2054,
1681,1153, 225,1627,2929, 162,2050,2511,3687,1954, 124,1859,2431,1684,3032,2894,
 585,4805,3969,2869,2704,2088,2032,2095,3656,2635,4362,2209, 256, 518,2042,2105,
3777,3657, 643,2298,1148,1779, 190, 989,3544, 414,  11,2135,2063,2979,1471, 403,
3678, 126, 770,1563, 671,2499,3216,2877, 600,1179, 307,2805,4937,1268,1297,2694,
 252,4032,1448,1494,1331,1394, 127,2256, 222,1647,1035,1481,3056,1915,1048, 873,
3651, 210,  33,1608,2516, 200,1520, 415, 102,   0,3389,1287, 817,  91,3299,2940,
 836,1814, 549,2197,1396,1669,2987,3582,2297,2848,4528,1070, 687,  20,1819, 121,
1552,1364,1461,1968,2617,3540,2824,2083, 177, 948,4938,2291, 110,4549,2066, 648,
3359,1755,2110,2114,4642,4845,1693,3937,3308,1257,1869,2123, 208,1804,3159,2992,
2531,2549,3361,2418,1350,2347,2800,2568,1291,2036,2680,  72, 842,1990, 212,1233,
1154,1586,  75,2027,3410,4900,1823,1337,2710,2676, 728,2810,1522,3026,4995, 157,
 755,1050,4022, 710, 785,1936,2194,2085,1406,2777,2400, 150,1250,4049,1206, 807,
1910, 534, 529,3309,1721,1660, 274,  39,2827, 661,2670,1578, 925,3248,3815,1094,
4278,4901,4252,  41,1150,3747,2572,2227,4501,3658,4902,3813,3357,3617,2884,2258,
 887, 538,4187,3199,1294,2439,3042,2329,2343,2497,1255, 107, 543,1527, 521,3478,
3568, 194,5062,  15, 961,3870,1241,1192,2664,  66,5215,3260,2111,1295,1127,2152,
3805,4135, 901,1164,1976, 398,1278, 530,1460, 748, 904,1054,1966,1426,  53,2909,
 509, 523,2279,1534, 536,1019, 239,1685, 460,2353, 673,1065,2401,3600,4298,2272,
1272,2363, 284,1753,3679,4064,1695,  81, 815,2677,2757,2731,1386, 859, 500,4221,
2190,2566, 757,1006,2519,2068,1166,1455, 337,2654,3203,1863,1682,1914,3025,1252,
1409,1366, 847, 714,2834,2038,3209, 964,2970,1901, 885,2553,1078,1756,3049, 301,
1572,3326, 688,2130,1996,2429,1805,1648,2930,3421,2750,3652,3088, 262,1158,1254,
 389,1641,1812, 526,1719, 923,2073,1073,1902, 468, 489,4625,1140, 857,2375,3070,
3319,2863, 380, 116,1328,2693,1161,2244, 273,1212,1884,2769,3011,1775,1142, 461,
3066,1200,2147,2212, 790, 702,2695,4222,1601,1058, 434,2338,5153,3640,  67,2360,
4099,2502, 618,3472,1329, 416,1132, 830,2782,1807,2653,3211,3510,1662, 192,2124,
 296,3979,1739,1611,3684,  23, 118, 324, 446,1239,1225, 293,2520,3814,3795,2535,
3116,  17,1074, 467,2692,2201, 387,2922,  45,1326,3055,1645,3659,2817, 958, 243,
1903,2320,1339,2825,1784,3289, 356, 576, 865,2315,2381,3377,3916,1088,3122,1713,
1655, 935, 628,4689,1034,1327, 441, 800, 720, 894,1979,2183,1528,5289,2702,1071,
4046,3572,2399,1571,3281,  79, 761,1103, 327, 134, 758,1899,1371,1615, 879, 442,
 215,2605,2579, 173,2048,2485,1057,2975,3317,1097,2253,3801,4263,1403,1650,2946,
 814,4968,3487,1548,2644,1567,1285,   2, 295,2636,  97, 946,3576, 832, 141,4257,
3273, 760,3821,3521,3156,2607, 949,1024,1733,1516,1803,1920,2125,2283,2665,3180,
1501,2064,3560,2171,1592, 803,3518,1416, 732,3897,4258,1363,1362,2458, 119,1427,
 602,1525,2608,1605,1639,3175, 694,3064,  10, 465,  76,2000,4846,4208, 444,3781,
1619,3353,2206,1273,3796, 740,2483, 320,1723,2377,3660,2619,1359,1137,1762,1724,
2345,2842,1850,1862, 912, 821,1866, 612,2625,1735,2573,3369,1093, 844,  89, 937,
 930,1424,3564,2413,2972,1004,3046,3019,2011, 711,3171,1452,4178, 428, 801,1943,
 432, 445,2811, 206,4136,1472, 730, 349,  73, 397,2802,2547, 998,1637,1167, 789,
 396,3217, 154,1218, 716,1120,1780,2819,4826,1931,3334,3762,2139,1215,2627, 552,
3664,3628,3232,1405,2383,3111,1356,2652,3577,3320,3101,1703, 640,1045,1370,1246,
4996, 371,1575,2436,1621,2210, 984,4033,1734,2638,  16,4529, 663,2755,3255,1451,
3917,2257,1253,1955,2234,1263,2951, 214,1229, 617, 485, 359,1831,1969, 473,2310,
 750,2058, 165,  80,2864,2419, 361,4344,2416,2479,1134, 796,3726,1266,2943, 860,
2715, 938, 390,2734,1313,1384, 248, 202, 877,1064,2854, 522,3907, 279,1602, 297,
2357, 395,3740, 137,2075, 944,4089,2584,1267,3802,  62,1533,2285, 178, 176, 780,
2440, 201,3707, 590, 478,1560,4354,2117,1075,  30,  74,4643,4004,1635,1441,2745,
 776,2596, 238,1077,1692,1912,2844, 605, 499,1742,3947, 241,3053, 980,1749, 936,
2640,4511,2582, 515,1543,2162,5322,2892,2993, 890,2148,1924, 665,1827,3581,1032,
 968,3163, 339,1044,1896, 270, 583,1791,1720,4367,1194,3488,3669,  43,2523,1657,
 163,2167, 290,1209,1622,3378, 550, 634,2508,2510, 695,2634,2384,2512,1476,1414,
 220,1469,2341,2138,2852,3183,2900,4939,2865,3502,1211,3680, 854,3227,1299,2976,
3172, 186,2998,1459, 443,1067,3251,1495, 321,1932,3054, 909, 753,1410,1828, 436,
2441,1119,1587,3164,2186,1258, 227, 231,1425,1890,3200,3942, 247, 959, 725,5254,
2741, 577,2158,2079, 929, 120, 174, 838,2813, 591,1115, 417,2024,  40,3240,1536,
1037, 291,4151,2354, 632,1298,2406,2500,3535,1825,1846,3451, 205,1171, 345,4238,
  18,1163, 811, 685,2208,1217, 425,1312,1508,1175,4308,2552,1033, 587,1381,3059,
2984,3482, 340,1316,4023,3972, 792,3176, 519, 777,4690, 918, 933,4130,2981,3741,
  90,3360,2911,2200,5184,4550, 609,3079,2030, 272,3379,2736, 363,3881,1130,1447,
 286, 779, 357,1169,3350,3137,1630,1220,2687,2391, 747,1277,3688,2618,2682,2601,
1156,3196,5290,4034,3102,1689,3596,3128, 874, 219,2783, 798, 508,1843,2461, 269,
1658,1776,1392,1913,2983,3287,2866,2159,2372, 829,4076,  46,4253,2873,1889,1894,
 915,1834,1631,2181,2318, 298, 664,2818,3555,2735, 954,3228,3117, 527,3511,2173,
 681,2712,3033,2247,2346,3467,1652, 155,2164,3382, 113,1994, 450, 899, 494, 994,
1237,2958,1875,2336,1926,3727, 545,1577,1550, 633,3473, 204,1305,3072,2410,1956,
2471, 707,2134, 841,2195,2196,2663,3843,1026,4940, 990,3252,4997, 368,1092, 437,
3212,3258,1933,1829, 675,2977,2893, 412, 943,3723,4644,3294,3283,2230,2373,5154,
2389,2241,2661,2323,1404,2524, 593, 787, 677,3008,1275,2059, 438,2709,2609,2240,
2269,2246,1446,  36,1568,1373,3892,1574,2301,1456,3962, 693,2276,5216,2035,1143,
2720,1919,1797,1811,2763,4137,2597,1830,1699,1488,1198,2090, 424,1694, 312,3634,
3390,4179,3335,2252,1214, 561,1059,3243,2295,2561, 975,5155,2321,2751,3772, 472,
1537,3282,3398,1047,2077,2348,2878,1323,3340,3076, 690,2906,  51, 369, 170,3541,
1060,2187,2688,3670,2541,1083,1683, 928,3918, 459, 109,4427, 599,3744,4286, 143,
2101,2730,2490,  82,1588,3036,2121, 281,1860, 477,4035,1238,2812,3020,2716,3312,
1530,2188,2055,1317, 843, 636,1808,1173,3495, 649, 181,1002, 147,3641,1159,2414,
3750,2289,2795, 813,3123,2610,1136,4368,   5,3391,4541,2174, 420, 429,1728, 754,
1228,2115,2219, 347,2223,2733, 735,1518,3003,2355,3134,1764,3948,3329,1888,2424,
1001,1234,1972,3321,3363,1672,1021,1450,1584, 226, 765, 655,2526,3404,3244,2302,
3665, 731, 594,2184, 319,1576, 621, 658,2656,4299,2099,3864,1279,2071,2598,2739,
 795,3086,3699,3908,1707,2352,2402,1382,3136,2475,1465,4847,3496,3865,1085,3004,
2591,1084, 213,2287,1963,3565,2250, 822, 793,4574,3187,1772,1789,3050, 595,1484,
1959,2770,1080,2650, 456, 422,2996, 940,3322,4328,4345,3092,2742, 965,2784, 739,
4124, 952,1358,2498,2949,2565, 332,2698,2378, 660,2260,2473,4194,3856,2919, 535,
1260,2651,1208,1428,1300,1949,1303,2942, 433,2455,2450,1251,1946, 614,1269, 641,
1306,1810,2737,3078,2912, 564,2365,1419,1415,1497,4460,2367,2185,1379,3005,1307,
3218,2175,1897,3063, 682,1157,4040,4005,1712,1160,1941,1399, 394, 402,2952,1573,
1151,2986,2404, 862, 299,2033,1489,3006, 346, 171,2886,3401,1726,2932, 168,2533,
  47,2507,1030,3735,1145,3370,1395,1318,1579,3609,4560,2857,4116,1457,2529,1965,
 504,1036,2690,2988,2405, 745,5871, 849,2397,2056,3081, 863,2359,3857,2096,  99,
1397,1769,2300,4428,1643,3455,1978,1757,3718,1440,  35,4879,3742,1296,4228,2280,
 160,5063,1599,2013, 166, 520,3479,1646,3345,3012, 490,1937,1545,1264,2182,2505,
1096,1188,1369,1436,2421,1667,2792,2460,1270,2122, 727,3167,2143, 806,1706,1012,
1800,3037, 960,2218,1882, 805, 139,2456,1139,1521, 851,1052,3093,3089, 342,2039,
 744,5097,1468,1502,1585,2087, 223, 939, 326,2140,2577, 892,2481,1623,4077, 982,
3708, 135,2131,  87,2503,3114,2326,1106, 876,1616, 547,2997,2831,2093,3441,4530,
4314,   9,3256,4229,4148, 659,1462,1986,1710,2046,2913,2231,4090,4880,5255,3392,
3274,1368,3689,4645,1477, 705,3384,3635,1068,1529,2941,1458,3782,1509, 100,1656,
2548, 718,2339, 408,1590,2780,3548,1838,4117,3719,1345,3530, 717,3442,2778,3220,
2898,1892,4590,3614,3371,2043,1998,1224,3483, 891, 635, 584,2559,3355, 733,1766,
1729,1172,3789,1891,2307, 781,2982,2271,1957,1580,5773,2633,2005,4195,3097,1535,
3213,1189,1934,5693,3262, 586,3118,1324,1598, 517,1564,2217,1868,1893,4445,3728,
2703,3139,1526,1787,1992,3882,2875,1549,1199,1056,2224,1904,2711,5098,4287, 338,
1993,3129,3489,2689,1809,2815,1997, 957,1855,3898,2550,3275,3057,1105,1319, 627,
1505,1911,1883,3526, 698,3629,3456,1833,1431, 746,  77,1261,2017,2296,1977,1885,
 125,1334,1600, 525,1798,1109,2222,1470,1945, 559,2236,1186,3443,2476,1929,1411,
2411,3135,1777,3372,2621,1841,1613,3229, 668,1430,1839,2643,2916, 195,1989,2671,
2358,1387, 629,3205,2293,5256,4439, 123,1310, 888,1879,4300,3021,3605,1003,1162,
3192,2910,2010, 140,2395,2859,  55,1082,2012,2901, 662, 419,2081,1438, 680,2774,
4654,3912,1620,1731,1625,5035,4065,2328, 512,1344, 802,5443,2163,2311,2537, 524,
3399,  98,1155,2103,1918,2606,3925,2816,1393,2465,1504,3773,2177,3963,1478,4346,
 180,1113,4655,3461,2028,1698, 833,2696,1235,1322,1594,4408,3623,3013,3225,2040,
3022, 541,2881, 607,3632,2029,1665,1219, 639,1385,1686,1099,2803,3231,1938,3188,
2858, 427, 676,2772,1168,2025, 454,3253,2486,3556, 230,1950, 580, 791,1991,1280,
1086,1974,2034, 630, 257,3338,2788,4903,1017,  86,4790, 966,2789,1995,1696,1131,
 259,3095,4188,1308, 179,1463,5257, 289,4107,1248,  42,3413,1725,2288, 896,1947,
 774,4474,4254, 604,3430,4264, 392,2514,2588, 452, 237,1408,3018, 988,4531,1970,
3034,3310, 540,2370,1562,1288,2990, 502,4765,1147,   4,1853,2708, 207, 294,2814,
4078,2902,2509, 684,  34,3105,3532,2551, 644, 709,2801,2344, 573,1727,3573,3557,
2021,1081,3100,4315,2100,3681, 199,2263,1837,2385, 146,3484,1195,2776,3949, 997,
1939,3973,1008,1091,1202,1962,1847,1149,4209,5444,1076, 493, 117,5400,2521, 972,
1490,2934,1796,4542,2374,1512,2933,2657, 413,2888,1135,2762,2314,2156,1355,2369,
 766,2007,2527,2170,3124,2491,2593,2632,4757,2437, 234,3125,3591,1898,1750,1376,
1942,3468,3138, 570,2127,2145,3276,4131, 962, 132,1445,4196,  19, 941,3624,3480,
3366,1973,1374,4461,3431,2629, 283,2415,2275, 808,2887,3620,2112,2563,1353,3610,
 955,1089,3103,1053,  96,  88,4097, 823,3808,1583, 399, 292,4091,3313, 421,1128,
 642,4006, 903,2539,1877,2082, 596,  29,4066,1790, 722,2157, 130, 995,1569, 769,
1485, 464, 513,2213, 288,1923,1101,2453,4316, 133, 486,2445,  50, 625, 487,2207,
  57, 423, 481,2962, 159,3729,1558, 491, 303, 482, 501, 240,2837, 112,3648,2392,
1783, 362,   8,3433,3422, 610,2793,3277,1390,1284,1654,  21,3823, 734, 367, 623,
 193, 287, 374,1009,1483, 816, 476, 313,2255,2340,1262,2150,2899,1146,2581, 782,
2116,1659,2018,1880, 255,3586,3314,1110,2867,2137,2564, 986,2767,5185,2006, 650,
 158, 926, 762, 881,3157,2717,2362,3587, 306,3690,3245,1542,3077,2427,1691,2478,
2118,2985,3490,2438, 539,2305, 983, 129,1754, 355,4201,2386, 827,2923, 104,1773,
2838,2771, 411,2905,3919, 376, 767, 122,1114, 828,2422,1817,3506, 266,3460,1007,
1609,4998, 945,2612,4429,2274, 726,1247,1964,2914,2199,2070,4002,4108, 657,3323,
1422, 579, 455,2764,4737,1222,2895,1670, 824,1223,1487,2525, 558, 861,3080, 598,
2659,2515,1967, 752,2583,2376,2214,4180, 977, 704,2464,4999,2622,4109,1210,2961,
 819,1541, 142,2284,  44, 418, 457,1126,3730,4347,4626,1644,1876,3671,1864, 302,
1063,5694, 624, 723,1984,3745,1314,1676,2488,1610,1449,3558,3569,2166,2098, 409,
1011,2325,3704,2306, 818,1732,1383,1824,1844,3757, 999,2705,3497,1216,1423,2683,
2426,2954,2501,2726,2229,1475,2554,5064,1971,1794,1666,2014,1343, 783, 724, 191,
2434,1354,2220,5065,1763,2752,2472,4152, 131, 175,2885,3434,  92,1466,4920,2616,
3871,3872,3866, 128,1551,1632, 669,1854,3682,4691,4125,1230, 188,2973,3290,1302,
1213, 560,3266, 917, 763,3909,3249,1760, 868,1958, 764,1782,2097, 145,2277,3774,
4462,  64,1491,3062, 971,2132,3606,2442, 221,1226,1617, 218, 323,1185,3207,3147,
 571, 619,1473,1005,1744,2281, 449,1887,2396,3685, 275, 375,3816,1743,3844,3731,
 845,1983,2350,4210,1377, 773, 967,3499,3052,3743,2725,4007,1697,1022,3943,1464,
3264,2855,2722,1952,1029,2839,2467,  84,4383,2215, 820,1391,2015,2448,3672, 377,
1948,2168, 797,2545,3536,2578,2645,  94,2874,1678, 405,1259,3071, 771, 546,1315,
 470,1243,3083, 895,2468, 981, 969,2037, 846,4181, 653,1276,2928,  14,2594, 557,
3007,2474, 156, 902,1338,1740,2574, 537,2518, 973,2282,2216,2433,1928, 138,2903,
1293,2631,1612, 646,3457, 839,2935, 111, 496,2191,2847, 589,3186, 149,3994,2060,
4031,2641,4067,3145,1870,  37,3597,2136,1025,2051,3009,3383,3549,1121,1016,3261,
1301, 251,2446,2599,2153, 872,3246, 637, 334,3705, 831, 884, 921,3065,3140,4092,
2198,1944, 246,2964, 108,2045,1152,1921,2308,1031, 203,3173,4170,1907,3890, 810,
1401,2003,1690, 506, 647,1242,2828,1761,1649,3208,2249,1589,3709,2931,5156,1708,
 498, 666,2613, 834,3817,1231, 184,2851,1124, 883,3197,2261,3710,1765,1553,2658,
1178,2639,2351,  93,1193, 942,2538,2141,4402, 235,1821, 870,1591,2192,1709,1871,
3341,1618,4126,2595,2334, 603, 651,  69, 701, 268,2662,3411,2555,1380,1606, 503,
 448, 254,2371,2646, 574,1187,2309,1770, 322,2235,1292,1801, 305, 566,1133, 229,
2067,2057, 706, 167, 483,2002,2672,3295,1820,3561,3067, 316, 378,2746,3452,1112,
 136,1981, 507,1651,2917,1117, 285,4591, 182,2580,3522,1304, 335,3303,1835,2504,
1795,1792,2248, 674,1018,2106,2449,1857,2292,2845, 976,3047,1781,2600,2727,1389,
1281,  52,3152, 153, 265,3950, 672,3485,3951,4463, 430,1183, 365, 278,2169,  27,
1407,1336,2304, 209,1340,1730,2202,1852,2403,2883, 979,1737,1062, 631,2829,2542,
3876,2592, 825,2086,2226,3048,3625, 352,1417,3724, 542, 991, 431,1351,3938,1861,
2294, 826,1361,2927,3142,3503,1738, 463,2462,2723, 582,1916,1595,2808, 400,3845,
3891,2868,3621,2254,  58,2492,1123, 910,2160,2614,1372,1603,1196,1072,3385,1700,
3267,1980, 696, 480,2430, 920, 799,1570,2920,1951,2041,4047,2540,1321,4223,2469,
3562,2228,1271,2602, 401,2833,3351,2575,5157, 907,2312,1256, 410, 263,3507,1582,
 996, 678,1849,2316,1480, 908,3545,2237, 703,2322, 667,1826,2849,1531,2604,2999,
2407,3146,2151,2630,1786,3711, 469,3542, 497,3899,2409, 858, 837,4446,3393,1274,
 786, 620,1845,2001,3311, 484, 308,3367,1204,1815,3691,2332,1532,2557,1842,2020,
2724,1927,2333,4440, 567,  22,1673,2728,4475,1987,1858,1144,1597, 101,1832,3601,
  12, 974,3783,4391, 951,1412,   1,3720, 453,4608,4041, 528,1041,1027,3230,2628,
1129, 875,1051,3291,1203,2262,1069,2860,2799,2149,2615,3278, 144,1758,3040,  31,
 475,1680, 366,2685,3184, 311,1642,4008,2466,5036,1593,1493,2809, 216,1420,1668,
 233, 304,2128,3284, 232,1429,1768,1040,2008,3407,2740,2967,2543, 242,2133, 778,
1565,2022,2620, 505,2189,2756,1098,2273, 372,1614, 708, 553,2846,2094,2278, 169,
3626,2835,4161, 228,2674,3165, 809,1454,1309, 466,1705,1095, 900,3423, 880,2667,
3751,5258,2317,3109,2571,4317,2766,1503,1342, 866,4447,1118,  63,2076, 314,1881,
1348,1061, 172, 978,3515,1747, 532, 511,3970,   6, 601, 905,2699,3300,1751, 276,
1467,3725,2668,  65,4239,2544,2779,2556,1604, 578,2451,1802, 992,2331,2624,1320,
3446, 713,1513,1013, 103,2786,2447,1661, 886,1702, 916, 654,3574,2031,1556, 751,
2178,2821,2179,1498,1538,2176, 271, 914,2251,2080,1325, 638,1953,2937,3877,2432,
2754,  95,3265,1716, 260,1227,4083, 775, 106,1357,3254, 426,1607, 555,2480, 772,
1985, 244,2546, 474, 495,1046,2611,1851,2061,  71,2089,1675,2590, 742,3758,2843,
3222,1433, 267,2180,2576,2826,2233,2092,3913,2435, 956,1745,3075, 856,2113,1116,
 451,   3,1988,2896,1398, 993,2463,1878,2049,1341,2718,2721,2870,2108, 712,2904,
4363,2753,2324, 277,2872,2349,2649, 384, 987, 435, 691,3000, 922, 164,3939, 652,
1500,1184,4153,2482,3373,2165,4848,2335,3775,3508,3154,2806,2830,1554,2102,1664,
2530,1434,2408, 893,1547,2623,3447,2832,2242,2532,3169,2856,3223,2078,  49,3770,
3469, 462, 318, 656,2259,3250,3069, 679,1629,2758, 344,1138,1104,3120,1836,1283,
3115,2154,1437,4448, 934, 759,1999, 794,2862,1038, 533,2560,1722,2342, 855,2626,
1197,1663,4476,3127,  85,4240,2528,  25,1111,1181,3673, 407,3470,4561,2679,2713,
 768,1925,2841,3986,1544,1165, 932, 373,1240,2146,1930,2673, 721,4766, 354,4333,
 391,2963, 187,  61,3364,1442,1102, 330,1940,1767, 341,3809,4118, 393,2496,2062,
2211, 105, 331, 300, 439, 913,1332, 626, 379,3304,1557, 328, 689,3952, 309,1555,
 931, 317,2517,3027, 325, 569, 686,2107,3084,  60,1042,1333,2794, 264,3177,4014,
1628, 258,3712,   7,4464,1176,1043,1778, 683, 114,1975,  78,1492, 383,1886, 510,
 386, 645,5291,2891,2069,3305,4138,3867,2939,2603,2493,1935,1066,1848,3588,1015,
1282,1289,4609, 697,1453,3044,2666,3611,1856,2412,  54, 719,1330, 568,3778,2459,
1748, 788, 492, 551,1191,1000, 488,3394,3763, 282,1799, 348,2016,1523,3155,2390,
1049, 382,2019,1788,1170, 729,2968,3523, 897,3926,2785,2938,3292, 350,2319,3238,
1718,1717,2655,3453,3143,4465, 161,2889,2980,2009,1421,  56,1908,1640,2387,2232,
1917,1874,2477,4921, 148,  83,3438, 592,4245,2882,1822,1055, 741, 115,1496,1624,
 381,1638,4592,1020, 516,3214, 458, 947,4575,1432, 211,1514,2926,1865,2142, 189,
 852,1221,1400,1486, 882,2299,4036, 351,  28,1122, 700,6479,6480,6481,6482,6483,  # last 512
#Everything below is of no interest for detection purpose
5508,6484,3900,3414,3974,4441,4024,3537,4037,5628,5099,3633,6485,3148,6486,3636,
5509,3257,5510,5973,5445,5872,4941,4403,3174,4627,5873,6276,2286,4230,5446,5874,
5122,6102,6103,4162,5447,5123,5323,4849,6277,3980,3851,5066,4246,5774,5067,6278,
3001,2807,5695,3346,5775,5974,5158,5448,6487,5975,5976,5776,3598,6279,5696,4806,
4211,4154,6280,6488,6489,6490,6281,4212,5037,3374,4171,6491,4562,4807,4722,4827,
5977,6104,4532,4079,5159,5324,5160,4404,3858,5359,5875,3975,4288,4610,3486,4512,
5325,3893,5360,6282,6283,5560,2522,4231,5978,5186,5449,2569,3878,6284,5401,3578,
4415,6285,4656,5124,5979,2506,4247,4449,3219,3417,4334,4969,4329,6492,4576,4828,
4172,4416,4829,5402,6286,3927,3852,5361,4369,4830,4477,4867,5876,4173,6493,6105,
4657,6287,6106,5877,5450,6494,4155,4868,5451,3700,5629,4384,6288,6289,5878,3189,
4881,6107,6290,6495,4513,6496,4692,4515,4723,5100,3356,6497,6291,3810,4080,5561,
3570,4430,5980,6498,4355,5697,6499,4724,6108,6109,3764,4050,5038,5879,4093,3226,
6292,5068,5217,4693,3342,5630,3504,4831,4377,4466,4309,5698,4431,5777,6293,5778,
4272,3706,6110,5326,3752,4676,5327,4273,5403,4767,5631,6500,5699,5880,3475,5039,
6294,5562,5125,4348,4301,4482,4068,5126,4593,5700,3380,3462,5981,5563,3824,5404,
4970,5511,3825,4738,6295,6501,5452,4516,6111,5881,5564,6502,6296,5982,6503,4213,
4163,3454,6504,6112,4009,4450,6113,4658,6297,6114,3035,6505,6115,3995,4904,4739,
4563,4942,4110,5040,3661,3928,5362,3674,6506,5292,3612,4791,5565,4149,5983,5328,
5259,5021,4725,4577,4564,4517,4364,6298,5405,4578,5260,4594,4156,4157,5453,3592,
3491,6507,5127,5512,4709,4922,5984,5701,4726,4289,6508,4015,6116,5128,4628,3424,
4241,5779,6299,4905,6509,6510,5454,5702,5780,6300,4365,4923,3971,6511,5161,3270,
3158,5985,4100, 867,5129,5703,6117,5363,3695,3301,5513,4467,6118,6512,5455,4232,
4242,4629,6513,3959,4478,6514,5514,5329,5986,4850,5162,5566,3846,4694,6119,5456,
4869,5781,3779,6301,5704,5987,5515,4710,6302,5882,6120,4392,5364,5705,6515,6121,
6516,6517,3736,5988,5457,5989,4695,2457,5883,4551,5782,6303,6304,6305,5130,4971,
6122,5163,6123,4870,3263,5365,3150,4871,6518,6306,5783,5069,5706,3513,3498,4409,
5330,5632,5366,5458,5459,3991,5990,4502,3324,5991,5784,3696,4518,5633,4119,6519,
4630,5634,4417,5707,4832,5992,3418,6124,5993,5567,4768,5218,6520,4595,3458,5367,
6125,5635,6126,4202,6521,4740,4924,6307,3981,4069,4385,6308,3883,2675,4051,3834,
4302,4483,5568,5994,4972,4101,5368,6309,5164,5884,3922,6127,6522,6523,5261,5460,
5187,4164,5219,3538,5516,4111,3524,5995,6310,6311,5369,3181,3386,2484,5188,3464,
5569,3627,5708,6524,5406,5165,4677,4492,6312,4872,4851,5885,4468,5996,6313,5709,
5710,6128,2470,5886,6314,5293,4882,5785,3325,5461,5101,6129,5711,5786,6525,4906,
6526,6527,4418,5887,5712,4808,2907,3701,5713,5888,6528,3765,5636,5331,6529,6530,
3593,5889,3637,4943,3692,5714,5787,4925,6315,6130,5462,4405,6131,6132,6316,5262,
6531,6532,5715,3859,5716,5070,4696,5102,3929,5788,3987,4792,5997,6533,6534,3920,
4809,5000,5998,6535,2974,5370,6317,5189,5263,5717,3826,6536,3953,5001,4883,3190,
5463,5890,4973,5999,4741,6133,6134,3607,5570,6000,4711,3362,3630,4552,5041,6318,
6001,2950,2953,5637,4646,5371,4944,6002,2044,4120,3429,6319,6537,5103,4833,6538,
6539,4884,4647,3884,6003,6004,4758,3835,5220,5789,4565,5407,6540,6135,5294,4697,
4852,6320,6321,3206,4907,6541,6322,4945,6542,6136,6543,6323,6005,4631,3519,6544,
5891,6545,5464,3784,5221,6546,5571,4659,6547,6324,6137,5190,6548,3853,6549,4016,
4834,3954,6138,5332,3827,4017,3210,3546,4469,5408,5718,3505,4648,5790,5131,5638,
5791,5465,4727,4318,6325,6326,5792,4553,4010,4698,3439,4974,3638,4335,3085,6006,
5104,5042,5166,5892,5572,6327,4356,4519,5222,5573,5333,5793,5043,6550,5639,5071,
4503,6328,6139,6551,6140,3914,3901,5372,6007,5640,4728,4793,3976,3836,4885,6552,
4127,6553,4451,4102,5002,6554,3686,5105,6555,5191,5072,5295,4611,5794,5296,6556,
5893,5264,5894,4975,5466,5265,4699,4976,4370,4056,3492,5044,4886,6557,5795,4432,
4769,4357,5467,3940,4660,4290,6141,4484,4770,4661,3992,6329,4025,4662,5022,4632,
4835,4070,5297,4663,4596,5574,5132,5409,5895,6142,4504,5192,4664,5796,5896,3885,
5575,5797,5023,4810,5798,3732,5223,4712,5298,4084,5334,5468,6143,4052,4053,4336,
4977,4794,6558,5335,4908,5576,5224,4233,5024,4128,5469,5225,4873,6008,5045,4729,
4742,4633,3675,4597,6559,5897,5133,5577,5003,5641,5719,6330,6560,3017,2382,3854,
4406,4811,6331,4393,3964,4946,6561,2420,3722,6562,4926,4378,3247,1736,4442,6332,
5134,6333,5226,3996,2918,5470,4319,4003,4598,4743,4744,4485,3785,3902,5167,5004,
5373,4394,5898,6144,4874,1793,3997,6334,4085,4214,5106,5642,4909,5799,6009,4419,
4189,3330,5899,4165,4420,5299,5720,5227,3347,6145,4081,6335,2876,3930,6146,3293,
3786,3910,3998,5900,5300,5578,2840,6563,5901,5579,6147,3531,5374,6564,6565,5580,
4759,5375,6566,6148,3559,5643,6336,6010,5517,6337,6338,5721,5902,3873,6011,6339,
6567,5518,3868,3649,5722,6568,4771,4947,6569,6149,4812,6570,2853,5471,6340,6341,
5644,4795,6342,6012,5723,6343,5724,6013,4349,6344,3160,6150,5193,4599,4514,4493,
5168,4320,6345,4927,3666,4745,5169,5903,5005,4928,6346,5725,6014,4730,4203,5046,
4948,3395,5170,6015,4150,6016,5726,5519,6347,5047,3550,6151,6348,4197,4310,5904,
6571,5581,2965,6152,4978,3960,4291,5135,6572,5301,5727,4129,4026,5905,4853,5728,
5472,6153,6349,4533,2700,4505,5336,4678,3583,5073,2994,4486,3043,4554,5520,6350,
6017,5800,4487,6351,3931,4103,5376,6352,4011,4321,4311,4190,5136,6018,3988,3233,
4350,5906,5645,4198,6573,5107,3432,4191,3435,5582,6574,4139,5410,6353,5411,3944,
5583,5074,3198,6575,6354,4358,6576,5302,4600,5584,5194,5412,6577,6578,5585,5413,
5303,4248,5414,3879,4433,6579,4479,5025,4854,5415,6355,4760,4772,3683,2978,4700,
3797,4452,3965,3932,3721,4910,5801,6580,5195,3551,5907,3221,3471,3029,6019,3999,
5908,5909,5266,5267,3444,3023,3828,3170,4796,5646,4979,4259,6356,5647,5337,3694,
6357,5648,5338,4520,4322,5802,3031,3759,4071,6020,5586,4836,4386,5048,6581,3571,
4679,4174,4949,6154,4813,3787,3402,3822,3958,3215,3552,5268,4387,3933,4950,4359,
6021,5910,5075,3579,6358,4234,4566,5521,6359,3613,5049,6022,5911,3375,3702,3178,
4911,5339,4521,6582,6583,4395,3087,3811,5377,6023,6360,6155,4027,5171,5649,4421,
4249,2804,6584,2270,6585,4000,4235,3045,6156,5137,5729,4140,4312,3886,6361,4330,
6157,4215,6158,3500,3676,4929,4331,3713,4930,5912,4265,3776,3368,5587,4470,4855,
3038,4980,3631,6159,6160,4132,4680,6161,6362,3923,4379,5588,4255,6586,4121,6587,
6363,4649,6364,3288,4773,4774,6162,6024,6365,3543,6588,4274,3107,3737,5050,5803,
4797,4522,5589,5051,5730,3714,4887,5378,4001,4523,6163,5026,5522,4701,4175,2791,
3760,6589,5473,4224,4133,3847,4814,4815,4775,3259,5416,6590,2738,6164,6025,5304,
3733,5076,5650,4816,5590,6591,6165,6592,3934,5269,6593,3396,5340,6594,5804,3445,
3602,4042,4488,5731,5732,3525,5591,4601,5196,6166,6026,5172,3642,4612,3202,4506,
4798,6366,3818,5108,4303,5138,5139,4776,3332,4304,2915,3415,4434,5077,5109,4856,
2879,5305,4817,6595,5913,3104,3144,3903,4634,5341,3133,5110,5651,5805,6167,4057,
5592,2945,4371,5593,6596,3474,4182,6367,6597,6168,4507,4279,6598,2822,6599,4777,
4713,5594,3829,6169,3887,5417,6170,3653,5474,6368,4216,2971,5228,3790,4579,6369,
5733,6600,6601,4951,4746,4555,6602,5418,5475,6027,3400,4665,5806,6171,4799,6028,
5052,6172,3343,4800,4747,5006,6370,4556,4217,5476,4396,5229,5379,5477,3839,5914,
5652,5807,4714,3068,4635,5808,6173,5342,4192,5078,5419,5523,5734,6174,4557,6175,
4602,6371,6176,6603,5809,6372,5735,4260,3869,5111,5230,6029,5112,6177,3126,4681,
5524,5915,2706,3563,4748,3130,6178,4018,5525,6604,6605,5478,4012,4837,6606,4534,
4193,5810,4857,3615,5479,6030,4082,3697,3539,4086,5270,3662,4508,4931,5916,4912,
5811,5027,3888,6607,4397,3527,3302,3798,2775,2921,2637,3966,4122,4388,4028,4054,
1633,4858,5079,3024,5007,3982,3412,5736,6608,3426,3236,5595,3030,6179,3427,3336,
3279,3110,6373,3874,3039,5080,5917,5140,4489,3119,6374,5812,3405,4494,6031,4666,
4141,6180,4166,6032,5813,4981,6609,5081,4422,4982,4112,3915,5653,3296,3983,6375,
4266,4410,5654,6610,6181,3436,5082,6611,5380,6033,3819,5596,4535,5231,5306,5113,
6612,4952,5918,4275,3113,6613,6376,6182,6183,5814,3073,4731,4838,5008,3831,6614,
4888,3090,3848,4280,5526,5232,3014,5655,5009,5737,5420,5527,6615,5815,5343,5173,
5381,4818,6616,3151,4953,6617,5738,2796,3204,4360,2989,4281,5739,5174,5421,5197,
3132,5141,3849,5142,5528,5083,3799,3904,4839,5480,2880,4495,3448,6377,6184,5271,
5919,3771,3193,6034,6035,5920,5010,6036,5597,6037,6378,6038,3106,5422,6618,5423,
5424,4142,6619,4889,5084,4890,4313,5740,6620,3437,5175,5307,5816,4199,5198,5529,
5817,5199,5656,4913,5028,5344,3850,6185,2955,5272,5011,5818,4567,4580,5029,5921,
3616,5233,6621,6622,6186,4176,6039,6379,6380,3352,5200,5273,2908,5598,5234,3837,
5308,6623,6624,5819,4496,4323,5309,5201,6625,6626,4983,3194,3838,4167,5530,5922,
5274,6381,6382,3860,3861,5599,3333,4292,4509,6383,3553,5481,5820,5531,4778,6187,
3955,3956,4324,4389,4218,3945,4325,3397,2681,5923,4779,5085,4019,5482,4891,5382,
5383,6040,4682,3425,5275,4094,6627,5310,3015,5483,5657,4398,5924,3168,4819,6628,
5925,6629,5532,4932,4613,6041,6630,4636,6384,4780,4204,5658,4423,5821,3989,4683,
5822,6385,4954,6631,5345,6188,5425,5012,5384,3894,6386,4490,4104,6632,5741,5053,
6633,5823,5926,5659,5660,5927,6634,5235,5742,5824,4840,4933,4820,6387,4859,5928,
4955,6388,4143,3584,5825,5346,5013,6635,5661,6389,5014,5484,5743,4337,5176,5662,
6390,2836,6391,3268,6392,6636,6042,5236,6637,4158,6638,5744,5663,4471,5347,3663,
4123,5143,4293,3895,6639,6640,5311,5929,5826,3800,6189,6393,6190,5664,5348,3554,
3594,4749,4603,6641,5385,4801,6043,5827,4183,6642,5312,5426,4761,6394,5665,6191,
4715,2669,6643,6644,5533,3185,5427,5086,5930,5931,5386,6192,6044,6645,4781,4013,
5745,4282,4435,5534,4390,4267,6045,5746,4984,6046,2743,6193,3501,4087,5485,5932,
5428,4184,4095,5747,4061,5054,3058,3862,5933,5600,6646,5144,3618,6395,3131,5055,
5313,6396,4650,4956,3855,6194,3896,5202,4985,4029,4225,6195,6647,5828,5486,5829,
3589,3002,6648,6397,4782,5276,6649,6196,6650,4105,3803,4043,5237,5830,6398,4096,
3643,6399,3528,6651,4453,3315,4637,6652,3984,6197,5535,3182,3339,6653,3096,2660,
6400,6654,3449,5934,4250,4236,6047,6401,5831,6655,5487,3753,4062,5832,6198,6199,
6656,3766,6657,3403,4667,6048,6658,4338,2897,5833,3880,2797,3780,4326,6659,5748,
5015,6660,5387,4351,5601,4411,6661,3654,4424,5935,4339,4072,5277,4568,5536,6402,
6662,5238,6663,5349,5203,6200,5204,6201,5145,4536,5016,5056,4762,5834,4399,4957,
6202,6403,5666,5749,6664,4340,6665,5936,5177,5667,6666,6667,3459,4668,6404,6668,
6669,4543,6203,6670,4276,6405,4480,5537,6671,4614,5205,5668,6672,3348,2193,4763,
6406,6204,5937,5602,4177,5669,3419,6673,4020,6205,4443,4569,5388,3715,3639,6407,
6049,4058,6206,6674,5938,4544,6050,4185,4294,4841,4651,4615,5488,6207,6408,6051,
5178,3241,3509,5835,6208,4958,5836,4341,5489,5278,6209,2823,5538,5350,5206,5429,
6675,4638,4875,4073,3516,4684,4914,4860,5939,5603,5389,6052,5057,3237,5490,3791,
6676,6409,6677,4821,4915,4106,5351,5058,4243,5539,4244,5604,4842,4916,5239,3028,
3716,5837,5114,5605,5390,5940,5430,6210,4332,6678,5540,4732,3667,3840,6053,4305,
3408,5670,5541,6410,2744,5240,5750,6679,3234,5606,6680,5607,5671,3608,4283,4159,
4400,5352,4783,6681,6411,6682,4491,4802,6211,6412,5941,6413,6414,5542,5751,6683,
4669,3734,5942,6684,6415,5943,5059,3328,4670,4144,4268,6685,6686,6687,6688,4372,
3603,6689,5944,5491,4373,3440,6416,5543,4784,4822,5608,3792,4616,5838,5672,3514,
5391,6417,4892,6690,4639,6691,6054,5673,5839,6055,6692,6056,5392,6212,4038,5544,
5674,4497,6057,6693,5840,4284,5675,4021,4545,5609,6418,4454,6419,6213,4113,4472,
5314,3738,5087,5279,4074,5610,4959,4063,3179,4750,6058,6420,6214,3476,4498,4716,
5431,4960,4685,6215,5241,6694,6421,6216,6695,5841,5945,6422,3748,5946,5179,3905,
5752,5545,5947,4374,6217,4455,6423,4412,6218,4803,5353,6696,3832,5280,6219,4327,
4702,6220,6221,6059,4652,5432,6424,3749,4751,6425,5753,4986,5393,4917,5948,5030,
5754,4861,4733,6426,4703,6697,6222,4671,5949,4546,4961,5180,6223,5031,3316,5281,
6698,4862,4295,4934,5207,3644,6427,5842,5950,6428,6429,4570,5843,5282,6430,6224,
5088,3239,6060,6699,5844,5755,6061,6431,2701,5546,6432,5115,5676,4039,3993,3327,
4752,4425,5315,6433,3941,6434,5677,4617,4604,3074,4581,6225,5433,6435,6226,6062,
4823,5756,5116,6227,3717,5678,4717,5845,6436,5679,5846,6063,5847,6064,3977,3354,
6437,3863,5117,6228,5547,5394,4499,4524,6229,4605,6230,4306,4500,6700,5951,6065,
3693,5952,5089,4366,4918,6701,6231,5548,6232,6702,6438,4704,5434,6703,6704,5953,
4168,6705,5680,3420,6706,5242,4407,6066,3812,5757,5090,5954,4672,4525,3481,5681,
4618,5395,5354,5316,5955,6439,4962,6707,4526,6440,3465,4673,6067,6441,5682,6708,
5435,5492,5758,5683,4619,4571,4674,4804,4893,4686,5493,4753,6233,6068,4269,6442,
6234,5032,4705,5146,5243,5208,5848,6235,6443,4963,5033,4640,4226,6236,5849,3387,
6444,6445,4436,4437,5850,4843,5494,4785,4894,6709,4361,6710,5091,5956,3331,6237,
4987,5549,6069,6711,4342,3517,4473,5317,6070,6712,6071,4706,6446,5017,5355,6713,
6714,4988,5436,6447,4734,5759,6715,4735,4547,4456,4754,6448,5851,6449,6450,3547,
5852,5318,6451,6452,5092,4205,6716,6238,4620,4219,5611,6239,6072,4481,5760,5957,
5958,4059,6240,6453,4227,4537,6241,5761,4030,4186,5244,5209,3761,4457,4876,3337,
5495,5181,6242,5959,5319,5612,5684,5853,3493,5854,6073,4169,5613,5147,4895,6074,
5210,6717,5182,6718,3830,6243,2798,3841,6075,6244,5855,5614,3604,4606,5496,5685,
5118,5356,6719,6454,5960,5357,5961,6720,4145,3935,4621,5119,5962,4261,6721,6455,
4786,5963,4375,4582,6245,6246,6247,6076,5437,4877,5856,3376,4380,6248,4160,6722,
5148,6456,5211,6457,6723,4718,6458,6724,6249,5358,4044,3297,6459,6250,5857,5615,
5497,5245,6460,5498,6725,6251,6252,5550,3793,5499,2959,5396,6461,6462,4572,5093,
5500,5964,3806,4146,6463,4426,5762,5858,6077,6253,4755,3967,4220,5965,6254,4989,
5501,6464,4352,6726,6078,4764,2290,5246,3906,5438,5283,3767,4964,2861,5763,5094,
6255,6256,4622,5616,5859,5860,4707,6727,4285,4708,4824,5617,6257,5551,4787,5212,
4965,4935,4687,6465,6728,6466,5686,6079,3494,4413,2995,5247,5966,5618,6729,5967,
5764,5765,5687,5502,6730,6731,6080,5397,6467,4990,6258,6732,4538,5060,5619,6733,
4719,5688,5439,5018,5149,5284,5503,6734,6081,4607,6259,5120,3645,5861,4583,6260,
4584,4675,5620,4098,5440,6261,4863,2379,3306,4585,5552,5689,4586,5285,6735,4864,
6736,5286,6082,6737,4623,3010,4788,4381,4558,5621,4587,4896,3698,3161,5248,4353,
4045,6262,3754,5183,4588,6738,6263,6739,6740,5622,3936,6741,6468,6742,6264,5095,
6469,4991,5968,6743,4992,6744,6083,4897,6745,4256,5766,4307,3108,3968,4444,5287,
3889,4343,6084,4510,6085,4559,6086,4898,5969,6746,5623,5061,4919,5249,5250,5504,
5441,6265,5320,4878,3242,5862,5251,3428,6087,6747,4237,5624,5442,6266,5553,4539,
6748,2585,3533,5398,4262,6088,5150,4736,4438,6089,6267,5505,4966,6749,6268,6750,
6269,5288,5554,3650,6090,6091,4624,6092,5690,6751,5863,4270,5691,4277,5555,5864,
6752,5692,4720,4865,6470,5151,4688,4825,6753,3094,6754,6471,3235,4653,6755,5213,
5399,6756,3201,4589,5865,4967,6472,5866,6473,5019,3016,6757,5321,4756,3957,4573,
6093,4993,5767,4721,6474,6758,5625,6759,4458,6475,6270,6760,5556,4994,5214,5252,
6271,3875,5768,6094,5034,5506,4376,5769,6761,2120,6476,5253,5770,6762,5771,5970,
3990,5971,5557,5558,5772,6477,6095,2787,4641,5972,5121,6096,6097,6272,6763,3703,
5867,5507,6273,4206,6274,4789,6098,6764,3619,3646,3833,3804,2394,3788,4936,3978,
4866,4899,6099,6100,5559,6478,6765,3599,5868,6101,5869,5870,6275,6766,4527,6767)

# flake8: noqa

########NEW FILE########
__FILENAME__ = gb2312prober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import GB2312DistributionAnalysis
from .mbcssm import GB2312SMModel

class GB2312Prober(MultiByteCharSetProber):
    def __init__(self):
        MultiByteCharSetProber.__init__(self)
        self._mCodingSM = CodingStateMachine(GB2312SMModel)
        self._mDistributionAnalyzer = GB2312DistributionAnalysis()
        self.reset()

    def get_charset_name(self):
        return "GB2312"

########NEW FILE########
__FILENAME__ = hebrewprober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
#          Shy Shalom
# Portions created by the Initial Developer are Copyright (C) 2005
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .charsetprober import CharSetProber
from .constants import eNotMe, eDetecting
from .compat import wrap_ord

# This prober doesn't actually recognize a language or a charset.
# It is a helper prober for the use of the Hebrew model probers

### General ideas of the Hebrew charset recognition ###
#
# Four main charsets exist in Hebrew:
# "ISO-8859-8" - Visual Hebrew
# "windows-1255" - Logical Hebrew
# "ISO-8859-8-I" - Logical Hebrew
# "x-mac-hebrew" - ?? Logical Hebrew ??
#
# Both "ISO" charsets use a completely identical set of code points, whereas
# "windows-1255" and "x-mac-hebrew" are two different proper supersets of
# these code points. windows-1255 defines additional characters in the range
# 0x80-0x9F as some misc punctuation marks as well as some Hebrew-specific
# diacritics and additional 'Yiddish' ligature letters in the range 0xc0-0xd6.
# x-mac-hebrew defines similar additional code points but with a different
# mapping.
#
# As far as an average Hebrew text with no diacritics is concerned, all four
# charsets are identical with respect to code points. Meaning that for the
# main Hebrew alphabet, all four map the same values to all 27 Hebrew letters
# (including final letters).
#
# The dominant difference between these charsets is their directionality.
# "Visual" directionality means that the text is ordered as if the renderer is
# not aware of a BIDI rendering algorithm. The renderer sees the text and
# draws it from left to right. The text itself when ordered naturally is read
# backwards. A buffer of Visual Hebrew generally looks like so:
# "[last word of first line spelled backwards] [whole line ordered backwards
# and spelled backwards] [first word of first line spelled backwards]
# [end of line] [last word of second line] ... etc' "
# adding punctuation marks, numbers and English text to visual text is
# naturally also "visual" and from left to right.
#
# "Logical" directionality means the text is ordered "naturally" according to
# the order it is read. It is the responsibility of the renderer to display
# the text from right to left. A BIDI algorithm is used to place general
# punctuation marks, numbers and English text in the text.
#
# Texts in x-mac-hebrew are almost impossible to find on the Internet. From
# what little evidence I could find, it seems that its general directionality
# is Logical.
#
# To sum up all of the above, the Hebrew probing mechanism knows about two
# charsets:
# Visual Hebrew - "ISO-8859-8" - backwards text - Words and sentences are
#    backwards while line order is natural. For charset recognition purposes
#    the line order is unimportant (In fact, for this implementation, even
#    word order is unimportant).
# Logical Hebrew - "windows-1255" - normal, naturally ordered text.
#
# "ISO-8859-8-I" is a subset of windows-1255 and doesn't need to be
#    specifically identified.
# "x-mac-hebrew" is also identified as windows-1255. A text in x-mac-hebrew
#    that contain special punctuation marks or diacritics is displayed with
#    some unconverted characters showing as question marks. This problem might
#    be corrected using another model prober for x-mac-hebrew. Due to the fact
#    that x-mac-hebrew texts are so rare, writing another model prober isn't
#    worth the effort and performance hit.
#
#### The Prober ####
#
# The prober is divided between two SBCharSetProbers and a HebrewProber,
# all of which are managed, created, fed data, inquired and deleted by the
# SBCSGroupProber. The two SBCharSetProbers identify that the text is in
# fact some kind of Hebrew, Logical or Visual. The final decision about which
# one is it is made by the HebrewProber by combining final-letter scores
# with the scores of the two SBCharSetProbers to produce a final answer.
#
# The SBCSGroupProber is responsible for stripping the original text of HTML
# tags, English characters, numbers, low-ASCII punctuation characters, spaces
# and new lines. It reduces any sequence of such characters to a single space.
# The buffer fed to each prober in the SBCS group prober is pure text in
# high-ASCII.
# The two SBCharSetProbers (model probers) share the same language model:
# Win1255Model.
# The first SBCharSetProber uses the model normally as any other
# SBCharSetProber does, to recognize windows-1255, upon which this model was
# built. The second SBCharSetProber is told to make the pair-of-letter
# lookup in the language model backwards. This in practice exactly simulates
# a visual Hebrew model using the windows-1255 logical Hebrew model.
#
# The HebrewProber is not using any language model. All it does is look for
# final-letter evidence suggesting the text is either logical Hebrew or visual
# Hebrew. Disjointed from the model probers, the results of the HebrewProber
# alone are meaningless. HebrewProber always returns 0.00 as confidence
# since it never identifies a charset by itself. Instead, the pointer to the
# HebrewProber is passed to the model probers as a helper "Name Prober".
# When the Group prober receives a positive identification from any prober,
# it asks for the name of the charset identified. If the prober queried is a
# Hebrew model prober, the model prober forwards the call to the
# HebrewProber to make the final decision. In the HebrewProber, the
# decision is made according to the final-letters scores maintained and Both
# model probers scores. The answer is returned in the form of the name of the
# charset identified, either "windows-1255" or "ISO-8859-8".

# windows-1255 / ISO-8859-8 code points of interest
FINAL_KAF = 0xea
NORMAL_KAF = 0xeb
FINAL_MEM = 0xed
NORMAL_MEM = 0xee
FINAL_NUN = 0xef
NORMAL_NUN = 0xf0
FINAL_PE = 0xf3
NORMAL_PE = 0xf4
FINAL_TSADI = 0xf5
NORMAL_TSADI = 0xf6

# Minimum Visual vs Logical final letter score difference.
# If the difference is below this, don't rely solely on the final letter score
# distance.
MIN_FINAL_CHAR_DISTANCE = 5

# Minimum Visual vs Logical model score difference.
# If the difference is below this, don't rely at all on the model score
# distance.
MIN_MODEL_DISTANCE = 0.01

VISUAL_HEBREW_NAME = "ISO-8859-8"
LOGICAL_HEBREW_NAME = "windows-1255"


class HebrewProber(CharSetProber):
    def __init__(self):
        CharSetProber.__init__(self)
        self._mLogicalProber = None
        self._mVisualProber = None
        self.reset()

    def reset(self):
        self._mFinalCharLogicalScore = 0
        self._mFinalCharVisualScore = 0
        # The two last characters seen in the previous buffer,
        # mPrev and mBeforePrev are initialized to space in order to simulate
        # a word delimiter at the beginning of the data
        self._mPrev = ' '
        self._mBeforePrev = ' '
        # These probers are owned by the group prober.

    def set_model_probers(self, logicalProber, visualProber):
        self._mLogicalProber = logicalProber
        self._mVisualProber = visualProber

    def is_final(self, c):
        return wrap_ord(c) in [FINAL_KAF, FINAL_MEM, FINAL_NUN, FINAL_PE,
                               FINAL_TSADI]

    def is_non_final(self, c):
        # The normal Tsadi is not a good Non-Final letter due to words like
        # 'lechotet' (to chat) containing an apostrophe after the tsadi. This
        # apostrophe is converted to a space in FilterWithoutEnglishLetters
        # causing the Non-Final tsadi to appear at an end of a word even
        # though this is not the case in the original text.
        # The letters Pe and Kaf rarely display a related behavior of not being
        # a good Non-Final letter. Words like 'Pop', 'Winamp' and 'Mubarak'
        # for example legally end with a Non-Final Pe or Kaf. However, the
        # benefit of these letters as Non-Final letters outweighs the damage
        # since these words are quite rare.
        return wrap_ord(c) in [NORMAL_KAF, NORMAL_MEM, NORMAL_NUN, NORMAL_PE]

    def feed(self, aBuf):
        # Final letter analysis for logical-visual decision.
        # Look for evidence that the received buffer is either logical Hebrew
        # or visual Hebrew.
        # The following cases are checked:
        # 1) A word longer than 1 letter, ending with a final letter. This is
        #    an indication that the text is laid out "naturally" since the
        #    final letter really appears at the end. +1 for logical score.
        # 2) A word longer than 1 letter, ending with a Non-Final letter. In
        #    normal Hebrew, words ending with Kaf, Mem, Nun, Pe or Tsadi,
        #    should not end with the Non-Final form of that letter. Exceptions
        #    to this rule are mentioned above in isNonFinal(). This is an
        #    indication that the text is laid out backwards. +1 for visual
        #    score
        # 3) A word longer than 1 letter, starting with a final letter. Final
        #    letters should not appear at the beginning of a word. This is an
        #    indication that the text is laid out backwards. +1 for visual
        #    score.
        #
        # The visual score and logical score are accumulated throughout the
        # text and are finally checked against each other in GetCharSetName().
        # No checking for final letters in the middle of words is done since
        # that case is not an indication for either Logical or Visual text.
        #
        # We automatically filter out all 7-bit characters (replace them with
        # spaces) so the word boundary detection works properly. [MAP]

        if self.get_state() == eNotMe:
            # Both model probers say it's not them. No reason to continue.
            return eNotMe

        aBuf = self.filter_high_bit_only(aBuf)

        for cur in aBuf:
            if cur == ' ':
                # We stand on a space - a word just ended
                if self._mBeforePrev != ' ':
                    # next-to-last char was not a space so self._mPrev is not a
                    # 1 letter word
                    if self.is_final(self._mPrev):
                        # case (1) [-2:not space][-1:final letter][cur:space]
                        self._mFinalCharLogicalScore += 1
                    elif self.is_non_final(self._mPrev):
                        # case (2) [-2:not space][-1:Non-Final letter][
                        #  cur:space]
                        self._mFinalCharVisualScore += 1
            else:
                # Not standing on a space
                if ((self._mBeforePrev == ' ') and
                        (self.is_final(self._mPrev)) and (cur != ' ')):
                    # case (3) [-2:space][-1:final letter][cur:not space]
                    self._mFinalCharVisualScore += 1
            self._mBeforePrev = self._mPrev
            self._mPrev = cur

        # Forever detecting, till the end or until both model probers return
        # eNotMe (handled above)
        return eDetecting

    def get_charset_name(self):
        # Make the decision: is it Logical or Visual?
        # If the final letter score distance is dominant enough, rely on it.
        finalsub = self._mFinalCharLogicalScore - self._mFinalCharVisualScore
        if finalsub >= MIN_FINAL_CHAR_DISTANCE:
            return LOGICAL_HEBREW_NAME
        if finalsub <= -MIN_FINAL_CHAR_DISTANCE:
            return VISUAL_HEBREW_NAME

        # It's not dominant enough, try to rely on the model scores instead.
        modelsub = (self._mLogicalProber.get_confidence()
                    - self._mVisualProber.get_confidence())
        if modelsub > MIN_MODEL_DISTANCE:
            return LOGICAL_HEBREW_NAME
        if modelsub < -MIN_MODEL_DISTANCE:
            return VISUAL_HEBREW_NAME

        # Still no good, back to final letter distance, maybe it'll save the
        # day.
        if finalsub < 0.0:
            return VISUAL_HEBREW_NAME

        # (finalsub > 0 - Logical) or (don't know what to do) default to
        # Logical.
        return LOGICAL_HEBREW_NAME

    def get_state(self):
        # Remain active as long as any of the model probers are active.
        if (self._mLogicalProber.get_state() == eNotMe) and \
           (self._mVisualProber.get_state() == eNotMe):
            return eNotMe
        return eDetecting

########NEW FILE########
__FILENAME__ = jisfreq
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# Sampling from about 20M text materials include literature and computer technology
#
# Japanese frequency table, applied to both S-JIS and EUC-JP
# They are sorted in order.

# 128  --> 0.77094
# 256  --> 0.85710
# 512  --> 0.92635
# 1024 --> 0.97130
# 2048 --> 0.99431
#
# Ideal Distribution Ratio = 0.92635 / (1-0.92635) = 12.58
# Random Distribution Ration = 512 / (2965+62+83+86-512) = 0.191
#
# Typical Distribution Ratio, 25% of IDR

JIS_TYPICAL_DISTRIBUTION_RATIO = 3.0

# Char to FreqOrder table ,
JIS_TABLE_SIZE = 4368

JISCharToFreqOrder = (
  40,   1,   6, 182, 152, 180, 295,2127, 285, 381,3295,4304,3068,4606,3165,3510, #   16
3511,1822,2785,4607,1193,2226,5070,4608, 171,2996,1247,  18, 179,5071, 856,1661, #   32
1262,5072, 619, 127,3431,3512,3230,1899,1700, 232, 228,1294,1298, 284, 283,2041, #   48
2042,1061,1062,  48,  49,  44,  45, 433, 434,1040,1041, 996, 787,2997,1255,4305, #   64
2108,4609,1684,1648,5073,5074,5075,5076,5077,5078,3687,5079,4610,5080,3927,3928, #   80
5081,3296,3432, 290,2285,1471,2187,5082,2580,2825,1303,2140,1739,1445,2691,3375, #   96
1691,3297,4306,4307,4611, 452,3376,1182,2713,3688,3069,4308,5083,5084,5085,5086, #  112
5087,5088,5089,5090,5091,5092,5093,5094,5095,5096,5097,5098,5099,5100,5101,5102, #  128
5103,5104,5105,5106,5107,5108,5109,5110,5111,5112,4097,5113,5114,5115,5116,5117, #  144
5118,5119,5120,5121,5122,5123,5124,5125,5126,5127,5128,5129,5130,5131,5132,5133, #  160
5134,5135,5136,5137,5138,5139,5140,5141,5142,5143,5144,5145,5146,5147,5148,5149, #  176
5150,5151,5152,4612,5153,5154,5155,5156,5157,5158,5159,5160,5161,5162,5163,5164, #  192
5165,5166,5167,5168,5169,5170,5171,5172,5173,5174,5175,1472, 598, 618, 820,1205, #  208
1309,1412,1858,1307,1692,5176,5177,5178,5179,5180,5181,5182,1142,1452,1234,1172, #  224
1875,2043,2149,1793,1382,2973, 925,2404,1067,1241, 960,1377,2935,1491, 919,1217, #  240
1865,2030,1406,1499,2749,4098,5183,5184,5185,5186,5187,5188,2561,4099,3117,1804, #  256
2049,3689,4309,3513,1663,5189,3166,3118,3298,1587,1561,3433,5190,3119,1625,2998, #  272
3299,4613,1766,3690,2786,4614,5191,5192,5193,5194,2161,  26,3377,   2,3929,  20, #  288
3691,  47,4100,  50,  17,  16,  35, 268,  27, 243,  42, 155,  24, 154,  29, 184, #  304
   4,  91,  14,  92,  53, 396,  33, 289,   9,  37,  64, 620,  21,  39, 321,   5, #  320
  12,  11,  52,  13,   3, 208, 138,   0,   7,  60, 526, 141, 151,1069, 181, 275, #  336
1591,  83, 132,1475, 126, 331, 829,  15,  69, 160,  59,  22, 157,  55,1079, 312, #  352
 109,  38,  23,  25,  10,  19,  79,5195,  61, 382,1124,   8,  30,5196,5197,5198, #  368
5199,5200,5201,5202,5203,5204,5205,5206,  89,  62,  74,  34,2416, 112, 139, 196, #  384
 271, 149,  84, 607, 131, 765,  46,  88, 153, 683,  76, 874, 101, 258,  57,  80, #  400
  32, 364, 121,1508, 169,1547,  68, 235, 145,2999,  41, 360,3027,  70,  63,  31, #  416
  43, 259, 262,1383,  99, 533, 194,  66,  93, 846, 217, 192,  56, 106,  58, 565, #  432
 280, 272, 311, 256, 146,  82, 308,  71, 100, 128, 214, 655, 110, 261, 104,1140, #  448
  54,  51,  36,  87,  67,3070, 185,2618,2936,2020,  28,1066,2390,2059,5207,5208, #  464
5209,5210,5211,5212,5213,5214,5215,5216,4615,5217,5218,5219,5220,5221,5222,5223, #  480
5224,5225,5226,5227,5228,5229,5230,5231,5232,5233,5234,5235,5236,3514,5237,5238, #  496
5239,5240,5241,5242,5243,5244,2297,2031,4616,4310,3692,5245,3071,5246,3598,5247, #  512
4617,3231,3515,5248,4101,4311,4618,3808,4312,4102,5249,4103,4104,3599,5250,5251, #  528
5252,5253,5254,5255,5256,5257,5258,5259,5260,5261,5262,5263,5264,5265,5266,5267, #  544
5268,5269,5270,5271,5272,5273,5274,5275,5276,5277,5278,5279,5280,5281,5282,5283, #  560
5284,5285,5286,5287,5288,5289,5290,5291,5292,5293,5294,5295,5296,5297,5298,5299, #  576
5300,5301,5302,5303,5304,5305,5306,5307,5308,5309,5310,5311,5312,5313,5314,5315, #  592
5316,5317,5318,5319,5320,5321,5322,5323,5324,5325,5326,5327,5328,5329,5330,5331, #  608
5332,5333,5334,5335,5336,5337,5338,5339,5340,5341,5342,5343,5344,5345,5346,5347, #  624
5348,5349,5350,5351,5352,5353,5354,5355,5356,5357,5358,5359,5360,5361,5362,5363, #  640
5364,5365,5366,5367,5368,5369,5370,5371,5372,5373,5374,5375,5376,5377,5378,5379, #  656
5380,5381, 363, 642,2787,2878,2788,2789,2316,3232,2317,3434,2011, 165,1942,3930, #  672
3931,3932,3933,5382,4619,5383,4620,5384,5385,5386,5387,5388,5389,5390,5391,5392, #  688
5393,5394,5395,5396,5397,5398,5399,5400,5401,5402,5403,5404,5405,5406,5407,5408, #  704
5409,5410,5411,5412,5413,5414,5415,5416,5417,5418,5419,5420,5421,5422,5423,5424, #  720
5425,5426,5427,5428,5429,5430,5431,5432,5433,5434,5435,5436,5437,5438,5439,5440, #  736
5441,5442,5443,5444,5445,5446,5447,5448,5449,5450,5451,5452,5453,5454,5455,5456, #  752
5457,5458,5459,5460,5461,5462,5463,5464,5465,5466,5467,5468,5469,5470,5471,5472, #  768
5473,5474,5475,5476,5477,5478,5479,5480,5481,5482,5483,5484,5485,5486,5487,5488, #  784
5489,5490,5491,5492,5493,5494,5495,5496,5497,5498,5499,5500,5501,5502,5503,5504, #  800
5505,5506,5507,5508,5509,5510,5511,5512,5513,5514,5515,5516,5517,5518,5519,5520, #  816
5521,5522,5523,5524,5525,5526,5527,5528,5529,5530,5531,5532,5533,5534,5535,5536, #  832
5537,5538,5539,5540,5541,5542,5543,5544,5545,5546,5547,5548,5549,5550,5551,5552, #  848
5553,5554,5555,5556,5557,5558,5559,5560,5561,5562,5563,5564,5565,5566,5567,5568, #  864
5569,5570,5571,5572,5573,5574,5575,5576,5577,5578,5579,5580,5581,5582,5583,5584, #  880
5585,5586,5587,5588,5589,5590,5591,5592,5593,5594,5595,5596,5597,5598,5599,5600, #  896
5601,5602,5603,5604,5605,5606,5607,5608,5609,5610,5611,5612,5613,5614,5615,5616, #  912
5617,5618,5619,5620,5621,5622,5623,5624,5625,5626,5627,5628,5629,5630,5631,5632, #  928
5633,5634,5635,5636,5637,5638,5639,5640,5641,5642,5643,5644,5645,5646,5647,5648, #  944
5649,5650,5651,5652,5653,5654,5655,5656,5657,5658,5659,5660,5661,5662,5663,5664, #  960
5665,5666,5667,5668,5669,5670,5671,5672,5673,5674,5675,5676,5677,5678,5679,5680, #  976
5681,5682,5683,5684,5685,5686,5687,5688,5689,5690,5691,5692,5693,5694,5695,5696, #  992
5697,5698,5699,5700,5701,5702,5703,5704,5705,5706,5707,5708,5709,5710,5711,5712, # 1008
5713,5714,5715,5716,5717,5718,5719,5720,5721,5722,5723,5724,5725,5726,5727,5728, # 1024
5729,5730,5731,5732,5733,5734,5735,5736,5737,5738,5739,5740,5741,5742,5743,5744, # 1040
5745,5746,5747,5748,5749,5750,5751,5752,5753,5754,5755,5756,5757,5758,5759,5760, # 1056
5761,5762,5763,5764,5765,5766,5767,5768,5769,5770,5771,5772,5773,5774,5775,5776, # 1072
5777,5778,5779,5780,5781,5782,5783,5784,5785,5786,5787,5788,5789,5790,5791,5792, # 1088
5793,5794,5795,5796,5797,5798,5799,5800,5801,5802,5803,5804,5805,5806,5807,5808, # 1104
5809,5810,5811,5812,5813,5814,5815,5816,5817,5818,5819,5820,5821,5822,5823,5824, # 1120
5825,5826,5827,5828,5829,5830,5831,5832,5833,5834,5835,5836,5837,5838,5839,5840, # 1136
5841,5842,5843,5844,5845,5846,5847,5848,5849,5850,5851,5852,5853,5854,5855,5856, # 1152
5857,5858,5859,5860,5861,5862,5863,5864,5865,5866,5867,5868,5869,5870,5871,5872, # 1168
5873,5874,5875,5876,5877,5878,5879,5880,5881,5882,5883,5884,5885,5886,5887,5888, # 1184
5889,5890,5891,5892,5893,5894,5895,5896,5897,5898,5899,5900,5901,5902,5903,5904, # 1200
5905,5906,5907,5908,5909,5910,5911,5912,5913,5914,5915,5916,5917,5918,5919,5920, # 1216
5921,5922,5923,5924,5925,5926,5927,5928,5929,5930,5931,5932,5933,5934,5935,5936, # 1232
5937,5938,5939,5940,5941,5942,5943,5944,5945,5946,5947,5948,5949,5950,5951,5952, # 1248
5953,5954,5955,5956,5957,5958,5959,5960,5961,5962,5963,5964,5965,5966,5967,5968, # 1264
5969,5970,5971,5972,5973,5974,5975,5976,5977,5978,5979,5980,5981,5982,5983,5984, # 1280
5985,5986,5987,5988,5989,5990,5991,5992,5993,5994,5995,5996,5997,5998,5999,6000, # 1296
6001,6002,6003,6004,6005,6006,6007,6008,6009,6010,6011,6012,6013,6014,6015,6016, # 1312
6017,6018,6019,6020,6021,6022,6023,6024,6025,6026,6027,6028,6029,6030,6031,6032, # 1328
6033,6034,6035,6036,6037,6038,6039,6040,6041,6042,6043,6044,6045,6046,6047,6048, # 1344
6049,6050,6051,6052,6053,6054,6055,6056,6057,6058,6059,6060,6061,6062,6063,6064, # 1360
6065,6066,6067,6068,6069,6070,6071,6072,6073,6074,6075,6076,6077,6078,6079,6080, # 1376
6081,6082,6083,6084,6085,6086,6087,6088,6089,6090,6091,6092,6093,6094,6095,6096, # 1392
6097,6098,6099,6100,6101,6102,6103,6104,6105,6106,6107,6108,6109,6110,6111,6112, # 1408
6113,6114,2044,2060,4621, 997,1235, 473,1186,4622, 920,3378,6115,6116, 379,1108, # 1424
4313,2657,2735,3934,6117,3809, 636,3233, 573,1026,3693,3435,2974,3300,2298,4105, # 1440
 854,2937,2463, 393,2581,2417, 539, 752,1280,2750,2480, 140,1161, 440, 708,1569, # 1456
 665,2497,1746,1291,1523,3000, 164,1603, 847,1331, 537,1997, 486, 508,1693,2418, # 1472
1970,2227, 878,1220, 299,1030, 969, 652,2751, 624,1137,3301,2619,  65,3302,2045, # 1488
1761,1859,3120,1930,3694,3516, 663,1767, 852, 835,3695, 269, 767,2826,2339,1305, # 1504
 896,1150, 770,1616,6118, 506,1502,2075,1012,2519, 775,2520,2975,2340,2938,4314, # 1520
3028,2086,1224,1943,2286,6119,3072,4315,2240,1273,1987,3935,1557, 175, 597, 985, # 1536
3517,2419,2521,1416,3029, 585, 938,1931,1007,1052,1932,1685,6120,3379,4316,4623, # 1552
 804, 599,3121,1333,2128,2539,1159,1554,2032,3810, 687,2033,2904, 952, 675,1467, # 1568
3436,6121,2241,1096,1786,2440,1543,1924, 980,1813,2228, 781,2692,1879, 728,1918, # 1584
3696,4624, 548,1950,4625,1809,1088,1356,3303,2522,1944, 502, 972, 373, 513,2827, # 1600
 586,2377,2391,1003,1976,1631,6122,2464,1084, 648,1776,4626,2141, 324, 962,2012, # 1616
2177,2076,1384, 742,2178,1448,1173,1810, 222, 102, 301, 445, 125,2420, 662,2498, # 1632
 277, 200,1476,1165,1068, 224,2562,1378,1446, 450,1880, 659, 791, 582,4627,2939, # 1648
3936,1516,1274, 555,2099,3697,1020,1389,1526,3380,1762,1723,1787,2229, 412,2114, # 1664
1900,2392,3518, 512,2597, 427,1925,2341,3122,1653,1686,2465,2499, 697, 330, 273, # 1680
 380,2162, 951, 832, 780, 991,1301,3073, 965,2270,3519, 668,2523,2636,1286, 535, # 1696
1407, 518, 671, 957,2658,2378, 267, 611,2197,3030,6123, 248,2299, 967,1799,2356, # 1712
 850,1418,3437,1876,1256,1480,2828,1718,6124,6125,1755,1664,2405,6126,4628,2879, # 1728
2829, 499,2179, 676,4629, 557,2329,2214,2090, 325,3234, 464, 811,3001, 992,2342, # 1744
2481,1232,1469, 303,2242, 466,1070,2163, 603,1777,2091,4630,2752,4631,2714, 322, # 1760
2659,1964,1768, 481,2188,1463,2330,2857,3600,2092,3031,2421,4632,2318,2070,1849, # 1776
2598,4633,1302,2254,1668,1701,2422,3811,2905,3032,3123,2046,4106,1763,1694,4634, # 1792
1604, 943,1724,1454, 917, 868,2215,1169,2940, 552,1145,1800,1228,1823,1955, 316, # 1808
1080,2510, 361,1807,2830,4107,2660,3381,1346,1423,1134,4108,6127, 541,1263,1229, # 1824
1148,2540, 545, 465,1833,2880,3438,1901,3074,2482, 816,3937, 713,1788,2500, 122, # 1840
1575, 195,1451,2501,1111,6128, 859, 374,1225,2243,2483,4317, 390,1033,3439,3075, # 1856
2524,1687, 266, 793,1440,2599, 946, 779, 802, 507, 897,1081, 528,2189,1292, 711, # 1872
1866,1725,1167,1640, 753, 398,2661,1053, 246, 348,4318, 137,1024,3440,1600,2077, # 1888
2129, 825,4319, 698, 238, 521, 187,2300,1157,2423,1641,1605,1464,1610,1097,2541, # 1904
1260,1436, 759,2255,1814,2150, 705,3235, 409,2563,3304, 561,3033,2005,2564, 726, # 1920
1956,2343,3698,4109, 949,3812,3813,3520,1669, 653,1379,2525, 881,2198, 632,2256, # 1936
1027, 778,1074, 733,1957, 514,1481,2466, 554,2180, 702,3938,1606,1017,1398,6129, # 1952
1380,3521, 921, 993,1313, 594, 449,1489,1617,1166, 768,1426,1360, 495,1794,3601, # 1968
1177,3602,1170,4320,2344, 476, 425,3167,4635,3168,1424, 401,2662,1171,3382,1998, # 1984
1089,4110, 477,3169, 474,6130,1909, 596,2831,1842, 494, 693,1051,1028,1207,3076, # 2000
 606,2115, 727,2790,1473,1115, 743,3522, 630, 805,1532,4321,2021, 366,1057, 838, # 2016
 684,1114,2142,4322,2050,1492,1892,1808,2271,3814,2424,1971,1447,1373,3305,1090, # 2032
1536,3939,3523,3306,1455,2199, 336, 369,2331,1035, 584,2393, 902, 718,2600,6131, # 2048
2753, 463,2151,1149,1611,2467, 715,1308,3124,1268, 343,1413,3236,1517,1347,2663, # 2064
2093,3940,2022,1131,1553,2100,2941,1427,3441,2942,1323,2484,6132,1980, 872,2368, # 2080
2441,2943, 320,2369,2116,1082, 679,1933,3941,2791,3815, 625,1143,2023, 422,2200, # 2096
3816,6133, 730,1695, 356,2257,1626,2301,2858,2637,1627,1778, 937, 883,2906,2693, # 2112
3002,1769,1086, 400,1063,1325,3307,2792,4111,3077, 456,2345,1046, 747,6134,1524, # 2128
 884,1094,3383,1474,2164,1059, 974,1688,2181,2258,1047, 345,1665,1187, 358, 875, # 2144
3170, 305, 660,3524,2190,1334,1135,3171,1540,1649,2542,1527, 927, 968,2793, 885, # 2160
1972,1850, 482, 500,2638,1218,1109,1085,2543,1654,2034, 876,  78,2287,1482,1277, # 2176
 861,1675,1083,1779, 724,2754, 454, 397,1132,1612,2332, 893, 672,1237, 257,2259, # 2192
2370, 135,3384, 337,2244, 547, 352, 340, 709,2485,1400, 788,1138,2511, 540, 772, # 2208
1682,2260,2272,2544,2013,1843,1902,4636,1999,1562,2288,4637,2201,1403,1533, 407, # 2224
 576,3308,1254,2071, 978,3385, 170, 136,1201,3125,2664,3172,2394, 213, 912, 873, # 2240
3603,1713,2202, 699,3604,3699, 813,3442, 493, 531,1054, 468,2907,1483, 304, 281, # 2256
4112,1726,1252,2094, 339,2319,2130,2639, 756,1563,2944, 748, 571,2976,1588,2425, # 2272
2715,1851,1460,2426,1528,1392,1973,3237, 288,3309, 685,3386, 296, 892,2716,2216, # 2288
1570,2245, 722,1747,2217, 905,3238,1103,6135,1893,1441,1965, 251,1805,2371,3700, # 2304
2601,1919,1078,  75,2182,1509,1592,1270,2640,4638,2152,6136,3310,3817, 524, 706, # 2320
1075, 292,3818,1756,2602, 317,  98,3173,3605,3525,1844,2218,3819,2502, 814, 567, # 2336
 385,2908,1534,6137, 534,1642,3239, 797,6138,1670,1529, 953,4323, 188,1071, 538, # 2352
 178, 729,3240,2109,1226,1374,2000,2357,2977, 731,2468,1116,2014,2051,6139,1261, # 2368
1593, 803,2859,2736,3443, 556, 682, 823,1541,6140,1369,2289,1706,2794, 845, 462, # 2384
2603,2665,1361, 387, 162,2358,1740, 739,1770,1720,1304,1401,3241,1049, 627,1571, # 2400
2427,3526,1877,3942,1852,1500, 431,1910,1503, 677, 297,2795, 286,1433,1038,1198, # 2416
2290,1133,1596,4113,4639,2469,1510,1484,3943,6141,2442, 108, 712,4640,2372, 866, # 2432
3701,2755,3242,1348, 834,1945,1408,3527,2395,3243,1811, 824, 994,1179,2110,1548, # 2448
1453, 790,3003, 690,4324,4325,2832,2909,3820,1860,3821, 225,1748, 310, 346,1780, # 2464
2470, 821,1993,2717,2796, 828, 877,3528,2860,2471,1702,2165,2910,2486,1789, 453, # 2480
 359,2291,1676,  73,1164,1461,1127,3311, 421, 604, 314,1037, 589, 116,2487, 737, # 2496
 837,1180, 111, 244, 735,6142,2261,1861,1362, 986, 523, 418, 581,2666,3822, 103, # 2512
 855, 503,1414,1867,2488,1091, 657,1597, 979, 605,1316,4641,1021,2443,2078,2001, # 2528
1209,  96, 587,2166,1032, 260,1072,2153, 173,  94, 226,3244, 819,2006,4642,4114, # 2544
2203, 231,1744, 782,  97,2667, 786,3387, 887, 391, 442,2219,4326,1425,6143,2694, # 2560
 633,1544,1202, 483,2015, 592,2052,1958,2472,1655, 419, 129,4327,3444,3312,1714, # 2576
1257,3078,4328,1518,1098, 865,1310,1019,1885,1512,1734, 469,2444, 148, 773, 436, # 2592
1815,1868,1128,1055,4329,1245,2756,3445,2154,1934,1039,4643, 579,1238, 932,2320, # 2608
 353, 205, 801, 115,2428, 944,2321,1881, 399,2565,1211, 678, 766,3944, 335,2101, # 2624
1459,1781,1402,3945,2737,2131,1010, 844, 981,1326,1013, 550,1816,1545,2620,1335, # 2640
1008, 371,2881, 936,1419,1613,3529,1456,1395,2273,1834,2604,1317,2738,2503, 416, # 2656
1643,4330, 806,1126, 229, 591,3946,1314,1981,1576,1837,1666, 347,1790, 977,3313, # 2672
 764,2861,1853, 688,2429,1920,1462,  77, 595, 415,2002,3034, 798,1192,4115,6144, # 2688
2978,4331,3035,2695,2582,2072,2566, 430,2430,1727, 842,1396,3947,3702, 613, 377, # 2704
 278, 236,1417,3388,3314,3174, 757,1869, 107,3530,6145,1194, 623,2262, 207,1253, # 2720
2167,3446,3948, 492,1117,1935, 536,1838,2757,1246,4332, 696,2095,2406,1393,1572, # 2736
3175,1782, 583, 190, 253,1390,2230, 830,3126,3389, 934,3245,1703,1749,2979,1870, # 2752
2545,1656,2204, 869,2346,4116,3176,1817, 496,1764,4644, 942,1504, 404,1903,1122, # 2768
1580,3606,2945,1022, 515, 372,1735, 955,2431,3036,6146,2797,1110,2302,2798, 617, # 2784
6147, 441, 762,1771,3447,3607,3608,1904, 840,3037,  86, 939,1385, 572,1370,2445, # 2800
1336, 114,3703, 898, 294, 203,3315, 703,1583,2274, 429, 961,4333,1854,1951,3390, # 2816
2373,3704,4334,1318,1381, 966,1911,2322,1006,1155, 309, 989, 458,2718,1795,1372, # 2832
1203, 252,1689,1363,3177, 517,1936, 168,1490, 562, 193,3823,1042,4117,1835, 551, # 2848
 470,4645, 395, 489,3448,1871,1465,2583,2641, 417,1493, 279,1295, 511,1236,1119, # 2864
  72,1231,1982,1812,3004, 871,1564, 984,3449,1667,2696,2096,4646,2347,2833,1673, # 2880
3609, 695,3246,2668, 807,1183,4647, 890, 388,2333,1801,1457,2911,1765,1477,1031, # 2896
3316,3317,1278,3391,2799,2292,2526, 163,3450,4335,2669,1404,1802,6148,2323,2407, # 2912
1584,1728,1494,1824,1269, 298, 909,3318,1034,1632, 375, 776,1683,2061, 291, 210, # 2928
1123, 809,1249,1002,2642,3038, 206,1011,2132, 144, 975, 882,1565, 342, 667, 754, # 2944
1442,2143,1299,2303,2062, 447, 626,2205,1221,2739,2912,1144,1214,2206,2584, 760, # 2960
1715, 614, 950,1281,2670,2621, 810, 577,1287,2546,4648, 242,2168, 250,2643, 691, # 2976
 123,2644, 647, 313,1029, 689,1357,2946,1650, 216, 771,1339,1306, 808,2063, 549, # 2992
 913,1371,2913,2914,6149,1466,1092,1174,1196,1311,2605,2396,1783,1796,3079, 406, # 3008
2671,2117,3949,4649, 487,1825,2220,6150,2915, 448,2348,1073,6151,2397,1707, 130, # 3024
 900,1598, 329, 176,1959,2527,1620,6152,2275,4336,3319,1983,2191,3705,3610,2155, # 3040
3706,1912,1513,1614,6153,1988, 646, 392,2304,1589,3320,3039,1826,1239,1352,1340, # 3056
2916, 505,2567,1709,1437,2408,2547, 906,6154,2672, 384,1458,1594,1100,1329, 710, # 3072
 423,3531,2064,2231,2622,1989,2673,1087,1882, 333, 841,3005,1296,2882,2379, 580, # 3088
1937,1827,1293,2585, 601, 574, 249,1772,4118,2079,1120, 645, 901,1176,1690, 795, # 3104
2207, 478,1434, 516,1190,1530, 761,2080, 930,1264, 355, 435,1552, 644,1791, 987, # 3120
 220,1364,1163,1121,1538, 306,2169,1327,1222, 546,2645, 218, 241, 610,1704,3321, # 3136
1984,1839,1966,2528, 451,6155,2586,3707,2568, 907,3178, 254,2947, 186,1845,4650, # 3152
 745, 432,1757, 428,1633, 888,2246,2221,2489,3611,2118,1258,1265, 956,3127,1784, # 3168
4337,2490, 319, 510, 119, 457,3612, 274,2035,2007,4651,1409,3128, 970,2758, 590, # 3184
2800, 661,2247,4652,2008,3950,1420,1549,3080,3322,3951,1651,1375,2111, 485,2491, # 3200
1429,1156,6156,2548,2183,1495, 831,1840,2529,2446, 501,1657, 307,1894,3247,1341, # 3216
 666, 899,2156,1539,2549,1559, 886, 349,2208,3081,2305,1736,3824,2170,2759,1014, # 3232
1913,1386, 542,1397,2948, 490, 368, 716, 362, 159, 282,2569,1129,1658,1288,1750, # 3248
2674, 276, 649,2016, 751,1496, 658,1818,1284,1862,2209,2087,2512,3451, 622,2834, # 3264
 376, 117,1060,2053,1208,1721,1101,1443, 247,1250,3179,1792,3952,2760,2398,3953, # 3280
6157,2144,3708, 446,2432,1151,2570,3452,2447,2761,2835,1210,2448,3082, 424,2222, # 3296
1251,2449,2119,2836, 504,1581,4338, 602, 817, 857,3825,2349,2306, 357,3826,1470, # 3312
1883,2883, 255, 958, 929,2917,3248, 302,4653,1050,1271,1751,2307,1952,1430,2697, # 3328
2719,2359, 354,3180, 777, 158,2036,4339,1659,4340,4654,2308,2949,2248,1146,2232, # 3344
3532,2720,1696,2623,3827,6158,3129,1550,2698,1485,1297,1428, 637, 931,2721,2145, # 3360
 914,2550,2587,  81,2450, 612, 827,2646,1242,4655,1118,2884, 472,1855,3181,3533, # 3376
3534, 569,1353,2699,1244,1758,2588,4119,2009,2762,2171,3709,1312,1531,6159,1152, # 3392
1938, 134,1830, 471,3710,2276,1112,1535,3323,3453,3535, 982,1337,2950, 488, 826, # 3408
 674,1058,1628,4120,2017, 522,2399, 211, 568,1367,3454, 350, 293,1872,1139,3249, # 3424
1399,1946,3006,1300,2360,3324, 588, 736,6160,2606, 744, 669,3536,3828,6161,1358, # 3440
 199, 723, 848, 933, 851,1939,1505,1514,1338,1618,1831,4656,1634,3613, 443,2740, # 3456
3829, 717,1947, 491,1914,6162,2551,1542,4121,1025,6163,1099,1223, 198,3040,2722, # 3472
 370, 410,1905,2589, 998,1248,3182,2380, 519,1449,4122,1710, 947, 928,1153,4341, # 3488
2277, 344,2624,1511, 615, 105, 161,1212,1076,1960,3130,2054,1926,1175,1906,2473, # 3504
 414,1873,2801,6164,2309, 315,1319,3325, 318,2018,2146,2157, 963, 631, 223,4342, # 3520
4343,2675, 479,3711,1197,2625,3712,2676,2361,6165,4344,4123,6166,2451,3183,1886, # 3536
2184,1674,1330,1711,1635,1506, 799, 219,3250,3083,3954,1677,3713,3326,2081,3614, # 3552
1652,2073,4657,1147,3041,1752, 643,1961, 147,1974,3955,6167,1716,2037, 918,3007, # 3568
1994, 120,1537, 118, 609,3184,4345, 740,3455,1219, 332,1615,3830,6168,1621,2980, # 3584
1582, 783, 212, 553,2350,3714,1349,2433,2082,4124, 889,6169,2310,1275,1410, 973, # 3600
 166,1320,3456,1797,1215,3185,2885,1846,2590,2763,4658, 629, 822,3008, 763, 940, # 3616
1990,2862, 439,2409,1566,1240,1622, 926,1282,1907,2764, 654,2210,1607, 327,1130, # 3632
3956,1678,1623,6170,2434,2192, 686, 608,3831,3715, 903,3957,3042,6171,2741,1522, # 3648
1915,1105,1555,2552,1359, 323,3251,4346,3457, 738,1354,2553,2311,2334,1828,2003, # 3664
3832,1753,2351,1227,6172,1887,4125,1478,6173,2410,1874,1712,1847, 520,1204,2607, # 3680
 264,4659, 836,2677,2102, 600,4660,3833,2278,3084,6174,4347,3615,1342, 640, 532, # 3696
 543,2608,1888,2400,2591,1009,4348,1497, 341,1737,3616,2723,1394, 529,3252,1321, # 3712
 983,4661,1515,2120, 971,2592, 924, 287,1662,3186,4349,2700,4350,1519, 908,1948, # 3728
2452, 156, 796,1629,1486,2223,2055, 694,4126,1259,1036,3392,1213,2249,2742,1889, # 3744
1230,3958,1015, 910, 408, 559,3617,4662, 746, 725, 935,4663,3959,3009,1289, 563, # 3760
 867,4664,3960,1567,2981,2038,2626, 988,2263,2381,4351, 143,2374, 704,1895,6175, # 3776
1188,3716,2088, 673,3085,2362,4352, 484,1608,1921,2765,2918, 215, 904,3618,3537, # 3792
 894, 509, 976,3043,2701,3961,4353,2837,2982, 498,6176,6177,1102,3538,1332,3393, # 3808
1487,1636,1637, 233, 245,3962, 383, 650, 995,3044, 460,1520,1206,2352, 749,3327, # 3824
 530, 700, 389,1438,1560,1773,3963,2264, 719,2951,2724,3834, 870,1832,1644,1000, # 3840
 839,2474,3717, 197,1630,3394, 365,2886,3964,1285,2133, 734, 922, 818,1106, 732, # 3856
 480,2083,1774,3458, 923,2279,1350, 221,3086,  85,2233,2234,3835,1585,3010,2147, # 3872
1387,1705,2382,1619,2475, 133, 239,2802,1991,1016,2084,2383, 411,2838,1113, 651, # 3888
1985,1160,3328, 990,1863,3087,1048,1276,2647, 265,2627,1599,3253,2056, 150, 638, # 3904
2019, 656, 853, 326,1479, 680,1439,4354,1001,1759, 413,3459,3395,2492,1431, 459, # 3920
4355,1125,3329,2265,1953,1450,2065,2863, 849, 351,2678,3131,3254,3255,1104,1577, # 3936
 227,1351,1645,2453,2193,1421,2887, 812,2121, 634,  95,2435, 201,2312,4665,1646, # 3952
1671,2743,1601,2554,2702,2648,2280,1315,1366,2089,3132,1573,3718,3965,1729,1189, # 3968
 328,2679,1077,1940,1136, 558,1283, 964,1195, 621,2074,1199,1743,3460,3619,1896, # 3984
1916,1890,3836,2952,1154,2112,1064, 862, 378,3011,2066,2113,2803,1568,2839,6178, # 4000
3088,2919,1941,1660,2004,1992,2194, 142, 707,1590,1708,1624,1922,1023,1836,1233, # 4016
1004,2313, 789, 741,3620,6179,1609,2411,1200,4127,3719,3720,4666,2057,3721, 593, # 4032
2840, 367,2920,1878,6180,3461,1521, 628,1168, 692,2211,2649, 300, 720,2067,2571, # 4048
2953,3396, 959,2504,3966,3539,3462,1977, 701,6181, 954,1043, 800, 681, 183,3722, # 4064
1803,1730,3540,4128,2103, 815,2314, 174, 467, 230,2454,1093,2134, 755,3541,3397, # 4080
1141,1162,6182,1738,2039, 270,3256,2513,1005,1647,2185,3837, 858,1679,1897,1719, # 4096
2954,2324,1806, 402, 670, 167,4129,1498,2158,2104, 750,6183, 915, 189,1680,1551, # 4112
 455,4356,1501,2455, 405,1095,2955, 338,1586,1266,1819, 570, 641,1324, 237,1556, # 4128
2650,1388,3723,6184,1368,2384,1343,1978,3089,2436, 879,3724, 792,1191, 758,3012, # 4144
1411,2135,1322,4357, 240,4667,1848,3725,1574,6185, 420,3045,1546,1391, 714,4358, # 4160
1967, 941,1864, 863, 664, 426, 560,1731,2680,1785,2864,1949,2363, 403,3330,1415, # 4176
1279,2136,1697,2335, 204, 721,2097,3838,  90,6186,2085,2505, 191,3967, 124,2148, # 4192
1376,1798,1178,1107,1898,1405, 860,4359,1243,1272,2375,2983,1558,2456,1638, 113, # 4208
3621, 578,1923,2609, 880, 386,4130, 784,2186,2266,1422,2956,2172,1722, 497, 263, # 4224
2514,1267,2412,2610, 177,2703,3542, 774,1927,1344, 616,1432,1595,1018, 172,4360, # 4240
2325, 911,4361, 438,1468,3622, 794,3968,2024,2173,1681,1829,2957, 945, 895,3090, # 4256
 575,2212,2476, 475,2401,2681, 785,2744,1745,2293,2555,1975,3133,2865, 394,4668, # 4272
3839, 635,4131, 639, 202,1507,2195,2766,1345,1435,2572,3726,1908,1184,1181,2457, # 4288
3727,3134,4362, 843,2611, 437, 916,4669, 234, 769,1884,3046,3047,3623, 833,6187, # 4304
1639,2250,2402,1355,1185,2010,2047, 999, 525,1732,1290,1488,2612, 948,1578,3728, # 4320
2413,2477,1216,2725,2159, 334,3840,1328,3624,2921,1525,4132, 564,1056, 891,4363, # 4336
1444,1698,2385,2251,3729,1365,2281,2235,1717,6188, 864,3841,2515, 444, 527,2767, # 4352
2922,3625, 544, 461,6189, 566, 209,2437,3398,2098,1065,2068,3331,3626,3257,2137, # 4368  #last 512
#Everything below is of no interest for detection purpose
2138,2122,3730,2888,1995,1820,1044,6190,6191,6192,6193,6194,6195,6196,6197,6198, # 4384
6199,6200,6201,6202,6203,6204,6205,4670,6206,6207,6208,6209,6210,6211,6212,6213, # 4400
6214,6215,6216,6217,6218,6219,6220,6221,6222,6223,6224,6225,6226,6227,6228,6229, # 4416
6230,6231,6232,6233,6234,6235,6236,6237,3187,6238,6239,3969,6240,6241,6242,6243, # 4432
6244,4671,6245,6246,4672,6247,6248,4133,6249,6250,4364,6251,2923,2556,2613,4673, # 4448
4365,3970,6252,6253,6254,6255,4674,6256,6257,6258,2768,2353,4366,4675,4676,3188, # 4464
4367,3463,6259,4134,4677,4678,6260,2267,6261,3842,3332,4368,3543,6262,6263,6264, # 4480
3013,1954,1928,4135,4679,6265,6266,2478,3091,6267,4680,4369,6268,6269,1699,6270, # 4496
3544,4136,4681,6271,4137,6272,4370,2804,6273,6274,2593,3971,3972,4682,6275,2236, # 4512
4683,6276,6277,4684,6278,6279,4138,3973,4685,6280,6281,3258,6282,6283,6284,6285, # 4528
3974,4686,2841,3975,6286,6287,3545,6288,6289,4139,4687,4140,6290,4141,6291,4142, # 4544
6292,6293,3333,6294,6295,6296,4371,6297,3399,6298,6299,4372,3976,6300,6301,6302, # 4560
4373,6303,6304,3843,3731,6305,4688,4374,6306,6307,3259,2294,6308,3732,2530,4143, # 4576
6309,4689,6310,6311,6312,3048,6313,6314,4690,3733,2237,6315,6316,2282,3334,6317, # 4592
6318,3844,6319,6320,4691,6321,3400,4692,6322,4693,6323,3049,6324,4375,6325,3977, # 4608
6326,6327,6328,3546,6329,4694,3335,6330,4695,4696,6331,6332,6333,6334,4376,3978, # 4624
6335,4697,3979,4144,6336,3980,4698,6337,6338,6339,6340,6341,4699,4700,4701,6342, # 4640
6343,4702,6344,6345,4703,6346,6347,4704,6348,4705,4706,3135,6349,4707,6350,4708, # 4656
6351,4377,6352,4709,3734,4145,6353,2506,4710,3189,6354,3050,4711,3981,6355,3547, # 4672
3014,4146,4378,3735,2651,3845,3260,3136,2224,1986,6356,3401,6357,4712,2594,3627, # 4688
3137,2573,3736,3982,4713,3628,4714,4715,2682,3629,4716,6358,3630,4379,3631,6359, # 4704
6360,6361,3983,6362,6363,6364,6365,4147,3846,4717,6366,6367,3737,2842,6368,4718, # 4720
2628,6369,3261,6370,2386,6371,6372,3738,3984,4719,3464,4720,3402,6373,2924,3336, # 4736
4148,2866,6374,2805,3262,4380,2704,2069,2531,3138,2806,2984,6375,2769,6376,4721, # 4752
4722,3403,6377,6378,3548,6379,6380,2705,3092,1979,4149,2629,3337,2889,6381,3338, # 4768
4150,2557,3339,4381,6382,3190,3263,3739,6383,4151,4723,4152,2558,2574,3404,3191, # 4784
6384,6385,4153,6386,4724,4382,6387,6388,4383,6389,6390,4154,6391,4725,3985,6392, # 4800
3847,4155,6393,6394,6395,6396,6397,3465,6398,4384,6399,6400,6401,6402,6403,6404, # 4816
4156,6405,6406,6407,6408,2123,6409,6410,2326,3192,4726,6411,6412,6413,6414,4385, # 4832
4157,6415,6416,4158,6417,3093,3848,6418,3986,6419,6420,3849,6421,6422,6423,4159, # 4848
6424,6425,4160,6426,3740,6427,6428,6429,6430,3987,6431,4727,6432,2238,6433,6434, # 4864
4386,3988,6435,6436,3632,6437,6438,2843,6439,6440,6441,6442,3633,6443,2958,6444, # 4880
6445,3466,6446,2364,4387,3850,6447,4388,2959,3340,6448,3851,6449,4728,6450,6451, # 4896
3264,4729,6452,3193,6453,4389,4390,2706,3341,4730,6454,3139,6455,3194,6456,3051, # 4912
2124,3852,1602,4391,4161,3853,1158,3854,4162,3989,4392,3990,4731,4732,4393,2040, # 4928
4163,4394,3265,6457,2807,3467,3855,6458,6459,6460,3991,3468,4733,4734,6461,3140, # 4944
2960,6462,4735,6463,6464,6465,6466,4736,4737,4738,4739,6467,6468,4164,2403,3856, # 4960
6469,6470,2770,2844,6471,4740,6472,6473,6474,6475,6476,6477,6478,3195,6479,4741, # 4976
4395,6480,2867,6481,4742,2808,6482,2493,4165,6483,6484,6485,6486,2295,4743,6487, # 4992
6488,6489,3634,6490,6491,6492,6493,6494,6495,6496,2985,4744,6497,6498,4745,6499, # 5008
6500,2925,3141,4166,6501,6502,4746,6503,6504,4747,6505,6506,6507,2890,6508,6509, # 5024
6510,6511,6512,6513,6514,6515,6516,6517,6518,6519,3469,4167,6520,6521,6522,4748, # 5040
4396,3741,4397,4749,4398,3342,2125,4750,6523,4751,4752,4753,3052,6524,2961,4168, # 5056
6525,4754,6526,4755,4399,2926,4169,6527,3857,6528,4400,4170,6529,4171,6530,6531, # 5072
2595,6532,6533,6534,6535,3635,6536,6537,6538,6539,6540,6541,6542,4756,6543,6544, # 5088
6545,6546,6547,6548,4401,6549,6550,6551,6552,4402,3405,4757,4403,6553,6554,6555, # 5104
4172,3742,6556,6557,6558,3992,3636,6559,6560,3053,2726,6561,3549,4173,3054,4404, # 5120
6562,6563,3993,4405,3266,3550,2809,4406,6564,6565,6566,4758,4759,6567,3743,6568, # 5136
4760,3744,4761,3470,6569,6570,6571,4407,6572,3745,4174,6573,4175,2810,4176,3196, # 5152
4762,6574,4177,6575,6576,2494,2891,3551,6577,6578,3471,6579,4408,6580,3015,3197, # 5168
6581,3343,2532,3994,3858,6582,3094,3406,4409,6583,2892,4178,4763,4410,3016,4411, # 5184
6584,3995,3142,3017,2683,6585,4179,6586,6587,4764,4412,6588,6589,4413,6590,2986, # 5200
6591,2962,3552,6592,2963,3472,6593,6594,4180,4765,6595,6596,2225,3267,4414,6597, # 5216
3407,3637,4766,6598,6599,3198,6600,4415,6601,3859,3199,6602,3473,4767,2811,4416, # 5232
1856,3268,3200,2575,3996,3997,3201,4417,6603,3095,2927,6604,3143,6605,2268,6606, # 5248
3998,3860,3096,2771,6607,6608,3638,2495,4768,6609,3861,6610,3269,2745,4769,4181, # 5264
3553,6611,2845,3270,6612,6613,6614,3862,6615,6616,4770,4771,6617,3474,3999,4418, # 5280
4419,6618,3639,3344,6619,4772,4182,6620,2126,6621,6622,6623,4420,4773,6624,3018, # 5296
6625,4774,3554,6626,4183,2025,3746,6627,4184,2707,6628,4421,4422,3097,1775,4185, # 5312
3555,6629,6630,2868,6631,6632,4423,6633,6634,4424,2414,2533,2928,6635,4186,2387, # 5328
6636,4775,6637,4187,6638,1891,4425,3202,3203,6639,6640,4776,6641,3345,6642,6643, # 5344
3640,6644,3475,3346,3641,4000,6645,3144,6646,3098,2812,4188,3642,3204,6647,3863, # 5360
3476,6648,3864,6649,4426,4001,6650,6651,6652,2576,6653,4189,4777,6654,6655,6656, # 5376
2846,6657,3477,3205,4002,6658,4003,6659,3347,2252,6660,6661,6662,4778,6663,6664, # 5392
6665,6666,6667,6668,6669,4779,4780,2048,6670,3478,3099,6671,3556,3747,4004,6672, # 5408
6673,6674,3145,4005,3748,6675,6676,6677,6678,6679,3408,6680,6681,6682,6683,3206, # 5424
3207,6684,6685,4781,4427,6686,4782,4783,4784,6687,6688,6689,4190,6690,6691,3479, # 5440
6692,2746,6693,4428,6694,6695,6696,6697,6698,6699,4785,6700,6701,3208,2727,6702, # 5456
3146,6703,6704,3409,2196,6705,4429,6706,6707,6708,2534,1996,6709,6710,6711,2747, # 5472
6712,6713,6714,4786,3643,6715,4430,4431,6716,3557,6717,4432,4433,6718,6719,6720, # 5488
6721,3749,6722,4006,4787,6723,6724,3644,4788,4434,6725,6726,4789,2772,6727,6728, # 5504
6729,6730,6731,2708,3865,2813,4435,6732,6733,4790,4791,3480,6734,6735,6736,6737, # 5520
4436,3348,6738,3410,4007,6739,6740,4008,6741,6742,4792,3411,4191,6743,6744,6745, # 5536
6746,6747,3866,6748,3750,6749,6750,6751,6752,6753,6754,6755,3867,6756,4009,6757, # 5552
4793,4794,6758,2814,2987,6759,6760,6761,4437,6762,6763,6764,6765,3645,6766,6767, # 5568
3481,4192,6768,3751,6769,6770,2174,6771,3868,3752,6772,6773,6774,4193,4795,4438, # 5584
3558,4796,4439,6775,4797,6776,6777,4798,6778,4799,3559,4800,6779,6780,6781,3482, # 5600
6782,2893,6783,6784,4194,4801,4010,6785,6786,4440,6787,4011,6788,6789,6790,6791, # 5616
6792,6793,4802,6794,6795,6796,4012,6797,6798,6799,6800,3349,4803,3483,6801,4804, # 5632
4195,6802,4013,6803,6804,4196,6805,4014,4015,6806,2847,3271,2848,6807,3484,6808, # 5648
6809,6810,4441,6811,4442,4197,4443,3272,4805,6812,3412,4016,1579,6813,6814,4017, # 5664
6815,3869,6816,2964,6817,4806,6818,6819,4018,3646,6820,6821,4807,4019,4020,6822, # 5680
6823,3560,6824,6825,4021,4444,6826,4198,6827,6828,4445,6829,6830,4199,4808,6831, # 5696
6832,6833,3870,3019,2458,6834,3753,3413,3350,6835,4809,3871,4810,3561,4446,6836, # 5712
6837,4447,4811,4812,6838,2459,4448,6839,4449,6840,6841,4022,3872,6842,4813,4814, # 5728
6843,6844,4815,4200,4201,4202,6845,4023,6846,6847,4450,3562,3873,6848,6849,4816, # 5744
4817,6850,4451,4818,2139,6851,3563,6852,6853,3351,6854,6855,3352,4024,2709,3414, # 5760
4203,4452,6856,4204,6857,6858,3874,3875,6859,6860,4819,6861,6862,6863,6864,4453, # 5776
3647,6865,6866,4820,6867,6868,6869,6870,4454,6871,2869,6872,6873,4821,6874,3754, # 5792
6875,4822,4205,6876,6877,6878,3648,4206,4455,6879,4823,6880,4824,3876,6881,3055, # 5808
4207,6882,3415,6883,6884,6885,4208,4209,6886,4210,3353,6887,3354,3564,3209,3485, # 5824
2652,6888,2728,6889,3210,3755,6890,4025,4456,6891,4825,6892,6893,6894,6895,4211, # 5840
6896,6897,6898,4826,6899,6900,4212,6901,4827,6902,2773,3565,6903,4828,6904,6905, # 5856
6906,6907,3649,3650,6908,2849,3566,6909,3567,3100,6910,6911,6912,6913,6914,6915, # 5872
4026,6916,3355,4829,3056,4457,3756,6917,3651,6918,4213,3652,2870,6919,4458,6920, # 5888
2438,6921,6922,3757,2774,4830,6923,3356,4831,4832,6924,4833,4459,3653,2507,6925, # 5904
4834,2535,6926,6927,3273,4027,3147,6928,3568,6929,6930,6931,4460,6932,3877,4461, # 5920
2729,3654,6933,6934,6935,6936,2175,4835,2630,4214,4028,4462,4836,4215,6937,3148, # 5936
4216,4463,4837,4838,4217,6938,6939,2850,4839,6940,4464,6941,6942,6943,4840,6944, # 5952
4218,3274,4465,6945,6946,2710,6947,4841,4466,6948,6949,2894,6950,6951,4842,6952, # 5968
4219,3057,2871,6953,6954,6955,6956,4467,6957,2711,6958,6959,6960,3275,3101,4843, # 5984
6961,3357,3569,6962,4844,6963,6964,4468,4845,3570,6965,3102,4846,3758,6966,4847, # 6000
3878,4848,4849,4029,6967,2929,3879,4850,4851,6968,6969,1733,6970,4220,6971,6972, # 6016
6973,6974,6975,6976,4852,6977,6978,6979,6980,6981,6982,3759,6983,6984,6985,3486, # 6032
3487,6986,3488,3416,6987,6988,6989,6990,6991,6992,6993,6994,6995,6996,6997,4853, # 6048
6998,6999,4030,7000,7001,3211,7002,7003,4221,7004,7005,3571,4031,7006,3572,7007, # 6064
2614,4854,2577,7008,7009,2965,3655,3656,4855,2775,3489,3880,4222,4856,3881,4032, # 6080
3882,3657,2730,3490,4857,7010,3149,7011,4469,4858,2496,3491,4859,2283,7012,7013, # 6096
7014,2365,4860,4470,7015,7016,3760,7017,7018,4223,1917,7019,7020,7021,4471,7022, # 6112
2776,4472,7023,7024,7025,7026,4033,7027,3573,4224,4861,4034,4862,7028,7029,1929, # 6128
3883,4035,7030,4473,3058,7031,2536,3761,3884,7032,4036,7033,2966,2895,1968,4474, # 6144
3276,4225,3417,3492,4226,2105,7034,7035,1754,2596,3762,4227,4863,4475,3763,4864, # 6160
3764,2615,2777,3103,3765,3658,3418,4865,2296,3766,2815,7036,7037,7038,3574,2872, # 6176
3277,4476,7039,4037,4477,7040,7041,4038,7042,7043,7044,7045,7046,7047,2537,7048, # 6192
7049,7050,7051,7052,7053,7054,4478,7055,7056,3767,3659,4228,3575,7057,7058,4229, # 6208
7059,7060,7061,3660,7062,3212,7063,3885,4039,2460,7064,7065,7066,7067,7068,7069, # 6224
7070,7071,7072,7073,7074,4866,3768,4867,7075,7076,7077,7078,4868,3358,3278,2653, # 6240
7079,7080,4479,3886,7081,7082,4869,7083,7084,7085,7086,7087,7088,2538,7089,7090, # 6256
7091,4040,3150,3769,4870,4041,2896,3359,4230,2930,7092,3279,7093,2967,4480,3213, # 6272
4481,3661,7094,7095,7096,7097,7098,7099,7100,7101,7102,2461,3770,7103,7104,4231, # 6288
3151,7105,7106,7107,4042,3662,7108,7109,4871,3663,4872,4043,3059,7110,7111,7112, # 6304
3493,2988,7113,4873,7114,7115,7116,3771,4874,7117,7118,4232,4875,7119,3576,2336, # 6320
4876,7120,4233,3419,4044,4877,4878,4482,4483,4879,4484,4234,7121,3772,4880,1045, # 6336
3280,3664,4881,4882,7122,7123,7124,7125,4883,7126,2778,7127,4485,4486,7128,4884, # 6352
3214,3887,7129,7130,3215,7131,4885,4045,7132,7133,4046,7134,7135,7136,7137,7138, # 6368
7139,7140,7141,7142,7143,4235,7144,4886,7145,7146,7147,4887,7148,7149,7150,4487, # 6384
4047,4488,7151,7152,4888,4048,2989,3888,7153,3665,7154,4049,7155,7156,7157,7158, # 6400
7159,7160,2931,4889,4890,4489,7161,2631,3889,4236,2779,7162,7163,4891,7164,3060, # 6416
7165,1672,4892,7166,4893,4237,3281,4894,7167,7168,3666,7169,3494,7170,7171,4050, # 6432
7172,7173,3104,3360,3420,4490,4051,2684,4052,7174,4053,7175,7176,7177,2253,4054, # 6448
7178,7179,4895,7180,3152,3890,3153,4491,3216,7181,7182,7183,2968,4238,4492,4055, # 6464
7184,2990,7185,2479,7186,7187,4493,7188,7189,7190,7191,7192,4896,7193,4897,2969, # 6480
4494,4898,7194,3495,7195,7196,4899,4495,7197,3105,2731,7198,4900,7199,7200,7201, # 6496
4056,7202,3361,7203,7204,4496,4901,4902,7205,4497,7206,7207,2315,4903,7208,4904, # 6512
7209,4905,2851,7210,7211,3577,7212,3578,4906,7213,4057,3667,4907,7214,4058,2354, # 6528
3891,2376,3217,3773,7215,7216,7217,7218,7219,4498,7220,4908,3282,2685,7221,3496, # 6544
4909,2632,3154,4910,7222,2337,7223,4911,7224,7225,7226,4912,4913,3283,4239,4499, # 6560
7227,2816,7228,7229,7230,7231,7232,7233,7234,4914,4500,4501,7235,7236,7237,2686, # 6576
7238,4915,7239,2897,4502,7240,4503,7241,2516,7242,4504,3362,3218,7243,7244,7245, # 6592
4916,7246,7247,4505,3363,7248,7249,7250,7251,3774,4506,7252,7253,4917,7254,7255, # 6608
3284,2991,4918,4919,3219,3892,4920,3106,3497,4921,7256,7257,7258,4922,7259,4923, # 6624
3364,4507,4508,4059,7260,4240,3498,7261,7262,4924,7263,2992,3893,4060,3220,7264, # 6640
7265,7266,7267,7268,7269,4509,3775,7270,2817,7271,4061,4925,4510,3776,7272,4241, # 6656
4511,3285,7273,7274,3499,7275,7276,7277,4062,4512,4926,7278,3107,3894,7279,7280, # 6672
4927,7281,4513,7282,7283,3668,7284,7285,4242,4514,4243,7286,2058,4515,4928,4929, # 6688
4516,7287,3286,4244,7288,4517,7289,7290,7291,3669,7292,7293,4930,4931,4932,2355, # 6704
4933,7294,2633,4518,7295,4245,7296,7297,4519,7298,7299,4520,4521,4934,7300,4246, # 6720
4522,7301,7302,7303,3579,7304,4247,4935,7305,4936,7306,7307,7308,7309,3777,7310, # 6736
4523,7311,7312,7313,4248,3580,7314,4524,3778,4249,7315,3581,7316,3287,7317,3221, # 6752
7318,4937,7319,7320,7321,7322,7323,7324,4938,4939,7325,4525,7326,7327,7328,4063, # 6768
7329,7330,4940,7331,7332,4941,7333,4526,7334,3500,2780,1741,4942,2026,1742,7335, # 6784
7336,3582,4527,2388,7337,7338,7339,4528,7340,4250,4943,7341,7342,7343,4944,7344, # 6800
7345,7346,3020,7347,4945,7348,7349,7350,7351,3895,7352,3896,4064,3897,7353,7354, # 6816
7355,4251,7356,7357,3898,7358,3779,7359,3780,3288,7360,7361,4529,7362,4946,4530, # 6832
2027,7363,3899,4531,4947,3222,3583,7364,4948,7365,7366,7367,7368,4949,3501,4950, # 6848
3781,4951,4532,7369,2517,4952,4252,4953,3155,7370,4954,4955,4253,2518,4533,7371, # 6864
7372,2712,4254,7373,7374,7375,3670,4956,3671,7376,2389,3502,4065,7377,2338,7378, # 6880
7379,7380,7381,3061,7382,4957,7383,7384,7385,7386,4958,4534,7387,7388,2993,7389, # 6896
3062,7390,4959,7391,7392,7393,4960,3108,4961,7394,4535,7395,4962,3421,4536,7396, # 6912
4963,7397,4964,1857,7398,4965,7399,7400,2176,3584,4966,7401,7402,3422,4537,3900, # 6928
3585,7403,3782,7404,2852,7405,7406,7407,4538,3783,2654,3423,4967,4539,7408,3784, # 6944
3586,2853,4540,4541,7409,3901,7410,3902,7411,7412,3785,3109,2327,3903,7413,7414, # 6960
2970,4066,2932,7415,7416,7417,3904,3672,3424,7418,4542,4543,4544,7419,4968,7420, # 6976
7421,4255,7422,7423,7424,7425,7426,4067,7427,3673,3365,4545,7428,3110,2559,3674, # 6992
7429,7430,3156,7431,7432,3503,7433,3425,4546,7434,3063,2873,7435,3223,4969,4547, # 7008
4548,2898,4256,4068,7436,4069,3587,3786,2933,3787,4257,4970,4971,3788,7437,4972, # 7024
3064,7438,4549,7439,7440,7441,7442,7443,4973,3905,7444,2874,7445,7446,7447,7448, # 7040
3021,7449,4550,3906,3588,4974,7450,7451,3789,3675,7452,2578,7453,4070,7454,7455, # 7056
7456,4258,3676,7457,4975,7458,4976,4259,3790,3504,2634,4977,3677,4551,4260,7459, # 7072
7460,7461,7462,3907,4261,4978,7463,7464,7465,7466,4979,4980,7467,7468,2213,4262, # 7088
7469,7470,7471,3678,4981,7472,2439,7473,4263,3224,3289,7474,3908,2415,4982,7475, # 7104
4264,7476,4983,2655,7477,7478,2732,4552,2854,2875,7479,7480,4265,7481,4553,4984, # 7120
7482,7483,4266,7484,3679,3366,3680,2818,2781,2782,3367,3589,4554,3065,7485,4071, # 7136
2899,7486,7487,3157,2462,4072,4555,4073,4985,4986,3111,4267,2687,3368,4556,4074, # 7152
3791,4268,7488,3909,2783,7489,2656,1962,3158,4557,4987,1963,3159,3160,7490,3112, # 7168
4988,4989,3022,4990,4991,3792,2855,7491,7492,2971,4558,7493,7494,4992,7495,7496, # 7184
7497,7498,4993,7499,3426,4559,4994,7500,3681,4560,4269,4270,3910,7501,4075,4995, # 7200
4271,7502,7503,4076,7504,4996,7505,3225,4997,4272,4077,2819,3023,7506,7507,2733, # 7216
4561,7508,4562,7509,3369,3793,7510,3590,2508,7511,7512,4273,3113,2994,2616,7513, # 7232
7514,7515,7516,7517,7518,2820,3911,4078,2748,7519,7520,4563,4998,7521,7522,7523, # 7248
7524,4999,4274,7525,4564,3682,2239,4079,4565,7526,7527,7528,7529,5000,7530,7531, # 7264
5001,4275,3794,7532,7533,7534,3066,5002,4566,3161,7535,7536,4080,7537,3162,7538, # 7280
7539,4567,7540,7541,7542,7543,7544,7545,5003,7546,4568,7547,7548,7549,7550,7551, # 7296
7552,7553,7554,7555,7556,5004,7557,7558,7559,5005,7560,3795,7561,4569,7562,7563, # 7312
7564,2821,3796,4276,4277,4081,7565,2876,7566,5006,7567,7568,2900,7569,3797,3912, # 7328
7570,7571,7572,4278,7573,7574,7575,5007,7576,7577,5008,7578,7579,4279,2934,7580, # 7344
7581,5009,7582,4570,7583,4280,7584,7585,7586,4571,4572,3913,7587,4573,3505,7588, # 7360
5010,7589,7590,7591,7592,3798,4574,7593,7594,5011,7595,4281,7596,7597,7598,4282, # 7376
5012,7599,7600,5013,3163,7601,5014,7602,3914,7603,7604,2734,4575,4576,4577,7605, # 7392
7606,7607,7608,7609,3506,5015,4578,7610,4082,7611,2822,2901,2579,3683,3024,4579, # 7408
3507,7612,4580,7613,3226,3799,5016,7614,7615,7616,7617,7618,7619,7620,2995,3290, # 7424
7621,4083,7622,5017,7623,7624,7625,7626,7627,4581,3915,7628,3291,7629,5018,7630, # 7440
7631,7632,7633,4084,7634,7635,3427,3800,7636,7637,4582,7638,5019,4583,5020,7639, # 7456
3916,7640,3801,5021,4584,4283,7641,7642,3428,3591,2269,7643,2617,7644,4585,3592, # 7472
7645,4586,2902,7646,7647,3227,5022,7648,4587,7649,4284,7650,7651,7652,4588,2284, # 7488
7653,5023,7654,7655,7656,4589,5024,3802,7657,7658,5025,3508,4590,7659,7660,7661, # 7504
1969,5026,7662,7663,3684,1821,2688,7664,2028,2509,4285,7665,2823,1841,7666,2689, # 7520
3114,7667,3917,4085,2160,5027,5028,2972,7668,5029,7669,7670,7671,3593,4086,7672, # 7536
4591,4087,5030,3803,7673,7674,7675,7676,7677,7678,7679,4286,2366,4592,4593,3067, # 7552
2328,7680,7681,4594,3594,3918,2029,4287,7682,5031,3919,3370,4288,4595,2856,7683, # 7568
3509,7684,7685,5032,5033,7686,7687,3804,2784,7688,7689,7690,7691,3371,7692,7693, # 7584
2877,5034,7694,7695,3920,4289,4088,7696,7697,7698,5035,7699,5036,4290,5037,5038, # 7600
5039,7700,7701,7702,5040,5041,3228,7703,1760,7704,5042,3229,4596,2106,4089,7705, # 7616
4597,2824,5043,2107,3372,7706,4291,4090,5044,7707,4091,7708,5045,3025,3805,4598, # 7632
4292,4293,4294,3373,7709,4599,7710,5046,7711,7712,5047,5048,3806,7713,7714,7715, # 7648
5049,7716,7717,7718,7719,4600,5050,7720,7721,7722,5051,7723,4295,3429,7724,7725, # 7664
7726,7727,3921,7728,3292,5052,4092,7729,7730,7731,7732,7733,7734,7735,5053,5054, # 7680
7736,7737,7738,7739,3922,3685,7740,7741,7742,7743,2635,5055,7744,5056,4601,7745, # 7696
7746,2560,7747,7748,7749,7750,3923,7751,7752,7753,7754,7755,4296,2903,7756,7757, # 7712
7758,7759,7760,3924,7761,5057,4297,7762,7763,5058,4298,7764,4093,7765,7766,5059, # 7728
3925,7767,7768,7769,7770,7771,7772,7773,7774,7775,7776,3595,7777,4299,5060,4094, # 7744
7778,3293,5061,7779,7780,4300,7781,7782,4602,7783,3596,7784,7785,3430,2367,7786, # 7760
3164,5062,5063,4301,7787,7788,4095,5064,5065,7789,3374,3115,7790,7791,7792,7793, # 7776
7794,7795,7796,3597,4603,7797,7798,3686,3116,3807,5066,7799,7800,5067,7801,7802, # 7792
4604,4302,5068,4303,4096,7803,7804,3294,7805,7806,5069,4605,2690,7807,3026,7808, # 7808
7809,7810,7811,7812,7813,7814,7815,7816,7817,7818,7819,7820,7821,7822,7823,7824, # 7824
7825,7826,7827,7828,7829,7830,7831,7832,7833,7834,7835,7836,7837,7838,7839,7840, # 7840
7841,7842,7843,7844,7845,7846,7847,7848,7849,7850,7851,7852,7853,7854,7855,7856, # 7856
7857,7858,7859,7860,7861,7862,7863,7864,7865,7866,7867,7868,7869,7870,7871,7872, # 7872
7873,7874,7875,7876,7877,7878,7879,7880,7881,7882,7883,7884,7885,7886,7887,7888, # 7888
7889,7890,7891,7892,7893,7894,7895,7896,7897,7898,7899,7900,7901,7902,7903,7904, # 7904
7905,7906,7907,7908,7909,7910,7911,7912,7913,7914,7915,7916,7917,7918,7919,7920, # 7920
7921,7922,7923,7924,3926,7925,7926,7927,7928,7929,7930,7931,7932,7933,7934,7935, # 7936
7936,7937,7938,7939,7940,7941,7942,7943,7944,7945,7946,7947,7948,7949,7950,7951, # 7952
7952,7953,7954,7955,7956,7957,7958,7959,7960,7961,7962,7963,7964,7965,7966,7967, # 7968
7968,7969,7970,7971,7972,7973,7974,7975,7976,7977,7978,7979,7980,7981,7982,7983, # 7984
7984,7985,7986,7987,7988,7989,7990,7991,7992,7993,7994,7995,7996,7997,7998,7999, # 8000
8000,8001,8002,8003,8004,8005,8006,8007,8008,8009,8010,8011,8012,8013,8014,8015, # 8016
8016,8017,8018,8019,8020,8021,8022,8023,8024,8025,8026,8027,8028,8029,8030,8031, # 8032
8032,8033,8034,8035,8036,8037,8038,8039,8040,8041,8042,8043,8044,8045,8046,8047, # 8048
8048,8049,8050,8051,8052,8053,8054,8055,8056,8057,8058,8059,8060,8061,8062,8063, # 8064
8064,8065,8066,8067,8068,8069,8070,8071,8072,8073,8074,8075,8076,8077,8078,8079, # 8080
8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095, # 8096
8096,8097,8098,8099,8100,8101,8102,8103,8104,8105,8106,8107,8108,8109,8110,8111, # 8112
8112,8113,8114,8115,8116,8117,8118,8119,8120,8121,8122,8123,8124,8125,8126,8127, # 8128
8128,8129,8130,8131,8132,8133,8134,8135,8136,8137,8138,8139,8140,8141,8142,8143, # 8144
8144,8145,8146,8147,8148,8149,8150,8151,8152,8153,8154,8155,8156,8157,8158,8159, # 8160
8160,8161,8162,8163,8164,8165,8166,8167,8168,8169,8170,8171,8172,8173,8174,8175, # 8176
8176,8177,8178,8179,8180,8181,8182,8183,8184,8185,8186,8187,8188,8189,8190,8191, # 8192
8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207, # 8208
8208,8209,8210,8211,8212,8213,8214,8215,8216,8217,8218,8219,8220,8221,8222,8223, # 8224
8224,8225,8226,8227,8228,8229,8230,8231,8232,8233,8234,8235,8236,8237,8238,8239, # 8240
8240,8241,8242,8243,8244,8245,8246,8247,8248,8249,8250,8251,8252,8253,8254,8255, # 8256
8256,8257,8258,8259,8260,8261,8262,8263,8264,8265,8266,8267,8268,8269,8270,8271) # 8272

# flake8: noqa

########NEW FILE########
__FILENAME__ = jpcntx
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .compat import wrap_ord

NUM_OF_CATEGORY = 6
DONT_KNOW = -1
ENOUGH_REL_THRESHOLD = 100
MAX_REL_THRESHOLD = 1000
MINIMUM_DATA_THRESHOLD = 4

# This is hiragana 2-char sequence table, the number in each cell represents its frequency category
jp2CharContext = (
(0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1),
(2,4,0,4,0,3,0,4,0,3,4,4,4,2,4,3,3,4,3,2,3,3,4,2,3,3,3,2,4,1,4,3,3,1,5,4,3,4,3,4,3,5,3,0,3,5,4,2,0,3,1,0,3,3,0,3,3,0,1,1,0,4,3,0,3,3,0,4,0,2,0,3,5,5,5,5,4,0,4,1,0,3,4),
(0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2),
(0,4,0,5,0,5,0,4,0,4,5,4,4,3,5,3,5,1,5,3,4,3,4,4,3,4,3,3,4,3,5,4,4,3,5,5,3,5,5,5,3,5,5,3,4,5,5,3,1,3,2,0,3,4,0,4,2,0,4,2,1,5,3,2,3,5,0,4,0,2,0,5,4,4,5,4,5,0,4,0,0,4,4),
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
(0,3,0,4,0,3,0,3,0,4,5,4,3,3,3,3,4,3,5,4,4,3,5,4,4,3,4,3,4,4,4,4,5,3,4,4,3,4,5,5,4,5,5,1,4,5,4,3,0,3,3,1,3,3,0,4,4,0,3,3,1,5,3,3,3,5,0,4,0,3,0,4,4,3,4,3,3,0,4,1,1,3,4),
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
(0,4,0,3,0,3,0,4,0,3,4,4,3,2,2,1,2,1,3,1,3,3,3,3,3,4,3,1,3,3,5,3,3,0,4,3,0,5,4,3,3,5,4,4,3,4,4,5,0,1,2,0,1,2,0,2,2,0,1,0,0,5,2,2,1,4,0,3,0,1,0,4,4,3,5,4,3,0,2,1,0,4,3),
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
(0,3,0,5,0,4,0,2,1,4,4,2,4,1,4,2,4,2,4,3,3,3,4,3,3,3,3,1,4,2,3,3,3,1,4,4,1,1,1,4,3,3,2,0,2,4,3,2,0,3,3,0,3,1,1,0,0,0,3,3,0,4,2,2,3,4,0,4,0,3,0,4,4,5,3,4,4,0,3,0,0,1,4),
(1,4,0,4,0,4,0,4,0,3,5,4,4,3,4,3,5,4,3,3,4,3,5,4,4,4,4,3,4,2,4,3,3,1,5,4,3,2,4,5,4,5,5,4,4,5,4,4,0,3,2,2,3,3,0,4,3,1,3,2,1,4,3,3,4,5,0,3,0,2,0,4,5,5,4,5,4,0,4,0,0,5,4),
(0,5,0,5,0,4,0,3,0,4,4,3,4,3,3,3,4,0,4,4,4,3,4,3,4,3,3,1,4,2,4,3,4,0,5,4,1,4,5,4,4,5,3,2,4,3,4,3,2,4,1,3,3,3,2,3,2,0,4,3,3,4,3,3,3,4,0,4,0,3,0,4,5,4,4,4,3,0,4,1,0,1,3),
(0,3,1,4,0,3,0,2,0,3,4,4,3,1,4,2,3,3,4,3,4,3,4,3,4,4,3,2,3,1,5,4,4,1,4,4,3,5,4,4,3,5,5,4,3,4,4,3,1,2,3,1,2,2,0,3,2,0,3,1,0,5,3,3,3,4,3,3,3,3,4,4,4,4,5,4,2,0,3,3,2,4,3),
(0,2,0,3,0,1,0,1,0,0,3,2,0,0,2,0,1,0,2,1,3,3,3,1,2,3,1,0,1,0,4,2,1,1,3,3,0,4,3,3,1,4,3,3,0,3,3,2,0,0,0,0,1,0,0,2,0,0,0,0,0,4,1,0,2,3,2,2,2,1,3,3,3,4,4,3,2,0,3,1,0,3,3),
(0,4,0,4,0,3,0,3,0,4,4,4,3,3,3,3,3,3,4,3,4,2,4,3,4,3,3,2,4,3,4,5,4,1,4,5,3,5,4,5,3,5,4,0,3,5,5,3,1,3,3,2,2,3,0,3,4,1,3,3,2,4,3,3,3,4,0,4,0,3,0,4,5,4,4,5,3,0,4,1,0,3,4),
(0,2,0,3,0,3,0,0,0,2,2,2,1,0,1,0,0,0,3,0,3,0,3,0,1,3,1,0,3,1,3,3,3,1,3,3,3,0,1,3,1,3,4,0,0,3,1,1,0,3,2,0,0,0,0,1,3,0,1,0,0,3,3,2,0,3,0,0,0,0,0,3,4,3,4,3,3,0,3,0,0,2,3),
(2,3,0,3,0,2,0,1,0,3,3,4,3,1,3,1,1,1,3,1,4,3,4,3,3,3,0,0,3,1,5,4,3,1,4,3,2,5,5,4,4,4,4,3,3,4,4,4,0,2,1,1,3,2,0,1,2,0,0,1,0,4,1,3,3,3,0,3,0,1,0,4,4,4,5,5,3,0,2,0,0,4,4),
(0,2,0,1,0,3,1,3,0,2,3,3,3,0,3,1,0,0,3,0,3,2,3,1,3,2,1,1,0,0,4,2,1,0,2,3,1,4,3,2,0,4,4,3,1,3,1,3,0,1,0,0,1,0,0,0,1,0,0,0,0,4,1,1,1,2,0,3,0,0,0,3,4,2,4,3,2,0,1,0,0,3,3),
(0,1,0,4,0,5,0,4,0,2,4,4,2,3,3,2,3,3,5,3,3,3,4,3,4,2,3,0,4,3,3,3,4,1,4,3,2,1,5,5,3,4,5,1,3,5,4,2,0,3,3,0,1,3,0,4,2,0,1,3,1,4,3,3,3,3,0,3,0,1,0,3,4,4,4,5,5,0,3,0,1,4,5),
(0,2,0,3,0,3,0,0,0,2,3,1,3,0,4,0,1,1,3,0,3,4,3,2,3,1,0,3,3,2,3,1,3,0,2,3,0,2,1,4,1,2,2,0,0,3,3,0,0,2,0,0,0,1,0,0,0,0,2,2,0,3,2,1,3,3,0,2,0,2,0,0,3,3,1,2,4,0,3,0,2,2,3),
(2,4,0,5,0,4,0,4,0,2,4,4,4,3,4,3,3,3,1,2,4,3,4,3,4,4,5,0,3,3,3,3,2,0,4,3,1,4,3,4,1,4,4,3,3,4,4,3,1,2,3,0,4,2,0,4,1,0,3,3,0,4,3,3,3,4,0,4,0,2,0,3,5,3,4,5,2,0,3,0,0,4,5),
(0,3,0,4,0,1,0,1,0,1,3,2,2,1,3,0,3,0,2,0,2,0,3,0,2,0,0,0,1,0,1,1,0,0,3,1,0,0,0,4,0,3,1,0,2,1,3,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,2,2,3,1,0,3,0,0,0,1,4,4,4,3,0,0,4,0,0,1,4),
(1,4,1,5,0,3,0,3,0,4,5,4,4,3,5,3,3,4,4,3,4,1,3,3,3,3,2,1,4,1,5,4,3,1,4,4,3,5,4,4,3,5,4,3,3,4,4,4,0,3,3,1,2,3,0,3,1,0,3,3,0,5,4,4,4,4,4,4,3,3,5,4,4,3,3,5,4,0,3,2,0,4,4),
(0,2,0,3,0,1,0,0,0,1,3,3,3,2,4,1,3,0,3,1,3,0,2,2,1,1,0,0,2,0,4,3,1,0,4,3,0,4,4,4,1,4,3,1,1,3,3,1,0,2,0,0,1,3,0,0,0,0,2,0,0,4,3,2,4,3,5,4,3,3,3,4,3,3,4,3,3,0,2,1,0,3,3),
(0,2,0,4,0,3,0,2,0,2,5,5,3,4,4,4,4,1,4,3,3,0,4,3,4,3,1,3,3,2,4,3,0,3,4,3,0,3,4,4,2,4,4,0,4,5,3,3,2,2,1,1,1,2,0,1,5,0,3,3,2,4,3,3,3,4,0,3,0,2,0,4,4,3,5,5,0,0,3,0,2,3,3),
(0,3,0,4,0,3,0,1,0,3,4,3,3,1,3,3,3,0,3,1,3,0,4,3,3,1,1,0,3,0,3,3,0,0,4,4,0,1,5,4,3,3,5,0,3,3,4,3,0,2,0,1,1,1,0,1,3,0,1,2,1,3,3,2,3,3,0,3,0,1,0,1,3,3,4,4,1,0,1,2,2,1,3),
(0,1,0,4,0,4,0,3,0,1,3,3,3,2,3,1,1,0,3,0,3,3,4,3,2,4,2,0,1,0,4,3,2,0,4,3,0,5,3,3,2,4,4,4,3,3,3,4,0,1,3,0,0,1,0,0,1,0,0,0,0,4,2,3,3,3,0,3,0,0,0,4,4,4,5,3,2,0,3,3,0,3,5),
(0,2,0,3,0,0,0,3,0,1,3,0,2,0,0,0,1,0,3,1,1,3,3,0,0,3,0,0,3,0,2,3,1,0,3,1,0,3,3,2,0,4,2,2,0,2,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,2,1,2,0,1,0,1,0,0,0,1,3,1,2,0,0,0,1,0,0,1,4),
(0,3,0,3,0,5,0,1,0,2,4,3,1,3,3,2,1,1,5,2,1,0,5,1,2,0,0,0,3,3,2,2,3,2,4,3,0,0,3,3,1,3,3,0,2,5,3,4,0,3,3,0,1,2,0,2,2,0,3,2,0,2,2,3,3,3,0,2,0,1,0,3,4,4,2,5,4,0,3,0,0,3,5),
(0,3,0,3,0,3,0,1,0,3,3,3,3,0,3,0,2,0,2,1,1,0,2,0,1,0,0,0,2,1,0,0,1,0,3,2,0,0,3,3,1,2,3,1,0,3,3,0,0,1,0,0,0,0,0,2,0,0,0,0,0,2,3,1,2,3,0,3,0,1,0,3,2,1,0,4,3,0,1,1,0,3,3),
(0,4,0,5,0,3,0,3,0,4,5,5,4,3,5,3,4,3,5,3,3,2,5,3,4,4,4,3,4,3,4,5,5,3,4,4,3,4,4,5,4,4,4,3,4,5,5,4,2,3,4,2,3,4,0,3,3,1,4,3,2,4,3,3,5,5,0,3,0,3,0,5,5,5,5,4,4,0,4,0,1,4,4),
(0,4,0,4,0,3,0,3,0,3,5,4,4,2,3,2,5,1,3,2,5,1,4,2,3,2,3,3,4,3,3,3,3,2,5,4,1,3,3,5,3,4,4,0,4,4,3,1,1,3,1,0,2,3,0,2,3,0,3,0,0,4,3,1,3,4,0,3,0,2,0,4,4,4,3,4,5,0,4,0,0,3,4),
(0,3,0,3,0,3,1,2,0,3,4,4,3,3,3,0,2,2,4,3,3,1,3,3,3,1,1,0,3,1,4,3,2,3,4,4,2,4,4,4,3,4,4,3,2,4,4,3,1,3,3,1,3,3,0,4,1,0,2,2,1,4,3,2,3,3,5,4,3,3,5,4,4,3,3,0,4,0,3,2,2,4,4),
(0,2,0,1,0,0,0,0,0,1,2,1,3,0,0,0,0,0,2,0,1,2,1,0,0,1,0,0,0,0,3,0,0,1,0,1,1,3,1,0,0,0,1,1,0,1,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1,1,2,2,0,3,4,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1),
(0,1,0,0,0,1,0,0,0,0,4,0,4,1,4,0,3,0,4,0,3,0,4,0,3,0,3,0,4,1,5,1,4,0,0,3,0,5,0,5,2,0,1,0,0,0,2,1,4,0,1,3,0,0,3,0,0,3,1,1,4,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0),
(1,4,0,5,0,3,0,2,0,3,5,4,4,3,4,3,5,3,4,3,3,0,4,3,3,3,3,3,3,2,4,4,3,1,3,4,4,5,4,4,3,4,4,1,3,5,4,3,3,3,1,2,2,3,3,1,3,1,3,3,3,5,3,3,4,5,0,3,0,3,0,3,4,3,4,4,3,0,3,0,2,4,3),
(0,1,0,4,0,0,0,0,0,1,4,0,4,1,4,2,4,0,3,0,1,0,1,0,0,0,0,0,2,0,3,1,1,1,0,3,0,0,0,1,2,1,0,0,1,1,1,1,0,1,0,0,0,1,0,0,3,0,0,0,0,3,2,0,2,2,0,1,0,0,0,2,3,2,3,3,0,0,0,0,2,1,0),
(0,5,1,5,0,3,0,3,0,5,4,4,5,1,5,3,3,0,4,3,4,3,5,3,4,3,3,2,4,3,4,3,3,0,3,3,1,4,4,3,4,4,4,3,4,5,5,3,2,3,1,1,3,3,1,3,1,1,3,3,2,4,5,3,3,5,0,4,0,3,0,4,4,3,5,3,3,0,3,4,0,4,3),
(0,5,0,5,0,3,0,2,0,4,4,3,5,2,4,3,3,3,4,4,4,3,5,3,5,3,3,1,4,0,4,3,3,0,3,3,0,4,4,4,4,5,4,3,3,5,5,3,2,3,1,2,3,2,0,1,0,0,3,2,2,4,4,3,1,5,0,4,0,3,0,4,3,1,3,2,1,0,3,3,0,3,3),
(0,4,0,5,0,5,0,4,0,4,5,5,5,3,4,3,3,2,5,4,4,3,5,3,5,3,4,0,4,3,4,4,3,2,4,4,3,4,5,4,4,5,5,0,3,5,5,4,1,3,3,2,3,3,1,3,1,0,4,3,1,4,4,3,4,5,0,4,0,2,0,4,3,4,4,3,3,0,4,0,0,5,5),
(0,4,0,4,0,5,0,1,1,3,3,4,4,3,4,1,3,0,5,1,3,0,3,1,3,1,1,0,3,0,3,3,4,0,4,3,0,4,4,4,3,4,4,0,3,5,4,1,0,3,0,0,2,3,0,3,1,0,3,1,0,3,2,1,3,5,0,3,0,1,0,3,2,3,3,4,4,0,2,2,0,4,4),
(2,4,0,5,0,4,0,3,0,4,5,5,4,3,5,3,5,3,5,3,5,2,5,3,4,3,3,4,3,4,5,3,2,1,5,4,3,2,3,4,5,3,4,1,2,5,4,3,0,3,3,0,3,2,0,2,3,0,4,1,0,3,4,3,3,5,0,3,0,1,0,4,5,5,5,4,3,0,4,2,0,3,5),
(0,5,0,4,0,4,0,2,0,5,4,3,4,3,4,3,3,3,4,3,4,2,5,3,5,3,4,1,4,3,4,4,4,0,3,5,0,4,4,4,4,5,3,1,3,4,5,3,3,3,3,3,3,3,0,2,2,0,3,3,2,4,3,3,3,5,3,4,1,3,3,5,3,2,0,0,0,0,4,3,1,3,3),
(0,1,0,3,0,3,0,1,0,1,3,3,3,2,3,3,3,0,3,0,0,0,3,1,3,0,0,0,2,2,2,3,0,0,3,2,0,1,2,4,1,3,3,0,0,3,3,3,0,1,0,0,2,1,0,0,3,0,3,1,0,3,0,0,1,3,0,2,0,1,0,3,3,1,3,3,0,0,1,1,0,3,3),
(0,2,0,3,0,2,1,4,0,2,2,3,1,1,3,1,1,0,2,0,3,1,2,3,1,3,0,0,1,0,4,3,2,3,3,3,1,4,2,3,3,3,3,1,0,3,1,4,0,1,1,0,1,2,0,1,1,0,1,1,0,3,1,3,2,2,0,1,0,0,0,2,3,3,3,1,0,0,0,0,0,2,3),
(0,5,0,4,0,5,0,2,0,4,5,5,3,3,4,3,3,1,5,4,4,2,4,4,4,3,4,2,4,3,5,5,4,3,3,4,3,3,5,5,4,5,5,1,3,4,5,3,1,4,3,1,3,3,0,3,3,1,4,3,1,4,5,3,3,5,0,4,0,3,0,5,3,3,1,4,3,0,4,0,1,5,3),
(0,5,0,5,0,4,0,2,0,4,4,3,4,3,3,3,3,3,5,4,4,4,4,4,4,5,3,3,5,2,4,4,4,3,4,4,3,3,4,4,5,5,3,3,4,3,4,3,3,4,3,3,3,3,1,2,2,1,4,3,3,5,4,4,3,4,0,4,0,3,0,4,4,4,4,4,1,0,4,2,0,2,4),
(0,4,0,4,0,3,0,1,0,3,5,2,3,0,3,0,2,1,4,2,3,3,4,1,4,3,3,2,4,1,3,3,3,0,3,3,0,0,3,3,3,5,3,3,3,3,3,2,0,2,0,0,2,0,0,2,0,0,1,0,0,3,1,2,2,3,0,3,0,2,0,4,4,3,3,4,1,0,3,0,0,2,4),
(0,0,0,4,0,0,0,0,0,0,1,0,1,0,2,0,0,0,0,0,1,0,2,0,1,0,0,0,0,0,3,1,3,0,3,2,0,0,0,1,0,3,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,4,0,2,0,0,0,0,0,0,2),
(0,2,1,3,0,2,0,2,0,3,3,3,3,1,3,1,3,3,3,3,3,3,4,2,2,1,2,1,4,0,4,3,1,3,3,3,2,4,3,5,4,3,3,3,3,3,3,3,0,1,3,0,2,0,0,1,0,0,1,0,0,4,2,0,2,3,0,3,3,0,3,3,4,2,3,1,4,0,1,2,0,2,3),
(0,3,0,3,0,1,0,3,0,2,3,3,3,0,3,1,2,0,3,3,2,3,3,2,3,2,3,1,3,0,4,3,2,0,3,3,1,4,3,3,2,3,4,3,1,3,3,1,1,0,1,1,0,1,0,1,0,1,0,0,0,4,1,1,0,3,0,3,1,0,2,3,3,3,3,3,1,0,0,2,0,3,3),
(0,0,0,0,0,0,0,0,0,0,3,0,2,0,3,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,3,0,3,0,3,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,2,0,2,3,0,0,0,0,0,0,0,0,3),
(0,2,0,3,1,3,0,3,0,2,3,3,3,1,3,1,3,1,3,1,3,3,3,1,3,0,2,3,1,1,4,3,3,2,3,3,1,2,2,4,1,3,3,0,1,4,2,3,0,1,3,0,3,0,0,1,3,0,2,0,0,3,3,2,1,3,0,3,0,2,0,3,4,4,4,3,1,0,3,0,0,3,3),
(0,2,0,1,0,2,0,0,0,1,3,2,2,1,3,0,1,1,3,0,3,2,3,1,2,0,2,0,1,1,3,3,3,0,3,3,1,1,2,3,2,3,3,1,2,3,2,0,0,1,0,0,0,0,0,0,3,0,1,0,0,2,1,2,1,3,0,3,0,0,0,3,4,4,4,3,2,0,2,0,0,2,4),
(0,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,2,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,3,1,0,0,0,0,0,0,0,3),
(0,3,0,3,0,2,0,3,0,3,3,3,2,3,2,2,2,0,3,1,3,3,3,2,3,3,0,0,3,0,3,2,2,0,2,3,1,4,3,4,3,3,2,3,1,5,4,4,0,3,1,2,1,3,0,3,1,1,2,0,2,3,1,3,1,3,0,3,0,1,0,3,3,4,4,2,1,0,2,1,0,2,4),
(0,1,0,3,0,1,0,2,0,1,4,2,5,1,4,0,2,0,2,1,3,1,4,0,2,1,0,0,2,1,4,1,1,0,3,3,0,5,1,3,2,3,3,1,0,3,2,3,0,1,0,0,0,0,0,0,1,0,0,0,0,4,0,1,0,3,0,2,0,1,0,3,3,3,4,3,3,0,0,0,0,2,3),
(0,0,0,1,0,0,0,0,0,0,2,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,1,0,0,0,0,0,3),
(0,1,0,3,0,4,0,3,0,2,4,3,1,0,3,2,2,1,3,1,2,2,3,1,1,1,2,1,3,0,1,2,0,1,3,2,1,3,0,5,5,1,0,0,1,3,2,1,0,3,0,0,1,0,0,0,0,0,3,4,0,1,1,1,3,2,0,2,0,1,0,2,3,3,1,2,3,0,1,0,1,0,4),
(0,0,0,1,0,3,0,3,0,2,2,1,0,0,4,0,3,0,3,1,3,0,3,0,3,0,1,0,3,0,3,1,3,0,3,3,0,0,1,2,1,1,1,0,1,2,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,2,2,1,2,0,0,2,0,0,0,0,2,3,3,3,3,0,0,0,0,1,4),
(0,0,0,3,0,3,0,0,0,0,3,1,1,0,3,0,1,0,2,0,1,0,0,0,0,0,0,0,1,0,3,0,2,0,2,3,0,0,2,2,3,1,2,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,2,0,0,0,0,2,3),
(2,4,0,5,0,5,0,4,0,3,4,3,3,3,4,3,3,3,4,3,4,4,5,4,5,5,5,2,3,0,5,5,4,1,5,4,3,1,5,4,3,4,4,3,3,4,3,3,0,3,2,0,2,3,0,3,0,0,3,3,0,5,3,2,3,3,0,3,0,3,0,3,4,5,4,5,3,0,4,3,0,3,4),
(0,3,0,3,0,3,0,3,0,3,3,4,3,2,3,2,3,0,4,3,3,3,3,3,3,3,3,0,3,2,4,3,3,1,3,4,3,4,4,4,3,4,4,3,2,4,4,1,0,2,0,0,1,1,0,2,0,0,3,1,0,5,3,2,1,3,0,3,0,1,2,4,3,2,4,3,3,0,3,2,0,4,4),
(0,3,0,3,0,1,0,0,0,1,4,3,3,2,3,1,3,1,4,2,3,2,4,2,3,4,3,0,2,2,3,3,3,0,3,3,3,0,3,4,1,3,3,0,3,4,3,3,0,1,1,0,1,0,0,0,4,0,3,0,0,3,1,2,1,3,0,4,0,1,0,4,3,3,4,3,3,0,2,0,0,3,3),
(0,3,0,4,0,1,0,3,0,3,4,3,3,0,3,3,3,1,3,1,3,3,4,3,3,3,0,0,3,1,5,3,3,1,3,3,2,5,4,3,3,4,5,3,2,5,3,4,0,1,0,0,0,0,0,2,0,0,1,1,0,4,2,2,1,3,0,3,0,2,0,4,4,3,5,3,2,0,1,1,0,3,4),
(0,5,0,4,0,5,0,2,0,4,4,3,3,2,3,3,3,1,4,3,4,1,5,3,4,3,4,0,4,2,4,3,4,1,5,4,0,4,4,4,4,5,4,1,3,5,4,2,1,4,1,1,3,2,0,3,1,0,3,2,1,4,3,3,3,4,0,4,0,3,0,4,4,4,3,3,3,0,4,2,0,3,4),
(1,4,0,4,0,3,0,1,0,3,3,3,1,1,3,3,2,2,3,3,1,0,3,2,2,1,2,0,3,1,2,1,2,0,3,2,0,2,2,3,3,4,3,0,3,3,1,2,0,1,1,3,1,2,0,0,3,0,1,1,0,3,2,2,3,3,0,3,0,0,0,2,3,3,4,3,3,0,1,0,0,1,4),
(0,4,0,4,0,4,0,0,0,3,4,4,3,1,4,2,3,2,3,3,3,1,4,3,4,0,3,0,4,2,3,3,2,2,5,4,2,1,3,4,3,4,3,1,3,3,4,2,0,2,1,0,3,3,0,0,2,0,3,1,0,4,4,3,4,3,0,4,0,1,0,2,4,4,4,4,4,0,3,2,0,3,3),
(0,0,0,1,0,4,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,3,2,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,2),
(0,2,0,3,0,4,0,4,0,1,3,3,3,0,4,0,2,1,2,1,1,1,2,0,3,1,1,0,1,0,3,1,0,0,3,3,2,0,1,1,0,0,0,0,0,1,0,2,0,2,2,0,3,1,0,0,1,0,1,1,0,1,2,0,3,0,0,0,0,1,0,0,3,3,4,3,1,0,1,0,3,0,2),
(0,0,0,3,0,5,0,0,0,0,1,0,2,0,3,1,0,1,3,0,0,0,2,0,0,0,1,0,0,0,1,1,0,0,4,0,0,0,2,3,0,1,4,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,3,0,0,0,0,0,3),
(0,2,0,5,0,5,0,1,0,2,4,3,3,2,5,1,3,2,3,3,3,0,4,1,2,0,3,0,4,0,2,2,1,1,5,3,0,0,1,4,2,3,2,0,3,3,3,2,0,2,4,1,1,2,0,1,1,0,3,1,0,1,3,1,2,3,0,2,0,0,0,1,3,5,4,4,4,0,3,0,0,1,3),
(0,4,0,5,0,4,0,4,0,4,5,4,3,3,4,3,3,3,4,3,4,4,5,3,4,5,4,2,4,2,3,4,3,1,4,4,1,3,5,4,4,5,5,4,4,5,5,5,2,3,3,1,4,3,1,3,3,0,3,3,1,4,3,4,4,4,0,3,0,4,0,3,3,4,4,5,0,0,4,3,0,4,5),
(0,4,0,4,0,3,0,3,0,3,4,4,4,3,3,2,4,3,4,3,4,3,5,3,4,3,2,1,4,2,4,4,3,1,3,4,2,4,5,5,3,4,5,4,1,5,4,3,0,3,2,2,3,2,1,3,1,0,3,3,3,5,3,3,3,5,4,4,2,3,3,4,3,3,3,2,1,0,3,2,1,4,3),
(0,4,0,5,0,4,0,3,0,3,5,5,3,2,4,3,4,0,5,4,4,1,4,4,4,3,3,3,4,3,5,5,2,3,3,4,1,2,5,5,3,5,5,2,3,5,5,4,0,3,2,0,3,3,1,1,5,1,4,1,0,4,3,2,3,5,0,4,0,3,0,5,4,3,4,3,0,0,4,1,0,4,4),
(1,3,0,4,0,2,0,2,0,2,5,5,3,3,3,3,3,0,4,2,3,4,4,4,3,4,0,0,3,4,5,4,3,3,3,3,2,5,5,4,5,5,5,4,3,5,5,5,1,3,1,0,1,0,0,3,2,0,4,2,0,5,2,3,2,4,1,3,0,3,0,4,5,4,5,4,3,0,4,2,0,5,4),
(0,3,0,4,0,5,0,3,0,3,4,4,3,2,3,2,3,3,3,3,3,2,4,3,3,2,2,0,3,3,3,3,3,1,3,3,3,0,4,4,3,4,4,1,1,4,4,2,0,3,1,0,1,1,0,4,1,0,2,3,1,3,3,1,3,4,0,3,0,1,0,3,1,3,0,0,1,0,2,0,0,4,4),
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
(0,3,0,3,0,2,0,3,0,1,5,4,3,3,3,1,4,2,1,2,3,4,4,2,4,4,5,0,3,1,4,3,4,0,4,3,3,3,2,3,2,5,3,4,3,2,2,3,0,0,3,0,2,1,0,1,2,0,0,0,0,2,1,1,3,1,0,2,0,4,0,3,4,4,4,5,2,0,2,0,0,1,3),
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0,0,4,2,1,1,0,1,0,3,2,0,0,3,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,1,0,0,0,2,0,0,0,1,4,0,4,2,1,0,0,0,0,0,1),
(0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,3,1,0,0,0,2,0,2,1,0,0,1,2,1,0,1,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,1,3,1,0,0,0,0,0,1,0,0,2,1,0,0,0,0,0,0,0,0,2),
(0,4,0,4,0,4,0,3,0,4,4,3,4,2,4,3,2,0,4,4,4,3,5,3,5,3,3,2,4,2,4,3,4,3,1,4,0,2,3,4,4,4,3,3,3,4,4,4,3,4,1,3,4,3,2,1,2,1,3,3,3,4,4,3,3,5,0,4,0,3,0,4,3,3,3,2,1,0,3,0,0,3,3),
(0,4,0,3,0,3,0,3,0,3,5,5,3,3,3,3,4,3,4,3,3,3,4,4,4,3,3,3,3,4,3,5,3,3,1,3,2,4,5,5,5,5,4,3,4,5,5,3,2,2,3,3,3,3,2,3,3,1,2,3,2,4,3,3,3,4,0,4,0,2,0,4,3,2,2,1,2,0,3,0,0,4,1),
)

class JapaneseContextAnalysis:
    def __init__(self):
        self.reset()

    def reset(self):
        self._mTotalRel = 0  # total sequence received
        # category counters, each interger counts sequence in its category
        self._mRelSample = [0] * NUM_OF_CATEGORY
        # if last byte in current buffer is not the last byte of a character,
        # we need to know how many bytes to skip in next buffer
        self._mNeedToSkipCharNum = 0
        self._mLastCharOrder = -1  # The order of previous char
        # If this flag is set to True, detection is done and conclusion has
        # been made
        self._mDone = False

    def feed(self, aBuf, aLen):
        if self._mDone:
            return

        # The buffer we got is byte oriented, and a character may span in more than one
        # buffers. In case the last one or two byte in last buffer is not
        # complete, we record how many byte needed to complete that character
        # and skip these bytes here.  We can choose to record those bytes as
        # well and analyse the character once it is complete, but since a
        # character will not make much difference, by simply skipping
        # this character will simply our logic and improve performance.
        i = self._mNeedToSkipCharNum
        while i < aLen:
            order, charLen = self.get_order(aBuf[i:i + 2])
            i += charLen
            if i > aLen:
                self._mNeedToSkipCharNum = i - aLen
                self._mLastCharOrder = -1
            else:
                if (order != -1) and (self._mLastCharOrder != -1):
                    self._mTotalRel += 1
                    if self._mTotalRel > MAX_REL_THRESHOLD:
                        self._mDone = True
                        break
                    self._mRelSample[jp2CharContext[self._mLastCharOrder][order]] += 1
                self._mLastCharOrder = order

    def got_enough_data(self):
        return self._mTotalRel > ENOUGH_REL_THRESHOLD

    def get_confidence(self):
        # This is just one way to calculate confidence. It works well for me.
        if self._mTotalRel > MINIMUM_DATA_THRESHOLD:
            return (self._mTotalRel - self._mRelSample[0]) / self._mTotalRel
        else:
            return DONT_KNOW

    def get_order(self, aBuf):
        return -1, 1

class SJISContextAnalysis(JapaneseContextAnalysis):
    def get_order(self, aBuf):
        if not aBuf:
            return -1, 1
        # find out current char's byte length
        first_char = wrap_ord(aBuf[0])
        if ((0x81 <= first_char <= 0x9F) or (0xE0 <= first_char <= 0xFC)):
            charLen = 2
        else:
            charLen = 1

        # return its order if it is hiragana
        if len(aBuf) > 1:
            second_char = wrap_ord(aBuf[1])
            if (first_char == 202) and (0x9F <= second_char <= 0xF1):
                return second_char - 0x9F, charLen

        return -1, charLen

class EUCJPContextAnalysis(JapaneseContextAnalysis):
    def get_order(self, aBuf):
        if not aBuf:
            return -1, 1
        # find out current char's byte length
        first_char = wrap_ord(aBuf[0])
        if (first_char == 0x8E) or (0xA1 <= first_char <= 0xFE):
            charLen = 2
        elif first_char == 0x8F:
            charLen = 3
        else:
            charLen = 1

        # return its order if it is hiragana
        if len(aBuf) > 1:
            second_char = wrap_ord(aBuf[1])
            if (first_char == 0xA4) and (0xA1 <= second_char <= 0xF3):
                return second_char - 0xA1, charLen

        return -1, charLen

# flake8: noqa

########NEW FILE########
__FILENAME__ = langbulgarianmodel
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# 255: Control characters that usually does not exist in any text
# 254: Carriage/Return
# 253: symbol (punctuation) that does not belong to word
# 252: 0 - 9

# Character Mapping Table:
# this table is modified base on win1251BulgarianCharToOrderMap, so
# only number <64 is sure valid

Latin5_BulgarianCharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253, 77, 90, 99,100, 72,109,107,101, 79,185, 81,102, 76, 94, 82,  # 40
110,186,108, 91, 74,119, 84, 96,111,187,115,253,253,253,253,253,  # 50
253, 65, 69, 70, 66, 63, 68,112,103, 92,194,104, 95, 86, 87, 71,  # 60
116,195, 85, 93, 97,113,196,197,198,199,200,253,253,253,253,253,  # 70
194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,  # 80
210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,  # 90
 81,226,227,228,229,230,105,231,232,233,234,235,236, 45,237,238,  # a0
 31, 32, 35, 43, 37, 44, 55, 47, 40, 59, 33, 46, 38, 36, 41, 30,  # b0
 39, 28, 34, 51, 48, 49, 53, 50, 54, 57, 61,239, 67,240, 60, 56,  # c0
  1, 18,  9, 20, 11,  3, 23, 15,  2, 26, 12, 10, 14,  6,  4, 13,  # d0
  7,  8,  5, 19, 29, 25, 22, 21, 27, 24, 17, 75, 52,241, 42, 16,  # e0
 62,242,243,244, 58,245, 98,246,247,248,249,250,251, 91,252,253,  # f0
)

win1251BulgarianCharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253, 77, 90, 99,100, 72,109,107,101, 79,185, 81,102, 76, 94, 82,  # 40
110,186,108, 91, 74,119, 84, 96,111,187,115,253,253,253,253,253,  # 50
253, 65, 69, 70, 66, 63, 68,112,103, 92,194,104, 95, 86, 87, 71,  # 60
116,195, 85, 93, 97,113,196,197,198,199,200,253,253,253,253,253,  # 70
206,207,208,209,210,211,212,213,120,214,215,216,217,218,219,220,  # 80
221, 78, 64, 83,121, 98,117,105,222,223,224,225,226,227,228,229,  # 90
 88,230,231,232,233,122, 89,106,234,235,236,237,238, 45,239,240,  # a0
 73, 80,118,114,241,242,243,244,245, 62, 58,246,247,248,249,250,  # b0
 31, 32, 35, 43, 37, 44, 55, 47, 40, 59, 33, 46, 38, 36, 41, 30,  # c0
 39, 28, 34, 51, 48, 49, 53, 50, 54, 57, 61,251, 67,252, 60, 56,  # d0
  1, 18,  9, 20, 11,  3, 23, 15,  2, 26, 12, 10, 14,  6,  4, 13,  # e0
  7,  8,  5, 19, 29, 25, 22, 21, 27, 24, 17, 75, 52,253, 42, 16,  # f0
)

# Model Table:
# total sequences: 100%
# first 512 sequences: 96.9392%
# first 1024 sequences:3.0618%
# rest  sequences:     0.2992%
# negative sequences:  0.0020%
BulgarianLangModel = (
0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,2,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,3,3,3,2,2,3,2,2,1,2,2,
3,1,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,0,3,0,1,
0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,2,3,3,3,3,3,3,3,3,0,3,1,0,
0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
3,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,1,3,2,3,3,3,3,3,3,3,3,0,3,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,1,3,2,3,3,3,3,3,3,3,3,0,3,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,2,3,2,2,1,3,3,3,3,2,2,2,1,1,2,0,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,2,3,2,2,3,3,1,1,2,3,3,2,3,3,3,3,2,1,2,0,2,0,3,0,0,
0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,1,3,3,3,3,3,2,3,2,3,3,3,3,3,2,3,3,1,3,0,3,0,2,0,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,3,1,3,3,2,3,3,3,1,3,3,2,3,2,2,2,0,0,2,0,2,0,2,0,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,3,3,0,3,3,3,2,2,3,3,3,1,2,2,3,2,1,1,2,0,2,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,2,3,3,1,2,3,2,2,2,3,3,3,3,3,2,2,3,1,2,0,2,1,2,0,0,
0,0,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,1,3,3,3,3,3,2,3,3,3,2,3,3,2,3,2,2,2,3,1,2,0,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,3,3,3,3,1,1,1,2,2,1,3,1,3,2,2,3,0,0,1,0,1,0,1,0,0,
0,0,0,1,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,2,2,3,2,2,3,1,2,1,1,1,2,3,1,3,1,2,2,0,1,1,1,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,1,3,2,2,3,3,1,2,3,1,1,3,3,3,3,1,2,2,1,1,1,0,2,0,2,0,1,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,2,2,3,3,3,2,2,1,1,2,0,2,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,0,1,2,1,3,3,2,3,3,3,3,3,2,3,2,1,0,3,1,2,1,2,1,2,3,2,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3,1,3,3,2,3,3,2,2,2,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,3,3,3,0,3,3,3,3,3,2,1,1,2,1,3,3,0,3,1,1,1,1,3,2,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,2,2,2,3,3,3,3,3,3,3,3,3,3,3,1,1,3,1,3,3,2,3,2,2,2,3,0,2,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,2,3,3,2,2,3,2,1,1,1,1,1,3,1,3,1,1,0,0,0,1,0,0,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,2,3,2,0,3,2,0,3,0,2,0,0,2,1,3,1,0,0,1,0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,2,1,1,1,1,2,1,1,2,1,1,1,2,2,1,2,1,1,1,0,1,1,0,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,2,1,3,1,1,2,1,3,2,1,1,0,1,2,3,2,1,1,1,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,3,3,3,2,2,1,0,1,0,0,1,0,0,0,2,1,0,3,0,0,1,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,2,3,2,3,3,1,3,2,1,1,1,2,1,1,2,1,3,0,1,0,0,0,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,2,2,3,3,2,3,2,2,2,3,1,2,2,1,1,2,1,1,2,2,0,1,1,0,1,0,2,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,2,1,3,1,0,2,2,1,3,2,1,0,0,2,0,2,0,1,0,0,0,0,0,0,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,1,2,0,2,3,1,2,3,2,0,1,3,1,2,1,1,1,0,0,1,0,0,2,2,2,3,
2,2,2,2,1,2,1,1,2,2,1,1,2,0,1,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,
3,3,3,3,3,2,1,2,2,1,2,0,2,0,1,0,1,2,1,2,1,1,0,0,0,1,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,
3,3,2,3,3,1,1,3,1,0,3,2,1,0,0,0,1,2,0,2,0,1,0,0,0,1,0,1,2,1,2,2,
1,1,1,1,1,1,1,2,2,2,1,1,1,1,1,1,1,0,1,2,1,1,1,0,0,0,0,0,1,1,0,0,
3,1,0,1,0,2,3,2,2,2,3,2,2,2,2,2,1,0,2,1,2,1,1,1,0,1,2,1,2,2,2,1,
1,1,2,2,2,2,1,2,1,1,0,1,2,1,2,2,2,1,1,1,0,1,1,1,1,2,0,1,0,0,0,0,
2,3,2,3,3,0,0,2,1,0,2,1,0,0,0,0,2,3,0,2,0,0,0,0,0,1,0,0,2,0,1,2,
2,1,2,1,2,2,1,1,1,2,1,1,1,0,1,2,2,1,1,1,1,1,0,1,1,1,0,0,1,2,0,0,
3,3,2,2,3,0,2,3,1,1,2,0,0,0,1,0,0,2,0,2,0,0,0,1,0,1,0,1,2,0,2,2,
1,1,1,1,2,1,0,1,2,2,2,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,
2,3,2,3,3,0,0,3,0,1,1,0,1,0,0,0,2,2,1,2,0,0,0,0,0,0,0,0,2,0,1,2,
2,2,1,1,1,1,1,2,2,2,1,0,2,0,1,0,1,0,0,1,0,1,0,0,1,0,0,0,0,1,0,0,
3,3,3,3,2,2,2,2,2,0,2,1,1,1,1,2,1,2,1,1,0,2,0,1,0,1,0,0,2,0,1,2,
1,1,1,1,1,1,1,2,2,1,1,0,2,0,1,0,2,0,0,1,1,1,0,0,2,0,0,0,1,1,0,0,
2,3,3,3,3,1,0,0,0,0,0,0,0,0,0,0,2,0,0,1,1,0,0,0,0,0,0,1,2,0,1,2,
2,2,2,1,1,2,1,1,2,2,2,1,2,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,0,0,
2,3,3,3,3,0,2,2,0,2,1,0,0,0,1,1,1,2,0,2,0,0,0,3,0,0,0,0,2,0,2,2,
1,1,1,2,1,2,1,1,2,2,2,1,2,0,1,1,1,0,1,1,1,1,0,2,1,0,0,0,1,1,0,0,
2,3,3,3,3,0,2,1,0,0,2,0,0,0,0,0,1,2,0,2,0,0,0,0,0,0,0,0,2,0,1,2,
1,1,1,2,1,1,1,1,2,2,2,0,1,0,1,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,
3,3,2,2,3,0,1,0,1,0,0,0,0,0,0,0,1,1,0,3,0,0,0,0,0,0,0,0,1,0,2,2,
1,1,1,1,1,2,1,1,2,2,1,2,2,1,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,
3,1,0,1,0,2,2,2,2,3,2,1,1,1,2,3,0,0,1,0,2,1,1,0,1,1,1,1,2,1,1,1,
1,2,2,1,2,1,2,2,1,1,0,1,2,1,2,2,1,1,1,0,0,1,1,1,2,1,0,1,0,0,0,0,
2,1,0,1,0,3,1,2,2,2,2,1,2,2,1,1,1,0,2,1,2,2,1,1,2,1,1,0,2,1,1,1,
1,2,2,2,2,2,2,2,1,2,0,1,1,0,2,1,1,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,
2,1,1,1,1,2,2,2,2,1,2,2,2,1,2,2,1,1,2,1,2,3,2,2,1,1,1,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,3,2,0,1,2,0,1,2,1,1,0,1,0,1,2,1,2,0,0,0,1,1,0,0,0,1,0,0,2,
1,1,0,0,1,1,0,1,1,1,1,0,2,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,1,0,0,
2,0,0,0,0,1,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,1,0,1,1,1,1,1,2,1,1,1,
1,2,2,2,2,1,1,2,1,2,1,1,1,0,2,1,2,1,1,1,0,2,1,1,1,1,0,1,0,0,0,0,
3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,
1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,3,2,0,0,0,0,1,0,0,0,0,0,0,1,1,0,2,0,0,0,0,0,0,0,0,1,0,1,2,
1,1,1,1,1,1,0,0,2,2,2,2,2,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,1,0,1,
2,3,1,2,1,0,1,1,0,2,2,2,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,2,
1,1,1,1,2,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0,
2,2,2,2,2,0,0,2,0,0,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,2,0,2,2,
1,1,1,1,1,0,0,1,2,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
1,2,2,2,2,0,0,2,0,1,1,0,0,0,1,0,0,2,0,2,0,0,0,0,0,0,0,0,0,0,1,1,
0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
1,2,2,3,2,0,0,1,0,0,1,0,0,0,0,0,0,1,0,2,0,0,0,1,0,0,0,0,0,0,0,2,
1,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
2,1,2,2,2,1,2,1,2,2,1,1,2,1,1,1,0,1,1,1,1,2,0,1,0,1,1,1,1,0,1,1,
1,1,2,1,1,1,1,1,1,0,0,1,2,1,1,1,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,
1,0,0,1,3,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,2,1,0,0,1,0,2,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,2,0,0,1,
0,2,0,1,0,0,1,1,2,0,1,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
1,2,2,2,2,0,1,1,0,2,1,0,1,1,1,0,0,1,0,2,0,1,0,0,0,0,0,0,0,0,0,1,
0,1,0,0,1,0,0,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,2,2,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,
0,1,0,1,1,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
2,0,1,0,0,1,2,1,1,1,1,1,1,2,2,1,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,0,
1,1,2,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,1,2,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,
0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,
1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,2,0,0,2,0,1,0,0,1,0,0,1,
1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,
1,1,1,1,1,1,1,2,0,0,0,0,0,0,2,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,1,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
)

Latin5BulgarianModel = {
  'charToOrderMap': Latin5_BulgarianCharToOrderMap,
  'precedenceMatrix': BulgarianLangModel,
  'mTypicalPositiveRatio': 0.969392,
  'keepEnglishLetter': False,
  'charsetName': "ISO-8859-5"
}

Win1251BulgarianModel = {
  'charToOrderMap': win1251BulgarianCharToOrderMap,
  'precedenceMatrix': BulgarianLangModel,
  'mTypicalPositiveRatio': 0.969392,
  'keepEnglishLetter': False,
  'charsetName': "windows-1251"
}


# flake8: noqa

########NEW FILE########
__FILENAME__ = langcyrillicmodel
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# KOI8-R language model
# Character Mapping Table:
KOI8R_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,  # 40
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,  # 50
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,  # 60
 67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,  # 70
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,  # 80
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,  # 90
223,224,225, 68,226,227,228,229,230,231,232,233,234,235,236,237,  # a0
238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,  # b0
 27,  3, 21, 28, 13,  2, 39, 19, 26,  4, 23, 11,  8, 12,  5,  1,  # c0
 15, 16,  9,  7,  6, 14, 24, 10, 17, 18, 20, 25, 30, 29, 22, 54,  # d0
 59, 37, 44, 58, 41, 48, 53, 46, 55, 42, 60, 36, 49, 38, 31, 34,  # e0
 35, 43, 45, 32, 40, 52, 56, 33, 61, 62, 51, 57, 47, 63, 50, 70,  # f0
)

win1251_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,  # 40
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,  # 50
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,  # 60
 67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,  # 70
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,
223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
239,240,241,242,243,244,245,246, 68,247,248,249,250,251,252,253,
 37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,
 45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,
  3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,
  9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27, 16,
)

latin5_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,  # 40
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,  # 50
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,  # 60
 67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,  # 70
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,
223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
 37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,
 45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,
  3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,
  9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27, 16,
239, 68,240,241,242,243,244,245,246,247,248,249,250,251,252,255,
)

macCyrillic_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,  # 40
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,  # 50
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,  # 60
 67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,  # 70
 37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,
 45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,
223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
239,240,241,242,243,244,245,246,247,248,249,250,251,252, 68, 16,
  3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,
  9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27,255,
)

IBM855_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,  # 40
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,  # 50
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,  # 60
 67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,  # 70
191,192,193,194, 68,195,196,197,198,199,200,201,202,203,204,205,
206,207,208,209,210,211,212,213,214,215,216,217, 27, 59, 54, 70,
  3, 37, 21, 44, 28, 58, 13, 41,  2, 48, 39, 53, 19, 46,218,219,
220,221,222,223,224, 26, 55,  4, 42,225,226,227,228, 23, 60,229,
230,231,232,233,234,235, 11, 36,236,237,238,239,240,241,242,243,
  8, 49, 12, 38,  5, 31,  1, 34, 15,244,245,246,247, 35, 16,248,
 43,  9, 45,  7, 32,  6, 40, 14, 52, 24, 56, 10, 33, 17, 61,249,
250, 18, 62, 20, 51, 25, 57, 30, 47, 29, 63, 22, 50,251,252,255,
)

IBM866_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,  # 40
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,  # 50
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,  # 60
 67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,  # 70
 37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,
 45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,
  3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,
223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
  9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27, 16,
239, 68,240,241,242,243,244,245,246,247,248,249,250,251,252,255,
)

# Model Table:
# total sequences: 100%
# first 512 sequences: 97.6601%
# first 1024 sequences: 2.3389%
# rest  sequences:      0.1237%
# negative sequences:   0.0009%
RussianLangModel = (
0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,3,3,3,3,1,3,3,3,2,3,2,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,3,2,2,2,2,2,0,0,2,
3,3,3,2,3,3,3,3,3,3,3,3,3,3,2,3,3,0,0,3,3,3,3,3,3,3,3,3,2,3,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,2,2,3,3,3,3,3,3,3,3,3,2,3,3,0,0,3,3,3,3,3,3,3,3,2,3,3,1,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3,3,3,3,3,3,3,3,3,3,3,2,1,
0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,0,0,3,3,3,3,3,3,3,3,3,3,3,2,1,
0,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,2,2,2,3,1,3,3,1,3,3,3,3,2,2,3,0,2,2,2,3,3,2,1,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,3,3,3,3,3,2,2,3,2,3,3,3,2,1,2,2,0,1,2,2,2,2,2,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,3,0,2,2,3,3,2,1,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,3,3,1,2,3,2,2,3,2,3,3,3,3,2,2,3,0,3,2,2,3,1,1,1,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,2,3,3,3,3,2,2,2,0,3,3,3,2,2,2,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,2,3,2,3,3,3,3,3,3,2,3,2,2,0,1,3,2,1,2,2,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,2,1,1,3,0,1,1,1,1,2,1,1,0,2,2,2,1,2,0,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,3,3,2,2,2,2,1,3,2,3,2,3,2,1,2,2,0,1,1,2,1,2,1,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,2,2,3,2,3,3,3,2,2,2,2,0,2,2,2,2,3,1,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
3,2,3,2,2,3,3,3,3,3,3,3,3,3,1,3,2,0,0,3,3,3,3,2,3,3,3,3,2,3,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,3,3,3,3,2,2,3,3,0,2,1,0,3,2,3,2,3,0,0,1,2,0,0,1,0,1,2,1,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,3,0,2,3,3,3,3,2,3,3,3,3,1,2,2,0,0,2,3,2,2,2,3,2,3,2,2,3,0,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,3,0,2,3,2,3,0,1,2,3,3,2,0,2,3,0,0,2,3,2,2,0,1,3,1,3,2,2,1,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,3,0,2,3,3,3,3,3,3,3,3,2,1,3,2,0,0,2,2,3,3,3,2,3,3,0,2,2,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,2,3,3,2,2,2,3,3,0,0,1,1,1,1,1,2,0,0,1,1,1,1,0,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,2,3,3,3,3,3,3,3,0,3,2,3,3,2,3,2,0,2,1,0,1,1,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,3,3,3,2,2,2,2,3,1,3,2,3,1,1,2,1,0,2,2,2,2,1,3,1,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
2,2,3,3,3,3,3,1,2,2,1,3,1,0,3,0,0,3,0,0,0,1,1,0,1,2,1,0,0,0,0,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,2,1,1,3,3,3,2,2,1,2,2,3,1,1,2,0,0,2,2,1,3,0,0,2,1,1,2,1,1,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,3,3,3,3,1,2,2,2,1,2,1,3,3,1,1,2,1,2,1,2,2,0,2,0,0,1,1,0,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,3,3,3,3,2,1,3,2,2,3,2,0,3,2,0,3,0,1,0,1,1,0,0,1,1,1,1,0,1,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,2,3,3,3,2,2,2,3,3,1,2,1,2,1,0,1,0,1,1,0,1,0,0,2,1,1,1,0,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
3,1,1,2,1,2,3,3,2,2,1,2,2,3,0,2,1,0,0,2,2,3,2,1,2,2,2,2,2,3,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,1,1,0,1,1,2,2,1,1,3,0,0,1,3,1,1,1,0,0,0,1,0,1,1,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,1,3,3,3,2,0,0,0,2,1,0,1,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,1,0,0,2,3,2,2,2,1,2,2,2,1,2,1,0,0,1,1,1,0,2,0,1,1,1,0,0,1,1,
1,0,0,0,0,0,1,2,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
2,3,3,3,3,0,0,0,0,1,0,0,0,0,3,0,1,2,1,0,0,0,0,0,0,0,1,1,0,0,1,1,
1,0,1,0,1,2,0,0,1,1,2,1,0,1,1,1,1,0,1,1,1,1,0,1,0,0,1,0,0,1,1,0,
2,2,3,2,2,2,3,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,0,1,0,1,1,1,0,2,1,
1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,
3,3,3,2,2,2,2,3,2,2,1,1,2,2,2,2,1,1,3,1,2,1,2,0,0,1,1,0,1,0,2,1,
1,1,1,1,1,2,1,0,1,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,1,0,
2,0,0,1,0,3,2,2,2,2,1,2,1,2,1,2,0,0,0,2,1,2,2,1,1,2,2,0,1,1,0,2,
1,1,1,1,1,0,1,1,1,2,1,1,1,2,1,0,1,2,1,1,1,1,0,1,1,1,0,0,1,0,0,1,
1,3,2,2,2,1,1,1,2,3,0,0,0,0,2,0,2,2,1,0,0,0,0,0,0,1,0,0,0,0,1,1,
1,0,1,1,0,1,0,1,1,0,1,1,0,2,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,
2,3,2,3,2,1,2,2,2,2,1,0,0,0,2,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,2,1,
1,1,2,1,0,2,0,0,1,0,1,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,1,0,0,0,0,0,
3,0,0,1,0,2,2,2,3,2,2,2,2,2,2,2,0,0,0,2,1,2,1,1,1,2,2,0,0,0,1,2,
1,1,1,1,1,0,1,2,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,
2,3,2,3,3,2,0,1,1,1,0,0,1,0,2,0,1,1,3,1,0,0,0,0,0,0,0,1,0,0,2,1,
1,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,0,0,0,0,1,0,
2,3,3,3,3,1,2,2,2,2,0,1,1,0,2,1,1,1,2,1,0,1,1,0,0,1,0,1,0,0,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,3,3,2,0,0,1,1,2,2,1,0,0,2,0,1,1,3,0,0,1,0,0,0,0,0,1,0,1,2,1,
1,1,2,0,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,1,1,0,
1,3,2,3,2,1,0,0,2,2,2,0,1,0,2,0,1,1,1,0,1,0,0,0,3,0,1,1,0,0,2,1,
1,1,1,0,1,1,0,0,0,0,1,1,0,1,0,0,2,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,
3,1,2,1,1,2,2,2,2,2,2,1,2,2,1,1,0,0,0,2,2,2,0,0,0,1,2,1,0,1,0,1,
2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,2,1,1,1,0,1,0,1,1,0,1,1,1,0,0,1,
3,0,0,0,0,2,0,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,0,0,1,0,1,
1,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,
1,3,3,2,2,0,0,0,2,2,0,0,0,1,2,0,1,1,2,0,0,0,0,0,0,0,0,1,0,0,2,1,
0,1,1,0,0,1,1,0,0,0,1,1,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,
2,3,2,3,2,0,0,0,0,1,1,0,0,0,2,0,2,0,2,0,0,0,0,0,1,0,0,1,0,0,1,1,
1,1,2,0,1,2,1,0,1,1,2,1,1,1,1,1,2,1,1,0,1,0,0,1,1,1,1,1,0,1,1,0,
1,3,2,2,2,1,0,0,2,2,1,0,1,2,2,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,1,
0,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,1,0,2,3,1,2,2,2,2,2,2,1,1,0,0,0,1,0,1,0,2,1,1,1,0,0,0,0,1,
1,1,0,1,1,0,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
2,0,2,0,0,1,0,3,2,1,2,1,2,2,0,1,0,0,0,2,1,0,0,2,1,1,1,1,0,2,0,2,
2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,0,1,
1,2,2,2,2,1,0,0,1,0,0,0,0,0,2,0,1,1,1,1,0,0,0,0,1,0,1,2,0,0,2,0,
1,0,1,1,1,2,1,0,1,0,1,1,0,0,1,0,1,1,1,0,1,0,0,0,1,0,0,1,0,1,1,0,
2,1,2,2,2,0,3,0,1,1,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,
1,2,2,3,2,2,0,0,1,1,2,0,1,2,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,
0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,
2,2,1,1,2,1,2,2,2,2,2,1,2,2,0,1,0,0,0,1,2,2,2,1,2,1,1,1,1,1,2,1,
1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,1,
1,2,2,2,2,0,1,0,2,2,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,
0,0,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,2,2,2,2,0,0,0,2,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
0,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,2,2,2,2,0,0,0,0,1,0,0,1,1,2,0,0,0,0,1,0,1,0,0,1,0,0,2,0,0,0,1,
0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
1,2,2,2,1,1,2,0,2,1,1,1,1,0,2,2,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,
0,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
1,0,2,1,2,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,
0,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,
1,0,0,0,0,2,0,1,2,1,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,1,
0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,
2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,1,1,0,1,0,1,0,0,1,1,1,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,0,0,
0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
)

Koi8rModel = {
  'charToOrderMap': KOI8R_CharToOrderMap,
  'precedenceMatrix': RussianLangModel,
  'mTypicalPositiveRatio': 0.976601,
  'keepEnglishLetter': False,
  'charsetName': "KOI8-R"
}

Win1251CyrillicModel = {
  'charToOrderMap': win1251_CharToOrderMap,
  'precedenceMatrix': RussianLangModel,
  'mTypicalPositiveRatio': 0.976601,
  'keepEnglishLetter': False,
  'charsetName': "windows-1251"
}

Latin5CyrillicModel = {
  'charToOrderMap': latin5_CharToOrderMap,
  'precedenceMatrix': RussianLangModel,
  'mTypicalPositiveRatio': 0.976601,
  'keepEnglishLetter': False,
  'charsetName': "ISO-8859-5"
}

MacCyrillicModel = {
  'charToOrderMap': macCyrillic_CharToOrderMap,
  'precedenceMatrix': RussianLangModel,
  'mTypicalPositiveRatio': 0.976601,
  'keepEnglishLetter': False,
  'charsetName': "MacCyrillic"
};

Ibm866Model = {
  'charToOrderMap': IBM866_CharToOrderMap,
  'precedenceMatrix': RussianLangModel,
  'mTypicalPositiveRatio': 0.976601,
  'keepEnglishLetter': False,
  'charsetName': "IBM866"
}

Ibm855Model = {
  'charToOrderMap': IBM855_CharToOrderMap,
  'precedenceMatrix': RussianLangModel,
  'mTypicalPositiveRatio': 0.976601,
  'keepEnglishLetter': False,
  'charsetName': "IBM855"
}

# flake8: noqa

########NEW FILE########
__FILENAME__ = langgreekmodel
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# 255: Control characters that usually does not exist in any text
# 254: Carriage/Return
# 253: symbol (punctuation) that does not belong to word
# 252: 0 - 9

# Character Mapping Table:
Latin7_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253, 82,100,104, 94, 98,101,116,102,111,187,117, 92, 88,113, 85,  # 40
 79,118,105, 83, 67,114,119, 95, 99,109,188,253,253,253,253,253,  # 50
253, 72, 70, 80, 81, 60, 96, 93, 89, 68,120, 97, 77, 86, 69, 55,  # 60
 78,115, 65, 66, 58, 76,106,103, 87,107,112,253,253,253,253,253,  # 70
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 80
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 90
253,233, 90,253,253,253,253,253,253,253,253,253,253, 74,253,253,  # a0
253,253,253,253,247,248, 61, 36, 46, 71, 73,253, 54,253,108,123,  # b0
110, 31, 51, 43, 41, 34, 91, 40, 52, 47, 44, 53, 38, 49, 59, 39,  # c0
 35, 48,250, 37, 33, 45, 56, 50, 84, 57,120,121, 17, 18, 22, 15,  # d0
124,  1, 29, 20, 21,  3, 32, 13, 25,  5, 11, 16, 10,  6, 30,  4,  # e0
  9,  8, 14,  7,  2, 12, 28, 23, 42, 24, 64, 75, 19, 26, 27,253,  # f0
)

win1253_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253, 82,100,104, 94, 98,101,116,102,111,187,117, 92, 88,113, 85,  # 40
 79,118,105, 83, 67,114,119, 95, 99,109,188,253,253,253,253,253,  # 50
253, 72, 70, 80, 81, 60, 96, 93, 89, 68,120, 97, 77, 86, 69, 55,  # 60
 78,115, 65, 66, 58, 76,106,103, 87,107,112,253,253,253,253,253,  # 70
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 80
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 90
253,233, 61,253,253,253,253,253,253,253,253,253,253, 74,253,253,  # a0
253,253,253,253,247,253,253, 36, 46, 71, 73,253, 54,253,108,123,  # b0
110, 31, 51, 43, 41, 34, 91, 40, 52, 47, 44, 53, 38, 49, 59, 39,  # c0
 35, 48,250, 37, 33, 45, 56, 50, 84, 57,120,121, 17, 18, 22, 15,  # d0
124,  1, 29, 20, 21,  3, 32, 13, 25,  5, 11, 16, 10,  6, 30,  4,  # e0
  9,  8, 14,  7,  2, 12, 28, 23, 42, 24, 64, 75, 19, 26, 27,253,  # f0
)

# Model Table:
# total sequences: 100%
# first 512 sequences: 98.2851%
# first 1024 sequences:1.7001%
# rest  sequences:     0.0359%
# negative sequences:  0.0148%
GreekLangModel = (
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,2,2,3,3,3,3,3,3,3,3,1,3,3,3,0,2,2,3,3,0,3,0,3,2,0,3,3,3,0,
3,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,0,3,3,0,3,2,3,3,0,3,2,3,3,3,0,0,3,0,3,0,3,3,2,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,
0,2,3,2,2,3,3,3,3,3,3,3,3,0,3,3,3,3,0,2,3,3,0,3,3,3,3,2,3,3,3,0,
2,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,0,2,1,3,3,3,3,2,3,3,2,3,3,2,0,
0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,0,3,3,3,3,3,3,0,3,3,0,3,3,3,3,3,3,3,3,3,3,0,3,2,3,3,0,
2,0,1,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,2,3,0,0,0,0,3,3,0,3,1,3,3,3,0,3,3,0,3,3,3,3,0,0,0,0,
2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,0,3,0,3,3,3,3,3,0,3,2,2,2,3,0,2,3,3,3,3,3,2,3,3,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,3,2,2,2,3,3,3,3,0,3,1,3,3,3,3,2,3,3,3,3,3,3,3,2,2,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,2,0,3,0,0,0,3,3,2,3,3,3,3,3,0,0,3,2,3,0,2,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,3,0,0,3,3,0,2,3,0,3,0,3,3,3,0,0,3,0,3,0,2,2,3,3,0,0,
0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,2,0,3,2,3,3,3,3,0,3,3,3,3,3,0,3,3,2,3,2,3,3,2,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,2,3,2,3,3,3,3,3,3,0,2,3,2,3,2,2,2,3,2,3,3,2,3,0,2,2,2,3,0,
2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,0,0,0,3,3,3,2,3,3,0,0,3,0,3,0,0,0,3,2,0,3,0,3,0,0,2,0,2,0,
0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,0,3,3,3,3,3,3,0,3,3,0,3,0,0,0,3,3,0,3,3,3,0,0,1,2,3,0,
3,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,2,0,0,3,2,2,3,3,0,3,3,3,3,3,2,1,3,0,3,2,3,3,2,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,3,0,2,3,3,3,3,3,3,0,0,3,0,3,0,0,0,3,3,0,3,2,3,0,0,3,3,3,0,
3,0,0,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,0,3,3,3,3,3,3,0,0,3,0,3,0,0,0,3,2,0,3,2,3,0,0,3,2,3,0,
2,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,1,2,2,3,3,3,3,3,3,0,2,3,0,3,0,0,0,3,3,0,3,0,2,0,0,2,3,1,0,
2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,3,0,3,0,3,3,2,3,0,3,3,3,3,3,3,0,3,3,3,0,2,3,0,0,3,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,0,0,3,0,0,0,3,3,0,3,0,2,3,3,0,0,3,0,3,0,3,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,0,0,0,3,3,3,3,3,3,0,0,3,0,2,0,0,0,3,3,0,3,0,3,0,0,2,0,2,0,
0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,3,0,3,0,2,0,3,2,0,3,2,3,2,3,0,0,3,2,3,2,3,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,0,0,2,3,3,3,3,3,0,0,0,3,0,2,1,0,0,3,2,2,2,0,3,0,0,2,2,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,2,0,3,0,3,0,3,3,0,2,1,2,3,3,0,0,3,0,3,0,3,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,3,3,3,0,3,3,3,3,3,3,0,2,3,0,3,0,0,0,2,1,0,2,2,3,0,0,2,2,2,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,0,0,2,3,3,3,2,3,0,0,1,3,0,2,0,0,0,0,3,0,1,0,2,0,0,1,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,1,0,3,0,0,0,3,2,0,3,2,3,3,3,0,0,3,0,3,2,2,2,1,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,0,0,3,0,0,0,0,2,0,2,3,3,2,2,2,2,3,0,2,0,2,2,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,2,0,0,0,0,0,0,2,3,0,2,0,2,3,2,0,0,3,0,3,0,3,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,3,2,3,3,2,2,3,0,2,0,3,0,0,0,2,0,0,0,0,1,2,0,2,0,2,0,
0,2,0,2,0,2,2,0,0,1,0,2,2,2,0,2,2,2,0,2,2,2,0,0,2,0,0,1,0,0,0,0,
0,2,0,3,3,2,0,0,0,0,0,0,1,3,0,2,0,2,2,2,0,0,2,0,3,0,0,2,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,2,3,2,0,2,2,0,2,0,2,2,0,2,0,2,2,2,0,0,0,0,0,0,2,3,0,0,0,2,
0,1,2,0,0,0,0,2,2,0,0,0,2,1,0,2,2,0,0,0,0,0,0,1,0,2,0,0,0,0,0,0,
0,0,2,1,0,2,3,2,2,3,2,3,2,0,0,3,3,3,0,0,3,2,0,0,0,1,1,0,2,0,2,2,
0,2,0,2,0,2,2,0,0,2,0,2,2,2,0,2,2,2,2,0,0,2,0,0,0,2,0,1,0,0,0,0,
0,3,0,3,3,2,2,0,3,0,0,0,2,2,0,2,2,2,1,2,0,0,1,2,2,0,0,3,0,0,0,2,
0,1,2,0,0,0,1,2,0,0,0,0,0,0,0,2,2,0,1,0,0,2,0,0,0,2,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,3,3,2,2,0,0,0,2,0,2,3,3,0,2,0,0,0,0,0,0,2,2,2,0,2,2,0,2,0,2,
0,2,2,0,0,2,2,2,2,1,0,0,2,2,0,2,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,
0,2,0,3,2,3,0,0,0,3,0,0,2,2,0,2,0,2,2,2,0,0,2,0,0,0,0,0,0,0,0,2,
0,0,2,2,0,0,2,2,2,0,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,2,0,0,3,2,0,2,2,2,2,2,0,0,0,2,0,0,0,0,2,0,1,0,0,2,0,1,0,0,0,
0,2,2,2,0,2,2,0,1,2,0,2,2,2,0,2,2,2,2,1,2,2,0,0,2,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,2,0,2,0,2,2,0,0,0,0,1,2,1,0,0,2,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,3,2,3,0,0,2,0,0,0,2,2,0,2,0,0,0,1,0,0,2,0,2,0,2,2,0,0,0,0,
0,0,2,0,0,0,0,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,
0,2,2,3,2,2,0,0,0,0,0,0,1,3,0,2,0,2,2,0,0,0,1,0,2,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,2,0,3,2,0,2,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
0,0,2,0,0,0,0,1,1,0,0,2,1,2,0,2,2,0,1,0,0,1,0,0,0,2,0,0,0,0,0,0,
0,3,0,2,2,2,0,0,2,0,0,0,2,0,0,0,2,3,0,2,0,0,0,0,0,0,2,2,0,0,0,2,
0,1,2,0,0,0,1,2,2,1,0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,1,2,0,2,2,0,2,0,0,2,0,0,0,0,1,2,1,0,2,1,0,0,0,0,0,0,0,0,0,0,
0,0,2,0,0,0,3,1,2,2,0,2,0,0,0,0,2,0,0,0,2,0,0,3,0,0,0,0,2,2,2,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,1,0,2,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,2,
0,2,2,0,0,2,2,2,2,2,0,1,2,0,0,0,2,2,0,1,0,2,0,0,2,2,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,3,0,0,2,0,0,0,0,0,0,0,0,2,0,2,0,0,0,0,2,
0,1,2,0,0,0,0,2,2,1,0,1,0,1,0,2,2,2,1,0,0,0,0,0,0,1,0,0,0,0,0,0,
0,2,0,1,2,0,0,0,0,0,0,0,0,0,0,2,0,0,2,2,0,0,0,0,1,0,0,0,0,0,0,2,
0,2,2,0,0,0,0,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,
0,2,2,2,2,0,0,0,3,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,1,
0,0,2,0,0,0,0,1,2,0,0,0,0,0,0,2,2,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,
0,2,0,2,2,2,0,0,2,0,0,0,0,0,0,0,2,2,2,0,0,0,2,0,0,0,0,0,0,0,0,2,
0,0,1,0,0,0,0,2,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
0,3,0,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,2,
0,0,2,0,0,0,0,2,2,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,2,2,1,0,0,0,0,0,0,2,0,0,2,0,2,2,2,0,0,0,0,0,0,2,0,0,0,0,2,
0,0,2,0,0,2,0,2,2,0,0,0,0,2,0,2,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,
0,0,3,0,0,0,2,2,0,2,2,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0,0,
0,2,2,2,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,
0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,2,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,2,0,0,0,2,0,0,0,0,0,1,0,0,0,0,2,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,2,0,0,0,
0,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,2,0,2,0,0,0,
0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,2,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
)

Latin7GreekModel = {
  'charToOrderMap': Latin7_CharToOrderMap,
  'precedenceMatrix': GreekLangModel,
  'mTypicalPositiveRatio': 0.982851,
  'keepEnglishLetter': False,
  'charsetName': "ISO-8859-7"
}

Win1253GreekModel = {
  'charToOrderMap': win1253_CharToOrderMap,
  'precedenceMatrix': GreekLangModel,
  'mTypicalPositiveRatio': 0.982851,
  'keepEnglishLetter': False,
  'charsetName': "windows-1253"
}

# flake8: noqa

########NEW FILE########
__FILENAME__ = langhebrewmodel
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
#          Simon Montagu
# Portions created by the Initial Developer are Copyright (C) 2005
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#   Shoshannah Forbes - original C code (?)
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# 255: Control characters that usually does not exist in any text
# 254: Carriage/Return
# 253: symbol (punctuation) that does not belong to word
# 252: 0 - 9

# Windows-1255 language model
# Character Mapping Table:
win1255_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253, 69, 91, 79, 80, 92, 89, 97, 90, 68,111,112, 82, 73, 95, 85,  # 40
 78,121, 86, 71, 67,102,107, 84,114,103,115,253,253,253,253,253,  # 50
253, 50, 74, 60, 61, 42, 76, 70, 64, 53,105, 93, 56, 65, 54, 49,  # 60
 66,110, 51, 43, 44, 63, 81, 77, 98, 75,108,253,253,253,253,253,  # 70
124,202,203,204,205, 40, 58,206,207,208,209,210,211,212,213,214,
215, 83, 52, 47, 46, 72, 32, 94,216,113,217,109,218,219,220,221,
 34,116,222,118,100,223,224,117,119,104,125,225,226, 87, 99,227,
106,122,123,228, 55,229,230,101,231,232,120,233, 48, 39, 57,234,
 30, 59, 41, 88, 33, 37, 36, 31, 29, 35,235, 62, 28,236,126,237,
238, 38, 45,239,240,241,242,243,127,244,245,246,247,248,249,250,
  9,  8, 20, 16,  3,  2, 24, 14, 22,  1, 25, 15,  4, 11,  6, 23,
 12, 19, 13, 26, 18, 27, 21, 17,  7, 10,  5,251,252,128, 96,253,
)

# Model Table:
# total sequences: 100%
# first 512 sequences: 98.4004%
# first 1024 sequences: 1.5981%
# rest  sequences:      0.087%
# negative sequences:   0.0015%
HebrewLangModel = (
0,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,2,3,2,1,2,0,1,0,0,
3,0,3,1,0,0,1,3,2,0,1,1,2,0,2,2,2,1,1,1,1,2,1,1,1,2,0,0,2,2,0,1,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,
1,2,1,2,1,2,0,0,2,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,
1,2,1,3,1,1,0,0,2,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,1,2,2,1,3,
1,2,1,1,2,2,0,0,2,2,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,2,2,2,2,3,2,
1,2,1,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,2,3,2,2,3,2,2,2,1,2,2,2,2,
1,2,1,1,2,2,0,1,2,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,0,2,2,2,2,2,
0,2,0,2,2,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,0,2,2,2,
0,2,1,2,2,2,0,0,2,1,0,0,0,0,1,0,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1,2,3,2,2,2,
1,2,1,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,
3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,2,0,2,
0,2,1,2,2,2,0,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,2,3,2,2,3,2,1,2,1,1,1,
0,1,1,1,1,1,3,0,1,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,0,
0,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,
0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,2,3,3,3,2,1,2,3,3,2,3,3,3,3,2,3,2,1,2,0,2,1,2,
0,2,0,2,2,2,0,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,
3,3,3,3,3,3,3,3,3,2,3,3,3,1,2,2,3,3,2,3,2,3,2,2,3,1,2,2,0,2,2,2,
0,2,1,2,2,2,0,0,1,2,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,2,2,2,3,3,3,3,1,3,2,2,2,
0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,3,3,3,2,3,2,2,2,1,2,2,0,2,2,2,2,
0,2,0,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,1,3,2,3,3,2,3,3,2,2,1,2,2,2,2,2,2,
0,2,1,2,1,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,2,3,2,3,3,2,3,3,3,3,2,3,2,3,3,3,3,3,2,2,2,2,2,2,2,1,
0,2,0,1,2,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,2,1,2,3,3,3,3,3,3,3,2,3,2,3,2,1,2,3,0,2,1,2,2,
0,2,1,1,2,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,0,
3,3,3,3,3,3,3,3,3,2,3,3,3,3,2,1,3,1,2,2,2,1,2,3,3,1,2,1,2,2,2,2,
0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,0,2,3,3,3,1,3,3,3,1,2,2,2,2,1,1,2,2,2,2,2,2,
0,2,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,2,3,3,3,2,2,3,3,3,2,1,2,3,2,3,2,2,2,2,1,2,1,1,1,2,2,
0,2,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,
1,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,2,3,3,2,3,1,2,2,2,2,3,2,3,1,1,2,2,1,2,2,1,1,0,2,2,2,2,
0,1,0,1,2,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,0,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,0,
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
3,2,2,1,2,2,2,2,2,2,2,1,2,2,1,2,2,1,1,1,1,1,1,1,1,2,1,1,0,3,3,3,
0,3,0,2,2,2,2,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
2,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,1,1,1,2,0,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,0,0,0,0,0,0,
0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,0,2,1,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
0,3,1,1,2,2,2,2,2,1,2,2,2,1,1,2,2,2,2,2,2,2,1,2,2,1,0,1,1,1,1,0,
0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,1,1,1,1,2,1,1,2,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,
0,0,2,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,0,0,
2,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,1,2,1,1,1,1,0,0,0,0,
0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,1,2,1,1,2,1,1,1,2,1,2,1,2,0,1,0,1,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,1,2,2,2,1,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,2,1,2,1,1,0,1,0,1,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,1,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,
0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,2,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,1,1,0,0,
0,1,1,1,2,1,2,2,2,0,2,0,2,0,1,1,2,1,1,1,1,2,1,0,1,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,1,0,0,0,0,0,1,0,1,2,2,0,1,0,0,1,1,2,2,1,2,0,2,0,0,0,1,2,0,1,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,2,0,2,1,2,0,2,0,0,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,0,1,0,2,1,1,0,1,0,0,1,1,1,2,2,0,0,1,0,0,0,1,0,0,1,
1,1,2,1,0,1,1,1,0,1,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,2,2,1,
0,2,0,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,1,0,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,1,1,1,1,1,1,1,2,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,0,1,1,0,1,0,0,0,1,1,0,1,
2,0,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,0,1,1,2,1,1,2,0,1,0,0,0,1,1,0,1,
1,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,0,0,2,1,1,2,0,2,0,0,0,1,1,0,1,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,2,1,1,0,1,0,0,2,2,1,2,1,1,0,1,0,0,0,1,1,0,1,
2,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,2,2,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,1,0,1,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,2,2,0,0,0,0,2,1,1,1,0,2,1,1,0,0,0,2,1,0,1,
1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,1,1,0,2,1,1,0,1,0,0,0,1,1,0,1,
2,2,1,1,1,0,1,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,2,1,1,0,1,0,0,1,1,0,1,2,1,0,2,0,0,0,1,1,0,1,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,
0,1,0,0,2,0,2,1,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,0,0,1,
1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,1,0,1,1,0,0,1,0,0,2,1,1,1,1,1,0,1,0,0,0,0,1,0,1,
0,1,1,1,2,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0,0,1,1,0,0,
)

Win1255HebrewModel = {
  'charToOrderMap': win1255_CharToOrderMap,
  'precedenceMatrix': HebrewLangModel,
  'mTypicalPositiveRatio': 0.984004,
  'keepEnglishLetter': False,
  'charsetName': "windows-1255"
}

# flake8: noqa

########NEW FILE########
__FILENAME__ = langhungarianmodel
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# 255: Control characters that usually does not exist in any text
# 254: Carriage/Return
# 253: symbol (punctuation) that does not belong to word
# 252: 0 - 9

# Character Mapping Table:
Latin2_HungarianCharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253, 28, 40, 54, 45, 32, 50, 49, 38, 39, 53, 36, 41, 34, 35, 47,
 46, 71, 43, 33, 37, 57, 48, 64, 68, 55, 52,253,253,253,253,253,
253,  2, 18, 26, 17,  1, 27, 12, 20,  9, 22,  7,  6, 13,  4,  8,
 23, 67, 10,  5,  3, 21, 19, 65, 62, 16, 11,253,253,253,253,253,
159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,
175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,
191,192,193,194,195,196,197, 75,198,199,200,201,202,203,204,205,
 79,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
221, 51, 81,222, 78,223,224,225,226, 44,227,228,229, 61,230,231,
232,233,234, 58,235, 66, 59,236,237,238, 60, 69, 63,239,240,241,
 82, 14, 74,242, 70, 80,243, 72,244, 15, 83, 77, 84, 30, 76, 85,
245,246,247, 25, 73, 42, 24,248,249,250, 31, 56, 29,251,252,253,
)

win1250HungarianCharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253, 28, 40, 54, 45, 32, 50, 49, 38, 39, 53, 36, 41, 34, 35, 47,
 46, 72, 43, 33, 37, 57, 48, 64, 68, 55, 52,253,253,253,253,253,
253,  2, 18, 26, 17,  1, 27, 12, 20,  9, 22,  7,  6, 13,  4,  8,
 23, 67, 10,  5,  3, 21, 19, 65, 62, 16, 11,253,253,253,253,253,
161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
177,178,179,180, 78,181, 69,182,183,184,185,186,187,188,189,190,
191,192,193,194,195,196,197, 76,198,199,200,201,202,203,204,205,
 81,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
221, 51, 83,222, 80,223,224,225,226, 44,227,228,229, 61,230,231,
232,233,234, 58,235, 66, 59,236,237,238, 60, 70, 63,239,240,241,
 84, 14, 75,242, 71, 82,243, 73,244, 15, 85, 79, 86, 30, 77, 87,
245,246,247, 25, 74, 42, 24,248,249,250, 31, 56, 29,251,252,253,
)

# Model Table:
# total sequences: 100%
# first 512 sequences: 94.7368%
# first 1024 sequences:5.2623%
# rest  sequences:     0.8894%
# negative sequences:  0.0009%
HungarianLangModel = (
0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,2,2,3,3,1,1,2,2,2,2,2,1,2,
3,2,2,3,3,3,3,3,2,3,3,3,3,3,3,1,2,3,3,3,3,2,3,3,1,1,3,3,0,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,
3,2,1,3,3,3,3,3,2,3,3,3,3,3,1,1,2,3,3,3,3,3,3,3,1,1,3,2,0,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,1,1,2,3,3,3,1,3,3,3,3,3,1,3,3,2,2,0,3,2,3,
0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,3,3,3,2,3,3,2,3,3,3,3,3,2,3,3,2,2,3,2,3,2,0,3,2,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
3,3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,1,2,3,2,2,3,1,2,3,3,2,2,0,3,3,3,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,3,2,3,3,3,3,2,3,3,3,3,0,2,3,2,
0,0,0,1,1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,1,1,1,3,3,2,1,3,2,2,3,2,1,3,2,2,1,0,3,3,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,2,2,3,3,3,3,3,1,2,3,3,3,3,1,2,1,3,3,3,3,2,2,3,1,1,3,2,0,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,2,1,3,3,3,3,3,2,2,1,3,3,3,0,1,1,2,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,2,3,3,3,2,0,3,2,3,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,1,0,
3,3,3,3,3,3,2,3,3,3,2,3,2,3,3,3,1,3,2,2,2,3,1,1,3,3,1,1,0,3,3,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,2,3,3,3,2,3,2,3,3,3,2,3,3,3,3,3,1,2,3,2,2,0,2,2,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,2,2,2,3,1,3,3,2,2,1,3,3,3,1,1,3,1,2,3,2,3,2,2,2,1,0,2,2,2,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,
3,1,1,3,3,3,3,3,1,2,3,3,3,3,1,2,1,3,3,3,2,2,3,2,1,0,3,2,0,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,3,3,3,3,3,1,2,3,3,3,3,1,1,0,3,3,3,3,0,2,3,0,0,2,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,2,3,3,2,2,2,2,3,3,0,1,2,3,2,3,2,2,3,2,1,2,0,2,2,2,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,
3,3,3,3,3,3,1,2,3,3,3,2,1,2,3,3,2,2,2,3,2,3,3,1,3,3,1,1,0,2,3,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,1,2,2,2,2,3,3,3,1,1,1,3,3,1,1,3,1,1,3,2,1,2,3,1,1,0,2,2,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,2,1,2,1,1,3,3,1,1,1,1,3,3,1,1,2,2,1,2,1,1,2,2,1,1,0,2,2,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,1,1,2,1,1,3,3,1,0,1,1,3,3,2,0,1,1,2,3,1,0,2,2,1,0,0,1,3,2,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,2,1,3,3,3,3,3,1,2,3,2,3,3,2,1,1,3,2,3,2,1,2,2,0,1,2,1,0,0,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,2,2,2,2,3,1,2,2,1,1,3,3,0,3,2,1,2,3,2,1,3,3,1,1,0,2,1,3,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,2,2,2,3,2,3,3,3,2,1,1,3,3,1,1,1,2,2,3,2,3,2,2,2,1,0,2,2,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
1,0,0,3,3,3,3,3,0,0,3,3,2,3,0,0,0,2,3,3,1,0,1,2,0,0,1,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,2,3,3,3,3,3,1,2,3,3,2,2,1,1,0,3,3,2,2,1,2,2,1,0,2,2,0,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,2,2,1,3,1,2,3,3,2,2,1,1,2,2,1,1,1,1,3,2,1,1,1,1,2,1,0,1,2,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
2,3,3,1,1,1,1,1,3,3,3,0,1,1,3,3,1,1,1,1,1,2,2,0,3,1,1,2,0,2,1,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,1,0,1,2,1,2,2,0,1,2,3,1,2,0,0,0,2,1,1,1,1,1,2,0,0,1,1,0,0,0,0,
1,2,1,2,2,2,1,2,1,2,0,2,0,2,2,1,1,2,1,1,2,1,1,1,0,1,0,0,0,1,1,0,
1,1,1,2,3,2,3,3,0,1,2,2,3,1,0,1,0,2,1,2,2,0,1,1,0,0,1,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,3,3,2,2,1,0,0,3,2,3,2,0,0,0,1,1,3,0,0,1,1,0,0,2,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,2,2,3,3,1,0,1,3,2,3,1,1,1,0,1,1,1,1,1,3,1,0,0,2,2,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,1,2,2,2,1,0,1,2,3,3,2,0,0,0,2,1,1,1,2,1,1,1,0,1,1,1,0,0,0,
1,2,2,2,2,2,1,1,1,2,0,2,1,1,1,1,1,2,1,1,1,1,1,1,0,1,1,1,0,0,1,1,
3,2,2,1,0,0,1,1,2,2,0,3,0,1,2,1,1,0,0,1,1,1,0,1,1,1,1,0,2,1,1,1,
2,2,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1,1,1,2,3,1,1,1,1,1,1,1,1,1,0,1,
2,3,3,0,1,0,0,0,3,3,1,0,0,1,2,2,1,0,0,0,0,2,0,0,1,1,1,0,2,1,1,1,
2,1,1,1,1,1,1,2,1,1,0,1,1,0,1,1,1,0,1,2,1,1,0,1,1,1,1,1,1,1,0,1,
2,3,3,0,1,0,0,0,2,2,0,0,0,0,1,2,2,0,0,0,0,1,0,0,1,1,0,0,2,0,1,0,
2,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,0,1,1,1,1,1,0,1,
3,2,2,0,1,0,1,0,2,3,2,0,0,1,2,2,1,0,0,1,1,1,0,0,2,1,0,1,2,2,1,1,
2,1,1,1,1,1,1,2,1,1,1,1,1,1,0,2,1,0,1,1,0,1,1,1,0,1,1,2,1,1,0,1,
2,2,2,0,0,1,0,0,2,2,1,1,0,0,2,1,1,0,0,0,1,2,0,0,2,1,0,0,2,1,1,1,
2,1,1,1,1,2,1,2,1,1,1,2,2,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,0,1,
1,2,3,0,0,0,1,0,3,2,1,0,0,1,2,1,1,0,0,0,0,2,1,0,1,1,0,0,2,1,2,1,
1,1,0,0,0,1,0,1,1,1,1,1,2,0,0,1,0,0,0,2,0,0,1,1,1,1,1,1,1,1,0,1,
3,0,0,2,1,2,2,1,0,0,2,1,2,2,0,0,0,2,1,1,1,0,1,1,0,0,1,1,2,0,0,0,
1,2,1,2,2,1,1,2,1,2,0,1,1,1,1,1,1,1,1,1,2,1,1,0,0,1,1,1,1,0,0,1,
1,3,2,0,0,0,1,0,2,2,2,0,0,0,2,2,1,0,0,0,0,3,1,1,1,1,0,0,2,1,1,1,
2,1,0,1,1,1,0,1,1,1,1,1,1,1,0,2,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,1,
2,3,2,0,0,0,1,0,2,2,0,0,0,0,2,1,1,0,0,0,0,2,1,0,1,1,0,0,2,1,1,0,
2,1,1,1,1,2,1,2,1,2,0,1,1,1,0,2,1,1,1,2,1,1,1,1,0,1,1,1,1,1,0,1,
3,1,1,2,2,2,3,2,1,1,2,2,1,1,0,1,0,2,2,1,1,1,1,1,0,0,1,1,0,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,0,0,0,0,0,2,2,0,0,0,0,2,2,1,0,0,0,1,1,0,0,1,2,0,0,2,1,1,1,
2,2,1,1,1,2,1,2,1,1,0,1,1,1,1,2,1,1,1,2,1,1,1,1,0,1,2,1,1,1,0,1,
1,0,0,1,2,3,2,1,0,0,2,0,1,1,0,0,0,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,
1,2,1,2,1,2,1,1,1,2,0,2,1,1,1,0,1,2,0,0,1,1,1,0,0,0,0,0,0,0,0,0,
2,3,2,0,0,0,0,0,1,1,2,1,0,0,1,1,1,0,0,0,0,2,0,0,1,1,0,0,2,1,1,1,
2,1,1,1,1,1,1,2,1,0,1,1,1,1,0,2,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,
1,2,2,0,1,1,1,0,2,2,2,0,0,0,3,2,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,0,
1,1,0,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,0,0,1,1,1,0,1,0,1,
2,1,0,2,1,1,2,2,1,1,2,1,1,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,0,0,0,
1,2,2,2,2,2,1,1,1,2,0,2,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,
1,2,3,0,0,0,1,0,2,2,0,0,0,0,2,2,0,0,0,0,0,1,0,0,1,0,0,0,2,0,1,0,
2,1,1,1,1,1,0,2,0,0,0,1,2,1,1,1,1,0,1,2,0,1,0,1,0,1,1,1,0,1,0,1,
2,2,2,0,0,0,1,0,2,1,2,0,0,0,1,1,2,0,0,0,0,1,0,0,1,1,0,0,2,1,0,1,
2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,1,1,1,1,1,0,1,
1,2,2,0,0,0,1,0,2,2,2,0,0,0,1,1,0,0,0,0,0,1,1,0,2,0,0,1,1,1,0,1,
1,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,0,1,
1,0,0,1,0,1,2,1,0,0,1,1,1,2,0,0,0,1,1,0,1,0,1,1,0,0,1,0,0,0,0,0,
0,2,1,2,1,1,1,1,1,2,0,2,0,1,1,0,1,2,1,0,1,1,1,0,0,0,0,0,0,1,0,0,
2,1,1,0,1,2,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,2,1,0,1,
2,2,1,1,1,1,1,2,1,1,0,1,1,1,1,2,1,1,1,2,1,1,0,1,0,1,1,1,1,1,0,1,
1,2,2,0,0,0,0,0,1,1,0,0,0,0,2,1,0,0,0,0,0,2,0,0,2,2,0,0,2,0,0,1,
2,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,
1,1,2,0,0,3,1,0,2,1,1,1,0,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,
1,2,1,0,1,1,1,2,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,0,1,0,0,
2,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,2,0,0,0,
2,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,2,1,1,0,0,1,1,1,1,1,0,1,
2,1,1,1,2,1,1,1,0,1,1,2,1,0,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,0,1,1,1,1,1,0,0,1,1,2,1,0,0,0,1,1,0,0,0,1,1,0,0,1,0,1,0,0,0,
1,2,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,
2,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,2,0,0,1,0,0,1,0,1,0,0,0,
0,1,1,1,1,1,1,1,1,2,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,
1,0,0,1,1,1,1,1,0,0,2,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,
0,1,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,
1,0,0,1,1,1,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
0,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,
2,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,
)

Latin2HungarianModel = {
  'charToOrderMap': Latin2_HungarianCharToOrderMap,
  'precedenceMatrix': HungarianLangModel,
  'mTypicalPositiveRatio': 0.947368,
  'keepEnglishLetter': True,
  'charsetName': "ISO-8859-2"
}

Win1250HungarianModel = {
  'charToOrderMap': win1250HungarianCharToOrderMap,
  'precedenceMatrix': HungarianLangModel,
  'mTypicalPositiveRatio': 0.947368,
  'keepEnglishLetter': True,
  'charsetName': "windows-1250"
}

# flake8: noqa

########NEW FILE########
__FILENAME__ = langthaimodel
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Communicator client code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

# 255: Control characters that usually does not exist in any text
# 254: Carriage/Return
# 253: symbol (punctuation) that does not belong to word
# 252: 0 - 9

# The following result for thai was collected from a limited sample (1M).

# Character Mapping Table:
TIS620CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,  # 00
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,  # 10
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,  # 20
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,  # 30
253,182,106,107,100,183,184,185,101, 94,186,187,108,109,110,111,  # 40
188,189,190, 89, 95,112,113,191,192,193,194,253,253,253,253,253,  # 50
253, 64, 72, 73,114, 74,115,116,102, 81,201,117, 90,103, 78, 82,  # 60
 96,202, 91, 79, 84,104,105, 97, 98, 92,203,253,253,253,253,253,  # 70
209,210,211,212,213, 88,214,215,216,217,218,219,220,118,221,222,
223,224, 99, 85, 83,225,226,227,228,229,230,231,232,233,234,235,
236,  5, 30,237, 24,238, 75,  8, 26, 52, 34, 51,119, 47, 58, 57,
 49, 53, 55, 43, 20, 19, 44, 14, 48,  3, 17, 25, 39, 62, 31, 54,
 45,  9, 16,  2, 61, 15,239, 12, 42, 46, 18, 21, 76,  4, 66, 63,
 22, 10,  1, 36, 23, 13, 40, 27, 32, 35, 86,240,241,242,243,244,
 11, 28, 41, 29, 33,245, 50, 37,  6,  7, 67, 77, 38, 93,246,247,
 68, 56, 59, 65, 69, 60, 70, 80, 71, 87,248,249,250,251,252,253,
)

# Model Table:
# total sequences: 100%
# first 512 sequences: 92.6386%
# first 1024 sequences:7.3177%
# rest  sequences:     1.0230%
# negative sequences:  0.0436%
ThaiLangModel = (
0,1,3,3,3,3,0,0,3,3,0,3,3,0,3,3,3,3,3,3,3,3,0,0,3,3,3,0,3,3,3,3,
0,3,3,0,0,0,1,3,0,3,3,2,3,3,0,1,2,3,3,3,3,0,2,0,2,0,0,3,2,1,2,2,
3,0,3,3,2,3,0,0,3,3,0,3,3,0,3,3,3,3,3,3,3,3,3,0,3,2,3,0,2,2,2,3,
0,2,3,0,0,0,0,1,0,1,2,3,1,1,3,2,2,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,
3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,3,3,2,3,2,3,3,2,2,2,
3,1,2,3,0,3,3,2,2,1,2,3,3,1,2,0,1,3,0,1,0,0,1,0,0,0,0,0,0,0,1,1,
3,3,2,2,3,3,3,3,1,2,3,3,3,3,3,2,2,2,2,3,3,2,2,3,3,2,2,3,2,3,2,2,
3,3,1,2,3,1,2,2,3,3,1,0,2,1,0,0,3,1,2,1,0,0,1,0,0,0,0,0,0,1,0,1,
3,3,3,3,3,3,2,2,3,3,3,3,2,3,2,2,3,3,2,2,3,2,2,2,2,1,1,3,1,2,1,1,
3,2,1,0,2,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,
3,3,3,2,3,2,3,3,2,2,3,2,3,3,2,3,1,1,2,3,2,2,2,3,2,2,2,2,2,1,2,1,
2,2,1,1,3,3,2,1,0,1,2,2,0,1,3,0,0,0,1,1,0,0,0,0,0,2,3,0,0,2,1,1,
3,3,2,3,3,2,0,0,3,3,0,3,3,0,2,2,3,1,2,2,1,1,1,0,2,2,2,0,2,2,1,1,
0,2,1,0,2,0,0,2,0,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,2,3,3,2,0,0,3,3,0,2,3,0,2,1,2,2,2,2,1,2,0,0,2,2,2,0,2,2,1,1,
0,2,1,0,2,0,0,2,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,
3,3,2,3,2,3,2,0,2,2,1,3,2,1,3,2,1,2,3,2,2,3,0,2,3,2,2,1,2,2,2,2,
1,2,2,0,0,0,0,2,0,1,2,0,1,1,1,0,1,0,3,1,1,0,0,0,0,0,0,0,0,0,1,0,
3,3,2,3,3,2,3,2,2,2,3,2,2,3,2,2,1,2,3,2,2,3,1,3,2,2,2,3,2,2,2,3,
3,2,1,3,0,1,1,1,0,2,1,1,1,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,2,0,0,
1,0,0,3,0,3,3,3,3,3,0,0,3,0,2,2,3,3,3,3,3,0,0,0,1,1,3,0,0,0,0,2,
0,0,1,0,0,0,0,0,0,0,2,3,0,0,0,3,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,
2,0,3,3,3,3,0,0,2,3,0,0,3,0,3,3,2,3,3,3,3,3,0,0,3,3,3,0,0,0,3,3,
0,0,3,0,0,0,0,2,0,0,2,1,1,3,0,0,1,0,0,2,3,0,1,0,0,0,0,0,0,0,1,0,
3,3,3,3,2,3,3,3,3,3,3,3,1,2,1,3,3,2,2,1,2,2,2,3,1,1,2,0,2,1,2,1,
2,2,1,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,
3,0,2,1,2,3,3,3,0,2,0,2,2,0,2,1,3,2,2,1,2,1,0,0,2,2,1,0,2,1,2,2,
0,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,2,1,3,3,1,1,3,0,2,3,1,1,3,2,1,1,2,0,2,2,3,2,1,1,1,1,1,2,
3,0,0,1,3,1,2,1,2,0,3,0,0,0,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
3,3,1,1,3,2,3,3,3,1,3,2,1,3,2,1,3,2,2,2,2,1,3,3,1,2,1,3,1,2,3,0,
2,1,1,3,2,2,2,1,2,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
3,3,2,3,2,3,3,2,3,2,3,2,3,3,2,1,0,3,2,2,2,1,2,2,2,1,2,2,1,2,1,1,
2,2,2,3,0,1,3,1,1,1,1,0,1,1,0,2,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,2,3,2,2,1,1,3,2,3,2,3,2,0,3,2,2,1,2,0,2,2,2,1,2,2,2,2,1,
3,2,1,2,2,1,0,2,0,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,2,3,1,2,3,3,2,2,3,0,1,1,2,0,3,3,2,2,3,0,1,1,3,0,0,0,0,
3,1,0,3,3,0,2,0,2,1,0,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,2,3,2,3,3,0,1,3,1,1,2,1,2,1,1,3,1,1,0,2,3,1,1,1,1,1,1,1,1,
3,1,1,2,2,2,2,1,1,1,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
3,2,2,1,1,2,1,3,3,2,3,2,2,3,2,2,3,1,2,2,1,2,0,3,2,1,2,2,2,2,2,1,
3,2,1,2,2,2,1,1,1,1,0,0,1,1,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,1,3,3,0,2,1,0,3,2,0,0,3,1,0,1,1,0,1,0,0,0,0,0,1,
1,0,0,1,0,3,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,2,2,2,3,0,0,1,3,0,3,2,0,3,2,2,3,3,3,3,3,1,0,2,2,2,0,2,2,1,2,
0,2,3,0,0,0,0,1,0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
3,0,2,3,1,3,3,2,3,3,0,3,3,0,3,2,2,3,2,3,3,3,0,0,2,2,3,0,1,1,1,3,
0,0,3,0,0,0,2,2,0,1,3,0,1,2,2,2,3,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
3,2,3,3,2,0,3,3,2,2,3,1,3,2,1,3,2,0,1,2,2,0,2,3,2,1,0,3,0,0,0,0,
3,0,0,2,3,1,3,0,0,3,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,3,2,2,2,1,2,0,1,3,1,1,3,1,3,0,0,2,1,1,1,1,2,1,1,1,0,2,1,0,1,
1,2,0,0,0,3,1,1,0,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,0,3,1,0,0,0,1,0,
3,3,3,3,2,2,2,2,2,1,3,1,1,1,2,0,1,1,2,1,2,1,3,2,0,0,3,1,1,1,1,1,
3,1,0,2,3,0,0,0,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,2,3,0,3,3,0,2,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,2,3,1,3,0,0,1,2,0,0,2,0,3,3,2,3,3,3,2,3,0,0,2,2,2,0,0,0,2,2,
0,0,1,0,0,0,0,3,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
0,0,0,3,0,2,0,0,0,0,0,0,0,0,0,0,1,2,3,1,3,3,0,0,1,0,3,0,0,0,0,0,
0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,1,2,3,1,2,3,1,0,3,0,2,2,1,0,2,1,1,2,0,1,0,0,1,1,1,1,0,1,0,0,
1,0,0,0,0,1,1,0,3,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,2,1,0,1,1,1,3,1,2,2,2,2,2,2,1,1,1,1,0,3,1,0,1,3,1,1,1,1,
1,1,0,2,0,1,3,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1,
3,0,2,2,1,3,3,2,3,3,0,1,1,0,2,2,1,2,1,3,3,1,0,0,3,2,0,0,0,0,2,1,
0,1,0,0,0,0,1,2,0,1,1,3,1,1,2,2,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,0,3,0,0,1,0,0,0,3,0,0,3,0,3,1,0,1,1,1,3,2,0,0,0,3,0,0,0,0,2,0,
0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,
3,3,1,3,2,1,3,3,1,2,2,0,1,2,1,0,1,2,0,0,0,0,0,3,0,0,0,3,0,0,0,0,
3,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,1,2,0,3,3,3,2,2,0,1,1,0,1,3,0,0,0,2,2,0,0,0,0,3,1,0,1,0,0,0,
0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,2,3,1,2,0,0,2,1,0,3,1,0,1,2,0,1,1,1,1,3,0,0,3,1,1,0,2,2,1,1,
0,2,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,0,3,1,2,0,0,2,2,0,1,2,0,1,0,1,3,1,2,1,0,0,0,2,0,3,0,0,0,1,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,1,1,2,2,0,0,0,2,0,2,1,0,1,1,0,1,1,1,2,1,0,0,1,1,1,0,2,1,1,1,
0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1,
0,0,0,2,0,1,3,1,1,1,1,0,0,0,0,3,2,0,1,0,0,0,1,2,0,0,0,1,0,0,0,0,
0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,3,3,3,3,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,2,3,2,2,0,0,0,1,0,0,0,0,2,3,2,1,2,2,3,0,0,0,2,3,1,0,0,0,1,1,
0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,
3,3,2,2,0,1,0,0,0,0,2,0,2,0,1,0,0,0,1,1,0,0,0,2,1,0,1,0,1,1,0,0,
0,1,0,2,0,0,1,0,3,0,1,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,1,0,0,1,0,0,0,0,0,1,1,2,0,0,0,0,1,0,0,1,3,1,0,0,0,0,1,1,0,0,
0,1,0,0,0,0,3,0,0,0,0,0,0,3,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,
3,3,1,1,1,1,2,3,0,0,2,1,1,1,1,1,0,2,1,1,0,0,0,2,1,0,1,2,1,1,0,1,
2,1,0,3,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,3,1,0,0,0,0,0,0,0,3,0,0,0,3,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,
0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,2,0,0,0,0,0,0,1,2,1,0,1,1,0,2,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,0,0,0,1,3,0,1,0,0,0,2,0,0,0,0,0,0,0,1,2,0,0,0,0,0,
3,3,0,0,1,1,2,0,0,1,2,1,0,1,1,1,0,1,1,0,0,2,1,1,0,1,0,0,1,1,1,0,
0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,1,0,0,0,0,1,0,0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,
2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,0,0,1,1,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,0,1,2,0,1,2,0,0,1,1,0,2,0,1,0,0,1,0,0,0,0,1,0,0,0,2,0,0,0,0,
1,0,0,1,0,1,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,1,1,0,1,1,0,2,1,3,0,0,0,0,1,1,0,0,0,0,0,0,0,3,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,1,0,1,0,0,2,0,0,2,0,0,1,1,2,0,0,1,1,0,0,0,1,0,0,0,1,1,0,0,0,
1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,1,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,3,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,
1,0,0,0,0,0,0,0,0,1,0,0,0,0,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,1,0,0,2,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
)

TIS620ThaiModel = {
  'charToOrderMap': TIS620CharToOrderMap,
  'precedenceMatrix': ThaiLangModel,
  'mTypicalPositiveRatio': 0.926386,
  'keepEnglishLetter': False,
  'charsetName': "TIS-620"
}

# flake8: noqa

########NEW FILE########
__FILENAME__ = latin1prober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .charsetprober import CharSetProber
from .constants import eNotMe
from .compat import wrap_ord

FREQ_CAT_NUM = 4

UDF = 0  # undefined
OTH = 1  # other
ASC = 2  # ascii capital letter
ASS = 3  # ascii small letter
ACV = 4  # accent capital vowel
ACO = 5  # accent capital other
ASV = 6  # accent small vowel
ASO = 7  # accent small other
CLASS_NUM = 8  # total classes

Latin1_CharToClass = (
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 00 - 07
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 08 - 0F
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 10 - 17
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 18 - 1F
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 20 - 27
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 28 - 2F
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 30 - 37
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 38 - 3F
    OTH, ASC, ASC, ASC, ASC, ASC, ASC, ASC,   # 40 - 47
    ASC, ASC, ASC, ASC, ASC, ASC, ASC, ASC,   # 48 - 4F
    ASC, ASC, ASC, ASC, ASC, ASC, ASC, ASC,   # 50 - 57
    ASC, ASC, ASC, OTH, OTH, OTH, OTH, OTH,   # 58 - 5F
    OTH, ASS, ASS, ASS, ASS, ASS, ASS, ASS,   # 60 - 67
    ASS, ASS, ASS, ASS, ASS, ASS, ASS, ASS,   # 68 - 6F
    ASS, ASS, ASS, ASS, ASS, ASS, ASS, ASS,   # 70 - 77
    ASS, ASS, ASS, OTH, OTH, OTH, OTH, OTH,   # 78 - 7F
    OTH, UDF, OTH, ASO, OTH, OTH, OTH, OTH,   # 80 - 87
    OTH, OTH, ACO, OTH, ACO, UDF, ACO, UDF,   # 88 - 8F
    UDF, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # 90 - 97
    OTH, OTH, ASO, OTH, ASO, UDF, ASO, ACO,   # 98 - 9F
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # A0 - A7
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # A8 - AF
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # B0 - B7
    OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,   # B8 - BF
    ACV, ACV, ACV, ACV, ACV, ACV, ACO, ACO,   # C0 - C7
    ACV, ACV, ACV, ACV, ACV, ACV, ACV, ACV,   # C8 - CF
    ACO, ACO, ACV, ACV, ACV, ACV, ACV, OTH,   # D0 - D7
    ACV, ACV, ACV, ACV, ACV, ACO, ACO, ACO,   # D8 - DF
    ASV, ASV, ASV, ASV, ASV, ASV, ASO, ASO,   # E0 - E7
    ASV, ASV, ASV, ASV, ASV, ASV, ASV, ASV,   # E8 - EF
    ASO, ASO, ASV, ASV, ASV, ASV, ASV, OTH,   # F0 - F7
    ASV, ASV, ASV, ASV, ASV, ASO, ASO, ASO,   # F8 - FF
)

# 0 : illegal
# 1 : very unlikely
# 2 : normal
# 3 : very likely
Latin1ClassModel = (
    # UDF OTH ASC ASS ACV ACO ASV ASO
    0,  0,  0,  0,  0,  0,  0,  0,  # UDF
    0,  3,  3,  3,  3,  3,  3,  3,  # OTH
    0,  3,  3,  3,  3,  3,  3,  3,  # ASC
    0,  3,  3,  3,  1,  1,  3,  3,  # ASS
    0,  3,  3,  3,  1,  2,  1,  2,  # ACV
    0,  3,  3,  3,  3,  3,  3,  3,  # ACO
    0,  3,  1,  3,  1,  1,  1,  3,  # ASV
    0,  3,  1,  3,  1,  1,  3,  3,  # ASO
)


class Latin1Prober(CharSetProber):
    def __init__(self):
        CharSetProber.__init__(self)
        self.reset()

    def reset(self):
        self._mLastCharClass = OTH
        self._mFreqCounter = [0] * FREQ_CAT_NUM
        CharSetProber.reset(self)

    def get_charset_name(self):
        return "windows-1252"

    def feed(self, aBuf):
        aBuf = self.filter_with_english_letters(aBuf)
        for c in aBuf:
            charClass = Latin1_CharToClass[wrap_ord(c)]
            freq = Latin1ClassModel[(self._mLastCharClass * CLASS_NUM)
                                    + charClass]
            if freq == 0:
                self._mState = eNotMe
                break
            self._mFreqCounter[freq] += 1
            self._mLastCharClass = charClass

        return self.get_state()

    def get_confidence(self):
        if self.get_state() == eNotMe:
            return 0.01

        total = sum(self._mFreqCounter)
        if total < 0.01:
            confidence = 0.0
        else:
            confidence = ((self._mFreqCounter[3] / total)
                          - (self._mFreqCounter[1] * 20.0 / total))
        if confidence < 0.0:
            confidence = 0.0
        # lower the confidence of latin1 so that other more accurate
        # detector can take priority.
        confidence = confidence * 0.5
        return confidence

########NEW FILE########
__FILENAME__ = mbcharsetprober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#   Proofpoint, Inc.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

import sys
from . import constants
from .charsetprober import CharSetProber


class MultiByteCharSetProber(CharSetProber):
    def __init__(self):
        CharSetProber.__init__(self)
        self._mDistributionAnalyzer = None
        self._mCodingSM = None
        self._mLastChar = [0, 0]

    def reset(self):
        CharSetProber.reset(self)
        if self._mCodingSM:
            self._mCodingSM.reset()
        if self._mDistributionAnalyzer:
            self._mDistributionAnalyzer.reset()
        self._mLastChar = [0, 0]

    def get_charset_name(self):
        pass

    def feed(self, aBuf):
        aLen = len(aBuf)
        for i in range(0, aLen):
            codingState = self._mCodingSM.next_state(aBuf[i])
            if codingState == constants.eError:
                if constants._debug:
                    sys.stderr.write(self.get_charset_name()
                                     + ' prober hit error at byte ' + str(i)
                                     + '\n')
                self._mState = constants.eNotMe
                break
            elif codingState == constants.eItsMe:
                self._mState = constants.eFoundIt
                break
            elif codingState == constants.eStart:
                charLen = self._mCodingSM.get_current_charlen()
                if i == 0:
                    self._mLastChar[1] = aBuf[0]
                    self._mDistributionAnalyzer.feed(self._mLastChar, charLen)
                else:
                    self._mDistributionAnalyzer.feed(aBuf[i - 1:i + 1],
                                                     charLen)

        self._mLastChar[0] = aBuf[aLen - 1]

        if self.get_state() == constants.eDetecting:
            if (self._mDistributionAnalyzer.got_enough_data() and
                    (self.get_confidence() > constants.SHORTCUT_THRESHOLD)):
                self._mState = constants.eFoundIt

        return self.get_state()

    def get_confidence(self):
        return self._mDistributionAnalyzer.get_confidence()

########NEW FILE########
__FILENAME__ = mbcsgroupprober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#   Proofpoint, Inc.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .charsetgroupprober import CharSetGroupProber
from .utf8prober import UTF8Prober
from .sjisprober import SJISProber
from .eucjpprober import EUCJPProber
from .gb2312prober import GB2312Prober
from .euckrprober import EUCKRProber
from .cp949prober import CP949Prober
from .big5prober import Big5Prober
from .euctwprober import EUCTWProber


class MBCSGroupProber(CharSetGroupProber):
    def __init__(self):
        CharSetGroupProber.__init__(self)
        self._mProbers = [
            UTF8Prober(),
            SJISProber(),
            EUCJPProber(),
            GB2312Prober(),
            EUCKRProber(),
            CP949Prober(),
            Big5Prober(),
            EUCTWProber()
        ]
        self.reset()

########NEW FILE########
__FILENAME__ = mbcssm
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .constants import eStart, eError, eItsMe

# BIG5

BIG5_cls = (
    1,1,1,1,1,1,1,1,  # 00 - 07    #allow 0x00 as legal value
    1,1,1,1,1,1,0,0,  # 08 - 0f
    1,1,1,1,1,1,1,1,  # 10 - 17
    1,1,1,0,1,1,1,1,  # 18 - 1f
    1,1,1,1,1,1,1,1,  # 20 - 27
    1,1,1,1,1,1,1,1,  # 28 - 2f
    1,1,1,1,1,1,1,1,  # 30 - 37
    1,1,1,1,1,1,1,1,  # 38 - 3f
    2,2,2,2,2,2,2,2,  # 40 - 47
    2,2,2,2,2,2,2,2,  # 48 - 4f
    2,2,2,2,2,2,2,2,  # 50 - 57
    2,2,2,2,2,2,2,2,  # 58 - 5f
    2,2,2,2,2,2,2,2,  # 60 - 67
    2,2,2,2,2,2,2,2,  # 68 - 6f
    2,2,2,2,2,2,2,2,  # 70 - 77
    2,2,2,2,2,2,2,1,  # 78 - 7f
    4,4,4,4,4,4,4,4,  # 80 - 87
    4,4,4,4,4,4,4,4,  # 88 - 8f
    4,4,4,4,4,4,4,4,  # 90 - 97
    4,4,4,4,4,4,4,4,  # 98 - 9f
    4,3,3,3,3,3,3,3,  # a0 - a7
    3,3,3,3,3,3,3,3,  # a8 - af
    3,3,3,3,3,3,3,3,  # b0 - b7
    3,3,3,3,3,3,3,3,  # b8 - bf
    3,3,3,3,3,3,3,3,  # c0 - c7
    3,3,3,3,3,3,3,3,  # c8 - cf
    3,3,3,3,3,3,3,3,  # d0 - d7
    3,3,3,3,3,3,3,3,  # d8 - df
    3,3,3,3,3,3,3,3,  # e0 - e7
    3,3,3,3,3,3,3,3,  # e8 - ef
    3,3,3,3,3,3,3,3,  # f0 - f7
    3,3,3,3,3,3,3,0  # f8 - ff
)

BIG5_st = (
    eError,eStart,eStart,     3,eError,eError,eError,eError,#00-07
    eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eError,#08-0f
    eError,eStart,eStart,eStart,eStart,eStart,eStart,eStart#10-17
)

Big5CharLenTable = (0, 1, 1, 2, 0)

Big5SMModel = {'classTable': BIG5_cls,
               'classFactor': 5,
               'stateTable': BIG5_st,
               'charLenTable': Big5CharLenTable,
               'name': 'Big5'}

# CP949

CP949_cls  = (
    1,1,1,1,1,1,1,1, 1,1,1,1,1,1,0,0,  # 00 - 0f
    1,1,1,1,1,1,1,1, 1,1,1,0,1,1,1,1,  # 10 - 1f
    1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,  # 20 - 2f
    1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,  # 30 - 3f
    1,4,4,4,4,4,4,4, 4,4,4,4,4,4,4,4,  # 40 - 4f
    4,4,5,5,5,5,5,5, 5,5,5,1,1,1,1,1,  # 50 - 5f
    1,5,5,5,5,5,5,5, 5,5,5,5,5,5,5,5,  # 60 - 6f
    5,5,5,5,5,5,5,5, 5,5,5,1,1,1,1,1,  # 70 - 7f
    0,6,6,6,6,6,6,6, 6,6,6,6,6,6,6,6,  # 80 - 8f
    6,6,6,6,6,6,6,6, 6,6,6,6,6,6,6,6,  # 90 - 9f
    6,7,7,7,7,7,7,7, 7,7,7,7,7,8,8,8,  # a0 - af
    7,7,7,7,7,7,7,7, 7,7,7,7,7,7,7,7,  # b0 - bf
    7,7,7,7,7,7,9,2, 2,3,2,2,2,2,2,2,  # c0 - cf
    2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  # d0 - df
    2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,2,  # e0 - ef
    2,2,2,2,2,2,2,2, 2,2,2,2,2,2,2,0,  # f0 - ff
)

CP949_st = (
#cls=    0      1      2      3      4      5      6      7      8      9  # previous state =
    eError,eStart,     3,eError,eStart,eStart,     4,     5,eError,     6, # eStart
    eError,eError,eError,eError,eError,eError,eError,eError,eError,eError, # eError
    eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe, # eItsMe
    eError,eError,eStart,eStart,eError,eError,eError,eStart,eStart,eStart, # 3
    eError,eError,eStart,eStart,eStart,eStart,eStart,eStart,eStart,eStart, # 4
    eError,eStart,eStart,eStart,eStart,eStart,eStart,eStart,eStart,eStart, # 5
    eError,eStart,eStart,eStart,eStart,eError,eError,eStart,eStart,eStart, # 6
)

CP949CharLenTable = (0, 1, 2, 0, 1, 1, 2, 2, 0, 2)

CP949SMModel = {'classTable': CP949_cls,
                'classFactor': 10,
                'stateTable': CP949_st,
                'charLenTable': CP949CharLenTable,
                'name': 'CP949'}

# EUC-JP

EUCJP_cls = (
    4,4,4,4,4,4,4,4,  # 00 - 07
    4,4,4,4,4,4,5,5,  # 08 - 0f
    4,4,4,4,4,4,4,4,  # 10 - 17
    4,4,4,5,4,4,4,4,  # 18 - 1f
    4,4,4,4,4,4,4,4,  # 20 - 27
    4,4,4,4,4,4,4,4,  # 28 - 2f
    4,4,4,4,4,4,4,4,  # 30 - 37
    4,4,4,4,4,4,4,4,  # 38 - 3f
    4,4,4,4,4,4,4,4,  # 40 - 47
    4,4,4,4,4,4,4,4,  # 48 - 4f
    4,4,4,4,4,4,4,4,  # 50 - 57
    4,4,4,4,4,4,4,4,  # 58 - 5f
    4,4,4,4,4,4,4,4,  # 60 - 67
    4,4,4,4,4,4,4,4,  # 68 - 6f
    4,4,4,4,4,4,4,4,  # 70 - 77
    4,4,4,4,4,4,4,4,  # 78 - 7f
    5,5,5,5,5,5,5,5,  # 80 - 87
    5,5,5,5,5,5,1,3,  # 88 - 8f
    5,5,5,5,5,5,5,5,  # 90 - 97
    5,5,5,5,5,5,5,5,  # 98 - 9f
    5,2,2,2,2,2,2,2,  # a0 - a7
    2,2,2,2,2,2,2,2,  # a8 - af
    2,2,2,2,2,2,2,2,  # b0 - b7
    2,2,2,2,2,2,2,2,  # b8 - bf
    2,2,2,2,2,2,2,2,  # c0 - c7
    2,2,2,2,2,2,2,2,  # c8 - cf
    2,2,2,2,2,2,2,2,  # d0 - d7
    2,2,2,2,2,2,2,2,  # d8 - df
    0,0,0,0,0,0,0,0,  # e0 - e7
    0,0,0,0,0,0,0,0,  # e8 - ef
    0,0,0,0,0,0,0,0,  # f0 - f7
    0,0,0,0,0,0,0,5  # f8 - ff
)

EUCJP_st = (
          3,     4,     3,     5,eStart,eError,eError,eError,#00-07
     eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,#08-0f
     eItsMe,eItsMe,eStart,eError,eStart,eError,eError,eError,#10-17
     eError,eError,eStart,eError,eError,eError,     3,eError,#18-1f
          3,eError,eError,eError,eStart,eStart,eStart,eStart#20-27
)

EUCJPCharLenTable = (2, 2, 2, 3, 1, 0)

EUCJPSMModel = {'classTable': EUCJP_cls,
                'classFactor': 6,
                'stateTable': EUCJP_st,
                'charLenTable': EUCJPCharLenTable,
                'name': 'EUC-JP'}

# EUC-KR

EUCKR_cls  = (
    1,1,1,1,1,1,1,1,  # 00 - 07
    1,1,1,1,1,1,0,0,  # 08 - 0f
    1,1,1,1,1,1,1,1,  # 10 - 17
    1,1,1,0,1,1,1,1,  # 18 - 1f
    1,1,1,1,1,1,1,1,  # 20 - 27
    1,1,1,1,1,1,1,1,  # 28 - 2f
    1,1,1,1,1,1,1,1,  # 30 - 37
    1,1,1,1,1,1,1,1,  # 38 - 3f
    1,1,1,1,1,1,1,1,  # 40 - 47
    1,1,1,1,1,1,1,1,  # 48 - 4f
    1,1,1,1,1,1,1,1,  # 50 - 57
    1,1,1,1,1,1,1,1,  # 58 - 5f
    1,1,1,1,1,1,1,1,  # 60 - 67
    1,1,1,1,1,1,1,1,  # 68 - 6f
    1,1,1,1,1,1,1,1,  # 70 - 77
    1,1,1,1,1,1,1,1,  # 78 - 7f
    0,0,0,0,0,0,0,0,  # 80 - 87
    0,0,0,0,0,0,0,0,  # 88 - 8f
    0,0,0,0,0,0,0,0,  # 90 - 97
    0,0,0,0,0,0,0,0,  # 98 - 9f
    0,2,2,2,2,2,2,2,  # a0 - a7
    2,2,2,2,2,3,3,3,  # a8 - af
    2,2,2,2,2,2,2,2,  # b0 - b7
    2,2,2,2,2,2,2,2,  # b8 - bf
    2,2,2,2,2,2,2,2,  # c0 - c7
    2,3,2,2,2,2,2,2,  # c8 - cf
    2,2,2,2,2,2,2,2,  # d0 - d7
    2,2,2,2,2,2,2,2,  # d8 - df
    2,2,2,2,2,2,2,2,  # e0 - e7
    2,2,2,2,2,2,2,2,  # e8 - ef
    2,2,2,2,2,2,2,2,  # f0 - f7
    2,2,2,2,2,2,2,0   # f8 - ff
)

EUCKR_st = (
    eError,eStart,     3,eError,eError,eError,eError,eError,#00-07
    eItsMe,eItsMe,eItsMe,eItsMe,eError,eError,eStart,eStart #08-0f
)

EUCKRCharLenTable = (0, 1, 2, 0)

EUCKRSMModel = {'classTable': EUCKR_cls,
                'classFactor': 4,
                'stateTable': EUCKR_st,
                'charLenTable': EUCKRCharLenTable,
                'name': 'EUC-KR'}

# EUC-TW

EUCTW_cls = (
    2,2,2,2,2,2,2,2,  # 00 - 07
    2,2,2,2,2,2,0,0,  # 08 - 0f
    2,2,2,2,2,2,2,2,  # 10 - 17
    2,2,2,0,2,2,2,2,  # 18 - 1f
    2,2,2,2,2,2,2,2,  # 20 - 27
    2,2,2,2,2,2,2,2,  # 28 - 2f
    2,2,2,2,2,2,2,2,  # 30 - 37
    2,2,2,2,2,2,2,2,  # 38 - 3f
    2,2,2,2,2,2,2,2,  # 40 - 47
    2,2,2,2,2,2,2,2,  # 48 - 4f
    2,2,2,2,2,2,2,2,  # 50 - 57
    2,2,2,2,2,2,2,2,  # 58 - 5f
    2,2,2,2,2,2,2,2,  # 60 - 67
    2,2,2,2,2,2,2,2,  # 68 - 6f
    2,2,2,2,2,2,2,2,  # 70 - 77
    2,2,2,2,2,2,2,2,  # 78 - 7f
    0,0,0,0,0,0,0,0,  # 80 - 87
    0,0,0,0,0,0,6,0,  # 88 - 8f
    0,0,0,0,0,0,0,0,  # 90 - 97
    0,0,0,0,0,0,0,0,  # 98 - 9f
    0,3,4,4,4,4,4,4,  # a0 - a7
    5,5,1,1,1,1,1,1,  # a8 - af
    1,1,1,1,1,1,1,1,  # b0 - b7
    1,1,1,1,1,1,1,1,  # b8 - bf
    1,1,3,1,3,3,3,3,  # c0 - c7
    3,3,3,3,3,3,3,3,  # c8 - cf
    3,3,3,3,3,3,3,3,  # d0 - d7
    3,3,3,3,3,3,3,3,  # d8 - df
    3,3,3,3,3,3,3,3,  # e0 - e7
    3,3,3,3,3,3,3,3,  # e8 - ef
    3,3,3,3,3,3,3,3,  # f0 - f7
    3,3,3,3,3,3,3,0   # f8 - ff
)

EUCTW_st = (
    eError,eError,eStart,     3,     3,     3,     4,eError,#00-07
    eError,eError,eError,eError,eError,eError,eItsMe,eItsMe,#08-0f
    eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eError,eStart,eError,#10-17
    eStart,eStart,eStart,eError,eError,eError,eError,eError,#18-1f
         5,eError,eError,eError,eStart,eError,eStart,eStart,#20-27
    eStart,eError,eStart,eStart,eStart,eStart,eStart,eStart #28-2f
)

EUCTWCharLenTable = (0, 0, 1, 2, 2, 2, 3)

EUCTWSMModel = {'classTable': EUCTW_cls,
                'classFactor': 7,
                'stateTable': EUCTW_st,
                'charLenTable': EUCTWCharLenTable,
                'name': 'x-euc-tw'}

# GB2312

GB2312_cls = (
    1,1,1,1,1,1,1,1,  # 00 - 07
    1,1,1,1,1,1,0,0,  # 08 - 0f
    1,1,1,1,1,1,1,1,  # 10 - 17
    1,1,1,0,1,1,1,1,  # 18 - 1f
    1,1,1,1,1,1,1,1,  # 20 - 27
    1,1,1,1,1,1,1,1,  # 28 - 2f
    3,3,3,3,3,3,3,3,  # 30 - 37
    3,3,1,1,1,1,1,1,  # 38 - 3f
    2,2,2,2,2,2,2,2,  # 40 - 47
    2,2,2,2,2,2,2,2,  # 48 - 4f
    2,2,2,2,2,2,2,2,  # 50 - 57
    2,2,2,2,2,2,2,2,  # 58 - 5f
    2,2,2,2,2,2,2,2,  # 60 - 67
    2,2,2,2,2,2,2,2,  # 68 - 6f
    2,2,2,2,2,2,2,2,  # 70 - 77
    2,2,2,2,2,2,2,4,  # 78 - 7f
    5,6,6,6,6,6,6,6,  # 80 - 87
    6,6,6,6,6,6,6,6,  # 88 - 8f
    6,6,6,6,6,6,6,6,  # 90 - 97
    6,6,6,6,6,6,6,6,  # 98 - 9f
    6,6,6,6,6,6,6,6,  # a0 - a7
    6,6,6,6,6,6,6,6,  # a8 - af
    6,6,6,6,6,6,6,6,  # b0 - b7
    6,6,6,6,6,6,6,6,  # b8 - bf
    6,6,6,6,6,6,6,6,  # c0 - c7
    6,6,6,6,6,6,6,6,  # c8 - cf
    6,6,6,6,6,6,6,6,  # d0 - d7
    6,6,6,6,6,6,6,6,  # d8 - df
    6,6,6,6,6,6,6,6,  # e0 - e7
    6,6,6,6,6,6,6,6,  # e8 - ef
    6,6,6,6,6,6,6,6,  # f0 - f7
    6,6,6,6,6,6,6,0   # f8 - ff
)

GB2312_st = (
    eError,eStart,eStart,eStart,eStart,eStart,     3,eError,#00-07
    eError,eError,eError,eError,eError,eError,eItsMe,eItsMe,#08-0f
    eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eError,eError,eStart,#10-17
         4,eError,eStart,eStart,eError,eError,eError,eError,#18-1f
    eError,eError,     5,eError,eError,eError,eItsMe,eError,#20-27
    eError,eError,eStart,eStart,eStart,eStart,eStart,eStart #28-2f
)

# To be accurate, the length of class 6 can be either 2 or 4.
# But it is not necessary to discriminate between the two since
# it is used for frequency analysis only, and we are validing
# each code range there as well. So it is safe to set it to be
# 2 here.
GB2312CharLenTable = (0, 1, 1, 1, 1, 1, 2)

GB2312SMModel = {'classTable': GB2312_cls,
                  'classFactor': 7,
                  'stateTable': GB2312_st,
                  'charLenTable': GB2312CharLenTable,
                  'name': 'GB2312'}

# Shift_JIS

SJIS_cls = (
    1,1,1,1,1,1,1,1,  # 00 - 07
    1,1,1,1,1,1,0,0,  # 08 - 0f
    1,1,1,1,1,1,1,1,  # 10 - 17
    1,1,1,0,1,1,1,1,  # 18 - 1f
    1,1,1,1,1,1,1,1,  # 20 - 27
    1,1,1,1,1,1,1,1,  # 28 - 2f
    1,1,1,1,1,1,1,1,  # 30 - 37
    1,1,1,1,1,1,1,1,  # 38 - 3f
    2,2,2,2,2,2,2,2,  # 40 - 47
    2,2,2,2,2,2,2,2,  # 48 - 4f
    2,2,2,2,2,2,2,2,  # 50 - 57
    2,2,2,2,2,2,2,2,  # 58 - 5f
    2,2,2,2,2,2,2,2,  # 60 - 67
    2,2,2,2,2,2,2,2,  # 68 - 6f
    2,2,2,2,2,2,2,2,  # 70 - 77
    2,2,2,2,2,2,2,1,  # 78 - 7f
    3,3,3,3,3,3,3,3,  # 80 - 87
    3,3,3,3,3,3,3,3,  # 88 - 8f
    3,3,3,3,3,3,3,3,  # 90 - 97
    3,3,3,3,3,3,3,3,  # 98 - 9f
    #0xa0 is illegal in sjis encoding, but some pages does
    #contain such byte. We need to be more error forgiven.
    2,2,2,2,2,2,2,2,  # a0 - a7
    2,2,2,2,2,2,2,2,  # a8 - af
    2,2,2,2,2,2,2,2,  # b0 - b7
    2,2,2,2,2,2,2,2,  # b8 - bf
    2,2,2,2,2,2,2,2,  # c0 - c7
    2,2,2,2,2,2,2,2,  # c8 - cf
    2,2,2,2,2,2,2,2,  # d0 - d7
    2,2,2,2,2,2,2,2,  # d8 - df
    3,3,3,3,3,3,3,3,  # e0 - e7
    3,3,3,3,3,4,4,4,  # e8 - ef
    4,4,4,4,4,4,4,4,  # f0 - f7
    4,4,4,4,4,0,0,0   # f8 - ff
)


SJIS_st = (
    eError,eStart,eStart,     3,eError,eError,eError,eError,#00-07
    eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,#08-0f
    eItsMe,eItsMe,eError,eError,eStart,eStart,eStart,eStart #10-17
)

SJISCharLenTable = (0, 1, 1, 2, 0, 0)

SJISSMModel = {'classTable': SJIS_cls,
               'classFactor': 6,
               'stateTable': SJIS_st,
               'charLenTable': SJISCharLenTable,
               'name': 'Shift_JIS'}

# UCS2-BE

UCS2BE_cls = (
    0,0,0,0,0,0,0,0,  # 00 - 07
    0,0,1,0,0,2,0,0,  # 08 - 0f
    0,0,0,0,0,0,0,0,  # 10 - 17
    0,0,0,3,0,0,0,0,  # 18 - 1f
    0,0,0,0,0,0,0,0,  # 20 - 27
    0,3,3,3,3,3,0,0,  # 28 - 2f
    0,0,0,0,0,0,0,0,  # 30 - 37
    0,0,0,0,0,0,0,0,  # 38 - 3f
    0,0,0,0,0,0,0,0,  # 40 - 47
    0,0,0,0,0,0,0,0,  # 48 - 4f
    0,0,0,0,0,0,0,0,  # 50 - 57
    0,0,0,0,0,0,0,0,  # 58 - 5f
    0,0,0,0,0,0,0,0,  # 60 - 67
    0,0,0,0,0,0,0,0,  # 68 - 6f
    0,0,0,0,0,0,0,0,  # 70 - 77
    0,0,0,0,0,0,0,0,  # 78 - 7f
    0,0,0,0,0,0,0,0,  # 80 - 87
    0,0,0,0,0,0,0,0,  # 88 - 8f
    0,0,0,0,0,0,0,0,  # 90 - 97
    0,0,0,0,0,0,0,0,  # 98 - 9f
    0,0,0,0,0,0,0,0,  # a0 - a7
    0,0,0,0,0,0,0,0,  # a8 - af
    0,0,0,0,0,0,0,0,  # b0 - b7
    0,0,0,0,0,0,0,0,  # b8 - bf
    0,0,0,0,0,0,0,0,  # c0 - c7
    0,0,0,0,0,0,0,0,  # c8 - cf
    0,0,0,0,0,0,0,0,  # d0 - d7
    0,0,0,0,0,0,0,0,  # d8 - df
    0,0,0,0,0,0,0,0,  # e0 - e7
    0,0,0,0,0,0,0,0,  # e8 - ef
    0,0,0,0,0,0,0,0,  # f0 - f7
    0,0,0,0,0,0,4,5   # f8 - ff
)

UCS2BE_st  = (
          5,     7,     7,eError,     4,     3,eError,eError,#00-07
     eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,#08-0f
     eItsMe,eItsMe,     6,     6,     6,     6,eError,eError,#10-17
          6,     6,     6,     6,     6,eItsMe,     6,     6,#18-1f
          6,     6,     6,     6,     5,     7,     7,eError,#20-27
          5,     8,     6,     6,eError,     6,     6,     6,#28-2f
          6,     6,     6,     6,eError,eError,eStart,eStart #30-37
)

UCS2BECharLenTable = (2, 2, 2, 0, 2, 2)

UCS2BESMModel = {'classTable': UCS2BE_cls,
                 'classFactor': 6,
                 'stateTable': UCS2BE_st,
                 'charLenTable': UCS2BECharLenTable,
                 'name': 'UTF-16BE'}

# UCS2-LE

UCS2LE_cls = (
    0,0,0,0,0,0,0,0,  # 00 - 07
    0,0,1,0,0,2,0,0,  # 08 - 0f
    0,0,0,0,0,0,0,0,  # 10 - 17
    0,0,0,3,0,0,0,0,  # 18 - 1f
    0,0,0,0,0,0,0,0,  # 20 - 27
    0,3,3,3,3,3,0,0,  # 28 - 2f
    0,0,0,0,0,0,0,0,  # 30 - 37
    0,0,0,0,0,0,0,0,  # 38 - 3f
    0,0,0,0,0,0,0,0,  # 40 - 47
    0,0,0,0,0,0,0,0,  # 48 - 4f
    0,0,0,0,0,0,0,0,  # 50 - 57
    0,0,0,0,0,0,0,0,  # 58 - 5f
    0,0,0,0,0,0,0,0,  # 60 - 67
    0,0,0,0,0,0,0,0,  # 68 - 6f
    0,0,0,0,0,0,0,0,  # 70 - 77
    0,0,0,0,0,0,0,0,  # 78 - 7f
    0,0,0,0,0,0,0,0,  # 80 - 87
    0,0,0,0,0,0,0,0,  # 88 - 8f
    0,0,0,0,0,0,0,0,  # 90 - 97
    0,0,0,0,0,0,0,0,  # 98 - 9f
    0,0,0,0,0,0,0,0,  # a0 - a7
    0,0,0,0,0,0,0,0,  # a8 - af
    0,0,0,0,0,0,0,0,  # b0 - b7
    0,0,0,0,0,0,0,0,  # b8 - bf
    0,0,0,0,0,0,0,0,  # c0 - c7
    0,0,0,0,0,0,0,0,  # c8 - cf
    0,0,0,0,0,0,0,0,  # d0 - d7
    0,0,0,0,0,0,0,0,  # d8 - df
    0,0,0,0,0,0,0,0,  # e0 - e7
    0,0,0,0,0,0,0,0,  # e8 - ef
    0,0,0,0,0,0,0,0,  # f0 - f7
    0,0,0,0,0,0,4,5   # f8 - ff
)

UCS2LE_st = (
          6,     6,     7,     6,     4,     3,eError,eError,#00-07
     eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,#08-0f
     eItsMe,eItsMe,     5,     5,     5,eError,eItsMe,eError,#10-17
          5,     5,     5,eError,     5,eError,     6,     6,#18-1f
          7,     6,     8,     8,     5,     5,     5,eError,#20-27
          5,     5,     5,eError,eError,eError,     5,     5,#28-2f
          5,     5,     5,eError,     5,eError,eStart,eStart #30-37
)

UCS2LECharLenTable = (2, 2, 2, 2, 2, 2)

UCS2LESMModel = {'classTable': UCS2LE_cls,
                 'classFactor': 6,
                 'stateTable': UCS2LE_st,
                 'charLenTable': UCS2LECharLenTable,
                 'name': 'UTF-16LE'}

# UTF-8

UTF8_cls = (
    1,1,1,1,1,1,1,1,  # 00 - 07  #allow 0x00 as a legal value
    1,1,1,1,1,1,0,0,  # 08 - 0f
    1,1,1,1,1,1,1,1,  # 10 - 17
    1,1,1,0,1,1,1,1,  # 18 - 1f
    1,1,1,1,1,1,1,1,  # 20 - 27
    1,1,1,1,1,1,1,1,  # 28 - 2f
    1,1,1,1,1,1,1,1,  # 30 - 37
    1,1,1,1,1,1,1,1,  # 38 - 3f
    1,1,1,1,1,1,1,1,  # 40 - 47
    1,1,1,1,1,1,1,1,  # 48 - 4f
    1,1,1,1,1,1,1,1,  # 50 - 57
    1,1,1,1,1,1,1,1,  # 58 - 5f
    1,1,1,1,1,1,1,1,  # 60 - 67
    1,1,1,1,1,1,1,1,  # 68 - 6f
    1,1,1,1,1,1,1,1,  # 70 - 77
    1,1,1,1,1,1,1,1,  # 78 - 7f
    2,2,2,2,3,3,3,3,  # 80 - 87
    4,4,4,4,4,4,4,4,  # 88 - 8f
    4,4,4,4,4,4,4,4,  # 90 - 97
    4,4,4,4,4,4,4,4,  # 98 - 9f
    5,5,5,5,5,5,5,5,  # a0 - a7
    5,5,5,5,5,5,5,5,  # a8 - af
    5,5,5,5,5,5,5,5,  # b0 - b7
    5,5,5,5,5,5,5,5,  # b8 - bf
    0,0,6,6,6,6,6,6,  # c0 - c7
    6,6,6,6,6,6,6,6,  # c8 - cf
    6,6,6,6,6,6,6,6,  # d0 - d7
    6,6,6,6,6,6,6,6,  # d8 - df
    7,8,8,8,8,8,8,8,  # e0 - e7
    8,8,8,8,8,9,8,8,  # e8 - ef
    10,11,11,11,11,11,11,11,  # f0 - f7
    12,13,13,13,14,15,0,0    # f8 - ff
)

UTF8_st = (
    eError,eStart,eError,eError,eError,eError,     12,   10,#00-07
         9,     11,     8,     7,     6,     5,     4,    3,#08-0f
    eError,eError,eError,eError,eError,eError,eError,eError,#10-17
    eError,eError,eError,eError,eError,eError,eError,eError,#18-1f
    eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,#20-27
    eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,#28-2f
    eError,eError,     5,     5,     5,     5,eError,eError,#30-37
    eError,eError,eError,eError,eError,eError,eError,eError,#38-3f
    eError,eError,eError,     5,     5,     5,eError,eError,#40-47
    eError,eError,eError,eError,eError,eError,eError,eError,#48-4f
    eError,eError,     7,     7,     7,     7,eError,eError,#50-57
    eError,eError,eError,eError,eError,eError,eError,eError,#58-5f
    eError,eError,eError,eError,     7,     7,eError,eError,#60-67
    eError,eError,eError,eError,eError,eError,eError,eError,#68-6f
    eError,eError,     9,     9,     9,     9,eError,eError,#70-77
    eError,eError,eError,eError,eError,eError,eError,eError,#78-7f
    eError,eError,eError,eError,eError,     9,eError,eError,#80-87
    eError,eError,eError,eError,eError,eError,eError,eError,#88-8f
    eError,eError,    12,    12,    12,    12,eError,eError,#90-97
    eError,eError,eError,eError,eError,eError,eError,eError,#98-9f
    eError,eError,eError,eError,eError,    12,eError,eError,#a0-a7
    eError,eError,eError,eError,eError,eError,eError,eError,#a8-af
    eError,eError,    12,    12,    12,eError,eError,eError,#b0-b7
    eError,eError,eError,eError,eError,eError,eError,eError,#b8-bf
    eError,eError,eStart,eStart,eStart,eStart,eError,eError,#c0-c7
    eError,eError,eError,eError,eError,eError,eError,eError #c8-cf
)

UTF8CharLenTable = (0, 1, 0, 0, 0, 0, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6)

UTF8SMModel = {'classTable': UTF8_cls,
               'classFactor': 16,
               'stateTable': UTF8_st,
               'charLenTable': UTF8CharLenTable,
               'name': 'UTF-8'}

# flake8: noqa

########NEW FILE########
__FILENAME__ = sbcharsetprober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

import sys
from . import constants
from .charsetprober import CharSetProber
from .compat import wrap_ord

SAMPLE_SIZE = 64
SB_ENOUGH_REL_THRESHOLD = 1024
POSITIVE_SHORTCUT_THRESHOLD = 0.95
NEGATIVE_SHORTCUT_THRESHOLD = 0.05
SYMBOL_CAT_ORDER = 250
NUMBER_OF_SEQ_CAT = 4
POSITIVE_CAT = NUMBER_OF_SEQ_CAT - 1
#NEGATIVE_CAT = 0


class SingleByteCharSetProber(CharSetProber):
    def __init__(self, model, reversed=False, nameProber=None):
        CharSetProber.__init__(self)
        self._mModel = model
        # TRUE if we need to reverse every pair in the model lookup
        self._mReversed = reversed
        # Optional auxiliary prober for name decision
        self._mNameProber = nameProber
        self.reset()

    def reset(self):
        CharSetProber.reset(self)
        # char order of last character
        self._mLastOrder = 255
        self._mSeqCounters = [0] * NUMBER_OF_SEQ_CAT
        self._mTotalSeqs = 0
        self._mTotalChar = 0
        # characters that fall in our sampling range
        self._mFreqChar = 0

    def get_charset_name(self):
        if self._mNameProber:
            return self._mNameProber.get_charset_name()
        else:
            return self._mModel['charsetName']

    def feed(self, aBuf):
        if not self._mModel['keepEnglishLetter']:
            aBuf = self.filter_without_english_letters(aBuf)
        aLen = len(aBuf)
        if not aLen:
            return self.get_state()
        for c in aBuf:
            order = self._mModel['charToOrderMap'][wrap_ord(c)]
            if order < SYMBOL_CAT_ORDER:
                self._mTotalChar += 1
            if order < SAMPLE_SIZE:
                self._mFreqChar += 1
                if self._mLastOrder < SAMPLE_SIZE:
                    self._mTotalSeqs += 1
                    if not self._mReversed:
                        i = (self._mLastOrder * SAMPLE_SIZE) + order
                        model = self._mModel['precedenceMatrix'][i]
                    else:  # reverse the order of the letters in the lookup
                        i = (order * SAMPLE_SIZE) + self._mLastOrder
                        model = self._mModel['precedenceMatrix'][i]
                    self._mSeqCounters[model] += 1
            self._mLastOrder = order

        if self.get_state() == constants.eDetecting:
            if self._mTotalSeqs > SB_ENOUGH_REL_THRESHOLD:
                cf = self.get_confidence()
                if cf > POSITIVE_SHORTCUT_THRESHOLD:
                    if constants._debug:
                        sys.stderr.write('%s confidence = %s, we have a'
                                         'winner\n' %
                                         (self._mModel['charsetName'], cf))
                    self._mState = constants.eFoundIt
                elif cf < NEGATIVE_SHORTCUT_THRESHOLD:
                    if constants._debug:
                        sys.stderr.write('%s confidence = %s, below negative'
                                         'shortcut threshhold %s\n' %
                                         (self._mModel['charsetName'], cf,
                                          NEGATIVE_SHORTCUT_THRESHOLD))
                    self._mState = constants.eNotMe

        return self.get_state()

    def get_confidence(self):
        r = 0.01
        if self._mTotalSeqs > 0:
            r = ((1.0 * self._mSeqCounters[POSITIVE_CAT]) / self._mTotalSeqs
                 / self._mModel['mTypicalPositiveRatio'])
            r = r * self._mFreqChar / self._mTotalChar
            if r >= 1.0:
                r = 0.99
        return r

########NEW FILE########
__FILENAME__ = sbcsgroupprober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from .charsetgroupprober import CharSetGroupProber
from .sbcharsetprober import SingleByteCharSetProber
from .langcyrillicmodel import (Win1251CyrillicModel, Koi8rModel,
                                Latin5CyrillicModel, MacCyrillicModel,
                                Ibm866Model, Ibm855Model)
from .langgreekmodel import Latin7GreekModel, Win1253GreekModel
from .langbulgarianmodel import Latin5BulgarianModel, Win1251BulgarianModel
from .langhungarianmodel import Latin2HungarianModel, Win1250HungarianModel
from .langthaimodel import TIS620ThaiModel
from .langhebrewmodel import Win1255HebrewModel
from .hebrewprober import HebrewProber


class SBCSGroupProber(CharSetGroupProber):
    def __init__(self):
        CharSetGroupProber.__init__(self)
        self._mProbers = [
            SingleByteCharSetProber(Win1251CyrillicModel),
            SingleByteCharSetProber(Koi8rModel),
            SingleByteCharSetProber(Latin5CyrillicModel),
            SingleByteCharSetProber(MacCyrillicModel),
            SingleByteCharSetProber(Ibm866Model),
            SingleByteCharSetProber(Ibm855Model),
            SingleByteCharSetProber(Latin7GreekModel),
            SingleByteCharSetProber(Win1253GreekModel),
            SingleByteCharSetProber(Latin5BulgarianModel),
            SingleByteCharSetProber(Win1251BulgarianModel),
            SingleByteCharSetProber(Latin2HungarianModel),
            SingleByteCharSetProber(Win1250HungarianModel),
            SingleByteCharSetProber(TIS620ThaiModel),
        ]
        hebrewProber = HebrewProber()
        logicalHebrewProber = SingleByteCharSetProber(Win1255HebrewModel,
                                                      False, hebrewProber)
        visualHebrewProber = SingleByteCharSetProber(Win1255HebrewModel, True,
                                                     hebrewProber)
        hebrewProber.set_model_probers(logicalHebrewProber, visualHebrewProber)
        self._mProbers.extend([hebrewProber, logicalHebrewProber,
                               visualHebrewProber])

        self.reset()

########NEW FILE########
__FILENAME__ = sjisprober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

import sys
from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import SJISDistributionAnalysis
from .jpcntx import SJISContextAnalysis
from .mbcssm import SJISSMModel
from . import constants


class SJISProber(MultiByteCharSetProber):
    def __init__(self):
        MultiByteCharSetProber.__init__(self)
        self._mCodingSM = CodingStateMachine(SJISSMModel)
        self._mDistributionAnalyzer = SJISDistributionAnalysis()
        self._mContextAnalyzer = SJISContextAnalysis()
        self.reset()

    def reset(self):
        MultiByteCharSetProber.reset(self)
        self._mContextAnalyzer.reset()

    def get_charset_name(self):
        return "SHIFT_JIS"

    def feed(self, aBuf):
        aLen = len(aBuf)
        for i in range(0, aLen):
            codingState = self._mCodingSM.next_state(aBuf[i])
            if codingState == constants.eError:
                if constants._debug:
                    sys.stderr.write(self.get_charset_name()
                                     + ' prober hit error at byte ' + str(i)
                                     + '\n')
                self._mState = constants.eNotMe
                break
            elif codingState == constants.eItsMe:
                self._mState = constants.eFoundIt
                break
            elif codingState == constants.eStart:
                charLen = self._mCodingSM.get_current_charlen()
                if i == 0:
                    self._mLastChar[1] = aBuf[0]
                    self._mContextAnalyzer.feed(self._mLastChar[2 - charLen:],
                                                charLen)
                    self._mDistributionAnalyzer.feed(self._mLastChar, charLen)
                else:
                    self._mContextAnalyzer.feed(aBuf[i + 1 - charLen:i + 3
                                                     - charLen], charLen)
                    self._mDistributionAnalyzer.feed(aBuf[i - 1:i + 1],
                                                     charLen)

        self._mLastChar[0] = aBuf[aLen - 1]

        if self.get_state() == constants.eDetecting:
            if (self._mContextAnalyzer.got_enough_data() and
               (self.get_confidence() > constants.SHORTCUT_THRESHOLD)):
                self._mState = constants.eFoundIt

        return self.get_state()

    def get_confidence(self):
        contxtCf = self._mContextAnalyzer.get_confidence()
        distribCf = self._mDistributionAnalyzer.get_confidence()
        return max(contxtCf, distribCf)

########NEW FILE########
__FILENAME__ = universaldetector
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is Mozilla Universal charset detector code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 2001
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#   Shy Shalom - original C code
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from . import constants
import sys
import codecs
from .latin1prober import Latin1Prober  # windows-1252
from .mbcsgroupprober import MBCSGroupProber  # multi-byte character sets
from .sbcsgroupprober import SBCSGroupProber  # single-byte character sets
from .escprober import EscCharSetProber  # ISO-2122, etc.
import re

MINIMUM_THRESHOLD = 0.20
ePureAscii = 0
eEscAscii = 1
eHighbyte = 2


class UniversalDetector:
    def __init__(self):
        self._highBitDetector = re.compile(b'[\x80-\xFF]')
        self._escDetector = re.compile(b'(\033|~{)')
        self._mEscCharSetProber = None
        self._mCharSetProbers = []
        self.reset()

    def reset(self):
        self.result = {'encoding': None, 'confidence': 0.0}
        self.done = False
        self._mStart = True
        self._mGotData = False
        self._mInputState = ePureAscii
        self._mLastChar = b''
        if self._mEscCharSetProber:
            self._mEscCharSetProber.reset()
        for prober in self._mCharSetProbers:
            prober.reset()

    def feed(self, aBuf):
        if self.done:
            return

        aLen = len(aBuf)
        if not aLen:
            return

        if not self._mGotData:
            # If the data starts with BOM, we know it is UTF
            if aBuf[:3] == codecs.BOM:
                # EF BB BF  UTF-8 with BOM
                self.result = {'encoding': "UTF-8", 'confidence': 1.0}
            elif aBuf[:4] == codecs.BOM_UTF32_LE:
                # FF FE 00 00  UTF-32, little-endian BOM
                self.result = {'encoding': "UTF-32LE", 'confidence': 1.0}
            elif aBuf[:4] == codecs.BOM_UTF32_BE:
                # 00 00 FE FF  UTF-32, big-endian BOM
                self.result = {'encoding': "UTF-32BE", 'confidence': 1.0}
            elif aBuf[:4] == b'\xFE\xFF\x00\x00':
                # FE FF 00 00  UCS-4, unusual octet order BOM (3412)
                self.result = {
                    'encoding': "X-ISO-10646-UCS-4-3412",
                    'confidence': 1.0
                }
            elif aBuf[:4] == b'\x00\x00\xFF\xFE':
                # 00 00 FF FE  UCS-4, unusual octet order BOM (2143)
                self.result = {
                    'encoding': "X-ISO-10646-UCS-4-2143",
                    'confidence': 1.0
                }
            elif aBuf[:2] == codecs.BOM_LE:
                # FF FE  UTF-16, little endian BOM
                self.result = {'encoding': "UTF-16LE", 'confidence': 1.0}
            elif aBuf[:2] == codecs.BOM_BE:
                # FE FF  UTF-16, big endian BOM
                self.result = {'encoding': "UTF-16BE", 'confidence': 1.0}

        self._mGotData = True
        if self.result['encoding'] and (self.result['confidence'] > 0.0):
            self.done = True
            return

        if self._mInputState == ePureAscii:
            if self._highBitDetector.search(aBuf):
                self._mInputState = eHighbyte
            elif ((self._mInputState == ePureAscii) and
                    self._escDetector.search(self._mLastChar + aBuf)):
                self._mInputState = eEscAscii

        self._mLastChar = aBuf[-1:]

        if self._mInputState == eEscAscii:
            if not self._mEscCharSetProber:
                self._mEscCharSetProber = EscCharSetProber()
            if self._mEscCharSetProber.feed(aBuf) == constants.eFoundIt:
                self.result = {'encoding': self._mEscCharSetProber.get_charset_name(),
                               'confidence': self._mEscCharSetProber.get_confidence()}
                self.done = True
        elif self._mInputState == eHighbyte:
            if not self._mCharSetProbers:
                self._mCharSetProbers = [MBCSGroupProber(), SBCSGroupProber(),
                                         Latin1Prober()]
            for prober in self._mCharSetProbers:
                if prober.feed(aBuf) == constants.eFoundIt:
                    self.result = {'encoding': prober.get_charset_name(),
                                   'confidence': prober.get_confidence()}
                    self.done = True
                    break

    def close(self):
        if self.done:
            return
        if not self._mGotData:
            if constants._debug:
                sys.stderr.write('no data received!\n')
            return
        self.done = True

        if self._mInputState == ePureAscii:
            self.result = {'encoding': 'ascii', 'confidence': 1.0}
            return self.result

        if self._mInputState == eHighbyte:
            proberConfidence = None
            maxProberConfidence = 0.0
            maxProber = None
            for prober in self._mCharSetProbers:
                if not prober:
                    continue
                proberConfidence = prober.get_confidence()
                if proberConfidence > maxProberConfidence:
                    maxProberConfidence = proberConfidence
                    maxProber = prober
            if maxProber and (maxProberConfidence > MINIMUM_THRESHOLD):
                self.result = {'encoding': maxProber.get_charset_name(),
                               'confidence': maxProber.get_confidence()}
                return self.result

        if constants._debug:
            sys.stderr.write('no probers hit minimum threshhold\n')
            for prober in self._mCharSetProbers[0].mProbers:
                if not prober:
                    continue
                sys.stderr.write('%s confidence = %s\n' %
                                 (prober.get_charset_name(),
                                  prober.get_confidence()))

########NEW FILE########
__FILENAME__ = utf8prober
######################## BEGIN LICENSE BLOCK ########################
# The Original Code is mozilla.org code.
#
# The Initial Developer of the Original Code is
# Netscape Communications Corporation.
# Portions created by the Initial Developer are Copyright (C) 1998
# the Initial Developer. All Rights Reserved.
#
# Contributor(s):
#   Mark Pilgrim - port to Python
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301  USA
######################### END LICENSE BLOCK #########################

from . import constants
from .charsetprober import CharSetProber
from .codingstatemachine import CodingStateMachine
from .mbcssm import UTF8SMModel

ONE_CHAR_PROB = 0.5


class UTF8Prober(CharSetProber):
    def __init__(self):
        CharSetProber.__init__(self)
        self._mCodingSM = CodingStateMachine(UTF8SMModel)
        self.reset()

    def reset(self):
        CharSetProber.reset(self)
        self._mCodingSM.reset()
        self._mNumOfMBChar = 0

    def get_charset_name(self):
        return "utf-8"

    def feed(self, aBuf):
        for c in aBuf:
            codingState = self._mCodingSM.next_state(c)
            if codingState == constants.eError:
                self._mState = constants.eNotMe
                break
            elif codingState == constants.eItsMe:
                self._mState = constants.eFoundIt
                break
            elif codingState == constants.eStart:
                if self._mCodingSM.get_current_charlen() >= 2:
                    self._mNumOfMBChar += 1

        if self.get_state() == constants.eDetecting:
            if self.get_confidence() > constants.SHORTCUT_THRESHOLD:
                self._mState = constants.eFoundIt

        return self.get_state()

    def get_confidence(self):
        unlike = 0.99
        if self._mNumOfMBChar < 6:
            for i in range(0, self._mNumOfMBChar):
                unlike = unlike * ONE_CHAR_PROB
            return 1.0 - unlike
        else:
            return unlike

########NEW FILE########
__FILENAME__ = connection
# urllib3/connection.py
# Copyright 2008-2013 Andrey Petrov and contributors (see CONTRIBUTORS.txt)
#
# This module is part of urllib3 and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

import sys
import socket
from socket import timeout as SocketTimeout

try: # Python 3
    from http.client import HTTPConnection as _HTTPConnection, HTTPException
except ImportError:
    from httplib import HTTPConnection as _HTTPConnection, HTTPException

class DummyConnection(object):
    "Used to detect a failed ConnectionCls import."
    pass

try: # Compiled with SSL?
    ssl = None
    HTTPSConnection = DummyConnection

    class BaseSSLError(BaseException):
        pass

    try: # Python 3
        from http.client import HTTPSConnection as _HTTPSConnection
    except ImportError:
        from httplib import HTTPSConnection as _HTTPSConnection

    import ssl
    BaseSSLError = ssl.SSLError

except (ImportError, AttributeError): # Platform-specific: No SSL.
    pass

from .exceptions import (
    ConnectTimeoutError,
)
from .packages.ssl_match_hostname import match_hostname
from .packages import six
from .util import (
    assert_fingerprint,
    resolve_cert_reqs,
    resolve_ssl_version,
    ssl_wrap_socket,
)


port_by_scheme = {
    'http': 80,
    'https': 443,
}


class HTTPConnection(_HTTPConnection, object):
    """
    Based on httplib.HTTPConnection but provides an extra constructor
    backwards-compatibility layer between older and newer Pythons.
    """

    default_port = port_by_scheme['http']

    # By default, disable Nagle's Algorithm.
    tcp_nodelay = 1

    def __init__(self, *args, **kw):
        if six.PY3:  # Python 3
            kw.pop('strict', None)
        if sys.version_info < (2, 7):  # Python 2.6 and older
            kw.pop('source_address', None)

        # Pre-set source_address in case we have an older Python like 2.6.
        self.source_address = kw.get('source_address')

        # Superclass also sets self.source_address in Python 2.7+.
        _HTTPConnection.__init__(self, *args, **kw)  

    def _new_conn(self):
        """ Establish a socket connection and set nodelay settings on it.

        :return: a new socket connection
        """
        extra_args = []
        if self.source_address:  # Python 2.7+
            extra_args.append(self.source_address)

        conn = socket.create_connection(
            (self.host, self.port), self.timeout, *extra_args)
        conn.setsockopt(
            socket.IPPROTO_TCP, socket.TCP_NODELAY, self.tcp_nodelay)

        return conn

    def _prepare_conn(self, conn):
        self.sock = conn
        # the _tunnel_host attribute was added in python 2.6.3 (via
        # http://hg.python.org/cpython/rev/0f57b30a152f) so pythons 2.6(0-2) do
        # not have them.
        if getattr(self, '_tunnel_host', None):
            # TODO: Fix tunnel so it doesn't depend on self.sock state.
            self._tunnel()

    def connect(self):
        conn = self._new_conn()
        self._prepare_conn(conn)


class HTTPSConnection(HTTPConnection):
    default_port = port_by_scheme['https']

    def __init__(self, host, port=None, key_file=None, cert_file=None,
                 strict=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, **kw):

        HTTPConnection.__init__(self, host, port, strict=strict,
                                timeout=timeout, **kw)

        self.key_file = key_file
        self.cert_file = cert_file

        # Required property for Google AppEngine 1.9.0 which otherwise causes
        # HTTPS requests to go out as HTTP. (See Issue #356)
        self._protocol = 'https'

    def connect(self):
        conn = self._new_conn()
        self._prepare_conn(conn)
        self.sock = ssl.wrap_socket(conn, self.key_file, self.cert_file)


class VerifiedHTTPSConnection(HTTPSConnection):
    """
    Based on httplib.HTTPSConnection but wraps the socket with
    SSL certification.
    """
    cert_reqs = None
    ca_certs = None
    ssl_version = None
    conn_kw = {}

    def set_cert(self, key_file=None, cert_file=None,
                 cert_reqs=None, ca_certs=None,
                 assert_hostname=None, assert_fingerprint=None):

        self.key_file = key_file
        self.cert_file = cert_file
        self.cert_reqs = cert_reqs
        self.ca_certs = ca_certs
        self.assert_hostname = assert_hostname
        self.assert_fingerprint = assert_fingerprint

    def connect(self):
        # Add certificate verification

        try:
            sock = socket.create_connection(
                address=(self.host, self.port), timeout=self.timeout,
                **self.conn_kw)
        except SocketTimeout:
            raise ConnectTimeoutError(
                self, "Connection to %s timed out. (connect timeout=%s)" %
                (self.host, self.timeout))

        sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY,
                        self.tcp_nodelay)

        resolved_cert_reqs = resolve_cert_reqs(self.cert_reqs)
        resolved_ssl_version = resolve_ssl_version(self.ssl_version)

        hostname = self.host
        if getattr(self, '_tunnel_host', None):
            # _tunnel_host was added in Python 2.6.3
            # (See: http://hg.python.org/cpython/rev/0f57b30a152f)

            self.sock = sock
            # Calls self._set_hostport(), so self.host is
            # self._tunnel_host below.
            self._tunnel()

            # Override the host with the one we're requesting data from.
            hostname = self._tunnel_host

        # Wrap socket using verification with the root certs in
        # trusted_root_certs
        self.sock = ssl_wrap_socket(sock, self.key_file, self.cert_file,
                                    cert_reqs=resolved_cert_reqs,
                                    ca_certs=self.ca_certs,
                                    server_hostname=hostname,
                                    ssl_version=resolved_ssl_version)

        if resolved_cert_reqs != ssl.CERT_NONE:
            if self.assert_fingerprint:
                assert_fingerprint(self.sock.getpeercert(binary_form=True),
                                   self.assert_fingerprint)
            elif self.assert_hostname is not False:
                match_hostname(self.sock.getpeercert(),
                               self.assert_hostname or hostname)


if ssl:
    # Make a copy for testing.
    UnverifiedHTTPSConnection = HTTPSConnection
    HTTPSConnection = VerifiedHTTPSConnection

########NEW FILE########
__FILENAME__ = connectionpool
# urllib3/connectionpool.py
# Copyright 2008-2013 Andrey Petrov and contributors (see CONTRIBUTORS.txt)
#
# This module is part of urllib3 and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

import sys
import errno
import logging

from socket import error as SocketError, timeout as SocketTimeout
import socket

try: # Python 3
    from queue import LifoQueue, Empty, Full
except ImportError:
    from Queue import LifoQueue, Empty, Full
    import Queue as _  # Platform-specific: Windows


from .exceptions import (
    ClosedPoolError,
    ConnectionError,
    ConnectTimeoutError,
    EmptyPoolError,
    HostChangedError,
    LocationParseError,
    MaxRetryError,
    SSLError,
    TimeoutError,
    ReadTimeoutError,
    ProxyError,
)
from .packages.ssl_match_hostname import CertificateError
from .packages import six
from .connection import (
    port_by_scheme,
    DummyConnection,
    HTTPConnection, HTTPSConnection, VerifiedHTTPSConnection,
    HTTPException, BaseSSLError,
)
from .request import RequestMethods
from .response import HTTPResponse
from .util import (
    get_host,
    is_connection_dropped,
    Timeout,
)


xrange = six.moves.xrange

log = logging.getLogger(__name__)

_Default = object()

## Pool objects

class ConnectionPool(object):
    """
    Base class for all connection pools, such as
    :class:`.HTTPConnectionPool` and :class:`.HTTPSConnectionPool`.
    """

    scheme = None
    QueueCls = LifoQueue

    def __init__(self, host, port=None):
        if host is None:
            raise LocationParseError(host)

        # httplib doesn't like it when we include brackets in ipv6 addresses
        host = host.strip('[]')

        self.host = host
        self.port = port

    def __str__(self):
        return '%s(host=%r, port=%r)' % (type(self).__name__,
                                         self.host, self.port)

# This is taken from http://hg.python.org/cpython/file/7aaba721ebc0/Lib/socket.py#l252
_blocking_errnos = set([errno.EAGAIN, errno.EWOULDBLOCK])

class HTTPConnectionPool(ConnectionPool, RequestMethods):
    """
    Thread-safe connection pool for one host.

    :param host:
        Host used for this HTTP Connection (e.g. "localhost"), passed into
        :class:`httplib.HTTPConnection`.

    :param port:
        Port used for this HTTP Connection (None is equivalent to 80), passed
        into :class:`httplib.HTTPConnection`.

    :param strict:
        Causes BadStatusLine to be raised if the status line can't be parsed
        as a valid HTTP/1.0 or 1.1 status line, passed into
        :class:`httplib.HTTPConnection`.

        .. note::
           Only works in Python 2. This parameter is ignored in Python 3.

    :param timeout:
        Socket timeout in seconds for each individual connection. This can
        be a float or integer, which sets the timeout for the HTTP request,
        or an instance of :class:`urllib3.util.Timeout` which gives you more
        fine-grained control over request timeouts. After the constructor has
        been parsed, this is always a `urllib3.util.Timeout` object.

    :param maxsize:
        Number of connections to save that can be reused. More than 1 is useful
        in multithreaded situations. If ``block`` is set to false, more
        connections will be created but they will not be saved once they've
        been used.

    :param block:
        If set to True, no more than ``maxsize`` connections will be used at
        a time. When no free connections are available, the call will block
        until a connection has been released. This is a useful side effect for
        particular multithreaded situations where one does not want to use more
        than maxsize connections per host to prevent flooding.

    :param headers:
        Headers to include with all requests, unless other headers are given
        explicitly.

    :param _proxy:
        Parsed proxy URL, should not be used directly, instead, see
        :class:`urllib3.connectionpool.ProxyManager`"

    :param _proxy_headers:
        A dictionary with proxy headers, should not be used directly,
        instead, see :class:`urllib3.connectionpool.ProxyManager`"
    """

    scheme = 'http'
    ConnectionCls = HTTPConnection

    def __init__(self, host, port=None, strict=False,
                 timeout=Timeout.DEFAULT_TIMEOUT, maxsize=1, block=False,
                 headers=None, _proxy=None, _proxy_headers=None, **conn_kw):
        ConnectionPool.__init__(self, host, port)
        RequestMethods.__init__(self, headers)

        self.strict = strict

        # This is for backwards compatibility and can be removed once a timeout
        # can only be set to a Timeout object
        if not isinstance(timeout, Timeout):
            timeout = Timeout.from_float(timeout)

        self.timeout = timeout

        self.pool = self.QueueCls(maxsize)
        self.block = block

        self.proxy = _proxy
        self.proxy_headers = _proxy_headers or {}

        # Fill the queue up so that doing get() on it will block properly
        for _ in xrange(maxsize):
            self.pool.put(None)

        # These are mostly for testing and debugging purposes.
        self.num_connections = 0
        self.num_requests = 0

        if sys.version_info < (2, 7):  # Python 2.6 and older
            conn_kw.pop('source_address', None)
        self.conn_kw = conn_kw

    def _new_conn(self):
        """
        Return a fresh :class:`HTTPConnection`.
        """
        self.num_connections += 1
        log.info("Starting new HTTP connection (%d): %s" %
                 (self.num_connections, self.host))

        conn = self.ConnectionCls(host=self.host, port=self.port,
                                  timeout=self.timeout.connect_timeout,
                                  strict=self.strict, **self.conn_kw)
        if self.proxy is not None:
            # Enable Nagle's algorithm for proxies, to avoid packet
            # fragmentation.
            conn.tcp_nodelay = 0
        return conn

    def _get_conn(self, timeout=None):
        """
        Get a connection. Will return a pooled connection if one is available.

        If no connections are available and :prop:`.block` is ``False``, then a
        fresh connection is returned.

        :param timeout:
            Seconds to wait before giving up and raising
            :class:`urllib3.exceptions.EmptyPoolError` if the pool is empty and
            :prop:`.block` is ``True``.
        """
        conn = None
        try:
            conn = self.pool.get(block=self.block, timeout=timeout)

        except AttributeError: # self.pool is None
            raise ClosedPoolError(self, "Pool is closed.")

        except Empty:
            if self.block:
                raise EmptyPoolError(self,
                                     "Pool reached maximum size and no more "
                                     "connections are allowed.")
            pass  # Oh well, we'll create a new connection then

        # If this is a persistent connection, check if it got disconnected
        if conn and is_connection_dropped(conn):
            log.info("Resetting dropped connection: %s" % self.host)
            conn.close()

        return conn or self._new_conn()

    def _put_conn(self, conn):
        """
        Put a connection back into the pool.

        :param conn:
            Connection object for the current host and port as returned by
            :meth:`._new_conn` or :meth:`._get_conn`.

        If the pool is already full, the connection is closed and discarded
        because we exceeded maxsize. If connections are discarded frequently,
        then maxsize should be increased.

        If the pool is closed, then the connection will be closed and discarded.
        """
        try:
            self.pool.put(conn, block=False)
            return # Everything is dandy, done.
        except AttributeError:
            # self.pool is None.
            pass
        except Full:
            # This should never happen if self.block == True
            log.warning(
                "Connection pool is full, discarding connection: %s" %
                self.host)

        # Connection never got put back into the pool, close it.
        if conn:
            conn.close()

    def _get_timeout(self, timeout):
        """ Helper that always returns a :class:`urllib3.util.Timeout` """
        if timeout is _Default:
            return self.timeout.clone()

        if isinstance(timeout, Timeout):
            return timeout.clone()
        else:
            # User passed us an int/float. This is for backwards compatibility,
            # can be removed later
            return Timeout.from_float(timeout)

    def _make_request(self, conn, method, url, timeout=_Default,
                      **httplib_request_kw):
        """
        Perform a request on a given urllib connection object taken from our
        pool.

        :param conn:
            a connection from one of our connection pools

        :param timeout:
            Socket timeout in seconds for the request. This can be a
            float or integer, which will set the same timeout value for
            the socket connect and the socket read, or an instance of
            :class:`urllib3.util.Timeout`, which gives you more fine-grained
            control over your timeouts.
        """
        self.num_requests += 1

        timeout_obj = self._get_timeout(timeout)

        try:
            timeout_obj.start_connect()
            conn.timeout = timeout_obj.connect_timeout
            # conn.request() calls httplib.*.request, not the method in
            # urllib3.request. It also calls makefile (recv) on the socket.
            conn.request(method, url, **httplib_request_kw)
        except SocketTimeout:
            raise ConnectTimeoutError(
                self, "Connection to %s timed out. (connect timeout=%s)" %
                (self.host, timeout_obj.connect_timeout))

        # Reset the timeout for the recv() on the socket
        read_timeout = timeout_obj.read_timeout

        # App Engine doesn't have a sock attr
        if hasattr(conn, 'sock'):
            # In Python 3 socket.py will catch EAGAIN and return None when you
            # try and read into the file pointer created by http.client, which
            # instead raises a BadStatusLine exception. Instead of catching
            # the exception and assuming all BadStatusLine exceptions are read
            # timeouts, check for a zero timeout before making the request.
            if read_timeout == 0:
                raise ReadTimeoutError(
                    self, url,
                    "Read timed out. (read timeout=%s)" % read_timeout)
            if read_timeout is Timeout.DEFAULT_TIMEOUT:
                conn.sock.settimeout(socket.getdefaulttimeout())
            else: # None or a value
                conn.sock.settimeout(read_timeout)

        # Receive the response from the server
        try:
            try: # Python 2.7+, use buffering of HTTP responses
                httplib_response = conn.getresponse(buffering=True)
            except TypeError: # Python 2.6 and older
                httplib_response = conn.getresponse()
        except SocketTimeout:
            raise ReadTimeoutError(
                self, url, "Read timed out. (read timeout=%s)" % read_timeout)

        except BaseSSLError as e:
            # Catch possible read timeouts thrown as SSL errors. If not the
            # case, rethrow the original. We need to do this because of:
            # http://bugs.python.org/issue10272
            if 'timed out' in str(e) or \
               'did not complete (read)' in str(e):  # Python 2.6
                raise ReadTimeoutError(self, url, "Read timed out.")

            raise

        except SocketError as e: # Platform-specific: Python 2
            # See the above comment about EAGAIN in Python 3. In Python 2 we
            # have to specifically catch it and throw the timeout error
            if e.errno in _blocking_errnos:
                raise ReadTimeoutError(
                    self, url,
                    "Read timed out. (read timeout=%s)" % read_timeout)

            raise

        # AppEngine doesn't have a version attr.
        http_version = getattr(conn, '_http_vsn_str', 'HTTP/?')
        log.debug("\"%s %s %s\" %s %s" % (method, url, http_version,
                                          httplib_response.status,
                                          httplib_response.length))
        return httplib_response

    def close(self):
        """
        Close all pooled connections and disable the pool.
        """
        # Disable access to the pool
        old_pool, self.pool = self.pool, None

        try:
            while True:
                conn = old_pool.get(block=False)
                if conn:
                    conn.close()

        except Empty:
            pass # Done.

    def is_same_host(self, url):
        """
        Check if the given ``url`` is a member of the same host as this
        connection pool.
        """
        if url.startswith('/'):
            return True

        # TODO: Add optional support for socket.gethostbyname checking.
        scheme, host, port = get_host(url)

        # Use explicit default port for comparison when none is given
        if self.port and not port:
            port = port_by_scheme.get(scheme)
        elif not self.port and port == port_by_scheme.get(scheme):
            port = None

        return (scheme, host, port) == (self.scheme, self.host, self.port)

    def urlopen(self, method, url, body=None, headers=None, retries=3,
                redirect=True, assert_same_host=True, timeout=_Default,
                pool_timeout=None, release_conn=None, **response_kw):
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.

        .. note::

           More commonly, it's appropriate to use a convenience method provided
           by :class:`.RequestMethods`, such as :meth:`request`.

        .. note::

           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.

        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)

        :param body:
            Data to send in the request body (useful for creating
            POST requests, see HTTPConnectionPool.post_url for
            more convenience).

        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.

        :param retries:
            Number of retries to allow before raising a MaxRetryError exception.
            If `False`, then retries are disabled and any exception is raised
            immediately.

        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.

        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When False, you can
            use the pool on an HTTP proxy and request foreign hosts.

        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.

        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.

        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of
            ``response_kw.get('preload_content', True)``.

        :param \**response_kw:
            Additional parameters are passed to
            :meth:`urllib3.response.HTTPResponse.from_httplib`
        """
        if headers is None:
            headers = self.headers

        if retries < 0 and retries is not False:
            raise MaxRetryError(self, url)

        if release_conn is None:
            release_conn = response_kw.get('preload_content', True)

        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries - 1)

        conn = None

        # Merge the proxy headers. Only do this in HTTP. We have to copy the
        # headers dict so we can safely change it without those changes being
        # reflected in anyone else's copy.
        if self.scheme == 'http':
            headers = headers.copy()
            headers.update(self.proxy_headers)

        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None

        try:
            # Request a connection from the queue
            conn = self._get_conn(timeout=pool_timeout)

            # Make the request on the httplib connection object
            httplib_response = self._make_request(conn, method, url,
                                                  timeout=timeout,
                                                  body=body, headers=headers)

            # If we're going to release the connection in ``finally:``, then
            # the request doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = not release_conn and conn

            # Import httplib's response into our own wrapper object
            response = HTTPResponse.from_httplib(httplib_response,
                                                 pool=self,
                                                 connection=response_conn,
                                                 **response_kw)

            # else:
            #     The connection will be put back into the pool when
            #     ``response.release_conn()`` is called (implicitly by
            #     ``response.read()``)

        except Empty:
            # Timed out by queue.
            raise EmptyPoolError(self, "No pool connections are available.")

        except (BaseSSLError, CertificateError) as e:
            # Release connection unconditionally because there is no way to
            # close it externally in case of exception.
            release_conn = True
            raise SSLError(e)

        except (TimeoutError, HTTPException, SocketError) as e:
            if conn:
                # Discard the connection for these exceptions. It will be
                # be replaced during the next _get_conn() call.
                conn.close()
                conn = None

            if not retries:
                if isinstance(e, TimeoutError):
                    # TimeoutError is exempt from MaxRetryError-wrapping.
                    # FIXME: ... Not sure why. Add a reason here.
                    raise

                # Wrap unexpected exceptions with the most appropriate
                # module-level exception and re-raise.
                if isinstance(e, SocketError) and self.proxy:
                    raise ProxyError('Cannot connect to proxy.', e)

                if retries is False:
                    raise ConnectionError('Connection failed.', e)

                raise MaxRetryError(self, url, e)

            # Keep track of the error for the retry warning.
            err = e

        finally:
            if release_conn:
                # Put the connection back to be reused. If the connection is
                # expired then it will be None, which will get replaced with a
                # fresh connection during _get_conn.
                self._put_conn(conn)

        if not conn:
            # Try again
            log.warning("Retrying (%d attempts remain) after connection "
                        "broken by '%r': %s" % (retries, err, url))
            return self.urlopen(method, url, body, headers, retries - 1,
                                redirect, assert_same_host,
                                timeout=timeout, pool_timeout=pool_timeout,
                                release_conn=release_conn, **response_kw)

        # Handle redirect?
        redirect_location = redirect and response.get_redirect_location()
        if redirect_location and retries is not False:
            if response.status == 303:
                method = 'GET'
            log.info("Redirecting %s -> %s" % (url, redirect_location))
            return self.urlopen(method, redirect_location, body, headers,
                                retries - 1, redirect, assert_same_host,
                                timeout=timeout, pool_timeout=pool_timeout,
                                release_conn=release_conn, **response_kw)

        return response


class HTTPSConnectionPool(HTTPConnectionPool):
    """
    Same as :class:`.HTTPConnectionPool`, but HTTPS.

    When Python is compiled with the :mod:`ssl` module, then
    :class:`.VerifiedHTTPSConnection` is used, which *can* verify certificates,
    instead of :class:`.HTTPSConnection`.

    :class:`.VerifiedHTTPSConnection` uses one of ``assert_fingerprint``,
    ``assert_hostname`` and ``host`` in this order to verify connections.
    If ``assert_hostname`` is False, no verification is done.

    The ``key_file``, ``cert_file``, ``cert_reqs``, ``ca_certs`` and
    ``ssl_version`` are only used if :mod:`ssl` is available and are fed into
    :meth:`urllib3.util.ssl_wrap_socket` to upgrade the connection socket
    into an SSL socket.
    """

    scheme = 'https'
    ConnectionCls = HTTPSConnection

    def __init__(self, host, port=None,
                 strict=False, timeout=None, maxsize=1,
                 block=False, headers=None,
                 _proxy=None, _proxy_headers=None,
                 key_file=None, cert_file=None, cert_reqs=None,
                 ca_certs=None, ssl_version=None,
                 assert_hostname=None, assert_fingerprint=None,
                 **conn_kw):

        if sys.version_info < (2, 7):  # Python 2.6 or older
            conn_kw.pop('source_address', None)

        HTTPConnectionPool.__init__(self, host, port, strict, timeout, maxsize,
                                    block, headers, _proxy, _proxy_headers, **conn_kw)
        self.key_file = key_file
        self.cert_file = cert_file
        self.cert_reqs = cert_reqs
        self.ca_certs = ca_certs
        self.ssl_version = ssl_version
        self.assert_hostname = assert_hostname
        self.assert_fingerprint = assert_fingerprint
        self.conn_kw = conn_kw

    def _prepare_conn(self, conn):
        """
        Prepare the ``connection`` for :meth:`urllib3.util.ssl_wrap_socket`
        and establish the tunnel if proxy is used.
        """

        if isinstance(conn, VerifiedHTTPSConnection):
            conn.set_cert(key_file=self.key_file,
                          cert_file=self.cert_file,
                          cert_reqs=self.cert_reqs,
                          ca_certs=self.ca_certs,
                          assert_hostname=self.assert_hostname,
                          assert_fingerprint=self.assert_fingerprint)
            conn.ssl_version = self.ssl_version
            conn.conn_kw = self.conn_kw

        if self.proxy is not None:
            # Python 2.7+
            try:
                set_tunnel = conn.set_tunnel
            except AttributeError:  # Platform-specific: Python 2.6
                set_tunnel = conn._set_tunnel
            set_tunnel(self.host, self.port, self.proxy_headers)
            # Establish tunnel connection early, because otherwise httplib
            # would improperly set Host: header to proxy's IP:port.
            conn.connect()

        return conn

    def _new_conn(self):
        """
        Return a fresh :class:`httplib.HTTPSConnection`.
        """
        self.num_connections += 1
        log.info("Starting new HTTPS connection (%d): %s"
                 % (self.num_connections, self.host))

        if not self.ConnectionCls or self.ConnectionCls is DummyConnection:
            # Platform-specific: Python without ssl
            raise SSLError("Can't connect to HTTPS URL because the SSL "
                           "module is not available.")

        actual_host = self.host
        actual_port = self.port
        if self.proxy is not None:
            actual_host = self.proxy.host
            actual_port = self.proxy.port

        extra_params = {}
        if not six.PY3:  # Python 2
            extra_params['strict'] = self.strict
        extra_params.update(self.conn_kw)

        conn = self.ConnectionCls(host=actual_host, port=actual_port,
                                  timeout=self.timeout.connect_timeout,
                                  **extra_params)
        if self.proxy is not None:
            # Enable Nagle's algorithm for proxies, to avoid packet
            # fragmentation.
            conn.tcp_nodelay = 0

        return self._prepare_conn(conn)


def connection_from_url(url, **kw):
    """
    Given a url, return an :class:`.ConnectionPool` instance of its host.

    This is a shortcut for not having to parse out the scheme, host, and port
    of the url before creating an :class:`.ConnectionPool` instance.

    :param url:
        Absolute URL string that must include the scheme. Port is optional.

    :param \**kw:
        Passes additional parameters to the constructor of the appropriate
        :class:`.ConnectionPool`. Useful for specifying things like
        timeout, maxsize, headers, etc.

    Example: ::

        >>> conn = connection_from_url('http://google.com/')
        >>> r = conn.request('GET', '/')
    """
    scheme, host, port = get_host(url)
    if scheme == 'https':
        return HTTPSConnectionPool(host, port=port, **kw)
    else:
        return HTTPConnectionPool(host, port=port, **kw)

########NEW FILE########
__FILENAME__ = ntlmpool
# urllib3/contrib/ntlmpool.py
# Copyright 2008-2013 Andrey Petrov and contributors (see CONTRIBUTORS.txt)
#
# This module is part of urllib3 and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

"""
NTLM authenticating pool, contributed by erikcederstran

Issue #10, see: http://code.google.com/p/urllib3/issues/detail?id=10
"""

try:
    from http.client import HTTPSConnection
except ImportError:
    from httplib import HTTPSConnection
from logging import getLogger
from ntlm import ntlm

from urllib3 import HTTPSConnectionPool


log = getLogger(__name__)


class NTLMConnectionPool(HTTPSConnectionPool):
    """
    Implements an NTLM authentication version of an urllib3 connection pool
    """

    scheme = 'https'

    def __init__(self, user, pw, authurl, *args, **kwargs):
        """
        authurl is a random URL on the server that is protected by NTLM.
        user is the Windows user, probably in the DOMAIN\\username format.
        pw is the password for the user.
        """
        super(NTLMConnectionPool, self).__init__(*args, **kwargs)
        self.authurl = authurl
        self.rawuser = user
        user_parts = user.split('\\', 1)
        self.domain = user_parts[0].upper()
        self.user = user_parts[1]
        self.pw = pw

    def _new_conn(self):
        # Performs the NTLM handshake that secures the connection. The socket
        # must be kept open while requests are performed.
        self.num_connections += 1
        log.debug('Starting NTLM HTTPS connection no. %d: https://%s%s' %
                  (self.num_connections, self.host, self.authurl))

        headers = {}
        headers['Connection'] = 'Keep-Alive'
        req_header = 'Authorization'
        resp_header = 'www-authenticate'

        conn = HTTPSConnection(host=self.host, port=self.port)

        # Send negotiation message
        headers[req_header] = (
            'NTLM %s' % ntlm.create_NTLM_NEGOTIATE_MESSAGE(self.rawuser))
        log.debug('Request headers: %s' % headers)
        conn.request('GET', self.authurl, None, headers)
        res = conn.getresponse()
        reshdr = dict(res.getheaders())
        log.debug('Response status: %s %s' % (res.status, res.reason))
        log.debug('Response headers: %s' % reshdr)
        log.debug('Response data: %s [...]' % res.read(100))

        # Remove the reference to the socket, so that it can not be closed by
        # the response object (we want to keep the socket open)
        res.fp = None

        # Server should respond with a challenge message
        auth_header_values = reshdr[resp_header].split(', ')
        auth_header_value = None
        for s in auth_header_values:
            if s[:5] == 'NTLM ':
                auth_header_value = s[5:]
        if auth_header_value is None:
            raise Exception('Unexpected %s response header: %s' %
                            (resp_header, reshdr[resp_header]))

        # Send authentication message
        ServerChallenge, NegotiateFlags = \
            ntlm.parse_NTLM_CHALLENGE_MESSAGE(auth_header_value)
        auth_msg = ntlm.create_NTLM_AUTHENTICATE_MESSAGE(ServerChallenge,
                                                         self.user,
                                                         self.domain,
                                                         self.pw,
                                                         NegotiateFlags)
        headers[req_header] = 'NTLM %s' % auth_msg
        log.debug('Request headers: %s' % headers)
        conn.request('GET', self.authurl, None, headers)
        res = conn.getresponse()
        log.debug('Response status: %s %s' % (res.status, res.reason))
        log.debug('Response headers: %s' % dict(res.getheaders()))
        log.debug('Response data: %s [...]' % res.read()[:100])
        if res.status != 200:
            if res.status == 401:
                raise Exception('Server rejected request: wrong '
                                'username or password')
            raise Exception('Wrong server response: %s %s' %
                            (res.status, res.reason))

        res.fp = None
        log.debug('Connection established')
        return conn

    def urlopen(self, method, url, body=None, headers=None, retries=3,
                redirect=True, assert_same_host=True):
        if headers is None:
            headers = {}
        headers['Connection'] = 'Keep-Alive'
        return super(NTLMConnectionPool, self).urlopen(method, url, body,
                                                       headers, retries,
                                                       redirect,
                                                       assert_same_host)

########NEW FILE########
__FILENAME__ = pyopenssl
'''SSL with SNI_-support for Python 2. Follow these instructions if you would
like to verify SSL certificates in Python 2. Note, the default libraries do
*not* do certificate checking; you need to do additional work to validate
certificates yourself.

This needs the following packages installed:

* pyOpenSSL (tested with 0.13)
* ndg-httpsclient (tested with 0.3.2)
* pyasn1 (tested with 0.1.6)

You can install them with the following command:

    pip install pyopenssl ndg-httpsclient pyasn1

To activate certificate checking, call
:func:`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code
before you begin making HTTP requests. This can be done in a ``sitecustomize``
module, or at any other time before your application begins using ``urllib3``,
like this::

    try:
        import urllib3.contrib.pyopenssl
        urllib3.contrib.pyopenssl.inject_into_urllib3()
    except ImportError:
        pass

Now you can use :mod:`urllib3` as you normally would, and it will support SNI
when the required modules are installed.

Activating this module also has the positive side effect of disabling SSL/TLS
encryption in Python 2 (see `CRIME attack`_).

If you want to configure the default list of supported cipher suites, you can
set the ``urllib3.contrib.pyopenssl.DEFAULT_SSL_CIPHER_LIST`` variable.

Module Variables
----------------

:var DEFAULT_SSL_CIPHER_LIST: The list of supported SSL/TLS cipher suites.
    Default: ``ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:ECDH+AES128:DH+AES:
    ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:!aNULL:!MD5:!DSS``

.. _sni: https://en.wikipedia.org/wiki/Server_Name_Indication
.. _crime attack: https://en.wikipedia.org/wiki/CRIME_(security_exploit)

'''

from ndg.httpsclient.ssl_peer_verification import SUBJ_ALT_NAME_SUPPORT
from ndg.httpsclient.subj_alt_name import SubjectAltName as BaseSubjectAltName
import OpenSSL.SSL
from pyasn1.codec.der import decoder as der_decoder
from pyasn1.type import univ, constraint
from socket import _fileobject, timeout
import ssl
import select
from cStringIO import StringIO

from .. import connection
from .. import util

__all__ = ['inject_into_urllib3', 'extract_from_urllib3']

# SNI only *really* works if we can read the subjectAltName of certificates.
HAS_SNI = SUBJ_ALT_NAME_SUPPORT

# Map from urllib3 to PyOpenSSL compatible parameter-values.
_openssl_versions = {
    ssl.PROTOCOL_SSLv23: OpenSSL.SSL.SSLv23_METHOD,
    ssl.PROTOCOL_SSLv3: OpenSSL.SSL.SSLv3_METHOD,
    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,
}
_openssl_verify = {
    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,
    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,
    ssl.CERT_REQUIRED: OpenSSL.SSL.VERIFY_PEER
                       + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,
}

# A secure default.
# Sources for more information on TLS ciphers:
#
# - https://wiki.mozilla.org/Security/Server_Side_TLS
# - https://www.ssllabs.com/projects/best-practices/index.html
# - https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/
#
# The general intent is:
# - Prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE),
# - prefer ECDHE over DHE for better performance,
# - prefer any AES-GCM over any AES-CBC for better performance and security,
# - use 3DES as fallback which is secure but slow,
# - disable NULL authentication, MD5 MACs and DSS for security reasons.
DEFAULT_SSL_CIPHER_LIST = "ECDH+AESGCM:DH+AESGCM:ECDH+AES256:DH+AES256:" + \
    "ECDH+AES128:DH+AES:ECDH+3DES:DH+3DES:RSA+AESGCM:RSA+AES:RSA+3DES:" + \
    "!aNULL:!MD5:!DSS"


orig_util_HAS_SNI = util.HAS_SNI
orig_connection_ssl_wrap_socket = connection.ssl_wrap_socket


def inject_into_urllib3():
    'Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.'

    connection.ssl_wrap_socket = ssl_wrap_socket
    util.HAS_SNI = HAS_SNI


def extract_from_urllib3():
    'Undo monkey-patching by :func:`inject_into_urllib3`.'

    connection.ssl_wrap_socket = orig_connection_ssl_wrap_socket
    util.HAS_SNI = orig_util_HAS_SNI


### Note: This is a slightly bug-fixed version of same from ndg-httpsclient.
class SubjectAltName(BaseSubjectAltName):
    '''ASN.1 implementation for subjectAltNames support'''

    # There is no limit to how many SAN certificates a certificate may have,
    #   however this needs to have some limit so we'll set an arbitrarily high
    #   limit.
    sizeSpec = univ.SequenceOf.sizeSpec + \
        constraint.ValueSizeConstraint(1, 1024)


### Note: This is a slightly bug-fixed version of same from ndg-httpsclient.
def get_subj_alt_name(peer_cert):
    # Search through extensions
    dns_name = []
    if not SUBJ_ALT_NAME_SUPPORT:
        return dns_name

    general_names = SubjectAltName()
    for i in range(peer_cert.get_extension_count()):
        ext = peer_cert.get_extension(i)
        ext_name = ext.get_short_name()
        if ext_name != 'subjectAltName':
            continue

        # PyOpenSSL returns extension data in ASN.1 encoded form
        ext_dat = ext.get_data()
        decoded_dat = der_decoder.decode(ext_dat,
                                         asn1Spec=general_names)

        for name in decoded_dat:
            if not isinstance(name, SubjectAltName):
                continue
            for entry in range(len(name)):
                component = name.getComponentByPosition(entry)
                if component.getName() != 'dNSName':
                    continue
                dns_name.append(str(component.getComponent()))

    return dns_name


class fileobject(_fileobject):

    def _wait_for_sock(self):
        rd, wd, ed = select.select([self._sock], [], [],
                                   self._sock.gettimeout())
        if not rd:
            raise timeout()


    def read(self, size=-1):
        # Use max, disallow tiny reads in a loop as they are very inefficient.
        # We never leave read() with any leftover data from a new recv() call
        # in our internal buffer.
        rbufsize = max(self._rbufsize, self.default_bufsize)
        # Our use of StringIO rather than lists of string objects returned by
        # recv() minimizes memory usage and fragmentation that occurs when
        # rbufsize is large compared to the typical return value of recv().
        buf = self._rbuf
        buf.seek(0, 2)  # seek end
        if size < 0:
            # Read until EOF
            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                try:
                    data = self._sock.recv(rbufsize)
                except OpenSSL.SSL.WantReadError:
                    self._wait_for_sock()
                    continue
                if not data:
                    break
                buf.write(data)
            return buf.getvalue()
        else:
            # Read until size bytes or EOF seen, whichever comes first
            buf_len = buf.tell()
            if buf_len >= size:
                # Already have size bytes in our buffer?  Extract and return.
                buf.seek(0)
                rv = buf.read(size)
                self._rbuf = StringIO()
                self._rbuf.write(buf.read())
                return rv

            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                left = size - buf_len
                # recv() will malloc the amount of memory given as its
                # parameter even though it often returns much less data
                # than that.  The returned data string is short lived
                # as we copy it into a StringIO and free it.  This avoids
                # fragmentation issues on many platforms.
                try:
                    data = self._sock.recv(left)
                except OpenSSL.SSL.WantReadError:
                    self._wait_for_sock()
                    continue
                if not data:
                    break
                n = len(data)
                if n == size and not buf_len:
                    # Shortcut.  Avoid buffer data copies when:
                    # - We have no data in our buffer.
                    # AND
                    # - Our call to recv returned exactly the
                    #   number of bytes we were asked to read.
                    return data
                if n == left:
                    buf.write(data)
                    del data  # explicit free
                    break
                assert n <= left, "recv(%d) returned %d bytes" % (left, n)
                buf.write(data)
                buf_len += n
                del data  # explicit free
                #assert buf_len == buf.tell()
            return buf.getvalue()

    def readline(self, size=-1):
        buf = self._rbuf
        buf.seek(0, 2)  # seek end
        if buf.tell() > 0:
            # check if we already have it in our buffer
            buf.seek(0)
            bline = buf.readline(size)
            if bline.endswith('\n') or len(bline) == size:
                self._rbuf = StringIO()
                self._rbuf.write(buf.read())
                return bline
            del bline
        if size < 0:
            # Read until \n or EOF, whichever comes first
            if self._rbufsize <= 1:
                # Speed up unbuffered case
                buf.seek(0)
                buffers = [buf.read()]
                self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
                data = None
                recv = self._sock.recv
                while True:
                    try:
                        while data != "\n":
                            data = recv(1)
                            if not data:
                                break
                            buffers.append(data)
                    except OpenSSL.SSL.WantReadError:
                        self._wait_for_sock()
                        continue
                    break
                return "".join(buffers)

            buf.seek(0, 2)  # seek end
            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                try:
                    data = self._sock.recv(self._rbufsize)
                except OpenSSL.SSL.WantReadError:
                    self._wait_for_sock()
                    continue
                if not data:
                    break
                nl = data.find('\n')
                if nl >= 0:
                    nl += 1
                    buf.write(data[:nl])
                    self._rbuf.write(data[nl:])
                    del data
                    break
                buf.write(data)
            return buf.getvalue()
        else:
            # Read until size bytes or \n or EOF seen, whichever comes first
            buf.seek(0, 2)  # seek end
            buf_len = buf.tell()
            if buf_len >= size:
                buf.seek(0)
                rv = buf.read(size)
                self._rbuf = StringIO()
                self._rbuf.write(buf.read())
                return rv
            self._rbuf = StringIO()  # reset _rbuf.  we consume it via buf.
            while True:
                try:
                    data = self._sock.recv(self._rbufsize)
                except OpenSSL.SSL.WantReadError:
                    self._wait_for_sock()
                    continue
                if not data:
                    break
                left = size - buf_len
                # did we just receive a newline?
                nl = data.find('\n', 0, left)
                if nl >= 0:
                    nl += 1
                    # save the excess data to _rbuf
                    self._rbuf.write(data[nl:])
                    if buf_len:
                        buf.write(data[:nl])
                        break
                    else:
                        # Shortcut.  Avoid data copy through buf when returning
                        # a substring of our first recv().
                        return data[:nl]
                n = len(data)
                if n == size and not buf_len:
                    # Shortcut.  Avoid data copy through buf when
                    # returning exactly all of our first recv().
                    return data
                if n >= left:
                    buf.write(data[:left])
                    self._rbuf.write(data[left:])
                    break
                buf.write(data)
                buf_len += n
                #assert buf_len == buf.tell()
            return buf.getvalue()


class WrappedSocket(object):
    '''API-compatibility wrapper for Python OpenSSL's Connection-class.'''

    def __init__(self, connection, socket):
        self.connection = connection
        self.socket = socket

    def fileno(self):
        return self.socket.fileno()

    def makefile(self, mode, bufsize=-1):
        return fileobject(self.connection, mode, bufsize)

    def settimeout(self, timeout):
        return self.socket.settimeout(timeout)

    def sendall(self, data):
        return self.connection.sendall(data)

    def close(self):
        return self.connection.shutdown()

    def getpeercert(self, binary_form=False):
        x509 = self.connection.get_peer_certificate()

        if not x509:
            return x509

        if binary_form:
            return OpenSSL.crypto.dump_certificate(
                OpenSSL.crypto.FILETYPE_ASN1,
                x509)

        return {
            'subject': (
                (('commonName', x509.get_subject().CN),),
            ),
            'subjectAltName': [
                ('DNS', value)
                for value in get_subj_alt_name(x509)
            ]
        }


def _verify_callback(cnx, x509, err_no, err_depth, return_code):
    return err_no == 0


def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,
                    ca_certs=None, server_hostname=None,
                    ssl_version=None):
    ctx = OpenSSL.SSL.Context(_openssl_versions[ssl_version])
    if certfile:
        ctx.use_certificate_file(certfile)
    if keyfile:
        ctx.use_privatekey_file(keyfile)
    if cert_reqs != ssl.CERT_NONE:
        ctx.set_verify(_openssl_verify[cert_reqs], _verify_callback)
    if ca_certs:
        try:
            ctx.load_verify_locations(ca_certs, None)
        except OpenSSL.SSL.Error as e:
            raise ssl.SSLError('bad ca_certs: %r' % ca_certs, e)
    else:
        ctx.set_default_verify_paths()

    # Disable TLS compression to migitate CRIME attack (issue #309)
    OP_NO_COMPRESSION = 0x20000
    ctx.set_options(OP_NO_COMPRESSION)

    # Set list of supported ciphersuites.
    ctx.set_cipher_list(DEFAULT_SSL_CIPHER_LIST)

    cnx = OpenSSL.SSL.Connection(ctx, sock)
    cnx.set_tlsext_host_name(server_hostname)
    cnx.set_connect_state()
    while True:
        try:
            cnx.do_handshake()
        except OpenSSL.SSL.WantReadError:
            select.select([sock], [], [])
            continue
        except OpenSSL.SSL.Error as e:
            raise ssl.SSLError('bad handshake', e)
        break

    return WrappedSocket(cnx, sock)

########NEW FILE########
__FILENAME__ = exceptions
# urllib3/exceptions.py
# Copyright 2008-2013 Andrey Petrov and contributors (see CONTRIBUTORS.txt)
#
# This module is part of urllib3 and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php


## Base Exceptions

class HTTPError(Exception):
    "Base exception used by this module."
    pass


class PoolError(HTTPError):
    "Base exception for errors caused within a pool."
    def __init__(self, pool, message):
        self.pool = pool
        HTTPError.__init__(self, "%s: %s" % (pool, message))

    def __reduce__(self):
        # For pickling purposes.
        return self.__class__, (None, None)


class RequestError(PoolError):
    "Base exception for PoolErrors that have associated URLs."
    def __init__(self, pool, url, message):
        self.url = url
        PoolError.__init__(self, pool, message)

    def __reduce__(self):
        # For pickling purposes.
        return self.__class__, (None, self.url, None)


class SSLError(HTTPError):
    "Raised when SSL certificate fails in an HTTPS connection."
    pass


class ProxyError(HTTPError):
    "Raised when the connection to a proxy fails."
    pass


class ConnectionError(HTTPError):
    "Raised when a normal connection fails."
    pass


class DecodeError(HTTPError):
    "Raised when automatic decoding based on Content-Type fails."
    pass


## Leaf Exceptions

class MaxRetryError(RequestError):
    "Raised when the maximum number of retries is exceeded."

    def __init__(self, pool, url, reason=None):
        self.reason = reason

        message = "Max retries exceeded with url: %s" % url
        if reason:
            message += " (Caused by %s: %s)" % (type(reason), reason)
        else:
            message += " (Caused by redirect)"

        RequestError.__init__(self, pool, url, message)


class HostChangedError(RequestError):
    "Raised when an existing pool gets a request for a foreign host."

    def __init__(self, pool, url, retries=3):
        message = "Tried to open a foreign host with url: %s" % url
        RequestError.__init__(self, pool, url, message)
        self.retries = retries


class TimeoutStateError(HTTPError):
    """ Raised when passing an invalid state to a timeout """
    pass


class TimeoutError(HTTPError):
    """ Raised when a socket timeout error occurs.

    Catching this error will catch both :exc:`ReadTimeoutErrors
    <ReadTimeoutError>` and :exc:`ConnectTimeoutErrors <ConnectTimeoutError>`.
    """
    pass


class ReadTimeoutError(TimeoutError, RequestError):
    "Raised when a socket timeout occurs while receiving data from a server"
    pass


# This timeout error does not have a URL attached and needs to inherit from the
# base HTTPError
class ConnectTimeoutError(TimeoutError):
    "Raised when a socket timeout occurs while connecting to a server"
    pass


class EmptyPoolError(PoolError):
    "Raised when a pool runs out of connections and no more are allowed."
    pass


class ClosedPoolError(PoolError):
    "Raised when a request enters a pool after the pool has been closed."
    pass


class LocationParseError(ValueError, HTTPError):
    "Raised when get_host or similar fails to parse the URL input."

    def __init__(self, location):
        message = "Failed to parse: %s" % location
        HTTPError.__init__(self, message)

        self.location = location

########NEW FILE########
__FILENAME__ = fields
# urllib3/fields.py
# Copyright 2008-2013 Andrey Petrov and contributors (see CONTRIBUTORS.txt)
#
# This module is part of urllib3 and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

import email.utils
import mimetypes

from .packages import six


def guess_content_type(filename, default='application/octet-stream'):
    """
    Guess the "Content-Type" of a file.

    :param filename:
        The filename to guess the "Content-Type" of using :mod:`mimetypes`.
    :param default:
        If no "Content-Type" can be guessed, default to `default`.
    """
    if filename:
        return mimetypes.guess_type(filename)[0] or default
    return default


def format_header_param(name, value):
    """
    Helper function to format and quote a single header parameter.

    Particularly useful for header parameters which might contain
    non-ASCII values, like file names. This follows RFC 2231, as
    suggested by RFC 2388 Section 4.4.

    :param name:
        The name of the parameter, a string expected to be ASCII only.
    :param value:
        The value of the parameter, provided as a unicode string.
    """
    if not any(ch in value for ch in '"\\\r\n'):
        result = '%s="%s"' % (name, value)
        try:
            result.encode('ascii')
        except UnicodeEncodeError:
            pass
        else:
            return result
    if not six.PY3:  # Python 2:
        value = value.encode('utf-8')
    value = email.utils.encode_rfc2231(value, 'utf-8')
    value = '%s*=%s' % (name, value)
    return value


class RequestField(object):
    """
    A data container for request body parameters.

    :param name:
        The name of this request field.
    :param data:
        The data/value body.
    :param filename:
        An optional filename of the request field.
    :param headers:
        An optional dict-like object of headers to initially use for the field.
    """
    def __init__(self, name, data, filename=None, headers=None):
        self._name = name
        self._filename = filename
        self.data = data
        self.headers = {}
        if headers:
            self.headers = dict(headers)

    @classmethod
    def from_tuples(cls, fieldname, value):
        """
        A :class:`~urllib3.fields.RequestField` factory from old-style tuple parameters.

        Supports constructing :class:`~urllib3.fields.RequestField` from parameter
        of key/value strings AND key/filetuple. A filetuple is a (filename, data, MIME type)
        tuple where the MIME type is optional. For example: ::

            'foo': 'bar',
            'fakefile': ('foofile.txt', 'contents of foofile'),
            'realfile': ('barfile.txt', open('realfile').read()),
            'typedfile': ('bazfile.bin', open('bazfile').read(), 'image/jpeg'),
            'nonamefile': 'contents of nonamefile field',

        Field names and filenames must be unicode.
        """
        if isinstance(value, tuple):
            if len(value) == 3:
                filename, data, content_type = value
            else:
                filename, data = value
                content_type = guess_content_type(filename)
        else:
            filename = None
            content_type = None
            data = value

        request_param = cls(fieldname, data, filename=filename)
        request_param.make_multipart(content_type=content_type)

        return request_param

    def _render_part(self, name, value):
        """
        Overridable helper function to format a single header parameter.

        :param name:
            The name of the parameter, a string expected to be ASCII only.
        :param value:
            The value of the parameter, provided as a unicode string.
        """
        return format_header_param(name, value)

    def _render_parts(self, header_parts):
        """
        Helper function to format and quote a single header.

        Useful for single headers that are composed of multiple items. E.g.,
        'Content-Disposition' fields.

        :param header_parts:
            A sequence of (k, v) typles or a :class:`dict` of (k, v) to format as
            `k1="v1"; k2="v2"; ...`.
        """
        parts = []
        iterable = header_parts
        if isinstance(header_parts, dict):
            iterable = header_parts.items()

        for name, value in iterable:
            if value:
                parts.append(self._render_part(name, value))

        return '; '.join(parts)

    def render_headers(self):
        """
        Renders the headers for this request field.
        """
        lines = []

        sort_keys = ['Content-Disposition', 'Content-Type', 'Content-Location']
        for sort_key in sort_keys:
            if self.headers.get(sort_key, False):
                lines.append('%s: %s' % (sort_key, self.headers[sort_key]))

        for header_name, header_value in self.headers.items():
            if header_name not in sort_keys:
                if header_value:
                    lines.append('%s: %s' % (header_name, header_value))

        lines.append('\r\n')
        return '\r\n'.join(lines)

    def make_multipart(self, content_disposition=None, content_type=None, content_location=None):
        """
        Makes this request field into a multipart request field.

        This method overrides "Content-Disposition", "Content-Type" and
        "Content-Location" headers to the request parameter.

        :param content_type:
            The 'Content-Type' of the request body.
        :param content_location:
            The 'Content-Location' of the request body.

        """
        self.headers['Content-Disposition'] = content_disposition or 'form-data'
        self.headers['Content-Disposition'] += '; '.join(['', self._render_parts((('name', self._name), ('filename', self._filename)))])
        self.headers['Content-Type'] = content_type
        self.headers['Content-Location'] = content_location

########NEW FILE########
__FILENAME__ = filepost
# urllib3/filepost.py
# Copyright 2008-2013 Andrey Petrov and contributors (see CONTRIBUTORS.txt)
#
# This module is part of urllib3 and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

import codecs
import mimetypes

from uuid import uuid4
from io import BytesIO

from .packages import six
from .packages.six import b
from .fields import RequestField

writer = codecs.lookup('utf-8')[3]


def choose_boundary():
    """
    Our embarassingly-simple replacement for mimetools.choose_boundary.
    """
    return uuid4().hex


def iter_field_objects(fields):
    """
    Iterate over fields.

    Supports list of (k, v) tuples and dicts, and lists of
    :class:`~urllib3.fields.RequestField`.

    """
    if isinstance(fields, dict):
        i = six.iteritems(fields)
    else:
        i = iter(fields)

    for field in i:
      if isinstance(field, RequestField):
        yield field
      else:
        yield RequestField.from_tuples(*field)


def iter_fields(fields):
    """
    .. deprecated:: 1.6

    Iterate over fields.

    The addition of :class:`~urllib3.fields.RequestField` makes this function
    obsolete. Instead, use :func:`iter_field_objects`, which returns
    :class:`~urllib3.fields.RequestField` objects.

    Supports list of (k, v) tuples and dicts.
    """
    if isinstance(fields, dict):
        return ((k, v) for k, v in six.iteritems(fields))

    return ((k, v) for k, v in fields)


def encode_multipart_formdata(fields, boundary=None):
    """
    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.

    :param fields:
        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).

    :param boundary:
        If not specified, then a random boundary will be generated using
        :func:`mimetools.choose_boundary`.
    """
    body = BytesIO()
    if boundary is None:
        boundary = choose_boundary()

    for field in iter_field_objects(fields):
        body.write(b('--%s\r\n' % (boundary)))

        writer(body).write(field.render_headers())
        data = field.data

        if isinstance(data, int):
            data = str(data)  # Backwards compatibility

        if isinstance(data, six.text_type):
            writer(body).write(data)
        else:
            body.write(data)

        body.write(b'\r\n')

    body.write(b('--%s--\r\n' % (boundary)))

    content_type = str('multipart/form-data; boundary=%s' % boundary)

    return body.getvalue(), content_type

########NEW FILE########
__FILENAME__ = ordered_dict
# Backport of OrderedDict() class that runs on Python 2.4, 2.5, 2.6, 2.7 and pypy.
# Passes Python2.7's test suite and incorporates all the latest updates.
# Copyright 2009 Raymond Hettinger, released under the MIT License.
# http://code.activestate.com/recipes/576693/

try:
    from thread import get_ident as _get_ident
except ImportError:
    from dummy_thread import get_ident as _get_ident

try:
    from _abcoll import KeysView, ValuesView, ItemsView
except ImportError:
    pass


class OrderedDict(dict):
    'Dictionary that remembers insertion order'
    # An inherited dict maps keys to values.
    # The inherited dict provides __getitem__, __len__, __contains__, and get.
    # The remaining methods are order-aware.
    # Big-O running times for all methods are the same as for regular dictionaries.

    # The internal self.__map dictionary maps keys to links in a doubly linked list.
    # The circular doubly linked list starts and ends with a sentinel element.
    # The sentinel element never gets deleted (this simplifies the algorithm).
    # Each link is stored as a list of length three:  [PREV, NEXT, KEY].

    def __init__(self, *args, **kwds):
        '''Initialize an ordered dictionary.  Signature is the same as for
        regular dictionaries, but keyword arguments are not recommended
        because their insertion order is arbitrary.

        '''
        if len(args) > 1:
            raise TypeError('expected at most 1 arguments, got %d' % len(args))
        try:
            self.__root
        except AttributeError:
            self.__root = root = []                     # sentinel node
            root[:] = [root, root, None]
            self.__map = {}
        self.__update(*args, **kwds)

    def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
        'od.__setitem__(i, y) <==> od[i]=y'
        # Setting a new item creates a new link which goes at the end of the linked
        # list, and the inherited dictionary is updated with the new key/value pair.
        if key not in self:
            root = self.__root
            last = root[0]
            last[1] = root[0] = self.__map[key] = [last, root, key]
        dict_setitem(self, key, value)

    def __delitem__(self, key, dict_delitem=dict.__delitem__):
        'od.__delitem__(y) <==> del od[y]'
        # Deleting an existing item uses self.__map to find the link which is
        # then removed by updating the links in the predecessor and successor nodes.
        dict_delitem(self, key)
        link_prev, link_next, key = self.__map.pop(key)
        link_prev[1] = link_next
        link_next[0] = link_prev

    def __iter__(self):
        'od.__iter__() <==> iter(od)'
        root = self.__root
        curr = root[1]
        while curr is not root:
            yield curr[2]
            curr = curr[1]

    def __reversed__(self):
        'od.__reversed__() <==> reversed(od)'
        root = self.__root
        curr = root[0]
        while curr is not root:
            yield curr[2]
            curr = curr[0]

    def clear(self):
        'od.clear() -> None.  Remove all items from od.'
        try:
            for node in self.__map.itervalues():
                del node[:]
            root = self.__root
            root[:] = [root, root, None]
            self.__map.clear()
        except AttributeError:
            pass
        dict.clear(self)

    def popitem(self, last=True):
        '''od.popitem() -> (k, v), return and remove a (key, value) pair.
        Pairs are returned in LIFO order if last is true or FIFO order if false.

        '''
        if not self:
            raise KeyError('dictionary is empty')
        root = self.__root
        if last:
            link = root[0]
            link_prev = link[0]
            link_prev[1] = root
            root[0] = link_prev
        else:
            link = root[1]
            link_next = link[1]
            root[1] = link_next
            link_next[0] = root
        key = link[2]
        del self.__map[key]
        value = dict.pop(self, key)
        return key, value

    # -- the following methods do not depend on the internal structure --

    def keys(self):
        'od.keys() -> list of keys in od'
        return list(self)

    def values(self):
        'od.values() -> list of values in od'
        return [self[key] for key in self]

    def items(self):
        'od.items() -> list of (key, value) pairs in od'
        return [(key, self[key]) for key in self]

    def iterkeys(self):
        'od.iterkeys() -> an iterator over the keys in od'
        return iter(self)

    def itervalues(self):
        'od.itervalues -> an iterator over the values in od'
        for k in self:
            yield self[k]

    def iteritems(self):
        'od.iteritems -> an iterator over the (key, value) items in od'
        for k in self:
            yield (k, self[k])

    def update(*args, **kwds):
        '''od.update(E, **F) -> None.  Update od from dict/iterable E and F.

        If E is a dict instance, does:           for k in E: od[k] = E[k]
        If E has a .keys() method, does:         for k in E.keys(): od[k] = E[k]
        Or if E is an iterable of items, does:   for k, v in E: od[k] = v
        In either case, this is followed by:     for k, v in F.items(): od[k] = v

        '''
        if len(args) > 2:
            raise TypeError('update() takes at most 2 positional '
                            'arguments (%d given)' % (len(args),))
        elif not args:
            raise TypeError('update() takes at least 1 argument (0 given)')
        self = args[0]
        # Make progressively weaker assumptions about "other"
        other = ()
        if len(args) == 2:
            other = args[1]
        if isinstance(other, dict):
            for key in other:
                self[key] = other[key]
        elif hasattr(other, 'keys'):
            for key in other.keys():
                self[key] = other[key]
        else:
            for key, value in other:
                self[key] = value
        for key, value in kwds.items():
            self[key] = value

    __update = update  # let subclasses override update without breaking __init__

    __marker = object()

    def pop(self, key, default=__marker):
        '''od.pop(k[,d]) -> v, remove specified key and return the corresponding value.
        If key is not found, d is returned if given, otherwise KeyError is raised.

        '''
        if key in self:
            result = self[key]
            del self[key]
            return result
        if default is self.__marker:
            raise KeyError(key)
        return default

    def setdefault(self, key, default=None):
        'od.setdefault(k[,d]) -> od.get(k,d), also set od[k]=d if k not in od'
        if key in self:
            return self[key]
        self[key] = default
        return default

    def __repr__(self, _repr_running={}):
        'od.__repr__() <==> repr(od)'
        call_key = id(self), _get_ident()
        if call_key in _repr_running:
            return '...'
        _repr_running[call_key] = 1
        try:
            if not self:
                return '%s()' % (self.__class__.__name__,)
            return '%s(%r)' % (self.__class__.__name__, self.items())
        finally:
            del _repr_running[call_key]

    def __reduce__(self):
        'Return state information for pickling'
        items = [[k, self[k]] for k in self]
        inst_dict = vars(self).copy()
        for k in vars(OrderedDict()):
            inst_dict.pop(k, None)
        if inst_dict:
            return (self.__class__, (items,), inst_dict)
        return self.__class__, (items,)

    def copy(self):
        'od.copy() -> a shallow copy of od'
        return self.__class__(self)

    @classmethod
    def fromkeys(cls, iterable, value=None):
        '''OD.fromkeys(S[, v]) -> New ordered dictionary with keys from S
        and values equal to v (which defaults to None).

        '''
        d = cls()
        for key in iterable:
            d[key] = value
        return d

    def __eq__(self, other):
        '''od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
        while comparison to a regular mapping is order-insensitive.

        '''
        if isinstance(other, OrderedDict):
            return len(self)==len(other) and self.items() == other.items()
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self == other

    # -- the following methods are only used in Python 2.7 --

    def viewkeys(self):
        "od.viewkeys() -> a set-like object providing a view on od's keys"
        return KeysView(self)

    def viewvalues(self):
        "od.viewvalues() -> an object providing a view on od's values"
        return ValuesView(self)

    def viewitems(self):
        "od.viewitems() -> a set-like object providing a view on od's items"
        return ItemsView(self)

########NEW FILE########
__FILENAME__ = six
"""Utilities for writing code that runs on Python 2 and 3"""

#Copyright (c) 2010-2011 Benjamin Peterson

#Permission is hereby granted, free of charge, to any person obtaining a copy of
#this software and associated documentation files (the "Software"), to deal in
#the Software without restriction, including without limitation the rights to
#use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
#the Software, and to permit persons to whom the Software is furnished to do so,
#subject to the following conditions:

#The above copyright notice and this permission notice shall be included in all
#copies or substantial portions of the Software.

#THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
#FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
#COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
#IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
#CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.2.0"  # Revision 41c74fef2ded


# True if we are running on Python 3.
PY3 = sys.version_info[0] == 3

if PY3:
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

    MAXSIZE = sys.maxsize
else:
    string_types = basestring,
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str

    if sys.platform.startswith("java"):
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31) - 1)
    else:
        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
        class X(object):
            def __len__(self):
                return 1 << 31
        try:
            len(X())
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31) - 1)
        else:
            # 64-bit
            MAXSIZE = int((1 << 63) - 1)
            del X


def _add_doc(func, doc):
    """Add documentation to a function."""
    func.__doc__ = doc


def _import_module(name):
    """Import module, returning the module after the last dot."""
    __import__(name)
    return sys.modules[name]


class _LazyDescr(object):

    def __init__(self, name):
        self.name = name

    def __get__(self, obj, tp):
        result = self._resolve()
        setattr(obj, self.name, result)
        # This is a bit ugly, but it avoids running this again.
        delattr(tp, self.name)
        return result


class MovedModule(_LazyDescr):

    def __init__(self, name, old, new=None):
        super(MovedModule, self).__init__(name)
        if PY3:
            if new is None:
                new = name
            self.mod = new
        else:
            self.mod = old

    def _resolve(self):
        return _import_module(self.mod)


class MovedAttribute(_LazyDescr):

    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
        super(MovedAttribute, self).__init__(name)
        if PY3:
            if new_mod is None:
                new_mod = name
            self.mod = new_mod
            if new_attr is None:
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
            self.attr = new_attr
        else:
            self.mod = old_mod
            if old_attr is None:
                old_attr = name
            self.attr = old_attr

    def _resolve(self):
        module = _import_module(self.mod)
        return getattr(module, self.attr)



class _MovedItems(types.ModuleType):
    """Lazy loading of moved objects"""


_moved_attributes = [
    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
    MovedAttribute("reload_module", "__builtin__", "imp", "reload"),
    MovedAttribute("reduce", "__builtin__", "functools"),
    MovedAttribute("StringIO", "StringIO", "io"),
    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),

    MovedModule("builtins", "__builtin__"),
    MovedModule("configparser", "ConfigParser"),
    MovedModule("copyreg", "copy_reg"),
    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
    MovedModule("http_cookies", "Cookie", "http.cookies"),
    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
    MovedModule("html_parser", "HTMLParser", "html.parser"),
    MovedModule("http_client", "httplib", "http.client"),
    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
    MovedModule("cPickle", "cPickle", "pickle"),
    MovedModule("queue", "Queue"),
    MovedModule("reprlib", "repr"),
    MovedModule("socketserver", "SocketServer"),
    MovedModule("tkinter", "Tkinter"),
    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
    MovedModule("tkinter_colorchooser", "tkColorChooser",
                "tkinter.colorchooser"),
    MovedModule("tkinter_commondialog", "tkCommonDialog",
                "tkinter.commondialog"),
    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
                "tkinter.simpledialog"),
    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
    MovedModule("winreg", "_winreg"),
]
for attr in _moved_attributes:
    setattr(_MovedItems, attr.name, attr)
del attr

moves = sys.modules[__name__ + ".moves"] = _MovedItems("moves")


def add_move(move):
    """Add an item to six.moves."""
    setattr(_MovedItems, move.name, move)


def remove_move(name):
    """Remove item from six.moves."""
    try:
        delattr(_MovedItems, name)
    except AttributeError:
        try:
            del moves.__dict__[name]
        except KeyError:
            raise AttributeError("no such move, %r" % (name,))


if PY3:
    _meth_func = "__func__"
    _meth_self = "__self__"

    _func_code = "__code__"
    _func_defaults = "__defaults__"

    _iterkeys = "keys"
    _itervalues = "values"
    _iteritems = "items"
else:
    _meth_func = "im_func"
    _meth_self = "im_self"

    _func_code = "func_code"
    _func_defaults = "func_defaults"

    _iterkeys = "iterkeys"
    _itervalues = "itervalues"
    _iteritems = "iteritems"


try:
    advance_iterator = next
except NameError:
    def advance_iterator(it):
        return it.next()
next = advance_iterator


if PY3:
    def get_unbound_function(unbound):
        return unbound

    Iterator = object

    def callable(obj):
        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)
else:
    def get_unbound_function(unbound):
        return unbound.im_func

    class Iterator(object):

        def next(self):
            return type(self).__next__(self)

    callable = callable
_add_doc(get_unbound_function,
         """Get the function out of a possibly unbound function""")


get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_function_code = operator.attrgetter(_func_code)
get_function_defaults = operator.attrgetter(_func_defaults)


def iterkeys(d):
    """Return an iterator over the keys of a dictionary."""
    return iter(getattr(d, _iterkeys)())

def itervalues(d):
    """Return an iterator over the values of a dictionary."""
    return iter(getattr(d, _itervalues)())

def iteritems(d):
    """Return an iterator over the (key, value) pairs of a dictionary."""
    return iter(getattr(d, _iteritems)())


if PY3:
    def b(s):
        return s.encode("latin-1")
    def u(s):
        return s
    if sys.version_info[1] <= 1:
        def int2byte(i):
            return bytes((i,))
    else:
        # This is about 2x faster than the implementation above on 3.2+
        int2byte = operator.methodcaller("to_bytes", 1, "big")
    import io
    StringIO = io.StringIO
    BytesIO = io.BytesIO
else:
    def b(s):
        return s
    def u(s):
        return unicode(s, "unicode_escape")
    int2byte = chr
    import StringIO
    StringIO = BytesIO = StringIO.StringIO
_add_doc(b, """Byte literal""")
_add_doc(u, """Text literal""")


if PY3:
    import builtins
    exec_ = getattr(builtins, "exec")


    def reraise(tp, value, tb=None):
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb)
        raise value


    print_ = getattr(builtins, "print")
    del builtins

else:
    def exec_(code, globs=None, locs=None):
        """Execute code in a namespace."""
        if globs is None:
            frame = sys._getframe(1)
            globs = frame.f_globals
            if locs is None:
                locs = frame.f_locals
            del frame
        elif locs is None:
            locs = globs
        exec("""exec code in globs, locs""")


    exec_("""def reraise(tp, value, tb=None):
    raise tp, value, tb
""")


    def print_(*args, **kwargs):
        """The new-style print function."""
        fp = kwargs.pop("file", sys.stdout)
        if fp is None:
            return
        def write(data):
            if not isinstance(data, basestring):
                data = str(data)
            fp.write(data)
        want_unicode = False
        sep = kwargs.pop("sep", None)
        if sep is not None:
            if isinstance(sep, unicode):
                want_unicode = True
            elif not isinstance(sep, str):
                raise TypeError("sep must be None or a string")
        end = kwargs.pop("end", None)
        if end is not None:
            if isinstance(end, unicode):
                want_unicode = True
            elif not isinstance(end, str):
                raise TypeError("end must be None or a string")
        if kwargs:
            raise TypeError("invalid keyword arguments to print()")
        if not want_unicode:
            for arg in args:
                if isinstance(arg, unicode):
                    want_unicode = True
                    break
        if want_unicode:
            newline = unicode("\n")
            space = unicode(" ")
        else:
            newline = "\n"
            space = " "
        if sep is None:
            sep = space
        if end is None:
            end = newline
        for i, arg in enumerate(args):
            if i:
                write(sep)
            write(arg)
        write(end)

_add_doc(reraise, """Reraise an exception.""")


def with_metaclass(meta, base=object):
    """Create a base class with a metaclass."""
    return meta("NewBase", (base,), {})

########NEW FILE########
__FILENAME__ = _implementation
"""The match_hostname() function from Python 3.3.3, essential when using SSL."""

# Note: This file is under the PSF license as the code comes from the python
# stdlib.   http://docs.python.org/3/license.html

import re

__version__ = '3.4.0.2'

class CertificateError(ValueError):
    pass


def _dnsname_match(dn, hostname, max_wildcards=1):
    """Matching according to RFC 6125, section 6.4.3

    http://tools.ietf.org/html/rfc6125#section-6.4.3
    """
    pats = []
    if not dn:
        return False

    # Ported from python3-syntax:
    # leftmost, *remainder = dn.split(r'.')
    parts = dn.split(r'.')
    leftmost = parts[0]
    remainder = parts[1:]

    wildcards = leftmost.count('*')
    if wildcards > max_wildcards:
        # Issue #17980: avoid denials of service by refusing more
        # than one wildcard per fragment.  A survey of established
        # policy among SSL implementations showed it to be a
        # reasonable choice.
        raise CertificateError(
            "too many wildcards in certificate DNS name: " + repr(dn))

    # speed up common case w/o wildcards
    if not wildcards:
        return dn.lower() == hostname.lower()

    # RFC 6125, section 6.4.3, subitem 1.
    # The client SHOULD NOT attempt to match a presented identifier in which
    # the wildcard character comprises a label other than the left-most label.
    if leftmost == '*':
        # When '*' is a fragment by itself, it matches a non-empty dotless
        # fragment.
        pats.append('[^.]+')
    elif leftmost.startswith('xn--') or hostname.startswith('xn--'):
        # RFC 6125, section 6.4.3, subitem 3.
        # The client SHOULD NOT attempt to match a presented identifier
        # where the wildcard character is embedded within an A-label or
        # U-label of an internationalized domain name.
        pats.append(re.escape(leftmost))
    else:
        # Otherwise, '*' matches any dotless string, e.g. www*
        pats.append(re.escape(leftmost).replace(r'\*', '[^.]*'))

    # add the remaining fragments, ignore any wildcards
    for frag in remainder:
        pats.append(re.escape(frag))

    pat = re.compile(r'\A' + r'\.'.join(pats) + r'\Z', re.IGNORECASE)
    return pat.match(hostname)


def match_hostname(cert, hostname):
    """Verify that *cert* (in decoded format as returned by
    SSLSocket.getpeercert()) matches the *hostname*.  RFC 2818 and RFC 6125
    rules are followed, but IP addresses are not accepted for *hostname*.

    CertificateError is raised on failure. On success, the function
    returns nothing.
    """
    if not cert:
        raise ValueError("empty or no certificate")
    dnsnames = []
    san = cert.get('subjectAltName', ())
    for key, value in san:
        if key == 'DNS':
            if _dnsname_match(value, hostname):
                return
            dnsnames.append(value)
    if not dnsnames:
        # The subject is only checked when there is no dNSName entry
        # in subjectAltName
        for sub in cert.get('subject', ()):
            for key, value in sub:
                # XXX according to RFC 2818, the most specific Common Name
                # must be used.
                if key == 'commonName':
                    if _dnsname_match(value, hostname):
                        return
                    dnsnames.append(value)
    if len(dnsnames) > 1:
        raise CertificateError("hostname %r "
            "doesn't match either of %s"
            % (hostname, ', '.join(map(repr, dnsnames))))
    elif len(dnsnames) == 1:
        raise CertificateError("hostname %r "
            "doesn't match %r"
            % (hostname, dnsnames[0]))
    else:
        raise CertificateError("no appropriate commonName or "
            "subjectAltName fields were found")

########NEW FILE########
__FILENAME__ = poolmanager
# urllib3/poolmanager.py
# Copyright 2008-2014 Andrey Petrov and contributors (see CONTRIBUTORS.txt)
#
# This module is part of urllib3 and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

import logging

try:  # Python 3
    from urllib.parse import urljoin
except ImportError:
    from urlparse import urljoin

from ._collections import RecentlyUsedContainer
from .connectionpool import HTTPConnectionPool, HTTPSConnectionPool
from .connectionpool import port_by_scheme
from .request import RequestMethods
from .util import parse_url


__all__ = ['PoolManager', 'ProxyManager', 'proxy_from_url']


pool_classes_by_scheme = {
    'http': HTTPConnectionPool,
    'https': HTTPSConnectionPool,
}

log = logging.getLogger(__name__)

SSL_KEYWORDS = ('key_file', 'cert_file', 'cert_reqs', 'ca_certs',
                'ssl_version')


class PoolManager(RequestMethods):
    """
    Allows for arbitrary requests while transparently keeping track of
    necessary connection pools for you.

    :param num_pools:
        Number of connection pools to cache before discarding the least
        recently used pool.

    :param headers:
        Headers to include with all requests, unless other headers are given
        explicitly.

    :param \**connection_pool_kw:
        Additional parameters are used to create fresh
        :class:`urllib3.connectionpool.ConnectionPool` instances.

    Example: ::

        >>> manager = PoolManager(num_pools=2)
        >>> r = manager.request('GET', 'http://google.com/')
        >>> r = manager.request('GET', 'http://google.com/mail')
        >>> r = manager.request('GET', 'http://yahoo.com/')
        >>> len(manager.pools)
        2

    """

    proxy = None

    def __init__(self, num_pools=10, headers=None, **connection_pool_kw):
        RequestMethods.__init__(self, headers)
        self.connection_pool_kw = connection_pool_kw
        self.pools = RecentlyUsedContainer(num_pools,
                                           dispose_func=lambda p: p.close())

    def _new_pool(self, scheme, host, port):
        """
        Create a new :class:`ConnectionPool` based on host, port and scheme.

        This method is used to actually create the connection pools handed out
        by :meth:`connection_from_url` and companion methods. It is intended
        to be overridden for customization.
        """
        pool_cls = pool_classes_by_scheme[scheme]
        kwargs = self.connection_pool_kw
        if scheme == 'http':
            kwargs = self.connection_pool_kw.copy()
            for kw in SSL_KEYWORDS:
                kwargs.pop(kw, None)

        return pool_cls(host, port, **kwargs)

    def clear(self):
        """
        Empty our store of pools and direct them all to close.

        This will not affect in-flight connections, but they will not be
        re-used after completion.
        """
        self.pools.clear()

    def connection_from_host(self, host, port=None, scheme='http'):
        """
        Get a :class:`ConnectionPool` based on the host, port, and scheme.

        If ``port`` isn't given, it will be derived from the ``scheme`` using
        ``urllib3.connectionpool.port_by_scheme``.
        """

        scheme = scheme or 'http'

        port = port or port_by_scheme.get(scheme, 80)

        pool_key = (scheme, host, port)

        with self.pools.lock:
            # If the scheme, host, or port doesn't match existing open
            # connections, open a new ConnectionPool.
            pool = self.pools.get(pool_key)
            if pool:
                return pool

            # Make a fresh ConnectionPool of the desired type
            pool = self._new_pool(scheme, host, port)
            self.pools[pool_key] = pool
        return pool

    def connection_from_url(self, url):
        """
        Similar to :func:`urllib3.connectionpool.connection_from_url` but
        doesn't pass any additional parameters to the
        :class:`urllib3.connectionpool.ConnectionPool` constructor.

        Additional parameters are taken from the :class:`.PoolManager`
        constructor.
        """
        u = parse_url(url)
        return self.connection_from_host(u.host, port=u.port, scheme=u.scheme)

    def urlopen(self, method, url, redirect=True, **kw):
        """
        Same as :meth:`urllib3.connectionpool.HTTPConnectionPool.urlopen`
        with custom cross-host redirect logic and only sends the request-uri
        portion of the ``url``.

        The given ``url`` parameter must be absolute, such that an appropriate
        :class:`urllib3.connectionpool.ConnectionPool` can be chosen for it.
        """
        u = parse_url(url)
        conn = self.connection_from_host(u.host, port=u.port, scheme=u.scheme)

        kw['assert_same_host'] = False
        kw['redirect'] = False
        if 'headers' not in kw:
            kw['headers'] = self.headers

        if self.proxy is not None and u.scheme == "http":
            response = conn.urlopen(method, url, **kw)
        else:
            response = conn.urlopen(method, u.request_uri, **kw)

        redirect_location = redirect and response.get_redirect_location()
        if not redirect_location:
            return response

        # Support relative URLs for redirecting.
        redirect_location = urljoin(url, redirect_location)

        # RFC 2616, Section 10.3.4
        if response.status == 303:
            method = 'GET'

        log.info("Redirecting %s -> %s" % (url, redirect_location))
        kw['retries'] = kw.get('retries', 3) - 1  # Persist retries countdown
        kw['redirect'] = redirect
        return self.urlopen(method, redirect_location, **kw)


class ProxyManager(PoolManager):
    """
    Behaves just like :class:`PoolManager`, but sends all requests through
    the defined proxy, using the CONNECT method for HTTPS URLs.

    :param proxy_url:
        The URL of the proxy to be used.

    :param proxy_headers:
        A dictionary contaning headers that will be sent to the proxy. In case
        of HTTP they are being sent with each request, while in the
        HTTPS/CONNECT case they are sent only once. Could be used for proxy
        authentication.

    Example:
        >>> proxy = urllib3.ProxyManager('http://localhost:3128/')
        >>> r1 = proxy.request('GET', 'http://google.com/')
        >>> r2 = proxy.request('GET', 'http://httpbin.org/')
        >>> len(proxy.pools)
        1
        >>> r3 = proxy.request('GET', 'https://httpbin.org/')
        >>> r4 = proxy.request('GET', 'https://twitter.com/')
        >>> len(proxy.pools)
        3

    """

    def __init__(self, proxy_url, num_pools=10, headers=None,
                 proxy_headers=None, **connection_pool_kw):

        if isinstance(proxy_url, HTTPConnectionPool):
            proxy_url = '%s://%s:%i' % (proxy_url.scheme, proxy_url.host,
                                        proxy_url.port)
        proxy = parse_url(proxy_url)
        if not proxy.port:
            port = port_by_scheme.get(proxy.scheme, 80)
            proxy = proxy._replace(port=port)
        self.proxy = proxy
        self.proxy_headers = proxy_headers or {}
        assert self.proxy.scheme in ("http", "https"), \
            'Not supported proxy scheme %s' % self.proxy.scheme
        connection_pool_kw['_proxy'] = self.proxy
        connection_pool_kw['_proxy_headers'] = self.proxy_headers
        super(ProxyManager, self).__init__(
            num_pools, headers, **connection_pool_kw)

    def connection_from_host(self, host, port=None, scheme='http'):
        if scheme == "https":
            return super(ProxyManager, self).connection_from_host(
                host, port, scheme)

        return super(ProxyManager, self).connection_from_host(
            self.proxy.host, self.proxy.port, self.proxy.scheme)

    def _set_proxy_headers(self, url, headers=None):
        """
        Sets headers needed by proxies: specifically, the Accept and Host
        headers. Only sets headers not provided by the user.
        """
        headers_ = {'Accept': '*/*'}

        netloc = parse_url(url).netloc
        if netloc:
            headers_['Host'] = netloc

        if headers:
            headers_.update(headers)
        return headers_

    def urlopen(self, method, url, redirect=True, **kw):
        "Same as HTTP(S)ConnectionPool.urlopen, ``url`` must be absolute."
        u = parse_url(url)

        if u.scheme == "http":
            # For proxied HTTPS requests, httplib sets the necessary headers
            # on the CONNECT to the proxy. For HTTP, we'll definitely
            # need to set 'Host' at the very least.
            kw['headers'] = self._set_proxy_headers(url, kw.get('headers',
                                                                self.headers))

        return super(ProxyManager, self).urlopen(method, url, redirect, **kw)


def proxy_from_url(url, **kw):
    return ProxyManager(proxy_url=url, **kw)

########NEW FILE########
__FILENAME__ = request
# urllib3/request.py
# Copyright 2008-2013 Andrey Petrov and contributors (see CONTRIBUTORS.txt)
#
# This module is part of urllib3 and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

try:
    from urllib.parse import urlencode
except ImportError:
    from urllib import urlencode

from .filepost import encode_multipart_formdata


__all__ = ['RequestMethods']


class RequestMethods(object):
    """
    Convenience mixin for classes who implement a :meth:`urlopen` method, such
    as :class:`~urllib3.connectionpool.HTTPConnectionPool` and
    :class:`~urllib3.poolmanager.PoolManager`.

    Provides behavior for making common types of HTTP request methods and
    decides which type of request field encoding to use.

    Specifically,

    :meth:`.request_encode_url` is for sending requests whose fields are encoded
    in the URL (such as GET, HEAD, DELETE).

    :meth:`.request_encode_body` is for sending requests whose fields are
    encoded in the *body* of the request using multipart or www-form-urlencoded
    (such as for POST, PUT, PATCH).

    :meth:`.request` is for making any kind of request, it will look up the
    appropriate encoding format and use one of the above two methods to make
    the request.

    Initializer parameters:

    :param headers:
        Headers to include with all requests, unless other headers are given
        explicitly.
    """

    _encode_url_methods = set(['DELETE', 'GET', 'HEAD', 'OPTIONS'])

    def __init__(self, headers=None):
        self.headers = headers or {}

    def urlopen(self, method, url, body=None, headers=None,
                encode_multipart=True, multipart_boundary=None,
                **kw): # Abstract
        raise NotImplemented("Classes extending RequestMethods must implement "
                             "their own ``urlopen`` method.")

    def request(self, method, url, fields=None, headers=None, **urlopen_kw):
        """
        Make a request using :meth:`urlopen` with the appropriate encoding of
        ``fields`` based on the ``method`` used.

        This is a convenience method that requires the least amount of manual
        effort. It can be used in most situations, while still having the option
        to drop down to more specific methods when necessary, such as
        :meth:`request_encode_url`, :meth:`request_encode_body`,
        or even the lowest level :meth:`urlopen`.
        """
        method = method.upper()

        if method in self._encode_url_methods:
            return self.request_encode_url(method, url, fields=fields,
                                            headers=headers,
                                            **urlopen_kw)
        else:
            return self.request_encode_body(method, url, fields=fields,
                                             headers=headers,
                                             **urlopen_kw)

    def request_encode_url(self, method, url, fields=None, **urlopen_kw):
        """
        Make a request using :meth:`urlopen` with the ``fields`` encoded in
        the url. This is useful for request methods like GET, HEAD, DELETE, etc.
        """
        if fields:
            url += '?' + urlencode(fields)
        return self.urlopen(method, url, **urlopen_kw)

    def request_encode_body(self, method, url, fields=None, headers=None,
                            encode_multipart=True, multipart_boundary=None,
                            **urlopen_kw):
        """
        Make a request using :meth:`urlopen` with the ``fields`` encoded in
        the body. This is useful for request methods like POST, PUT, PATCH, etc.

        When ``encode_multipart=True`` (default), then
        :meth:`urllib3.filepost.encode_multipart_formdata` is used to encode the
        payload with the appropriate content type. Otherwise
        :meth:`urllib.urlencode` is used with the
        'application/x-www-form-urlencoded' content type.

        Multipart encoding must be used when posting files, and it's reasonably
        safe to use it in other times too. However, it may break request signing,
        such as with OAuth.

        Supports an optional ``fields`` parameter of key/value strings AND
        key/filetuple. A filetuple is a (filename, data, MIME type) tuple where
        the MIME type is optional. For example: ::

            fields = {
                'foo': 'bar',
                'fakefile': ('foofile.txt', 'contents of foofile'),
                'realfile': ('barfile.txt', open('realfile').read()),
                'typedfile': ('bazfile.bin', open('bazfile').read(),
                              'image/jpeg'),
                'nonamefile': 'contents of nonamefile field',
            }

        When uploading a file, providing a filename (the first parameter of the
        tuple) is optional but recommended to best mimick behavior of browsers.

        Note that if ``headers`` are supplied, the 'Content-Type' header will be
        overwritten because it depends on the dynamic random boundary string
        which is used to compose the body of the request. The random boundary
        string can be explicitly set with the ``multipart_boundary`` parameter.
        """
        if encode_multipart:
            body, content_type = encode_multipart_formdata(fields or {},
                                    boundary=multipart_boundary)
        else:
            body, content_type = (urlencode(fields or {}),
                                    'application/x-www-form-urlencoded')

        if headers is None:
            headers = self.headers

        headers_ = {'Content-Type': content_type}
        headers_.update(headers)

        return self.urlopen(method, url, body=body, headers=headers_,
                            **urlopen_kw)

########NEW FILE########
__FILENAME__ = response
# urllib3/response.py
# Copyright 2008-2013 Andrey Petrov and contributors (see CONTRIBUTORS.txt)
#
# This module is part of urllib3 and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php


import logging
import zlib
import io

from ._collections import HTTPHeaderDict
from .exceptions import DecodeError
from .packages.six import string_types as basestring, binary_type
from .util import is_fp_closed


log = logging.getLogger(__name__)


class DeflateDecoder(object):

    def __init__(self):
        self._first_try = True
        self._data = binary_type()
        self._obj = zlib.decompressobj()

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        if not self._first_try:
            return self._obj.decompress(data)

        self._data += data
        try:
            return self._obj.decompress(data)
        except zlib.error:
            self._first_try = False
            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)
            try:
                return self.decompress(self._data)
            finally:
                self._data = None


def _get_decoder(mode):
    if mode == 'gzip':
        return zlib.decompressobj(16 + zlib.MAX_WBITS)

    return DeflateDecoder()


class HTTPResponse(io.IOBase):
    """
    HTTP Response container.

    Backwards-compatible to httplib's HTTPResponse but the response ``body`` is
    loaded and decoded on-demand when the ``data`` property is accessed.

    Extra parameters for behaviour not present in httplib.HTTPResponse:

    :param preload_content:
        If True, the response's body will be preloaded during construction.

    :param decode_content:
        If True, attempts to decode specific content-encoding's based on headers
        (like 'gzip' and 'deflate') will be skipped and raw data will be used
        instead.

    :param original_response:
        When this HTTPResponse wrapper is generated from an httplib.HTTPResponse
        object, it's convenient to include the original for debug purposes. It's
        otherwise unused.
    """

    CONTENT_DECODERS = ['gzip', 'deflate']
    REDIRECT_STATUSES = [301, 302, 303, 307, 308]

    def __init__(self, body='', headers=None, status=0, version=0, reason=None,
                 strict=0, preload_content=True, decode_content=True,
                 original_response=None, pool=None, connection=None):

        self.headers = HTTPHeaderDict()
        if headers:
            self.headers.update(headers)
        self.status = status
        self.version = version
        self.reason = reason
        self.strict = strict
        self.decode_content = decode_content

        self._decoder = None
        self._body = body if body and isinstance(body, basestring) else None
        self._fp = None
        self._original_response = original_response
        self._fp_bytes_read = 0

        self._pool = pool
        self._connection = connection

        if hasattr(body, 'read'):
            self._fp = body

        if preload_content and not self._body:
            self._body = self.read(decode_content=decode_content)

    def get_redirect_location(self):
        """
        Should we redirect and where to?

        :returns: Truthy redirect location string if we got a redirect status
            code and valid location. ``None`` if redirect status and no
            location. ``False`` if not a redirect status code.
        """
        if self.status in self.REDIRECT_STATUSES:
            return self.headers.get('location')

        return False

    def release_conn(self):
        if not self._pool or not self._connection:
            return

        self._pool._put_conn(self._connection)
        self._connection = None

    @property
    def data(self):
        # For backwords-compat with earlier urllib3 0.4 and earlier.
        if self._body:
            return self._body

        if self._fp:
            return self.read(cache_content=True)

    def tell(self):
        """
        Obtain the number of bytes pulled over the wire so far. May differ from
        the amount of content returned by :meth:``HTTPResponse.read`` if bytes
        are encoded on the wire (e.g, compressed).
        """
        return self._fp_bytes_read

    def read(self, amt=None, decode_content=None, cache_content=False):
        """
        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional
        parameters: ``decode_content`` and ``cache_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.

        :param cache_content:
            If True, will save the returned data such that the same result is
            returned despite of the state of the underlying file object. This
            is useful if you want the ``.data`` property to continue working
            after having ``.read()`` the file object. (Overridden if ``amt`` is
            set.)
        """
        # Note: content-encoding value should be case-insensitive, per RFC 2616
        # Section 3.5
        content_encoding = self.headers.get('content-encoding', '').lower()
        if self._decoder is None:
            if content_encoding in self.CONTENT_DECODERS:
                self._decoder = _get_decoder(content_encoding)
        if decode_content is None:
            decode_content = self.decode_content

        if self._fp is None:
            return

        flush_decoder = False

        try:
            if amt is None:
                # cStringIO doesn't like amt=None
                data = self._fp.read()
                flush_decoder = True
            else:
                cache_content = False
                data = self._fp.read(amt)
                if amt != 0 and not data:  # Platform-specific: Buggy versions of Python.
                    # Close the connection when no data is returned
                    #
                    # This is redundant to what httplib/http.client _should_
                    # already do.  However, versions of python released before
                    # December 15, 2012 (http://bugs.python.org/issue16298) do not
                    # properly close the connection in all cases. There is no harm
                    # in redundantly calling close.
                    self._fp.close()
                    flush_decoder = True

            self._fp_bytes_read += len(data)

            try:
                if decode_content and self._decoder:
                    data = self._decoder.decompress(data)
            except (IOError, zlib.error) as e:
                raise DecodeError(
                    "Received response with content-encoding: %s, but "
                    "failed to decode it." % content_encoding,
                    e)

            if flush_decoder and decode_content and self._decoder:
                buf = self._decoder.decompress(binary_type())
                data += buf + self._decoder.flush()

            if cache_content:
                self._body = data

            return data

        finally:
            if self._original_response and self._original_response.isclosed():
                self.release_conn()

    def stream(self, amt=2**16, decode_content=None):
        """
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.

        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """
        while not is_fp_closed(self._fp):
            data = self.read(amt=amt, decode_content=decode_content)

            if data:
                yield data


    @classmethod
    def from_httplib(ResponseCls, r, **response_kw):
        """
        Given an :class:`httplib.HTTPResponse` instance ``r``, return a
        corresponding :class:`urllib3.response.HTTPResponse` object.

        Remaining parameters are passed to the HTTPResponse constructor, along
        with ``original_response=r``.
        """

        headers = HTTPHeaderDict()
        for k, v in r.getheaders():
            headers.add(k, v)

        # HTTPResponse objects in Python 3 don't have a .strict attribute
        strict = getattr(r, 'strict', 0)
        return ResponseCls(body=r,
                           headers=headers,
                           status=r.status,
                           version=r.version,
                           reason=r.reason,
                           strict=strict,
                           original_response=r,
                           **response_kw)

    # Backwards-compatibility methods for httplib.HTTPResponse
    def getheaders(self):
        return self.headers

    def getheader(self, name, default=None):
        return self.headers.get(name, default)

    # Overrides from io.IOBase
    def close(self):
        if not self.closed:
            self._fp.close()

    @property
    def closed(self):
        if self._fp is None:
            return True
        elif hasattr(self._fp, 'closed'):
            return self._fp.closed
        elif hasattr(self._fp, 'isclosed'):  # Python 2
            return self._fp.isclosed()
        else:
            return True

    def fileno(self):
        if self._fp is None:
            raise IOError("HTTPResponse has no file to get a fileno from")
        elif hasattr(self._fp, "fileno"):
            return self._fp.fileno()
        else:
            raise IOError("The file-like object  this HTTPResponse is wrapped "
                          "around has no file descriptor")

    def flush(self):
        if self._fp is not None and hasattr(self._fp, 'flush'):
            return self._fp.flush()

    def readable(self):
        return True

########NEW FILE########
__FILENAME__ = connection
from socket import error as SocketError
try:
    from select import poll, POLLIN
except ImportError:  # `poll` doesn't exist on OSX and other platforms
    poll = False
    try:
        from select import select
    except ImportError:  # `select` doesn't exist on AppEngine.
        select = False

def is_connection_dropped(conn):  # Platform-specific
    """
    Returns True if the connection is dropped and should be closed.

    :param conn:
        :class:`httplib.HTTPConnection` object.

    Note: For platforms like AppEngine, this will always return ``False`` to
    let the platform handle connection recycling transparently for us.
    """
    sock = getattr(conn, 'sock', False)
    if sock is False:  # Platform-specific: AppEngine
        return False
    if sock is None:  # Connection already closed (such as by httplib).
        return False

    if not poll:
        if not select:  # Platform-specific: AppEngine
            return False

        try:
            return select([sock], [], [], 0.0)[0]
        except SocketError:
            return True

    # This version is better on platforms that support it.
    p = poll()
    p.register(sock, POLLIN)
    for (fno, ev) in p.poll(0.0):
        if fno == sock.fileno():
            # Either data is buffered (bad), or the connection is dropped.
            return True




########NEW FILE########
__FILENAME__ = request
from base64 import b64encode

from ..packages import six


ACCEPT_ENCODING = 'gzip,deflate'


def make_headers(keep_alive=None, accept_encoding=None, user_agent=None,
                 basic_auth=None, proxy_basic_auth=None):
    """
    Shortcuts for generating request headers.

    :param keep_alive:
        If ``True``, adds 'connection: keep-alive' header.

    :param accept_encoding:
        Can be a boolean, list, or string.
        ``True`` translates to 'gzip,deflate'.
        List will get joined by comma.
        String will be used as provided.

    :param user_agent:
        String representing the user-agent you want, such as
        "python-urllib3/0.6"

    :param basic_auth:
        Colon-separated username:password string for 'authorization: basic ...'
        auth header.

    :param proxy_basic_auth:
        Colon-separated username:password string for 'proxy-authorization: basic ...'
        auth header.

    Example: ::

        >>> make_headers(keep_alive=True, user_agent="Batman/1.0")
        {'connection': 'keep-alive', 'user-agent': 'Batman/1.0'}
        >>> make_headers(accept_encoding=True)
        {'accept-encoding': 'gzip,deflate'}
    """
    headers = {}
    if accept_encoding:
        if isinstance(accept_encoding, str):
            pass
        elif isinstance(accept_encoding, list):
            accept_encoding = ','.join(accept_encoding)
        else:
            accept_encoding = ACCEPT_ENCODING
        headers['accept-encoding'] = accept_encoding

    if user_agent:
        headers['user-agent'] = user_agent

    if keep_alive:
        headers['connection'] = 'keep-alive'

    if basic_auth:
        headers['authorization'] = 'Basic ' + \
            b64encode(six.b(basic_auth)).decode('utf-8')

    if proxy_basic_auth:
        headers['proxy-authorization'] = 'Basic ' + \
            b64encode(six.b(proxy_basic_auth)).decode('utf-8')

    return headers



########NEW FILE########
__FILENAME__ = response
def is_fp_closed(obj):
    """
    Checks whether a given file-like object is closed.

    :param obj:
        The file-like object to check.
    """
    if hasattr(obj, 'fp'):
        # Object is a container for another file-like object that gets released
        # on exhaustion (e.g. HTTPResponse)
        return obj.fp is None

    return obj.closed

########NEW FILE########
__FILENAME__ = ssl_
from binascii import hexlify, unhexlify
from hashlib import md5, sha1

from ..exceptions import SSLError


try:  # Test for SSL features
    SSLContext = None
    HAS_SNI = False

    import ssl
    from ssl import wrap_socket, CERT_NONE, PROTOCOL_SSLv23
    from ssl import SSLContext  # Modern SSL?
    from ssl import HAS_SNI  # Has SNI?
except ImportError:
    pass


def assert_fingerprint(cert, fingerprint):
    """
    Checks if given fingerprint matches the supplied certificate.

    :param cert:
        Certificate as bytes object.
    :param fingerprint:
        Fingerprint as string of hexdigits, can be interspersed by colons.
    """

    # Maps the length of a digest to a possible hash function producing
    # this digest.
    hashfunc_map = {
        16: md5,
        20: sha1
    }

    fingerprint = fingerprint.replace(':', '').lower()

    digest_length, rest = divmod(len(fingerprint), 2)

    if rest or digest_length not in hashfunc_map:
        raise SSLError('Fingerprint is of invalid length.')

    # We need encode() here for py32; works on py2 and p33.
    fingerprint_bytes = unhexlify(fingerprint.encode())

    hashfunc = hashfunc_map[digest_length]

    cert_digest = hashfunc(cert).digest()

    if not cert_digest == fingerprint_bytes:
        raise SSLError('Fingerprints did not match. Expected "{0}", got "{1}".'
                       .format(hexlify(fingerprint_bytes),
                               hexlify(cert_digest)))


def resolve_cert_reqs(candidate):
    """
    Resolves the argument to a numeric constant, which can be passed to
    the wrap_socket function/method from the ssl module.
    Defaults to :data:`ssl.CERT_NONE`.
    If given a string it is assumed to be the name of the constant in the
    :mod:`ssl` module or its abbrevation.
    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.
    If it's neither `None` nor a string we assume it is already the numeric
    constant which can directly be passed to wrap_socket.
    """
    if candidate is None:
        return CERT_NONE

    if isinstance(candidate, str):
        res = getattr(ssl, candidate, None)
        if res is None:
            res = getattr(ssl, 'CERT_' + candidate)
        return res

    return candidate


def resolve_ssl_version(candidate):
    """
    like resolve_cert_reqs
    """
    if candidate is None:
        return PROTOCOL_SSLv23

    if isinstance(candidate, str):
        res = getattr(ssl, candidate, None)
        if res is None:
            res = getattr(ssl, 'PROTOCOL_' + candidate)
        return res

    return candidate


if SSLContext is not None:  # Python 3.2+
    def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,
                        ca_certs=None, server_hostname=None,
                        ssl_version=None):
        """
        All arguments except `server_hostname` have the same meaning as for
        :func:`ssl.wrap_socket`

        :param server_hostname:
            Hostname of the expected certificate
        """
        context = SSLContext(ssl_version)
        context.verify_mode = cert_reqs

        # Disable TLS compression to migitate CRIME attack (issue #309)
        OP_NO_COMPRESSION = 0x20000
        context.options |= OP_NO_COMPRESSION

        if ca_certs:
            try:
                context.load_verify_locations(ca_certs)
            # Py32 raises IOError
            # Py33 raises FileNotFoundError
            except Exception as e:  # Reraise as SSLError
                raise SSLError(e)
        if certfile:
            # FIXME: This block needs a test.
            context.load_cert_chain(certfile, keyfile)
        if HAS_SNI:  # Platform-specific: OpenSSL with enabled SNI
            return context.wrap_socket(sock, server_hostname=server_hostname)
        return context.wrap_socket(sock)

else:  # Python 3.1 and earlier
    def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,
                        ca_certs=None, server_hostname=None,
                        ssl_version=None):
        return wrap_socket(sock, keyfile=keyfile, certfile=certfile,
                           ca_certs=ca_certs, cert_reqs=cert_reqs,
                           ssl_version=ssl_version)

########NEW FILE########
__FILENAME__ = timeout
from socket import _GLOBAL_DEFAULT_TIMEOUT
import time

from ..exceptions import TimeoutStateError


def current_time():
    """
    Retrieve the current time, this function is mocked out in unit testing.
    """
    return time.time()


_Default = object()
# The default timeout to use for socket connections. This is the attribute used
# by httplib to define the default timeout


class Timeout(object):
    """
    Utility object for storing timeout values.

    Example usage:

    .. code-block:: python

        timeout = urllib3.util.Timeout(connect=2.0, read=7.0)
        pool = HTTPConnectionPool('www.google.com', 80, timeout=timeout)
        pool.request(...) # Etc, etc

    :param connect:
        The maximum amount of time to wait for a connection attempt to a server
        to succeed. Omitting the parameter will default the connect timeout to
        the system default, probably `the global default timeout in socket.py
        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
        None will set an infinite timeout for connection attempts.

    :type connect: integer, float, or None

    :param read:
        The maximum amount of time to wait between consecutive
        read operations for a response from the server. Omitting
        the parameter will default the read timeout to the system
        default, probably `the global default timeout in socket.py
        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
        None will set an infinite timeout.

    :type read: integer, float, or None

    :param total:
        This combines the connect and read timeouts into one; the read timeout
        will be set to the time leftover from the connect attempt. In the
        event that both a connect timeout and a total are specified, or a read
        timeout and a total are specified, the shorter timeout will be applied.

        Defaults to None.

    :type total: integer, float, or None

    .. note::

        Many factors can affect the total amount of time for urllib3 to return
        an HTTP response. Specifically, Python's DNS resolver does not obey the
        timeout specified on the socket. Other factors that can affect total
        request time include high CPU load, high swap, the program running at a
        low priority level, or other behaviors. The observed running time for
        urllib3 to return a response may be greater than the value passed to
        `total`.

        In addition, the read and total timeouts only measure the time between
        read operations on the socket connecting the client and the server,
        not the total amount of time for the request to return a complete
        response. For most requests, the timeout is raised because the server
        has not sent the first byte in the specified time. This is not always
        the case; if a server streams one byte every fifteen seconds, a timeout
        of 20 seconds will not ever trigger, even though the request will
        take several minutes to complete.

        If your goal is to cut off any request after a set amount of wall clock
        time, consider having a second "watcher" thread to cut off a slow
        request.
    """

    #: A sentinel object representing the default timeout value
    DEFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT

    def __init__(self, total=None, connect=_Default, read=_Default):
        self._connect = self._validate_timeout(connect, 'connect')
        self._read = self._validate_timeout(read, 'read')
        self.total = self._validate_timeout(total, 'total')
        self._start_connect = None

    def __str__(self):
        return '%s(connect=%r, read=%r, total=%r)' % (
            type(self).__name__, self._connect, self._read, self.total)


    @classmethod
    def _validate_timeout(cls, value, name):
        """ Check that a timeout attribute is valid

        :param value: The timeout value to validate
        :param name: The name of the timeout attribute to validate. This is used
            for clear error messages
        :return: the value
        :raises ValueError: if the type is not an integer or a float, or if it
            is a numeric value less than zero
        """
        if value is _Default:
            return cls.DEFAULT_TIMEOUT

        if value is None or value is cls.DEFAULT_TIMEOUT:
            return value

        try:
            float(value)
        except (TypeError, ValueError):
            raise ValueError("Timeout value %s was %s, but it must be an "
                             "int or float." % (name, value))

        try:
            if value < 0:
                raise ValueError("Attempted to set %s timeout to %s, but the "
                                 "timeout cannot be set to a value less "
                                 "than 0." % (name, value))
        except TypeError: # Python 3
            raise ValueError("Timeout value %s was %s, but it must be an "
                             "int or float." % (name, value))

        return value

    @classmethod
    def from_float(cls, timeout):
        """ Create a new Timeout from a legacy timeout value.

        The timeout value used by httplib.py sets the same timeout on the
        connect(), and recv() socket requests. This creates a :class:`Timeout`
        object that sets the individual timeouts to the ``timeout`` value passed
        to this function.

        :param timeout: The legacy timeout value
        :type timeout: integer, float, sentinel default object, or None
        :return: a Timeout object
        :rtype: :class:`Timeout`
        """
        return Timeout(read=timeout, connect=timeout)

    def clone(self):
        """ Create a copy of the timeout object

        Timeout properties are stored per-pool but each request needs a fresh
        Timeout object to ensure each one has its own start/stop configured.

        :return: a copy of the timeout object
        :rtype: :class:`Timeout`
        """
        # We can't use copy.deepcopy because that will also create a new object
        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to
        # detect the user default.
        return Timeout(connect=self._connect, read=self._read,
                       total=self.total)

    def start_connect(self):
        """ Start the timeout clock, used during a connect() attempt

        :raises urllib3.exceptions.TimeoutStateError: if you attempt
            to start a timer that has been started already.
        """
        if self._start_connect is not None:
            raise TimeoutStateError("Timeout timer has already been started.")
        self._start_connect = current_time()
        return self._start_connect

    def get_connect_duration(self):
        """ Gets the time elapsed since the call to :meth:`start_connect`.

        :return: the elapsed time
        :rtype: float
        :raises urllib3.exceptions.TimeoutStateError: if you attempt
            to get duration for a timer that hasn't been started.
        """
        if self._start_connect is None:
            raise TimeoutStateError("Can't get connect duration for timer "
                                    "that has not started.")
        return current_time() - self._start_connect

    @property
    def connect_timeout(self):
        """ Get the value to use when setting a connection timeout.

        This will be a positive float or integer, the value None
        (never timeout), or the default system timeout.

        :return: the connect timeout
        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
        """
        if self.total is None:
            return self._connect

        if self._connect is None or self._connect is self.DEFAULT_TIMEOUT:
            return self.total

        return min(self._connect, self.total)

    @property
    def read_timeout(self):
        """ Get the value for the read timeout.

        This assumes some time has elapsed in the connection timeout and
        computes the read timeout appropriately.

        If self.total is set, the read timeout is dependent on the amount of
        time taken by the connect timeout. If the connection time has not been
        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be
        raised.

        :return: the value to use for the read timeout
        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`
            has not yet been called on this object.
        """
        if (self.total is not None and
            self.total is not self.DEFAULT_TIMEOUT and
            self._read is not None and
            self._read is not self.DEFAULT_TIMEOUT):
            # in case the connect timeout has not yet been established.
            if self._start_connect is None:
                return self._read
            return max(0, min(self.total - self.get_connect_duration(),
                              self._read))
        elif self.total is not None and self.total is not self.DEFAULT_TIMEOUT:
            return max(0, self.total - self.get_connect_duration())
        else:
            return self._read

########NEW FILE########
__FILENAME__ = url
from collections import namedtuple

from ..exceptions import LocationParseError


class Url(namedtuple('Url', ['scheme', 'auth', 'host', 'port', 'path', 'query', 'fragment'])):
    """
    Datastructure for representing an HTTP URL. Used as a return value for
    :func:`parse_url`.
    """
    slots = ()

    def __new__(cls, scheme=None, auth=None, host=None, port=None, path=None, query=None, fragment=None):
        return super(Url, cls).__new__(cls, scheme, auth, host, port, path, query, fragment)

    @property
    def hostname(self):
        """For backwards-compatibility with urlparse. We're nice like that."""
        return self.host

    @property
    def request_uri(self):
        """Absolute path including the query string."""
        uri = self.path or '/'

        if self.query is not None:
            uri += '?' + self.query

        return uri

    @property
    def netloc(self):
        """Network location including host and port"""
        if self.port:
            return '%s:%d' % (self.host, self.port)
        return self.host


def split_first(s, delims):
    """
    Given a string and an iterable of delimiters, split on the first found
    delimiter. Return two split parts and the matched delimiter.

    If not found, then the first part is the full input string.

    Example: ::

        >>> split_first('foo/bar?baz', '?/=')
        ('foo', 'bar?baz', '/')
        >>> split_first('foo/bar?baz', '123')
        ('foo/bar?baz', '', None)

    Scales linearly with number of delims. Not ideal for large number of delims.
    """
    min_idx = None
    min_delim = None
    for d in delims:
        idx = s.find(d)
        if idx < 0:
            continue

        if min_idx is None or idx < min_idx:
            min_idx = idx
            min_delim = d

    if min_idx is None or min_idx < 0:
        return s, '', None

    return s[:min_idx], s[min_idx+1:], min_delim


def parse_url(url):
    """
    Given a url, return a parsed :class:`.Url` namedtuple. Best-effort is
    performed to parse incomplete urls. Fields not provided will be None.

    Partly backwards-compatible with :mod:`urlparse`.

    Example: ::

        >>> parse_url('http://google.com/mail/')
        Url(scheme='http', host='google.com', port=None, path='/', ...)
        >>> parse_url('google.com:80')
        Url(scheme=None, host='google.com', port=80, path=None, ...)
        >>> parse_url('/foo?bar')
        Url(scheme=None, host=None, port=None, path='/foo', query='bar', ...)
    """

    # While this code has overlap with stdlib's urlparse, it is much
    # simplified for our needs and less annoying.
    # Additionally, this implementations does silly things to be optimal
    # on CPython.

    scheme = None
    auth = None
    host = None
    port = None
    path = None
    fragment = None
    query = None

    # Scheme
    if '://' in url:
        scheme, url = url.split('://', 1)

    # Find the earliest Authority Terminator
    # (http://tools.ietf.org/html/rfc3986#section-3.2)
    url, path_, delim = split_first(url, ['/', '?', '#'])

    if delim:
        # Reassemble the path
        path = delim + path_

    # Auth
    if '@' in url:
        # Last '@' denotes end of auth part
        auth, url = url.rsplit('@', 1)

    # IPv6
    if url and url[0] == '[':
        host, url = url.split(']', 1)
        host += ']'

    # Port
    if ':' in url:
        _host, port = url.split(':', 1)

        if not host:
            host = _host

        if port:
            # If given, ports must be integers.
            if not port.isdigit():
                raise LocationParseError(url)
            port = int(port)
        else:
            # Blank ports are cool, too. (rfc3986#section-3.2.3)
            port = None

    elif not host and url:
        host = url

    if not path:
        return Url(scheme, auth, host, port, path, query, fragment)

    # Fragment
    if '#' in path:
        path, fragment = path.split('#', 1)

    # Query
    if '?' in path:
        path, query = path.split('?', 1)

    return Url(scheme, auth, host, port, path, query, fragment)


def get_host(url):
    """
    Deprecated. Use :func:`.parse_url` instead.
    """
    p = parse_url(url)
    return p.scheme or 'http', p.hostname, p.port

########NEW FILE########
__FILENAME__ = _collections
# urllib3/_collections.py
# Copyright 2008-2013 Andrey Petrov and contributors (see CONTRIBUTORS.txt)
#
# This module is part of urllib3 and is released under
# the MIT License: http://www.opensource.org/licenses/mit-license.php

from collections import Mapping, MutableMapping
try:
    from threading import RLock
except ImportError: # Platform-specific: No threads available
    class RLock:
        def __enter__(self):
            pass

        def __exit__(self, exc_type, exc_value, traceback):
            pass


try: # Python 2.7+
    from collections import OrderedDict
except ImportError:
    from .packages.ordered_dict import OrderedDict
from .packages.six import itervalues


__all__ = ['RecentlyUsedContainer', 'HTTPHeaderDict']


_Null = object()


class RecentlyUsedContainer(MutableMapping):
    """
    Provides a thread-safe dict-like container which maintains up to
    ``maxsize`` keys while throwing away the least-recently-used keys beyond
    ``maxsize``.

    :param maxsize:
        Maximum number of recent elements to retain.

    :param dispose_func:
        Every time an item is evicted from the container,
        ``dispose_func(value)`` is called.  Callback which will get called
    """

    ContainerCls = OrderedDict

    def __init__(self, maxsize=10, dispose_func=None):
        self._maxsize = maxsize
        self.dispose_func = dispose_func

        self._container = self.ContainerCls()
        self.lock = RLock()

    def __getitem__(self, key):
        # Re-insert the item, moving it to the end of the eviction line.
        with self.lock:
            item = self._container.pop(key)
            self._container[key] = item
            return item

    def __setitem__(self, key, value):
        evicted_value = _Null
        with self.lock:
            # Possibly evict the existing value of 'key'
            evicted_value = self._container.get(key, _Null)
            self._container[key] = value

            # If we didn't evict an existing value, we might have to evict the
            # least recently used item from the beginning of the container.
            if len(self._container) > self._maxsize:
                _key, evicted_value = self._container.popitem(last=False)

        if self.dispose_func and evicted_value is not _Null:
            self.dispose_func(evicted_value)

    def __delitem__(self, key):
        with self.lock:
            value = self._container.pop(key)

        if self.dispose_func:
            self.dispose_func(value)

    def __len__(self):
        with self.lock:
            return len(self._container)

    def __iter__(self):
        raise NotImplementedError('Iteration over this class is unlikely to be threadsafe.')

    def clear(self):
        with self.lock:
            # Copy pointers to all values, then wipe the mapping
            # under Python 2, this copies the list of values twice :-|
            values = list(self._container.values())
            self._container.clear()

        if self.dispose_func:
            for value in values:
                self.dispose_func(value)

    def keys(self):
        with self.lock:
            return self._container.keys()


class HTTPHeaderDict(MutableMapping):
    """
    :param headers:
        An iterable of field-value pairs. Must not contain multiple field names
        when compared case-insensitively.

    :param kwargs:
        Additional field-value pairs to pass in to ``dict.update``.

    A ``dict`` like container for storing HTTP Headers.

    Field names are stored and compared case-insensitively in compliance with
    RFC 2616. Iteration provides the first case-sensitive key seen for each
    case-insensitive pair.

    Using ``__setitem__`` syntax overwrites fields that compare equal
    case-insensitively in order to maintain ``dict``'s api. For fields that
    compare equal, instead create a new ``HTTPHeaderDict`` and use ``.add``
    in a loop.

    If multiple fields that are equal case-insensitively are passed to the
    constructor or ``.update``, the behavior is undefined and some will be
    lost.

    >>> headers = HTTPHeaderDict()
    >>> headers.add('Set-Cookie', 'foo=bar')
    >>> headers.add('set-cookie', 'baz=quxx')
    >>> headers['content-length'] = '7'
    >>> headers['SET-cookie']
    'foo=bar, baz=quxx'
    >>> headers['Content-Length']
    '7'

    If you want to access the raw headers with their original casing
    for debugging purposes you can access the private ``._data`` attribute
    which is a normal python ``dict`` that maps the case-insensitive key to a
    list of tuples stored as (case-sensitive-original-name, value). Using the
    structure from above as our example:

    >>> headers._data
    {'set-cookie': [('Set-Cookie', 'foo=bar'), ('set-cookie', 'baz=quxx')],
    'content-length': [('content-length', '7')]}
    """

    def __init__(self, headers=None, **kwargs):
        self._data = {}
        if headers is None:
            headers = {}
        self.update(headers, **kwargs)

    def add(self, key, value):
        """Adds a (name, value) pair, doesn't overwrite the value if it already
        exists.

        >>> headers = HTTPHeaderDict(foo='bar')
        >>> headers.add('Foo', 'baz')
        >>> headers['foo']
        'bar, baz'
        """
        self._data.setdefault(key.lower(), []).append((key, value))

    def getlist(self, key):
        """Returns a list of all the values for the named field. Returns an
        empty list if the key doesn't exist."""
        return self[key].split(', ') if key in self else []

    def copy(self):
        h = HTTPHeaderDict()
        for key in self._data:
            for rawkey, value in self._data[key]:
                h.add(rawkey, value)
        return h

    def __eq__(self, other):
        if not isinstance(other, Mapping):
            return False
        other = HTTPHeaderDict(other)
        return dict((k1, self[k1]) for k1 in self._data) == \
                dict((k2, other[k2]) for k2 in other._data)

    def __getitem__(self, key):
        values = self._data[key.lower()]
        return ', '.join(value[1] for value in values)

    def __setitem__(self, key, value):
        self._data[key.lower()] = [(key, value)]

    def __delitem__(self, key):
        del self._data[key.lower()]

    def __len__(self):
        return len(self._data)

    def __iter__(self):
        for headers in itervalues(self._data):
            yield headers[0][0]

    def __repr__(self):
        return '%s(%r)' % (self.__class__.__name__, dict(self.items()))

########NEW FILE########
__FILENAME__ = sessions
# -*- coding: utf-8 -*-

"""
requests.session
~~~~~~~~~~~~~~~~

This module provides a Session object to manage and persist settings across
requests (cookies, auth, proxies).

"""
import os
from collections import Mapping
from datetime import datetime

from .auth import _basic_auth_str
from .compat import cookielib, OrderedDict, urljoin, urlparse, builtin_str
from .cookies import (
    cookiejar_from_dict, extract_cookies_to_jar, RequestsCookieJar, merge_cookies)
from .models import Request, PreparedRequest, DEFAULT_REDIRECT_LIMIT
from .hooks import default_hooks, dispatch_hook
from .utils import to_key_val_list, default_headers, to_native_string
from .exceptions import (
    TooManyRedirects, InvalidSchema, ChunkedEncodingError, ContentDecodingError)
from .structures import CaseInsensitiveDict

from .adapters import HTTPAdapter

from .utils import (
    requote_uri, get_environ_proxies, get_netrc_auth, should_bypass_proxies,
    get_auth_from_url
)

from .status_codes import codes

# formerly defined here, reexposed here for backward compatibility
from .models import REDIRECT_STATI


def merge_setting(request_setting, session_setting, dict_class=OrderedDict):
    """
    Determines appropriate setting for a given request, taking into account the
    explicit setting on that request, and the setting in the session. If a
    setting is a dictionary, they will be merged together using `dict_class`
    """

    if session_setting is None:
        return request_setting

    if request_setting is None:
        return session_setting

    # Bypass if not a dictionary (e.g. verify)
    if not (
            isinstance(session_setting, Mapping) and
            isinstance(request_setting, Mapping)
    ):
        return request_setting

    merged_setting = dict_class(to_key_val_list(session_setting))
    merged_setting.update(to_key_val_list(request_setting))

    # Remove keys that are set to None.
    for (k, v) in request_setting.items():
        if v is None:
            del merged_setting[k]

    merged_setting = dict((k, v) for (k, v) in merged_setting.items() if v is not None)

    return merged_setting


def merge_hooks(request_hooks, session_hooks, dict_class=OrderedDict):
    """
    Properly merges both requests and session hooks.

    This is necessary because when request_hooks == {'response': []}, the
    merge breaks Session hooks entirely.
    """
    if session_hooks is None or session_hooks.get('response') == []:
        return request_hooks

    if request_hooks is None or request_hooks.get('response') == []:
        return session_hooks

    return merge_setting(request_hooks, session_hooks, dict_class)


class SessionRedirectMixin(object):
    def resolve_redirects(self, resp, req, stream=False, timeout=None,
                          verify=True, cert=None, proxies=None):
        """Receives a Response. Returns a generator of Responses."""

        i = 0

        while resp.is_redirect:
            prepared_request = req.copy()

            try:
                resp.content  # Consume socket so it can be released
            except (ChunkedEncodingError, ContentDecodingError, RuntimeError):
                resp.raw.read(decode_content=False)

            if i >= self.max_redirects:
                raise TooManyRedirects('Exceeded %s redirects.' % self.max_redirects)

            # Release the connection back into the pool.
            resp.close()

            url = resp.headers['location']
            method = req.method

            # Handle redirection without scheme (see: RFC 1808 Section 4)
            if url.startswith('//'):
                parsed_rurl = urlparse(resp.url)
                url = '%s:%s' % (parsed_rurl.scheme, url)

            # The scheme should be lower case...
            parsed = urlparse(url)
            url = parsed.geturl()

            # Facilitate non-RFC2616-compliant 'location' headers
            # (e.g. '/path/to/resource' instead of 'http://domain.tld/path/to/resource')
            # Compliant with RFC3986, we percent encode the url.
            if not urlparse(url).netloc:
                url = urljoin(resp.url, requote_uri(url))
            else:
                url = requote_uri(url)

            prepared_request.url = to_native_string(url)

            # http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4
            if (resp.status_code == codes.see_other and
                    method != 'HEAD'):
                method = 'GET'

            # Do what the browsers do, despite standards...
            # First, turn 302s into GETs.
            if resp.status_code == codes.found and method != 'HEAD':
                method = 'GET'

            # Second, if a POST is responded to with a 301, turn it into a GET.
            # This bizarre behaviour is explained in Issue 1704.
            if resp.status_code == codes.moved and method == 'POST':
                method = 'GET'

            prepared_request.method = method

            # https://github.com/kennethreitz/requests/issues/1084
            if resp.status_code not in (codes.temporary, codes.resume):
                if 'Content-Length' in prepared_request.headers:
                    del prepared_request.headers['Content-Length']

                prepared_request.body = None

            headers = prepared_request.headers
            try:
                del headers['Cookie']
            except KeyError:
                pass

            extract_cookies_to_jar(prepared_request._cookies, prepared_request, resp.raw)
            prepared_request._cookies.update(self.cookies)
            prepared_request.prepare_cookies(prepared_request._cookies)

            # Rebuild auth and proxy information.
            proxies = self.rebuild_proxies(prepared_request, proxies)
            self.rebuild_auth(prepared_request, resp)

            # Override the original request.
            req = prepared_request

            resp = self.send(
                req,
                stream=stream,
                timeout=timeout,
                verify=verify,
                cert=cert,
                proxies=proxies,
                allow_redirects=False,
            )

            extract_cookies_to_jar(self.cookies, prepared_request, resp.raw)

            i += 1
            yield resp

    def rebuild_auth(self, prepared_request, response):
        """
        When being redirected we may want to strip authentication from the
        request to avoid leaking credentials. This method intelligently removes
        and reapplies authentication where possible to avoid credential loss.
        """
        headers = prepared_request.headers
        url = prepared_request.url

        if 'Authorization' in headers:
            # If we get redirected to a new host, we should strip out any
            # authentication headers.
            original_parsed = urlparse(response.request.url)
            redirect_parsed = urlparse(url)

            if (original_parsed.hostname != redirect_parsed.hostname):
                del headers['Authorization']

        # .netrc might have more auth for us on our new host.
        new_auth = get_netrc_auth(url) if self.trust_env else None
        if new_auth is not None:
            prepared_request.prepare_auth(new_auth)

        return

    def rebuild_proxies(self, prepared_request, proxies):
        """
        This method re-evaluates the proxy configuration by considering the
        environment variables. If we are redirected to a URL covered by
        NO_PROXY, we strip the proxy configuration. Otherwise, we set missing
        proxy keys for this URL (in case they were stripped by a previous
        redirect).

        This method also replaces the Proxy-Authorization header where
        necessary.
        """
        headers = prepared_request.headers
        url = prepared_request.url
        scheme = urlparse(url).scheme
        new_proxies = proxies.copy() if proxies is not None else {}

        if self.trust_env and not should_bypass_proxies(url):
            environ_proxies = get_environ_proxies(url)

            proxy = environ_proxies.get(scheme)

            if proxy:
                new_proxies.setdefault(scheme, environ_proxies[scheme])

        if 'Proxy-Authorization' in headers:
            del headers['Proxy-Authorization']

        try:
            username, password = get_auth_from_url(new_proxies[scheme])
        except KeyError:
            username, password = None, None

        if username and password:
            headers['Proxy-Authorization'] = _basic_auth_str(username, password)

        return new_proxies


class Session(SessionRedirectMixin):
    """A Requests session.

    Provides cookie persistence, connection-pooling, and configuration.

    Basic Usage::

      >>> import requests
      >>> s = requests.Session()
      >>> s.get('http://httpbin.org/get')
      200
    """

    __attrs__ = [
        'headers', 'cookies', 'auth', 'timeout', 'proxies', 'hooks',
        'params', 'verify', 'cert', 'prefetch', 'adapters', 'stream',
        'trust_env', 'max_redirects']

    def __init__(self):

        #: A case-insensitive dictionary of headers to be sent on each
        #: :class:`Request <Request>` sent from this
        #: :class:`Session <Session>`.
        self.headers = default_headers()

        #: Default Authentication tuple or object to attach to
        #: :class:`Request <Request>`.
        self.auth = None

        #: Dictionary mapping protocol to the URL of the proxy (e.g.
        #: {'http': 'foo.bar:3128'}) to be used on each
        #: :class:`Request <Request>`.
        self.proxies = {}

        #: Event-handling hooks.
        self.hooks = default_hooks()

        #: Dictionary of querystring data to attach to each
        #: :class:`Request <Request>`. The dictionary values may be lists for
        #: representing multivalued query parameters.
        self.params = {}

        #: Stream response content default.
        self.stream = False

        #: SSL Verification default.
        self.verify = True

        #: SSL certificate default.
        self.cert = None

        #: Maximum number of redirects allowed. If the request exceeds this
        #: limit, a :class:`TooManyRedirects` exception is raised.
        self.max_redirects = DEFAULT_REDIRECT_LIMIT

        #: Should we trust the environment?
        self.trust_env = True

        #: A CookieJar containing all currently outstanding cookies set on this
        #: session. By default it is a
        #: :class:`RequestsCookieJar <requests.cookies.RequestsCookieJar>`, but
        #: may be any other ``cookielib.CookieJar`` compatible object.
        self.cookies = cookiejar_from_dict({})

        # Default connection adapters.
        self.adapters = OrderedDict()
        self.mount('https://', HTTPAdapter())
        self.mount('http://', HTTPAdapter())

    def __enter__(self):
        return self

    def __exit__(self, *args):
        self.close()

    def prepare_request(self, request):
        """Constructs a :class:`PreparedRequest <PreparedRequest>` for
        transmission and returns it. The :class:`PreparedRequest` has settings
        merged from the :class:`Request <Request>` instance and those of the
        :class:`Session`.

        :param request: :class:`Request` instance to prepare with this
            session's settings.
        """
        cookies = request.cookies or {}

        # Bootstrap CookieJar.
        if not isinstance(cookies, cookielib.CookieJar):
            cookies = cookiejar_from_dict(cookies)

        # Merge with session cookies
        merged_cookies = merge_cookies(
            merge_cookies(RequestsCookieJar(), self.cookies), cookies)


        # Set environment's basic authentication if not explicitly set.
        auth = request.auth
        if self.trust_env and not auth and not self.auth:
            auth = get_netrc_auth(request.url)

        p = PreparedRequest()
        p.prepare(
            method=request.method.upper(),
            url=request.url,
            files=request.files,
            data=request.data,
            headers=merge_setting(request.headers, self.headers, dict_class=CaseInsensitiveDict),
            params=merge_setting(request.params, self.params),
            auth=merge_setting(auth, self.auth),
            cookies=merged_cookies,
            hooks=merge_hooks(request.hooks, self.hooks),
        )
        return p

    def request(self, method, url,
        params=None,
        data=None,
        headers=None,
        cookies=None,
        files=None,
        auth=None,
        timeout=None,
        allow_redirects=True,
        proxies=None,
        hooks=None,
        stream=None,
        verify=None,
        cert=None):
        """Constructs a :class:`Request <Request>`, prepares it and sends it.
        Returns :class:`Response <Response>` object.

        :param method: method for the new :class:`Request` object.
        :param url: URL for the new :class:`Request` object.
        :param params: (optional) Dictionary or bytes to be sent in the query
            string for the :class:`Request`.
        :param data: (optional) Dictionary or bytes to send in the body of the
            :class:`Request`.
        :param headers: (optional) Dictionary of HTTP Headers to send with the
            :class:`Request`.
        :param cookies: (optional) Dict or CookieJar object to send with the
            :class:`Request`.
        :param files: (optional) Dictionary of 'filename': file-like-objects
            for multipart encoding upload.
        :param auth: (optional) Auth tuple or callable to enable
            Basic/Digest/Custom HTTP Auth.
        :param timeout: (optional) Float describing the timeout of the
            request in seconds.
        :param allow_redirects: (optional) Boolean. Set to True by default.
        :param proxies: (optional) Dictionary mapping protocol to the URL of
            the proxy.
        :param stream: (optional) whether to immediately download the response
            content. Defaults to ``False``.
        :param verify: (optional) if ``True``, the SSL cert will be verified.
            A CA_BUNDLE path can also be provided.
        :param cert: (optional) if String, path to ssl client cert file (.pem).
            If Tuple, ('cert', 'key') pair.
        """

        method = builtin_str(method)

        # Create the Request.
        req = Request(
            method = method.upper(),
            url = url,
            headers = headers,
            files = files,
            data = data or {},
            params = params or {},
            auth = auth,
            cookies = cookies,
            hooks = hooks,
        )
        prep = self.prepare_request(req)

        proxies = proxies or {}

        # Gather clues from the surrounding environment.
        if self.trust_env:
            # Set environment's proxies.
            env_proxies = get_environ_proxies(url) or {}
            for (k, v) in env_proxies.items():
                proxies.setdefault(k, v)

            # Look for configuration.
            if not verify and verify is not False:
                verify = os.environ.get('REQUESTS_CA_BUNDLE')

            # Curl compatibility.
            if not verify and verify is not False:
                verify = os.environ.get('CURL_CA_BUNDLE')

        # Merge all the kwargs.
        proxies = merge_setting(proxies, self.proxies)
        stream = merge_setting(stream, self.stream)
        verify = merge_setting(verify, self.verify)
        cert = merge_setting(cert, self.cert)

        # Send the request.
        send_kwargs = {
            'stream': stream,
            'timeout': timeout,
            'verify': verify,
            'cert': cert,
            'proxies': proxies,
            'allow_redirects': allow_redirects,
        }
        resp = self.send(prep, **send_kwargs)

        return resp

    def get(self, url, **kwargs):
        """Sends a GET request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        """

        kwargs.setdefault('allow_redirects', True)
        return self.request('GET', url, **kwargs)

    def options(self, url, **kwargs):
        """Sends a OPTIONS request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        """

        kwargs.setdefault('allow_redirects', True)
        return self.request('OPTIONS', url, **kwargs)

    def head(self, url, **kwargs):
        """Sends a HEAD request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        """

        kwargs.setdefault('allow_redirects', False)
        return self.request('HEAD', url, **kwargs)

    def post(self, url, data=None, **kwargs):
        """Sends a POST request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        """

        return self.request('POST', url, data=data, **kwargs)

    def put(self, url, data=None, **kwargs):
        """Sends a PUT request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        """

        return self.request('PUT', url, data=data, **kwargs)

    def patch(self, url, data=None, **kwargs):
        """Sends a PATCH request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param data: (optional) Dictionary, bytes, or file-like object to send in the body of the :class:`Request`.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        """

        return self.request('PATCH', url,  data=data, **kwargs)

    def delete(self, url, **kwargs):
        """Sends a DELETE request. Returns :class:`Response` object.

        :param url: URL for the new :class:`Request` object.
        :param \*\*kwargs: Optional arguments that ``request`` takes.
        """

        return self.request('DELETE', url, **kwargs)

    def send(self, request, **kwargs):
        """Send a given PreparedRequest."""
        # Set defaults that the hooks can utilize to ensure they always have
        # the correct parameters to reproduce the previous request.
        kwargs.setdefault('stream', self.stream)
        kwargs.setdefault('verify', self.verify)
        kwargs.setdefault('cert', self.cert)
        kwargs.setdefault('proxies', self.proxies)

        # It's possible that users might accidentally send a Request object.
        # Guard against that specific failure case.
        if not isinstance(request, PreparedRequest):
            raise ValueError('You can only send PreparedRequests.')

        # Set up variables needed for resolve_redirects and dispatching of hooks
        allow_redirects = kwargs.pop('allow_redirects', True)
        stream = kwargs.get('stream')
        timeout = kwargs.get('timeout')
        verify = kwargs.get('verify')
        cert = kwargs.get('cert')
        proxies = kwargs.get('proxies')
        hooks = request.hooks

        # Get the appropriate adapter to use
        adapter = self.get_adapter(url=request.url)

        # Start time (approximately) of the request
        start = datetime.utcnow()

        # Send the request
        r = adapter.send(request, **kwargs)

        # Total elapsed time of the request (approximately)
        r.elapsed = datetime.utcnow() - start

        # Response manipulation hooks
        r = dispatch_hook('response', hooks, r, **kwargs)

        # Persist cookies
        if r.history:

            # If the hooks create history then we want those cookies too
            for resp in r.history:
                extract_cookies_to_jar(self.cookies, resp.request, resp.raw)

        extract_cookies_to_jar(self.cookies, request, r.raw)

        # Redirect resolving generator.
        gen = self.resolve_redirects(r, request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies)

        # Resolve redirects if allowed.
        history = [resp for resp in gen] if allow_redirects else []

        # Shuffle things around if there's history.
        if history:
            # Insert the first (original) request at the start
            history.insert(0, r)
            # Get the last request made
            r = history.pop()
            r.history = history

        if not stream:
            r.content

        return r

    def get_adapter(self, url):
        """Returns the appropriate connnection adapter for the given URL."""
        for (prefix, adapter) in self.adapters.items():

            if url.lower().startswith(prefix):
                return adapter

        # Nothing matches :-/
        raise InvalidSchema("No connection adapters were found for '%s'" % url)

    def close(self):
        """Closes all adapters and as such the session"""
        for v in self.adapters.values():
            v.close()

    def mount(self, prefix, adapter):
        """Registers a connection adapter to a prefix.

        Adapters are sorted in descending order by key length."""

        self.adapters[prefix] = adapter
        keys_to_move = [k for k in self.adapters if len(k) < len(prefix)]

        for key in keys_to_move:
            self.adapters[key] = self.adapters.pop(key)

    def __getstate__(self):
        return dict((attr, getattr(self, attr, None)) for attr in self.__attrs__)

    def __setstate__(self, state):
        for attr, value in state.items():
            setattr(self, attr, value)


def session():
    """Returns a :class:`Session` for context-management."""

    return Session()

########NEW FILE########
__FILENAME__ = status_codes
# -*- coding: utf-8 -*-

from .structures import LookupDict

_codes = {

    # Informational.
    100: ('continue',),
    101: ('switching_protocols',),
    102: ('processing',),
    103: ('checkpoint',),
    122: ('uri_too_long', 'request_uri_too_long'),
    200: ('ok', 'okay', 'all_ok', 'all_okay', 'all_good', '\\o/', '✓'),
    201: ('created',),
    202: ('accepted',),
    203: ('non_authoritative_info', 'non_authoritative_information'),
    204: ('no_content',),
    205: ('reset_content', 'reset'),
    206: ('partial_content', 'partial'),
    207: ('multi_status', 'multiple_status', 'multi_stati', 'multiple_stati'),
    208: ('already_reported',),
    226: ('im_used',),

    # Redirection.
    300: ('multiple_choices',),
    301: ('moved_permanently', 'moved', '\\o-'),
    302: ('found',),
    303: ('see_other', 'other'),
    304: ('not_modified',),
    305: ('use_proxy',),
    306: ('switch_proxy',),
    307: ('temporary_redirect', 'temporary_moved', 'temporary'),
    308: ('resume_incomplete', 'resume'),

    # Client Error.
    400: ('bad_request', 'bad'),
    401: ('unauthorized',),
    402: ('payment_required', 'payment'),
    403: ('forbidden',),
    404: ('not_found', '-o-'),
    405: ('method_not_allowed', 'not_allowed'),
    406: ('not_acceptable',),
    407: ('proxy_authentication_required', 'proxy_auth', 'proxy_authentication'),
    408: ('request_timeout', 'timeout'),
    409: ('conflict',),
    410: ('gone',),
    411: ('length_required',),
    412: ('precondition_failed', 'precondition'),
    413: ('request_entity_too_large',),
    414: ('request_uri_too_large',),
    415: ('unsupported_media_type', 'unsupported_media', 'media_type'),
    416: ('requested_range_not_satisfiable', 'requested_range', 'range_not_satisfiable'),
    417: ('expectation_failed',),
    418: ('im_a_teapot', 'teapot', 'i_am_a_teapot'),
    422: ('unprocessable_entity', 'unprocessable'),
    423: ('locked',),
    424: ('failed_dependency', 'dependency'),
    425: ('unordered_collection', 'unordered'),
    426: ('upgrade_required', 'upgrade'),
    428: ('precondition_required', 'precondition'),
    429: ('too_many_requests', 'too_many'),
    431: ('header_fields_too_large', 'fields_too_large'),
    444: ('no_response', 'none'),
    449: ('retry_with', 'retry'),
    450: ('blocked_by_windows_parental_controls', 'parental_controls'),
    451: ('unavailable_for_legal_reasons', 'legal_reasons'),
    499: ('client_closed_request',),

    # Server Error.
    500: ('internal_server_error', 'server_error', '/o\\', '✗'),
    501: ('not_implemented',),
    502: ('bad_gateway',),
    503: ('service_unavailable', 'unavailable'),
    504: ('gateway_timeout',),
    505: ('http_version_not_supported', 'http_version'),
    506: ('variant_also_negotiates',),
    507: ('insufficient_storage',),
    509: ('bandwidth_limit_exceeded', 'bandwidth'),
    510: ('not_extended',),
}

codes = LookupDict(name='status_codes')

for (code, titles) in list(_codes.items()):
    for title in titles:
        setattr(codes, title, code)
        if not title.startswith('\\'):
            setattr(codes, title.upper(), code)

########NEW FILE########
__FILENAME__ = structures
# -*- coding: utf-8 -*-

"""
requests.structures
~~~~~~~~~~~~~~~~~~~

Data structures that power Requests.

"""

import os
import collections
from itertools import islice


class IteratorProxy(object):
    """docstring for IteratorProxy"""
    def __init__(self, i):
        self.i = i
        # self.i = chain.from_iterable(i)

    def __iter__(self):
        return self.i

    def __len__(self):
        if hasattr(self.i, '__len__'):
            return len(self.i)
        if hasattr(self.i, 'len'):
            return self.i.len
        if hasattr(self.i, 'fileno'):
            return os.fstat(self.i.fileno()).st_size

    def read(self, n):
        return "".join(islice(self.i, None, n))


class CaseInsensitiveDict(collections.MutableMapping):
    """
    A case-insensitive ``dict``-like object.

    Implements all methods and operations of
    ``collections.MutableMapping`` as well as dict's ``copy``. Also
    provides ``lower_items``.

    All keys are expected to be strings. The structure remembers the
    case of the last key to be set, and ``iter(instance)``,
    ``keys()``, ``items()``, ``iterkeys()``, and ``iteritems()``
    will contain case-sensitive keys. However, querying and contains
    testing is case insensitive:

        cid = CaseInsensitiveDict()
        cid['Accept'] = 'application/json'
        cid['aCCEPT'] == 'application/json'  # True
        list(cid) == ['Accept']  # True

    For example, ``headers['content-encoding']`` will return the
    value of a ``'Content-Encoding'`` response header, regardless
    of how the header name was originally stored.

    If the constructor, ``.update``, or equality comparison
    operations are given keys that have equal ``.lower()``s, the
    behavior is undefined.

    """
    def __init__(self, data=None, **kwargs):
        self._store = dict()
        if data is None:
            data = {}
        self.update(data, **kwargs)

    def __setitem__(self, key, value):
        # Use the lowercased key for lookups, but store the actual
        # key alongside the value.
        self._store[key.lower()] = (key, value)

    def __getitem__(self, key):
        return self._store[key.lower()][1]

    def __delitem__(self, key):
        del self._store[key.lower()]

    def __iter__(self):
        return (casedkey for casedkey, mappedvalue in self._store.values())

    def __len__(self):
        return len(self._store)

    def lower_items(self):
        """Like iteritems(), but with all lowercase keys."""
        return (
            (lowerkey, keyval[1])
            for (lowerkey, keyval)
            in self._store.items()
        )

    def __eq__(self, other):
        if isinstance(other, collections.Mapping):
            other = CaseInsensitiveDict(other)
        else:
            return NotImplemented
        # Compare insensitively
        return dict(self.lower_items()) == dict(other.lower_items())

    # Copy is required
    def copy(self):
        return CaseInsensitiveDict(self._store.values())

    def __repr__(self):
        return str(dict(self.items()))

class LookupDict(dict):
    """Dictionary lookup object."""

    def __init__(self, name=None):
        self.name = name
        super(LookupDict, self).__init__()

    def __repr__(self):
        return '<lookup \'%s\'>' % (self.name)

    def __getitem__(self, key):
        # We allow fall-through here, so values default to None

        return self.__dict__.get(key, None)

    def get(self, key, default=None):
        return self.__dict__.get(key, default)

########NEW FILE########
__FILENAME__ = utils
# -*- coding: utf-8 -*-

"""
requests.utils
~~~~~~~~~~~~~~

This module provides utility functions that are used within Requests
that are also useful for external consumption.

"""

import cgi
import codecs
import collections
import io
import os
import platform
import re
import sys
import socket
import struct

from . import __version__
from . import certs
from .compat import parse_http_list as _parse_list_header
from .compat import (quote, urlparse, bytes, str, OrderedDict, unquote, is_py2,
                     builtin_str, getproxies, proxy_bypass, urlunparse)
from .cookies import RequestsCookieJar, cookiejar_from_dict
from .structures import CaseInsensitiveDict
from .exceptions import InvalidURL

_hush_pyflakes = (RequestsCookieJar,)

NETRC_FILES = ('.netrc', '_netrc')

DEFAULT_CA_BUNDLE_PATH = certs.where()


def dict_to_sequence(d):
    """Returns an internal sequence dictionary update."""

    if hasattr(d, 'items'):
        d = d.items()

    return d


def super_len(o):
    if hasattr(o, '__len__'):
        return len(o)

    if hasattr(o, 'len'):
        return o.len

    if hasattr(o, 'fileno'):
        try:
            fileno = o.fileno()
        except io.UnsupportedOperation:
            pass
        else:
            return os.fstat(fileno).st_size

    if hasattr(o, 'getvalue'):
        # e.g. BytesIO, cStringIO.StringIO
        return len(o.getvalue())


def get_netrc_auth(url):
    """Returns the Requests tuple auth for a given url from netrc."""

    try:
        from netrc import netrc, NetrcParseError

        netrc_path = None

        for f in NETRC_FILES:
            try:
                loc = os.path.expanduser('~/{0}'.format(f))
            except KeyError:
                # os.path.expanduser can fail when $HOME is undefined and
                # getpwuid fails. See http://bugs.python.org/issue20164 &
                # https://github.com/kennethreitz/requests/issues/1846
                return

            if os.path.exists(loc):
                netrc_path = loc
                break

        # Abort early if there isn't one.
        if netrc_path is None:
            return

        ri = urlparse(url)

        # Strip port numbers from netloc
        host = ri.netloc.split(':')[0]

        try:
            _netrc = netrc(netrc_path).authenticators(host)
            if _netrc:
                # Return with login / password
                login_i = (0 if _netrc[0] else 1)
                return (_netrc[login_i], _netrc[2])
        except (NetrcParseError, IOError):
            # If there was a parsing error or a permissions issue reading the file,
            # we'll just skip netrc auth
            pass

    # AppEngine hackiness.
    except (ImportError, AttributeError):
        pass


def guess_filename(obj):
    """Tries to guess the filename of the given object."""
    name = getattr(obj, 'name', None)
    if name and name[0] != '<' and name[-1] != '>':
        return os.path.basename(name)


def from_key_val_list(value):
    """Take an object and test to see if it can be represented as a
    dictionary. Unless it can not be represented as such, return an
    OrderedDict, e.g.,

    ::

        >>> from_key_val_list([('key', 'val')])
        OrderedDict([('key', 'val')])
        >>> from_key_val_list('string')
        ValueError: need more than 1 value to unpack
        >>> from_key_val_list({'key': 'val'})
        OrderedDict([('key', 'val')])
    """
    if value is None:
        return None

    if isinstance(value, (str, bytes, bool, int)):
        raise ValueError('cannot encode objects that are not 2-tuples')

    return OrderedDict(value)


def to_key_val_list(value):
    """Take an object and test to see if it can be represented as a
    dictionary. If it can be, return a list of tuples, e.g.,

    ::

        >>> to_key_val_list([('key', 'val')])
        [('key', 'val')]
        >>> to_key_val_list({'key': 'val'})
        [('key', 'val')]
        >>> to_key_val_list('string')
        ValueError: cannot encode objects that are not 2-tuples.
    """
    if value is None:
        return None

    if isinstance(value, (str, bytes, bool, int)):
        raise ValueError('cannot encode objects that are not 2-tuples')

    if isinstance(value, collections.Mapping):
        value = value.items()

    return list(value)


# From mitsuhiko/werkzeug (used with permission).
def parse_list_header(value):
    """Parse lists as described by RFC 2068 Section 2.

    In particular, parse comma-separated lists where the elements of
    the list may include quoted-strings.  A quoted-string could
    contain a comma.  A non-quoted string could have quotes in the
    middle.  Quotes are removed automatically after parsing.

    It basically works like :func:`parse_set_header` just that items
    may appear multiple times and case sensitivity is preserved.

    The return value is a standard :class:`list`:

    >>> parse_list_header('token, "quoted value"')
    ['token', 'quoted value']

    To create a header from the :class:`list` again, use the
    :func:`dump_header` function.

    :param value: a string with a list header.
    :return: :class:`list`
    """
    result = []
    for item in _parse_list_header(value):
        if item[:1] == item[-1:] == '"':
            item = unquote_header_value(item[1:-1])
        result.append(item)
    return result


# From mitsuhiko/werkzeug (used with permission).
def parse_dict_header(value):
    """Parse lists of key, value pairs as described by RFC 2068 Section 2 and
    convert them into a python dict:

    >>> d = parse_dict_header('foo="is a fish", bar="as well"')
    >>> type(d) is dict
    True
    >>> sorted(d.items())
    [('bar', 'as well'), ('foo', 'is a fish')]

    If there is no value for a key it will be `None`:

    >>> parse_dict_header('key_without_value')
    {'key_without_value': None}

    To create a header from the :class:`dict` again, use the
    :func:`dump_header` function.

    :param value: a string with a dict header.
    :return: :class:`dict`
    """
    result = {}
    for item in _parse_list_header(value):
        if '=' not in item:
            result[item] = None
            continue
        name, value = item.split('=', 1)
        if value[:1] == value[-1:] == '"':
            value = unquote_header_value(value[1:-1])
        result[name] = value
    return result


# From mitsuhiko/werkzeug (used with permission).
def unquote_header_value(value, is_filename=False):
    r"""Unquotes a header value.  (Reversal of :func:`quote_header_value`).
    This does not use the real unquoting but what browsers are actually
    using for quoting.

    :param value: the header value to unquote.
    """
    if value and value[0] == value[-1] == '"':
        # this is not the real unquoting, but fixing this so that the
        # RFC is met will result in bugs with internet explorer and
        # probably some other browsers as well.  IE for example is
        # uploading files with "C:\foo\bar.txt" as filename
        value = value[1:-1]

        # if this is a filename and the starting characters look like
        # a UNC path, then just return the value without quotes.  Using the
        # replace sequence below on a UNC path has the effect of turning
        # the leading double slash into a single slash and then
        # _fix_ie_filename() doesn't work correctly.  See #458.
        if not is_filename or value[:2] != '\\\\':
            return value.replace('\\\\', '\\').replace('\\"', '"')
    return value


def dict_from_cookiejar(cj):
    """Returns a key/value dictionary from a CookieJar.

    :param cj: CookieJar object to extract cookies from.
    """

    cookie_dict = {}

    for cookie in cj:
        cookie_dict[cookie.name] = cookie.value

    return cookie_dict


def add_dict_to_cookiejar(cj, cookie_dict):
    """Returns a CookieJar from a key/value dictionary.

    :param cj: CookieJar to insert cookies into.
    :param cookie_dict: Dict of key/values to insert into CookieJar.
    """

    cj2 = cookiejar_from_dict(cookie_dict)
    cj.update(cj2)
    return cj


def get_encodings_from_content(content):
    """Returns encodings from given content string.

    :param content: bytestring to extract encodings from.
    """

    charset_re = re.compile(r'<meta.*?charset=["\']*(.+?)["\'>]', flags=re.I)
    pragma_re = re.compile(r'<meta.*?content=["\']*;?charset=(.+?)["\'>]', flags=re.I)
    xml_re = re.compile(r'^<\?xml.*?encoding=["\']*(.+?)["\'>]')

    return (charset_re.findall(content) +
            pragma_re.findall(content) +
            xml_re.findall(content))


def get_encoding_from_headers(headers):
    """Returns encodings from given HTTP Header Dict.

    :param headers: dictionary to extract encoding from.
    """

    content_type = headers.get('content-type')

    if not content_type:
        return None

    content_type, params = cgi.parse_header(content_type)

    if 'charset' in params:
        return params['charset'].strip("'\"")

    if 'text' in content_type:
        return 'ISO-8859-1'


def stream_decode_response_unicode(iterator, r):
    """Stream decodes a iterator."""

    if r.encoding is None:
        for item in iterator:
            yield item
        return

    decoder = codecs.getincrementaldecoder(r.encoding)(errors='replace')
    for chunk in iterator:
        rv = decoder.decode(chunk)
        if rv:
            yield rv
    rv = decoder.decode(b'', final=True)
    if rv:
        yield rv


def iter_slices(string, slice_length):
    """Iterate over slices of a string."""
    pos = 0
    while pos < len(string):
        yield string[pos:pos + slice_length]
        pos += slice_length


def get_unicode_from_response(r):
    """Returns the requested content back in unicode.

    :param r: Response object to get unicode content from.

    Tried:

    1. charset from content-type

    2. every encodings from ``<meta ... charset=XXX>``

    3. fall back and replace all unicode characters

    """

    tried_encodings = []

    # Try charset from content-type
    encoding = get_encoding_from_headers(r.headers)

    if encoding:
        try:
            return str(r.content, encoding)
        except UnicodeError:
            tried_encodings.append(encoding)

    # Fall back:
    try:
        return str(r.content, encoding, errors='replace')
    except TypeError:
        return r.content


# The unreserved URI characters (RFC 3986)
UNRESERVED_SET = frozenset(
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    + "0123456789-._~")


def unquote_unreserved(uri):
    """Un-escape any percent-escape sequences in a URI that are unreserved
    characters. This leaves all reserved, illegal and non-ASCII bytes encoded.
    """
    parts = uri.split('%')
    for i in range(1, len(parts)):
        h = parts[i][0:2]
        if len(h) == 2 and h.isalnum():
            try:
                c = chr(int(h, 16))
            except ValueError:
                raise InvalidURL("Invalid percent-escape sequence: '%s'" % h)

            if c in UNRESERVED_SET:
                parts[i] = c + parts[i][2:]
            else:
                parts[i] = '%' + parts[i]
        else:
            parts[i] = '%' + parts[i]
    return ''.join(parts)


def requote_uri(uri):
    """Re-quote the given URI.

    This function passes the given URI through an unquote/quote cycle to
    ensure that it is fully and consistently quoted.
    """
    # Unquote only the unreserved characters
    # Then quote only illegal characters (do not quote reserved, unreserved,
    # or '%')
    return quote(unquote_unreserved(uri), safe="!#$%&'()*+,/:;=?@[]~")


def address_in_network(ip, net):
    """
    This function allows you to check if on IP belongs to a network subnet
    Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24
             returns False if ip = 192.168.1.1 and net = 192.168.100.0/24
    """
    ipaddr = struct.unpack('=L', socket.inet_aton(ip))[0]
    netaddr, bits = net.split('/')
    netmask = struct.unpack('=L', socket.inet_aton(dotted_netmask(int(bits))))[0]
    network = struct.unpack('=L', socket.inet_aton(netaddr))[0] & netmask
    return (ipaddr & netmask) == (network & netmask)


def dotted_netmask(mask):
    """
    Converts mask from /xx format to xxx.xxx.xxx.xxx
    Example: if mask is 24 function returns 255.255.255.0
    """
    bits = 0xffffffff ^ (1 << 32 - mask) - 1
    return socket.inet_ntoa(struct.pack('>I', bits))


def is_ipv4_address(string_ip):
    try:
        socket.inet_aton(string_ip)
    except socket.error:
        return False
    return True


def is_valid_cidr(string_network):
    """Very simple check of the cidr format in no_proxy variable"""
    if string_network.count('/') == 1:
        try:
            mask = int(string_network.split('/')[1])
        except ValueError:
            return False

        if mask < 1 or mask > 32:
            return False

        try:
            socket.inet_aton(string_network.split('/')[0])
        except socket.error:
            return False
    else:
        return False
    return True


def should_bypass_proxies(url):
    """
    Returns whether we should bypass proxies or not.
    """
    get_proxy = lambda k: os.environ.get(k) or os.environ.get(k.upper())

    # First check whether no_proxy is defined. If it is, check that the URL
    # we're getting isn't in the no_proxy list.
    no_proxy = get_proxy('no_proxy')
    netloc = urlparse(url).netloc

    if no_proxy:
        # We need to check whether we match here. We need to see if we match
        # the end of the netloc, both with and without the port.
        no_proxy = no_proxy.replace(' ', '').split(',')

        ip = netloc.split(':')[0]
        if is_ipv4_address(ip):
            for proxy_ip in no_proxy:
                if is_valid_cidr(proxy_ip):
                    if address_in_network(ip, proxy_ip):
                        return True
        else:
            for host in no_proxy:
                if netloc.endswith(host) or netloc.split(':')[0].endswith(host):
                    # The URL does match something in no_proxy, so we don't want
                    # to apply the proxies on this URL.
                    return True

    # If the system proxy settings indicate that this URL should be bypassed,
    # don't proxy.
    # The proxy_bypass function is incredibly buggy on OS X in early versions
    # of Python 2.6, so allow this call to fail. Only catch the specific
    # exceptions we've seen, though: this call failing in other ways can reveal
    # legitimate problems.
    try:
        bypass = proxy_bypass(netloc)
    except (TypeError, socket.gaierror):
        bypass = False

    if bypass:
        return True

    return False

def get_environ_proxies(url):
    """Return a dict of environment proxies."""
    if should_bypass_proxies(url):
        return {}
    else:
        return getproxies()


def default_user_agent(name="python-requests"):
    """Return a string representing the default user agent."""
    _implementation = platform.python_implementation()

    if _implementation == 'CPython':
        _implementation_version = platform.python_version()
    elif _implementation == 'PyPy':
        _implementation_version = '%s.%s.%s' % (sys.pypy_version_info.major,
                                                sys.pypy_version_info.minor,
                                                sys.pypy_version_info.micro)
        if sys.pypy_version_info.releaselevel != 'final':
            _implementation_version = ''.join([_implementation_version, sys.pypy_version_info.releaselevel])
    elif _implementation == 'Jython':
        _implementation_version = platform.python_version()  # Complete Guess
    elif _implementation == 'IronPython':
        _implementation_version = platform.python_version()  # Complete Guess
    else:
        _implementation_version = 'Unknown'

    try:
        p_system = platform.system()
        p_release = platform.release()
    except IOError:
        p_system = 'Unknown'
        p_release = 'Unknown'

    return " ".join(['%s/%s' % (name, __version__),
                     '%s/%s' % (_implementation, _implementation_version),
                     '%s/%s' % (p_system, p_release)])


def default_headers():
    return CaseInsensitiveDict({
        'User-Agent': default_user_agent(),
        'Accept-Encoding': ', '.join(('gzip', 'deflate')),
        'Accept': '*/*'
    })


def parse_header_links(value):
    """Return a dict of parsed link headers proxies.

    i.e. Link: <http:/.../front.jpeg>; rel=front; type="image/jpeg",<http://.../back.jpeg>; rel=back;type="image/jpeg"

    """

    links = []

    replace_chars = " '\""

    for val in value.split(","):
        try:
            url, params = val.split(";", 1)
        except ValueError:
            url, params = val, ''

        link = {}

        link["url"] = url.strip("<> '\"")

        for param in params.split(";"):
            try:
                key, value = param.split("=")
            except ValueError:
                break

            link[key.strip(replace_chars)] = value.strip(replace_chars)

        links.append(link)

    return links


# Null bytes; no need to recreate these on each call to guess_json_utf
_null = '\x00'.encode('ascii')  # encoding to ASCII for Python 3
_null2 = _null * 2
_null3 = _null * 3


def guess_json_utf(data):
    # JSON always starts with two ASCII characters, so detection is as
    # easy as counting the nulls and from their location and count
    # determine the encoding. Also detect a BOM, if present.
    sample = data[:4]
    if sample in (codecs.BOM_UTF32_LE, codecs.BOM32_BE):
        return 'utf-32'     # BOM included
    if sample[:3] == codecs.BOM_UTF8:
        return 'utf-8-sig'  # BOM included, MS style (discouraged)
    if sample[:2] in (codecs.BOM_UTF16_LE, codecs.BOM_UTF16_BE):
        return 'utf-16'     # BOM included
    nullcount = sample.count(_null)
    if nullcount == 0:
        return 'utf-8'
    if nullcount == 2:
        if sample[::2] == _null2:   # 1st and 3rd are null
            return 'utf-16-be'
        if sample[1::2] == _null2:  # 2nd and 4th are null
            return 'utf-16-le'
        # Did not detect 2 valid UTF-16 ascii-range characters
    if nullcount == 3:
        if sample[:3] == _null3:
            return 'utf-32-be'
        if sample[1:] == _null3:
            return 'utf-32-le'
        # Did not detect a valid UTF-32 ascii-range character
    return None


def prepend_scheme_if_needed(url, new_scheme):
    '''Given a URL that may or may not have a scheme, prepend the given scheme.
    Does not replace a present scheme with the one provided as an argument.'''
    scheme, netloc, path, params, query, fragment = urlparse(url, new_scheme)

    # urlparse is a finicky beast, and sometimes decides that there isn't a
    # netloc present. Assume that it's being over-cautious, and switch netloc
    # and path if urlparse decided there was no netloc.
    if not netloc:
        netloc, path = path, netloc

    return urlunparse((scheme, netloc, path, params, query, fragment))


def get_auth_from_url(url):
    """Given a url with authentication components, extract them into a tuple of
    username,password."""
    parsed = urlparse(url)

    try:
        auth = (unquote(parsed.username), unquote(parsed.password))
    except (AttributeError, TypeError):
        auth = ('', '')

    return auth


def to_native_string(string, encoding='ascii'):
    """
    Given a string object, regardless of type, returns a representation of that
    string in the native string type, encoding and decoding where necessary.
    This assumes ASCII unless told otherwise.
    """
    out = None

    if isinstance(string, builtin_str):
        out = string
    else:
        if is_py2:
            out = string.encode(encoding)
        else:
            out = string.decode(encoding)

    return out

########NEW FILE########
__FILENAME__ = six
"""Utilities for writing code that runs on Python 2 and 3"""

# Copyright (c) 2010-2014 Benjamin Peterson
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import operator
import sys
import types

__author__ = "Benjamin Peterson <benjamin@python.org>"
__version__ = "1.6.1"


# Useful for very coarse version differentiation.
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3

if PY3:
    string_types = str,
    integer_types = int,
    class_types = type,
    text_type = str
    binary_type = bytes

    MAXSIZE = sys.maxsize
else:
    string_types = basestring,
    integer_types = (int, long)
    class_types = (type, types.ClassType)
    text_type = unicode
    binary_type = str

    if sys.platform.startswith("java"):
        # Jython always uses 32 bits.
        MAXSIZE = int((1 << 31) - 1)
    else:
        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).
        class X(object):
            def __len__(self):
                return 1 << 31
        try:
            len(X())
        except OverflowError:
            # 32-bit
            MAXSIZE = int((1 << 31) - 1)
        else:
            # 64-bit
            MAXSIZE = int((1 << 63) - 1)
        del X


def _add_doc(func, doc):
    """Add documentation to a function."""
    func.__doc__ = doc


def _import_module(name):
    """Import module, returning the module after the last dot."""
    __import__(name)
    return sys.modules[name]


class _LazyDescr(object):

    def __init__(self, name):
        self.name = name

    def __get__(self, obj, tp):
        try:
            result = self._resolve()
        except ImportError:
            # See the nice big comment in MovedModule.__getattr__.
            raise AttributeError("%s could not be imported " % self.name)
        setattr(obj, self.name, result) # Invokes __set__.
        # This is a bit ugly, but it avoids running this again.
        delattr(obj.__class__, self.name)
        return result


class MovedModule(_LazyDescr):

    def __init__(self, name, old, new=None):
        super(MovedModule, self).__init__(name)
        if PY3:
            if new is None:
                new = name
            self.mod = new
        else:
            self.mod = old

    def _resolve(self):
        return _import_module(self.mod)

    def __getattr__(self, attr):
        # It turns out many Python frameworks like to traverse sys.modules and
        # try to load various attributes. This causes problems if this is a
        # platform-specific module on the wrong platform, like _winreg on
        # Unixes. Therefore, we silently pretend unimportable modules do not
        # have any attributes. See issues #51, #53, #56, and #63 for the full
        # tales of woe.
        #
        # First, if possible, avoid loading the module just to look at __file__,
        # __name__, or __path__.
        if (attr in ("__file__", "__name__", "__path__") and
            self.mod not in sys.modules):
            raise AttributeError(attr)
        try:
            _module = self._resolve()
        except ImportError:
            raise AttributeError(attr)
        value = getattr(_module, attr)
        setattr(self, attr, value)
        return value


class _LazyModule(types.ModuleType):

    def __init__(self, name):
        super(_LazyModule, self).__init__(name)
        self.__doc__ = self.__class__.__doc__

    def __dir__(self):
        attrs = ["__doc__", "__name__"]
        attrs += [attr.name for attr in self._moved_attributes]
        return attrs

    # Subclasses should override this
    _moved_attributes = []


class MovedAttribute(_LazyDescr):

    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
        super(MovedAttribute, self).__init__(name)
        if PY3:
            if new_mod is None:
                new_mod = name
            self.mod = new_mod
            if new_attr is None:
                if old_attr is None:
                    new_attr = name
                else:
                    new_attr = old_attr
            self.attr = new_attr
        else:
            self.mod = old_mod
            if old_attr is None:
                old_attr = name
            self.attr = old_attr

    def _resolve(self):
        module = _import_module(self.mod)
        return getattr(module, self.attr)



class _MovedItems(_LazyModule):
    """Lazy loading of moved objects"""


_moved_attributes = [
    MovedAttribute("cStringIO", "cStringIO", "io", "StringIO"),
    MovedAttribute("filter", "itertools", "builtins", "ifilter", "filter"),
    MovedAttribute("filterfalse", "itertools", "itertools", "ifilterfalse", "filterfalse"),
    MovedAttribute("input", "__builtin__", "builtins", "raw_input", "input"),
    MovedAttribute("map", "itertools", "builtins", "imap", "map"),
    MovedAttribute("range", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("reload_module", "__builtin__", "imp", "reload"),
    MovedAttribute("reduce", "__builtin__", "functools"),
    MovedAttribute("StringIO", "StringIO", "io"),
    MovedAttribute("UserString", "UserString", "collections"),
    MovedAttribute("xrange", "__builtin__", "builtins", "xrange", "range"),
    MovedAttribute("zip", "itertools", "builtins", "izip", "zip"),
    MovedAttribute("zip_longest", "itertools", "itertools", "izip_longest", "zip_longest"),

    MovedModule("builtins", "__builtin__"),
    MovedModule("configparser", "ConfigParser"),
    MovedModule("copyreg", "copy_reg"),
    MovedModule("dbm_gnu", "gdbm", "dbm.gnu"),
    MovedModule("http_cookiejar", "cookielib", "http.cookiejar"),
    MovedModule("http_cookies", "Cookie", "http.cookies"),
    MovedModule("html_entities", "htmlentitydefs", "html.entities"),
    MovedModule("html_parser", "HTMLParser", "html.parser"),
    MovedModule("http_client", "httplib", "http.client"),
    MovedModule("email_mime_multipart", "email.MIMEMultipart", "email.mime.multipart"),
    MovedModule("email_mime_text", "email.MIMEText", "email.mime.text"),
    MovedModule("email_mime_base", "email.MIMEBase", "email.mime.base"),
    MovedModule("BaseHTTPServer", "BaseHTTPServer", "http.server"),
    MovedModule("CGIHTTPServer", "CGIHTTPServer", "http.server"),
    MovedModule("SimpleHTTPServer", "SimpleHTTPServer", "http.server"),
    MovedModule("cPickle", "cPickle", "pickle"),
    MovedModule("queue", "Queue"),
    MovedModule("reprlib", "repr"),
    MovedModule("socketserver", "SocketServer"),
    MovedModule("_thread", "thread", "_thread"),
    MovedModule("tkinter", "Tkinter"),
    MovedModule("tkinter_dialog", "Dialog", "tkinter.dialog"),
    MovedModule("tkinter_filedialog", "FileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_scrolledtext", "ScrolledText", "tkinter.scrolledtext"),
    MovedModule("tkinter_simpledialog", "SimpleDialog", "tkinter.simpledialog"),
    MovedModule("tkinter_tix", "Tix", "tkinter.tix"),
    MovedModule("tkinter_ttk", "ttk", "tkinter.ttk"),
    MovedModule("tkinter_constants", "Tkconstants", "tkinter.constants"),
    MovedModule("tkinter_dnd", "Tkdnd", "tkinter.dnd"),
    MovedModule("tkinter_colorchooser", "tkColorChooser",
                "tkinter.colorchooser"),
    MovedModule("tkinter_commondialog", "tkCommonDialog",
                "tkinter.commondialog"),
    MovedModule("tkinter_tkfiledialog", "tkFileDialog", "tkinter.filedialog"),
    MovedModule("tkinter_font", "tkFont", "tkinter.font"),
    MovedModule("tkinter_messagebox", "tkMessageBox", "tkinter.messagebox"),
    MovedModule("tkinter_tksimpledialog", "tkSimpleDialog",
                "tkinter.simpledialog"),
    MovedModule("urllib_parse", __name__ + ".moves.urllib_parse", "urllib.parse"),
    MovedModule("urllib_error", __name__ + ".moves.urllib_error", "urllib.error"),
    MovedModule("urllib", __name__ + ".moves.urllib", __name__ + ".moves.urllib"),
    MovedModule("urllib_robotparser", "robotparser", "urllib.robotparser"),
    MovedModule("xmlrpc_client", "xmlrpclib", "xmlrpc.client"),
    MovedModule("xmlrpc_server", "xmlrpclib", "xmlrpc.server"),
    MovedModule("winreg", "_winreg"),
]
for attr in _moved_attributes:
    setattr(_MovedItems, attr.name, attr)
    if isinstance(attr, MovedModule):
        sys.modules[__name__ + ".moves." + attr.name] = attr
del attr

_MovedItems._moved_attributes = _moved_attributes

moves = sys.modules[__name__ + ".moves"] = _MovedItems(__name__ + ".moves")


class Module_six_moves_urllib_parse(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_parse"""


_urllib_parse_moved_attributes = [
    MovedAttribute("ParseResult", "urlparse", "urllib.parse"),
    MovedAttribute("SplitResult", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qs", "urlparse", "urllib.parse"),
    MovedAttribute("parse_qsl", "urlparse", "urllib.parse"),
    MovedAttribute("urldefrag", "urlparse", "urllib.parse"),
    MovedAttribute("urljoin", "urlparse", "urllib.parse"),
    MovedAttribute("urlparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlsplit", "urlparse", "urllib.parse"),
    MovedAttribute("urlunparse", "urlparse", "urllib.parse"),
    MovedAttribute("urlunsplit", "urlparse", "urllib.parse"),
    MovedAttribute("quote", "urllib", "urllib.parse"),
    MovedAttribute("quote_plus", "urllib", "urllib.parse"),
    MovedAttribute("unquote", "urllib", "urllib.parse"),
    MovedAttribute("unquote_plus", "urllib", "urllib.parse"),
    MovedAttribute("urlencode", "urllib", "urllib.parse"),
    MovedAttribute("splitquery", "urllib", "urllib.parse"),
]
for attr in _urllib_parse_moved_attributes:
    setattr(Module_six_moves_urllib_parse, attr.name, attr)
del attr

Module_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes

sys.modules[__name__ + ".moves.urllib_parse"] = sys.modules[__name__ + ".moves.urllib.parse"] = Module_six_moves_urllib_parse(__name__ + ".moves.urllib_parse")


class Module_six_moves_urllib_error(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_error"""


_urllib_error_moved_attributes = [
    MovedAttribute("URLError", "urllib2", "urllib.error"),
    MovedAttribute("HTTPError", "urllib2", "urllib.error"),
    MovedAttribute("ContentTooShortError", "urllib", "urllib.error"),
]
for attr in _urllib_error_moved_attributes:
    setattr(Module_six_moves_urllib_error, attr.name, attr)
del attr

Module_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes

sys.modules[__name__ + ".moves.urllib_error"] = sys.modules[__name__ + ".moves.urllib.error"] = Module_six_moves_urllib_error(__name__ + ".moves.urllib.error")


class Module_six_moves_urllib_request(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_request"""


_urllib_request_moved_attributes = [
    MovedAttribute("urlopen", "urllib2", "urllib.request"),
    MovedAttribute("install_opener", "urllib2", "urllib.request"),
    MovedAttribute("build_opener", "urllib2", "urllib.request"),
    MovedAttribute("pathname2url", "urllib", "urllib.request"),
    MovedAttribute("url2pathname", "urllib", "urllib.request"),
    MovedAttribute("getproxies", "urllib", "urllib.request"),
    MovedAttribute("Request", "urllib2", "urllib.request"),
    MovedAttribute("OpenerDirector", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDefaultErrorHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPRedirectHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPCookieProcessor", "urllib2", "urllib.request"),
    MovedAttribute("ProxyHandler", "urllib2", "urllib.request"),
    MovedAttribute("BaseHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgr", "urllib2", "urllib.request"),
    MovedAttribute("HTTPPasswordMgrWithDefaultRealm", "urllib2", "urllib.request"),
    MovedAttribute("AbstractBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyBasicAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("AbstractDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("ProxyDigestAuthHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPSHandler", "urllib2", "urllib.request"),
    MovedAttribute("FileHandler", "urllib2", "urllib.request"),
    MovedAttribute("FTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("CacheFTPHandler", "urllib2", "urllib.request"),
    MovedAttribute("UnknownHandler", "urllib2", "urllib.request"),
    MovedAttribute("HTTPErrorProcessor", "urllib2", "urllib.request"),
    MovedAttribute("urlretrieve", "urllib", "urllib.request"),
    MovedAttribute("urlcleanup", "urllib", "urllib.request"),
    MovedAttribute("URLopener", "urllib", "urllib.request"),
    MovedAttribute("FancyURLopener", "urllib", "urllib.request"),
    MovedAttribute("proxy_bypass", "urllib", "urllib.request"),
]
for attr in _urllib_request_moved_attributes:
    setattr(Module_six_moves_urllib_request, attr.name, attr)
del attr

Module_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes

sys.modules[__name__ + ".moves.urllib_request"] = sys.modules[__name__ + ".moves.urllib.request"] = Module_six_moves_urllib_request(__name__ + ".moves.urllib.request")


class Module_six_moves_urllib_response(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_response"""


_urllib_response_moved_attributes = [
    MovedAttribute("addbase", "urllib", "urllib.response"),
    MovedAttribute("addclosehook", "urllib", "urllib.response"),
    MovedAttribute("addinfo", "urllib", "urllib.response"),
    MovedAttribute("addinfourl", "urllib", "urllib.response"),
]
for attr in _urllib_response_moved_attributes:
    setattr(Module_six_moves_urllib_response, attr.name, attr)
del attr

Module_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes

sys.modules[__name__ + ".moves.urllib_response"] = sys.modules[__name__ + ".moves.urllib.response"] = Module_six_moves_urllib_response(__name__ + ".moves.urllib.response")


class Module_six_moves_urllib_robotparser(_LazyModule):
    """Lazy loading of moved objects in six.moves.urllib_robotparser"""


_urllib_robotparser_moved_attributes = [
    MovedAttribute("RobotFileParser", "robotparser", "urllib.robotparser"),
]
for attr in _urllib_robotparser_moved_attributes:
    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)
del attr

Module_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes

sys.modules[__name__ + ".moves.urllib_robotparser"] = sys.modules[__name__ + ".moves.urllib.robotparser"] = Module_six_moves_urllib_robotparser(__name__ + ".moves.urllib.robotparser")


class Module_six_moves_urllib(types.ModuleType):
    """Create a six.moves.urllib namespace that resembles the Python 3 namespace"""
    parse = sys.modules[__name__ + ".moves.urllib_parse"]
    error = sys.modules[__name__ + ".moves.urllib_error"]
    request = sys.modules[__name__ + ".moves.urllib_request"]
    response = sys.modules[__name__ + ".moves.urllib_response"]
    robotparser = sys.modules[__name__ + ".moves.urllib_robotparser"]

    def __dir__(self):
        return ['parse', 'error', 'request', 'response', 'robotparser']


sys.modules[__name__ + ".moves.urllib"] = Module_six_moves_urllib(__name__ + ".moves.urllib")


def add_move(move):
    """Add an item to six.moves."""
    setattr(_MovedItems, move.name, move)


def remove_move(name):
    """Remove item from six.moves."""
    try:
        delattr(_MovedItems, name)
    except AttributeError:
        try:
            del moves.__dict__[name]
        except KeyError:
            raise AttributeError("no such move, %r" % (name,))


if PY3:
    _meth_func = "__func__"
    _meth_self = "__self__"

    _func_closure = "__closure__"
    _func_code = "__code__"
    _func_defaults = "__defaults__"
    _func_globals = "__globals__"

    _iterkeys = "keys"
    _itervalues = "values"
    _iteritems = "items"
    _iterlists = "lists"
else:
    _meth_func = "im_func"
    _meth_self = "im_self"

    _func_closure = "func_closure"
    _func_code = "func_code"
    _func_defaults = "func_defaults"
    _func_globals = "func_globals"

    _iterkeys = "iterkeys"
    _itervalues = "itervalues"
    _iteritems = "iteritems"
    _iterlists = "iterlists"


try:
    advance_iterator = next
except NameError:
    def advance_iterator(it):
        return it.next()
next = advance_iterator


try:
    callable = callable
except NameError:
    def callable(obj):
        return any("__call__" in klass.__dict__ for klass in type(obj).__mro__)


if PY3:
    def get_unbound_function(unbound):
        return unbound

    create_bound_method = types.MethodType

    Iterator = object
else:
    def get_unbound_function(unbound):
        return unbound.im_func

    def create_bound_method(func, obj):
        return types.MethodType(func, obj, obj.__class__)

    class Iterator(object):

        def next(self):
            return type(self).__next__(self)

    callable = callable
_add_doc(get_unbound_function,
         """Get the function out of a possibly unbound function""")


get_method_function = operator.attrgetter(_meth_func)
get_method_self = operator.attrgetter(_meth_self)
get_function_closure = operator.attrgetter(_func_closure)
get_function_code = operator.attrgetter(_func_code)
get_function_defaults = operator.attrgetter(_func_defaults)
get_function_globals = operator.attrgetter(_func_globals)


def iterkeys(d, **kw):
    """Return an iterator over the keys of a dictionary."""
    return iter(getattr(d, _iterkeys)(**kw))

def itervalues(d, **kw):
    """Return an iterator over the values of a dictionary."""
    return iter(getattr(d, _itervalues)(**kw))

def iteritems(d, **kw):
    """Return an iterator over the (key, value) pairs of a dictionary."""
    return iter(getattr(d, _iteritems)(**kw))

def iterlists(d, **kw):
    """Return an iterator over the (key, [values]) pairs of a dictionary."""
    return iter(getattr(d, _iterlists)(**kw))


if PY3:
    def b(s):
        return s.encode("latin-1")
    def u(s):
        return s
    unichr = chr
    if sys.version_info[1] <= 1:
        def int2byte(i):
            return bytes((i,))
    else:
        # This is about 2x faster than the implementation above on 3.2+
        int2byte = operator.methodcaller("to_bytes", 1, "big")
    byte2int = operator.itemgetter(0)
    indexbytes = operator.getitem
    iterbytes = iter
    import io
    StringIO = io.StringIO
    BytesIO = io.BytesIO
else:
    def b(s):
        return s
    # Workaround for standalone backslash
    def u(s):
        return unicode(s.replace(r'\\', r'\\\\'), "unicode_escape")
    unichr = unichr
    int2byte = chr
    def byte2int(bs):
        return ord(bs[0])
    def indexbytes(buf, i):
        return ord(buf[i])
    def iterbytes(buf):
        return (ord(byte) for byte in buf)
    import StringIO
    StringIO = BytesIO = StringIO.StringIO
_add_doc(b, """Byte literal""")
_add_doc(u, """Text literal""")


if PY3:
    exec_ = getattr(moves.builtins, "exec")


    def reraise(tp, value, tb=None):
        if value.__traceback__ is not tb:
            raise value.with_traceback(tb)
        raise value

else:
    def exec_(_code_, _globs_=None, _locs_=None):
        """Execute code in a namespace."""
        if _globs_ is None:
            frame = sys._getframe(1)
            _globs_ = frame.f_globals
            if _locs_ is None:
                _locs_ = frame.f_locals
            del frame
        elif _locs_ is None:
            _locs_ = _globs_
        exec("""exec _code_ in _globs_, _locs_""")


    exec_("""def reraise(tp, value, tb=None):
    raise tp, value, tb
""")


print_ = getattr(moves.builtins, "print", None)
if print_ is None:
    def print_(*args, **kwargs):
        """The new-style print function for Python 2.4 and 2.5."""
        fp = kwargs.pop("file", sys.stdout)
        if fp is None:
            return
        def write(data):
            if not isinstance(data, basestring):
                data = str(data)
            # If the file has an encoding, encode unicode with it.
            if (isinstance(fp, file) and
                isinstance(data, unicode) and
                fp.encoding is not None):
                errors = getattr(fp, "errors", None)
                if errors is None:
                    errors = "strict"
                data = data.encode(fp.encoding, errors)
            fp.write(data)
        want_unicode = False
        sep = kwargs.pop("sep", None)
        if sep is not None:
            if isinstance(sep, unicode):
                want_unicode = True
            elif not isinstance(sep, str):
                raise TypeError("sep must be None or a string")
        end = kwargs.pop("end", None)
        if end is not None:
            if isinstance(end, unicode):
                want_unicode = True
            elif not isinstance(end, str):
                raise TypeError("end must be None or a string")
        if kwargs:
            raise TypeError("invalid keyword arguments to print()")
        if not want_unicode:
            for arg in args:
                if isinstance(arg, unicode):
                    want_unicode = True
                    break
        if want_unicode:
            newline = unicode("\n")
            space = unicode(" ")
        else:
            newline = "\n"
            space = " "
        if sep is None:
            sep = space
        if end is None:
            end = newline
        for i, arg in enumerate(args):
            if i:
                write(sep)
            write(arg)
        write(end)

_add_doc(reraise, """Reraise an exception.""")


def with_metaclass(meta, *bases):
    """Create a base class with a metaclass."""
    return meta("NewBase", bases, {})

def add_metaclass(metaclass):
    """Class decorator for creating a class with a metaclass."""
    def wrapper(cls):
        orig_vars = cls.__dict__.copy()
        orig_vars.pop('__dict__', None)
        orig_vars.pop('__weakref__', None)
        slots = orig_vars.get('__slots__')
        if slots is not None:
            if isinstance(slots, str):
                slots = [slots]
            for slots_var in slots:
                orig_vars.pop(slots_var)
        return metaclass(cls.__name__, cls.__bases__, orig_vars)
    return wrapper

########NEW FILE########
__FILENAME__ = markers
# -*- coding: utf-8 -*-
"""Interpret PEP 345 environment markers.

EXPR [in|==|!=|not in] EXPR [or|and] ...

where EXPR belongs to any of those:

    python_version = '%s.%s' % (sys.version_info[0], sys.version_info[1])
    python_full_version = sys.version.split()[0]
    os.name = os.name
    sys.platform = sys.platform
    platform.version = platform.version()
    platform.machine = platform.machine()
    platform.python_implementation = platform.python_implementation()
    a free string, like '2.6', or 'win32'
"""

__all__ = ['default_environment', 'compile', 'interpret']

import ast
import os
import platform
import sys
import weakref

_builtin_compile = compile

try:
    from platform import python_implementation
except ImportError:
    if os.name == "java":
        # Jython 2.5 has ast module, but not platform.python_implementation() function.
        def python_implementation():
            return "Jython"
    else:
        raise


# restricted set of variables
_VARS = {'sys.platform': sys.platform,
         'python_version': '%s.%s' % sys.version_info[:2],
         # FIXME parsing sys.platform is not reliable, but there is no other
         # way to get e.g. 2.7.2+, and the PEP is defined with sys.version
         'python_full_version': sys.version.split(' ', 1)[0],
         'os.name': os.name,
         'platform.version': platform.version(),
         'platform.machine': platform.machine(),
         'platform.python_implementation': python_implementation(),
         'extra': None # wheel extension
        }

for var in list(_VARS.keys()):
    if '.' in var:
        _VARS[var.replace('.', '_')] = _VARS[var]

def default_environment():
    """Return copy of default PEP 385 globals dictionary."""
    return dict(_VARS)

class ASTWhitelist(ast.NodeTransformer):
    def __init__(self, statement):
        self.statement = statement # for error messages

    ALLOWED = (ast.Compare, ast.BoolOp, ast.Attribute, ast.Name, ast.Load, ast.Str)
    # Bool operations
    ALLOWED += (ast.And, ast.Or)
    # Comparison operations
    ALLOWED += (ast.Eq, ast.Gt, ast.GtE, ast.In, ast.Is, ast.IsNot, ast.Lt, ast.LtE, ast.NotEq, ast.NotIn)

    def visit(self, node):
        """Ensure statement only contains allowed nodes."""
        if not isinstance(node, self.ALLOWED):
            raise SyntaxError('Not allowed in environment markers.\n%s\n%s' %
                               (self.statement,
                               (' ' * node.col_offset) + '^'))
        return ast.NodeTransformer.visit(self, node)

    def visit_Attribute(self, node):
        """Flatten one level of attribute access."""
        new_node = ast.Name("%s.%s" % (node.value.id, node.attr), node.ctx)
        return ast.copy_location(new_node, node)

def parse_marker(marker):
    tree = ast.parse(marker, mode='eval')
    new_tree = ASTWhitelist(marker).generic_visit(tree)
    return new_tree

def compile_marker(parsed_marker):
    return _builtin_compile(parsed_marker, '<environment marker>', 'eval',
                   dont_inherit=True)

_cache = weakref.WeakValueDictionary()

def compile(marker):
    """Return compiled marker as a function accepting an environment dict."""
    try:
        return _cache[marker]
    except KeyError:
        pass
    if not marker.strip():
        def marker_fn(environment=None, override=None):
            """"""
            return True
    else:
        compiled_marker = compile_marker(parse_marker(marker))
        def marker_fn(environment=None, override=None):
            """override updates environment"""
            if override is None:
                override = {}
            if environment is None:
                environment = default_environment()
            environment.update(override)
            return eval(compiled_marker, environment)
    marker_fn.__doc__ = marker
    _cache[marker] = marker_fn
    return _cache[marker]

def interpret(marker, environment=None):
    return compile(marker)(environment)

########NEW FILE########
__FILENAME__ = __main__
import sys

# If we are running from a wheel, add the wheel to sys.path
# This allows the usage python pip-*.whl/pip install pip-*.whl
if __package__ == '':
    import os
    # __file__ is pip-*.whl/pip/__main__.py
    # first dirname call strips of '/__main__.py', second strips off '/pip'
    # Resulting path is the name of the wheel itself
    # Add that to sys.path so we can import pip
    path = os.path.dirname(os.path.dirname(__file__))
    sys.path.insert(0, path)

import pip

if __name__ == '__main__':
    sys.exit(pip.main())

########NEW FILE########
__FILENAME__ = generate
import base64
import io
import os
import shutil
import tempfile
import zipfile

import invoke

from . import paths


@invoke.task
def authors():
    print("[generate.authors] Generating AUTHORS")

    # Get our list of authors
    print("[generate.authors] Collecting author names")
    r = invoke.run("git log --use-mailmap --format'=%aN <%aE>'", hide=True)
    authors = []
    seen_authors = set()
    for author in r.stdout.splitlines():
        author = author.strip()
        if author.lower() not in seen_authors:
            seen_authors.add(author.lower())
            authors.append(author)

    # Sort our list of Authors by their case insensitive name
    authors = sorted(authors, key=lambda x: x.lower())

    # Write our authors to the AUTHORS file
    print("[generate.authors] Writing AUTHORS")
    with io.open("AUTHORS.txt", "w", encoding="utf8") as fp:
        fp.write(u"\n".join(authors))
        fp.write(u"\n")


@invoke.task
def installer(installer_path=os.path.join(paths.CONTRIB, "get-pip.py")):
    print("[generate.installer] Generating installer")

    # Define our wrapper script
    WRAPPER_SCRIPT = """
#!/usr/bin/env python
#
# Hi There!
# You may be wondering what this giant blob of binary data here is, you might
# even be worried that we're up to something nefarious (good for you for being
# paranoid!). This is a base64 encoding of a zip file, this zip file contains
# an entire copy of pip.
#
# Pip is a thing that installs packages, pip itself is a package that someone
# might want to install, especially if they're looking to run this get-pip.py
# script. Pip has a lot of code to deal with the security of installing
# packages, various edge cases on various platforms, and other such sort of
# "tribal knowledge" that has been encoded in its code base. Because of this
# we basically include an entire copy of pip inside this blob. We do this
# because the alternatives are attempt to implement a "minipip" that probably
# doesn't do things correctly and has weird edge cases, or compress pip itself
# down into a single file.
#
# If you're wondering how this is created, it is using an invoke task located
# in tasks/generate.py called "installer". It can be invoked by using
# ``invoke generate.installer``.

import os.path
import pkgutil
import shutil
import sys
import struct
import tempfile

# Useful for very coarse version differentiation.
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3

if PY3:
    iterbytes = iter
else:
    def iterbytes(buf):
        return (ord(byte) for byte in buf)

try:
    from base64 import b85decode
except ImportError:
    _b85alphabet = (b"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                    b"abcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{{|}}~")

    def b85decode(b):
        _b85dec = [None] * 256
        for i, c in enumerate(iterbytes(_b85alphabet)):
            _b85dec[c] = i

        padding = (-len(b)) % 5
        b = b + b'~' * padding
        out = []
        packI = struct.Struct('!I').pack
        for i in range(0, len(b), 5):
            chunk = b[i:i + 5]
            acc = 0
            try:
                for c in iterbytes(chunk):
                    acc = acc * 85 + _b85dec[c]
            except TypeError:
                for j, c in enumerate(iterbytes(chunk)):
                    if _b85dec[c] is None:
                        raise ValueError('bad base85 character at position %d'
                                        % (i + j))
                raise
            try:
                out.append(packI(acc))
            except struct.error:
                raise ValueError('base85 overflow in hunk starting at byte %d'
                                 % i)

        result = b''.join(out)
        if padding:
            result = result[:-padding]
        return result


def bootstrap(tmpdir=None):
    # Import pip so we can use it to install pip and maybe setuptools too
    import pip

    # We always want to install pip
    packages = ["pip"]

    # Check if the user has requested us not to install setuptools
    if "--no-setuptools" in sys.argv or os.environ.get("PIP_NO_SETUPTOOLS"):
        args = [x for x in sys.argv[1:] if x != "--no-setuptools"]
    else:
        args = sys.argv[1:]

        # We want to see if setuptools is available before attempting to
        # install it
        try:
            import setuptools  # noqa
        except ImportError:
            packages += ["setuptools"]

    delete_tmpdir = False
    try:
        # Create a temporary directory to act as a working directory if we were
        # not given one.
        if tmpdir is None:
            tmpdir = tempfile.mkdtemp()
            delete_tmpdir = True

        # We need to extract the SSL certificates from requests so that they
        # can be passed to --cert
        cert_path = os.path.join(tmpdir, "cacert.pem")
        with open(cert_path, "wb") as cert:
            cert.write(pkgutil.get_data("pip._vendor.requests", "cacert.pem"))

        # Use an environment variable here so that users can still pass
        # --cert via sys.argv
        os.environ.setdefault("PIP_CERT", cert_path)

        # Execute the included pip and use it to install the latest pip and
        # setuptools from PyPI
        sys.exit(pip.main(["install", "--upgrade"] + packages + args))
    finally:
        # Remove our temporary directory
        if delete_tmpdir and tmpdir:
            shutil.rmtree(tmpdir, ignore_errors=True)


def main():
    tmpdir = None
    try:
        # Create a temporary working directory
        tmpdir = tempfile.mkdtemp()

        # Unpack the zipfile into the temporary directory
        pip_zip = os.path.join(tmpdir, "pip.zip")
        with open(pip_zip, "wb") as fp:
            fp.write(b85decode(DATA.replace(b"\\n", b"")))

        # Add the zipfile to sys.path so that we can import it
        sys.path.insert(0, pip_zip)

        # Run the bootstrap
        bootstrap(tmpdir=tmpdir)
    finally:
        # Clean up our temporary working directory
        if tmpdir:
            shutil.rmtree(tmpdir, ignore_errors=True)


DATA = b\"\"\"
{zipfile}
\"\"\"


if __name__ == "__main__":
    main()
""".lstrip()

    # Get all of the files we want to add to the zip file
    print("[generate.installer] Collect all the files that should be zipped")
    all_files = []
    for root, dirs, files in os.walk(os.path.join(paths.PROJECT_ROOT, "pip")):
        for pyfile in files:
            if os.path.splitext(pyfile)[1] in {".py", ".pem", ".cfg", ".exe"}:
                path = os.path.join(root, pyfile)
                all_files.append(
                    "/".join(
                        path.split("/")[len(paths.PROJECT_ROOT.split("/")):]
                    )
                )

    tmpdir = tempfile.mkdtemp()
    try:
        # Get a temporary path to use as staging for the pip zip
        zpth = os.path.join(tmpdir, "pip.zip")

        # Write the pip files to the zip archive
        print("[generate.installer] Generate the bundled zip of pip")
        with zipfile.ZipFile(zpth, "w", compression=zipfile.ZIP_DEFLATED) as z:
            for filename in all_files:
                z.write(os.path.join(paths.PROJECT_ROOT, filename), filename)

        # Get the binary data that compromises our zip file
        with open(zpth, "rb") as fp:
            data = fp.read()
    finally:
        shutil.rmtree(tmpdir, ignore_errors=True)

    # Write out the wrapper script that will take the place of the zip script
    # The reason we need to do this instead of just directly executing the
    # zip script is that while Python will happily execute a zip script if
    # passed it on the file system, it will not however allow this to work if
    # passed it via stdin. This means that this wrapper script is required to
    # make ``curl https://...../get-pip.py | python`` continue to work.
    print(
        "[generate.installer] Write the wrapper script with the bundled zip "
        "file"
    )

    zipdata = base64.b85encode(data).decode("utf8")
    chunked = []

    for i in range(0, len(zipdata), 79):
        chunked.append(zipdata[i:i + 79])

    with open(installer_path, "w") as fp:
        fp.write(WRAPPER_SCRIPT.format(zipfile="\n".join(chunked)))

    # Ensure the permissions on the newly created file
    oldmode = os.stat(installer_path).st_mode & 0o7777
    newmode = (oldmode | 0o555) & 0o7777
    os.chmod(installer_path, newmode)

    print("[generate.installer] Generated installer")

########NEW FILE########
__FILENAME__ = paths
import os.path

PROJECT_ROOT = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))

CONTRIB = os.path.join(PROJECT_ROOT, "contrib")

########NEW FILE########
__FILENAME__ = conftest
import os
import shutil

import py
import pytest

from tests.lib import SRC_DIR, TestData
from tests.lib.path import Path
from tests.lib.scripttest import PipTestEnvironment
from tests.lib.venv import VirtualEnvironment


@pytest.fixture
def tmpdir(request):
    """
    Return a temporary directory path object which is unique to each test
    function invocation, created as a sub directory of the base temporary
    directory. The returned object is a ``tests.lib.path.Path`` object.

    This is taken from pytest itself but modified to return our typical
    path object instead of py.path.local as well as deleting the temporary
    directories at the end of each test case.
    """
    name = request.node.name
    name = py.std.re.sub("[\W]", "_", name)
    tmp = request.config._tmpdirhandler.mktemp(name, numbered=True)

    # Clear out the temporary directory after the test has finished using it.
    # This should prevent us from needing a multiple gigabyte temporary
    # directory while running the tests.
    request.addfinalizer(lambda: shutil.rmtree(str(tmp), ignore_errors=True))

    return Path(str(tmp))


@pytest.fixture(autouse=True)
def isolate(tmpdir):
    """
    Isolate our tests so that things like global configuration files and the
    like do not affect our test results.

    We use an autouse function scoped fixture because we want to ensure that
    every test has it's own isolated home directory.
    """
    # TODO: Ensure Windows will respect $HOME, including for the cache
    #       directory

    # TODO: Figure out how to isolate from *system* level configuration files
    #       as well as user level configuration files.

    # Create a directory to use as our home location.
    home_dir = os.path.join(str(tmpdir), "home")
    os.makedirs(home_dir)

    # Create a directory to use as a fake root
    fake_root = os.path.join(str(tmpdir), "fake-root")
    os.makedirs(fake_root)

    # Set our home directory to our temporary directory, this should force all
    # of our relative configuration files to be read from here instead of the
    # user's actual $HOME directory.
    os.environ["HOME"] = home_dir

    # Isolate ourselves from XDG directories
    os.environ["XDG_DATA_HOME"] = os.path.join(home_dir, ".local", "share")
    os.environ["XDG_CONFIG_HOME"] = os.path.join(home_dir, ".config")
    os.environ["XDG_CACHE_HOME"] = os.path.join(home_dir, ".cache")
    os.environ["XDG_RUNTIME_DIR"] = os.path.join(home_dir, ".runtime")
    os.environ["XDG_DATA_DIRS"] = ":".join([
        os.path.join(fake_root, "usr", "local", "share"),
        os.path.join(fake_root, "usr", "share"),
    ])
    os.environ["XDG_CONFIG_DIRS"] = os.path.join(fake_root, "etc", "xdg")

    # Configure git, because without an author name/email git will complain
    # and cause test failures.
    os.environ["GIT_CONFIG_NOSYSTEM"] = "1"
    os.environ["GIT_AUTHOR_NAME"] = "pip"
    os.environ["GIT_AUTHOR_EMAIL"] = "pypa-dev@googlegroups.com"

    os.makedirs(os.path.join(home_dir, ".config", "git"))
    with open(os.path.join(home_dir, ".config", "git", "config"), "wb") as fp:
        fp.write(
            b"[user]\n\tname = pip\n\temail = pypa-dev@googlegroups.com\n"
        )


@pytest.fixture
def virtualenv(tmpdir, monkeypatch):
    """
    Return a virtual environment which is unique to each test function
    invocation created inside of a sub directory of the test function's
    temporary directory. The returned object is a
    ``tests.lib.venv.VirtualEnvironment`` object.
    """
    # Force shutil to use the older method of rmtree that didn't use the fd
    # functions. These seem to fail on Travis (and only on Travis).
    monkeypatch.setattr(shutil, "_use_fd_functions", False, raising=False)

    # Copy over our source tree so that each virtual environment is self
    # contained
    pip_src = tmpdir.join("pip_src").abspath
    shutil.copytree(
        SRC_DIR,
        pip_src,
        ignore=shutil.ignore_patterns(
            "*.pyc", "tests", "pip.egg-info", "build", "dist", ".tox",
        ),
    )

    # Create the virtual environment
    venv = VirtualEnvironment.create(
        tmpdir.join("workspace", "venv"),
        pip_source_dir=pip_src,
    )

    # Undo our monkeypatching of shutil
    monkeypatch.undo()

    return venv


@pytest.fixture
def script(tmpdir, virtualenv):
    """
    Return a PipTestEnvironment which is unique to each test function and
    will execute all commands inside of the unique virtual environment for this
    test function. The returned object is a
    ``tests.lib.scripttest.PipTestEnvironment``.
    """
    return PipTestEnvironment(
        # The base location for our test environment
        tmpdir.join("workspace"),

        # Tell the Test Environment where our virtualenv is located
        virtualenv=virtualenv.location,

        # Do not ignore hidden files, they need to be checked as well
        ignore_hidden=False,

        # We are starting with an already empty directory
        start_clear=False,

        # We want to ensure no temporary files are left behind, so the
        # PipTestEnvironment needs to capture and assert against temp
        capture_temp=True,
        assert_no_temp=True,
    )


@pytest.fixture
def data(tmpdir):
    return TestData.copy(tmpdir.join("data"))

########NEW FILE########
__FILENAME__ = broken

########NEW FILE########
__FILENAME__ = test_completion
import os


def test_completion_for_bash(script):
    """
    Test getting completion for bash shell
    """
    bash_completion = """\
_pip_completion()
{
    COMPREPLY=( $( COMP_WORDS="${COMP_WORDS[*]}" \\
                   COMP_CWORD=$COMP_CWORD \\
                   PIP_AUTO_COMPLETE=1 $1 ) )
}
complete -o default -F _pip_completion pip"""

    result = script.pip('completion', '--bash')
    assert bash_completion in result.stdout, 'bash completion is wrong'


def test_completion_for_zsh(script):
    """
    Test getting completion for zsh shell
    """
    zsh_completion = """\
function _pip_completion {
  local words cword
  read -Ac words
  read -cn cword
  reply=( $( COMP_WORDS="$words[*]" \\
             COMP_CWORD=$(( cword-1 )) \\
             PIP_AUTO_COMPLETE=1 $words[1] ) )
}
compctl -K _pip_completion pip"""

    result = script.pip('completion', '--zsh')
    assert zsh_completion in result.stdout, 'zsh completion is wrong'


def test_completion_for_unknown_shell(script):
    """
    Test getting completion for an unknown shell
    """
    error_msg = 'no such option: --myfooshell'
    result = script.pip('completion', '--myfooshell', expect_error=True)
    assert error_msg in result.stderr, 'tests for an unknown shell failed'


def test_completion_alone(script):
    """
    Test getting completion for none shell, just pip completion
    """
    result = script.pip('completion', expect_error=True)
    assert 'ERROR: You must pass --bash or --zsh' in result.stderr, \
           'completion alone failed -- ' + result.stderr


def setup_completion(script, words, cword):
    script.environ = os.environ.copy()
    script.environ['PIP_AUTO_COMPLETE'] = '1'
    script.environ['COMP_WORDS'] = words
    script.environ['COMP_CWORD'] = cword

    # expect_error is True because autocomplete exists with 1 status code
    result = script.run(
        'python', '-c', 'import pip;pip.autocomplete()',
        expect_error=True,
    )

    return result, script


def test_completion_for_un_snippet(script):
    """
    Test getting completion for ``un`` should return
    uninstall and unzip
    """

    res, env = setup_completion(script, 'pip un', '1')
    assert res.stdout.strip().split() == ['uninstall', 'unzip'], res.stdout


def test_completion_for_default_parameters(script):
    """
    Test getting completion for ``--`` should contain --help
    """

    res, env = setup_completion(script, 'pip --', '1')
    assert '--help' in res.stdout,\
           "autocomplete function could not complete ``--``"


def test_completion_option_for_command(script):
    """
    Test getting completion for ``--`` in command (eg. pip search --)
    """

    res, env = setup_completion(script, 'pip search --', '2')
    assert '--help' in res.stdout,\
           "autocomplete function could not complete ``--``"

########NEW FILE########
__FILENAME__ = test_freeze
import sys
import re
import textwrap
from doctest import OutputChecker, ELLIPSIS

from tests.lib.local_repos import local_checkout, local_repo


distribute_re = re.compile('^distribute==[0-9.]+\n', re.MULTILINE)


def _check_output(result, expected):
    checker = OutputChecker()
    actual = str(result)

    # FIXME!  The following is a TOTAL hack.  For some reason the
    # __str__ result for pkg_resources.Requirement gets downcased on
    # Windows.  Since INITools is the only package we're installing
    # in this file with funky case requirements, I'm forcibly
    # upcasing it.  You can also normalize everything to lowercase,
    # but then you have to remember to upcase <BLANKLINE>.  The right
    # thing to do in the end is probably to find out how to report
    # the proper fully-cased package name in our error message.
    if sys.platform == 'win32':
        actual = actual.replace('initools', 'INITools')

    # This allows our existing tests to work when run in a context
    # with distribute installed.
    actual = distribute_re.sub('', actual)

    def banner(msg):
        return '\n========== %s ==========\n' % msg

    assert checker.check_output(expected, actual, ELLIPSIS), (
        banner('EXPECTED') + expected + banner('ACTUAL') + actual +
        banner(6 * '=')
    )


def test_freeze_basic(script):
    """
    Some tests of freeze, first we have to install some stuff.  Note that
    the test is a little crude at the end because Python 2.5+ adds egg
    info to the standard library, so stuff like wsgiref will show up in
    the freezing.  (Probably that should be accounted for in pip, but
    currently it is not).

    """
    script.scratch_path.join("initools-req.txt").write(textwrap.dedent("""\
        simple==2.0
        # and something else to test out:
        simple2<=3.0
        """))
    script.pip_install_local(
        '-r', script.scratch_path / 'initools-req.txt',
    )
    result = script.pip('freeze', expect_stderr=True)
    expected = textwrap.dedent("""\
        Script result: pip freeze
        -- stdout: --------------------
        ...simple==2.0
        simple2==3.0...
        <BLANKLINE>""")
    _check_output(result, expected)


def test_freeze_svn(script, tmpdir):
    """Test freezing a svn checkout"""

    checkout_path = local_checkout(
        'svn+http://svn.colorstudy.com/INITools/trunk',
        tmpdir.join("cache"),
    )
    # svn internally stores windows drives as uppercase; we'll match that.
    checkout_path = checkout_path.replace('c:', 'C:')

    # Checkout
    script.run(
        'svn', 'co', '-r10',
        local_repo(
            'svn+http://svn.colorstudy.com/INITools/trunk',
            tmpdir.join("cache"),
        ),
        'initools-trunk',
    )
    # Install with develop
    script.run(
        'python', 'setup.py', 'develop',
        cwd=script.scratch_path / 'initools-trunk',
        expect_stderr=True,
    )
    result = script.pip('freeze', expect_stderr=True)

    expected = textwrap.dedent("""\
        Script result: pip freeze
        -- stdout: --------------------
        ...-e %s@10#egg=INITools-0.3.1dev...-dev_r10
        ...""" % checkout_path)
    _check_output(result, expected)


def test_freeze_git_clone(script, tmpdir):
    """
    Test freezing a Git clone.
    """
    result = script.run(
        'git',
        'clone',
        local_repo(
            'git+http://github.com/pypa/pip-test-package.git',
            tmpdir.join("cache"),
        ),
        'pip-test-package',
        expect_stderr=True,
    )
    result = script.run(
        'git',
        'checkout',
        '7d654e66c8fa7149c165ddeffa5b56bc06619458',
        cwd=script.scratch_path / 'pip-test-package',
        expect_stderr=True,
    )
    result = script.run(
        'python', 'setup.py', 'develop',
        cwd=script.scratch_path / 'pip-test-package'
    )
    result = script.pip('freeze', expect_stderr=True)
    expected = textwrap.dedent(
        """
            Script result: ...pip freeze
            -- stdout: --------------------
            ...-e %s@...#egg=pip_test_package-...
            ...
        """ %
        local_checkout(
            'git+http://github.com/pypa/pip-test-package.git',
            tmpdir.join("cache"),
        )
    ).strip()
    _check_output(result, expected)

    result = script.pip(
        'freeze', '-f',
        '%s#egg=pip_test_package' %
        local_checkout(
            'git+http://github.com/pypa/pip-test-package.git',
            tmpdir.join("cache"),
        ),
        expect_stderr=True,
    )
    expected = textwrap.dedent(
        """
            Script result: pip freeze -f %(repo)s#egg=pip_test_package
            -- stdout: --------------------
            -f %(repo)s#egg=pip_test_package...
            -e %(repo)s@...#egg=pip_test_package-0.1.1
            ...
        """ %
        {
            'repo': local_checkout(
                'git+http://github.com/pypa/pip-test-package.git',
                tmpdir.join("cache"),
            ),
        },
    ).strip()
    _check_output(result, expected)


def test_freeze_mercurial_clone(script, tmpdir):
    """
    Test freezing a Mercurial clone.

    """
    result = script.run(
        'hg', 'clone',
        '-r', 'c9963c111e7c',
        local_repo(
            'hg+http://bitbucket.org/pypa/pip-test-package',
            tmpdir.join("cache"),
        ),
        'pip-test-package',
    )
    result = script.run(
        'python', 'setup.py', 'develop',
        cwd=script.scratch_path / 'pip-test-package',
        expect_stderr=True,
    )
    result = script.pip('freeze', expect_stderr=True)
    expected = textwrap.dedent(
        """
            Script result: ...pip freeze
            -- stdout: --------------------
            ...-e %s@...#egg=pip_test_package-...
            ...
        """ %
        local_checkout(
            'hg+http://bitbucket.org/pypa/pip-test-package',
            tmpdir.join("cache"),
        ),
    ).strip()
    _check_output(result, expected)

    result = script.pip(
        'freeze', '-f',
        '%s#egg=pip_test_package' %
        local_checkout(
            'hg+http://bitbucket.org/pypa/pip-test-package',
            tmpdir.join("cache"),
        ),
        expect_stderr=True,
    )
    expected = textwrap.dedent(
        """
            Script result: ...pip freeze -f %(repo)s#egg=pip_test_package
            -- stdout: --------------------
            -f %(repo)s#egg=pip_test_package
            ...-e %(repo)s@...#egg=pip_test_package-dev
            ...
        """ %
        {
            'repo': local_checkout(
                'hg+http://bitbucket.org/pypa/pip-test-package',
                tmpdir.join("cache"),
            ),
        },
    ).strip()
    _check_output(result, expected)


def test_freeze_bazaar_clone(script, tmpdir):
    """
    Test freezing a Bazaar clone.

    """

    checkout_path = local_checkout(
        'bzr+http://bazaar.launchpad.net/%7Edjango-wikiapp/django-wikiapp/'
        'release-0.1',
        tmpdir.join("cache"),
    )
    # bzr internally stores windows drives as uppercase; we'll match that.
    checkout_pathC = checkout_path.replace('c:', 'C:')

    result = script.run(
        'bzr', 'checkout', '-r', '174',
        local_repo(
            'bzr+http://bazaar.launchpad.net/%7Edjango-wikiapp/django-wikiapp/'
            'release-0.1',
            tmpdir.join("cache"),
        ),
        'django-wikiapp',
    )
    result = script.run(
        'python', 'setup.py', 'develop',
        cwd=script.scratch_path / 'django-wikiapp',
    )
    result = script.pip('freeze', expect_stderr=True)
    expected = textwrap.dedent("""\
        Script result: ...pip freeze
        -- stdout: --------------------
        ...-e %s@...#egg=django_wikiapp-...
        ...""" % checkout_pathC)
    _check_output(result, expected)

    result = script.pip(
        'freeze', '-f',
        '%s/#egg=django-wikiapp' % checkout_path,
        expect_stderr=True,
    )
    expected = textwrap.dedent("""\
        Script result: ...pip freeze -f %(repo)s/#egg=django-wikiapp
        -- stdout: --------------------
        -f %(repo)s/#egg=django-wikiapp
        ...-e %(repoC)s@...#egg=django_wikiapp-...
        ...""" % {'repoC': checkout_pathC, 'repo': checkout_path})
    _check_output(result, expected)


def test_freeze_with_local_option(script):
    """
    Test that wsgiref (from global site-packages) is reported normally, but not
    with --local.
    """
    result = script.pip('install', 'initools==0.2')
    result = script.pip('freeze', expect_stderr=True)
    expected = textwrap.dedent("""\
        Script result: ...pip freeze
        -- stdout: --------------------
        INITools==0.2
        wsgiref==...
        <BLANKLINE>""")

    # The following check is broken (see
    # http://bitbucket.org/ianb/pip/issue/110).  For now we are simply
    # neutering this test, but if we can't find a way to fix it,
    # this whole function should be removed.

    # _check_output(result, expected)

    result = script.pip('freeze', '--local', expect_stderr=True)
    expected = textwrap.dedent("""\
        Script result: ...pip freeze --local
        -- stdout: --------------------
        INITools==0.2
        <BLANKLINE>""")
    _check_output(result, expected)


def test_freeze_with_requirement_option(script):
    """
    Test that new requirements are created correctly with --requirement hints

    """
    ignores = textwrap.dedent("""\
        # Unchanged requirements below this line
        -r ignore.txt
        --requirement ignore.txt
        -Z ignore
        --always-unzip ignore
        -f http://ignore
        -i http://ignore
        --extra-index-url http://ignore
        --find-links http://ignore
        --index-url http://ignore
        """)
    script.scratch_path.join("hint.txt").write(textwrap.dedent("""\
        INITools==0.1
        NoExist==4.2
        """) + ignores)
    result = script.pip('install', 'initools==0.2')
    result = script.pip_install_local('simple')
    result = script.pip(
        'freeze', '--requirement', 'hint.txt',
        expect_stderr=True,
    )
    expected = """\
Script result: pip freeze --requirement hint.txt
-- stderr: --------------------
Requirement file contains NoExist==4.2, but that package is not installed

-- stdout: --------------------
INITools==0.2
""" + ignores + "## The following requirements were added by pip --freeze:..."
    _check_output(result, expected)

########NEW FILE########
__FILENAME__ = test_help
import pytest

from pip.exceptions import CommandError
from pip.basecommand import ERROR, SUCCESS
from pip.commands.help import HelpCommand
from pip.commands import commands
from mock import Mock


def test_run_method_should_return_sucess_when_finds_command_name():
    """
    Test HelpCommand.run for existing command
    """
    options_mock = Mock()
    args = ('freeze',)
    help_cmd = HelpCommand()
    status = help_cmd.run(options_mock, args)
    assert status == SUCCESS


def test_run_method_should_return_sucess_when_command_name_not_specified():
    """
    Test HelpCommand.run when there are no args
    """
    options_mock = Mock()
    args = ()
    help_cmd = HelpCommand()
    status = help_cmd.run(options_mock, args)
    assert status == SUCCESS


def test_run_method_should_raise_command_error_when_command_does_not_exist():
    """
    Test HelpCommand.run for non-existing command
    """
    options_mock = Mock()
    args = ('mycommand',)
    help_cmd = HelpCommand()

    with pytest.raises(CommandError):
        help_cmd.run(options_mock, args)


def test_help_command_should_exit_status_ok_when_command_exists(script):
    """
    Test `help` command for existing command
    """
    result = script.pip('help', 'freeze')
    assert result.returncode == SUCCESS


def test_help_command_should_exit_status_ok_when_no_cmd_is_specified(script):
    """
    Test `help` command for no command
    """
    result = script.pip('help')
    assert result.returncode == SUCCESS


def test_help_command_should_exit_status_error_when_cmd_does_not_exist(script):
    """
    Test `help` command for non-existing command
    """
    result = script.pip('help', 'mycommand', expect_error=True)
    assert result.returncode == ERROR


def test_help_commands_equally_functional(script):
    """
    Test if `pip help` and 'pip --help' behave the same way.
    """
    results = list(map(script.pip, ('help', '--help')))
    results.append(script.pip())

    out = map(lambda x: x.stdout, results)
    ret = map(lambda x: x.returncode, results)

    msg = '"pip --help" != "pip help" != "pip"'
    assert len(set(out)) == 1, 'output of: ' + msg
    assert sum(ret) == 0, 'exit codes of: ' + msg

    for name, cls in commands.items():
        if cls.hidden:
            continue

        assert (
            script.pip('help', name).stdout
            == script.pip(name, '--help').stdout
        )

########NEW FILE########
__FILENAME__ = test_install
import os
import textwrap
import glob

from os.path import join, curdir, pardir

import pytest

from pip.util import rmtree
from tests.lib import pyversion
from tests.lib.local_repos import local_checkout
from tests.lib.path import Path


def test_without_setuptools(script):
    script.run("pip", "uninstall", "setuptools", "-y")
    result = script.run(
        "python", "-c",
        "import pip; pip.main(['install', 'INITools==0.2', '--no-use-wheel'])",
        expect_error=True,
    )
    assert (
        "setuptools must be installed to install from a source distribution"
        in result.stdout
    )


def test_pip_second_command_line_interface_works(script):
    """
    Check if ``pip<PYVERSION>`` commands behaves equally
    """
    args = ['pip%s' % pyversion]
    args.extend(['install', 'INITools==0.2'])
    result = script.run(*args)
    egg_info_folder = (
        script.site_packages / 'INITools-0.2-py%s.egg-info' % pyversion
    )
    initools_folder = script.site_packages / 'initools'
    assert egg_info_folder in result.files_created, str(result)
    assert initools_folder in result.files_created, str(result)


def test_install_from_pypi(script):
    """
    Test installing a package from PyPI.
    """
    result = script.pip('install', '-vvv', 'INITools==0.2')
    egg_info_folder = (
        script.site_packages / 'INITools-0.2-py%s.egg-info' % pyversion
    )
    initools_folder = script.site_packages / 'initools'
    assert egg_info_folder in result.files_created, str(result)
    assert initools_folder in result.files_created, str(result)


def test_editable_install(script):
    """
    Test editable installation.
    """
    result = script.pip('install', '-e', 'INITools==0.2', expect_error=True)
    assert (
        "INITools==0.2 should either be a path to a local project or a VCS url"
        in result.stdout
    )
    assert len(result.files_created) == 1, result.files_created
    assert not result.files_updated, result.files_updated


def test_install_editable_from_svn(script, tmpdir):
    """
    Test checking out from svn.
    """
    result = script.pip(
        'install',
        '-e',
        '%s#egg=initools-dev' %
        local_checkout(
            'svn+http://svn.colorstudy.com/INITools/trunk',
            tmpdir.join("cache")
        )
    )
    result.assert_installed('INITools', with_files=['.svn'])


def test_download_editable_to_custom_path(script, tmpdir):
    """
    Test downloading an editable using a relative custom src folder.
    """
    script.scratch_path.join("customdl").mkdir()
    result = script.pip(
        'install',
        '-e',
        '%s#egg=initools-dev' %
        local_checkout(
            'svn+http://svn.colorstudy.com/INITools/trunk',
            tmpdir.join("cache")
        ),
        '--src',
        'customsrc',
        '--download',
        'customdl',
    )
    customsrc = Path('scratch') / 'customsrc' / 'initools'
    assert customsrc in result.files_created, (
        sorted(result.files_created.keys())
    )
    assert customsrc / 'setup.py' in result.files_created, (
        sorted(result.files_created.keys())
    )

    customdl = Path('scratch') / 'customdl' / 'initools'
    customdl_files_created = [
        filename for filename in result.files_created
        if filename.startswith(customdl)
    ]
    assert customdl_files_created


def test_editable_no_install_followed_by_no_download(script, tmpdir):
    """
    Test installing an editable in two steps (first with --no-install, then
    with --no-download).
    """
    result = script.pip(
        'install',
        '-e',
        '%s#egg=initools-dev' %
        local_checkout(
            'svn+http://svn.colorstudy.com/INITools/trunk',
            tmpdir.join("cache"),
        ),
        '--no-install',
        expect_error=True,
    )
    result.assert_installed(
        'INITools', without_egg_link=True, with_files=['.svn'],
    )

    result = script.pip(
        'install',
        '-e',
        '%s#egg=initools-dev' %
        local_checkout(
            'svn+http://svn.colorstudy.com/INITools/trunk',
            tmpdir.join("cache"),
        ),
        '--no-download',
        expect_error=True,
    )
    result.assert_installed('INITools', without_files=[curdir, '.svn'])


def test_no_install_followed_by_no_download(script):
    """
    Test installing in two steps (first with --no-install, then with
    --no-download).
    """
    egg_info_folder = (
        script.site_packages / 'INITools-0.2-py%s.egg-info' % pyversion
    )
    initools_folder = script.site_packages / 'initools'
    build_dir = script.venv / 'build' / 'INITools'

    result1 = script.pip(
        'install', 'INITools==0.2', '--no-install', expect_error=True,
    )
    assert egg_info_folder not in result1.files_created, str(result1)
    assert initools_folder not in result1.files_created, (
        sorted(result1.files_created)
    )
    assert build_dir in result1.files_created, result1.files_created
    assert build_dir / 'INITools.egg-info' in result1.files_created

    result2 = script.pip(
        'install', 'INITools==0.2', '--no-download', expect_error=True,
    )
    assert egg_info_folder in result2.files_created, str(result2)
    assert initools_folder in result2.files_created, (
        sorted(result2.files_created)
    )
    assert build_dir not in result2.files_created
    assert build_dir / 'INITools.egg-info' not in result2.files_created


def test_bad_install_with_no_download(script):
    """
    Test that --no-download behaves sensibly if the package source can't be
    found.
    """
    result = script.pip(
        'install', 'INITools==0.2', '--no-download', expect_error=True,
    )
    assert (
        "perhaps --no-download was used without first running "
        "an equivalent install with --no-install?" in result.stdout
    )


def test_install_dev_version_from_pypi(script):
    """
    Test using package==dev.
    """
    result = script.pip(
        'install', 'INITools==dev',
        '--allow-external', 'INITools',
        '--allow-unverified', 'INITools',
        expect_error=True,
    )
    assert (script.site_packages / 'initools') in result.files_created, (
        str(result.stdout)
    )


def test_install_editable_from_git(script, tmpdir):
    """
    Test cloning from Git.
    """
    args = ['install']
    args.extend([
        '-e',
        '%s#egg=pip-test-package' %
        local_checkout(
            'git+http://github.com/pypa/pip-test-package.git',
            tmpdir.join("cache"),
        ),
    ])
    result = script.pip(*args, **{"expect_error": True})
    result.assert_installed('pip-test-package', with_files=['.git'])


def test_install_editable_from_hg(script, tmpdir):
    """
    Test cloning from Mercurial.
    """
    result = script.pip(
        'install', '-e',
        '%s#egg=ScriptTest' %
        local_checkout(
            'hg+https://bitbucket.org/ianb/scripttest',
            tmpdir.join("cache"),
        ),
        expect_error=True,
    )
    result.assert_installed('ScriptTest', with_files=['.hg'])


def test_vcs_url_final_slash_normalization(script, tmpdir):
    """
    Test that presence or absence of final slash in VCS URL is normalized.
    """
    result = script.pip(
        'install', '-e',
        '%s/#egg=ScriptTest' %
        local_checkout(
            'hg+https://bitbucket.org/ianb/scripttest',
            tmpdir.join("cache"),
        ),
        expect_error=True,
    )
    assert 'pip-log.txt' not in result.files_created, (
        result.files_created['pip-log.txt'].bytes
    )


def test_install_editable_from_bazaar(script, tmpdir):
    """
    Test checking out from Bazaar.
    """
    result = script.pip(
        'install', '-e',
        '%s/@174#egg=django-wikiapp' %
        local_checkout(
            'bzr+http://bazaar.launchpad.net/%7Edjango-wikiapp/django-wikiapp'
            '/release-0.1',
            tmpdir.join("cache"),
        ),
        expect_error=True,
    )
    result.assert_installed('django-wikiapp', with_files=['.bzr'])


def test_vcs_url_urlquote_normalization(script, tmpdir):
    """
    Test that urlquoted characters are normalized for repo URL comparison.
    """
    result = script.pip(
        'install', '-e',
        '%s/#egg=django-wikiapp' %
        local_checkout(
            'bzr+http://bazaar.launchpad.net/%7Edjango-wikiapp/django-wikiapp'
            '/release-0.1',
            tmpdir.join("cache"),
        ),
        expect_error=True,
    )
    assert 'pip-log.txt' not in result.files_created, (
        result.files_created['pip-log.txt'].bytes
    )


def test_install_from_local_directory(script, data):
    """
    Test installing from a local directory.
    """
    to_install = data.packages.join("FSPkg")
    result = script.pip('install', to_install, expect_error=False)
    fspkg_folder = script.site_packages / 'fspkg'
    egg_info_folder = (
        script.site_packages / 'FSPkg-0.1dev-py%s.egg-info' % pyversion
    )
    assert fspkg_folder in result.files_created, str(result.stdout)
    assert egg_info_folder in result.files_created, str(result)


def test_install_from_local_directory_with_symlinks_to_directories(
        script, data):
    """
    Test installing from a local directory containing symlinks to directories.
    """
    to_install = data.packages.join("symlinks")
    result = script.pip('install', to_install, expect_error=False)
    pkg_folder = script.site_packages / 'symlinks'
    egg_info_folder = (
        script.site_packages / 'symlinks-0.1dev-py%s.egg-info' % pyversion
    )
    assert pkg_folder in result.files_created, str(result.stdout)
    assert egg_info_folder in result.files_created, str(result)


def test_install_from_local_directory_with_no_setup_py(script, data):
    """
    Test installing from a local directory with no 'setup.py'.
    """
    result = script.pip('install', data.root, expect_error=True)
    assert len(result.files_created) == 1, result.files_created
    assert 'pip-log.txt' in result.files_created, result.files_created
    assert "is not installable. File 'setup.py' not found." in result.stdout


def test_editable_install_from_local_directory_with_no_setup_py(script, data):
    """
    Test installing from a local directory with no 'setup.py'.
    """
    result = script.pip('install', '-e', data.root, expect_error=True)
    assert len(result.files_created) == 1, result.files_created
    assert 'pip-log.txt' in result.files_created, result.files_created
    assert "is not installable. File 'setup.py' not found." in result.stdout


def test_install_as_egg(script, data):
    """
    Test installing as egg, instead of flat install.
    """
    to_install = data.packages.join("FSPkg")
    result = script.pip('install', to_install, '--egg', expect_error=False)
    fspkg_folder = script.site_packages / 'fspkg'
    egg_folder = script.site_packages / 'FSPkg-0.1dev-py%s.egg' % pyversion
    assert fspkg_folder not in result.files_created, str(result.stdout)
    assert egg_folder in result.files_created, str(result)
    assert join(egg_folder, 'fspkg') in result.files_created, str(result)


def test_install_curdir(script, data):
    """
    Test installing current directory ('.').
    """
    run_from = data.packages.join("FSPkg")
    # Python 2.4 Windows balks if this exists already
    egg_info = join(run_from, "FSPkg.egg-info")
    if os.path.isdir(egg_info):
        rmtree(egg_info)
    result = script.pip('install', curdir, cwd=run_from, expect_error=False)
    fspkg_folder = script.site_packages / 'fspkg'
    egg_info_folder = (
        script.site_packages / 'FSPkg-0.1dev-py%s.egg-info' % pyversion
    )
    assert fspkg_folder in result.files_created, str(result.stdout)
    assert egg_info_folder in result.files_created, str(result)


def test_install_pardir(script, data):
    """
    Test installing parent directory ('..').
    """
    run_from = data.packages.join("FSPkg", "fspkg")
    result = script.pip('install', pardir, cwd=run_from, expect_error=False)
    fspkg_folder = script.site_packages / 'fspkg'
    egg_info_folder = (
        script.site_packages / 'FSPkg-0.1dev-py%s.egg-info' % pyversion
    )
    assert fspkg_folder in result.files_created, str(result.stdout)
    assert egg_info_folder in result.files_created, str(result)


def test_install_global_option(script):
    """
    Test using global distutils options.
    (In particular those that disable the actual install action)
    """
    result = script.pip(
        'install', '--global-option=--version', "INITools==0.1",
    )
    assert '0.1\n' in result.stdout


def test_install_with_pax_header(script, data):
    """
    test installing from a tarball with pax header for python<2.6
    """
    script.pip('install', 'paxpkg.tar.bz2', cwd=data.packages)


def test_install_with_hacked_egg_info(script, data):
    """
    test installing a package which defines its own egg_info class
    """
    run_from = data.packages.join("HackedEggInfo")
    result = script.pip('install', '.', cwd=run_from)
    assert 'Successfully installed hackedegginfo\n' in result.stdout


def test_install_using_install_option_and_editable(script, tmpdir):
    """
    Test installing a tool using -e and --install-option
    """
    folder = 'script_folder'
    script.scratch_path.join(folder).mkdir()
    url = 'git+git://github.com/pypa/pip-test-package'
    result = script.pip(
        'install', '-e', '%s#egg=pip-test-package' %
        local_checkout(url, tmpdir.join("cache")),
        '--install-option=--script-dir=%s' % folder
    )
    script_file = (
        script.venv / 'src' / 'pip-test-package' /
        folder / 'pip-test-package' + script.exe
    )
    assert script_file in result.files_created


def test_install_global_option_using_editable(script, tmpdir):
    """
    Test using global distutils options, but in an editable installation
    """
    url = 'hg+http://bitbucket.org/runeh/anyjson'
    result = script.pip(
        'install', '--global-option=--version', '-e',
        '%s@0.2.5#egg=anyjson' % local_checkout(url, tmpdir.join("cache"))
    )
    assert '0.2.5\n' in result.stdout


def test_install_package_with_same_name_in_curdir(script):
    """
    Test installing a package with the same name of a local folder
    """
    script.scratch_path.join("mock==0.6").mkdir()
    result = script.pip('install', 'mock==0.6')
    egg_folder = script.site_packages / 'mock-0.6.0-py%s.egg-info' % pyversion
    assert egg_folder in result.files_created, str(result)


mock100_setup_py = textwrap.dedent('''\
                        from setuptools import setup
                        setup(name='mock',
                              version='100.1')''')


def test_install_folder_using_dot_slash(script):
    """
    Test installing a folder using pip install ./foldername
    """
    script.scratch_path.join("mock").mkdir()
    pkg_path = script.scratch_path / 'mock'
    pkg_path.join("setup.py").write(mock100_setup_py)
    result = script.pip('install', './mock')
    egg_folder = script.site_packages / 'mock-100.1-py%s.egg-info' % pyversion
    assert egg_folder in result.files_created, str(result)


def test_install_folder_using_slash_in_the_end(script):
    r"""
    Test installing a folder using pip install foldername/ or foldername\
    """
    script.scratch_path.join("mock").mkdir()
    pkg_path = script.scratch_path / 'mock'
    pkg_path.join("setup.py").write(mock100_setup_py)
    result = script.pip('install', 'mock' + os.path.sep)
    egg_folder = script.site_packages / 'mock-100.1-py%s.egg-info' % pyversion
    assert egg_folder in result.files_created, str(result)


def test_install_folder_using_relative_path(script):
    """
    Test installing a folder using pip install folder1/folder2
    """
    script.scratch_path.join("initools").mkdir()
    script.scratch_path.join("initools", "mock").mkdir()
    pkg_path = script.scratch_path / 'initools' / 'mock'
    pkg_path.join("setup.py").write(mock100_setup_py)
    result = script.pip('install', Path('initools') / 'mock')
    egg_folder = script.site_packages / 'mock-100.1-py%s.egg-info' % pyversion
    assert egg_folder in result.files_created, str(result)


def test_install_package_which_contains_dev_in_name(script):
    """
    Test installing package from pypi which contains 'dev' in name
    """
    result = script.pip('install', 'django-devserver==0.0.4')
    devserver_folder = script.site_packages / 'devserver'
    egg_info_folder = (
        script.site_packages / 'django_devserver-0.0.4-py%s.egg-info' %
        pyversion
    )
    assert devserver_folder in result.files_created, str(result.stdout)
    assert egg_info_folder in result.files_created, str(result)


def test_install_package_with_target(script):
    """
    Test installing a package using pip install --target
    """
    target_dir = script.scratch_path / 'target'
    result = script.pip('install', '-t', target_dir, "initools==0.1")
    assert Path('scratch') / 'target' / 'initools' in result.files_created, (
        str(result)
    )


def test_install_package_with_root(script, data):
    """
    Test installing a package using pip install --root
    """
    root_dir = script.scratch_path / 'root'
    result = script.pip(
        'install', '--root', root_dir, '-f', data.find_links, '--no-index',
        'simple==1.0',
    )
    normal_install_path = (
        script.base_path / script.site_packages / 'simple-1.0-py%s.egg-info' %
        pyversion
    )
    # use distutils to change the root exactly how the --root option does it
    from distutils.util import change_root
    root_path = change_root(
        os.path.join(script.scratch, 'root'),
        normal_install_path
    )
    assert root_path in result.files_created, str(result)


# skip on win/py3 for now, see issue #782
@pytest.mark.skipif("sys.platform == 'win32' and sys.version_info >= (3,)")
def test_install_package_that_emits_unicode(script, data):
    """
    Install a package with a setup.py that emits UTF-8 output and then fails.

    Refs https://github.com/pypa/pip/issues/326
    """
    to_install = data.packages.join("BrokenEmitsUTF8")
    result = script.pip(
        'install', to_install, expect_error=True, expect_temp=True, quiet=True,
    )
    assert (
        'FakeError: this package designed to fail on install' in result.stdout
    )
    assert 'UnicodeDecodeError' not in result.stdout


def test_install_package_with_utf8_setup(script, data):
    """Install a package with a setup.py that declares a utf-8 encoding."""
    to_install = data.packages.join("SetupPyUTF8")
    script.pip('install', to_install)


def test_install_package_with_latin1_setup(script, data):
    """Install a package with a setup.py that declares a latin-1 encoding."""
    to_install = data.packages.join("SetupPyLatin1")
    script.pip('install', to_install)


def test_url_req_case_mismatch_no_index(script, data):
    """
    tar ball url requirements (with no egg fragment), that happen to have upper
    case project names, should be considered equal to later requirements that
    reference the project name using lower case.

    tests/packages contains Upper-1.0.tar.gz and Upper-2.0.tar.gz
    'requiresupper' has install_requires = ['upper']
    """
    Upper = os.path.join(data.find_links, 'Upper-1.0.tar.gz')
    result = script.pip(
        'install', '--no-index', '-f', data.find_links, Upper, 'requiresupper'
    )

    # only Upper-1.0.tar.gz should get installed.
    egg_folder = script.site_packages / 'Upper-1.0-py%s.egg-info' % pyversion
    assert egg_folder in result.files_created, str(result)
    egg_folder = script.site_packages / 'Upper-2.0-py%s.egg-info' % pyversion
    assert egg_folder not in result.files_created, str(result)


def test_url_req_case_mismatch_file_index(script, data):
    """
    tar ball url requirements (with no egg fragment), that happen to have upper
    case project names, should be considered equal to later requirements that
    reference the project name using lower case.

    tests/packages3 contains Dinner-1.0.tar.gz and Dinner-2.0.tar.gz
    'requiredinner' has install_requires = ['dinner']

    This test is similar to test_url_req_case_mismatch_no_index; that test
    tests behaviour when using "--no-index -f", while this one does the same
    test when using "--index-url". Unfortunately this requires a different
    set of packages as it requires a prepared index.html file and
    subdirectory-per-package structure.
    """
    Dinner = os.path.join(data.find_links3, 'Dinner', 'Dinner-1.0.tar.gz')
    result = script.pip(
        'install', '--index-url', data.find_links3, Dinner, 'requiredinner'
    )

    # only Upper-1.0.tar.gz should get installed.
    egg_folder = script.site_packages / 'Dinner-1.0-py%s.egg-info' % pyversion
    assert egg_folder in result.files_created, str(result)
    egg_folder = script.site_packages / 'Dinner-2.0-py%s.egg-info' % pyversion
    assert egg_folder not in result.files_created, str(result)


def test_url_incorrect_case_no_index(script, data):
    """
    Same as test_url_req_case_mismatch_no_index, except testing for the case
    where the incorrect case is given in the name of the package to install
    rather than in a requirements file.
    """
    result = script.pip(
        'install', '--no-index', '-f', data.find_links, "upper",
    )

    # only Upper-2.0.tar.gz should get installed.
    egg_folder = script.site_packages / 'Upper-1.0-py%s.egg-info' % pyversion
    assert egg_folder not in result.files_created, str(result)
    egg_folder = script.site_packages / 'Upper-2.0-py%s.egg-info' % pyversion
    assert egg_folder in result.files_created, str(result)


def test_url_incorrect_case_file_index(script, data):
    """
    Same as test_url_req_case_mismatch_file_index, except testing for the case
    where the incorrect case is given in the name of the package to install
    rather than in a requirements file.
    """
    result = script.pip(
        'install', '--index-url', data.find_links3, "dinner",
    )

    # only Upper-2.0.tar.gz should get installed.
    egg_folder = script.site_packages / 'Dinner-1.0-py%s.egg-info' % pyversion
    assert egg_folder not in result.files_created, str(result)
    egg_folder = script.site_packages / 'Dinner-2.0-py%s.egg-info' % pyversion
    assert egg_folder in result.files_created, str(result)


def test_compiles_pyc(script):
    """
    Test installing with --compile on
    """
    del script.environ["PYTHONDONTWRITEBYTECODE"]
    script.pip("install", "--compile", "--no-use-wheel", "INITools==0.2")

    # There are many locations for the __init__.pyc file so attempt to find
    #   any of them
    exists = [
        os.path.exists(script.site_packages_path / "initools/__init__.pyc"),
    ]

    exists += glob.glob(
        script.site_packages_path / "initools/__pycache__/__init__*.pyc"
    )

    assert any(exists)


def test_no_compiles_pyc(script, data):
    """
    Test installing from wheel with --compile on
    """
    del script.environ["PYTHONDONTWRITEBYTECODE"]
    script.pip("install", "--no-compile", "--no-use-wheel", "INITools==0.2")

    # There are many locations for the __init__.pyc file so attempt to find
    #   any of them
    exists = [
        os.path.exists(script.site_packages_path / "initools/__init__.pyc"),
    ]

    exists += glob.glob(
        script.site_packages_path / "initools/__pycache__/__init__*.pyc"
    )

    assert not any(exists)

########NEW FILE########
__FILENAME__ = test_install_cleanup
import os

from os.path import exists

from tests.lib.local_repos import local_checkout
from tests.lib.path import Path
from pip.locations import write_delete_marker_file
from pip.status_codes import PREVIOUS_BUILD_DIR_ERROR


def test_cleanup_after_install(script, data):
    """
    Test clean up after installing a package.
    """
    script.pip(
        'install', '--no-index', '--find-links=%s' % data.find_links, 'simple'
    )
    build = script.venv_path / "build"
    src = script.venv_path / "src"
    assert not exists(build), "build/ dir still exists: %s" % build
    assert not exists(src), "unexpected src/ dir exists: %s" % src
    script.assert_no_temp()


def test_no_clean_option_blocks_cleaning_after_install(script, data):
    """
    Test --no-clean option blocks cleaning after install
    """
    result = script.pip(
        'install', '--no-clean', '--no-index',
        '--find-links=%s' % data.find_links, 'simple'
    )
    build = script.venv_path / 'build' / 'simple'
    assert exists(build), "build/simple should still exist %s" % str(result)


def test_cleanup_after_install_editable_from_hg(script, tmpdir):
    """
    Test clean up after cloning from Mercurial.

    """
    script.pip(
        'install',
        '-e',
        '%s#egg=ScriptTest' %
        local_checkout(
            'hg+https://bitbucket.org/ianb/scripttest',
            tmpdir.join("cache"),
        ),
        expect_error=True,
    )
    build = script.venv_path / 'build'
    src = script.venv_path / 'src'
    assert not exists(build), "build/ dir still exists: %s" % build
    assert exists(src), "expected src/ dir doesn't exist: %s" % src
    script.assert_no_temp()


def test_cleanup_after_install_from_local_directory(script, data):
    """
    Test clean up after installing from a local directory.
    """
    to_install = data.packages.join("FSPkg")
    script.pip('install', to_install, expect_error=False)
    build = script.venv_path / 'build'
    src = script.venv_path / 'src'
    assert not exists(build), "unexpected build/ dir exists: %s" % build
    assert not exists(src), "unexpected src/ dir exist: %s" % src
    script.assert_no_temp()


def test_no_install_and_download_should_not_leave_build_dir(script):
    """
    It should remove build/ dir if it was pip that created
    """
    script.scratch_path.join("downloaded_packages").mkdir()
    assert not os.path.exists(script.venv_path / 'build')
    result = script.pip(
        'install', '--no-install', 'INITools==0.2', '-d', 'downloaded_packages'
    )
    assert (
        Path('scratch') / 'downloaded_packages/build'
        not in result.files_created
    ), 'pip should not leave build/ dir'
    assert not os.path.exists(script.venv_path / 'build'), (
        "build/ dir should be deleted"
    )


def test_cleanup_req_satisifed_no_name(script, data):
    """
    Test cleanup when req is already satisfied, and req has no 'name'
    """
    # this test confirms Issue #420 is fixed
    # reqs with no 'name' that were already satisfied were leaving behind tmp
    # build dirs
    # 2 examples of reqs that would do this
    # 1) https://bitbucket.org/ianb/initools/get/tip.zip
    # 2) parent-0.1.tar.gz
    dist = data.packages.join("parent-0.1.tar.gz")

    script.pip('install', dist)
    script.pip('install', dist)

    build = script.venv_path / 'build'
    assert not exists(build), "unexpected build/ dir exists: %s" % build
    script.assert_no_temp()


def test_download_should_not_delete_existing_build_dir(script):
    """
    It should not delete build/ if existing before run the command
    """
    script.venv_path.join("build").mkdir()
    script.venv_path.join("build", "somefile.txt").write("I am not empty!")
    script.pip('install', '--no-install', 'INITools==0.2', '-d', '.')
    with open(script.venv_path / 'build' / 'somefile.txt') as fp:
        content = fp.read()
    assert os.path.exists(script.venv_path / 'build'), (
        "build/ should be left if it exists before pip run"
    )
    assert content == 'I am not empty!', (
        "it should not affect build/ and its content"
    )
    assert ['somefile.txt'] == os.listdir(script.venv_path / 'build')


def test_cleanup_after_install_exception(script, data):
    """
    Test clean up after a 'setup.py install' exception.
    """
    # broken==0.2broken fails during install; see packages readme file
    result = script.pip(
        'install', '-f', data.find_links, '--no-index', 'broken==0.2broken',
        expect_error=True,
    )
    build = script.venv_path / 'build'
    assert not exists(build), "build/ dir still exists: %s" % result.stdout
    script.assert_no_temp()


def test_cleanup_after_egg_info_exception(script, data):
    """
    Test clean up after a 'setup.py egg_info' exception.
    """
    # brokenegginfo fails during egg_info; see packages readme file
    result = script.pip(
        'install', '-f', data.find_links, '--no-index', 'brokenegginfo==0.1',
        expect_error=True,
    )
    build = script.venv_path / 'build'
    assert not exists(build), "build/ dir still exists: %s" % result.stdout
    script.assert_no_temp()


def test_cleanup_prevented_upon_build_dir_exception(script, data):
    """
    Test no cleanup occurs after a PreviousBuildDirError
    """
    build = script.venv_path / 'build' / 'simple'
    os.makedirs(build)
    write_delete_marker_file(script.venv_path / 'build')
    build.join("setup.py").write("#")
    result = script.pip(
        'install', '-f', data.find_links, '--no-index', 'simple',
        expect_error=True,
    )

    assert result.returncode == PREVIOUS_BUILD_DIR_ERROR
    assert "pip can't proceed" in result.stdout, result.stdout
    assert exists(build)

########NEW FILE########
__FILENAME__ = test_install_compat
"""
Tests for compatibility workarounds.

"""
import os
from tests.lib import pyversion, assert_all_changes


def test_debian_egg_name_workaround(script):
    """
    We can uninstall packages installed with the pyversion removed from the
    egg-info metadata directory name.

    Refs:
    http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=618367
    https://bugs.launchpad.net/ubuntu/+source/distribute/+bug/725178
    https://bitbucket.org/ianb/pip/issue/104/pip-uninstall-on-ubuntu-linux

    """
    result = script.pip('install', 'INITools==0.2', expect_error=True)

    egg_info = os.path.join(
        script.site_packages, "INITools-0.2-py%s.egg-info" % pyversion)

    # Debian only removes pyversion for global installs, not inside a venv
    # so even if this test runs on a Debian/Ubuntu system with broken
    # setuptools, since our test runs inside a venv we'll still have the normal
    # .egg-info
    assert egg_info in result.files_created, "Couldn't find %s" % egg_info

    # The Debian no-pyversion version of the .egg-info
    mangled = os.path.join(script.site_packages, "INITools-0.2.egg-info")
    assert mangled not in result.files_created, "Found unexpected %s" % mangled

    # Simulate a Debian install by copying the .egg-info to their name for it
    full_egg_info = os.path.join(script.base_path, egg_info)
    assert os.path.isdir(full_egg_info)
    full_mangled = os.path.join(script.base_path, mangled)
    os.renames(full_egg_info, full_mangled)
    assert os.path.isdir(full_mangled)

    # Try the uninstall and verify that everything is removed.
    result2 = script.pip("uninstall", "INITools", "-y")
    assert_all_changes(result, result2, [script.venv / 'build', 'cache'])


def test_setup_py_with_dos_line_endings(script, data):
    """
    It doesn't choke on a setup.py file that uses DOS line endings (\\r\\n).

    Refs https://github.com/pypa/pip/issues/237
    """
    to_install = data.packages.join("LineEndings")
    script.pip('install', to_install, expect_error=False)

########NEW FILE########
__FILENAME__ = test_install_config
import os
import tempfile
import textwrap


def test_options_from_env_vars(script):
    """
    Test if ConfigOptionParser reads env vars (e.g. not using PyPI here)

    """
    script.environ['PIP_NO_INDEX'] = '1'
    result = script.pip('install', '-vvv', 'INITools', expect_error=True)
    assert "Ignoring indexes:" in result.stdout, str(result)
    assert (
        "DistributionNotFound: No distributions at all found for INITools"
        in result.stdout
    )


def test_command_line_options_override_env_vars(script, virtualenv):
    """
    Test that command line options override environmental variables.

    """
    script.environ['PIP_INDEX_URL'] = 'http://b.pypi.python.org/simple/'
    result = script.pip('install', '-vvv', 'INITools', expect_error=True)
    assert (
        "Getting page http://b.pypi.python.org/simple/INITools"
        in result.stdout
    )
    virtualenv.clear()
    result = script.pip(
        'install', '-vvv', '--index-url', 'http://download.zope.org/ppix',
        'INITools',
        expect_error=True,
    )
    assert "b.pypi.python.org" not in result.stdout
    assert "Getting page http://download.zope.org/ppix" in result.stdout


def test_env_vars_override_config_file(script, virtualenv):
    """
    Test that environmental variables override settings in config files.

    """
    fd, config_file = tempfile.mkstemp('-pip.cfg', 'test-')
    try:
        _test_env_vars_override_config_file(script, virtualenv, config_file)
    finally:
        # `os.close` is a workaround for a bug in subprocess
        # http://bugs.python.org/issue3210
        os.close(fd)
        os.remove(config_file)


def _test_env_vars_override_config_file(script, virtualenv, config_file):
    # set this to make pip load it
    script.environ['PIP_CONFIG_FILE'] = config_file
    # It's important that we test this particular config value ('no-index')
    # because there is/was a bug which only shows up in cases in which
    # 'config-item' and 'config_item' hash to the same value modulo the size
    # of the config dictionary.
    (script.scratch_path / config_file).write(textwrap.dedent("""\
        [global]
        no-index = 1
        """))
    result = script.pip('install', '-vvv', 'INITools', expect_error=True)
    assert (
        "DistributionNotFound: No distributions at all found for INITools"
        in result.stdout
    )
    script.environ['PIP_NO_INDEX'] = '0'
    virtualenv.clear()
    result = script.pip('install', '-vvv', 'INITools', expect_error=True)
    assert "Successfully installed INITools" in result.stdout


def test_command_line_append_flags(script, virtualenv, data):
    """
    Test command line flags that append to defaults set by environmental
    variables.

    """
    script.environ['PIP_FIND_LINKS'] = 'http://pypi.pinaxproject.com'
    result = script.pip('install', '-vvv', 'INITools', expect_error=True)
    assert (
        "Analyzing links from page http://pypi.pinaxproject.com"
        in result.stdout
    )
    virtualenv.clear()
    result = script.pip(
        'install', '-vvv', '--find-links', data.find_links, 'INITools',
        expect_error=True,
    )
    assert (
        "Analyzing links from page http://pypi.pinaxproject.com"
        in result.stdout
    )
    assert "Skipping link %s" % data.find_links in result.stdout


def test_command_line_appends_correctly(script, data):
    """
    Test multiple appending options set by environmental variables.

    """
    script.environ['PIP_FIND_LINKS'] = (
        'http://pypi.pinaxproject.com %s' % data.find_links
    )
    result = script.pip('install', '-vvv', 'INITools', expect_error=True)

    assert (
        "Analyzing links from page http://pypi.pinaxproject.com"
        in result.stdout
    ), result.stdout
    assert "Skipping link %s" % data.find_links in result.stdout


def test_config_file_override_stack(script, virtualenv):
    """
    Test config files (global, overriding a global config with a
    local, overriding all with a command line flag).

    """
    fd, config_file = tempfile.mkstemp('-pip.cfg', 'test-')
    try:
        _test_config_file_override_stack(script, virtualenv, config_file)
    finally:
        # `os.close` is a workaround for a bug in subprocess
        # http://bugs.python.org/issue3210
        os.close(fd)
        os.remove(config_file)


def _test_config_file_override_stack(script, virtualenv, config_file):
    # set this to make pip load it
    script.environ['PIP_CONFIG_FILE'] = config_file
    (script.scratch_path / config_file).write(textwrap.dedent("""\
        [global]
        index-url = http://download.zope.org/ppix
        """))
    result = script.pip('install', '-vvv', 'INITools', expect_error=True)
    assert (
        "Getting page http://download.zope.org/ppix/INITools" in result.stdout
    )
    virtualenv.clear()
    (script.scratch_path / config_file).write(textwrap.dedent("""\
        [global]
        index-url = http://download.zope.org/ppix
        [install]
        index-url = http://pypi.appspot.com/
        """))
    result = script.pip('install', '-vvv', 'INITools', expect_error=True)
    assert "Getting page http://pypi.appspot.com/INITools" in result.stdout
    result = script.pip(
        'install', '-vvv', '--index-url', 'http://pypi.python.org/simple',
        'INITools',
        expect_error=True,
    )
    assert (
        "Getting page http://download.zope.org/ppix/INITools"
        not in result.stdout
    )
    assert "Getting page http://pypi.appspot.com/INITools" not in result.stdout
    assert (
        "Getting page http://pypi.python.org/simple/INITools" in result.stdout
    )


def test_log_file_no_directory():
    """
    Test opening a log file with no directory name.

    """
    from pip.basecommand import open_logfile
    fp = open_logfile('testpip.log')
    fp.write('can write')
    fp.close()
    assert os.path.exists(fp.name)
    os.remove(fp.name)


def test_options_from_venv_config(script, virtualenv):
    """
    Test if ConfigOptionParser reads a virtualenv-local config file

    """
    from pip.locations import default_config_basename
    conf = "[global]\nno-index = true"
    ini = virtualenv.location / default_config_basename
    with open(ini, 'w') as f:
        f.write(conf)
    result = script.pip('install', '-vvv', 'INITools', expect_error=True)
    assert "Ignoring indexes:" in result.stdout, str(result)
    assert (
        "DistributionNotFound: No distributions at all found for INITools"
        in result.stdout
    )

########NEW FILE########
__FILENAME__ = test_install_download
import os
import textwrap

from tests.lib.path import Path


def test_download_if_requested(script):
    """
    It should download (in the scratch path) and not install if requested.
    """
    result = script.pip(
        'install', 'INITools==0.1', '-d', '.', expect_error=True
    )
    assert Path('scratch') / 'INITools-0.1.tar.gz' in result.files_created
    assert script.site_packages / 'initools' not in result.files_created


def test_download_wheel(script):
    """
    Test using "pip install --download" to download a *.whl archive.
    FIXME: this test could use a local --find-links dir, but -d with local
           --find-links has a bug https://github.com/pypa/pip/issues/1111
    """
    result = script.pip(
        'install', '--use-wheel',
        '-f', 'https://bitbucket.org/pypa/pip-test-package/downloads',
        '-d', '.', 'pip-test-package'
    )
    assert (
        Path('scratch') / 'pip_test_package-0.1.1-py2.py3-none-any.whl'
        in result.files_created
    )
    assert script.site_packages / 'piptestpackage' not in result.files_created


def test_single_download_from_requirements_file(script):
    """
    It should support download (in the scratch path) from PyPi from a
    requirements file
    """
    script.scratch_path.join("test-req.txt").write(textwrap.dedent("""
        INITools==0.1
        """))
    result = script.pip(
        'install', '-r', script.scratch_path / 'test-req.txt', '-d', '.',
        expect_error=True,
    )
    assert Path('scratch') / 'INITools-0.1.tar.gz' in result.files_created
    assert script.site_packages / 'initools' not in result.files_created


def test_download_should_download_dependencies(script):
    """
    It should download dependencies (in the scratch path)
    """
    result = script.pip(
        'install', 'Paste[openid]==1.7.5.1', '-d', '.', expect_error=True,
    )
    assert Path('scratch') / 'Paste-1.7.5.1.tar.gz' in result.files_created
    openid_tarball_prefix = str(Path('scratch') / 'python-openid-')
    assert any(
        path.startswith(openid_tarball_prefix) for path in result.files_created
    )
    assert script.site_packages / 'openid' not in result.files_created


def test_download_wheel_archive(script, data):
    """
    It should download a wheel archive path
    """
    wheel_filename = 'colander-0.9.9-py2.py3-none-any.whl'
    wheel_path = os.path.join(data.find_links, wheel_filename)
    result = script.pip(
        'install', wheel_path,
        '-d', '.', '--no-deps'
    )
    assert Path('scratch') / wheel_filename in result.files_created


def test_download_should_download_wheel_deps(script, data):
    """
    It should download dependencies for wheels(in the scratch path)
    """
    wheel_filename = 'colander-0.9.9-py2.py3-none-any.whl'
    dep_filename = 'translationstring-1.1.tar.gz'
    wheel_path = os.path.join(data.find_links, wheel_filename)
    result = script.pip(
        'install', wheel_path,
        '-d', '.', '--find-links', data.find_links, '--no-index'
    )
    assert Path('scratch') / wheel_filename in result.files_created
    assert Path('scratch') / dep_filename in result.files_created


def test_download_should_skip_existing_files(script):
    """
    It should not download files already existing in the scratch dir
    """
    script.scratch_path.join("test-req.txt").write(textwrap.dedent("""
        INITools==0.1
        """))

    result = script.pip(
        'install', '-r', script.scratch_path / 'test-req.txt', '-d', '.',
        expect_error=True,
    )
    assert Path('scratch') / 'INITools-0.1.tar.gz' in result.files_created
    assert script.site_packages / 'initools' not in result.files_created

    # adding second package to test-req.txt
    script.scratch_path.join("test-req.txt").write(textwrap.dedent("""
        INITools==0.1
        python-openid==2.2.5
        """))

    # only the second package should be downloaded
    result = script.pip(
        'install', '-r', script.scratch_path / 'test-req.txt', '-d', '.',
        expect_error=True,
    )
    openid_tarball_prefix = str(Path('scratch') / 'python-openid-')
    assert any(
        path.startswith(openid_tarball_prefix) for path in result.files_created
    )
    assert Path('scratch') / 'INITools-0.1.tar.gz' not in result.files_created
    assert script.site_packages / 'initools' not in result.files_created
    assert script.site_packages / 'openid' not in result.files_created

########NEW FILE########
__FILENAME__ = test_install_extras
from os.path import join


def test_simple_extras_install_from_pypi(script):
    """
    Test installing a package from PyPI using extras dependency Paste[openid].
    """
    result = script.pip(
        'install', 'Paste[openid]==1.7.5.1', expect_stderr=True,
    )
    initools_folder = script.site_packages / 'openid'
    assert initools_folder in result.files_created, result.files_created


def test_no_extras_uninstall(script):
    """
    No extras dependency gets uninstalled when the root package is uninstalled
    """
    result = script.pip(
        'install', 'Paste[openid]==1.7.5.1', expect_stderr=True,
    )
    assert join(script.site_packages, 'paste') in result.files_created, (
        sorted(result.files_created.keys())
    )
    assert join(script.site_packages, 'openid') in result.files_created, (
        sorted(result.files_created.keys())
    )
    result2 = script.pip('uninstall', 'Paste', '-y')
    # openid should not be uninstalled
    initools_folder = script.site_packages / 'openid'
    assert initools_folder not in result2.files_deleted, result.files_deleted

########NEW FILE########
__FILENAME__ = test_install_index
import textwrap

from pip.compat import urllib

from tests.lib import pyversion


def test_find_links_relative_path(script, data):
    """Test find-links as a relative path."""
    result = script.pip(
        'install',
        'parent==0.1',
        '--no-index',
        '--find-links',
        'packages/',
        cwd=data.root,
    )
    egg_info_folder = (
        script.site_packages / 'parent-0.1-py%s.egg-info' % pyversion
    )
    initools_folder = script.site_packages / 'parent'
    assert egg_info_folder in result.files_created, str(result)
    assert initools_folder in result.files_created, str(result)


def test_find_links_requirements_file_relative_path(script, data):
    """Test find-links as a relative path to a reqs file."""
    script.scratch_path.join("test-req.txt").write(textwrap.dedent("""
        --no-index
        --find-links=%s
        parent==0.1
        """ % data.packages))
    result = script.pip(
        'install',
        '-r',
        script.scratch_path / "test-req.txt",
        cwd=data.root,
    )
    egg_info_folder = (
        script.site_packages / 'parent-0.1-py%s.egg-info' % pyversion
    )
    initools_folder = script.site_packages / 'parent'
    assert egg_info_folder in result.files_created, str(result)
    assert initools_folder in result.files_created, str(result)


def test_install_from_file_index_hash_link(script, data):
    """
    Test that a pkg can be installed from a file:// index using a link with a
    hash
    """
    result = script.pip('install', '-i', data.index_url(), 'simple==1.0')
    egg_info_folder = (
        script.site_packages / 'simple-1.0-py%s.egg-info' % pyversion
    )
    assert egg_info_folder in result.files_created, str(result)


def test_file_index_url_quoting(script, data):
    """
    Test url quoting of file index url with a space
    """
    index_url = data.index_url(urllib.quote("in dex"))
    result = script.pip(
        'install', '-vvv', '--index-url', index_url, 'simple',
        expect_error=False,
    )
    assert (script.site_packages / 'simple') in result.files_created, (
        str(result.stdout)
    )
    assert (
        script.site_packages / 'simple-1.0-py%s.egg-info' % pyversion
    ) in result.files_created, str(result)

########NEW FILE########
__FILENAME__ = test_install_reqs
import os.path
import textwrap

import pytest

from tests.lib import (pyversion, path_to_url,
                       _create_test_package_with_subdirectory)
from tests.lib.local_repos import local_checkout


def test_requirements_file(script):
    """
    Test installing from a requirements file.

    """
    other_lib_name, other_lib_version = 'anyjson', '0.3'
    script.scratch_path.join("initools-req.txt").write(textwrap.dedent("""\
        INITools==0.2
        # and something else to test out:
        %s<=%s
        """ % (other_lib_name, other_lib_version)))
    result = script.pip(
        'install', '-r', script.scratch_path / 'initools-req.txt'
    )
    assert (
        script.site_packages / 'INITools-0.2-py%s.egg-info' %
        pyversion in result.files_created
    )
    assert script.site_packages / 'initools' in result.files_created
    assert result.files_created[script.site_packages / other_lib_name].dir
    fn = '%s-%s-py%s.egg-info' % (other_lib_name, other_lib_version, pyversion)
    assert result.files_created[script.site_packages / fn].dir


def test_schema_check_in_requirements_file(script):
    """
    Test installing from a requirements file with an invalid vcs schema..

    """
    script.scratch_path.join("file-egg-req.txt").write(
        "\n%s\n" % (
            "git://github.com/alex/django-fixture-generator.git"
            "#egg=fixture_generator"
        )
    )

    with pytest.raises(AssertionError):
        script.pip(
            "install", "-vvv", "-r", script.scratch_path / "file-egg-req.txt"
        )


def test_relative_requirements_file(script, data):
    """
    Test installing from a requirements file with a relative path with an
    egg= definition..

    """
    url = path_to_url(
        os.path.join(data.root, "packages", "..", "packages", "FSPkg")
    ) + '#egg=FSPkg'
    script.scratch_path.join("file-egg-req.txt").write(textwrap.dedent("""\
        %s
        """ % url))
    result = script.pip(
        'install', '-vvv', '-r', script.scratch_path / 'file-egg-req.txt'
    )
    assert (
        script.site_packages / 'FSPkg-0.1dev-py%s.egg-info' % pyversion
    ) in result.files_created, str(result)
    assert (script.site_packages / 'fspkg') in result.files_created, (
        str(result.stdout)
    )


def test_multiple_requirements_files(script, tmpdir):
    """
    Test installing from multiple nested requirements files.

    """
    other_lib_name, other_lib_version = 'anyjson', '0.3'
    script.scratch_path.join("initools-req.txt").write(
        textwrap.dedent("""
            -e %s@10#egg=INITools-dev
            -r %s-req.txt
        """) %
        (
            local_checkout(
                'svn+http://svn.colorstudy.com/INITools/trunk',
                tmpdir.join("cache"),
            ),
            other_lib_name
        ),
    )
    script.scratch_path.join("%s-req.txt" % other_lib_name).write(
        "%s<=%s" % (other_lib_name, other_lib_version)
    )
    result = script.pip(
        'install', '-r', script.scratch_path / 'initools-req.txt'
    )
    assert result.files_created[script.site_packages / other_lib_name].dir
    fn = '%s-%s-py%s.egg-info' % (other_lib_name, other_lib_version, pyversion)
    assert result.files_created[script.site_packages / fn].dir
    assert script.venv / 'src' / 'initools' in result.files_created


def test_respect_order_in_requirements_file(script, data):
    script.scratch_path.join("frameworks-req.txt").write(textwrap.dedent("""\
        parent
        child
        simple
        """))

    result = script.pip(
        'install', '--no-index', '-f', data.find_links, '-r',
        script.scratch_path / 'frameworks-req.txt'
    )

    downloaded = [line for line in result.stdout.split('\n')
                  if 'Downloading/unpacking' in line]

    assert 'parent' in downloaded[0], (
        'First download should be "parent" but was "%s"' % downloaded[0]
    )
    assert 'child' in downloaded[1], (
        'Second download should be "child" but was "%s"' % downloaded[1]
    )
    assert 'simple' in downloaded[2], (
        'Third download should be "simple" but was "%s"' % downloaded[2]
    )


def test_install_local_editable_with_subdirectory(script):
    version_pkg_path = _create_test_package_with_subdirectory(script,
                                                              'version_subdir')
    result = script.pip(
        'install', '-e',
        '%s#egg=version_subpkg&subdirectory=version_subdir' %
        ('git+file://%s' % version_pkg_path,)
    )

    result.assert_installed('version-subpkg', sub_dir='version_subdir')

########NEW FILE########
__FILENAME__ = test_install_upgrade
import os
import sys
import textwrap

import pytest

from tests.lib import (
    assert_all_changes, pyversion, _create_test_package,
    _change_test_package_version,
)
from tests.lib.local_repos import local_checkout


def test_no_upgrade_unless_requested(script):
    """
    No upgrade if not specifically requested.

    """
    script.pip('install', 'INITools==0.1', expect_error=True)
    result = script.pip('install', 'INITools', expect_error=True)
    assert not result.files_created, (
        'pip install INITools upgraded when it should not have'
    )


def test_upgrade_to_specific_version(script):
    """
    It does upgrade to specific version requested.

    """
    script.pip('install', 'INITools==0.1', expect_error=True)
    result = script.pip('install', 'INITools==0.2', expect_error=True)
    assert result.files_created, (
        'pip install with specific version did not upgrade'
    )
    assert (
        script.site_packages / 'INITools-0.1-py%s.egg-info' %
        pyversion in result.files_deleted
    )
    assert (
        script.site_packages / 'INITools-0.2-py%s.egg-info' %
        pyversion in result.files_created
    )


def test_upgrade_if_requested(script):
    """
    And it does upgrade if requested.

    """
    script.pip('install', 'INITools==0.1', expect_error=True)
    result = script.pip('install', '--upgrade', 'INITools', expect_error=True)
    assert result.files_created, 'pip install --upgrade did not upgrade'
    assert (
        script.site_packages / 'INITools-0.1-py%s.egg-info' %
        pyversion not in result.files_created
    )


def test_upgrade_with_newest_already_installed(script, data):
    """
    If the newest version of a package is already installed, the package should
    not be reinstalled and the user should be informed.
    """
    script.pip('install', '-f', data.find_links, '--no-index', 'simple')
    result = script.pip(
        'install', '--upgrade', '-f', data.find_links, '--no-index', 'simple'
    )
    assert not result.files_created, 'simple upgraded when it should not have'
    assert 'already up-to-date' in result.stdout, result.stdout


def test_upgrade_force_reinstall_newest(script):
    """
    Force reinstallation of a package even if it is already at its newest
    version if --force-reinstall is supplied.
    """
    result = script.pip('install', 'INITools')
    assert script.site_packages / 'initools' in result.files_created, (
        sorted(result.files_created.keys())
    )
    result2 = script.pip(
        'install', '--upgrade', '--force-reinstall', 'INITools'
    )
    assert result2.files_updated, 'upgrade to INITools 0.3 failed'
    result3 = script.pip('uninstall', 'initools', '-y', expect_error=True)
    assert_all_changes(result, result3, [script.venv / 'build', 'cache'])


def test_uninstall_before_upgrade(script):
    """
    Automatic uninstall-before-upgrade.

    """
    result = script.pip('install', 'INITools==0.2', expect_error=True)
    assert script.site_packages / 'initools' in result.files_created, (
        sorted(result.files_created.keys())
    )
    result2 = script.pip('install', 'INITools==0.3', expect_error=True)
    assert result2.files_created, 'upgrade to INITools 0.3 failed'
    result3 = script.pip('uninstall', 'initools', '-y', expect_error=True)
    assert_all_changes(result, result3, [script.venv / 'build', 'cache'])


def test_uninstall_before_upgrade_from_url(script):
    """
    Automatic uninstall-before-upgrade from URL.

    """
    result = script.pip('install', 'INITools==0.2', expect_error=True)
    assert script.site_packages / 'initools' in result.files_created, (
        sorted(result.files_created.keys())
    )
    result2 = script.pip(
        'install',
        'http://pypi.python.org/packages/source/I/INITools/INITools-'
        '0.3.tar.gz',
        expect_error=True,
    )
    assert result2.files_created, 'upgrade to INITools 0.3 failed'
    result3 = script.pip('uninstall', 'initools', '-y', expect_error=True)
    assert_all_changes(result, result3, [script.venv / 'build', 'cache'])


def test_upgrade_to_same_version_from_url(script):
    """
    When installing from a URL the same version that is already installed, no
    need to uninstall and reinstall if --upgrade is not specified.

    """
    result = script.pip('install', 'INITools==0.3', expect_error=True)
    assert script.site_packages / 'initools' in result.files_created, (
        sorted(result.files_created.keys())
    )
    result2 = script.pip(
        'install',
        'http://pypi.python.org/packages/source/I/INITools/INITools-'
        '0.3.tar.gz',
        expect_error=True,
    )
    assert not result2.files_updated, 'INITools 0.3 reinstalled same version'
    result3 = script.pip('uninstall', 'initools', '-y', expect_error=True)
    assert_all_changes(result, result3, [script.venv / 'build', 'cache'])


def test_upgrade_from_reqs_file(script):
    """
    Upgrade from a requirements file.

    """
    script.scratch_path.join("test-req.txt").write(textwrap.dedent("""\
        PyLogo<0.4
        # and something else to test out:
        INITools==0.3
        """))
    install_result = script.pip(
        'install', '-r', script.scratch_path / 'test-req.txt'
    )
    script.scratch_path.join("test-req.txt").write(textwrap.dedent("""\
        PyLogo
        # and something else to test out:
        INITools
        """))
    script.pip(
        'install', '--upgrade', '-r', script.scratch_path / 'test-req.txt'
    )
    uninstall_result = script.pip(
        'uninstall', '-r', script.scratch_path / 'test-req.txt', '-y'
    )
    assert_all_changes(
        install_result,
        uninstall_result,
        [script.venv / 'build', 'cache', script.scratch / 'test-req.txt'],
    )


def test_uninstall_rollback(script, data):
    """
    Test uninstall-rollback (using test package with a setup.py
    crafted to fail on install).

    """
    result = script.pip(
        'install', '-f', data.find_links, '--no-index', 'broken==0.1'
    )
    assert script.site_packages / 'broken.py' in result.files_created, list(
        result.files_created.keys()
    )
    result2 = script.pip(
        'install', '-f', data.find_links, '--no-index', 'broken==0.2broken',
        expect_error=True,
    )
    assert result2.returncode == 1, str(result2)
    assert script.run(
        'python', '-c', "import broken; print(broken.VERSION)"
    ).stdout == '0.1\n'
    assert_all_changes(
        result.files_after,
        result2,
        [script.venv / 'build', 'pip-log.txt'],
    )


# Issue #530 - temporarily disable flaky test
@pytest.mark.skipif
def test_editable_git_upgrade(script):
    """
    Test installing an editable git package from a repository, upgrading the
    repository, installing again, and check it gets the newer version
    """
    version_pkg_path = _create_test_package(script)
    script.pip(
        'install', '-e',
        '%s#egg=version_pkg' % ('git+file://' + version_pkg_path),
    )
    version = script.run('version_pkg')
    assert '0.1' in version.stdout
    _change_test_package_version(script, version_pkg_path)
    script.pip(
        'install', '-e',
        '%s#egg=version_pkg' % ('git+file://' + version_pkg_path),
    )
    version2 = script.run('version_pkg')
    assert 'some different version' in version2.stdout, (
        "Output: %s" % (version2.stdout)
    )


def test_should_not_install_always_from_cache(script):
    """
    If there is an old cached package, pip should download the newer version
    Related to issue #175
    """
    script.pip('install', 'INITools==0.2', expect_error=True)
    script.pip('uninstall', '-y', 'INITools')
    result = script.pip('install', 'INITools==0.1', expect_error=True)
    assert (
        script.site_packages / 'INITools-0.2-py%s.egg-info' %
        pyversion not in result.files_created
    )
    assert (
        script.site_packages / 'INITools-0.1-py%s.egg-info' %
        pyversion in result.files_created
    )


def test_install_with_ignoreinstalled_requested(script):
    """
    Test old conflicting package is completely ignored
    """
    script.pip('install', 'INITools==0.1', expect_error=True)
    result = script.pip('install', '-I', 'INITools==0.3', expect_error=True)
    assert result.files_created, 'pip install -I did not install'
    # both the old and new metadata should be present.
    assert os.path.exists(
        script.site_packages_path / 'INITools-0.1-py%s.egg-info' % pyversion
    )
    assert os.path.exists(
        script.site_packages_path / 'INITools-0.3-py%s.egg-info' % pyversion
    )


def test_upgrade_vcs_req_with_no_dists_found(script, tmpdir):
    """It can upgrade a VCS requirement that has no distributions otherwise."""
    req = "%s#egg=pip-test-package" % local_checkout(
        "git+http://github.com/pypa/pip-test-package.git",
        tmpdir.join("cache"),
    )
    script.pip("install", req)
    result = script.pip("install", "-U", req)
    assert not result.returncode


def test_upgrade_vcs_req_with_dist_found(script):
    """It can upgrade a VCS requirement that has distributions on the index."""
    # TODO(pnasrat) Using local_checkout fails on windows - oddness with the
    # test path urls/git.
    req = (
        "%s#egg=pretend" %
        (
            "git+git://github.com/alex/pretend@e7f26ad7dbcb4a02a4995aade4"
            "743aad47656b27"
        )
    )
    script.pip("install", req)
    result = script.pip("install", "-U", req)
    assert "pypi.python.org" not in result.stdout, result.stdout


class TestUpgradeSetuptools(object):
    """
    Tests for upgrading to setuptools (using pip from src tree)
    The tests use a *fixed* set of packages from our test packages dir
    note: virtualenv-1.9.1 contains distribute-0.6.34
    note: virtualenv-1.10 contains setuptools-0.9.7
    """

    def prep_ve(self, script, version, pip_src, distribute=False):
        self.script = script
        self.script.pip_install_local('virtualenv==%s' % version)
        args = ['virtualenv', self.script.scratch_path / 'VE']
        if distribute:
            args.insert(1, '--distribute')
        if version == "1.9.1" and not distribute:
            # setuptools 0.6 didn't support PYTHONDONTWRITEBYTECODE
            del self.script.environ["PYTHONDONTWRITEBYTECODE"]
        self.script.run(*args)
        if sys.platform == 'win32':
            bindir = "Scripts"
        else:
            bindir = "bin"
        self.ve_bin = self.script.scratch_path / 'VE' / bindir
        self.script.run(self.ve_bin / 'pip', 'uninstall', '-y', 'pip')
        self.script.run(
            self.ve_bin / 'python', 'setup.py', 'install',
            cwd=pip_src,
            expect_stderr=True,
        )

    @pytest.mark.skipif("sys.version_info >= (3,0)")
    def test_py2_from_setuptools_6_to_setuptools_7(
            self, script, data, virtualenv):
        self.prep_ve(script, '1.9.1', virtualenv.pip_source_dir)
        result = self.script.run(
            self.ve_bin / 'pip', 'install', '--no-use-wheel', '--no-index',
            '--find-links=%s' % data.find_links, '-U', 'setuptools'
        )
        assert (
            "Found existing installation: setuptools 0.6c11" in result.stdout
        )
        result = self.script.run(self.ve_bin / 'pip', 'list')
        "setuptools (0.9.8)" in result.stdout

    def test_py2_py3_from_distribute_6_to_setuptools_7(
            self, script, data, virtualenv):
        self.prep_ve(
            script, '1.9.1', virtualenv.pip_source_dir, distribute=True
        )
        result = self.script.run(
            self.ve_bin / 'pip', 'install', '--no-index',
            '--find-links=%s' % data.find_links, '-U', 'setuptools'
        )
        assert (
            "Found existing installation: distribute 0.6.34" in result.stdout
        )
        result = self.script.run(self.ve_bin / 'pip', 'list')
        "setuptools (0.9.8)" in result.stdout
        "distribute (0.7.3)" in result.stdout

    def test_from_setuptools_7_to_setuptools_7(self, script, data, virtualenv):
        self.prep_ve(script, '1.10', virtualenv.pip_source_dir)
        result = self.script.run(
            self.ve_bin / 'pip', 'install', '--no-index',
            '--find-links=%s' % data.find_links, '-U', 'setuptools'
        )
        assert "Found existing installation: setuptools 0.9.7" in result.stdout
        result = self.script.run(self.ve_bin / 'pip', 'list')
        "setuptools (0.9.8)" in result.stdout

    def test_from_setuptools_7_to_setuptools_7_using_wheel(
            self, script, data, virtualenv):
        self.prep_ve(script, '1.10', virtualenv.pip_source_dir)
        result = self.script.run(
            self.ve_bin / 'pip', 'install', '--use-wheel', '--no-index',
            '--find-links=%s' % data.find_links, '-U', 'setuptools'
        )
        assert "Found existing installation: setuptools 0.9.7" in result.stdout
        # only wheels use dist-info
        assert 'setuptools-0.9.8.dist-info' in str(result.files_created)
        result = self.script.run(self.ve_bin / 'pip', 'list')
        "setuptools (0.9.8)" in result.stdout

    # disabling intermittent travis failure:
    #   https://github.com/pypa/pip/issues/1379
    @pytest.mark.skipif("hasattr(sys, 'pypy_version_info')")
    def test_from_setuptools_7_to_setuptools_7_with_distribute_7_installed(
            self, script, data, virtualenv):
        self.prep_ve(
            script, '1.9.1', virtualenv.pip_source_dir, distribute=True
        )
        result = self.script.run(
            self.ve_bin / 'pip', 'install', '--no-index',
            '--find-links=%s' % data.find_links, '-U', 'setuptools'
        )
        result = self.script.run(
            self.ve_bin / 'pip', 'install', '--no-index',
            '--find-links=%s' % data.find_links, 'setuptools==0.9.6'
        )
        result = self.script.run(self.ve_bin / 'pip', 'list')
        "setuptools (0.9.6)" in result.stdout
        "distribute (0.7.3)" in result.stdout
        result = self.script.run(
            self.ve_bin / 'pip', 'install', '--no-index',
            '--find-links=%s' % data.find_links, '-U', 'setuptools'
        )
        assert "Found existing installation: setuptools 0.9.6" in result.stdout
        result = self.script.run(self.ve_bin / 'pip', 'list')
        "setuptools (0.9.8)" in result.stdout
        "distribute (0.7.3)" in result.stdout

########NEW FILE########
__FILENAME__ = test_install_user
"""
tests specific to "pip install --user"
"""
import imp
import os
import textwrap

from os.path import curdir, isdir, isfile

from pip.compat import uses_pycache

from tests.lib.local_repos import local_checkout
from tests.lib import pyversion


def _patch_dist_in_site_packages(script):
    sitecustomize_path = script.lib_path.join("sitecustomize.py")
    sitecustomize_path.write(textwrap.dedent("""
        def dist_in_site_packages(dist):
            return False

        from pip.req import req_install
        req_install.dist_in_site_packages = dist_in_site_packages
    """))

    # Caught py32 with an outdated __pycache__ file after a sitecustomize
    #   update (after python should have updated it) so will delete the cache
    #   file to be sure
    #   See: https://github.com/pypa/pip/pull/893#issuecomment-16426701
    if uses_pycache:
        cache_path = imp.cache_from_source(sitecustomize_path)
        if os.path.isfile(cache_path):
            os.remove(cache_path)


class Tests_UserSite:

    def test_reset_env_system_site_packages_usersite(self, script, virtualenv):
        """
        reset_env(system_site_packages=True) produces env where a --user
        install can be found using pkg_resources
        """
        virtualenv.system_site_packages = True
        script.pip('install', '--user', 'INITools==0.2')
        result = script.run(
            'python', '-c',
            "import pkg_resources; print(pkg_resources.get_distribution"
            "('initools').project_name)",
        )
        project_name = result.stdout.strip()
        assert (
            'INITools' == project_name, "'%s' should be 'INITools'" %
            project_name
        )

    def test_install_subversion_usersite_editable_with_distribute(
            self, script, virtualenv, tmpdir):
        """
        Test installing current directory ('.') into usersite after installing
        distribute
        """
        virtualenv.system_site_packages = True
        result = script.pip(
            'install', '--user', '-e',
            '%s#egg=initools-dev' %
            local_checkout(
                'svn+http://svn.colorstudy.com/INITools/trunk',
                tmpdir.join("cache"),
            )
        )
        result.assert_installed('INITools', use_user_site=True)

    def test_install_curdir_usersite(self, script, virtualenv, data):
        """
        Test installing current directory ('.') into usersite
        """
        virtualenv.system_site_packages = True
        run_from = data.packages.join("FSPkg")
        result = script.pip(
            'install', '-vvv', '--user', curdir,
            cwd=run_from,
            expect_error=False,
        )
        fspkg_folder = script.user_site / 'fspkg'
        egg_info_folder = (
            script.user_site / 'FSPkg-0.1dev-py%s.egg-info' % pyversion
        )
        assert fspkg_folder in result.files_created, result.stdout

        assert egg_info_folder in result.files_created

    def test_install_user_venv_nositepkgs_fails(self, script, data):
        """
        user install in virtualenv (with no system packages) fails with message
        """
        run_from = data.packages.join("FSPkg")
        result = script.pip(
            'install', '--user', curdir,
            cwd=run_from,
            expect_error=True,
        )
        assert (
            "Can not perform a '--user' install. User site-packages are not "
            "visible in this virtualenv." in result.stdout
        )

    def test_install_user_conflict_in_usersite(self, script, virtualenv):
        """
        Test user install with conflict in usersite updates usersite.
        """
        virtualenv.system_site_packages = True

        script.pip('install', '--user', 'INITools==0.3')

        result2 = script.pip('install', '--user', 'INITools==0.1')

        # usersite has 0.1
        egg_info_folder = (
            script.user_site / 'INITools-0.1-py%s.egg-info' % pyversion
        )
        initools_v3_file = (
            # file only in 0.3
            script.base_path / script.user_site / 'initools' /
            'configparser.py'
        )
        assert egg_info_folder in result2.files_created, str(result2)
        assert not isfile(initools_v3_file), initools_v3_file

    def test_install_user_conflict_in_globalsite(self, script, virtualenv):
        """
        Test user install with conflict in global site ignores site and
        installs to usersite
        """
        # the test framework only supports testing using virtualenvs
        # the sys.path ordering for virtualenvs with --system-site-packages is
        # this: virtualenv-site, user-site, global-site
        # this test will use 2 modifications to simulate the
        # user-site/global-site relationship
        # 1) a monkey patch which will make it appear INITools==0.2 is not in
        #    the virtualenv site if we don't patch this, pip will return an
        #    installation error:  "Will not install to the usersite because it
        #    will lack sys.path precedence..."
        # 2) adding usersite to PYTHONPATH, so usersite as sys.path precedence
        #    over the virtualenv site

        virtualenv.system_site_packages = True
        script.environ["PYTHONPATH"] = script.base_path / script.user_site
        _patch_dist_in_site_packages(script)

        script.pip('install', 'INITools==0.2')

        result2 = script.pip('install', '--user', 'INITools==0.1')

        # usersite has 0.1
        egg_info_folder = (
            script.user_site / 'INITools-0.1-py%s.egg-info' % pyversion
        )
        initools_folder = script.user_site / 'initools'
        assert egg_info_folder in result2.files_created, str(result2)
        assert initools_folder in result2.files_created, str(result2)

        # site still has 0.2 (can't look in result1; have to check)
        egg_info_folder = (
            script.base_path / script.site_packages /
            'INITools-0.2-py%s.egg-info' % pyversion
        )
        initools_folder = script.base_path / script.site_packages / 'initools'
        assert isdir(egg_info_folder)
        assert isdir(initools_folder)

    def test_upgrade_user_conflict_in_globalsite(self, script, virtualenv):
        """
        Test user install/upgrade with conflict in global site ignores site and
        installs to usersite
        """
        # the test framework only supports testing using virtualenvs
        # the sys.path ordering for virtualenvs with --system-site-packages is
        # this: virtualenv-site, user-site, global-site
        # this test will use 2 modifications to simulate the
        # user-site/global-site relationship
        # 1) a monkey patch which will make it appear INITools==0.2 is not in
        #    the virtualenv site if we don't patch this, pip will return an
        #    installation error:  "Will not install to the usersite because it
        #    will lack sys.path precedence..."
        # 2) adding usersite to PYTHONPATH, so usersite as sys.path precedence
        #    over the virtualenv site

        virtualenv.system_site_packages = True
        script.environ["PYTHONPATH"] = script.base_path / script.user_site
        _patch_dist_in_site_packages(script)

        script.pip('install', 'INITools==0.2')
        result2 = script.pip('install', '--user', '--upgrade', 'INITools')

        # usersite has 0.3.1
        egg_info_folder = (
            script.user_site / 'INITools-0.3.1-py%s.egg-info' % pyversion
        )
        initools_folder = script.user_site / 'initools'
        assert egg_info_folder in result2.files_created, str(result2)
        assert initools_folder in result2.files_created, str(result2)

        # site still has 0.2 (can't look in result1; have to check)
        egg_info_folder = (
            script.base_path / script.site_packages /
            'INITools-0.2-py%s.egg-info' % pyversion
        )
        initools_folder = script.base_path / script.site_packages / 'initools'
        assert isdir(egg_info_folder), result2.stdout
        assert isdir(initools_folder)

    def test_install_user_conflict_in_globalsite_and_usersite(
            self, script, virtualenv):
        """
        Test user install with conflict in globalsite and usersite ignores
        global site and updates usersite.
        """
        # the test framework only supports testing using virtualenvs.
        # the sys.path ordering for virtualenvs with --system-site-packages is
        # this: virtualenv-site, user-site, global-site.
        # this test will use 2 modifications to simulate the
        # user-site/global-site relationship
        # 1) a monkey patch which will make it appear INITools==0.2 is not in
        #    the virtualenv site if we don't patch this, pip will return an
        #    installation error:  "Will not install to the usersite because it
        #    will lack sys.path precedence..."
        # 2) adding usersite to PYTHONPATH, so usersite as sys.path precedence
        #    over the virtualenv site

        virtualenv.system_site_packages = True
        script.environ["PYTHONPATH"] = script.base_path / script.user_site
        _patch_dist_in_site_packages(script)

        script.pip('install', 'INITools==0.2')
        script.pip('install', '--user', 'INITools==0.3')

        result3 = script.pip('install', '--user', 'INITools==0.1')

        # usersite has 0.1
        egg_info_folder = (
            script.user_site / 'INITools-0.1-py%s.egg-info' % pyversion
        )
        initools_v3_file = (
            # file only in 0.3
            script.base_path / script.user_site / 'initools' /
            'configparser.py'
        )
        assert egg_info_folder in result3.files_created, str(result3)
        assert not isfile(initools_v3_file), initools_v3_file

        # site still has 0.2 (can't just look in result1; have to check)
        egg_info_folder = (
            script.base_path / script.site_packages /
            'INITools-0.2-py%s.egg-info' % pyversion
        )
        initools_folder = script.base_path / script.site_packages / 'initools'
        assert isdir(egg_info_folder)
        assert isdir(initools_folder)

    def test_install_user_in_global_virtualenv_with_conflict_fails(
            self, script, virtualenv):
        """
        Test user install in --system-site-packages virtualenv with conflict in
        site fails.
        """
        virtualenv.system_site_packages = True

        script.pip('install', 'INITools==0.2')

        result2 = script.pip(
            'install', '--user', 'INITools==0.1',
            expect_error=True,
        )
        resultp = script.run(
            'python', '-c',
            "import pkg_resources; print(pkg_resources.get_distribution"
            "('initools').location)",
        )
        dist_location = resultp.stdout.strip()
        assert (
            "Will not install to the user site because it will lack sys.path "
            "precedence to %s in %s" %
            ('INITools', dist_location) in result2.stdout, result2.stdout
        )

########NEW FILE########
__FILENAME__ = test_install_vcs
from tests.lib import _create_test_package, _change_test_package_version
from tests.lib.local_repos import local_checkout


def test_install_editable_from_git_with_https(script, tmpdir):
    """
    Test cloning from Git with https.
    """
    result = script.pip(
        'install', '-e',
        '%s#egg=pip-test-package' %
        local_checkout(
            'git+https://github.com/pypa/pip-test-package.git',
            tmpdir.join("cache"),
        ),
        expect_error=True,
    )
    result.assert_installed('pip-test-package', with_files=['.git'])


def test_git_with_sha1_revisions(script):
    """
    Git backend should be able to install from SHA1 revisions
    """
    version_pkg_path = _create_test_package(script)
    _change_test_package_version(script, version_pkg_path)
    sha1 = script.run(
        'git', 'rev-parse', 'HEAD~1',
        cwd=version_pkg_path,
    ).stdout.strip()
    script.pip(
        'install', '-e',
        '%s@%s#egg=version_pkg' %
        ('git+file://' + version_pkg_path.abspath.replace('\\', '/'), sha1)
    )
    version = script.run('version_pkg')
    assert '0.1' in version.stdout, version.stdout


def test_git_with_branch_name_as_revision(script):
    """
    Git backend should be able to install from branch names
    """
    version_pkg_path = _create_test_package(script)
    script.run(
        'git', 'checkout', '-b', 'test_branch',
        expect_stderr=True,
        cwd=version_pkg_path,
    )
    _change_test_package_version(script, version_pkg_path)
    script.pip(
        'install', '-e', '%s@test_branch#egg=version_pkg' %
        ('git+file://' + version_pkg_path.abspath.replace('\\', '/'))
    )
    version = script.run('version_pkg')
    assert 'some different version' in version.stdout


def test_git_with_tag_name_as_revision(script):
    """
    Git backend should be able to install from tag names
    """
    version_pkg_path = _create_test_package(script)
    script.run(
        'git', 'tag', 'test_tag',
        expect_stderr=True,
        cwd=version_pkg_path,
    )
    _change_test_package_version(script, version_pkg_path)
    script.pip(
        'install', '-e', '%s@test_tag#egg=version_pkg' %
        ('git+file://' + version_pkg_path.abspath.replace('\\', '/'))
    )
    version = script.run('version_pkg')
    assert '0.1' in version.stdout


def test_git_with_tag_name_and_update(script, tmpdir):
    """
    Test cloning a git repository and updating to a different version.
    """
    result = script.pip(
        'install', '-e', '%s#egg=pip-test-package' %
        local_checkout(
            'git+http://github.com/pypa/pip-test-package.git',
            tmpdir.join("cache"),
        ),
        expect_error=True,
    )
    result.assert_installed('pip-test-package', with_files=['.git'])
    result = script.pip(
        'install', '--global-option=--version', '-e',
        '%s@0.1.2#egg=pip-test-package' %
        local_checkout(
            'git+http://github.com/pypa/pip-test-package.git',
            tmpdir.join("cache"),
        ),
        expect_error=True,
    )
    assert '0.1.2' in result.stdout


def test_git_branch_should_not_be_changed(script, tmpdir):
    """
    Editable installations should not change branch
    related to issue #32 and #161
    """
    script.pip(
        'install', '-e', '%s#egg=pip-test-package' %
        local_checkout(
            'git+http://github.com/pypa/pip-test-package.git',
            tmpdir.join("cache"),
        ),
        expect_error=True,
    )
    source_dir = script.venv_path / 'src' / 'pip-test-package'
    result = script.run('git', 'branch', cwd=source_dir)
    assert '* master' in result.stdout, result.stdout


def test_git_with_non_editable_unpacking(script, tmpdir):
    """
    Test cloning a git repository from a non-editable URL with a given tag.
    """
    result = script.pip(
        'install', '--global-option=--version',
        local_checkout(
            'git+http://github.com/pypa/pip-test-package.git@0.1.2'
            '#egg=pip-test-package',
            tmpdir.join("cache")
        ),
        expect_error=True,
    )
    assert '0.1.2' in result.stdout


def test_git_with_editable_where_egg_contains_dev_string(script, tmpdir):
    """
    Test cloning a git repository from an editable url which contains "dev"
    string
    """
    result = script.pip(
        'install', '-e',
        '%s#egg=django-devserver' %
        local_checkout(
            'git+git://github.com/dcramer/django-devserver.git',
            tmpdir.join("cache")
        )
    )
    result.assert_installed('django-devserver', with_files=['.git'])


def test_git_with_non_editable_where_egg_contains_dev_string(script, tmpdir):
    """
    Test cloning a git repository from a non-editable url which contains "dev"
    string
    """
    result = script.pip(
        'install',
        '%s#egg=django-devserver' %
        local_checkout(
            'git+git://github.com/dcramer/django-devserver.git',
            tmpdir.join("cache")
        ),
    )
    devserver_folder = script.site_packages / 'devserver'
    assert devserver_folder in result.files_created, str(result)


def test_git_with_ambiguous_revs(script):
    """
    Test git with two "names" (tag/branch) pointing to the same commit
    """
    version_pkg_path = _create_test_package(script)
    package_url = (
        'git+file://%s@0.1#egg=version_pkg' %
        (version_pkg_path.abspath.replace('\\', '/'))
    )
    script.run('git', 'tag', '0.1', cwd=version_pkg_path)
    result = script.pip('install', '-e', package_url)
    assert 'Could not find a tag or branch' not in result.stdout
    # it is 'version-pkg' instead of 'version_pkg' because
    # egg-link name is version-pkg.egg-link because it is a single .py module
    result.assert_installed('version-pkg', with_files=['.git'])


def test_git_works_with_editable_non_origin_repo(script):
    # set up, create a git repo and install it as editable from a local
    # directory path
    version_pkg_path = _create_test_package(script)
    script.pip('install', '-e', version_pkg_path.abspath)

    # 'freeze'ing this should not fall over, but should result in stderr output
    # warning
    result = script.pip('freeze', expect_stderr=True)
    assert "Error when trying to get requirement" in result.stderr
    assert "Could not determine repository location" in result.stdout
    assert "version-pkg==0.1" in result.stdout

########NEW FILE########
__FILENAME__ = test_install_vcs_git
import pytest

from mock import patch

from pip.vcs.git import Git
from tests.lib import _create_test_package
from tests.lib.git_submodule_helpers import (
    _change_test_package_submodule,
    _pull_in_submodule_changes_to_module,
    _create_test_package_with_submodule,
)


def test_get_refs_should_return_tag_name_and_commit_pair(script):
    version_pkg_path = _create_test_package(script)
    script.run('git', 'tag', '0.1', cwd=version_pkg_path)
    script.run('git', 'tag', '0.2', cwd=version_pkg_path)
    commit = script.run(
        'git', 'rev-parse', 'HEAD',
        cwd=version_pkg_path
    ).stdout.strip()
    git = Git()
    result = git.get_refs(version_pkg_path)
    assert result['0.1'] == commit, result
    assert result['0.2'] == commit, result


def test_get_refs_should_return_branch_name_and_commit_pair(script):
    version_pkg_path = _create_test_package(script)
    script.run('git', 'branch', 'branch0.1', cwd=version_pkg_path)
    commit = script.run(
        'git', 'rev-parse', 'HEAD',
        cwd=version_pkg_path
    ).stdout.strip()
    git = Git()
    result = git.get_refs(version_pkg_path)
    assert result['master'] == commit, result
    assert result['branch0.1'] == commit, result


def test_get_refs_should_ignore_no_branch(script):
    version_pkg_path = _create_test_package(script)
    script.run('git', 'branch', 'branch0.1', cwd=version_pkg_path)
    commit = script.run(
        'git', 'rev-parse', 'HEAD',
        cwd=version_pkg_path
    ).stdout.strip()
    # current branch here is "* (nobranch)"
    script.run(
        'git', 'checkout', commit,
        cwd=version_pkg_path,
        expect_stderr=True,
    )
    git = Git()
    result = git.get_refs(version_pkg_path)
    assert result['master'] == commit, result
    assert result['branch0.1'] == commit, result


@patch('pip.vcs.git.Git.get_refs')
def test_check_rev_options_should_handle_branch_name(get_refs_mock):
    get_refs_mock.return_value = {'master': '123456', '0.1': '123456'}
    git = Git()

    result = git.check_rev_options('master', '.', [])
    assert result == ['123456']


@patch('pip.vcs.git.Git.get_refs')
def test_check_rev_options_should_handle_tag_name(get_refs_mock):
    get_refs_mock.return_value = {'master': '123456', '0.1': '123456'}
    git = Git()

    result = git.check_rev_options('0.1', '.', [])
    assert result == ['123456']


@patch('pip.vcs.git.Git.get_refs')
def test_check_rev_options_should_handle_ambiguous_commit(get_refs_mock):
    get_refs_mock.return_value = {'master': '123456', '0.1': '123456'}
    git = Git()

    result = git.check_rev_options('0.1', '.', [])
    assert result == ['123456'], result


# TODO(pnasrat) fix all helpers to do right things with paths on windows.
@pytest.mark.skipif("sys.platform == 'win32'")
def test_check_submodule_addition(script):
    """
    Submodules are pulled in on install and updated on upgrade.
    """
    module_path, submodule_path = _create_test_package_with_submodule(script)

    install_result = script.pip(
        'install', '-e', 'git+' + module_path + '#egg=version_pkg'
    )
    assert (
        script.venv / 'src/version-pkg/testpkg/static/testfile'
        in install_result.files_created
    )

    _change_test_package_submodule(script, submodule_path)
    _pull_in_submodule_changes_to_module(script, module_path)

    # expect error because git may write to stderr
    update_result = script.pip(
        'install', '-e', 'git+' + module_path + '#egg=version_pkg',
        '--upgrade',
        expect_error=True,
    )

    assert (
        script.venv / 'src/version-pkg/testpkg/static/testfile2'
        in update_result.files_created
    )

########NEW FILE########
__FILENAME__ = test_install_vcs_svn
from mock import patch
from pip.vcs.subversion import Subversion


@patch('pip.vcs.subversion.call_subprocess')
def test_obtain_should_recognize_auth_info_url(call_subprocess_mock, script):
    svn = Subversion(url='svn+http://username:password@svn.example.com/')
    svn.obtain(script.scratch_path / 'test')
    call_subprocess_mock.assert_called_with([
        svn.cmd, 'checkout', '-q', '--username', 'username', '--password',
        'password', 'http://username:password@svn.example.com/',
        script.scratch_path / 'test',
    ])


@patch('pip.vcs.subversion.call_subprocess')
def test_export_should_recognize_auth_info_url(call_subprocess_mock, script):
    svn = Subversion(url='svn+http://username:password@svn.example.com/')
    svn.export(script.scratch_path / 'test')
    assert call_subprocess_mock.call_args[0] == (
        [
            svn.cmd, 'export', '--username', 'username', '--password',
            'password', 'http://username:password@svn.example.com/',
            script.scratch_path / 'test',
        ],
    )

########NEW FILE########
__FILENAME__ = test_install_wheel
import os
import pytest
import glob

from tests.lib.path import Path
from tests.lib import TestFailure


def test_install_from_future_wheel_version(script, data):
    """
    Test installing a future wheel
    """
    package = data.packages.join("futurewheel-3.0-py2.py3-none-any.whl")
    result = script.pip('install', package, '--no-index', expect_error=True)
    with pytest.raises(TestFailure):
        result.assert_installed('futurewheel', without_egg_link=True,
                                editable=False)

    package = data.packages.join("futurewheel-1.9-py2.py3-none-any.whl")
    result = script.pip('install', package, '--no-index', expect_error=False)
    result.assert_installed('futurewheel', without_egg_link=True,
                            editable=False)


def test_install_from_broken_wheel(script, data):
    """
    Test that installing a broken wheel fails properly
    """
    package = data.packages.join("brokenwheel-1.0-py2.py3-none-any.whl")
    result = script.pip('install', package, '--no-index', expect_error=True)
    with pytest.raises(TestFailure):
        result.assert_installed('futurewheel', without_egg_link=True,
                                editable=False)


def test_install_from_wheel(script, data):
    """
    Test installing from a wheel (that has a script)
    """
    result = script.pip(
        'install', 'has.script==1.0', '--use-wheel', '--no-index',
        '--find-links=' + data.find_links,
        expect_error=False,
    )
    dist_info_folder = script.site_packages / 'has.script-1.0.dist-info'
    assert dist_info_folder in result.files_created, (dist_info_folder,
                                                      result.files_created,
                                                      result.stdout)
    script_file = script.bin / 'script.py'
    assert script_file in result.files_created


def test_install_from_wheel_with_extras(script, data):
    """
    Test installing from a wheel with extras.
    """
    result = script.pip(
        'install', 'complex-dist[simple]', '--use-wheel', '--no-index',
        '--find-links=' + data.find_links,
        expect_error=False,
    )
    dist_info_folder = script.site_packages / 'complex_dist-0.1.dist-info'
    assert dist_info_folder in result.files_created, (dist_info_folder,
                                                      result.files_created,
                                                      result.stdout)
    dist_info_folder = script.site_packages / 'simple.dist-0.1.dist-info'
    assert dist_info_folder in result.files_created, (dist_info_folder,
                                                      result.files_created,
                                                      result.stdout)


def test_install_from_wheel_file(script, data):
    """
    Test installing directly from a wheel file.
    """
    package = data.packages.join("simple.dist-0.1-py2.py3-none-any.whl")
    result = script.pip('install', package, '--no-index', expect_error=False)
    dist_info_folder = script.site_packages / 'simple.dist-0.1.dist-info'
    assert dist_info_folder in result.files_created, (dist_info_folder,
                                                      result.files_created,
                                                      result.stdout)


# header installs are broke in pypy virtualenvs
# https://github.com/pypa/virtualenv/issues/510
@pytest.mark.skipif("hasattr(sys, 'pypy_version_info')")
def test_install_from_wheel_with_headers(script, data):
    """
    Test installing from a wheel file with headers
    """
    package = data.packages.join("headers.dist-0.1-py2.py3-none-any.whl")
    result = script.pip('install', package, '--no-index', expect_error=False)
    dist_info_folder = script.site_packages / 'headers.dist-0.1.dist-info'
    assert dist_info_folder in result.files_created, (dist_info_folder,
                                                      result.files_created,
                                                      result.stdout)


def test_install_wheel_with_target(script, data):
    """
    Test installing a wheel using pip install --target
    """
    script.pip('install', 'wheel')
    target_dir = script.scratch_path / 'target'
    result = script.pip(
        'install', 'simple.dist==0.1', '-t', target_dir, '--use-wheel',
        '--no-index', '--find-links=' + data.find_links,
    )
    assert Path('scratch') / 'target' / 'simpledist' in result.files_created, (
        str(result)
    )


def test_install_wheel_with_root(script, data):
    """
    Test installing a wheel using pip install --root
    """
    root_dir = script.scratch_path / 'root'
    result = script.pip(
        'install', 'simple.dist==0.1', '--root', root_dir, '--use-wheel',
        '--no-index', '--find-links=' + data.find_links,
    )
    assert Path('scratch') / 'root' in result.files_created


def test_install_from_wheel_installs_deps(script, data):
    """
    Test can install dependencies of wheels
    """
    # 'requires_source' depends on the 'source' project
    package = data.packages.join("requires_source-1.0-py2.py3-none-any.whl")
    result = script.pip(
        'install', '--no-index', '--find-links', data.find_links, package,
    )
    result.assert_installed('source', editable=False)


def test_install_from_wheel_no_deps(script, data):
    """
    Test --no-deps works with wheel installs
    """
    # 'requires_source' depends on the 'source' project
    package = data.packages.join("requires_source-1.0-py2.py3-none-any.whl")
    result = script.pip(
        'install', '--no-index', '--find-links', data.find_links, '--no-deps',
        package,
    )
    pkg_folder = script.site_packages / 'source'
    assert pkg_folder not in result.files_created


def test_install_user_wheel(script, virtualenv, data):
    """
    Test user install from wheel (that has a script)
    """
    virtualenv.system_site_packages = True
    script.pip('install', 'wheel')
    result = script.pip(
        'install', 'has.script==1.0', '--user', '--use-wheel', '--no-index',
        '--find-links=' + data.find_links,
    )
    egg_info_folder = script.user_site / 'has.script-1.0.dist-info'
    assert egg_info_folder in result.files_created, str(result)
    script_file = script.user_bin / 'script.py'
    assert script_file in result.files_created


def test_install_from_wheel_gen_entrypoint(script, data):
    """
    Test installing scripts (entry points are generated)
    """
    result = script.pip(
        'install', 'script.wheel1a==0.1', '--use-wheel', '--no-index',
        '--find-links=' + data.find_links,
        expect_error=False,
    )
    if os.name == 'nt':
        wrapper_file = script.bin / 't1.exe'
    else:
        wrapper_file = script.bin / 't1'
    assert wrapper_file in result.files_created

    if os.name != "nt":
        assert bool(os.access(script.base_path / wrapper_file, os.X_OK))


def test_install_from_wheel_with_legacy(script, data):
    """
    Test installing scripts (legacy scripts are preserved)
    """
    result = script.pip(
        'install', 'script.wheel2a==0.1', '--use-wheel', '--no-index',
        '--find-links=' + data.find_links,
        expect_error=False,
    )

    legacy_file1 = script.bin / 'testscript1.bat'
    legacy_file2 = script.bin / 'testscript2'

    assert legacy_file1 in result.files_created
    assert legacy_file2 in result.files_created


def test_install_from_wheel_no_setuptools_entrypoint(script, data):
    """
    Test that when we generate scripts, any existing setuptools wrappers in
    the wheel are skipped.
    """
    result = script.pip(
        'install', 'script.wheel1==0.1', '--use-wheel', '--no-index',
        '--find-links=' + data.find_links,
        expect_error=False,
    )
    if os.name == 'nt':
        wrapper_file = script.bin / 't1.exe'
    else:
        wrapper_file = script.bin / 't1'
    wrapper_helper = script.bin / 't1-script.py'

    # The wheel has t1.exe and t1-script.py. We will be generating t1 or
    # t1.exe depending on the platform. So we check that the correct wrapper
    # is present and that the -script.py helper has been skipped. We can't
    # easily test that the wrapper from the wheel has been skipped /
    # overwritten without getting very platform-dependent, so omit that.
    assert wrapper_file in result.files_created
    assert wrapper_helper not in result.files_created


def test_skipping_setuptools_doesnt_skip_legacy(script, data):
    """
    Test installing scripts (legacy scripts are preserved even when we skip
    setuptools wrappers)
    """
    result = script.pip(
        'install', 'script.wheel2==0.1', '--use-wheel', '--no-index',
        '--find-links=' + data.find_links,
        expect_error=False,
    )

    legacy_file1 = script.bin / 'testscript1.bat'
    legacy_file2 = script.bin / 'testscript2'
    wrapper_helper = script.bin / 't1-script.py'

    assert legacy_file1 in result.files_created
    assert legacy_file2 in result.files_created
    assert wrapper_helper not in result.files_created


def test_install_from_wheel_gui_entrypoint(script, data):
    """
    Test installing scripts (gui entry points are generated)
    """
    result = script.pip(
        'install', 'script.wheel3==0.1', '--use-wheel', '--no-index',
        '--find-links=' + data.find_links,
        expect_error=False,
    )
    if os.name == 'nt':
        wrapper_file = script.bin / 't1.exe'
    else:
        wrapper_file = script.bin / 't1'
    assert wrapper_file in result.files_created


def test_wheel_compiles_pyc(script, data):
    """
    Test installing from wheel with --compile on
    """
    script.pip(
        "install", "--compile", "simple.dist==0.1", "--no-index",
        "--find-links=" + data.find_links
    )
    # There are many locations for the __init__.pyc file so attempt to find
    #   any of them
    exists = [
        os.path.exists(script.site_packages_path / "simpledist/__init__.pyc"),
    ]

    exists += glob.glob(
        script.site_packages_path / "simpledist/__pycache__/__init__*.pyc"
    )

    assert any(exists)


def test_wheel_no_compiles_pyc(script, data):
    """
    Test installing from wheel with --compile on
    """
    script.pip(
        "install", "--no-compile", "simple.dist==0.1", "--no-index",
        "--find-links=" + data.find_links
    )
    # There are many locations for the __init__.pyc file so attempt to find
    #   any of them
    exists = [
        os.path.exists(script.site_packages_path / "simpledist/__init__.pyc"),
    ]

    exists += glob.glob(
        script.site_packages_path / "simpledist/__pycache__/__init__*.pyc"
    )

    assert not any(exists)


def test_install_from_wheel_uninstalls_old_version(script, data):
    # regression test for https://github.com/pypa/pip/issues/1825
    package = data.packages.join("simplewheel-1.0-py2.py3-none-any.whl")
    result = script.pip('install', package, '--no-index', expect_error=True)
    package = data.packages.join("simplewheel-2.0-py2.py3-none-any.whl")
    result = script.pip('install', package, '--no-index', expect_error=False)
    dist_info_folder = script.site_packages / 'simplewheel-2.0.dist-info'
    assert dist_info_folder in result.files_created
    dist_info_folder = script.site_packages / 'simplewheel-1.0.dist-info'
    assert dist_info_folder not in result.files_created

########NEW FILE########
__FILENAME__ = test_list
import os


def test_list_command(script, data):
    """
    Test default behavior of list command.

    """
    script.pip(
        'install', '-f', data.find_links, '--no-index', 'simple==1.0',
        'simple2==3.0',
    )
    result = script.pip('list')
    assert 'simple (1.0)' in result.stdout, str(result)
    assert 'simple2 (3.0)' in result.stdout, str(result)


def test_local_flag(script, data):
    """
    Test the behavior of --local flag in the list command

    """
    script.pip('install', '-f', data.find_links, '--no-index', 'simple==1.0')
    result = script.pip('list', '--local')
    assert 'simple (1.0)' in result.stdout


def test_uptodate_flag(script, data):
    """
    Test the behavior of --uptodate flag in the list command

    """
    script.pip(
        'install', '-f', data.find_links, '--no-index', 'simple==1.0',
        'simple2==3.0',
    )
    script.pip(
        'install', '-e',
        'git+https://github.com/pypa/pip-test-package.git#egg=pip-test-package'
    )
    result = script.pip(
        'list', '-f', data.find_links, '--no-index', '--uptodate'
    )
    assert 'simple (1.0)' not in result.stdout  # 3.0 is latest
    assert 'pip-test-package' not in result.stdout  # editables excluded
    assert 'simple2 (3.0)' in result.stdout, str(result)


def test_outdated_flag(script, data):
    """
    Test the behavior of --outdated flag in the list command

    """
    script.pip(
        'install', '-f', data.find_links, '--no-index', 'simple==1.0',
        'simple2==3.0',
    )
    script.pip(
        'install', '-e',
        'git+https://github.com/pypa/pip-test-package.git#egg=pip-test-package'
    )
    result = script.pip(
        'list', '-f', data.find_links, '--no-index', '--outdated',
    )
    assert 'simple (Current: 1.0 Latest: 3.0)' in result.stdout
    assert 'pip-test-package' not in result.stdout  # editables excluded
    assert 'simple2' not in result.stdout, str(result)  # 3.0 is latest


def test_editables_flag(script, data):
    """
    Test the behavior of --editables flag in the list command
    """
    script.pip('install', '-f', data.find_links, '--no-index', 'simple==1.0')
    result = script.pip(
        'install', '-e',
        'git+https://github.com/pypa/pip-test-package.git#egg=pip-test-package'
    )
    result = script.pip('list', '--editable')
    assert 'simple (1.0)' not in result.stdout, str(result)
    assert os.path.join('src', 'pip-test-package') in result.stdout, (
        str(result)
    )

########NEW FILE########
__FILENAME__ = test_requests
import pytest


@pytest.mark.skipif
def test_timeout(script):
    result = script.pip(
        "--timeout", "0.01", "install", "-vvv", "INITools",
        expect_error=True,
    )
    assert (
        "Could not fetch URL https://pypi.python.org/simple/INITools/: "
        "timed out" in result.stdout
    )
    assert (
        "Could not fetch URL https://pypi.python.org/simple/: "
        "timed out" in result.stdout
    )

########NEW FILE########
__FILENAME__ = test_search
from pip.commands.search import (compare_versions,
                                 highest_version,
                                 transform_hits,
                                 SearchCommand)
from pip.status_codes import NO_MATCHES_FOUND, SUCCESS
from mock import Mock
from tests.lib import pyversion


if pyversion >= '3':
    VERBOSE_FALSE = False
else:
    VERBOSE_FALSE = 0


def test_version_compare():
    """
    Test version comparison.

    """
    assert compare_versions('1.0', '1.1') == -1
    assert compare_versions('1.1', '1.0') == 1
    assert compare_versions('1.1a1', '1.1') == -1
    assert compare_versions('1.1.1', '1.1a') == -1
    assert highest_version(['1.0', '2.0', '0.1']) == '2.0'
    assert highest_version(['1.0a1', '1.0']) == '1.0'


def test_pypi_xml_transformation():
    """
    Test transformation of data structures (pypi xmlrpc to custom list).

    """
    pypi_hits = [
        {
            '_pypi_ordering': 100,
            'name': 'foo',
            'summary': 'foo summary',
            'version': '1.0',
        },
        {
            '_pypi_ordering': 200,
            'name': 'foo',
            'summary': 'foo summary v2',
            'version': '2.0',
        },
        {
            '_pypi_ordering': 50,
            'name': 'bar',
            'summary': 'bar summary',
            'version': '1.0',
        },
    ]
    expected = [
        {
            'score': 200,
            'versions': ['1.0', '2.0'],
            'name': 'foo',
            'summary': 'foo summary v2',
        },
        {
            'score': 50,
            'versions': ['1.0'],
            'name': 'bar',
            'summary': 'bar summary',
        },
    ]
    assert transform_hits(pypi_hits) == expected


def test_invalid_pypi_transformation():
    """
    Test transformation of pypi when ordering None
    """
    pypi_hits = [
        {
            '_pypi_ordering': None,
            'name': 'bar',
            'summary': 'bar summary',
            'version': '1.0',
        },
        {
            '_pypi_ordering': 100,
            'name': 'foo',
            'summary': 'foo summary',
            'version': '1.0',
        },
    ]

    expected = [
        {
            'score': 100,
            'versions': ['1.0'],
            'name': 'foo',
            'summary': 'foo summary',
        },
        {
            'score': 0,
            'versions': ['1.0'],
            'name': 'bar',
            'summary': 'bar summary',
        },
    ]
    assert transform_hits(pypi_hits) == expected


def test_search(script):
    """
    End to end test of search command.

    """
    output = script.pip('search', 'pip')
    assert (
        'A tool for installing and managing Python packages' in output.stdout
    )


def test_multiple_search(script):
    """
    Test searching for multiple packages at once.

    """
    output = script.pip('search', 'pip', 'INITools')
    assert (
        'A tool for installing and managing Python packages' in output.stdout
    )
    assert 'Tools for parsing and using INI-style files' in output.stdout


def test_search_missing_argument(script):
    """
    Test missing required argument for search
    """
    result = script.pip('search', expect_error=True)
    assert 'ERROR: Missing required argument (search query).' in result.stdout


def test_run_method_should_return_sucess_when_find_packages():
    """
    Test SearchCommand.run for found package
    """
    options_mock = Mock()
    options_mock.index = 'http://pypi.python.org/pypi'
    search_cmd = SearchCommand()
    status = search_cmd.run(options_mock, ('pip',))
    assert status == SUCCESS


def test_run_method_should_return_no_matches_found_when_does_not_find_pkgs():
    """
    Test SearchCommand.run for no matches
    """
    options_mock = Mock()
    options_mock.index = 'https://pypi.python.org/pypi'
    search_cmd = SearchCommand()
    status = search_cmd.run(options_mock, ('non-existent-package',))
    assert status == NO_MATCHES_FOUND, status


def test_search_should_exit_status_code_zero_when_find_packages(script):
    """
    Test search exit status code for package found
    """
    result = script.pip('search', 'pip')
    assert result.returncode == SUCCESS


def test_search_exit_status_code_when_finds_no_package(script):
    """
    Test search exit status code for no matches
    """
    result = script.pip('search', 'non-existent-package', expect_error=True)
    assert result.returncode == NO_MATCHES_FOUND, result.returncode

########NEW FILE########
__FILENAME__ = test_show
import re
from pip import __version__
from pip.commands.show import search_packages_info


def test_show(script):
    """
    Test end to end test for show command.
    """
    result = script.pip('show', 'pip')
    lines = result.stdout.split('\n')
    assert len(lines) == 6
    assert lines[0] == '---', lines[0]
    assert lines[1] == 'Name: pip', lines[1]
    assert lines[2] == 'Version: %s' % __version__, lines[2]
    assert lines[3].startswith('Location: '), lines[3]
    assert lines[4] == 'Requires: '


def test_show_with_files_not_found(script, data):
    """
    Test for show command with installed files listing enabled and
    installed-files.txt not found.
    """
    editable = data.packages.join('SetupPyUTF8')
    script.pip('install', '-e', editable)
    result = script.pip('show', '-f', 'SetupPyUTF8')
    lines = result.stdout.split('\n')
    assert len(lines) == 8
    assert lines[0] == '---', lines[0]
    assert lines[1] == 'Name: SetupPyUTF8', lines[1]
    assert lines[2] == 'Version: 0.0.0', lines[2]
    assert lines[3].startswith('Location: '), lines[3]
    assert lines[4] == 'Requires: ', lines[4]
    assert lines[5] == 'Files:', lines[5]
    assert lines[6] == 'Cannot locate installed-files.txt', lines[6]


def test_show_with_files_from_wheel(script, data):
    """
    Test that a wheel's files can be listed
    """
    wheel_file = data.packages.join('simple.dist-0.1-py2.py3-none-any.whl')
    script.pip('install', '--no-index', wheel_file)
    result = script.pip('show', '-f', 'simple.dist')
    lines = result.stdout.split('\n')
    assert lines[1] == 'Name: simple.dist', lines[1]
    assert 'Cannot locate installed-files.txt' not in lines[6], lines[6]
    assert re.search(r"Files:\n(  .+\n)+", result.stdout)


def test_show_with_all_files(script):
    """
    Test listing all files in the show command.
    """
    script.pip('install', 'initools==0.2')
    result = script.pip('show', '--files', 'initools')
    lines = result.stdout.split('\n')
    assert 'Cannot locate installed-files.txt' not in lines[6], lines[6]
    assert re.search(r"Files:\n(  .+\n)+", result.stdout)


def test_missing_argument(script):
    """
    Test show command with no arguments.
    """
    result = script.pip('show')
    assert 'ERROR: Please provide a package name or names.' in result.stdout


def test_find_package_not_found():
    """
    Test trying to get info about a nonexistent package.

    """
    result = search_packages_info(['abcd3'])
    assert len(list(result)) == 0


def test_search_any_case():
    """
    Search for a package in any case.

    """
    result = list(search_packages_info(['PIP']))
    assert len(result) == 1
    assert 'pip' == result[0]['name']


def test_more_than_one_package():
    """
    Search for more than one package.

    """
    result = list(search_packages_info(['Pip', 'pytest', 'Virtualenv']))
    assert len(result) == 3

########NEW FILE########
__FILENAME__ = test_uninstall
from __future__ import with_statement

import textwrap
import os
import sys
from os.path import join, normpath
from tempfile import mkdtemp
from mock import patch
from tests.lib import assert_all_changes, pyversion
from tests.lib.local_repos import local_repo, local_checkout

from pip.util import rmtree


def test_simple_uninstall(script):
    """
    Test simple install and uninstall.

    """
    result = script.pip('install', 'INITools==0.2')
    assert join(script.site_packages, 'initools') in result.files_created, (
        sorted(result.files_created.keys())
    )
    # the import forces the generation of __pycache__ if the version of python
    # supports it
    script.run('python', '-c', "import initools")
    result2 = script.pip('uninstall', 'INITools', '-y')
    assert_all_changes(result, result2, [script.venv / 'build', 'cache'])


def test_uninstall_with_scripts(script):
    """
    Uninstall an easy_installed package with scripts.

    """
    result = script.run('easy_install', 'PyLogo', expect_stderr=True)
    easy_install_pth = script.site_packages / 'easy-install.pth'
    pylogo = sys.platform == 'win32' and 'pylogo' or 'PyLogo'
    assert(pylogo in result.files_updated[easy_install_pth].bytes)
    result2 = script.pip('uninstall', 'pylogo', '-y')
    assert_all_changes(
        result,
        result2,
        [script.venv / 'build', 'cache', easy_install_pth],
    )


def test_uninstall_easy_install_after_import(script):
    """
    Uninstall an easy_installed package after it's been imported

    """
    result = script.run('easy_install', 'INITools==0.2', expect_stderr=True)
    # the import forces the generation of __pycache__ if the version of python
    # supports it
    script.run('python', '-c', "import initools")
    result2 = script.pip('uninstall', 'INITools', '-y')
    assert_all_changes(
        result,
        result2,
        [
            script.venv / 'build',
            'cache',
            script.site_packages / 'easy-install.pth',
        ]
    )


def test_uninstall_namespace_package(script):
    """
    Uninstall a distribution with a namespace package without clobbering
    the namespace and everything in it.

    """
    result = script.pip('install', 'pd.requires==0.0.3', expect_error=True)
    assert join(script.site_packages, 'pd') in result.files_created, (
        sorted(result.files_created.keys())
    )
    result2 = script.pip('uninstall', 'pd.find', '-y', expect_error=True)
    assert join(script.site_packages, 'pd') not in result2.files_deleted, (
        sorted(result2.files_deleted.keys())
    )
    assert join(script.site_packages, 'pd', 'find') in result2.files_deleted, (
        sorted(result2.files_deleted.keys())
    )


def test_uninstall_overlapping_package(script, data):
    """
    Uninstalling a distribution that adds modules to a pre-existing package
    should only remove those added modules, not the rest of the existing
    package.

    See: GitHub issue #355 (pip uninstall removes things it didn't install)
    """
    parent_pkg = data.packages.join("parent-0.1.tar.gz")
    child_pkg = data.packages.join("child-0.1.tar.gz")

    result1 = script.pip('install', parent_pkg, expect_error=False)
    assert join(script.site_packages, 'parent') in result1.files_created, (
        sorted(result1.files_created.keys())
    )
    result2 = script.pip('install', child_pkg, expect_error=False)
    assert join(script.site_packages, 'child') in result2.files_created, (
        sorted(result2.files_created.keys())
    )
    assert normpath(
        join(script.site_packages, 'parent/plugins/child_plugin.py')
    ) in result2.files_created, sorted(result2.files_created.keys())
    # The import forces the generation of __pycache__ if the version of python
    #  supports it
    script.run('python', '-c', "import parent.plugins.child_plugin, child")
    result3 = script.pip('uninstall', '-y', 'child', expect_error=False)
    assert join(script.site_packages, 'child') in result3.files_deleted, (
        sorted(result3.files_created.keys())
    )
    assert normpath(
        join(script.site_packages, 'parent/plugins/child_plugin.py')
    ) in result3.files_deleted, sorted(result3.files_deleted.keys())
    assert join(script.site_packages, 'parent') not in result3.files_deleted, (
        sorted(result3.files_deleted.keys())
    )
    # Additional check: uninstalling 'child' should return things to the
    # previous state, without unintended side effects.
    assert_all_changes(result2, result3, [])


def test_uninstall_console_scripts(script):
    """
    Test uninstalling a package with more files (console_script entry points,
    extra directories).
    """
    args = ['install']
    args.append('discover')
    result = script.pip(*args, **{"expect_error": True})
    assert script.bin / 'discover' + script.exe in result.files_created, (
        sorted(result.files_created.keys())
    )
    result2 = script.pip('uninstall', 'discover', '-y', expect_error=True)
    assert_all_changes(result, result2, [script.venv / 'build', 'cache'])


def test_uninstall_easy_installed_console_scripts(script):
    """
    Test uninstalling package with console_scripts that is easy_installed.
    """
    args = ['easy_install']
    args.append('discover')
    result = script.run(*args, **{"expect_stderr": True})
    assert script.bin / 'discover' + script.exe in result.files_created, (
        sorted(result.files_created.keys())
    )
    result2 = script.pip('uninstall', 'discover', '-y')
    assert_all_changes(
        result,
        result2,
        [
            script.venv / 'build',
            'cache',
            script.site_packages / 'easy-install.pth',
        ]
    )


def test_uninstall_editable_from_svn(script, tmpdir):
    """
    Test uninstalling an editable installation from svn.
    """
    result = script.pip(
        'install', '-e',
        '%s#egg=initools-dev' % local_checkout(
            'svn+http://svn.colorstudy.com/INITools/trunk',
            tmpdir.join("cache"),
        ),
    )
    result.assert_installed('INITools')
    result2 = script.pip('uninstall', '-y', 'initools')
    assert (script.venv / 'src' / 'initools' in result2.files_after)
    assert_all_changes(
        result,
        result2,
        [
            script.venv / 'src',
            script.venv / 'build',
            script.site_packages / 'easy-install.pth'
        ],
    )


def test_uninstall_editable_with_source_outside_venv(script, tmpdir):
    """
    Test uninstalling editable install from existing source outside the venv.

    """
    cache_dir = tmpdir.join("cache")

    try:
        temp = mkdtemp()
        tmpdir = join(temp, 'pip-test-package')
        _test_uninstall_editable_with_source_outside_venv(
            script,
            tmpdir,
            cache_dir,
        )
    finally:
        rmtree(temp)


def _test_uninstall_editable_with_source_outside_venv(
        script, tmpdir, cache_dir):
    result = script.run(
        'git', 'clone',
        local_repo(
            'git+git://github.com/pypa/pip-test-package',
            cache_dir,
        ),
        tmpdir,
        expect_stderr=True,
    )
    result2 = script.pip('install', '-e', tmpdir)
    assert join(
        script.site_packages, 'pip-test-package.egg-link'
    ) in result2.files_created, list(result2.files_created.keys())
    result3 = script.pip('uninstall', '-y',
                         'pip-test-package', expect_error=True)
    assert_all_changes(
        result,
        result3,
        [script.venv / 'build', script.site_packages / 'easy-install.pth'],
    )


def test_uninstall_from_reqs_file(script, tmpdir):
    """
    Test uninstall from a requirements file.

    """
    script.scratch_path.join("test-req.txt").write(
        textwrap.dedent("""
            -e %s#egg=initools-dev
            # and something else to test out:
            PyLogo<0.4
        """) %
        local_checkout(
            'svn+http://svn.colorstudy.com/INITools/trunk',
            tmpdir.join("cache")
        )
    )
    result = script.pip('install', '-r', 'test-req.txt')
    script.scratch_path.join("test-req.txt").write(
        textwrap.dedent("""
            # -f, -i, and --extra-index-url should all be ignored by uninstall
            -f http://www.example.com
            -i http://www.example.com
            --extra-index-url http://www.example.com

            -e %s#egg=initools-dev
            # and something else to test out:
            PyLogo<0.4
        """) %
        local_checkout(
            'svn+http://svn.colorstudy.com/INITools/trunk',
            tmpdir.join("cache")
        )
    )
    result2 = script.pip('uninstall', '-r', 'test-req.txt', '-y')
    assert_all_changes(
        result,
        result2,
        [
            script.venv / 'build',
            script.venv / 'src',
            script.scratch / 'test-req.txt',
            script.site_packages / 'easy-install.pth',
        ],
    )


def test_uninstall_as_egg(script, data):
    """
    Test uninstall package installed as egg.
    """
    to_install = data.packages.join("FSPkg")
    result = script.pip('install', to_install, '--egg', expect_error=False)
    fspkg_folder = script.site_packages / 'fspkg'
    egg_folder = script.site_packages / 'FSPkg-0.1dev-py%s.egg' % pyversion
    assert fspkg_folder not in result.files_created, str(result.stdout)
    assert egg_folder in result.files_created, str(result)

    result2 = script.pip('uninstall', 'FSPkg', '-y', expect_error=True)
    assert_all_changes(
        result,
        result2,
        [
            script.venv / 'build',
            'cache',
            script.site_packages / 'easy-install.pth',
        ],
    )


@patch('pip.req.req_uninstall.logger')
def test_uninstallpathset_no_paths(mock_logger):
    """
    Test UninstallPathSet logs notification when there are no paths to
    uninstall
    """
    from pip.req.req_uninstall import UninstallPathSet
    from pkg_resources import get_distribution
    test_dist = get_distribution('pip')
    # ensure that the distribution is "local"
    with patch("pip.req.req_uninstall.dist_is_local") as mock_dist_is_local:
        mock_dist_is_local.return_value = True
        uninstall_set = UninstallPathSet(test_dist)
        uninstall_set.remove()  # with no files added to set
    mock_logger.notify.assert_any_call(
        "Can't uninstall 'pip'. No files were found to uninstall.",
    )


@patch('pip.req.req_uninstall.logger')
def test_uninstallpathset_non_local(mock_logger):
    """
    Test UninstallPathSet logs notification and returns (with no exception)
    when dist is non-local
    """
    nonlocal_path = os.path.abspath("/nonlocal")
    from pip.req.req_uninstall import UninstallPathSet
    from pkg_resources import get_distribution
    test_dist = get_distribution('pip')
    test_dist.location = nonlocal_path
    # ensure that the distribution is "non-local"
    # setting location isn't enough, due to egg-link file checking for
    # develop-installs
    with patch("pip.req.req_uninstall.dist_is_local") as mock_dist_is_local:
        mock_dist_is_local.return_value = False
        uninstall_set = UninstallPathSet(test_dist)
        # with no files added to set; which is the case when trying to remove
        # non-local dists
        uninstall_set.remove()
    mock_logger.notify.assert_any_call(
        "Not uninstalling pip at %s, outside environment %s" %
        (nonlocal_path, sys.prefix)
    )
    mock_logger.notify.mock_calls


def test_uninstall_wheel(script, data):
    """
    Test uninstalling a wheel
    """
    package = data.packages.join("simple.dist-0.1-py2.py3-none-any.whl")
    result = script.pip('install', package, '--no-index')
    dist_info_folder = script.site_packages / 'simple.dist-0.1.dist-info'
    assert dist_info_folder in result.files_created
    result2 = script.pip('uninstall', 'simple.dist', '-y')
    assert_all_changes(result, result2, [])

########NEW FILE########
__FILENAME__ = test_uninstall_user
"""
tests specific to uninstalling --user installs
"""
from os.path import isdir, isfile

from tests.lib import pyversion, assert_all_changes
from tests.functional.test_install_user import _patch_dist_in_site_packages


class Tests_UninstallUserSite:

    def test_uninstall_from_usersite(self, script, virtualenv):
        """
        Test uninstall from usersite
        """
        virtualenv.system_site_packages = True
        result1 = script.pip('install', '--user', 'INITools==0.3')
        result2 = script.pip('uninstall', '-y', 'INITools')
        assert_all_changes(result1, result2, [script.venv / 'build', 'cache'])

    def test_uninstall_from_usersite_with_dist_in_global_site(
            self, script, virtualenv):
        """
        Test uninstall from usersite (with same dist in global site)
        """
        # the test framework only supports testing using virtualenvs.
        # the sys.path ordering for virtualenvs with --system-site-packages is
        # this: virtualenv-site, user-site, global-site.
        # this test will use 2 modifications to simulate the
        #   user-site/global-site relationship
        # 1) a monkey patch which will make it appear piptestpackage is not in
        #    the virtualenv site if we don't patch this, pip will return an
        #    installation error:  "Will not install to the usersite because it
        #    will lack sys.path precedence..."
        # 2) adding usersite to PYTHONPATH, so usersite has sys.path precedence
        #    over the virtualenv site

        virtualenv.system_site_packages = True
        script.environ["PYTHONPATH"] = script.base_path / script.user_site
        _patch_dist_in_site_packages(script)

        script.pip_install_local('pip-test-package==0.1')

        result2 = script.pip_install_local('--user', 'pip-test-package==0.1.1')
        result3 = script.pip('uninstall', '-vy', 'pip-test-package')

        # uninstall console is mentioning user scripts, but not global scripts
        assert script.user_bin_path in result3.stdout
        assert script.bin_path not in result3.stdout

        # uninstall worked
        assert_all_changes(result2, result3, [script.venv / 'build', 'cache'])

        # site still has 0.2 (can't look in result1; have to check)
        egg_info_folder = (
            script.base_path / script.site_packages /
            'pip_test_package-0.1-py%s.egg-info' % pyversion
        )
        assert isdir(egg_info_folder)

    def test_uninstall_editable_from_usersite(self, script, virtualenv, data):
        """
        Test uninstall editable local user install
        """
        virtualenv.system_site_packages = True
        script.user_site_path.makedirs()

        # install
        to_install = data.packages.join("FSPkg")
        result1 = script.pip(
            'install', '--user', '-e', to_install, expect_error=False,
        )
        egg_link = script.user_site / 'FSPkg.egg-link'
        assert egg_link in result1.files_created, str(result1.stdout)

        # uninstall
        result2 = script.pip('uninstall', '-y', 'FSPkg')
        assert not isfile(script.base_path / egg_link)

        assert_all_changes(
            result1,
            result2,
            [
                script.venv / 'build',
                'cache',
                script.user_site / 'easy-install.pth',
            ]
        )

########NEW FILE########
__FILENAME__ = test_wheel
"""'pip wheel' tests"""
import os

from os.path import exists

from pip.locations import write_delete_marker_file
from pip.status_codes import PREVIOUS_BUILD_DIR_ERROR
from tests.lib import pyversion


def test_pip_wheel_fails_without_wheel(script, data):
    """
    Test 'pip wheel' fails without wheel
    """
    result = script.pip(
        'wheel', '--no-index', '-f', data.find_links, 'simple==3.0',
        expect_error=True,
    )
    assert "'pip wheel' requires the 'wheel' package" in result.stdout


def test_pip_wheel_success(script, data):
    """
    Test 'pip wheel' success.
    """
    script.pip('install', 'wheel')
    result = script.pip(
        'wheel', '--no-index', '-f', data.find_links, 'simple==3.0',
    )
    wheel_file_name = 'simple-3.0-py%s-none-any.whl' % pyversion[0]
    wheel_file_path = script.scratch / 'wheelhouse' / wheel_file_name
    assert wheel_file_path in result.files_created, result.stdout
    assert "Successfully built simple" in result.stdout, result.stdout


def test_pip_wheel_downloads_wheels(script, data):
    """
    Test 'pip wheel' downloads wheels
    """
    script.pip('install', 'wheel')
    result = script.pip(
        'wheel', '--no-index', '-f', data.find_links, 'simple.dist',
    )
    wheel_file_name = 'simple.dist-0.1-py2.py3-none-any.whl'
    wheel_file_path = script.scratch / 'wheelhouse' / wheel_file_name
    assert wheel_file_path in result.files_created, result.stdout
    assert "Saved" in result.stdout, result.stdout


def test_pip_wheel_builds_editable_deps(script, data):
    """
    Test 'pip wheel' finds and builds dependencies of editables
    """
    script.pip('install', 'wheel')
    editable_path = os.path.join(data.src, 'requires_simple')
    result = script.pip(
        'wheel', '--no-index', '-f', data.find_links, '-e', editable_path
    )
    wheel_file_name = 'simple-1.0-py%s-none-any.whl' % pyversion[0]
    wheel_file_path = script.scratch / 'wheelhouse' / wheel_file_name
    assert wheel_file_path in result.files_created, result.stdout


def test_pip_wheel_fail(script, data):
    """
    Test 'pip wheel' failure.
    """
    script.pip('install', 'wheel')
    result = script.pip(
        'wheel', '--no-index', '-f', data.find_links, 'wheelbroken==0.1',
        expect_error=True,
    )
    wheel_file_name = 'wheelbroken-0.1-py%s-none-any.whl' % pyversion[0]
    wheel_file_path = script.scratch / 'wheelhouse' / wheel_file_name
    assert wheel_file_path not in result.files_created, (
        wheel_file_path,
        result.files_created,
    )
    assert "FakeError" in result.stdout, result.stdout
    assert "Failed to build wheelbroken" in result.stdout, result.stdout
    assert result.returncode != 0


def test_no_clean_option_blocks_cleaning_after_wheel(script, data):
    """
    Test --no-clean option blocks cleaning after wheel build
    """
    script.pip('install', 'wheel')
    result = script.pip(
        'wheel', '--no-clean', '--no-index',
        '--find-links=%s' % data.find_links, 'simple',
    )
    build = script.venv_path / 'build' / 'simple'
    assert exists(build), "build/simple should still exist %s" % str(result)


def test_pip_wheel_source_deps(script, data):
    """
    Test 'pip wheel --use-wheel' finds and builds source archive dependencies
    of wheels
    """
    # 'requires_source' is a wheel that depends on the 'source' project
    script.pip('install', 'wheel')
    result = script.pip(
        'wheel', '--use-wheel', '--no-index', '-f', data.find_links,
        'requires_source',
    )
    wheel_file_name = 'source-1.0-py%s-none-any.whl' % pyversion[0]
    wheel_file_path = script.scratch / 'wheelhouse' / wheel_file_name
    assert wheel_file_path in result.files_created, result.stdout
    assert "Successfully built source" in result.stdout, result.stdout


def test_pip_wheel_fail_cause_of_previous_build_dir(script, data):
    """
    Test when 'pip wheel' tries to install a package that has a previous build
    directory
    """

    script.pip('install', 'wheel')

    # Given that I have a previous build dir of the `simple` package
    build = script.venv_path / 'build' / 'simple'
    os.makedirs(build)
    write_delete_marker_file(script.venv_path / 'build')
    build.join('setup.py').write('#')

    # When I call pip trying to install things again
    result = script.pip(
        'wheel', '--no-index', '--find-links=%s' % data.find_links,
        'simple==3.0', expect_error=True,
    )

    # Then I see that the error code is the right one
    assert result.returncode == PREVIOUS_BUILD_DIR_ERROR, result

########NEW FILE########
__FILENAME__ = git_submodule_helpers
from __future__ import absolute_import

import textwrap


def _create_test_package_submodule(env):
    env.scratch_path.join("version_pkg_submodule").mkdir()
    submodule_path = env.scratch_path / 'version_pkg_submodule'
    env.run('touch', 'testfile', cwd=submodule_path)
    env.run('git', 'init', cwd=submodule_path)
    env.run('git', 'add', '.', cwd=submodule_path)
    env.run('git', 'commit', '-q',
            '--author', 'pip <pypa-dev@googlegroups.com>',
            '-am', 'initial version / submodule', cwd=submodule_path)
    return submodule_path


def _change_test_package_submodule(env, submodule_path):
    submodule_path.join("testfile").write("this is a changed file")
    submodule_path.join("testfile2").write("this is an added file")
    env.run('git', 'add', '.', cwd=submodule_path)
    env.run('git', 'commit', '-q',
            '--author', 'pip <pypa-dev@googlegroups.com>',
            '-am', 'submodule change', cwd=submodule_path)


def _pull_in_submodule_changes_to_module(env, module_path):
    env.run(
        'git',
        'pull',
        '-q',
        'origin',
        'master',
        cwd=module_path / 'testpkg/static/',
    )
    env.run('git', 'commit', '-q',
            '--author', 'pip <pypa-dev@googlegroups.com>',
            '-am', 'submodule change', cwd=module_path)


def _create_test_package_with_submodule(env):
    env.scratch_path.join("version_pkg").mkdir()
    version_pkg_path = env.scratch_path / 'version_pkg'
    version_pkg_path.join("testpkg").mkdir()
    pkg_path = version_pkg_path / 'testpkg'

    pkg_path.join("__init__.py").write("# hello there")
    pkg_path.join("version_pkg.py").write(textwrap.dedent('''\
                                def main():
                                    print('0.1')
                                '''))
    version_pkg_path.join("setup.py").write(textwrap.dedent('''\
                        from setuptools import setup, find_packages
                        setup(name='version_pkg',
                              version='0.1',
                              packages=find_packages(),
                             )
                        '''))
    env.run('git', 'init', cwd=version_pkg_path, expect_error=True)
    env.run('git', 'add', '.', cwd=version_pkg_path, expect_error=True)
    env.run('git', 'commit', '-q',
            '--author', 'pip <pypa-dev@googlegroups.com>',
            '-am', 'initial version', cwd=version_pkg_path,
            expect_error=True)

    submodule_path = _create_test_package_submodule(env)

    env.run(
        'git',
        'submodule',
        'add',
        submodule_path,
        'testpkg/static',
        cwd=version_pkg_path,
        expect_error=True,
    )
    env.run('git', 'commit', '-q',
            '--author', 'pip <pypa-dev@googlegroups.com>',
            '-am', 'initial version w submodule', cwd=version_pkg_path,
            expect_error=True)

    return version_pkg_path, submodule_path

########NEW FILE########
__FILENAME__ = local_repos
from __future__ import absolute_import

import os
import subprocess
from pip.vcs import subversion, git, bazaar, mercurial
from pip.compat import urlretrieve
from tests.lib import path_to_url


if hasattr(subprocess, "check_call"):
    subprocess_call = subprocess.check_call
else:
    subprocess_call = subprocess.call


def _create_initools_repository(directory):
    subprocess_call('svnadmin create INITools'.split(), cwd=directory)


def _dump_initools_repository(directory):
    filename, _ = urlretrieve(
        'http://bitbucket.org/hltbra/pip-initools-dump/raw/8b55c908a320/'
        'INITools_modified.dump'
    )
    initools_folder = os.path.join(directory, 'INITools')
    devnull = open(os.devnull, 'w')
    dump = open(filename)
    subprocess_call(
        ['svnadmin', 'load', initools_folder],
        stdin=dump,
        stdout=devnull,
    )
    dump.close()
    devnull.close()
    os.remove(filename)


def _create_svn_repository_for_initools(directory):
    if not os.path.exists(os.path.join(directory, 'INITools')):
        _create_initools_repository(directory)
        _dump_initools_repository(directory)


def _get_vcs_and_checkout_url(remote_repository, directory):
    vcs_classes = {'svn': subversion.Subversion,
                   'git': git.Git,
                   'bzr': bazaar.Bazaar,
                   'hg': mercurial.Mercurial}
    default_vcs = 'svn'
    if '+' not in remote_repository:
        remote_repository = '%s+%s' % (default_vcs, remote_repository)
    vcs, repository_path = remote_repository.split('+', 1)
    vcs_class = vcs_classes[vcs]
    branch = ''
    if vcs == 'svn':
        branch = os.path.basename(remote_repository)
        # remove the slash
        repository_name = os.path.basename(
            remote_repository[:-len(branch) - 1]
        )
    else:
        repository_name = os.path.basename(remote_repository)

    destination_path = os.path.join(directory, repository_name)
    if not os.path.exists(destination_path):
        vcs_class(remote_repository).obtain(destination_path)
    return '%s+%s' % (
        vcs,
        path_to_url('/'.join([directory, repository_name, branch])),
    )


def local_checkout(remote_repo, directory):
    if not os.path.exists(directory):
        os.mkdir(directory)
        # os.makedirs(directory)

    if remote_repo.startswith('svn'):
        _create_svn_repository_for_initools(directory)
    return _get_vcs_and_checkout_url(remote_repo, directory)


def local_repo(remote_repo, directory):
    return local_checkout(remote_repo, directory).split('+', 1)[1]

########NEW FILE########
__FILENAME__ = path
# flake8: noqa
# -*- coding: utf-8 -*-
# Author: Aziz Köksal
from __future__ import absolute_import

import glob
import os
import sys
import shutil

try:
    from os import supports_fd
except ImportError:
    supports_fd = set()

if sys.version_info >= (3,):
    unicode = str
    u = str
else:
    unicode = unicode
    u = lambda s: s.decode('utf-8')

_base = os.path.supports_unicode_filenames and unicode or str


class Path(_base):
    """
    Models a path in an object oriented way.
    """

    # File system path separator: '/' or '\'.
    sep = os.sep

    # Separator in the PATH environment variable.
    pathsep = os.pathsep

    def __new__(cls, *paths):
        if len(paths):
            return _base.__new__(cls, os.path.join(*paths))
        return _base.__new__(cls)

    def __div__(self, path):
        """
        Joins this path with another path.

        >>> path_obj / 'bc.d'
        >>> path_obj / path_obj2
        """
        return Path(self, path)

    __truediv__ = __div__

    def __rdiv__(self, path):
        """
        Joins this path with another path.

        >>> "/home/a" / path_obj
        """
        return Path(path, self)

    __rtruediv__ = __rdiv__

    def __idiv__(self, path):
        """
        Like __div__ but also assigns to the variable.

        >>> path_obj /= 'bc.d'
        """
        return Path(self, path)

    __itruediv__ = __idiv__

    def __floordiv__(self, paths):
        """
        Returns a list of paths prefixed with 'self'.

        >>> '/home/a' // [bc.d, ef.g]
        [/home/a/bc.d, /home/a/ef.g]
        """
        return [Path(self, path) for path in paths]

    def __sub__(self, path):
        """
        Makes this path relative to another path.

        >>> path_obj - '/home/a'
        >>> path_obj - path_obj2
        """
        return Path(os.path.relpath(self, path))

    def __rsub__(self, path):
        """
        Returns path relative to this path.

        >>> "/home/a" - path_obj
        """
        return Path(os.path.relpath(path, self))

    def __add__(self, path):
        """
        >>> Path('/home/a') + 'bc.d'
        '/home/abc.d'
        """
        return Path(_base(self) + path)

    def __radd__(self, path):
        """
        >>> '/home/a' + Path('bc.d')
        '/home/abc.d'
        """
        return Path(path + _base(self))

    def __repr__(self):
        return u("Path(%s)" % _base.__repr__(self))

    def __hash__(self):
        return _base.__hash__(self)

    @property
    def name(self):
        """
        '/home/a/bc.d' -> 'bc.d'
        """
        return os.path.basename(self)

    @property
    def namebase(self):
        """
        '/home/a/bc.d' -> 'bc'
        """
        return self.noext.name

    @property
    def noext(self):
        """
        '/home/a/bc.d' -> '/home/a/bc'
        """
        return Path(os.path.splitext(self)[0])

    @property
    def ext(self):
        """
        '/home/a/bc.d' -> '.d'
        """
        return Path(os.path.splitext(self)[1])

    @property
    def abspath(self):
        """
        './a/bc.d' -> '/home/a/bc.d'
        """
        return Path(os.path.abspath(self))

    @property
    def realpath(self):
        """
        Resolves symbolic links.
        """
        return Path(os.path.realpath(self))

    @property
    def normpath(self):
        """
        '/home/x/.././a//bc.d' -> '/home/a/bc.d'
        """
        return Path(os.path.normpath(self))

    @property
    def normcase(self):
        """
        Deals with case-insensitive filesystems
        """
        return Path(os.path.normcase(self))

    @property
    def folder(self):
        """
        Returns the folder of this path.

        '/home/a/bc.d' -> '/home/a'
        '/home/a/' -> '/home/a'
        '/home/a' -> '/home'
        """
        return Path(os.path.dirname(self))

    @property
    def exists(self):
        """
        Returns True if the path exists.
        """
        return os.path.exists(self)

    @property
    def atime(self):
        """
        Returns last accessed time.
        """
        return os.path.getatime(self)

    @property
    def mtime(self):
        """
        Returns last modified time.
        """
        return os.path.getmtime(self)

    @property
    def ctime(self):
        """
        Returns last changed time.
        """
        return os.path.getctime(self)

    @classmethod
    def supports_unicode(self):
        """
        Returns True if the system can handle Unicode file names.
        """
        return os.path.supports_unicode_filenames()

    def walk(self, **kwargs):
        """ Returns a generator that walks through a directory tree. """
        return os.walk(self, **kwargs)

    def mkdir(self, mode=0x1FF):  # 0o777
        """
        Creates a directory, if it doesn't exist already.
        """
        if not self.exists:
            os.mkdir(self, mode)
        return self

    def makedirs(self, mode=0x1FF):  # 0o777
        """
        Like mkdir(), but also creates parent directories.
        """
        if not self.exists:
            os.makedirs(self, mode)
        return self

    def remove(self):
        """
        Removes a file.
        """
        return os.remove(self)

    rm = remove  # Alias.

    def rmdir(self):
        """
        Removes a directory.
        """
        return os.rmdir(self)

    def rmtree(self, noerrors=True):
        """
        Removes a directory tree. Ignores errors by default.
        """
        return shutil.rmtree(self, ignore_errors=noerrors)

    def copy(self, to):
        return shutil.copy(self, to)

    def copytree(self, to):
        """
        Copies a directory tree to another path.
        """
        return shutil.copytree(self, to, symlinks=True)

    def move(self, to):
        """
        Moves a file or directory to another path.
        """
        return shutil.move(self, to)

    def rename(self, to):
        """
        Renames a file or directory. May throw an OSError.
        """
        return os.rename(self, to)

    def renames(self, to):
        return os.renames(self, to)

    def glob(self, pattern):
        return (Path(i) for i in glob.iglob(self.join(pattern)))

    def join(self, *parts):
        return Path(self, *parts)

    def write(self, content):
        with open(self, "w") as fp:
            fp.write(content)

    def touch(self, times=None):
        with open(self, "a") as fp:
            os.utime(fp.fileno() if os.utime in supports_fd else self, times)

curdir = Path(os.path.curdir)

########NEW FILE########
__FILENAME__ = scripttest
from __future__ import absolute_import

from . import PipTestEnvironment  # noqa

########NEW FILE########
__FILENAME__ = test_lib
"""Test the test support."""
from __future__ import absolute_import

import filecmp
import re
from os.path import join, isdir

from tests.lib import SRC_DIR


def test_tmp_dir_exists_in_env(script):
    """
    Test that $TMPDIR == env.temp_path and path exists and env.assert_no_temp()
    passes (in fast env)
    """
    # need these tests to ensure the assert_no_temp feature of scripttest is
    # working
    script.assert_no_temp()  # this fails if env.tmp_path doesn't exist
    assert script.environ['TMPDIR'] == script.temp_path
    assert isdir(script.temp_path)


def test_correct_pip_version(script):
    """
    Check we are running proper version of pip in run_pip.
    """
    # output is like:
    # pip PIPVERSION from PIPDIRECTORY (python PYVERSION)
    result = script.pip('--version')

    # compare the directory tree of the invoked pip with that of this source
    # distribution
    dir = re.match(
        r'pip \d(\.[\d])+(\.?(rc|dev|pre|post)\d+)? from (.*) '
        r'\(python \d(.[\d])+\)$',
        result.stdout
    ).group(4)
    pip_folder = join(SRC_DIR, 'pip')
    pip_folder_outputed = join(dir, 'pip')

    diffs = filecmp.dircmp(pip_folder, pip_folder_outputed)

    # If any non-matching .py files exist, we have a problem: run_pip
    # is picking up some other version!  N.B. if this project acquires
    # primary resources other than .py files, this code will need
    # maintenance
    mismatch_py = [
        x for x in diffs.left_only + diffs.right_only + diffs.diff_files
        if x.endswith('.py')
    ]
    assert not mismatch_py, (
        'mismatched source files in %r and %r: %r' %
        (pip_folder, pip_folder_outputed, mismatch_py)
    )

########NEW FILE########
__FILENAME__ = venv
from __future__ import absolute_import

import os
import sys
import subprocess

import virtualenv as _virtualenv

from .path import Path


# On Python < 3.3 we don't have subprocess.DEVNULL
try:
    DEVNULL = subprocess.DEVNULL
except AttributeError:
    DEVNULL = open(os.devnull, "wb")


class VirtualEnvironment(object):
    """
    An abstraction around virtual environments, currently it only uses
    virtualenv but in the future it could use pyvenv.
    """

    def __init__(self, location, *args, **kwargs):
        self.location = Path(location)
        self.pip_source_dir = kwargs.pop("pip_source_dir")
        self._system_site_packages = kwargs.pop("system_site_packages", False)

        home, lib, inc, bin = _virtualenv.path_locations(self.location)
        # workaround for https://github.com/pypa/virtualenv/issues/306
        if hasattr(sys, "pypy_version_info"):
            lib = os.path.join(home, 'lib-python', sys.version[:3])
        self.lib = Path(lib)
        self.bin = Path(bin)

        super(VirtualEnvironment, self).__init__(*args, **kwargs)

    def __repr__(self):
        return "<VirtualEnvironment {}>".format(self.location)

    @classmethod
    def create(cls, location, clear=False, pip_source_dir=None):
        obj = cls(location, pip_source_dir=pip_source_dir)
        obj._create(clear=clear)
        return obj

    def _create(self, clear=False):
        # Create the actual virtual environment
        _virtualenv.create_environment(
            self.location,
            clear=clear,
            never_download=True,
            no_pip=True,
        )

        # Install our development version of pip install the virtual
        # environment
        cmd = [self.bin.join("python"), "setup.py", "develop"]
        p = subprocess.Popen(
            cmd,
            cwd=self.pip_source_dir,
            # stderr=subprocess.STDOUT,
            # stdout=DEVNULL,
        )
        p.communicate()
        if p.returncode != 0:
            raise Exception(p.stderr)
            raise subprocess.CalledProcessError(
                p.returncode,
                cmd[0],
                output=p.stdout,
            )

    def clear(self):
        self._create(clear=True)

    @property
    def system_site_packages(self):
        return self._system_site_packages

    @system_site_packages.setter
    def system_site_packages(self, value):
        marker = self.lib.join("no-global-site-packages.txt")
        if value:
            marker.rm()
        else:
            marker.touch()
        self._system_site_packages = value

########NEW FILE########
__FILENAME__ = test_all_pip
import os
import re
import sys
import subprocess
from os.path import dirname, abspath

from pip.compat import urllib
from pip.util import rmtree


src_folder = dirname(dirname(abspath(__file__)))

if sys.platform == 'win32':
    bin_dir = 'Scripts'
else:
    bin_dir = 'bin'


def all_projects():
    data = urllib.urlopen('http://pypi.python.org/simple/').read()
    projects = [m.group(1) for m in re.finditer(r'<a.*?>(.+)</a>', data)]
    return projects


def main(args=None):
    if args is None:
        args = sys.argv[1:]
    if not args:
        print('Usage: test_all_pip.py <output-dir>')
        sys.exit(1)
    output = os.path.abspath(args[0])
    if not os.path.exists(output):
        print('Creating %s' % output)
        os.makedirs(output)
    pending_fn = os.path.join(output, 'pending.txt')
    if not os.path.exists(pending_fn):
        print('Downloading pending list')
        projects = all_projects()
        print('Found %s projects' % len(projects))
        f = open(pending_fn, 'w')
        for name in projects:
            f.write(name + '\n')
        f.close()
    print('Starting testing...')
    while os.stat(pending_fn).st_size:
        _test_packages(output, pending_fn)
    print('Finished all pending!')


def _test_packages(output, pending_fn):
    package = get_last_item(pending_fn)
    print('Testing package %s' % package)
    dest_dir = os.path.join(output, package)
    print('Creating virtualenv in %s' % dest_dir)
    create_venv(dest_dir)
    print('Uninstalling actual pip')
    code = subprocess.check_call([
        os.path.join(dest_dir, bin_dir, 'pip'),
        'uninstall',
        '-y',
        'pip',
    ])
    assert not code, 'pip uninstallation failed'
    print('Installing development pip')
    code = subprocess.check_call(
        [
            os.path.join(dest_dir, bin_dir, 'python'),
            'setup.py',
            'install'
        ],
        cwd=src_folder,
    )
    assert not code, 'pip installation failed'
    print('Trying installation of %s' % dest_dir)
    code = subprocess.check_call([
        os.path.join(dest_dir, bin_dir, 'pip'),
        'install',
        package,
    ])
    if code:
        print('Installation of %s failed' % package)
        print('Now checking easy_install...')
        create_venv(dest_dir)
        code = subprocess.check_call([
            os.path.join(dest_dir, bin_dir, 'easy_install'),
            package,
        ])
        if code:
            print('easy_install also failed')
            add_package(os.path.join(output, 'easy-failure.txt'), package)
        else:
            print('easy_install succeeded')
            add_package(os.path.join(output, 'failure.txt'), package)
        pop_last_item(pending_fn, package)
    else:
        print('Installation of %s succeeded' % package)
        add_package(os.path.join(output, 'success.txt'), package)
        pop_last_item(pending_fn, package)
        rmtree(dest_dir)


def create_venv(dest_dir):
    if os.path.exists(dest_dir):
        rmtree(dest_dir)
    print('Creating virtualenv in %s' % dest_dir)
    code = subprocess.check_call([
        'virtualenv',
        '--no-site-packages',
        dest_dir,
    ])
    assert not code, "virtualenv failed"


def get_last_item(fn):
    f = open(fn, 'r')
    lines = f.readlines()
    f.close()
    return lines[-1].strip()


def pop_last_item(fn, line=None):
    f = open(fn, 'r')
    lines = f.readlines()
    f.close()
    if line:
        assert lines[-1].strip() == line.strip()
    lines.pop()
    f = open(fn, 'w')
    f.writelines(lines)
    f.close()


def add_package(filename, package):
    f = open(filename, 'a')
    f.write(package + '\n')
    f.close()


if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = test_appdirs
import sys

import pretend

from pip import appdirs


class TestUserCacheDir:

    def test_user_cache_dir_win(self, monkeypatch):
        @pretend.call_recorder
        def _get_win_folder(base):
            return "C:\\Users\\test\\AppData\\Local"

        monkeypatch.setattr(
            appdirs,
            "_get_win_folder",
            _get_win_folder,
            raising=False,
        )
        monkeypatch.setattr(sys, "platform", "win32")

        assert (appdirs.user_cache_dir("pip").replace("/", "\\")
                == "C:\\Users\\test\\AppData\\Local\\pip\\Cache")
        assert _get_win_folder.calls == [pretend.call("CSIDL_LOCAL_APPDATA")]

    def test_user_cache_dir_osx(self, monkeypatch):
        monkeypatch.setenv("HOME", "/home/test")
        monkeypatch.setattr(sys, "platform", "darwin")

        assert appdirs.user_cache_dir("pip") == "/home/test/Library/Caches/pip"

    def test_user_cache_dir_linux(self, monkeypatch):
        monkeypatch.delenv("XDG_CACHE_HOME")
        monkeypatch.setenv("HOME", "/home/test")
        monkeypatch.setattr(sys, "platform", "linux2")

        assert appdirs.user_cache_dir("pip") == "/home/test/.cache/pip"

    def test_user_cache_dir_linux_override(self, monkeypatch):
        monkeypatch.setenv("XDG_CACHE_HOME", "/home/test/.other-cache")
        monkeypatch.setenv("HOME", "/home/test")
        monkeypatch.setattr(sys, "platform", "linux2")

        assert appdirs.user_cache_dir("pip") == "/home/test/.other-cache/pip"

########NEW FILE########
__FILENAME__ = test_basecommand
import os
from pip.basecommand import Command
from pip.log import logger


class FakeCommand(Command):
    name = 'fake'
    summary = name

    def __init__(self, error=False):
        self.error = error
        super(FakeCommand, self).__init__()

    def run(self, options, args):
        logger.info("fake")
        if self.error:
            raise SystemExit(1)


class Test_basecommand_logging(object):
    """
    Test `pip.basecommand.Command` setting up logging consumers based on
    options
    """

    def teardown(self):
        logger.consumers = []

    def test_log_command_success(self, tmpdir):
        """
        Test the --log option logs when command succeeds
        """
        cmd = FakeCommand()
        log_path = tmpdir.join('log')
        cmd.main(['fake', '--log', log_path])
        assert 'fake' == open(log_path).read().strip()[:4]

    def test_log_command_error(self, tmpdir):
        """
        Test the --log option logs when command fails
        """
        cmd = FakeCommand(error=True)
        log_path = tmpdir.join('log')
        cmd.main(['fake', '--log', log_path])
        assert 'fake' == open(log_path).read().strip()[:4]

    def test_log_file_command_success(self, tmpdir):
        """
        Test the --log-file option *doesn't* log when command succeeds.
        (It's just the historical behavior? this just confirms it)
        """
        cmd = FakeCommand()
        log_file_path = tmpdir.join('log_file')
        cmd.main(['fake', '--log-file', log_file_path])
        assert not os.path.exists(log_file_path)

    def test_log_file_command_error(self, tmpdir):
        """
        Test the --log-file option logs (when there's an error).
        """
        cmd = FakeCommand(error=True)
        log_file_path = tmpdir.join('log_file')
        cmd.main(['fake', '--log-file', log_file_path])
        assert 'fake' == open(log_file_path).read().strip()[:4]

    def test_log_log_file(self, tmpdir):
        """
        Test the --log and --log-file options log together (when there's an
        error).
        """
        cmd = FakeCommand(error=True)
        log_path = tmpdir.join('log')
        log_file_path = tmpdir.join('log_file')
        cmd.main(['fake', '--log', log_path, '--log-file', log_file_path])
        assert 'fake' == open(log_path).read().strip()[:4]
        assert 'fake' == open(log_file_path).read().strip()[:4]

    def test_verbose_quiet(self):
        """
        Test additive quality of -v and -q
        """
        cmd = FakeCommand()
        cmd.main(['fake', '-vqq'])
        console_level = logger.consumers[0][0]
        assert console_level == logger.WARN

########NEW FILE########
__FILENAME__ = test_compat
import os
from pip.compat import get_path_uid
import pytest


def test_get_path_uid():
    path = os.getcwd()
    assert get_path_uid(path) == os.stat(path).st_uid


@pytest.mark.skipif("not hasattr(os, 'O_NOFOLLOW')")
def test_get_path_uid_without_NOFOLLOW(monkeypatch):
    monkeypatch.delattr("os.O_NOFOLLOW")
    path = os.getcwd()
    assert get_path_uid(path) == os.stat(path).st_uid


@pytest.mark.skipif("not hasattr(os, 'symlink')")
def test_get_path_uid_symlink(tmpdir):
    f = tmpdir.mkdir("symlink").join("somefile")
    f.write("content")
    fs = f + '_link'
    os.symlink(f, fs)
    with pytest.raises(OSError):
        get_path_uid(fs)


@pytest.mark.skipif("not hasattr(os, 'O_NOFOLLOW')")
@pytest.mark.skipif("not hasattr(os, 'symlink')")
def test_get_path_uid_symlink_without_NOFOLLOW(tmpdir, monkeypatch):
    monkeypatch.delattr("os.O_NOFOLLOW")
    f = tmpdir.mkdir("symlink").join("somefile")
    f.write("content")
    fs = f + '_link'
    os.symlink(f, fs)
    with pytest.raises(OSError):
        get_path_uid(fs)

########NEW FILE########
__FILENAME__ = test_download
import hashlib
import os
from shutil import rmtree, copy
from tempfile import mkdtemp

from mock import Mock, patch
import pytest

import pip
from pip.compat import BytesIO, b, pathname2url
from pip.exceptions import HashMismatch
from pip.download import (
    PipSession, SafeFileCache, path_to_url, unpack_http_url, url_to_path,
    unpack_file_url,
)
from pip.index import Link


def test_unpack_http_url_with_urllib_response_without_content_type(data):
    """
    It should download and unpack files even if no Content-Type header exists
    """
    _real_session = PipSession()

    def _fake_session_get(*args, **kwargs):
        resp = _real_session.get(*args, **kwargs)
        del resp.headers["Content-Type"]
        return resp

    session = Mock()
    session.get = _fake_session_get

    uri = path_to_url(data.packages.join("simple-1.0.tar.gz"))
    link = Link(uri)
    temp_dir = mkdtemp()
    try:
        unpack_http_url(
            link,
            temp_dir,
            download_dir=None,
            session=session,
        )
        assert set(os.listdir(temp_dir)) == set([
            'PKG-INFO', 'setup.cfg', 'setup.py', 'simple', 'simple.egg-info'
        ])
    finally:
        rmtree(temp_dir)


def test_user_agent():
    PipSession().headers["User-Agent"].startswith("pip/%s" % pip.__version__)


def _write_file(fn, contents):
    with open(fn, 'w') as fh:
        fh.write(contents)


class FakeStream(object):

    def __init__(self, contents):
        self._io = BytesIO(contents)

    def read(self, size, decode_content=None):
        return self._io.read(size)

    def stream(self, size, decode_content=None):
        yield self._io.read(size)


class MockResponse(object):

    def __init__(self, contents):
        self.raw = FakeStream(contents)

    def raise_for_status(self):
        pass


@patch('pip.download.unpack_file')
def test_unpack_http_url_bad_downloaded_checksum(mock_unpack_file):
    """
    If already-downloaded file has bad checksum, re-download.
    """
    base_url = 'http://www.example.com/somepackage.tgz'
    contents = b('downloaded')
    download_hash = hashlib.new('sha1', contents)
    link = Link(base_url + '#sha1=' + download_hash.hexdigest())

    session = Mock()
    session.get = Mock()
    response = session.get.return_value = MockResponse(contents)
    response.headers = {'content-type': 'application/x-tar'}
    response.url = base_url

    download_dir = mkdtemp()
    try:
        downloaded_file = os.path.join(download_dir, 'somepackage.tgz')
        _write_file(downloaded_file, 'some contents')

        unpack_http_url(
            link,
            'location',
            download_dir=download_dir,
            session=session,
        )

        # despite existence of downloaded file with bad hash, downloaded again
        session.get.assert_called_once_with(
            'http://www.example.com/somepackage.tgz',
            headers={"Accept-Encoding": "identity"},
            stream=True,
        )
        # cached file is replaced with newly downloaded file
        with open(downloaded_file) as fh:
            assert fh.read() == 'downloaded'

    finally:
        rmtree(download_dir)


@pytest.mark.skipif("sys.platform == 'win32'")
def test_path_to_url_unix():
    assert path_to_url('/tmp/file') == 'file:///tmp/file'
    path = os.path.join(os.getcwd(), 'file')
    assert path_to_url('file') == 'file://' + pathname2url(path)


@pytest.mark.skipif("sys.platform == 'win32'")
def test_url_to_path_unix():
    assert url_to_path('file:///tmp/file') == '/tmp/file'


@pytest.mark.skipif("sys.platform != 'win32'")
def test_path_to_url_win():
    assert path_to_url('c:/tmp/file') == 'file:///c:/tmp/file'
    assert path_to_url('c:\\tmp\\file') == 'file:///c:/tmp/file'
    path = os.path.join(os.getcwd(), 'file')
    assert path_to_url('file') == 'file:' + pathname2url(path)


@pytest.mark.skipif("sys.platform != 'win32'")
def test_url_to_path_win():
    assert url_to_path('file:///c:/tmp/file') == 'c:/tmp/file'


class Test_unpack_file_url(object):

    def prep(self, tmpdir, data):
        self.build_dir = tmpdir.join('build')
        self.download_dir = tmpdir.join('download')
        os.mkdir(self.build_dir)
        os.mkdir(self.download_dir)
        self.dist_file = "simple-1.0.tar.gz"
        self.dist_file2 = "simple-2.0.tar.gz"
        self.dist_path = data.packages.join(self.dist_file)
        self.dist_path2 = data.packages.join(self.dist_file2)
        self.dist_url = Link(path_to_url(self.dist_path))
        self.dist_url2 = Link(path_to_url(self.dist_path2))

    def test_unpack_file_url_no_download(self, tmpdir, data):
        self.prep(tmpdir, data)
        unpack_file_url(self.dist_url, self.build_dir)
        assert os.path.isdir(os.path.join(self.build_dir, 'simple'))
        assert not os.path.isfile(
            os.path.join(self.download_dir, self.dist_file))

    def test_unpack_file_url_and_download(self, tmpdir, data):
        self.prep(tmpdir, data)
        unpack_file_url(self.dist_url, self.build_dir,
                        download_dir=self.download_dir)
        assert os.path.isdir(os.path.join(self.build_dir, 'simple'))
        assert os.path.isfile(os.path.join(self.download_dir, self.dist_file))

    def test_unpack_file_url_download_already_exists(self, tmpdir,
                                                     data, monkeypatch):
        self.prep(tmpdir, data)
        # add in previous download (copy simple-2.0 as simple-1.0)
        # so we can tell it didn't get overwritten
        dest_file = os.path.join(self.download_dir, self.dist_file)
        copy(self.dist_path2, dest_file)
        dist_path2_md5 = hashlib.md5(
            open(self.dist_path2, 'rb').read()).hexdigest()

        unpack_file_url(self.dist_url, self.build_dir,
                        download_dir=self.download_dir)
        # our hash should be the same, i.e. not overwritten by simple-1.0 hash
        assert dist_path2_md5 == hashlib.md5(
            open(dest_file, 'rb').read()).hexdigest()

    def test_unpack_file_url_bad_hash(self, tmpdir, data,
                                      monkeypatch):
        """
        Test when the file url hash fragment is wrong
        """
        self.prep(tmpdir, data)
        self.dist_url.url = "%s#md5=bogus" % self.dist_url.url
        with pytest.raises(HashMismatch):
            unpack_file_url(self.dist_url, self.build_dir)

    def test_unpack_file_url_download_bad_hash(self, tmpdir, data,
                                               monkeypatch):
        """
        Test when existing download has different hash from the file url
        fragment
        """
        self.prep(tmpdir, data)

        # add in previous download (copy simple-2.0 as simple-1.0 so it's wrong
        # hash)
        dest_file = os.path.join(self.download_dir, self.dist_file)
        copy(self.dist_path2, dest_file)

        dist_path_md5 = hashlib.md5(
            open(self.dist_path, 'rb').read()).hexdigest()
        dist_path2_md5 = hashlib.md5(open(dest_file, 'rb').read()).hexdigest()

        assert dist_path_md5 != dist_path2_md5

        self.dist_url.url = "%s#md5=%s" % (
            self.dist_url.url,
            dist_path_md5
        )
        unpack_file_url(self.dist_url, self.build_dir,
                        download_dir=self.download_dir)

        # confirm hash is for simple1-1.0
        # the previous bad download has been removed
        assert (hashlib.md5(open(dest_file, 'rb').read()).hexdigest()
                ==
                dist_path_md5
                ), hashlib.md5(open(dest_file, 'rb').read()).hexdigest()

    def test_unpack_file_url_thats_a_dir(self, tmpdir, data):
        self.prep(tmpdir, data)
        dist_path = data.packages.join("FSPkg")
        dist_url = Link(path_to_url(dist_path))
        unpack_file_url(dist_url, self.build_dir,
                        download_dir=self.download_dir)
        assert os.path.isdir(os.path.join(self.build_dir, 'fspkg'))


class TestSafeFileCache:

    def test_cache_roundtrip(self, tmpdir):
        cache_dir = tmpdir.join("test-cache")
        cache_dir.makedirs()

        cache = SafeFileCache(cache_dir)
        assert cache.get("test key") is None
        cache.set("test key", b"a test string")
        assert cache.get("test key") == b"a test string"
        cache.delete("test key")
        assert cache.get("test key") is None

    def test_safe_get_no_perms(self, tmpdir, monkeypatch):
        cache_dir = tmpdir.join("unreadable-cache")
        cache_dir.makedirs()
        os.chmod(cache_dir, 000)

        monkeypatch.setattr(os.path, "exists", lambda x: True)

        cache = SafeFileCache(cache_dir)
        cache.get("foo")

    def test_safe_set_no_perms(self, tmpdir):
        cache_dir = tmpdir.join("unreadable-cache")
        cache_dir.makedirs()
        os.chmod(cache_dir, 000)

        cache = SafeFileCache(cache_dir)
        cache.set("foo", "bar")

    def test_safe_delete_no_perms(self, tmpdir):
        cache_dir = tmpdir.join("unreadable-cache")
        cache_dir.makedirs()
        os.chmod(cache_dir, 000)

        cache = SafeFileCache(cache_dir)
        cache.delete("foo")


class TestPipSession:

    def test_cache_defaults_off(self):
        session = PipSession()

        assert not hasattr(session.adapters["http://"], "cache")
        assert not hasattr(session.adapters["https://"], "cache")

    def test_cache_is_enabled(self, tmpdir):
        session = PipSession(cache=tmpdir.join("test-cache"))

        assert hasattr(session.adapters["http://"], "cache")
        assert hasattr(session.adapters["https://"], "cache")

        assert (session.adapters["http://"].cache.directory
                == tmpdir.join("test-cache"))
        assert (session.adapters["https://"].cache.directory
                == tmpdir.join("test-cache"))

########NEW FILE########
__FILENAME__ = test_download_hashes
import pytest

from pip.download import _get_hash_from_file, _check_hash
from pip.exceptions import InstallationError
from pip.index import Link


def test_get_hash_from_file_md5(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#md5=d41d8cd98f00b204e9800998ecf8427e"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    assert download_hash.digest_size == 16
    assert download_hash.hexdigest() == "d41d8cd98f00b204e9800998ecf8427e"


def test_get_hash_from_file_sha1(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#sha1=da39a3ee5e6b4b0d3255bfef95601890afd80709"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    assert download_hash.digest_size == 20
    assert download_hash.hexdigest() == (
        "da39a3ee5e6b4b0d3255bfef95601890afd80709"
    )


def test_get_hash_from_file_sha224(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#sha224=d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    assert download_hash.digest_size == 28
    assert download_hash.hexdigest() == (
        "d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f"
    )


def test_get_hash_from_file_sha384(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#sha384=38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e"
        "1da274edebfe76f65fbd51ad2f14898b95b"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    assert download_hash.digest_size == 48
    assert download_hash.hexdigest() == (
        "38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6e1da274e"
        "debfe76f65fbd51ad2f14898b95b"
    )


def test_get_hash_from_file_sha256(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#sha256=e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852"
        "b855"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    assert download_hash.digest_size == 32
    assert download_hash.hexdigest() == (
        "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
    )


def test_get_hash_from_file_sha512(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#sha512=cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36"
        "ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    assert download_hash.digest_size == 64
    assert download_hash.hexdigest() == (
        "cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0"
        "d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"
    )


def test_get_hash_from_file_unknown(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#unknown_hash=d41d8cd98f00b204e9800998ecf8427e"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    assert download_hash is None


def test_check_hash_md5_valid(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#md5=d41d8cd98f00b204e9800998ecf8427e"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    _check_hash(download_hash, file_link)


def test_check_hash_md5_invalid(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link("http://testserver/gmpy-1.15.tar.gz#md5=deadbeef")

    download_hash = _get_hash_from_file(file_path, file_link)

    with pytest.raises(InstallationError):
        _check_hash(download_hash, file_link)


def test_check_hash_sha1_valid(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#sha1=da39a3ee5e6b4b0d3255bfef95601890afd80709"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    _check_hash(download_hash, file_link)


def test_check_hash_sha1_invalid(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link("http://testserver/gmpy-1.15.tar.gz#sha1=deadbeef")

    download_hash = _get_hash_from_file(file_path, file_link)

    with pytest.raises(InstallationError):
        _check_hash(download_hash, file_link)


def test_check_hash_sha224_valid(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#sha224=d14a028c2a3a2bc9476102bb288234c415a2b01f828ea62ac5b3e42f'"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    _check_hash(download_hash, file_link)


def test_check_hash_sha224_invalid(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link("http://testserver/gmpy-1.15.tar.gz#sha224=deadbeef")

    download_hash = _get_hash_from_file(file_path, file_link)

    with pytest.raises(InstallationError):
        _check_hash(download_hash, file_link)


def test_check_hash_sha384_valid(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#sha384=38b060a751ac96384cd9327eb1b1e36a21fdb71114be07434c0cc7bf63f6"
        "e1da274edebfe76f65fbd51ad2f14898b95b"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    _check_hash(download_hash, file_link)


def test_check_hash_sha384_invalid(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link("http://testserver/gmpy-1.15.tar.gz#sha384=deadbeef")

    download_hash = _get_hash_from_file(file_path, file_link)

    with pytest.raises(InstallationError):
        _check_hash(download_hash, file_link)


def test_check_hash_sha256_valid(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#sha256=e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b785"
        "2b855"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    _check_hash(download_hash, file_link)


def test_check_hash_sha256_invalid(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link("http://testserver/gmpy-1.15.tar.gz#sha256=deadbeef")

    download_hash = _get_hash_from_file(file_path, file_link)

    with pytest.raises(InstallationError):
        _check_hash(download_hash, file_link)


def test_check_hash_sha512_valid(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#sha512=cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36c"
        "e9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    _check_hash(download_hash, file_link)


def test_check_hash_sha512_invalid(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link("http://testserver/gmpy-1.15.tar.gz#sha512=deadbeef")

    download_hash = _get_hash_from_file(file_path, file_link)

    with pytest.raises(InstallationError):
        _check_hash(download_hash, file_link)


def test_check_hasher_mismsatch(data):
    file_path = data.packages.join("gmpy-1.15.tar.gz")
    file_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#md5=d41d8cd98f00b204e9800998ecf8427e"
    )
    other_link = Link(
        "http://testserver/gmpy-1.15.tar.gz"
        "#sha256=e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b785"
        "2b855"
    )

    download_hash = _get_hash_from_file(file_path, file_link)

    with pytest.raises(InstallationError):
        _check_hash(download_hash, other_link)

########NEW FILE########
__FILENAME__ = test_finder
import pytest

import pip.wheel
import pip.pep425tags

from pkg_resources import parse_version, Distribution
from pip.log import logger
from pip.req import InstallRequirement
from pip.index import PackageFinder, Link
from pip.exceptions import (
    BestVersionAlreadyInstalled, DistributionNotFound, InstallationError,
)
from pip.util import Inf
from pip.download import PipSession

from mock import Mock, patch


def test_no_mpkg(data):
    """Finder skips zipfiles with "macosx10" in the name."""
    finder = PackageFinder([data.find_links], [], session=PipSession())
    req = InstallRequirement.from_line("pkgwithmpkg")
    found = finder.find_requirement(req, False)

    assert found.url.endswith("pkgwithmpkg-1.0.tar.gz"), found


def test_no_partial_name_match(data):
    """Finder requires the full project name to match, not just beginning."""
    finder = PackageFinder([data.find_links], [], session=PipSession())
    req = InstallRequirement.from_line("gmpy")
    found = finder.find_requirement(req, False)

    assert found.url.endswith("gmpy-1.15.tar.gz"), found


def test_duplicates_sort_ok(data):
    """Finder successfully finds one of a set of duplicates in different
    locations"""
    finder = PackageFinder(
        [data.find_links, data.find_links2],
        [],
        session=PipSession(),
    )
    req = InstallRequirement.from_line("duplicate")
    found = finder.find_requirement(req, False)

    assert found.url.endswith("duplicate-1.0.tar.gz"), found


def test_finder_detects_latest_find_links(data):
    """Test PackageFinder detects latest using find-links"""
    req = InstallRequirement.from_line('simple', None)
    finder = PackageFinder([data.find_links], [], session=PipSession())
    link = finder.find_requirement(req, False)
    assert link.url.endswith("simple-3.0.tar.gz")


def test_finder_detects_latest_already_satisfied_find_links(data):
    """Test PackageFinder detects latest already satisfied using find-links"""
    req = InstallRequirement.from_line('simple', None)
    # the latest simple in local pkgs is 3.0
    latest_version = "3.0"
    satisfied_by = Mock(
        location="/path",
        parsed_version=parse_version(latest_version),
        version=latest_version
    )
    req.satisfied_by = satisfied_by
    finder = PackageFinder([data.find_links], [], session=PipSession())

    with pytest.raises(BestVersionAlreadyInstalled):
        finder.find_requirement(req, True)


def test_finder_detects_latest_already_satisfied_pypi_links():
    """Test PackageFinder detects latest already satisfied using pypi links"""
    req = InstallRequirement.from_line('initools', None)
    # the latest initools on pypi is 0.3.1
    latest_version = "0.3.1"
    satisfied_by = Mock(
        location="/path",
        parsed_version=parse_version(latest_version),
        version=latest_version,
    )
    req.satisfied_by = satisfied_by
    finder = PackageFinder(
        [],
        ["http://pypi.python.org/simple"],
        session=PipSession(),
    )

    with pytest.raises(BestVersionAlreadyInstalled):
        finder.find_requirement(req, True)


class TestWheel:

    def teardown(self):
        logger.consumers = []

    def test_skip_invalid_wheel_link(self, data):
        """
        Test if PackageFinder skips invalid wheel filenames
        """
        log = []
        logger.add_consumers((logger.DEBUG, log.append))
        req = InstallRequirement.from_line("invalid")
        # data.find_links contains "invalid.whl", which is an invalid wheel
        finder = PackageFinder(
            [data.find_links],
            [],
            use_wheel=True,
            session=PipSession(),
        )
        with pytest.raises(DistributionNotFound):
            finder.find_requirement(req, True)
        "invalid.whl because the wheel filename is invalid" in "".join(log)

    def test_not_find_wheel_not_supported(self, data, monkeypatch):
        """
        Test not finding an unsupported wheel.
        """
        monkeypatch.setattr(
            pip.pep425tags,
            "supported_tags",
            [('py1', 'none', 'any')],
        )

        req = InstallRequirement.from_line("simple.dist")
        finder = PackageFinder(
            [data.find_links],
            [],
            use_wheel=True,
            session=PipSession(),
        )

        with pytest.raises(DistributionNotFound):
            finder.find_requirement(req, True)

    def test_find_wheel_supported(self, data, monkeypatch):
        """
        Test finding supported wheel.
        """
        monkeypatch.setattr(
            pip.pep425tags,
            "supported_tags",
            [('py2', 'none', 'any')],
        )

        req = InstallRequirement.from_line("simple.dist")
        finder = PackageFinder(
            [data.find_links],
            [],
            use_wheel=True,
            session=PipSession(),
        )
        found = finder.find_requirement(req, True)
        assert (
            found.url.endswith("simple.dist-0.1-py2.py3-none-any.whl"), found
        )

    def test_wheel_over_sdist_priority(self, data):
        """
        Test wheels have priority over sdists.
        `test_link_sorting` also covers this at lower level
        """
        req = InstallRequirement.from_line("priority")
        finder = PackageFinder(
            [data.find_links],
            [],
            use_wheel=True,
            session=PipSession(),
        )
        found = finder.find_requirement(req, True)
        assert found.url.endswith("priority-1.0-py2.py3-none-any.whl"), found

    def test_existing_over_wheel_priority(self, data):
        """
        Test existing install has priority over wheels.
        `test_link_sorting` also covers this at a lower level
        """
        req = InstallRequirement.from_line('priority', None)
        latest_version = "1.0"
        satisfied_by = Mock(
            location="/path",
            parsed_version=parse_version(latest_version),
            version=latest_version,
        )
        req.satisfied_by = satisfied_by
        finder = PackageFinder(
            [data.find_links],
            [],
            use_wheel=True,
            session=PipSession(),
        )

        with pytest.raises(BestVersionAlreadyInstalled):
            finder.find_requirement(req, True)

    @patch('pip.pep425tags.supported_tags', [
        ('pyT', 'none', 'TEST'),
        ('pyT', 'TEST', 'any'),
        ('pyT', 'none', 'any'),
    ])
    def test_link_sorting(self):
        """
        Test link sorting
        """
        links = [
            (parse_version('2.0'), Link(Inf), '2.0'),
            (parse_version('2.0'), Link('simple-2.0.tar.gz'), '2.0'),
            (
                parse_version('1.0'),
                Link('simple-1.0-pyT-none-TEST.whl'),
                '1.0',
            ),
            (parse_version('1.0'), Link('simple-1.0-pyT-TEST-any.whl'), '1.0'),
            (parse_version('1.0'), Link('simple-1.0-pyT-none-any.whl'), '1.0'),
            (parse_version('1.0'), Link('simple-1.0.tar.gz'), '1.0'),
        ]

        finder = PackageFinder([], [], session=PipSession())
        finder.use_wheel = True

        results = finder._sort_versions(links)
        results2 = finder._sort_versions(sorted(links, reverse=True))

        assert links == results == results2, results2

    @patch('pip.pep425tags.supported_tags', [])
    def test_link_sorting_raises_when_wheel_unsupported(self):
        links = [
            (
                parse_version('1.0'),
                Link('simple-1.0-py2.py3-none-TEST.whl'),
                '1.0',
            ),
        ]
        finder = PackageFinder([], [], use_wheel=True, session=PipSession())
        with pytest.raises(InstallationError):
            finder._sort_versions(links)


def test_finder_priority_file_over_page(data):
    """Test PackageFinder prefers file links over equivalent page links"""
    req = InstallRequirement.from_line('gmpy==1.15', None)
    finder = PackageFinder(
        [data.find_links],
        ["http://pypi.python.org/simple"],
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.url.startswith("file://")


def test_finder_priority_nonegg_over_eggfragments():
    """Test PackageFinder prefers non-egg links over "#egg=" links"""
    req = InstallRequirement.from_line('bar==1.0', None)
    links = ['http://foo/bar.py#egg=bar-1.0', 'http://foo/bar-1.0.tar.gz']

    finder = PackageFinder(links, [], session=PipSession())

    with patch.object(finder, "_get_pages", lambda x, y: []):
        link = finder.find_requirement(req, False)

    assert link.url.endswith('tar.gz')

    links.reverse()
    finder = PackageFinder(links, [], session=PipSession())

    with patch.object(finder, "_get_pages", lambda x, y: []):
        link = finder.find_requirement(req, False)

    assert link.url.endswith('tar.gz')


def test_finder_only_installs_stable_releases(data):
    """
    Test PackageFinder only accepts stable versioned releases by default.
    """

    req = InstallRequirement.from_line("bar", None)

    # using a local index (that has pre & dev releases)
    finder = PackageFinder([], [data.index_url("pre")], session=PipSession())
    link = finder.find_requirement(req, False)
    assert link.url.endswith("bar-1.0.tar.gz"), link.url

    # using find-links
    links = ["https://foo/bar-1.0.tar.gz", "https://foo/bar-2.0b1.tar.gz"]
    finder = PackageFinder(links, [], session=PipSession())

    with patch.object(finder, "_get_pages", lambda x, y: []):
        link = finder.find_requirement(req, False)
        assert link.url == "https://foo/bar-1.0.tar.gz"

    links.reverse()
    finder = PackageFinder(links, [], session=PipSession())

    with patch.object(finder, "_get_pages", lambda x, y: []):
        link = finder.find_requirement(req, False)
        assert link.url == "https://foo/bar-1.0.tar.gz"


def test_finder_installs_pre_releases(data):
    """
    Test PackageFinder finds pre-releases if asked to.
    """

    req = InstallRequirement.from_line("bar", None, prereleases=True)

    # using a local index (that has pre & dev releases)
    finder = PackageFinder([], [data.index_url("pre")], session=PipSession())
    link = finder.find_requirement(req, False)
    assert link.url.endswith("bar-2.0b1.tar.gz"), link.url

    # using find-links
    links = ["https://foo/bar-1.0.tar.gz", "https://foo/bar-2.0b1.tar.gz"]
    finder = PackageFinder(links, [], session=PipSession())

    with patch.object(finder, "_get_pages", lambda x, y: []):
        link = finder.find_requirement(req, False)
        assert link.url == "https://foo/bar-2.0b1.tar.gz"

    links.reverse()
    finder = PackageFinder(links, [], session=PipSession())

    with patch.object(finder, "_get_pages", lambda x, y: []):
        link = finder.find_requirement(req, False)
        assert link.url == "https://foo/bar-2.0b1.tar.gz"


def test_finder_installs_dev_releases(data):
    """
    Test PackageFinder finds dev releases if asked to.
    """

    req = InstallRequirement.from_line("bar", None, prereleases=True)

    # using a local index (that has dev releases)
    finder = PackageFinder([], [data.index_url("dev")], session=PipSession())
    link = finder.find_requirement(req, False)
    assert link.url.endswith("bar-2.0.dev1.tar.gz"), link.url


def test_finder_installs_pre_releases_with_version_spec():
    """
    Test PackageFinder only accepts stable versioned releases by default.
    """
    req = InstallRequirement.from_line("bar>=0.0.dev0", None)
    links = ["https://foo/bar-1.0.tar.gz", "https://foo/bar-2.0b1.tar.gz"]

    finder = PackageFinder(links, [], session=PipSession())

    with patch.object(finder, "_get_pages", lambda x, y: []):
        link = finder.find_requirement(req, False)
        assert link.url == "https://foo/bar-2.0b1.tar.gz"

    links.reverse()
    finder = PackageFinder(links, [], session=PipSession())

    with patch.object(finder, "_get_pages", lambda x, y: []):
        link = finder.find_requirement(req, False)
        assert link.url == "https://foo/bar-2.0b1.tar.gz"


def test_finder_ignores_external_links(data):
    """
    Tests that PackageFinder ignores external links, with or without hashes.
    """
    req = InstallRequirement.from_line("bar", None)

    # using a local index
    finder = PackageFinder(
        [],
        [data.index_url("externals")],
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.filename == "bar-1.0.tar.gz"


def test_finder_finds_external_links_with_hashes_per_project(data):
    """
    Tests that PackageFinder finds external links but only if they have a hash
    using the per project configuration.
    """
    req = InstallRequirement.from_line("bar", None)

    # using a local index
    finder = PackageFinder(
        [],
        [data.index_url("externals")],
        allow_external=["bar"],
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.filename == "bar-2.0.tar.gz"


def test_finder_finds_external_links_with_hashes_all(data):
    """
    Tests that PackageFinder finds external links but only if they have a hash
    using the all externals flag.
    """
    req = InstallRequirement.from_line("bar", None)

    # using a local index
    finder = PackageFinder(
        [],
        [data.index_url("externals")],
        allow_all_external=True,
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.filename == "bar-2.0.tar.gz"


def test_finder_finds_external_links_without_hashes_per_project(data):
    """
    Tests that PackageFinder finds external links if they do not have a hash
    """
    req = InstallRequirement.from_line("bar==3.0", None)

    # using a local index
    finder = PackageFinder(
        [],
        [data.index_url("externals")],
        allow_external=["bar"],
        allow_unverified=["bar"],
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.filename == "bar-3.0.tar.gz"


def test_finder_finds_external_links_without_hashes_all(data):
    """
    Tests that PackageFinder finds external links if they do not have a hash
    using the all external flag
    """
    req = InstallRequirement.from_line("bar==3.0", None)

    # using a local index
    finder = PackageFinder(
        [],
        [data.index_url("externals")],
        allow_all_external=True,
        allow_unverified=["bar"],
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.filename == "bar-3.0.tar.gz"


def test_finder_finds_external_links_without_hashes_scraped_per_project(data):
    """
    Tests that PackageFinder finds externally scraped links
    """
    req = InstallRequirement.from_line("bar", None)

    # using a local index
    finder = PackageFinder(
        [],
        [data.index_url("externals")],
        allow_external=["bar"],
        allow_unverified=["bar"],
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.filename == "bar-4.0.tar.gz"


def test_finder_finds_external_links_without_hashes_scraped_all(data):
    """
    Tests that PackageFinder finds externally scraped links using the all
    external flag.
    """
    req = InstallRequirement.from_line("bar", None)

    # using a local index
    finder = PackageFinder(
        [],
        [data.index_url("externals")],
        allow_all_external=True,
        allow_unverified=["bar"],
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.filename == "bar-4.0.tar.gz"


def test_finder_finds_external_links_without_hashes_per_project_all_insecure(
        data):
    """
    Tests that PackageFinder finds external links if they do not have a hash
    """
    req = InstallRequirement.from_line("bar==3.0", None)

    # using a local index
    finder = PackageFinder(
        [],
        [data.index_url("externals")],
        allow_external=["bar"],
        allow_unverified=["bar"],
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.filename == "bar-3.0.tar.gz"


def test_finder_finds_external_links_without_hashes_all_all_insecure(data):
    """
    Tests that PackageFinder finds external links if they do not have a hash
    using the all external flag
    """
    req = InstallRequirement.from_line("bar==3.0", None)

    # using a local index
    finder = PackageFinder(
        [],
        [data.index_url("externals")],
        allow_all_external=True,
        allow_unverified=["bar"],
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.filename == "bar-3.0.tar.gz"


def test_finder_finds_external_links_without_hashes_scraped_per_project_all_insecure(data):  # noqa
    """
    Tests that PackageFinder finds externally scraped links
    """
    req = InstallRequirement.from_line("bar", None)

    # using a local index
    finder = PackageFinder(
        [],
        [data.index_url("externals")],
        allow_external=["bar"],
        allow_unverified=["bar"],
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.filename == "bar-4.0.tar.gz"


def test_finder_finds_external_links_without_hashes_scraped_all_all_insecure(
        data):
    """
    Tests that PackageFinder finds externally scraped links using the all
    external flag.
    """
    req = InstallRequirement.from_line("bar", None)

    # using a local index
    finder = PackageFinder(
        [],
        [data.index_url("externals")],
        allow_all_external=True,
        allow_unverified=["bar"],
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.filename == "bar-4.0.tar.gz"


def test_finder_finds_external_links_without_hashes_scraped_insecure(data):
    """
    Tests that PackageFinder finds externally scraped links without the
    external flag
    """
    req = InstallRequirement.from_line("bar", None)

    # using a local index
    finder = PackageFinder(
        [],
        [data.index_url("externals")],
        allow_unverified=["bar"],
        session=PipSession(),
    )
    link = finder.find_requirement(req, False)
    assert link.filename == "bar-4.0.tar.gz"


class test_link_package_versions(object):

    # patch this for travis which has distribute in its base env for now
    @patch(
        'pip.wheel.pkg_resources.get_distribution',
        lambda x: Distribution(project_name='setuptools', version='0.9')
    )
    def setup(self):
        self.version = '1.0'
        self.parsed_version = parse_version(self.version)
        self.search_name = 'pytest'
        self.finder = PackageFinder(
            [],
            [],
            use_wheel=True,
            session=PipSession(),
        )

    def test_link_package_versions_match_wheel(self):
        """Test that 'pytest' archives match for 'pytest'"""

        # TODO: Uncomment these, when #1217 is fixed
        # link = Link('http:/yo/pytest-1.0.tar.gz')
        # result = self.finder._link_package_versions(link, self.search_name)
        # assert result == [(self.parsed_version, link, self.version)], result

        link = Link('http:/yo/pytest-1.0-py2.py3-none-any.whl')
        result = self.finder._link_package_versions(link, self.search_name)
        assert result == [(self.parsed_version, link, self.version)], result

    def test_link_package_versions_substring_fails(self):
        """Test that 'pytest<something> archives won't match for 'pytest'"""

        # TODO: Uncomment these, when #1217 is fixed
        # link = Link('http:/yo/pytest-xdist-1.0.tar.gz')
        # result = self.finder._link_package_versions(link, self.search_name)
        # assert result == [], result

        # link = Link('http:/yo/pytest2-1.0.tar.gz')
        # result = self.finder._link_package_versions(link, self.search_name)
        # assert result == [], result

        link = Link('http:/yo/pytest_xdist-1.0-py2.py3-none-any.whl')
        result = self.finder._link_package_versions(link, self.search_name)
        assert result == [], result

########NEW FILE########
__FILENAME__ = test_index
from pip.download import PipSession
from pip.index import package_to_requirement, HTMLPage
from pip.index import PackageFinder, Link, INSTALLED_VERSION


def test_package_name_should_be_converted_to_requirement():
    """
    Test that it translates a name like Foo-1.2 to Foo==1.3
    """
    assert package_to_requirement('Foo-1.2') == 'Foo==1.2'
    assert package_to_requirement('Foo-dev') == 'Foo==dev'
    assert package_to_requirement('Foo') == 'Foo'


def test_html_page_should_be_able_to_scrap_rel_links():
    """
    Test scraping page looking for url in href
    """
    page = HTMLPage(
        """
<!-- The <th> elements below are a terrible terrible hack for setuptools -->
<li>
<strong>Home Page:</strong>
<!-- <th>Home Page -->
<a href="http://supervisord.org/">http://supervisord.org/</a>
</li>
        """,
        "supervisor",
    )

    links = list(page.scraped_rel_links())
    assert len(links) == 1
    assert links[0].url == 'http://supervisord.org/'


def test_sort_locations_file_find_link(data):
    """
    Test that a file:// find-link dir gets listdir run
    """
    finder = PackageFinder([data.find_links], [], session=PipSession())
    files, urls = finder._sort_locations([data.find_links])
    assert files and not urls, (
        "files and not urls should have been found at find-links url: %s" %
        data.find_links
    )


def test_sort_locations_file_not_find_link(data):
    """
    Test that a file:// url dir that's not a find-link, doesn't get a listdir
    run
    """
    finder = PackageFinder([], [], session=PipSession())
    files, urls = finder._sort_locations(data.index_url("empty_with_pkg"))
    assert urls and not files, "urls, but not files should have been found"


def test_INSTALLED_VERSION_greater():
    """Test INSTALLED_VERSION compares greater."""
    assert INSTALLED_VERSION > Link("some link")


class TestLink(object):

    def test_splitext(self):
        assert ('wheel', '.whl') == Link('http://yo/wheel.whl').splitext()

    def test_filename(self):
        assert 'wheel.whl' == Link('http://yo/wheel.whl').filename
        assert 'wheel' == Link('http://yo/wheel').filename

    def test_no_ext(self):
        assert '' == Link('http://yo/wheel').ext

    def test_ext(self):
        assert '.whl' == Link('http://yo/wheel.whl').ext

    def test_ext_fragment(self):
        assert '.whl' == Link('http://yo/wheel.whl#frag').ext

    def test_ext_query(self):
        assert '.whl' == Link('http://yo/wheel.whl?a=b').ext

########NEW FILE########
__FILENAME__ = test_locations
"""
locations.py tests

"""
import os
import sys
import shutil
import tempfile
import getpass

import pytest

from mock import Mock
import pip

from pip.locations import distutils_scheme

if sys.platform == 'win32':
    pwd = Mock()
else:
    import pwd


class TestLocations:
    def setup(self):
        self.tempdir = tempfile.mkdtemp()
        self.st_uid = 9999
        self.username = "example"
        self.patch()

    def teardown(self):
        self.revert_patch()
        shutil.rmtree(self.tempdir, ignore_errors=True)

    def patch(self):
        """ first store and then patch python methods pythons """
        self.tempfile_gettempdir = tempfile.gettempdir
        self.old_os_fstat = os.fstat
        if sys.platform != 'win32':
            # os.geteuid and pwd.getpwuid are not implemented on windows
            self.old_os_geteuid = os.geteuid
            self.old_pwd_getpwuid = pwd.getpwuid
        self.old_getpass_getuser = getpass.getuser

        # now patch
        tempfile.gettempdir = lambda: self.tempdir
        getpass.getuser = lambda: self.username
        os.geteuid = lambda: self.st_uid
        os.fstat = lambda fd: self.get_mock_fstat(fd)

        if sys.platform != 'win32':
            pwd.getpwuid = lambda uid: self.get_mock_getpwuid(uid)

    def revert_patch(self):
        """ revert the patches to python methods """
        tempfile.gettempdir = self.tempfile_gettempdir
        getpass.getuser = self.old_getpass_getuser
        if sys.platform != 'win32':
            # os.geteuid and pwd.getpwuid are not implemented on windows
            os.geteuid = self.old_os_geteuid
            pwd.getpwuid = self.old_pwd_getpwuid
        os.fstat = self.old_os_fstat

    def get_mock_fstat(self, fd):
        """ returns a basic mock fstat call result.
            Currently only the st_uid attribute has been set.
        """
        result = Mock()
        result.st_uid = self.st_uid
        return result

    def get_mock_getpwuid(self, uid):
        """ returns a basic mock pwd.getpwuid call result.
            Currently only the pw_name attribute has been set.
        """
        result = Mock()
        result.pw_name = self.username
        return result

    def get_build_dir_location(self):
        """ returns a string pointing to the
            current build_prefix.
        """
        return os.path.join(self.tempdir, 'pip_build_%s' % self.username)

    def test_dir_path(self):
        """ test the path name for the build_prefix
        """
        from pip import locations
        assert locations._get_build_prefix() == self.get_build_dir_location()

    # skip on windows, build dir is not created
    @pytest.mark.skipif("sys.platform == 'win32'")
    @pytest.mark.skipif("not hasattr(os, 'O_NOFOLLOW')")
    def test_dir_created(self):
        """ test that the build_prefix directory is generated when
            _get_build_prefix is called.
        """
        assert not os.path.exists(self.get_build_dir_location()), \
            "the build_prefix directory should not exist yet!"
        from pip import locations
        locations._get_build_prefix()
        assert os.path.exists(self.get_build_dir_location()), \
            "the build_prefix directory should now exist!"

    # skip on windows, build dir is not created
    @pytest.mark.skipif("sys.platform == 'win32'")
    def test_dir_created_without_NOFOLLOW(self, monkeypatch):
        """ test that the build_prefix directory is generated when
            os.O_NOFOLLOW doen't exist
        """
        if hasattr(os, 'O_NOFOLLOW'):
            monkeypatch.delattr("os.O_NOFOLLOW")
        assert not os.path.exists(self.get_build_dir_location()), \
            "the build_prefix directory should not exist yet!"
        from pip import locations
        locations._get_build_prefix()
        assert os.path.exists(self.get_build_dir_location()), \
            "the build_prefix directory should now exist!"

    # skip on windows; this exception logic only runs on linux
    @pytest.mark.skipif("sys.platform == 'win32'")
    @pytest.mark.skipif("not hasattr(os, 'O_NOFOLLOW')")
    def test_error_raised_when_owned_by_another(self):
        """ test calling _get_build_prefix when there is a temporary
            directory owned by another user raises an InstallationError.
        """
        from pip import locations
        os.geteuid = lambda: 1111
        os.mkdir(self.get_build_dir_location())

        with pytest.raises(pip.exceptions.InstallationError):
            locations._get_build_prefix()

    # skip on windows; this exception logic only runs on linux
    @pytest.mark.skipif("sys.platform == 'win32'")
    def test_error_raised_when_owned_by_another_without_NOFOLLOW(
            self, monkeypatch):
        """ test calling _get_build_prefix when there is a temporary
            directory owned by another user raises an InstallationError.
            (when os.O_NOFOLLOW doesn't exist
        """
        if hasattr(os, 'O_NOFOLLOW'):
            monkeypatch.delattr("os.O_NOFOLLOW")
        from pip import locations
        os.geteuid = lambda: 1111
        os.mkdir(self.get_build_dir_location())

        with pytest.raises(pip.exceptions.InstallationError):
            locations._get_build_prefix()

    def test_no_error_raised_when_owned_by_you(self):
        """ test calling _get_build_prefix when there is a temporary
            directory owned by you raise no InstallationError.
        """
        from pip import locations
        os.mkdir(self.get_build_dir_location())
        locations._get_build_prefix()


class TestDisutilsScheme:

    def test_root_modifies_appropiately(self):
        norm_scheme = distutils_scheme("example")
        root_scheme = distutils_scheme("example", root="/test/root/")

        for key, value in norm_scheme.items():
            expected = os.path.join("/test/root/", os.path.abspath(value)[1:])
            assert os.path.abspath(root_scheme[key]) == expected

    def test_distutils_config_file_read(self, tmpdir, monkeypatch):
        f = tmpdir.mkdir("config").join("setup.cfg")
        f.write("[install]\ninstall-scripts=/somewhere/else")
        from distutils.dist import Distribution
        # patch the function that returns what config files are present
        monkeypatch.setattr(
            Distribution,
            'find_config_files',
            lambda self: [f],
        )
        scheme = distutils_scheme('example')
        assert scheme['scripts'] == '/somewhere/else'

    def test_install_lib_takes_precedence(self, tmpdir, monkeypatch):
        f = tmpdir.mkdir("config").join("setup.cfg")
        f.write("[install]\ninstall-lib=/somewhere/else/")
        from distutils.dist import Distribution
        # patch the function that returns what config files are present
        monkeypatch.setattr(
            Distribution,
            'find_config_files',
            lambda self: [f],
        )
        scheme = distutils_scheme('example')
        assert scheme['platlib'] == '/somewhere/else/'
        assert scheme['purelib'] == '/somewhere/else/'

########NEW FILE########
__FILENAME__ = test_log
from pip.compat import StringIO
from pip.log import should_color, should_warn, Logger


def test_should_color_std():
    assert not should_color(object(), {}, std=[object()])


def test_should_color_isatty():
    class FakeTTY(object):
        def isatty(self):
            return True

    consumer = FakeTTY()
    assert should_color(consumer, {}, std=[consumer])


def test_should_color_environ():
    consumer = object()
    assert should_color(consumer, {"TERM": "ANSI"}, std=[consumer])


def test_should_color_notty_environ():
    consumer = object()
    assert not should_color(consumer, {}, std=[consumer])


def test_should_warn_greater_one_minor():
    assert should_warn("1.4", "1.6")


def test_should_warn_exactly_one_minor():
    assert not should_warn("1.5", "1.6")


def test_should_warn_equal():
    assert not should_warn("1.6", "1.6")


def test_should_warn_greater():
    assert not should_warn("1.7", "1.6")


def test_should_warn_significance():
    assert should_warn("1.4.dev1", "1.6")


def test_ignores_duplicate_consumers():
    """
    Make sure if the same consumer & level pair are asked to be added,
    they're ignored.
    """
    logger = Logger()

    import sys
    consumer1 = sys.stdout
    consumer2 = sys.stdout

    logger.add_consumers(
        (logger.NOTIFY, consumer1),
        (logger.NOTIFY, consumer2),
    )
    logger.add_consumers(
        (logger.NOTIFY, consumer1),
        (logger.NOTIFY, consumer2),
    )

    assert 1 == len(logger.consumers)


def test_ignores_Win32_wrapped_consumers(monkeypatch):
    """
    Test that colorama wrapped duplicate streams are ignored, too.
    """
    logger = Logger()
    consumer = StringIO()

    consumer1 = consumer
    consumer2 = consumer

    # Pretend to be Windows
    monkeypatch.setattr('sys.platform', 'win32')
    logger.add_consumers(
        (logger.NOTIFY, consumer1),
        (logger.NOTIFY, consumer2),
    )
    # Pretend to be linux
    monkeypatch.setattr('sys.platform', 'linux2')
    logger.add_consumers(
        (logger.NOTIFY, consumer2),
        (logger.NOTIFY, consumer1),
    )

    assert 1 == len(logger.consumers)


def test_log_no_extra_line_break():
    """
    Confirm that multiple `.write()` consumers doesn't result in additional
    '\n's per write
    """
    consumer1 = StringIO()
    consumer2 = StringIO()
    logger = Logger()
    logger.add_consumers(
        (logger.NOTIFY, consumer1),
        (logger.NOTIFY, consumer2)
    )
    logger.notify("one line")
    # splitlines(True) will detect empty line-breaks
    assert 1 == len(consumer1.getvalue().splitlines(True))
    assert 1 == len(consumer2.getvalue().splitlines(True))


def test_level_for_integer():
    logger = Logger()
    assert logger.VERBOSE_DEBUG == logger.level_for_integer(-1000)
    assert logger.VERBOSE_DEBUG == logger.level_for_integer(0)
    assert logger.DEBUG == logger.level_for_integer(1)
    assert logger.INFO == logger.level_for_integer(2)
    assert logger.NOTIFY == logger.level_for_integer(3)
    assert logger.WARN == logger.level_for_integer(4)
    assert logger.ERROR == logger.level_for_integer(5)
    assert logger.FATAL == logger.level_for_integer(6)
    assert logger.FATAL == logger.level_for_integer(1000)

########NEW FILE########
__FILENAME__ = test_options
import os
import pytest
import pip.baseparser
from pip import main
from pip import cmdoptions
from pip.basecommand import Command
from pip.commands import commands


class FakeCommand(Command):
    name = 'fake'
    summary = name

    def main(self, args):
        index_opts = cmdoptions.make_option_group(
            cmdoptions.index_group,
            self.parser,
        )
        self.parser.add_option_group(index_opts)
        return self.parse_args(args)


class TestOptionPrecedence(object):
    """
    Tests for confirming our option precedence:
         cli -> environment -> subcommand config -> global config -> option
         defaults
    """

    def setup(self):
        self.environ_before = os.environ.copy()
        commands[FakeCommand.name] = FakeCommand

    def teardown(self):
        os.environ = self.environ_before
        commands.pop(FakeCommand.name)

    def get_config_section(self, section):
        config = {
            'global': [('timeout', '-3')],
            'fake': [('timeout', '-2')],
        }
        return config[section]

    def get_config_section_global(self, section):
        config = {
            'global': [('timeout', '-3')],
            'fake': [],
        }
        return config[section]

    def test_env_override_default_int(self):
        """
        Test that environment variable overrides an int option default.
        """
        os.environ['PIP_TIMEOUT'] = '-1'
        options, args = main(['fake'])
        assert options.timeout == -1

    def test_env_override_default_append(self):
        """
        Test that environment variable overrides an append option default.
        """
        os.environ['PIP_FIND_LINKS'] = 'F1'
        options, args = main(['fake'])
        assert options.find_links == ['F1']

        os.environ['PIP_FIND_LINKS'] = 'F1 F2'
        options, args = main(['fake'])
        assert options.find_links == ['F1', 'F2']

    def test_env_override_default_choice(self):
        """
        Test that environment variable overrides a choice option default.
        """
        os.environ['PIP_EXISTS_ACTION'] = 'w'
        options, args = main(['fake'])
        assert options.exists_action == ['w']

        os.environ['PIP_EXISTS_ACTION'] = 's w'
        options, args = main(['fake'])
        assert options.exists_action == ['s', 'w']

    def test_env_alias_override_default(self):
        """
        When an option has multiple long forms, test that the technique of
        using the env variable, "PIP_<long form>" works for all cases.
        (e.g. PIP_LOG_FILE and PIP_LOCAL_LOG should all work)
        """
        os.environ['PIP_LOG_FILE'] = 'override.log'
        options, args = main(['fake'])
        assert options.log_file == 'override.log'
        os.environ['PIP_LOCAL_LOG'] = 'override.log'
        options, args = main(['fake'])
        assert options.log_file == 'override.log'

    def test_cli_override_environment(self):
        """
        Test the cli overrides and environment variable
        """
        os.environ['PIP_TIMEOUT'] = '-1'
        options, args = main(['fake', '--timeout', '-2'])
        assert options.timeout == -2

    def test_environment_override_config(self, monkeypatch):
        """
        Test an environment variable overrides the config file
        """
        monkeypatch.setattr(
            pip.baseparser.ConfigOptionParser,
            "get_config_section",
            self.get_config_section,
        )
        os.environ['PIP_TIMEOUT'] = '-1'
        options, args = main(['fake'])
        assert options.timeout == -1

    def test_commmand_config_override_global_config(self, monkeypatch):
        """
        Test that command config overrides global config
        """
        monkeypatch.setattr(
            pip.baseparser.ConfigOptionParser,
            "get_config_section",
            self.get_config_section,
        )
        options, args = main(['fake'])
        assert options.timeout == -2

    def test_global_config_is_used(self, monkeypatch):
        """
        Test that global config is used
        """
        monkeypatch.setattr(
            pip.baseparser.ConfigOptionParser,
            "get_config_section",
            self.get_config_section_global,
        )
        options, args = main(['fake'])
        assert options.timeout == -3


class TestOptionsInterspersed(object):

    def setup(self):
        self.environ_before = os.environ.copy()
        commands[FakeCommand.name] = FakeCommand

    def teardown(self):
        os.environ = self.environ_before
        commands.pop(FakeCommand.name)

    def test_general_option_after_subcommand(self):
        options, args = main(['fake', '--timeout', '-1'])
        assert options.timeout == -1

    def test_option_after_subcommand_arg(self):
        options, args = main(['fake', 'arg', '--timeout', '-1'])
        assert options.timeout == -1

    def test_additive_before_after_subcommand(self):
        options, args = main(['-v', 'fake', '-v'])
        assert options.verbose == 2

    def test_subcommand_option_before_subcommand_fails(self):
        with pytest.raises(SystemExit):
            main(['--find-links', 'F1', 'fake'])


class TestGeneralOptions(object):

    # the reason to specifically test general options is due to the
    # extra processing they receive, and the number of bugs we've had

    def setup(self):
        self.environ_before = os.environ.copy()
        commands[FakeCommand.name] = FakeCommand

    def teardown(self):
        os.environ = self.environ_before
        commands.pop(FakeCommand.name)

    def test_require_virtualenv(self):
        options1, args1 = main(['--require-virtualenv', 'fake'])
        options2, args2 = main(['fake', '--require-virtualenv'])
        assert options1.require_venv
        assert options2.require_venv

    def test_verbose(self):
        options1, args1 = main(['--verbose', 'fake'])
        options2, args2 = main(['fake', '--verbose'])
        assert options1.verbose == options2.verbose == 1

    def test_quiet(self):
        options1, args1 = main(['--quiet', 'fake'])
        options2, args2 = main(['fake', '--quiet'])
        assert options1.quiet == options2.quiet == 1

    def test_log(self):
        options1, args1 = main(['--log', 'path', 'fake'])
        options2, args2 = main(['fake', '--log', 'path'])
        assert options1.log == options2.log == 'path'

    def test_log_explicit_levels(self):
        options1, args1 = main(['--log-explicit-levels', 'fake'])
        options2, args2 = main(['fake', '--log-explicit-levels'])
        assert options1.log_explicit_levels
        assert options2.log_explicit_levels

    def test_local_log(self):
        options1, args1 = main(['--local-log', 'path', 'fake'])
        options2, args2 = main(['fake', '--local-log', 'path'])
        assert options1.log_file == options2.log_file == 'path'

    def test_no_input(self):
        options1, args1 = main(['--no-input', 'fake'])
        options2, args2 = main(['fake', '--no-input'])
        assert options1.no_input
        assert options2.no_input

    def test_proxy(self):
        options1, args1 = main(['--proxy', 'path', 'fake'])
        options2, args2 = main(['fake', '--proxy', 'path'])
        assert options1.proxy == options2.proxy == 'path'

    def test_retries(self):
        options1, args1 = main(['--retries', '-1', 'fake'])
        options2, args2 = main(['fake', '--retries', '-1'])
        assert options1.retries == options2.retries == -1

    def test_timeout(self):
        options1, args1 = main(['--timeout', '-1', 'fake'])
        options2, args2 = main(['fake', '--timeout', '-1'])
        assert options1.timeout == options2.timeout == -1

    def test_default_vcs(self):
        options1, args1 = main(['--default-vcs', 'path', 'fake'])
        options2, args2 = main(['fake', '--default-vcs', 'path'])
        assert options1.default_vcs == options2.default_vcs == 'path'

    def test_skip_requirements_regex(self):
        options1, args1 = main(['--skip-requirements-regex', 'path', 'fake'])
        options2, args2 = main(['fake', '--skip-requirements-regex', 'path'])
        assert options1.skip_requirements_regex == 'path'
        assert options2.skip_requirements_regex == 'path'

    def test_exists_action(self):
        options1, args1 = main(['--exists-action', 'w', 'fake'])
        options2, args2 = main(['fake', '--exists-action', 'w'])
        assert options1.exists_action == options2.exists_action == ['w']

    def test_cert(self):
        options1, args1 = main(['--cert', 'path', 'fake'])
        options2, args2 = main(['fake', '--cert', 'path'])
        assert options1.cert == options2.cert == 'path'

    def test_client_cert(self):
        options1, args1 = main(['--client-cert', 'path', 'fake'])
        options2, args2 = main(['fake', '--client-cert', 'path'])
        assert options1.client_cert == options2.client_cert == 'path'

    def test_no_check_certificate(self):
        options1, args1 = main(['--no-check-certificate', 'fake'])
        options2, args2 = main(['fake', '--no-check-certificate'])
        assert options1.no_check_certificate == options2.no_check_certificate


class TestOptionsConfigFiles(object):

    def test_venv_config_file_found(self, monkeypatch):
        # We only want a dummy object to call the get_config_files method
        monkeypatch.setattr(
            pip.baseparser.ConfigOptionParser,
            '__init__',
            lambda self: None,
        )

        # If we are running in a virtualenv and all files appear to exist,
        # we should see two config files.
        monkeypatch.setattr(
            pip.baseparser,
            'running_under_virtualenv',
            lambda: True,
        )
        monkeypatch.setattr(os.path, 'exists', lambda filename: True)
        cp = pip.baseparser.ConfigOptionParser()
        assert len(cp.get_config_files()) == 2

########NEW FILE########
__FILENAME__ = test_proxy
"""
Tests for the proxy support in pip.
"""

import pip

from tests.lib import SRC_DIR
from tests.lib.path import Path


def test_correct_pip_version():
    """
    Check we are importing pip from the right place.

    """
    assert Path(pip.__file__).folder.folder.abspath == SRC_DIR

########NEW FILE########
__FILENAME__ = test_req
import os
import shutil
import tempfile

import pytest

from mock import Mock, patch, mock_open
from pip.exceptions import (
    PreviousBuildDirError, InvalidWheelFilename, UnsupportedWheel,
)
from pip.download import PipSession
from pip._vendor import pkg_resources
from pip.index import PackageFinder
from pip.log import logger
from pip.req import (InstallRequirement, RequirementSet,
                     Requirements, parse_requirements)
from pip.req.req_install import parse_editable
from pip.util import read_text_file
from tests.lib import assert_raises_regexp


class TestRequirementSet(object):
    """RequirementSet tests"""

    def setup(self):
        logger.consumers = [(logger.NOTIFY, Mock())]
        self.tempdir = tempfile.mkdtemp()

    def teardown(self):
        logger.consumers = []
        shutil.rmtree(self.tempdir, ignore_errors=True)

    def basic_reqset(self):
        return RequirementSet(
            build_dir=os.path.join(self.tempdir, 'build'),
            src_dir=os.path.join(self.tempdir, 'src'),
            download_dir=None,
            session=PipSession(),
        )

    def test_no_reuse_existing_build_dir(self, data):
        """Test prepare_files raise exception with previous build dir"""

        build_dir = os.path.join(self.tempdir, 'build', 'simple')
        os.makedirs(build_dir)
        open(os.path.join(build_dir, "setup.py"), 'w')
        reqset = self.basic_reqset()
        req = InstallRequirement.from_line('simple')
        reqset.add_requirement(req)
        finder = PackageFinder([data.find_links], [], session=PipSession())
        assert_raises_regexp(
            PreviousBuildDirError,
            "pip can't proceed with [\s\S]*%s[\s\S]*%s" %
            (req, build_dir.replace('\\', '\\\\')),
            reqset.prepare_files,
            finder,
        )


@pytest.mark.parametrize(('file_contents', 'expected'), [
    (b'\xf6\x80', b'\xc3\xb6\xe2\x82\xac'),  # cp1252
    (b'\xc3\xb6\xe2\x82\xac', b'\xc3\xb6\xe2\x82\xac'),  # utf-8
    (b'\xc3\xb6\xe2', b'\xc3\x83\xc2\xb6\xc3\xa2'),  # Garbage
])
def test_egg_info_data(file_contents, expected):
    om = mock_open(read_data=file_contents)
    em = Mock()
    em.return_value = 'cp1252'
    with patch('pip.util.open', om, create=True):
        with patch('locale.getpreferredencoding', em):
            ret = read_text_file('foo')
    assert ret == expected.decode('utf-8')


class TestInstallRequirement(object):

    def test_url_with_query(self):
        """InstallRequirement should strip the fragment, but not the query."""
        url = 'http://foo.com/?p=bar.git;a=snapshot;h=v0.1;sf=tgz'
        fragment = '#egg=bar'
        req = InstallRequirement.from_line(url + fragment)
        assert req.url == url, req.url

    def test_unsupported_wheel_requirement_raises(self):
        with pytest.raises(UnsupportedWheel):
            InstallRequirement.from_line(
                'peppercorn-0.4-py2.py3-bogus-any.whl',
            )

    def test_invalid_wheel_requirement_raises(self):
        with pytest.raises(InvalidWheelFilename):
            InstallRequirement.from_line('invalid.whl')

    def test_wheel_requirement_sets_req_attribute(self):
        req = InstallRequirement.from_line('simple-0.1-py2.py3-none-any.whl')
        assert req.req == pkg_resources.Requirement.parse('simple==0.1')


def test_requirements_data_structure_keeps_order():
    requirements = Requirements()
    requirements['pip'] = 'pip'
    requirements['nose'] = 'nose'
    requirements['coverage'] = 'coverage'

    assert ['pip', 'nose', 'coverage'] == list(requirements.values())
    assert ['pip', 'nose', 'coverage'] == list(requirements.keys())


def test_requirements_data_structure_implements__repr__():
    requirements = Requirements()
    requirements['pip'] = 'pip'
    requirements['nose'] = 'nose'

    assert "Requirements({'pip': 'pip', 'nose': 'nose'})" == repr(requirements)


def test_requirements_data_structure_implements__contains__():
    requirements = Requirements()
    requirements['pip'] = 'pip'

    assert 'pip' in requirements
    assert 'nose' not in requirements


@patch('os.path.normcase')
@patch('pip.req.req_install.os.getcwd')
@patch('pip.req.req_install.os.path.exists')
@patch('pip.req.req_install.os.path.isdir')
def test_parse_editable_local(
        isdir_mock, exists_mock, getcwd_mock, normcase_mock):
    exists_mock.return_value = isdir_mock.return_value = True
    # mocks needed to support path operations on windows tests
    normcase_mock.return_value = getcwd_mock.return_value = "/some/path"
    assert parse_editable('.', 'git') == (None, 'file:///some/path', None)
    normcase_mock.return_value = "/some/path/foo"
    assert parse_editable('foo', 'git') == (
        None, 'file:///some/path/foo', None,
    )


def test_parse_editable_default_vcs():
    assert parse_editable('https://foo#egg=foo', 'git') == (
        'foo',
        'git+https://foo#egg=foo',
        {'egg': 'foo'},
    )


def test_parse_editable_explicit_vcs():
    assert parse_editable('svn+https://foo#egg=foo', 'git') == (
        'foo',
        'svn+https://foo#egg=foo',
        {'egg': 'foo'},
    )


def test_parse_editable_vcs_extras():
    assert parse_editable('svn+https://foo#egg=foo[extras]', 'git') == (
        'foo[extras]',
        'svn+https://foo#egg=foo[extras]',
        {'egg': 'foo[extras]'},
    )


@patch('os.path.normcase')
@patch('pip.req.req_install.os.getcwd')
@patch('pip.req.req_install.os.path.exists')
@patch('pip.req.req_install.os.path.isdir')
def test_parse_editable_local_extras(
        isdir_mock, exists_mock, getcwd_mock, normcase_mock):
    exists_mock.return_value = isdir_mock.return_value = True
    normcase_mock.return_value = getcwd_mock.return_value = "/some/path"
    assert parse_editable('.[extras]', 'git') == (
        None, 'file://' + "/some/path", ('extras',),
    )
    normcase_mock.return_value = "/some/path/foo"
    assert parse_editable('foo[bar,baz]', 'git') == (
        None, 'file:///some/path/foo', ('bar', 'baz'),
    )


def test_remote_reqs_parse():
    """
    Test parsing a simple remote requirements file
    """
    # this requirements file just contains a comment
    # previously this has failed in py3: https://github.com/pypa/pip/issues/760
    for req in parse_requirements(
            'https://raw.githubusercontent.com/pypa/pip-test-package/master/'
            'tests/req_just_comment.txt', session=PipSession()):
        pass


def test_req_file_parse_use_wheel(data):
    """
    Test parsing --use-wheel from a req file
    """
    finder = PackageFinder([], [], session=PipSession())
    for req in parse_requirements(
            data.reqfiles.join("supported_options.txt"), finder,
            session=PipSession()):
        pass
    assert finder.use_wheel


def test_req_file_parse_comment_start_of_line(tmpdir):
    """
    Test parsing comments in a requirements file
    """
    with open(tmpdir.join("req1.txt"), "w") as fp:
        fp.write("# Comment ")

    finder = PackageFinder([], [], session=PipSession())
    reqs = list(parse_requirements(tmpdir.join("req1.txt"), finder,
                session=PipSession()))

    assert not reqs


def test_req_file_parse_comment_end_of_line_with_url(tmpdir):
    """
    Test parsing comments in a requirements file
    """
    with open(tmpdir.join("req1.txt"), "w") as fp:
        fp.write("https://example.com/foo.tar.gz # Comment ")

    finder = PackageFinder([], [], session=PipSession())
    reqs = list(parse_requirements(tmpdir.join("req1.txt"), finder,
                session=PipSession()))

    assert len(reqs) == 1
    assert reqs[0].url == "https://example.com/foo.tar.gz"


def test_req_file_parse_egginfo_end_of_line_with_url(tmpdir):
    """
    Test parsing comments in a requirements file
    """
    with open(tmpdir.join("req1.txt"), "w") as fp:
        fp.write("https://example.com/foo.tar.gz#egg=wat")

    finder = PackageFinder([], [], session=PipSession())
    reqs = list(parse_requirements(tmpdir.join("req1.txt"), finder,
                session=PipSession()))

    assert len(reqs) == 1
    assert reqs[0].name == "wat"

########NEW FILE########
__FILENAME__ = test_util
"""
util tests

"""
import os
import stat
import sys
import shutil
import tempfile

import pytest

from mock import Mock, patch
from pip.exceptions import BadCommand
from pip.util import (egg_link_path, Inf, get_installed_distributions,
                      find_command, untar_file, unzip_file)
from pip.commands.freeze import freeze_excludes


class Tests_EgglinkPath:
    "util.egg_link_path() tests"

    def setup(self):

        project = 'foo'

        self.mock_dist = Mock(project_name=project)
        self.site_packages = 'SITE_PACKAGES'
        self.user_site = 'USER_SITE'
        self.user_site_egglink = os.path.join(
            self.user_site,
            '%s.egg-link' % project
        )
        self.site_packages_egglink = os.path.join(
            self.site_packages,
            '%s.egg-link' % project,
        )

        # patches
        from pip import util
        self.old_site_packages = util.site_packages
        self.mock_site_packages = util.site_packages = 'SITE_PACKAGES'
        self.old_running_under_virtualenv = util.running_under_virtualenv
        self.mock_running_under_virtualenv = util.running_under_virtualenv = \
            Mock()
        self.old_virtualenv_no_global = util.virtualenv_no_global
        self.mock_virtualenv_no_global = util.virtualenv_no_global = Mock()
        self.old_user_site = util.user_site
        self.mock_user_site = util.user_site = self.user_site
        from os import path
        self.old_isfile = path.isfile
        self.mock_isfile = path.isfile = Mock()

    def teardown(self):
        from pip import util
        util.site_packages = self.old_site_packages
        util.running_under_virtualenv = self.old_running_under_virtualenv
        util.virtualenv_no_global = self.old_virtualenv_no_global
        util.user_site = self.old_user_site
        from os import path
        path.isfile = self.old_isfile

    def eggLinkInUserSite(self, egglink):
        return egglink == self.user_site_egglink

    def eggLinkInSitePackages(self, egglink):
        return egglink == self.site_packages_egglink

    # ####################### #
    # # egglink in usersite # #
    # ####################### #
    def test_egglink_in_usersite_notvenv(self):
        self.mock_virtualenv_no_global.return_value = False
        self.mock_running_under_virtualenv.return_value = False
        self.mock_isfile.side_effect = self.eggLinkInUserSite
        assert egg_link_path(self.mock_dist) == self.user_site_egglink

    def test_egglink_in_usersite_venv_noglobal(self):
        self.mock_virtualenv_no_global.return_value = True
        self.mock_running_under_virtualenv.return_value = True
        self.mock_isfile.side_effect = self.eggLinkInUserSite
        assert egg_link_path(self.mock_dist) is None

    def test_egglink_in_usersite_venv_global(self):
        self.mock_virtualenv_no_global.return_value = False
        self.mock_running_under_virtualenv.return_value = True
        self.mock_isfile.side_effect = self.eggLinkInUserSite
        assert egg_link_path(self.mock_dist) == self.user_site_egglink

    # ####################### #
    # # egglink in sitepkgs # #
    # ####################### #
    def test_egglink_in_sitepkgs_notvenv(self):
        self.mock_virtualenv_no_global.return_value = False
        self.mock_running_under_virtualenv.return_value = False
        self.mock_isfile.side_effect = self.eggLinkInSitePackages
        assert egg_link_path(self.mock_dist) == self.site_packages_egglink

    def test_egglink_in_sitepkgs_venv_noglobal(self):
        self.mock_virtualenv_no_global.return_value = True
        self.mock_running_under_virtualenv.return_value = True
        self.mock_isfile.side_effect = self.eggLinkInSitePackages
        assert egg_link_path(self.mock_dist) == self.site_packages_egglink

    def test_egglink_in_sitepkgs_venv_global(self):
        self.mock_virtualenv_no_global.return_value = False
        self.mock_running_under_virtualenv.return_value = True
        self.mock_isfile.side_effect = self.eggLinkInSitePackages
        assert egg_link_path(self.mock_dist) == self.site_packages_egglink

    # ################################## #
    # # egglink in usersite & sitepkgs # #
    # ################################## #
    def test_egglink_in_both_notvenv(self):
        self.mock_virtualenv_no_global.return_value = False
        self.mock_running_under_virtualenv.return_value = False
        self.mock_isfile.return_value = True
        assert egg_link_path(self.mock_dist) == self.user_site_egglink

    def test_egglink_in_both_venv_noglobal(self):
        self.mock_virtualenv_no_global.return_value = True
        self.mock_running_under_virtualenv.return_value = True
        self.mock_isfile.return_value = True
        assert egg_link_path(self.mock_dist) == self.site_packages_egglink

    def test_egglink_in_both_venv_global(self):
        self.mock_virtualenv_no_global.return_value = False
        self.mock_running_under_virtualenv.return_value = True
        self.mock_isfile.return_value = True
        assert egg_link_path(self.mock_dist) == self.site_packages_egglink

    # ############## #
    # # no egglink # #
    # ############## #
    def test_noegglink_in_sitepkgs_notvenv(self):
        self.mock_virtualenv_no_global.return_value = False
        self.mock_running_under_virtualenv.return_value = False
        self.mock_isfile.return_value = False
        assert egg_link_path(self.mock_dist) is None

    def test_noegglink_in_sitepkgs_venv_noglobal(self):
        self.mock_virtualenv_no_global.return_value = True
        self.mock_running_under_virtualenv.return_value = True
        self.mock_isfile.return_value = False
        assert egg_link_path(self.mock_dist) is None

    def test_noegglink_in_sitepkgs_venv_global(self):
        self.mock_virtualenv_no_global.return_value = False
        self.mock_running_under_virtualenv.return_value = True
        self.mock_isfile.return_value = False
        assert egg_link_path(self.mock_dist) is None


def test_Inf_greater():
    """Test Inf compares greater."""
    assert Inf > object()


def test_Inf_equals_Inf():
    """Test Inf compares greater."""
    assert Inf == Inf


@patch('pip.util.dist_is_local')
@patch('pip.util.dist_is_editable')
class Tests_get_installed_distributions:
    """test util.get_installed_distributions"""

    workingset = [
        Mock(test_name="global"),
        Mock(test_name="editable"),
        Mock(test_name="normal"),
    ]

    workingset_stdlib = [
        Mock(test_name='normal', key='argparse'),
        Mock(test_name='normal', key='wsgiref')
    ]

    workingset_freeze = [
        Mock(test_name='normal', key='pip'),
        Mock(test_name='normal', key='setuptools'),
        Mock(test_name='normal', key='distribute')
    ]

    def dist_is_editable(self, dist):
        return dist.test_name == "editable"

    def dist_is_local(self, dist):
        return dist.test_name != "global"

    @patch('pip._vendor.pkg_resources.working_set', workingset)
    def test_editables_only(self, mock_dist_is_editable, mock_dist_is_local):
        mock_dist_is_editable.side_effect = self.dist_is_editable
        mock_dist_is_local.side_effect = self.dist_is_local
        dists = get_installed_distributions(editables_only=True)
        assert len(dists) == 1, dists
        assert dists[0].test_name == "editable"

    @patch('pip._vendor.pkg_resources.working_set', workingset)
    def test_exclude_editables(
            self, mock_dist_is_editable, mock_dist_is_local):
        mock_dist_is_editable.side_effect = self.dist_is_editable
        mock_dist_is_local.side_effect = self.dist_is_local
        dists = get_installed_distributions(include_editables=False)
        assert len(dists) == 1
        assert dists[0].test_name == "normal"

    @patch('pip._vendor.pkg_resources.working_set', workingset)
    def test_include_globals(self, mock_dist_is_editable, mock_dist_is_local):
        mock_dist_is_editable.side_effect = self.dist_is_editable
        mock_dist_is_local.side_effect = self.dist_is_local
        dists = get_installed_distributions(local_only=False)
        assert len(dists) == 3

    @pytest.mark.skipif("sys.version_info >= (2,7)")
    @patch('pip._vendor.pkg_resources.working_set', workingset_stdlib)
    def test_py26_excludes(self, mock_dist_is_editable, mock_dist_is_local):
        mock_dist_is_editable.side_effect = self.dist_is_editable
        mock_dist_is_local.side_effect = self.dist_is_local
        dists = get_installed_distributions()
        assert len(dists) == 1
        assert dists[0].key == 'argparse'

    @pytest.mark.skipif("sys.version_info < (2,7)")
    @patch('pip._vendor.pkg_resources.working_set', workingset_stdlib)
    def test_gte_py27_excludes(self, mock_dist_is_editable,
                               mock_dist_is_local):
        mock_dist_is_editable.side_effect = self.dist_is_editable
        mock_dist_is_local.side_effect = self.dist_is_local
        dists = get_installed_distributions()
        assert len(dists) == 0

    @patch('pip._vendor.pkg_resources.working_set', workingset_freeze)
    def test_freeze_excludes(self, mock_dist_is_editable, mock_dist_is_local):
        mock_dist_is_editable.side_effect = self.dist_is_editable
        mock_dist_is_local.side_effect = self.dist_is_local
        dists = get_installed_distributions(skip=freeze_excludes)
        assert len(dists) == 0


def test_find_command_folder_in_path(script):
    """
    If a folder named e.g. 'git' is in PATH, and find_command is looking for
    the 'git' executable, it should not match the folder, but rather keep
    looking.
    """
    script.scratch_path.join("path_one").mkdir()
    path_one = script.scratch_path / 'path_one'
    path_one.join("foo").mkdir()
    script.scratch_path.join("path_two").mkdir()
    path_two = script.scratch_path / 'path_two'
    path_two.join("foo").write("# nothing")
    found_path = find_command('foo', map(str, [path_one, path_two]))
    assert found_path == path_two / 'foo'


def test_does_not_find_command_because_there_is_no_path():
    """
    Test calling `pip.utils.find_command` when there is no PATH env variable
    """
    environ_before = os.environ
    os.environ = {}
    try:
        try:
            find_command('anycommand')
        except BadCommand:
            e = sys.exc_info()[1]
            assert e.args == ("Cannot find command 'anycommand'",)
        else:
            raise AssertionError("`find_command` should raise `BadCommand`")
    finally:
        os.environ = environ_before


@patch('os.pathsep', ':')
@patch('pip.util.get_pathext')
@patch('os.path.isfile')
def test_find_command_trys_all_pathext(mock_isfile, getpath_mock):
    """
    If no pathext should check default list of extensions, if file does not
    exist.
    """
    mock_isfile.return_value = False

    getpath_mock.return_value = os.pathsep.join([".COM", ".EXE"])

    paths = [
        os.path.join('path_one', f) for f in ['foo.com', 'foo.exe', 'foo']
    ]
    expected = [((p,),) for p in paths]

    with pytest.raises(BadCommand):
        find_command("foo", "path_one")

    assert (
        mock_isfile.call_args_list == expected, "Actual: %s\nExpected %s" %
        (mock_isfile.call_args_list, expected)
    )
    assert getpath_mock.called, "Should call get_pathext"


@patch('os.pathsep', ':')
@patch('pip.util.get_pathext')
@patch('os.path.isfile')
def test_find_command_trys_supplied_pathext(mock_isfile, getpath_mock):
    """
    If pathext supplied find_command should use all of its list of extensions
    to find file.
    """
    mock_isfile.return_value = False
    getpath_mock.return_value = ".FOO"

    pathext = os.pathsep.join([".RUN", ".CMD"])

    paths = [
        os.path.join('path_one', f) for f in ['foo.run', 'foo.cmd', 'foo']
    ]
    expected = [((p,),) for p in paths]

    with pytest.raises(BadCommand):
        find_command("foo", "path_one", pathext)

    assert (
        mock_isfile.call_args_list == expected, "Actual: %s\nExpected %s" %
        (mock_isfile.call_args_list, expected)
    )
    assert not getpath_mock.called, "Should not call get_pathext"


class TestUnpackArchives(object):
    """
    test_tar.tgz/test_tar.zip have content as follows engineered to confirm 3
    things:
     1) confirm that reg files, dirs, and symlinks get unpacked
     2) permissions are not preserved (and go by the 022 umask)
     3) reg files with *any* execute perms, get chmod +x

       file.txt         600 regular file
       symlink.txt      777 symlink to file.txt
       script_owner.sh  700 script where owner can execute
       script_group.sh  610 script where group can execute
       script_world.sh  601 script where world can execute
       dir              744 directory
       dir/dirfile      622 regular file

    """

    def setup(self):
        self.tempdir = tempfile.mkdtemp()
        self.old_mask = os.umask(0o022)
        self.symlink_expected_mode = None

    def teardown(self):
        os.umask(self.old_mask)
        shutil.rmtree(self.tempdir, ignore_errors=True)

    def mode(self, path):
        return stat.S_IMODE(os.stat(path).st_mode)

    def confirm_files(self):
        # expections based on 022 umask set above and the unpack logic that
        # sets execute permissions, not preservation
        for fname, expected_mode, test in [
                ('file.txt', 0o644, os.path.isfile),
                ('symlink.txt', 0o644, os.path.isfile),
                ('script_owner.sh', 0o755, os.path.isfile),
                ('script_group.sh', 0o755, os.path.isfile),
                ('script_world.sh', 0o755, os.path.isfile),
                ('dir', 0o755, os.path.isdir),
                (os.path.join('dir', 'dirfile'), 0o644, os.path.isfile)]:
            path = os.path.join(self.tempdir, fname)
            if path.endswith('symlink.txt') and sys.platform == 'win32':
                # no symlinks created on windows
                continue
            assert test(path), path
            if sys.platform == 'win32':
                # the permissions tests below don't apply in windows
                # due to os.chmod being a noop
                continue
            mode = self.mode(path)
            assert mode == expected_mode, (
                "mode: %s, expected mode: %s" % (mode, expected_mode)
            )

    def test_unpack_tgz(self, data):
        """
        Test unpacking a *.tgz, and setting execute permissions
        """
        test_file = data.packages.join("test_tar.tgz")
        untar_file(test_file, self.tempdir)
        self.confirm_files()

    def test_unpack_zip(self, data):
        """
        Test unpacking a *.zip, and setting execute permissions
        """
        test_file = data.packages.join("test_zip.zip")
        unzip_file(test_file, self.tempdir)
        self.confirm_files()

########NEW FILE########
__FILENAME__ = test_vcs
from tests.lib import pyversion
from pip.vcs.bazaar import Bazaar

if pyversion >= '3':
    VERBOSE_FALSE = False
else:
    VERBOSE_FALSE = 0


def test_bazaar_simple_urls():
    """
    Test bzr url support.

    SSH and launchpad have special handling.
    """
    http_bzr_repo = Bazaar(
        url='bzr+http://bzr.myproject.org/MyProject/trunk/#egg=MyProject'
    )
    https_bzr_repo = Bazaar(
        url='bzr+https://bzr.myproject.org/MyProject/trunk/#egg=MyProject'
    )
    ssh_bzr_repo = Bazaar(
        url='bzr+ssh://bzr.myproject.org/MyProject/trunk/#egg=MyProject'
    )
    ftp_bzr_repo = Bazaar(
        url='bzr+ftp://bzr.myproject.org/MyProject/trunk/#egg=MyProject'
    )
    sftp_bzr_repo = Bazaar(
        url='bzr+sftp://bzr.myproject.org/MyProject/trunk/#egg=MyProject'
    )
    launchpad_bzr_repo = Bazaar(
        url='bzr+lp:MyLaunchpadProject#egg=MyLaunchpadProject'
    )

    assert http_bzr_repo.get_url_rev() == (
        'http://bzr.myproject.org/MyProject/trunk/', None,
    )
    assert https_bzr_repo.get_url_rev() == (
        'https://bzr.myproject.org/MyProject/trunk/', None,
    )
    assert ssh_bzr_repo.get_url_rev() == (
        'bzr+ssh://bzr.myproject.org/MyProject/trunk/', None,
    )
    assert ftp_bzr_repo.get_url_rev() == (
        'ftp://bzr.myproject.org/MyProject/trunk/', None,
    )
    assert sftp_bzr_repo.get_url_rev() == (
        'sftp://bzr.myproject.org/MyProject/trunk/', None,
    )
    assert launchpad_bzr_repo.get_url_rev() == (
        'lp:MyLaunchpadProject', None,
    )

########NEW FILE########
__FILENAME__ = test_wheel
"""Tests for wheel binary packages and .dist-info."""
import os

import pytest
from mock import patch, Mock

from pip._vendor import pkg_resources
from pip import wheel
from pip.exceptions import InvalidWheelFilename, UnsupportedWheel
from pip.util import unpack_file


def test_get_entrypoints(tmpdir):
    with open(str(tmpdir.join("entry_points.txt")), "w") as fp:
        fp.write("""
            [console_scripts]
            pip = pip.main:pip
        """)

    assert wheel.get_entrypoints(str(tmpdir.join("entry_points.txt"))) == (
        {"pip": "pip.main:pip"},
        {},
    )


def test_uninstallation_paths():
    class dist(object):
        def get_metadata_lines(self, record):
            return ['file.py,,',
                    'file.pyc,,',
                    'file.so,,',
                    'nopyc.py']
        location = ''

    d = dist()

    paths = list(wheel.uninstallation_paths(d))

    expected = ['file.py',
                'file.pyc',
                'file.so',
                'nopyc.py',
                'nopyc.pyc']

    assert paths == expected

    # Avoid an easy 'unique generator' bug
    paths2 = list(wheel.uninstallation_paths(d))

    assert paths2 == paths


def test_wheel_version(tmpdir, data):
    future_wheel = 'futurewheel-1.9-py2.py3-none-any.whl'
    broken_wheel = 'brokenwheel-1.0-py2.py3-none-any.whl'
    future_version = (1, 9)

    unpack_file(data.packages.join(future_wheel),
                tmpdir + 'future', None, None)
    unpack_file(data.packages.join(broken_wheel),
                tmpdir + 'broken', None, None)

    assert wheel.wheel_version(tmpdir + 'future') == future_version
    assert not wheel.wheel_version(tmpdir + 'broken')


def test_check_compatibility():
    name = 'test'
    vc = wheel.VERSION_COMPATIBLE

    # Major version is higher - should be incompatible
    higher_v = (vc[0] + 1, vc[1])

    # test raises with correct error
    with pytest.raises(UnsupportedWheel) as e:
        wheel.check_compatibility(higher_v, name)
    assert 'is not compatible' in str(e)

    # Should only log.warn - minor version is greator
    higher_v = (vc[0], vc[1] + 1)
    wheel.check_compatibility(higher_v, name)

    # These should work fine
    wheel.check_compatibility(wheel.VERSION_COMPATIBLE, name)

    # E.g if wheel to install is 1.0 and we support up to 1.2
    lower_v = (vc[0], max(0, vc[1] - 1))
    wheel.check_compatibility(lower_v, name)


class TestWheelFile(object):

    def test_std_wheel_pattern(self):
        w = wheel.Wheel('simple-1.1.1-py2-none-any.whl')
        assert w.name == 'simple'
        assert w.version == '1.1.1'
        assert w.pyversions == ['py2']
        assert w.abis == ['none']
        assert w.plats == ['any']

    def test_wheel_pattern_multi_values(self):
        w = wheel.Wheel('simple-1.1-py2.py3-abi1.abi2-any.whl')
        assert w.name == 'simple'
        assert w.version == '1.1'
        assert w.pyversions == ['py2', 'py3']
        assert w.abis == ['abi1', 'abi2']
        assert w.plats == ['any']

    def test_wheel_with_build_tag(self):
        # pip doesn't do anything with build tags, but theoretically, we might
        # see one, in this case the build tag = '4'
        w = wheel.Wheel('simple-1.1-4-py2-none-any.whl')
        assert w.name == 'simple'
        assert w.version == '1.1'
        assert w.pyversions == ['py2']
        assert w.abis == ['none']
        assert w.plats == ['any']

    def test_single_digit_version(self):
        w = wheel.Wheel('simple-1-py2-none-any.whl')
        assert w.version == '1'

    def test_missing_version_raises(self):
        with pytest.raises(InvalidWheelFilename):
            wheel.Wheel('Cython-cp27-none-linux_x86_64.whl')

    def test_invalid_filename_raises(self):
        with pytest.raises(InvalidWheelFilename):
            wheel.Wheel('invalid.whl')

    def test_supported_single_version(self):
        """
        Test single-version wheel is known to be supported
        """
        w = wheel.Wheel('simple-0.1-py2-none-any.whl')
        assert w.supported(tags=[('py2', 'none', 'any')])

    def test_supported_multi_version(self):
        """
        Test multi-version wheel is known to be supported
        """
        w = wheel.Wheel('simple-0.1-py2.py3-none-any.whl')
        assert w.supported(tags=[('py3', 'none', 'any')])

    def test_not_supported_version(self):
        """
        Test unsupported wheel is known to be unsupported
        """
        w = wheel.Wheel('simple-0.1-py2-none-any.whl')
        assert not w.supported(tags=[('py1', 'none', 'any')])

    def test_support_index_min(self):
        """
        Test results from `support_index_min`
        """
        tags = [
            ('py2', 'none', 'TEST'),
            ('py2', 'TEST', 'any'),
            ('py2', 'none', 'any'),
        ]
        w = wheel.Wheel('simple-0.1-py2-none-any.whl')
        assert w.support_index_min(tags=tags) == 2
        w = wheel.Wheel('simple-0.1-py2-none-TEST.whl')
        assert w.support_index_min(tags=tags) == 0

    def test_support_index_min_none(self):
        """
        Test `support_index_min` returns None, when wheel not supported
        """
        w = wheel.Wheel('simple-0.1-py2-none-any.whl')
        assert w.support_index_min(tags=[]) is None

    def test_unpack_wheel_no_flatten(self):
        from pip import util
        from tempfile import mkdtemp
        from shutil import rmtree

        filepath = '../data/packages/meta-1.0-py2.py3-none-any.whl'
        if not os.path.exists(filepath):
            pytest.skip("%s does not exist" % filepath)
        try:
            tmpdir = mkdtemp()
            util.unpack_file(filepath, tmpdir, 'application/zip', None)
            assert os.path.isdir(os.path.join(tmpdir, 'meta-1.0.dist-info'))
        finally:
            rmtree(tmpdir)
            pass

    def test_purelib_platlib(self, data):
        """
        Test the "wheel is purelib/platlib" code.
        """
        packages = [
            ("pure_wheel", data.packages.join("pure_wheel-1.7"), True),
            ("plat_wheel", data.packages.join("plat_wheel-1.7"), False),
        ]

        for name, path, expected in packages:
            assert wheel.root_is_purelib(name, path) == expected

    def test_version_underscore_conversion(self):
        """
        Test that we convert '_' to '-' for versions parsed out of wheel
        filenames
        """
        w = wheel.Wheel('simple-0.1_1-py2-none-any.whl')
        assert w.version == '0.1-1'


class TestPEP425Tags(object):

    def test_broken_sysconfig(self):
        """
        Test that pep425tags still works when sysconfig is broken.
        Can be a problem on Python 2.7
        Issue #1074.
        """
        import pip.pep425tags

        def raises_ioerror(var):
            raise IOError("I have the wrong path!")

        with patch('pip.pep425tags.sysconfig.get_config_var', raises_ioerror):
            assert len(pip.pep425tags.get_supported())


class TestMoveWheelFiles(object):
    """
    Tests for moving files from wheel src to scheme paths
    """

    def prep(self, data, tmpdir):
        self.name = 'sample'
        self.wheelpath = data.packages.join(
            'sample-1.2.0-py2.py3-none-any.whl')
        self.req = pkg_resources.Requirement.parse('sample')
        self.src = os.path.join(tmpdir, 'src')
        self.dest = os.path.join(tmpdir, 'dest')
        unpack_file(self.wheelpath, self.src, None, None)
        self.scheme = {
            'scripts': os.path.join(self.dest, 'bin'),
            'purelib': os.path.join(self.dest, 'lib'),
            'data': os.path.join(self.dest, 'data'),
        }
        self.src_dist_info = os.path.join(
            self.src, 'sample-1.2.0.dist-info')
        self.dest_dist_info = os.path.join(
            self.scheme['purelib'], 'sample-1.2.0.dist-info')

    def assert_installed(self):
        # lib
        assert os.path.isdir(
            os.path.join(self.scheme['purelib'], 'sample'))
        # dist-info
        metadata = os.path.join(self.dest_dist_info, 'METADATA')
        assert os.path.isfile(metadata)
        # data files
        data_file = os.path.join(self.scheme['data'], 'my_data', 'data_file')
        assert os.path.isfile(data_file)
        # package data
        pkg_data = os.path.join(
            self.scheme['purelib'], 'sample', 'package_data.dat')
        assert os.path.isfile(pkg_data)

    def test_std_install(self, data, tmpdir):
        self.prep(data, tmpdir)
        wheel.move_wheel_files(
            self.name, self.req, self.src, scheme=self.scheme)
        self.assert_installed()

    def test_dist_info_contains_empty_dir(self, data, tmpdir):
        """
        Test that empty dirs are not installed
        """
        # e.g. https://github.com/pypa/pip/issues/1632#issuecomment-38027275
        self.prep(data, tmpdir)
        src_empty_dir = os.path.join(
            self.src_dist_info, 'empty_dir', 'empty_dir')
        os.makedirs(src_empty_dir)
        assert os.path.isdir(src_empty_dir)
        wheel.move_wheel_files(
            self.name, self.req, self.src, scheme=self.scheme)
        self.assert_installed()
        assert not os.path.isdir(
            os.path.join(self.dest_dist_info, 'empty_dir'))


class TestWheelBuilder(object):

    @patch('pip.log.Logger.log')
    @patch('pip.wheel.WheelBuilder._build_one')
    def test_skip_building_wheels(self, mock_build_one, mock_log):
        wheel_req = Mock(is_wheel=True, editable=False)
        reqset = Mock(requirements=Mock(values=lambda: [wheel_req]))
        wb = wheel.WheelBuilder(reqset, Mock(), '/wheel/dir')
        wb.build()
        name, args, kwargs = mock_log.mock_calls[0]
        assert "due to already being wheel" in args[1]
        assert mock_build_one.mock_calls == []

    @patch('pip.log.Logger.log')
    @patch('pip.wheel.WheelBuilder._build_one')
    def test_skip_building_editables(self, mock_build_one, mock_log):
        editable_req = Mock(editable=True, is_wheel=False)
        reqset = Mock(requirements=Mock(values=lambda: [editable_req]))
        wb = wheel.WheelBuilder(reqset, Mock(), '/wheel/dir')
        wb.build()
        name, args, kwargs = mock_log.mock_calls[0]
        assert "due to being editable" in args[1]
        assert mock_build_one.mock_calls == []

########NEW FILE########
