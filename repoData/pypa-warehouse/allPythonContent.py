__FILENAME__ = conf
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# This file is execfile()d with the current directory set to its containing
# dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.

warehouse = {}
filename = os.path.join(
    os.path.dirname(__file__),
    os.pardir,
    "warehouse",
    "__about__.py",
)
with open(os.path.abspath(filename)) as fp:
    exec(fp.read(), warehouse)

# -- General configuration ----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
# needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    "sphinx.ext.autodoc",
    "sphinx.ext.doctest",
    "sphinx.ext.intersphinx",
    "sphinx.ext.coverage",
    "sphinx.ext.viewcode",
    "sphinxcontrib.httpdomain",
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ["_templates"]

# The suffix of source filenames.
source_suffix = ".rst"

# The master toctree document.
master_doc = "index"

# General information about the project.
project = "Warehouse"
copyright = "2013, Donald Stufft"

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = ".".join(warehouse["__version__"].split(".")[:2])
# The full version, including alpha/beta/rc tags.
release = warehouse["__version__"]

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ["_build"]

# If true, '()' will be appended to :func: etc. cross-reference text.
add_function_parentheses = True

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = "sphinx"

# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {
    "http://docs.python.org/": None,
}

# -- Options for HTML output --------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = "default"

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ["_static"]

# Output file base name for HTML help builder.
htmlhelp_basename = "Warehousedoc"

########NEW FILE########
__FILENAME__ = test_db
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from unittest import mock
import datetime
import pytest

import pretend

from warehouse.accounts.tables import users, emails


def test_get_user(dbapp):
    dbapp.engine.execute(users.insert().values(
        password="!",
        username="test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))

    assert {
        "id": mock.ANY,
        "date_joined": mock.ANY,
        "email": None,
        "name": "Test User",
        "username": "test-user",
    } == dbapp.db.accounts.get_user("test-user")


def test_get_user_with_email(dbapp):
    dbapp.engine.execute(users.insert().values(
        id=1,
        password="!",
        username="test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))
    dbapp.engine.execute(emails.insert().values(
        user_id=1,
        email="test-user@example.com",
        primary=True,
        verified=True,
    ))

    assert {
        "id": 1,
        "date_joined": mock.ANY,
        "email": "test-user@example.com",
        "name": "Test User",
        "username": "test-user",
    } == dbapp.db.accounts.get_user("test-user")


def test_get_user_missing(dbapp):
    assert dbapp.db.accounts.get_user("test-user") is None


def test_user_authenticate(dbapp):
    dbapp.engine.execute(users.insert().values(
        id=1,
        password="hash!",
        username="test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))
    dbapp.passlib.verify_and_update = pretend.call_recorder(
        lambda p, h: (True, None)
    )

    assert dbapp.db.accounts.user_authenticate("test-user", "password")
    assert dbapp.passlib.verify_and_update.calls == [
        pretend.call("password", "hash!"),
    ]


def test_user_authenticate_update(dbapp):
    dbapp.engine.execute(users.insert().values(
        id=1,
        password="hash!",
        username="test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))
    dbapp.passlib.verify_and_update = pretend.call_recorder(
        lambda p, h: (True, "new hash!")
    )

    assert dbapp.db.accounts.user_authenticate("test-user", "password")
    assert dbapp.passlib.verify_and_update.calls == [
        pretend.call("password", "hash!"),
    ]

    r = dbapp.engine.execute("SELECT password FROM accounts_user WHERE id = 1")

    assert list(r) == [("new hash!",)]


def test_user_authenticate_no_user(dbapp):
    assert not dbapp.db.accounts.user_authenticate("test-user", "password")


def test_user_authenticate_exception(engine, dbapp):
    engine.execute(users.insert().values(
        id=1,
        password="hash!",
        username="test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))

    def verify_and_update(password, password_hash):
        raise ValueError("Invalid something or other")
    dbapp.passlib.verify_and_update = verify_and_update

    assert not dbapp.db.accounts.user_authenticate("test-user", "password")


def test_user_authenticate_invalid(engine, dbapp):
    engine.execute(users.insert().values(
        id=1,
        password="hash!",
        username="test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))

    dbapp.passlib.verify_and_update = lambda p, h: (False, None)

    assert not dbapp.db.accounts.user_authenticate("test-user", "password")


def test_insert_and_delete_user(dbapp):
    username = "guidovanrossum"
    email = "notanemail@python.org"
    password = "plaintextpasswordsaregreat"
    dbapp.db.accounts.insert_user(
        username,
        email,
        password
    )
    assert dbapp.db.accounts.user_authenticate(username,
                                               password)
    assert dbapp.db.accounts.get_user(username)
    assert dbapp.db.accounts.get_user_id_by_email(email)
    dbapp.db.accounts.delete_user(username)
    assert not dbapp.db.accounts.get_user(username)


def test_insert_with_same_email(dbapp, user):
    new_username = 'rhodes'
    with pytest.raises(ValueError):
        dbapp.db.accounts.insert_user(
            new_username,
            user['email'],
            "dummy_password"
        )
    dbapp.db.accounts.delete_user(new_username)


def test_update_user_email(dbapp, user):
    email = "montypython@python.org"
    dbapp.db.accounts.update_user_email(user['id'], email)
    new_info = dbapp.db.accounts.get_user(user['username'])
    assert new_info['email'] == email


def test_update_password(dbapp, user):
    password = "thisisntmyrealpassword"
    dbapp.db.accounts.update_user_password(user['id'], password)
    assert dbapp.db.accounts.user_authenticate(user['username'], password)


def test_update_user(dbapp, user):
    new_password = "test"
    email = "new email"
    dbapp.db.accounts.update_user(user['id'],
                                  password=new_password,
                                  email=email)
    assert dbapp.db.accounts.user_authenticate(user['username'],
                                               new_password)
    new_info = dbapp.db.accounts.get_user(user['username'])
    assert new_info['email'] == email


def test_update_nothing(dbapp, user):
    dbapp.db.accounts.update_user(user['id'])
    info = dbapp.db.accounts.get_user(user['username'])
    assert info['email'] == user['email']
    assert dbapp.db.accounts.user_authenticate(user['username'],
                                               user['password'])

########NEW FILE########
__FILENAME__ = test_forms
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from werkzeug.datastructures import MultiDict

from warehouse.accounts.forms import LoginForm


def test_validate_username_valid():
    form = LoginForm(
        MultiDict({"username": "test-user", "password": "p@ssw0rd"}),
        authenticator=lambda username, password: True,
    )
    assert form.validate()


def test_validate_username_invalid():
    form = LoginForm(
        MultiDict({"username": "test-user", "password": "p@ssw0rd"}),
        authenticator=lambda username, password: False,
    )
    assert not form.validate()

########NEW FILE########
__FILENAME__ = test_views
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from unittest import mock

import pretend
import pytest

from werkzeug.datastructures import MultiDict
from werkzeug.exceptions import NotFound

from warehouse.accounts.views import user_profile, login, logout
from warehouse.sessions import Session


def test_user_profile_missing_user():
    app = pretend.stub(
        db=pretend.stub(
            accounts=pretend.stub(
                get_user=pretend.call_recorder(lambda user: None),
            ),
        ),
    )
    request = pretend.stub()

    username = "test-user"

    with pytest.raises(NotFound):
        user_profile(app, request, username=username)

    assert app.db.accounts.get_user.calls == [pretend.call("test-user")]


def test_user_profile_redirects():
    app = pretend.stub(
        config=pretend.stub(
            cache=pretend.stub(
                browser=False,
                varnish=False,
            ),
        ),
        db=pretend.stub(
            accounts=pretend.stub(
                get_user=pretend.call_recorder(
                    lambda user: {"username": "test-User"},
                ),
            ),
        ),
    )
    request = pretend.stub(
        url_adapter=pretend.stub(
            build=pretend.call_recorder(
                lambda *a, **kw: "/~test-User/",
            ),
        ),
    )

    username = "test-user"

    resp = user_profile(app, request, username=username)

    assert resp.status_code == 301
    assert resp.headers["Location"] == "/~test-User/"

    assert app.db.accounts.get_user.calls == [pretend.call("test-user")]

    assert request.url_adapter.build.calls == [
        pretend.call(
            "warehouse.accounts.views.user_profile",
            {"username": "test-User"},
            force_external=False,
        ),
    ]


def test_user_profile_renders(app):
    app.db = pretend.stub(
        accounts=pretend.stub(
            get_user=pretend.call_recorder(
                lambda user: {
                    "username": "test-user",
                    "email": "test@example.com",
                },
            ),
        ),
        packaging=pretend.stub(
            get_projects_for_user=pretend.call_recorder(lambda user: None),
        ),
    )

    request = pretend.stub()

    resp = user_profile(app, request, username="test-user")

    assert resp.status_code == 200
    assert resp.response.context == {
        "projects": None,
        "user": {
            "username": "test-user",
            "email": "test@example.com",
        },
    }

    assert app.db.accounts.get_user.calls == [pretend.call("test-user")]
    assert app.db.packaging.get_projects_for_user.calls == [
        pretend.call("test-user"),
    ]


def test_user_login_get(app):
    app.db = pretend.stub(
        accounts=pretend.stub(
            user_authenticate=pretend.stub(),
        ),
    )

    request = pretend.stub(
        method="GET",
        form=MultiDict(),
        values={},
        _session=Session({}, "1234", False),
    )

    resp = login(app, request)

    assert resp.status_code == 200
    assert resp.response.context == {
        "form": mock.ANY,
        "next": None,
    }


@pytest.mark.parametrize(("form", "values", "session", "location"), [
    ({"username": "test", "password": "p@ssw0rd"}, {}, {}, "/"),
    ({"username": "test", "password": "p@ssw0rd"}, {}, {"user.id": 100}, "/"),
    ({"username": "test", "password": "p@ssw0rd"}, {}, {"user.id": 9001}, "/"),
    (
        {"username": "test", "password": "p@ssw0rd"},
        {"next": "/wat/"},
        {},
        "/wat/",
    ),
    (
        {"username": "test", "password": "p@ssw0rd"},
        {"next": "/wat/"},
        {"user.id": 100},
        "/wat/",
    ),
    (
        {"username": "test", "password": "p@ssw0rd"},
        {"next": "/wat/"},
        {"user.id": 9001},
        "/wat/",
    ),
])
def test_user_login_post_valid(app, form, values, session, location):
    app.db = pretend.stub(
        accounts=pretend.stub(
            get_user_id=lambda username: 9001,
            user_authenticate=lambda user, password: True,
        ),
    )

    request = pretend.stub(
        method="POST",
        form=MultiDict(form),
        host="example.com",
        values=values,
        url_adapter=pretend.stub(
            build=lambda *a, **kw: "/",
        ),
        _session=Session(session, "1234", False),
    )

    resp = login(app, request)

    assert request.session["user.id"] == 9001
    assert resp.status_code == 303
    assert resp.headers["Location"] == location
    assert resp.headers.getlist("Set-Cookie") == ["username=test; Path=/"]


def test_user_logout_get(app):
    request = pretend.stub(
        method="GET",
        values={},
        _session=Session({"user.id": 1}, "1234", False),
    )

    resp = logout(app, request)

    assert resp.status_code == 200
    assert resp.response.template.name == "accounts/logout.html"
    assert resp.response.context == {"next": None}


@pytest.mark.parametrize(("values", "location"), [
    ({}, "/"),
    ({"next": "/wat/"}, "/wat/"),
])
def test_user_logout_post(values, location):
    app = pretend.stub(config=pretend.stub())
    request = pretend.stub(
        method="POST",
        host="example.com",
        values=values,
        url_adapter=pretend.stub(
            build=lambda *a, **kw: "/",
        ),
        _session=Session({"user.id": 1}, "1234", False),
    )

    resp = logout(app, request)

    assert resp.status_code == 303
    assert resp.headers["Location"] == location
    assert resp.headers.getlist("Set-Cookie") == [
        "username=; Expires=Thu, 01-Jan-1970 00:00:00 GMT; Max-Age=0; Path=/",
    ]
    assert request._session.deleted

########NEW FILE########
__FILENAME__ = conftest
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import subprocess
import os

from sqlalchemy.engine import create_engine
from sqlalchemy.pool import AssertionPool
import alembic.config
import alembic.command
import pretend
import pytest


def pytest_collection_modifyitems(items):
    for item in items:
        # Mark any item with one of the database fixture as using the db
        if set(getattr(item, "funcargnames", [])) & {"engine", "database"}:
            item.add_marker(pytest.mark.db)


@pytest.fixture(scope='session')
def database(request):
    """Creates the warehouse_unittest database, builds the schema and returns
    an SQLALchemy Connection to the database.
    """

    if os.getenv('WAREHOUSE_DATABASE_URL'):
        # Assume that the database was externally created
        url = os.getenv('WAREHOUSE_DATABASE_URL')
    else:
        # (Drop and) create the warehouse_unittest database with UTF-8 encoding
        # (in case the default encoding was changed from UTF-8)
        subprocess.call(['dropdb', 'warehouse_unittest'])
        subprocess.check_call(['createdb', '-E', 'UTF8', 'warehouse_unittest'])
        url = 'postgresql:///warehouse_unittest'

    engine = create_engine(url, poolclass=AssertionPool)

    request.addfinalizer(engine.dispose)

    if not os.getenv('WAREHOUSE_DATABASE_URL'):
        request.addfinalizer(
            lambda: subprocess.call(['dropdb', 'warehouse_unittest'])
        )

    # Connect to the database and create the necessary extensions
    engine.execute('CREATE EXTENSION IF NOT EXISTS "citext"')
    engine.execute('CREATE EXTENSION IF NOT EXISTS "uuid-ossp"')

    # Have Alembic create the schema
    alembic_cfg = alembic.config.Config()
    alembic_cfg.set_main_option(
        "script_location",
        "warehouse:migrations",
    )
    alembic_cfg.set_main_option("url", url)
    alembic.command.upgrade(alembic_cfg, "head")

    return engine


@pytest.fixture
def engine(request, database):
    connection = database.connect()
    transaction = connection.begin_nested()
    request.addfinalizer(transaction.rollback)
    request.addfinalizer(connection.close)
    return connection


class ErrorRedis:
    def __init__(self, url):
        self.url = url

    @classmethod
    def from_url(cls, url):
        return ErrorRedis(url)

    def __getattr__(self, name):
        raise RuntimeError("Cannot access redis")


@pytest.fixture
def dbapp(engine):
    from warehouse.application import Warehouse

    return Warehouse.from_yaml(
        override={
            "site": {
                "access_token": "testing",
                "hosts": "localhost",
            },
            "redis": {
                "downloads": "redis://nonexistent/0",
                "sessions": "redis://nonexistent/0",
            },
            "search": {"hosts": []},
        },
        engine=engine,
        redis_class=ErrorRedis,
    )


@pytest.fixture
def app():
    from warehouse.application import Warehouse

    def connect():
        raise RuntimeError(
            "Cannot access the database through the app fixture"
        )

    return Warehouse.from_yaml(
        override={
            "site": {
                "access_token": "testing",
                "hosts": "localhost",
            },
            "database": {"url": "postgresql:///nonexistent"},
            "redis": {
                "downloads": "redis://nonexistent/0",
                "sessions": "redis://nonexistent/0",
            },
            "search": {"hosts": []},
        },
        engine=pretend.stub(connect=connect, execute=connect),
        redis_class=ErrorRedis,
    )


@pytest.fixture
def user(dbapp):

    username = "guidovanrossum"
    email = "notanemail@example.org"
    password = "plaintextpasswordsaregreat"
    dbapp.db.accounts.insert_user(
        username,
        email,
        password)
    return_value = dbapp.db.accounts.get_user(username)
    return_value['password'] = password
    return return_value


@pytest.fixture
def project(user, dbapp):
    project_name = "fooproject"

    dbapp.db.packaging.upsert_project(project_name, user['username'],
                                      '0.0.0.0')
    return {
        "name": project_name
    }


@pytest.fixture
def release(user, dbapp, project):
    version = '1.0'

    dbapp.db.packaging.upsert_release(
        project['name'], version, user['username'], '0.0.0.0',
        description="this is a dummy package"
    )
    return {
        'project': project,
        'version': version
    }

########NEW FILE########
__FILENAME__ = test_middlewares
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pretend

from warehouse.legacy.middlewares import LegacyRewriteMiddleware


def test_no_modification():
    app = pretend.call_recorder(lambda environ, start_response: None)
    LegacyRewriteMiddleware(app)({"PATH_INFO": "/foo/bar"}, None)

    assert app.calls == [pretend.call({"PATH_INFO": "/foo/bar"}, None)]


def test_pypi_passes_through():
    app = pretend.call_recorder(lambda environ, start_response: None)
    LegacyRewriteMiddleware(app)({"PATH_INFO": "/pypi"}, None)

    assert app.calls == [pretend.call({"PATH_INFO": "/pypi"}, None)]


def test_pypi_dispatches_xmlrpc():
    app = pretend.call_recorder(lambda environ, start_response: None)
    LegacyRewriteMiddleware(app)(
        {
            "PATH_INFO": "/pypi",
            "CONTENT_TYPE": "text/xml",
        },
        None,
    )

    assert app.calls == [
        pretend.call(
            {"PATH_INFO": "/_legacy/xmlrpc/", "CONTENT_TYPE": "text/xml"},
            None,
        ),
    ]

########NEW FILE########
__FILENAME__ = test_pypi
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time
import datetime

import pretend
import pytest

from werkzeug.exceptions import NotFound, BadRequest
from werkzeug.routing import Map

from warehouse.legacy import pypi, xmlrpc
from warehouse.packaging import urls


@pytest.mark.parametrize("content_type", [None, "text/html", "__empty__"])
def test_pypi_index(content_type):
    headers = {}

    if content_type != "__empty__":
        headers["Content-Type"] = content_type

    app = pretend.stub()
    request = pretend.stub(
        args={},
        headers=headers,
        url_adapter=pretend.stub(
            build=pretend.call_recorder(
                lambda *a, **kw: "/",
            ),
        ),
    )
    # request for /pypi with no additional request information redirects
    # to site root
    #
    resp = pypi.pypi(app, request)
    assert resp.status_code == 301
    assert resp.headers["Location"] == "/"
    assert request.url_adapter.build.calls == [
        pretend.call(
            "warehouse.views.index",
            {},
            force_external=False,
        ),
    ]


def test_pypi_route_action(monkeypatch):
    app = pretend.stub()
    request = pretend.stub(
        args={':action': 'test'},
        headers={},
    )

    _action_methods = {}
    monkeypatch.setattr(pypi, '_action_methods', _action_methods)

    @pypi.register('test')
    def test(app, request):
        test.called = True
        return 'success'

    resp = pypi.pypi(app, request)

    assert resp == 'success'
    assert test.called


def test_pypi_route_action_double(monkeypatch):
    _action_methods = {'test': None}
    monkeypatch.setattr(pypi, '_action_methods', _action_methods)

    with pytest.raises(KeyError):
        pypi.register('test')


def test_daytime(monkeypatch):
    app = pretend.stub()
    request = pretend.stub()

    monkeypatch.setattr(time, 'time', lambda: 0)

    resp = pypi.daytime(app, request)

    assert resp.response[0] == b'19700101T00:00:00\n'


@pytest.mark.parametrize(("version", "callback"), [
    (None, None),
    (None, 'yes'),
    ('1.0', 'yes'),
    ('1.0', None),
])
def test_json(monkeypatch, version, callback):
    get_project = pretend.call_recorder(lambda n: {'name': 'spam'})
    get_project_versions = pretend.call_recorder(lambda n: ['2.0', '1.0'])
    get_last_serial = pretend.call_recorder(lambda *n: 42)
    app = pretend.stub(
        config=pretend.stub(cache=pretend.stub(browser=False, varnish=False)),
        db=pretend.stub(
            packaging=pretend.stub(
                get_project=get_project,
                get_project_versions=get_project_versions,
                get_last_serial=get_last_serial,
            )
        )
    )
    request = pretend.stub(args={})
    if callback:
        request.args['callback'] = callback

    release_data = pretend.call_recorder(lambda n, v: dict(some='data'))
    release_urls = pretend.call_recorder(lambda n, v: [dict(
        some='url',
        upload_time=datetime.date(1970, 1, 1)
    )])
    all_release_urls = pretend.call_recorder(lambda *n: {
        '1.0': [dict(some='data', upload_time=datetime.date(1970, 1, 1))],
        '2.0': [dict(some='data', upload_time=datetime.date(1970, 1, 1))],
    })
    Interface = pretend.call_recorder(lambda a, r: pretend.stub(
        release_data=release_data,
        release_urls=release_urls,
        all_release_urls=all_release_urls,
    ))

    monkeypatch.setattr(xmlrpc, 'Interface', Interface)

    resp = pypi.project_json(app, request, project_name='spam',
                             version=version)

    assert get_project.calls == [pretend.call('spam')]
    assert get_project_versions.calls == [pretend.call('spam')]
    assert release_data.calls == [pretend.call('spam', version or '2.0')]
    assert release_urls.calls == [pretend.call('spam', version or '2.0')]
    assert all_release_urls.calls == [pretend.call('spam')]
    assert get_last_serial.calls == [pretend.call()]
    expected = '{"info": {"some": "data"}, ' \
        '"releases": ' \
        '{"1.0": [{"some": "data", "upload_time": "1970-01-01T00:00:00"}], ' \
        '"2.0": [{"some": "data", "upload_time": "1970-01-01T00:00:00"}]}, ' \
        '"urls": [{"some": "url", "upload_time": "1970-01-01T00:00:00"}]}'
    if callback:
        expected = '/**/ %s(%s);' % (callback, expected)
    assert resp.data == expected.encode("utf8")


def test_jsonp_invalid():
    app = pretend.stub()
    request = pretend.stub(args={'callback': 'quite invalid'})
    with pytest.raises(BadRequest):
        pypi.project_json(app, request, project_name='spam')


@pytest.mark.parametrize(("project", "version"), [
    (None, None),
    (pretend.stub(name="spam"), None),
    (pretend.stub(name="spam"), '1'),
])
def test_json_missing(monkeypatch, project, version):
    return_value = {'name': project} if project else None
    get_project = pretend.call_recorder(lambda n: return_value)
    get_project_versions = pretend.call_recorder(lambda n: [])
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_project=get_project,
                get_project_versions=get_project_versions,
            )
        )
    )
    request = pretend.stub(args={})

    with pytest.raises(NotFound):
        pypi.project_json(app, request, project_name='spam', version=version)


def test_rss(app, monkeypatch):
    now = datetime.datetime.utcnow()

    get_recently_updated = pretend.call_recorder(lambda num=10: [
        dict(name='spam', version='1.0', summary='hai spam', created=now),
        dict(name='ham', version='2.0', summary='hai ham', created=now),
        dict(name='spam', version='2.0', summary='hai spam v2', created=now),
    ])

    app.db = pretend.stub(
        packaging=pretend.stub(
            get_recently_updated=get_recently_updated,
        )
    )
    app.config = pretend.stub(
        site={"url": "http://test.server/", "name": "PyPI"},
    )

    request = pretend.stub(
        url_adapter=Map(urls.urls).bind('test.server', '/'),
    )

    resp = pypi.rss(app, request)

    assert resp.response.context == {
        "description": "package updates",
        "site": {"name": "PyPI", "url": "http://test.server/"},
        "releases": [
            {
                "url": "http://test.server/project/spam/1.0/",
                "version": "1.0",
                "name": "spam",
                "summary": "hai spam",
                "created": now,
            },
            {
                "url": "http://test.server/project/ham/2.0/",
                "version": "2.0",
                "name": "ham",
                "summary": "hai ham",
                "created": now,
            },
            {
                "url": "http://test.server/project/spam/2.0/",
                "version": "2.0",
                "name": "spam",
                "summary": "hai spam v2",
                "created": now,
            }
        ],
    }
    assert get_recently_updated.calls == [pretend.call(num=40)]


def test_packages_rss(app, monkeypatch):
    now = datetime.datetime.utcnow()

    get_recent_projects = pretend.call_recorder(lambda num=10: [
        dict(name='spam', version='1.0', summary='hai spam', created=now),
        dict(name='ham', version='2.0', summary='hai ham', created=now),
        dict(name='eggs', version='21.0', summary='hai eggs!', created=now),
    ])
    app.db = pretend.stub(
        packaging=pretend.stub(
            get_recent_projects=get_recent_projects,
        )
    )
    app.config = pretend.stub(
        site={"url": "http://test.server/", "name": "PyPI"},
    )

    request = pretend.stub(
        url_adapter=Map(urls.urls).bind('test.server', '/'),
    )

    resp = pypi.packages_rss(app, request)

    assert resp.response.context == {
        "description": "new projects",
        "site": {"name": "PyPI", "url": "http://test.server/"},
        "releases": [
            {
                "url": "http://test.server/project/spam/",
                "version": "1.0",
                "name": "spam",
                "summary": "hai spam",
                "created": now,
            },
            {
                "url": "http://test.server/project/ham/",
                "version": "2.0",
                "name": "ham",
                "summary": "hai ham",
                "created": now,
            },
            {
                "url": "http://test.server/project/eggs/",
                "version": "21.0",
                "name": "eggs",
                "summary": "hai eggs!",
                "created": now,
            },
        ],
    }
    assert get_recent_projects.calls == [pretend.call(num=40)]


def test_rss_xml_template(app, monkeypatch):
    template = app.templates.get_template('legacy/rss.xml')
    content = template.render(
        site=dict(url='http://test.server/', name="PyPI"),
        description='package updates',
        releases=[
            {
                'url': 'http://test.server/project/spam/',
                'version': u'1.0',
                'name': u'spam',
                'summary': u'hai spam',
                'created': datetime.date(1970, 1, 1),
            }, {
                'url': 'http://test.server/project/ham/',
                'version': u'2.0',
                'name': u'ham',
                'summary': u'hai ham',
                'created': datetime.date(1970, 1, 1),
            }, {
                'url': 'http://test.server/project/eggs/',
                'version': u'21.0',
                'name': u'eggs',
                'summary': u'hai eggs!',
                'created': datetime.date(1970, 1, 1),
            }
        ],
    )
    assert content == '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rss PUBLIC "-//Netscape Communications//DTD RSS 0.91//EN" \
"http://my.netscape.com/publish/formats/rss-0.91.dtd">
<rss version="0.91">
 <channel>
  <title>PyPI Recent Package Updates</title>
  <link>http://test.server/</link>
  <description>Recent package updates at PyPI</description>
  <language>en</language>
  \n\
  <item>
    <title>spam 1.0</title>
    <link>http://test.server/project/spam/</link>
    <guid>http://test.server/project/spam/</guid>
    <description>hai spam</description>
    <pubDate>01 Jan 1970 00:00:00 GMT</pubDate>
  </item>
  \n\
  <item>
    <title>ham 2.0</title>
    <link>http://test.server/project/ham/</link>
    <guid>http://test.server/project/ham/</guid>
    <description>hai ham</description>
    <pubDate>01 Jan 1970 00:00:00 GMT</pubDate>
  </item>
  \n\
  <item>
    <title>eggs 21.0</title>
    <link>http://test.server/project/eggs/</link>
    <guid>http://test.server/project/eggs/</guid>
    <description>hai eggs!</description>
    <pubDate>01 Jan 1970 00:00:00 GMT</pubDate>
  </item>
  \n\
  </channel>
</rss>'''

########NEW FILE########
__FILENAME__ = test_simple
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os.path

import pretend
import pytest

from werkzeug.exceptions import NotFound
from werkzeug.test import create_environ

from warehouse.legacy import simple


def test_index(app):
    all_projects = ["bar", "foo"]

    app.db = pretend.stub(
        packaging=pretend.stub(
            all_projects=pretend.call_recorder(lambda: all_projects),
            get_last_serial=pretend.call_recorder(lambda: 9999),
        ),
    )

    request = pretend.stub()
    resp = simple.index(app, request)

    assert resp.headers["X-PyPI-Last-Serial"] == "9999"
    assert resp.response.template.name == "legacy/simple/index.html"
    assert resp.response.context == {
        "projects": ["bar", "foo"],
    }


@pytest.mark.parametrize(
    ("project_name", "hosting_mode", "release_urls", "e_project_urls"),
    [
        ("foo", "pypi-explicit", {}, []),
        ("foo", "pypi-explicit", {}, []),
        (
            "foo", "pypi-scrape",
            {
                "1.0": (
                    "http://example.com/home/",
                    "http://example.com/download/",
                ),
            },
            [
                {
                    "name": "1.0 home_page",
                    "rel": "ext-homepage",
                    "url": "http://example.com/home/",
                },
                {
                    "name": "1.0 download_url",
                    "rel": "ext-download",
                    "url": "http://example.com/download/",
                },
            ],
        ),
        ("foo", "pypi-scrape", {"1.0": ("UNKNOWN", "UNKNOWN")}, []),
    ],
)
def test_project(app, monkeypatch,
                 project_name, hosting_mode, release_urls, e_project_urls):
    url_for = lambda *a, **k: "/foo/"
    monkeypatch.setattr(simple, "url_for", url_for)

    app.db = pretend.stub(
        packaging=pretend.stub(
            get_project=pretend.call_recorder(
                lambda p: {'name': project_name},
            ),
            get_file_urls=pretend.call_recorder(lambda p: []),
            get_hosting_mode=pretend.call_recorder(
                lambda p: hosting_mode,
            ),
            get_external_urls=pretend.call_recorder(lambda p: []),
            get_last_serial=pretend.call_recorder(lambda p: 9999),
            get_release_urls=pretend.call_recorder(lambda p: release_urls),
        ),
    )

    request = pretend.stub()
    resp = simple.project(app, request, project_name=project_name)

    assert resp.headers["Link"] == "</foo/>; rel=canonical"
    assert (resp.headers["Surrogate-Key"] ==
            "project project/{}".format(project_name))
    assert resp.response.template.name == "legacy/simple/detail.html"
    assert resp.response.context == {
        "project": project_name,
        "project_urls": e_project_urls,
        "files": [],
        "external_urls": [],
    }

    assert app.db.packaging.get_project.calls == [
        pretend.call(project_name),
    ]
    assert app.db.packaging.get_file_urls.calls == [
        pretend.call(project_name),
    ]
    assert app.db.packaging.get_hosting_mode.calls == [
        pretend.call(project_name),
    ]
    assert app.db.packaging.get_external_urls.calls == [
        pretend.call(project_name),
    ]
    assert app.db.packaging.get_last_serial.calls == [
        pretend.call(project_name),
    ]

    if hosting_mode == "pypi-explicit":
        assert app.db.packaging.get_release_urls.calls == []
    else:
        assert app.db.packaging.get_release_urls.calls == [
            pretend.call(project_name),
        ]


def test_project_not_found(app):
    app.db = pretend.stub(
        packaging=pretend.stub(
            get_project=pretend.call_recorder(lambda p: None),
        ),
    )

    request = pretend.stub()

    with pytest.raises(NotFound):
        simple.project(app, request, project_name="foo")

    assert app.db.packaging.get_project.calls == [pretend.call("foo")]


@pytest.mark.parametrize(("serial", "md5_hash"), [
    (999, "d41d8cd98f00b204e9800998ecf8427f"),
    (None, "d41d8cd98f00b204e9800998ecf8427f"),
    (999, None),
    (None, None),
])
def test_package(serial, md5_hash, monkeypatch):
    safe_join = pretend.call_recorder(
        lambda *a, **k: "/tmp/packages/any/t/test-1.0.tar.gz"
    )
    _fp = pretend.stub(__enter__=lambda: None, __exit__=lambda *a: None)
    _open = pretend.call_recorder(lambda *a, **k: _fp)
    wrap_file = lambda *a, **k: None
    mtime = pretend.call_recorder(lambda f: 123457)
    getsize = pretend.call_recorder(lambda f: 54321)

    monkeypatch.setattr(simple, "safe_join", safe_join)
    monkeypatch.setattr(simple, "open", _open, raising=False)
    monkeypatch.setattr(simple, "wrap_file", wrap_file)
    monkeypatch.setattr(os.path, "getmtime", mtime)
    monkeypatch.setattr(os.path, "getsize", getsize)

    gpff = pretend.call_recorder(lambda p: "test")
    get_md5 = pretend.call_recorder(
        lambda p: md5_hash
    )
    get_last_serial = pretend.call_recorder(lambda p: serial)

    app = pretend.stub(
        config=pretend.stub(
            cache=pretend.stub(browser=False, varnish=False),
            paths=pretend.stub(packages="/tmp"),
        ),
        db=pretend.stub(
            packaging=pretend.stub(
                get_project_for_filename=gpff,
                get_filename_md5=get_md5,
                get_last_serial=get_last_serial,
            ),
        ),
    )
    request = pretend.stub(environ=create_environ())

    resp = simple.package(app, request, path="packages/any/t/test-1.0.tar.gz")

    if serial:
        assert resp.headers["X-PyPI-Last-Serial"] == str(serial)
    else:
        assert "X-PyPI-Last-Serial" not in resp.headers

    assert resp.headers["Surrogate-Key"] == "project project/test"
    assert resp.headers["Content-Length"] == "54321"

    assert safe_join.calls == [
        pretend.call("/tmp", "packages/any/t/test-1.0.tar.gz"),
    ]
    assert _open.calls == [
        pretend.call("/tmp/packages/any/t/test-1.0.tar.gz", "rb"),
    ]
    assert mtime.calls == [pretend.call("/tmp/packages/any/t/test-1.0.tar.gz")]
    assert getsize.calls == [
        pretend.call("/tmp/packages/any/t/test-1.0.tar.gz"),
    ]
    assert gpff.calls == [pretend.call("test-1.0.tar.gz")]
    assert get_md5.calls == [pretend.call("test-1.0.tar.gz")]
    assert get_last_serial.calls == [pretend.call("test")]


def test_package_not_found_unsafe(monkeypatch):
    safe_join = pretend.call_recorder(lambda *a, **k: None)
    monkeypatch.setattr(simple, "safe_join", safe_join)

    app = pretend.stub(
        config=pretend.stub(
            paths=pretend.stub(packages="/tmp"),
        ),
    )
    request = pretend.stub()

    with pytest.raises(NotFound):
        simple.package(app, request, path="packages/any/t/test-1.0.tar.gz")

    assert safe_join.calls == [
        pretend.call("/tmp", "packages/any/t/test-1.0.tar.gz"),
    ]


def test_package_not_found_unsafe_missing(monkeypatch):
    safe_join = pretend.call_recorder(
        lambda *a, **k: "/tmp/packages/any/t/test-1.0.tar.gz"
    )

    def raising_open(*args, **kwargs):
        raise IOError

    _open = pretend.call_recorder(raising_open)

    monkeypatch.setattr(simple, "safe_join", safe_join)
    monkeypatch.setattr(simple, "open", _open, raising=False)

    app = pretend.stub(
        config=pretend.stub(
            paths=pretend.stub(packages="/tmp"),
        ),
    )
    request = pretend.stub()

    with pytest.raises(NotFound):
        simple.package(app, request, path="packages/any/t/test-1.0.tar.gz")

    assert safe_join.calls == [
        pretend.call("/tmp", "packages/any/t/test-1.0.tar.gz"),
    ]
    assert _open.calls == [
        pretend.call("/tmp/packages/any/t/test-1.0.tar.gz", "rb"),
    ]

########NEW FILE########
__FILENAME__ = test_xmlrpc
# -*- encoding: utf8 -*-
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime

import arrow
import pretend
import pytest

from werkzeug.exceptions import BadRequest

from warehouse.legacy import xmlrpc


def test_xmlrpc_handler(monkeypatch):
    Response = pretend.call_recorder(lambda *a, **k: 'response')
    monkeypatch.setattr(xmlrpc, "Response", Response)

    # I'm aware that list_packages shouldn't return data with unicode strings
    # but for the purposes of this test I'm just ensuring that unicode data is
    # handled sanely
    interface = pretend.stub(
        list_packages=pretend.call_recorder(lambda *a, **k: ['one', 'unicod€'])
    )
    Interface = lambda a, r: interface
    monkeypatch.setattr(xmlrpc, "Interface", Interface)

    app = pretend.stub()

    xml_request = '''<?xml version="1.0"?><methodCall>
        <methodName>list_packages</methodName></methodCall>'''

    request = pretend.stub(
        headers={
            'Content-Type': 'text/xml',
            'Content-Length': str(len(xml_request)),
        },
        get_data=lambda **k: xml_request,
    )

    assert xmlrpc.handler(app, request) == 'response'

    assert interface.list_packages.calls == [pretend.call()]

    response_xml = Response.calls[0].args[0]
    assert response_xml == b'''<?xml version='1.0'?>
<methodResponse>
<params>
<param>
<value><array><data>
<value><string>one</string></value>
<value><string>unicod\xe2\x82\xac</string></value>
</data></array></value>
</param>
</params>
</methodResponse>
'''

    assert Response.calls[0].kwargs == dict(mimetype='text/xml; charset=utf-8')


def test_xmlrpc_handler_size_limit(monkeypatch):
    app = pretend.stub()

    request = pretend.stub(
        headers={
            'Content-Type': 'text/xml',
            'Content-Length': str(10 * 1024 * 1024 + 1)
        },
    )

    with pytest.raises(BadRequest):
        xmlrpc.handler(app, request)


def test_xmlrpc_list_packages():
    all_projects = ["bar", "foo"]

    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                all_projects=pretend.call_recorder(lambda: all_projects),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    result = interface.list_packages()

    assert app.db.packaging.all_projects.calls == [pretend.call()]
    assert result == ['bar', 'foo']


@pytest.mark.parametrize(("num", "result"), [
    (None, [('three', 10000), ('one', 1110), ('two', 22)]),
    (2, [('three', 10000), ('one', 1110)]),
])
def test_xmlrpc_top_packages(num, result):
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_top_projects=pretend.call_recorder(lambda *a: result),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    if num:
        r = interface.top_packages(num)
        assert app.db.packaging.get_top_projects.calls == [
            pretend.call(num)
        ]
    else:
        r = interface.top_packages()
        assert app.db.packaging.get_top_projects.calls == [
            pretend.call(None)
        ]

    assert r == result


def test_xmlrpc_package_releases():
    result = ['1', '2', '3', '4']
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_project_versions=pretend.call_recorder(lambda *a: result),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    assert interface.package_releases('name') == ['1', '2', '3', '4']

    assert app.db.packaging.get_project_versions.calls == [
        pretend.call('name')
    ]


def test_xmlrpc_package_roles():
    result = [
        dict(user_name='one', role_name='Owner'),
        dict(user_name='two', role_name='Maintainer')
    ]
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_roles_for_project=pretend.call_recorder(lambda *a: result),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    assert interface.package_roles('name') == [
        ['one', 'Owner'], ['two', 'Maintainer']
    ]

    assert app.db.packaging.get_roles_for_project.calls == [
        pretend.call('name')
    ]


def test_xmlrpc_user_packages():
    result = [
        dict(package_name='one', role_name='Owner'),
        dict(package_name='two', role_name='Maintainer')
    ]
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_roles_for_user=pretend.call_recorder(lambda *a: result),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    assert interface.user_packages('name') == [
        ['one', 'Owner'], ['two', 'Maintainer']
    ]

    assert app.db.packaging.get_roles_for_user.calls == [
        pretend.call('name')
    ]


def test_xmlrpc_package_hosting_mode():
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_hosting_mode=pretend.call_recorder(lambda *a: 'yes!'),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    assert interface.package_hosting_mode('name') == 'yes!'

    assert app.db.packaging.get_hosting_mode.calls == [
        pretend.call('name')
    ]


def test_xmlrpc_release_downloads():
    results = [
        dict(filename='one', downloads=1),
        dict(filename='two', downloads=2),
    ]
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_downloads=pretend.call_recorder(lambda *a: results),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    assert interface.release_downloads('name', '1.0') == [
        ['one', 1], ['two', 2]
    ]

    assert app.db.packaging.get_downloads.calls == [
        pretend.call('name', '1.0')
    ]


@pytest.mark.parametrize("with_ids", [False, True])
def test_xmlrpc_changelog(with_ids):
    now_timestamp = arrow.utcnow().timestamp
    now = arrow.get(now_timestamp).datetime
    old = datetime.datetime.utcnow() - datetime.timedelta(days=1)
    old_timestamp = arrow.get(old).timestamp
    old = arrow.get(old_timestamp).datetime
    now_plus_1 = now + datetime.timedelta(days=1)
    now_plus_2 = now + datetime.timedelta(days=2)
    data = [
        dict(name='one', version='1', submitted_date=now,
             action='created', id=1),
        dict(name='two', version='2', submitted_date=now,
             action='new release', id=2),
        dict(name='one', version='2', submitted_date=now_plus_1,
             action='new release', id=3),
        dict(name='one', version='3', submitted_date=now_plus_2,
             action='new release', id=4),
    ]
    result = [
        ['one', '1', arrow.get(now).timestamp, 'created', 1],
        ['two', '2', arrow.get(now).timestamp, 'new release', 2],
        ['one', '2', arrow.get(now_plus_1).timestamp, 'new release', 3],
        ['one', '3', arrow.get(now_plus_2).timestamp, 'new release', 4],
    ]
    if not with_ids:
        result = [r[:4] for r in result]
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_changelog=pretend.call_recorder(lambda *a: data),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    old_timestamp = arrow.get(old).timestamp
    assert interface.changelog(old_timestamp, with_ids) == result

    old = arrow.get(old_timestamp).datetime
    assert app.db.packaging.get_changelog.calls == [
        pretend.call(old)
    ]


def test_xmlrpc_changelog_last_serial():
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_last_changelog_serial=pretend.call_recorder(lambda *a: 2),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    assert interface.changelog_last_serial() == 2

    assert app.db.packaging.get_last_changelog_serial.calls == [
        pretend.call()
    ]


def test_xmlrpc_changelog_serial():
    now_timestamp = arrow.utcnow().timestamp
    now = arrow.get(now_timestamp).datetime
    now_plus_1 = now + datetime.timedelta(days=1)
    now_plus_2 = now + datetime.timedelta(days=2)
    data = [
        dict(name='one', version='1', submitted_date=now,
             action='created', id=1),
        dict(name='two', version='2', submitted_date=now,
             action='new release', id=2),
        dict(name='one', version='2', submitted_date=now_plus_1,
             action='new release', id=3),
        dict(name='one', version='3', submitted_date=now_plus_2,
             action='new release', id=4),
    ]
    result = [
        ['one', '1', arrow.get(now).timestamp, 'created', 1],
        ['two', '2', arrow.get(now).timestamp, 'new release', 2],
        ['one', '2', arrow.get(now_plus_1).timestamp, 'new release', 3],
        ['one', '3', arrow.get(now_plus_2).timestamp, 'new release', 4],
    ]
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_changelog_serial=pretend.call_recorder(lambda *a: data),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    assert interface.changelog_since_serial(1) == result

    assert app.db.packaging.get_changelog_serial.calls == [
        pretend.call(1)
    ]


def test_xmlrpc_updated_releases():
    now = datetime.datetime.utcnow()

    result = [
        dict(name='one', version='1', created=now, summary='text'),
        dict(name='two', version='2', created=now, summary='text'),
        dict(name='two', version='3', created=now, summary='text'),
        dict(name='three', version='4', created=now, summary='text')]
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_releases_since=pretend.call_recorder(lambda *a: result),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    old_timestamp = arrow.get(now - datetime.timedelta(days=1)).timestamp
    assert interface.updated_releases(old_timestamp) == \
        [['one', '1'], ['two', '2'], ['two', '3'], ['three', '4']]

    assert app.db.packaging.get_releases_since.calls == [
        pretend.call(arrow.get(old_timestamp).datetime)
    ]


def test_xmlrpc_changed_packages():
    now = datetime.datetime.utcnow()

    result = ['one', 'two', 'three']
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_changed_since=pretend.call_recorder(lambda *a: result),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    old_timestamp = arrow.get(now - datetime.timedelta(days=1)).timestamp
    assert interface.changed_packages(old_timestamp) == result

    assert app.db.packaging.get_changed_since.calls == [
        pretend.call(arrow.get(old_timestamp).datetime)
    ]


def test_xmlrpc_list_packages_with_serial():
    d = dict(one=1, two=2, three=3)
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_projects_with_serial=pretend.call_recorder(lambda: d),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    result = interface.list_packages_with_serial()

    assert app.db.packaging.get_projects_with_serial.calls == [
        pretend.call(),
    ]
    assert result == d


@pytest.mark.parametrize("pgp", [True, False])
def test_release_urls(pgp, monkeypatch):
    dt = datetime.datetime.utcnow()

    downloads = [
        dict(
            name="spam",
            url='/packages/source/t/spam/spam-1.0.tar.gz',
            version="1.0",
            filename="spam-1.0.tar.gz",
            python_version="source",
            packagetype="sdist",
            md5_digest="0cc175b9c0f1b6a831c399e269772661",
            downloads=10,
            size=1234,
            pgp_url='/packages/source/t/spam/spam-1.0.tar.gz.sig'
                if pgp else None,
            comment_text='download for great justice',
            upload_time=dt,
        ),
        dict(
            name="spam",
            url='/packages/source/t/spam/spam-1.0.zip',
            version="1.0",
            filename="spam-1.0.zip",
            python_version="source",
            packagetype="sdist",
            md5_digest="0cc175b3c0f1b6a831c399e269772661",
            downloads=12,
            size=1235,
            pgp_url='/packages/source/t/spam/spam-1.0.zip.sig'
                if pgp else None,
            comment_text=None,
            upload_time=dt,
        )
    ]
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_downloads=pretend.call_recorder(lambda *a: downloads),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    result = interface.release_urls('spam', '1.0')

    assert app.db.packaging.get_downloads.calls == [
        pretend.call('spam', '1.0'),
    ]
    assert result == [
        dict(
            url='/packages/source/t/spam/spam-1.0.tar.gz',
            packagetype="sdist",
            filename="spam-1.0.tar.gz",
            size=1234,
            md5_digest="0cc175b9c0f1b6a831c399e269772661",
            downloads=10,
            has_sig=pgp,
            python_version="source",
            comment_text='download for great justice',
            upload_time=dt,
        ),
        dict(
            url='/packages/source/t/spam/spam-1.0.zip',
            packagetype="sdist",
            filename="spam-1.0.zip",
            size=1235,
            md5_digest="0cc175b3c0f1b6a831c399e269772661",
            downloads=12,
            has_sig=pgp,
            python_version="source",
            comment_text=None,
            upload_time=dt,
        )
    ]


def test_all_release_urls(monkeypatch):
    dt = datetime.datetime.utcnow()

    urls = {
        '1.0': [
            dict(
                name="spam",
                url='/packages/source/t/spam/spam-1.0.tar.gz',
                version="1.0",
                filename="spam-1.0.tar.gz",
                python_version="source",
                packagetype="sdist",
                md5_digest="0cc175b9c0f1b6a831c399e269772661",
                downloads=10,
                size=1234,
                pgp_url=None,
                comment_text='download for great justice',
                upload_time=dt,
            ),
            dict(
                name="spam",
                url='/packages/source/t/spam/spam-1.0.zip',
                version="1.0",
                filename="spam-1.0.zip",
                python_version="source",
                packagetype="sdist",
                md5_digest="0cc175b3c0f1b6a831c399e269772661",
                downloads=12,
                size=1235,
                pgp_url=None,
                comment_text=None,
                upload_time=dt,
            )
        ],
        '2.0': [
            dict(
                name="spam",
                url='/packages/source/t/spam/spam-2.0.tar.gz',
                version="2.0",
                filename="spam-2.0.tar.gz",
                python_version="source",
                packagetype="sdist",
                md5_digest="0cc175b9c0f1b6a831c399e269772661",
                downloads=10,
                size=1234,
                pgp_url=None,
                comment_text='download for great justice',
                upload_time=dt,
            )
        ]
    }

    vers = ['1.0', '2.0']

    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_downloads=pretend.call_recorder(lambda *a: urls[a[1]]),
                get_project_versions=pretend.call_recorder(lambda *a: vers),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    result = interface.all_release_urls('spam')

    assert app.db.packaging.get_downloads.calls == [
        pretend.call('spam', '1.0'),
        pretend.call('spam', '2.0'),
    ]
    assert result == {
        '1.0': [
            dict(
                url='/packages/source/t/spam/spam-1.0.tar.gz',
                packagetype="sdist",
                filename="spam-1.0.tar.gz",
                size=1234,
                md5_digest="0cc175b9c0f1b6a831c399e269772661",
                downloads=10,
                has_sig=False,
                python_version="source",
                comment_text='download for great justice',
                upload_time=dt,
            ),
            dict(
                url='/packages/source/t/spam/spam-1.0.zip',
                packagetype="sdist",
                filename="spam-1.0.zip",
                size=1235,
                md5_digest="0cc175b3c0f1b6a831c399e269772661",
                downloads=12,
                has_sig=False,
                python_version="source",
                comment_text=None,
                upload_time=dt,
            )
        ],
        '2.0': [
            dict(
                url='/packages/source/t/spam/spam-2.0.tar.gz',
                packagetype="sdist",
                filename="spam-2.0.tar.gz",
                size=1234,
                md5_digest="0cc175b9c0f1b6a831c399e269772661",
                downloads=10,
                has_sig=False,
                python_version="source",
                comment_text='download for great justice',
                upload_time=dt,
            )
        ]
    }


def test_release_data(monkeypatch):
    # arrow conversion is messy, make sure we are comparing the same thing
    now_timestamp = arrow.utcnow().timestamp
    now = arrow.get(now_timestamp).datetime

    resp = dict(
        name="spam",
        version="1.0",
        author="John Doe",
        author_email="john.doe@example.com",
        maintainer=None,
        maintainer_email=None,
        home_page="https://example.com/",
        license="Apache License v2.0",
        summary="A Test Project",
        description="A Longer Test Project and let's have some üñìçøđé",
        keywords="foo,bar,wat",
        platform="All",
        download_url="https://example.com/downloads/test-project-1.0.tar.gz",
        requires_dist=["requests (>=2.0)"],
        provides_dist=["test-project-old"],
        project_url={"Repository": "git://git.example.com/"},
        created=now,
    )
    # snapshot that info now for comparison later
    info = dict(resp)
    docs = "https://pythonhosted.org/spam/"
    cfiers = ['Section A :: Subsection B :: Aisle 3', 'Section B']
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_release=pretend.call_recorder(lambda *a: resp),
                get_documentation_url=pretend.call_recorder(lambda *a: docs),
                get_download_counts=pretend.call_recorder(lambda *a: 10),
                get_classifiers=pretend.call_recorder(lambda *a: cfiers),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    result = interface.release_data('spam', '1.0')

    assert app.db.packaging.get_release.calls == [
        pretend.call('spam', '1.0'),
    ]

    # modify the model response data according to the expected mutation
    info.update(
        package_url='http://pypi.python.org/pypi/spam',
        release_url='http://pypi.python.org/pypi/spam/1.0',
        docs_url=docs,
        downloads=10,
        classifiers=cfiers,
        maintainer='',              # converted from None
        maintainer_email='',        # converted from None
        stable_version='',          # filled in as no-op
        created=now_timestamp,
    )
    assert result == info


def test_release_data_missing(monkeypatch):
    def f(*a):
        raise IndexError()

    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_release=pretend.call_recorder(f),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    result = interface.release_data('spam', '1.0')

    assert app.db.packaging.get_release.calls == [
        pretend.call('spam', '1.0'),
    ]

    assert result == {}


def test_xmlrpc_browse():
    cids = {'hello': 1, 'there': 2}
    results = [['one', 1], ['two', 2]]
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_classifier_ids=pretend.call_recorder(lambda *a: cids),
                search_by_classifier=pretend.call_recorder(lambda *a: results),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    assert interface.browse(['hello', 'there']) == results

    assert app.db.packaging.get_classifier_ids.calls == [
        pretend.call(['hello', 'there'])
    ]
    assert app.db.packaging.search_by_classifier.calls == [
        pretend.call(set([2, 1]))
    ]


def test_xmlrpc_browse_invalid_arg():
    interface = xmlrpc.Interface(pretend.stub(), pretend.stub())

    with pytest.raises(TypeError):
        interface.browse('hello')


def test_xmlrpc_browse_invalid_classifier():
    cids = {'hello': 1}
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_classifier_ids=pretend.call_recorder(lambda *a: cids),
            ),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    with pytest.raises(ValueError):
        interface.browse(['hello', 'spam'])


@pytest.mark.parametrize(("spec", "operator", "length", "query"), [
    ({"name": "Django"}, None, 1000, {'match': {'name': 'Django'}}),
    ({"name": "Django"}, None, 2000, {'match': {'name': 'Django'}}),
    ({"name": ["Django"]}, None, 1000, {'match': {'name': 'Django'}}),
    ({"name": ["Django"]}, None, 2000, {'match': {'name': 'Django'}}),
    ({"name": "Django"}, "and", 1000, {'match': {'name': 'Django'}}),
    ({"name": "Django"}, "and", 2000, {'match': {'name': 'Django'}}),
    ({"name": ["Django"]}, "and", 1000, {'match': {'name': 'Django'}}),
    ({"name": ["Django"]}, "and", 2000, {'match': {'name': 'Django'}}),
    (
        {"name": "Django"},
        "or",
        1000,
        {'bool': {'should': [{'match': {'name': {'query': 'Django'}}}]}},
    ),
    (
        {"name": "Django"},
        "or",
        2000,
        {'bool': {'should': [{'match': {'name': {'query': 'Django'}}}]}},
    ),
    (
        {"name": ["Django"]},
        "or", 1000,
        {'bool': {'should': [{'match': {'name': {'query': 'Django'}}}]}},
    ),
    (
        {"name": ["Django"]},
        "or",
        2000,
        {'bool': {'should': [{'match': {'name': {'query': 'Django'}}}]}},
    ),
])
def test_xmlrpc_search(spec, operator, length, query):
    results = {
        "hits": {
            "hits": [{
                "_source": {
                    "name": "Django",
                    "version": "1.0",
                    "summary": "Wat",
                },
            }] * 1000,
            "total": length,
        }
    }
    app = pretend.stub(
        search=pretend.stub(
            es=pretend.stub(
                search=pretend.call_recorder(
                    lambda index, doc_type, body: results
                ),
            ),
            _index="warehouse",
            types=pretend.stub(project=pretend.stub(_type="project")),
        ),
    )

    interface = xmlrpc.Interface(app, pretend.stub())

    args = [spec]
    if operator:
        args.append(operator)

    assert interface.search(*args) == [
        {
            "name": "Django",
            "version": "1.0",
            "summary": "Wat",
            "_pypi_ordering": 0,
        }
    ] * length

    calls = [
        pretend.call(
            body={'query': query, 'from': x * 1000, 'size': 1000},
            index='warehouse',
            doc_type='project',
        )
        for x in range(0, length // 1000)
    ]

    assert app.search.es.search.calls == calls


def test_xmlrpc_search_invalid():
    interface = xmlrpc.Interface(pretend.stub(), pretend.stub())

    with pytest.raises(TypeError):
        interface.search({}, "fake!")

########NEW FILE########
__FILENAME__ = db
import datetime
import random

import factory

from factory import base
from factory.fuzzy import (
    BaseFuzzyAttribute, FuzzyText, FuzzyNaiveDateTime, FuzzyInteger,
    FuzzyChoice,
)

from warehouse.packaging.tables import packages, releases, release_files
from warehouse.utils import normalize_project_name


def table_shim(table):
    class FakeTable(dict):
        __table__ = table

    return FakeTable


class FuzzyVersion(BaseFuzzyAttribute):

    def __init__(self, length=3):
        self.length = length

    def fuzz(self):
        return ".".join(
            str(random.randint(0, 100)) for _ in range(self.length)
        )


class WarehouseFactory(base.Factory):

    @classmethod
    def _create(cls, target_class, *args, **kwargs):
        engine = kwargs.pop("engine")
        obj = target_class(*args, **kwargs)
        engine.execute(target_class.__table__.insert().values(**obj))
        return obj


class ProjectFactory(WarehouseFactory):
    FACTORY_FOR = table_shim(packages)

    name = FuzzyText()
    normalized_name = factory.LazyAttribute(
        lambda obj: normalize_project_name(obj.name)
    )


class ReleaseFactory(WarehouseFactory):
    FACTORY_FOR = table_shim(releases)

    version = FuzzyVersion()
    summary = FuzzyText(length=75)
    created = FuzzyNaiveDateTime(
        datetime.datetime.now() - datetime.timedelta(days=5),
    )


class ReleaseFileFactory(WarehouseFactory):
    FACTORY_FOR = table_shim(release_files)
    FACTORY_HIDDEN_ARGS = ["EXTS"]

    EXTS = {
        "sdist": ".tar.gz",
    }

    packagetype = FuzzyChoice(["sdist"])
    filename = factory.LazyAttribute(
        lambda obj: "{}-{}{}".format(
            obj.name,
            obj.version,
            obj.EXTS[obj.packagetype],
        )
    )
    downloads = FuzzyInteger(10000)

########NEW FILE########
__FILENAME__ = test_cli
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from unittest import mock

import pretend

from warehouse.migrations.cli import AlembicCommand


def test_calling_alembic_command(app):
    rvalue = pretend.stub()

    class TestCommand(AlembicCommand):
        command = pretend.call_recorder(lambda c, *a, **k: rvalue)

    assert TestCommand()(app) is rvalue
    assert TestCommand.command.calls == [pretend.call(mock.ANY)]

########NEW FILE########
__FILENAME__ = test_db
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import os.path

import pretend
import pytest

from warehouse.accounts.tables import users, emails
from warehouse.packaging.db import log
from warehouse.packaging.tables import (
    packages, releases, release_files, description_urls, journals, classifiers,
    release_classifiers, release_dependencies, roles, ReleaseDependencyKind
)


def test_get_project_count(dbapp):
    dbapp.engine.execute(packages.insert().values(name="foo1"))
    dbapp.engine.execute(packages.insert().values(name="foo2"))
    dbapp.engine.execute(packages.insert().values(name="foo3"))

    assert dbapp.db.packaging.get_project_count() == 3


def test_get_download_count(dbapp):
    assert dbapp.db.packaging.get_download_count() == 0

    dbapp.engine.execute(packages.insert().values(name="foo"))
    dbapp.engine.execute(releases.insert().values(name="foo", version="1.0"))
    dbapp.engine.execute(release_files.insert().values(
        name="foo",
        version="1.0",
        filename="foo-1.0.tar.gz",
        downloads=15,
    ))
    dbapp.engine.execute(release_files.insert().values(
        name="foo",
        version="1.0",
        filename="foo-1.0.tar.bz2",
        downloads=12,
    ))

    assert dbapp.db.packaging.get_download_count() == 27


def test_get_recently_updated(dbapp):
    dbapp.engine.execute(packages.insert().values(name="foo1"))
    dbapp.engine.execute(packages.insert().values(name="foo2"))
    dbapp.engine.execute(packages.insert().values(name="foo3"))
    dbapp.engine.execute(packages.insert().values(name="foo4"))
    dbapp.engine.execute(packages.insert().values(name="foo5"))
    dbapp.engine.execute(packages.insert().values(name="foo6"))
    dbapp.engine.execute(packages.insert().values(name="foo7"))
    dbapp.engine.execute(packages.insert().values(name="foo8"))
    dbapp.engine.execute(packages.insert().values(name="foo9"))
    dbapp.engine.execute(packages.insert().values(name="foo10"))
    dbapp.engine.execute(packages.insert().values(name="foo11"))
    dbapp.engine.execute(packages.insert().values(name="foo12"))

    now = datetime.datetime.utcnow()

    dbapp.engine.execute(releases.insert().values(
        name="foo1", version="2.0", created=now,
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo1", version="1.0",
        created=now - datetime.timedelta(seconds=5),
    ))

    dbapp.engine.execute(releases.insert().values(
        name="foo2", version="1.0",
        created=now - datetime.timedelta(seconds=10),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo3", version="1.0",
        created=now - datetime.timedelta(seconds=15),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo4", version="1.0",
        created=now - datetime.timedelta(seconds=20),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo5", version="1.0",
        created=now - datetime.timedelta(seconds=25),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo6", version="1.0",
        created=now - datetime.timedelta(seconds=30),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo7", version="1.0",
        created=now - datetime.timedelta(seconds=35),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo8", version="1.0",
        created=now - datetime.timedelta(seconds=40),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo9", version="1.0",
        created=now - datetime.timedelta(seconds=45),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo10", version="1.0",
        created=now - datetime.timedelta(seconds=50),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo11", version="1.0",
        created=now - datetime.timedelta(seconds=55),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo12", version="1.0",
        created=now - datetime.timedelta(seconds=60),
    ))

    assert dbapp.db.packaging.get_recently_updated() == [
        {
            "name": "foo1",
            "version": "2.0",
            "summary": None,
            "created": now,
        },
        {
            "name": "foo2",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=10),
        },
        {
            "name": "foo3",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=15),
        },
        {
            "name": "foo4",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=20),
        },
        {
            "name": "foo5",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=25),
        },
        {
            "name": "foo6",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=30),
        },
        {
            "name": "foo7",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=35),
        },
        {
            "name": "foo8",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=40),
        },
        {
            "name": "foo9",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=45),
        },
        {
            "name": "foo10",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=50),
        },
    ]


def test_get_releases_since(dbapp):
    dbapp.engine.execute(packages.insert().values(name="foo1"))
    dbapp.engine.execute(packages.insert().values(name="foo2"))
    dbapp.engine.execute(packages.insert().values(name="foo3"))

    now = datetime.datetime.utcnow()

    dbapp.engine.execute(releases.insert().values(
        name="foo2", version="1.0",
        created=now - datetime.timedelta(seconds=10),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo3", version="2.0",
        created=now - datetime.timedelta(seconds=9),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo1", version="1.0",
        created=now - datetime.timedelta(seconds=4),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo3", version="1.0",
        created=now - datetime.timedelta(seconds=3),
    ))
    dbapp.engine.execute(releases.insert().values(
        name="foo1", version="2.0", created=now,
    ))

    since = now - datetime.timedelta(seconds=5)
    assert dbapp.db.packaging.get_releases_since(since) == [
        {
            "name": "foo1",
            "version": "2.0",
            "summary": None,
            "created": now,
        },
        {
            "name": "foo3",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=3),
        },
        {
            "name": "foo1",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=4),
        },
    ]


def test_get_changed_since(dbapp):
    dbapp.engine.execute(packages.insert().values(name="foo1"))
    dbapp.engine.execute(packages.insert().values(name="foo2"))
    dbapp.engine.execute(packages.insert().values(name="foo3"))

    now = datetime.datetime.utcnow()

    dbapp.engine.execute(journals.insert().values(
        name="foo2", submitted_date=now - datetime.timedelta(seconds=10),
    ))
    dbapp.engine.execute(journals.insert().values(
        name="foo1", submitted_date=now - datetime.timedelta(seconds=4),
    ))
    dbapp.engine.execute(journals.insert().values(
        name="foo3", submitted_date=now - datetime.timedelta(seconds=3),
    ))
    dbapp.engine.execute(journals.insert().values(
        name="foo1", submitted_date=now, ))

    since = now - datetime.timedelta(seconds=5)
    assert dbapp.db.packaging.get_changed_since(since) == ["foo1", "foo3"]


def test_get_changelog(dbapp):
    now = datetime.datetime.utcnow()

    def create(name, delta):
        dbapp.engine.execute(packages.insert().values(name=name))
        dbapp.engine.execute(journals.insert().values(
            name=name,
            version=None,
            submitted_date=now - delta,
            action="create",
            id=create.id,
        ))
        create.id += 1
    create.id = 1
    create("foo1", datetime.timedelta(seconds=4))
    create("foo2", datetime.timedelta(seconds=5))
    create("foo3", datetime.timedelta(seconds=10))

    def release(name, version, delta):
        dbapp.engine.execute(releases.insert().values(
            name=name,
            version=version,
            created=now - delta,
        ))
        dbapp.engine.execute(journals.insert().values(
            id=create.id,
            name=name,
            version=version,
            submitted_date=now - delta,
            action="new release",
        ))
        create.id += 1
    release("foo2", "1.0", datetime.timedelta(seconds=10))
    release("foo3", "2.0", datetime.timedelta(seconds=9))
    release("foo1", "1.0", datetime.timedelta(seconds=3))
    release("foo3", "1.0", datetime.timedelta(seconds=2))
    release("foo1", "2.0", datetime.timedelta(seconds=1))

    since = now - datetime.timedelta(seconds=5)
    assert dbapp.db.packaging.get_changelog(since) == [
        {
            "name": "foo1",
            "version": "2.0",
            "action": "new release",
            "submitted_date": now - datetime.timedelta(seconds=1),
            "id": 8,
        },
        {
            "name": "foo3",
            "version": "1.0",
            "action": "new release",
            "submitted_date": now - datetime.timedelta(seconds=2),
            "id": 7,
        },
        {
            "name": "foo1",
            "version": "1.0",
            "action": "new release",
            "submitted_date": now - datetime.timedelta(seconds=3),
            "id": 6,
        },
        {
            "name": "foo1",
            "version": None,
            "action": "create",
            "submitted_date": now - datetime.timedelta(seconds=4),
            "id": 1,
        },
    ]


def test_get_last_changelog_serial(dbapp):
    dbapp.engine.execute(journals.insert().values(id=1))
    dbapp.engine.execute(journals.insert().values(id=2))
    dbapp.engine.execute(journals.insert().values(id=3))

    assert dbapp.db.packaging.get_last_changelog_serial() == 3


def test_get_changelog_serial(dbapp):
    now = datetime.datetime.utcnow()

    def create(name, delta):
        dbapp.engine.execute(packages.insert().values(name=name))
        dbapp.engine.execute(journals.insert().values(
            name=name,
            version=None,
            submitted_date=now - delta,
            action="create",
            id=create.id,
        ))
        create.id += 1
    create.id = 1
    create("foo1", datetime.timedelta(seconds=4))
    create("foo2", datetime.timedelta(seconds=5))
    create("foo3", datetime.timedelta(seconds=10))

    def release(name, version, delta):
        dbapp.engine.execute(releases.insert().values(
            name=name,
            version=version,
            created=now - delta,
        ))
        dbapp.engine.execute(journals.insert().values(
            id=create.id,
            name=name,
            version=version,
            submitted_date=now - delta,
            action="new release",
        ))
        create.id += 1
    release("foo2", "1.0", datetime.timedelta(seconds=10))
    release("foo3", "2.0", datetime.timedelta(seconds=9))
    release("foo1", "1.0", datetime.timedelta(seconds=3))
    release("foo3", "1.0", datetime.timedelta(seconds=2))
    release("foo1", "2.0", datetime.timedelta(seconds=1))

    assert dbapp.db.packaging.get_changelog_serial(5) == [
        {
            "name": "foo1",
            "version": "2.0",
            "action": "new release",
            "submitted_date": now - datetime.timedelta(seconds=1),
            "id": 8,
        },
        {
            "name": "foo3",
            "version": "1.0",
            "action": "new release",
            "submitted_date": now - datetime.timedelta(seconds=2),
            "id": 7,
        },
        {
            "name": "foo1",
            "version": "1.0",
            "action": "new release",
            "submitted_date": now - datetime.timedelta(seconds=3),
            "id": 6,
        },
    ]


@pytest.mark.parametrize("projects", [
    ["foo", "bar", "zap"],
    ["fail", "win", "YeS"],
])
def test_all_projects(projects, dbapp):
    # Insert some data into the database
    for project in projects:
        dbapp.engine.execute(packages.insert().values(name=project))

    all_projects = sorted(projects, key=lambda x: x.lower())

    assert dbapp.db.packaging.all_projects() == all_projects


@pytest.mark.parametrize(("num", "result"), [
    (None, [('three', 10000), ('one', 1110), ('two', 22)]),
    (2, [('three', 10000), ('one', 1110)]),
])
def test_top_projects(num, result, dbapp):
    # Insert some data into the database
    files = [
        ('one', 10, 'one-1.0.zip'),
        ('one', 100, 'one-1.1.zip'),
        ('one', 1000, 'one-1.2.zip'),
        ('two', 2, 'two-1.0.zip'),
        ('two', 20, 'two-1.2.zip'),
        ('three', 10000, 'three-1.0.zip'),
    ]
    for name, downloads, filename in files:
        dbapp.engine.execute(release_files.insert().values(
            name=name,
            downloads=downloads,
            filename=filename,
        ))

    top = dbapp.db.packaging.get_top_projects(num)
    assert top == result


def test_get_recent_projects(dbapp):
    def create_package(name, version, ordering, created):
        dbapp.engine.execute(packages.insert().values(
            name=name, created=created))
        dbapp.engine.execute(releases.insert().values(
            name=name, version=version, _pypi_ordering=ordering,
            created=created))

    now = datetime.datetime.utcnow()
    create_package("foo1", "2.0", 2, now)
    create_package("foo2", "1.0", 1, now - datetime.timedelta(seconds=45))
    create_package("foo3", "1.0", 1, now - datetime.timedelta(seconds=15))
    create_package("foo4", "1.0", 1, now - datetime.timedelta(seconds=40))
    create_package("foo5", "1.0", 1, now - datetime.timedelta(seconds=25))
    create_package("foo6", "1.0", 1, now - datetime.timedelta(seconds=30))
    create_package("foo7", "1.0", 1, now - datetime.timedelta(seconds=35))

    dbapp.engine.execute(releases.insert().values(
        name="foo1", version="1.0", _pypi_ordering=1,
        created=now - datetime.timedelta(seconds=5),
    ))

    assert dbapp.db.packaging.get_recent_projects(num=4) == [
        {
            "name": "foo1",
            "version": "2.0",
            "summary": None,
            "created": now,
        },
        {
            "name": "foo3",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=15),
        },
        {
            "name": "foo5",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=25),
        },
        {
            "name": "foo6",
            "version": "1.0",
            "summary": None,
            "created": now - datetime.timedelta(seconds=30),
        },
    ]


@pytest.mark.parametrize(("name", "normalized"), [
    ("foo_bar", "foo-bar"),
    ("Bar", "bar"),
])
def test_get_project(name, normalized, dbapp):
    # prepare database
    dbapp.engine.execute(
        packages.insert().values(name=name, normalized_name=normalized)
    )

    assert dbapp.db.packaging.get_project(normalized)['name'] == name


def test_get_project_missing(dbapp):
    assert dbapp.db.packaging.get_project("missing") is None


def test_get_projects_for_user(dbapp):
    dbapp.engine.execute(users.insert().values(
        password="!",
        username="test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))
    dbapp.engine.execute(packages.insert().values(name="test-project"))
    dbapp.engine.execute(releases.insert().values(
        name="test-project",
        version="1.0",
        summary="test summmary",
        _pypi_ordering=1,
    ))
    dbapp.engine.execute(releases.insert().values(
        name="test-project",
        version="2.0",
        summary="test summmary 2.0",
        _pypi_ordering=2,
    ))
    dbapp.engine.execute(roles.insert().values(
        package_name="test-project",
        user_name="test-user",
        role_name="Owner",
    ))

    assert dbapp.db.packaging.get_projects_for_user("test-user") == [
        {"name": "test-project", "summary": "test summmary 2.0"},
    ]


def test_get_projects_for_user_missing(dbapp):
    assert dbapp.db.packaging.get_projects_for_user("missing") == []


def test_get_users_for_project(dbapp):
    dbapp.engine.execute(users.insert().values(
        id=1,
        password="!",
        username="test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))
    dbapp.engine.execute(users.insert().values(
        id=2,
        password="!",
        username="a-test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))
    dbapp.engine.execute(users.insert().values(
        id=3,
        password="!",
        username="test-user2",
        name="Test User2",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))
    dbapp.engine.execute(emails.insert().values(
        user_id=3,
        email="test@example.com",
        primary=True,
        verified=True,
    ))
    dbapp.engine.execute(packages.insert().values(name="test-project"))
    dbapp.engine.execute(roles.insert().values(
        package_name="test-project",
        user_name="test-user",
        role_name="Owner",
    ))
    dbapp.engine.execute(roles.insert().values(
        package_name="test-project",
        user_name="test-user2",
        role_name="Maintainer",
    ))
    dbapp.engine.execute(roles.insert().values(
        package_name="test-project",
        user_name="test-user",
        role_name="Maintainer",
    ))
    dbapp.engine.execute(roles.insert().values(
        package_name="test-project",
        user_name="a-test-user",
        role_name="Maintainer",
    ))

    assert dbapp.db.packaging.get_users_for_project("test-project") == [
        {"username": "a-test-user", "email": None},
        {"username": "test-user", "email": None},
        {"username": "test-user2", "email": "test@example.com"},
    ]


def test_get_roles_for_project(dbapp):
    dbapp.engine.execute(users.insert().values(
        id=1,
        password="!",
        username="test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))
    dbapp.engine.execute(users.insert().values(
        id=2,
        password="!",
        username="a-test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))
    dbapp.engine.execute(users.insert().values(
        id=3,
        password="!",
        username="test-user2",
        name="Test User2",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))
    dbapp.engine.execute(packages.insert().values(name="test-project"))
    dbapp.engine.execute(roles.insert().values(
        package_name="test-project",
        user_name="test-user",
        role_name="Owner",
    ))
    dbapp.engine.execute(roles.insert().values(
        package_name="test-project",
        user_name="test-user",
        role_name="Maintainer",
    ))
    dbapp.engine.execute(roles.insert().values(
        package_name="test-project",
        user_name="a-test-user",
        role_name="Maintainer",
    ))

    assert dbapp.db.packaging.get_roles_for_project("test-project") == [
        {"user_name": "a-test-user", "role_name": 'Maintainer'},
        {"user_name": "test-user", "role_name": 'Maintainer'},
        {"user_name": "test-user", "role_name": "Owner"},
    ]


def test_get_roles_for_user(dbapp):
    dbapp.engine.execute(users.insert().values(
        id=1,
        password="!",
        username="test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))
    dbapp.engine.execute(users.insert().values(
        id=2,
        password="!",
        username="a-test-user",
        name="Test User",
        last_login=datetime.datetime.utcnow(),
        is_active=True,
        is_superuser=False,
        is_staff=False,
    ))
    dbapp.engine.execute(packages.insert().values(name="test-project"))
    dbapp.engine.execute(packages.insert().values(name="test-project2"))
    dbapp.engine.execute(packages.insert().values(name="test-project3"))
    dbapp.engine.execute(roles.insert().values(
        package_name="test-project",
        user_name="test-user",
        role_name="Owner",
    ))
    dbapp.engine.execute(roles.insert().values(
        package_name="test-project",
        user_name="test-user",
        role_name="Maintainer",
    ))
    dbapp.engine.execute(roles.insert().values(
        package_name="test-project2",
        user_name="a-test-user",
        role_name="Maintainer",
    ))
    dbapp.engine.execute(roles.insert().values(
        package_name="test-project2",
        user_name="test-user",
        role_name="Maintainer",
    ))

    assert dbapp.db.packaging.get_roles_for_user("test-user") == [
        {"package_name": "test-project", "role_name": 'Maintainer'},
        {"package_name": "test-project", "role_name": "Owner"},
        {"package_name": "test-project2", "role_name": 'Maintainer'},
    ]


def test_get_users_for_project_missing(dbapp):
    assert dbapp.db.packaging.get_users_for_project("test-project") == []


@pytest.mark.parametrize(("name", "mode"), [
    ("foo", "pypi-explicit"),
    ("bar", "pypi-scrape"),
    ("wat", "pypi-scrape-crawl"),
])
def test_get_hosting_mode(name, mode, dbapp):
    # prepare database
    dbapp.engine.execute(
        packages.insert().values(name=name, hosting_mode=mode)
    )

    assert dbapp.db.packaging.get_hosting_mode(name) == mode


@pytest.mark.parametrize(("name", "attrs"), [
    ("foo", [
        {"version": "1.0", "home_page": "https://example.com/v1/home/"},
        {"version": "2.0", "download_url": "https://example.com/v2/download"},
        {
            "version": "3.0",
            "home_page": "https://example.com/v3/home/",
            "download_url": "https://example.com/v3/download",
        },
    ]),
])
def test_get_release_urls(name, attrs, dbapp):
    # prepare database
    dbapp.engine.execute(packages.insert().values(name=name))
    for data in attrs:
        dbapp.engine.execute(
            releases.insert().values(name=name, **data)
        )

    assert dbapp.db.packaging.get_release_urls(name) == {
        a["version"]: (a.get("home_page"), a.get("download_url"))
        for a in attrs
    }


@pytest.mark.parametrize(("name", "urls"), [
    ("foo", [
        "https://example.com/1/",
        "https://example.com/3/",
        "https://example.com/2/",
        "https://example.com/5/",
        "https://example.com/3/",
    ]),
])
def test_get_external_urls(name, urls, dbapp):
    # prepare database
    for url in urls:
        dbapp.engine.execute(
            description_urls.insert().values(name=name, url=url)
        )

    assert dbapp.db.packaging.get_external_urls(name) == sorted(set(urls))


@pytest.mark.parametrize(("name", "values", "urls"), [
    (
        "test-package",
        [
            {
                "filename": "test-package-1.0.tar.gz",
                "python_version": "any",
                "md5_digest": "d41d8cd98f00b204e9800998ecf8427e",
            },
            {
                "filename": "test-package-2.0.tar.gz",
                "python_version": "any",
                "md5_digest": "d41d8cd98f00b204e9800998ecf8427f",
            },
        ],
        [
            (
                "test-package-1.0.tar.gz",
                ("../../packages/any/t/test-package/test-package-1.0.tar.gz"
                 "#md5=d41d8cd98f00b204e9800998ecf8427e"),
            ),
            (
                "test-package-2.0.tar.gz",
                ("../../packages/any/t/test-package/test-package-2.0.tar.gz"
                 "#md5=d41d8cd98f00b204e9800998ecf8427f"),
            ),
        ],
    ),
])
def test_get_file_urls(name, values, urls, dbapp):
    # prepare db
    dbapp.engine.execute(packages.insert().values(name=name))
    for value in values:
        dbapp.engine.execute(release_files.insert().values(name=name, **value))

    assert dbapp.db.packaging.get_file_urls(name) == [
        {"filename": f, "url": u} for f, u in sorted(set(urls), reverse=True)
    ]


@pytest.mark.parametrize(("name", "filename"), [
    ("foo", "foo-1.0.tar.gz"),
])
def test_get_project_for_filename(name, filename, dbapp):
    # prepare database
    dbapp.engine.execute(
        release_files.insert().values(name=name, filename=filename)
    )

    assert dbapp.db.packaging.get_project_for_filename(filename) == name


@pytest.mark.parametrize(("filename", "md5"), [
    ("foo-1.0.tar.gz", "d41d8cd98f00b204e9800998ecf8427f"),
])
def test_get_filename_md5(filename, md5, dbapp):
    # prepare database
    dbapp.engine.execute(
        release_files.insert().values(filename=filename, md5_digest=md5)
    )

    assert dbapp.db.packaging.get_filename_md5(filename) == md5


@pytest.mark.parametrize(("name", "serial"), [
    ("foo", 1234567),
    (None, 2345553),
])
def test_get_last_serial(name, serial, dbapp):
    dbapp.engine.execute(journals.insert().values(id=serial, name=name))

    assert dbapp.db.packaging.get_last_serial(name) == serial


def test_get_projects_with_serial(dbapp):
    dbapp.engine.execute(journals.insert().values(id=1, name='one'))
    dbapp.engine.execute(journals.insert().values(id=2, name='two'))
    dbapp.engine.execute(journals.insert().values(id=3, name='three'))

    assert dbapp.db.packaging.get_projects_with_serial() == dict(
        one=1,
        two=2,
        three=3
    )


def test_get_project_versions(dbapp):
    dbapp.engine.execute(packages.insert().values(name="test-project"))
    dbapp.engine.execute(releases.insert().values(
        name="test-project",
        version="2.0",
        _pypi_ordering=2,
    ))
    dbapp.engine.execute(releases.insert().values(
        name="test-project",
        version="1.0",
        _pypi_ordering=1,
    ))
    dbapp.engine.execute(releases.insert().values(
        name="test-project",
        version="3.0",
        _pypi_ordering=3,
    ))
    dbapp.engine.execute(releases.insert().values(
        name="test-project",
        version="4.0",
        _pypi_ordering=4,
    ))

    assert dbapp.db.packaging.get_project_versions("test-project") == \
        ["4.0", "3.0", "2.0", "1.0"]


def test_get_release_missing_project(dbapp):
    assert not dbapp.db.packaging.get_release("foo", "1.2.3")


def test_get_release(dbapp):
    created = datetime.datetime.utcnow()

    dbapp.engine.execute(packages.insert().values(name="test-project"))
    dbapp.engine.execute(releases.insert().values(
        created=created,
        name="test-project",
        version="1.0",
        author="John Doe",
        author_email="john.doe@example.com",
        maintainer="Jane Doe",
        maintainer_email="jane.doe@example.com",
        home_page="https://example.com/",
        license="Apache License v2.0",
        summary="A Test Project",
        description="A Longer Test Project",
        keywords="foo,bar,wat",
        platform="All",
        download_url="https://example.com/downloads/test-project-1.0.tar.gz",
        _pypi_ordering=1,
    ))
    dbapp.engine.execute(releases.insert().values(
        created=created,
        name="test-project",
        version="2.0",
        author="John Doe",
        author_email="john.doe@example.com",
        maintainer="Jane Doe",
        maintainer_email="jane.doe@example.com",
        home_page="https://example.com/",
        license="Apache License v2.0",
        summary="A Test Project",
        description="A Longer Test Project",
        keywords="foo,bar,wat",
        platform="All",
        download_url="https://example.com/downloads/test-project-1.0.tar.gz",
        _pypi_ordering=2,
    ))
    dbapp.engine.execute(release_dependencies.insert().values(
        name="test-project",
        version="1.0",
        kind=4,
        specifier="requests (>=2.0)",
    ))
    dbapp.engine.execute(release_dependencies.insert().values(
        name="test-project",
        version="2.0",
        kind=4,
        specifier="requests (>=2.0)",
    ))
    dbapp.engine.execute(release_dependencies.insert().values(
        name="test-project",
        version="1.0",
        kind=5,
        specifier="test-project-old",
    ))
    dbapp.engine.execute(release_dependencies.insert().values(
        name="test-project",
        version="2.0",
        kind=5,
        specifier="test-project-old",
    ))
    dbapp.engine.execute(release_dependencies.insert().values(
        name="test-project",
        version="1.0",
        kind=8,
        specifier="Repository,git://git.example.com/",
    ))
    dbapp.engine.execute(release_dependencies.insert().values(
        name="test-project",
        version="2.0",
        kind=8,
        specifier="Repository,git://git.example.com/",
    ))

    test_release = dbapp.db.packaging.get_release("test-project", "1.0")

    assert test_release == {
        "name": "test-project",
        "version": "1.0",
        "author": "John Doe",
        "author_email": "john.doe@example.com",
        "maintainer": "Jane Doe",
        "maintainer_email": "jane.doe@example.com",
        "home_page": "https://example.com/",
        "license": "Apache License v2.0",
        "summary": "A Test Project",
        "description": "A Longer Test Project",
        "keywords": "foo,bar,wat",
        "platform": "All",
        "download_url": ("https://example.com/downloads/"
                         "test-project-1.0.tar.gz"),
        "requires_dist": ["requests (>=2.0)"],
        "provides_dist": ["test-project-old"],
        "project_url": {"Repository": "git://git.example.com/"},
        "created": created,
    }


def test_get_releases(dbapp):
    created = datetime.datetime.utcnow()

    dbapp.engine.execute(packages.insert().values(name="test-project"))
    dbapp.engine.execute(releases.insert().values(
        created=created,
        name="test-project",
        version="1.0",
        author="John Doe",
        author_email="john.doe@example.com",
        maintainer="Jane Doe",
        maintainer_email="jane.doe@example.com",
        home_page="https://example.com/",
        license="Apache License v2.0",
        summary="A Test Project",
        description="A Longer Test Project",
        keywords="foo,bar,wat",
        platform="All",
        download_url="https://example.com/downloads/test-project-1.0.tar.gz",
        _pypi_ordering=1,
    ))
    dbapp.engine.execute(releases.insert().values(
        created=created,
        name="test-project",
        version="2.0",
        author="John Doe",
        author_email="john.doe@example.com",
        maintainer="Jane Doe",
        maintainer_email="jane.doe@example.com",
        home_page="https://example.com/",
        license="Apache License v2.0",
        summary="A Test Project",
        description="A Longer Test Project",
        keywords="foo,bar,wat",
        platform="All",
        download_url="https://example.com/downloads/test-project-1.0.tar.gz",
        _pypi_ordering=2,
    ))
    dbapp.engine.execute(release_dependencies.insert().values(
        name="test-project",
        version="1.0",
        kind=4,
        specifier="requests (>=2.0)",
    ))
    dbapp.engine.execute(release_dependencies.insert().values(
        name="test-project",
        version="2.0",
        kind=4,
        specifier="requests (>=2.0)",
    ))
    dbapp.engine.execute(release_dependencies.insert().values(
        name="test-project",
        version="1.0",
        kind=5,
        specifier="test-project-old",
    ))
    dbapp.engine.execute(release_dependencies.insert().values(
        name="test-project",
        version="2.0",
        kind=5,
        specifier="test-project-old",
    ))
    dbapp.engine.execute(release_dependencies.insert().values(
        name="test-project",
        version="1.0",
        kind=8,
        specifier="Repository,git://git.example.com/",
    ))
    dbapp.engine.execute(release_dependencies.insert().values(
        name="test-project",
        version="2.0",
        kind=8,
        specifier="Repository,git://git.example.com/",
    ))

    assert dbapp.db.packaging.get_releases("test-project") == [
        {
            "name": "test-project",
            "version": "2.0",
            "author": "John Doe",
            "author_email": "john.doe@example.com",
            "maintainer": "Jane Doe",
            "maintainer_email": "jane.doe@example.com",
            "home_page": "https://example.com/",
            "license": "Apache License v2.0",
            "summary": "A Test Project",
            "keywords": "foo,bar,wat",
            "platform": "All",
            "download_url": ("https://example.com/downloads/"
                             "test-project-1.0.tar.gz"),
            "created": created,
        },
        {
            "name": "test-project",
            "version": "1.0",
            "author": "John Doe",
            "author_email": "john.doe@example.com",
            "maintainer": "Jane Doe",
            "maintainer_email": "jane.doe@example.com",
            "home_page": "https://example.com/",
            "license": "Apache License v2.0",
            "summary": "A Test Project",
            "keywords": "foo,bar,wat",
            "platform": "All",
            "download_url": ("https://example.com/downloads/"
                             "test-project-1.0.tar.gz"),
            "created": created,
        },
    ]


@pytest.mark.parametrize("exists", [True, False])
def test_get_documentation_url(exists, dbapp, monkeypatch):
    os_exists = pretend.call_recorder(lambda p: exists)

    monkeypatch.setattr(os.path, "exists", os_exists)

    docurl = dbapp.db.packaging.get_documentation_url("test-project")

    if exists:
        assert docurl == "https://pythonhosted.org/test-project/"
    else:
        assert docurl is None

    assert os_exists.calls == [
        pretend.call("data/packagedocs/test-project/index.html"),
    ]


def test_get_bugtrack_url(dbapp):
    dbapp.engine.execute(packages.insert().values(
        name="test-project",
        bugtrack_url="https://example.com/issues/",
    ))

    bugtracker = dbapp.db.packaging.get_bugtrack_url("test-project")

    assert bugtracker == "https://example.com/issues/"


def test_get_classifiers(dbapp):
    dbapp.engine.execute(packages.insert().values(name="test-project"))
    dbapp.engine.execute(releases.insert().values(
        name="test-project",
        version="1.0",
    ))
    dbapp.engine.execute(classifiers.insert().values(
        id=1,
        classifier="Test :: Classifier",
    ))
    dbapp.engine.execute(release_classifiers.insert().values(
        name="test-project",
        version="1.0",
        trove_id=1,
    ))

    test_classifiers = dbapp.db.packaging.get_classifiers(
        "test-project",
        "1.0",
    )

    assert test_classifiers == ["Test :: Classifier"]


def test_get_classifier_ids(dbapp):
    dbapp.engine.execute(classifiers.insert().values(
        id=1,
        classifier="Test :: Classifier",
    ))
    dbapp.engine.execute(classifiers.insert().values(
        id=2,
        classifier="Test :: Another",
    ))
    dbapp.engine.execute(classifiers.insert().values(
        id=3,
        classifier="Test :: The Other One",
    ))

    test_classifiers = dbapp.db.packaging.get_classifier_ids(
        ["Test :: Classifier", "Test :: The Other One"]
    )

    assert test_classifiers == {
        "Test :: Classifier": 1,
        "Test :: The Other One": 3
    }


@pytest.mark.parametrize(("search", "result"), [
    ([], []),
    ([1], [("one", "1"), ("two", "1"), ("four-six", "1")]),
    ([4], [("four-six", "1")]),
    ([7], [("seven", "1")]),
    ([4, 6], [("four-six", "1")]),
])
def test_search_by_classifier(search, result, dbapp):
    dbapp.engine.execute(classifiers.insert().values(
        id=1,
        classifier="Test :: Classifier",
        l2=1,
    ))
    dbapp.engine.execute(classifiers.insert().values(
        id=2,
        classifier="Test :: Classifier :: More",
        l2=1,
        l3=2
    ))
    dbapp.engine.execute(classifiers.insert().values(
        id=5,
        classifier="Test :: Classifier :: Alternative",
        l2=1,
        l3=5
    ))
    dbapp.engine.execute(classifiers.insert().values(
        id=3,
        classifier="Test :: Classifier :: More :: Wow",
        l2=1,
        l3=2,
        l4=3
    ))
    dbapp.engine.execute(classifiers.insert().values(
        id=4,
        classifier="Test :: Classifier :: More :: Wow :: So Classifier",
        l2=1,
        l3=2,
        l4=3,
        l5=4
    ))
    dbapp.engine.execute(classifiers.insert().values(
        id=6,
        classifier="Other :: Thing",
        l2=6
    ))
    dbapp.engine.execute(classifiers.insert().values(
        id=7,
        classifier="Other :: Thing :: Moar",
        l2=6,
        l3=7
    ))

    def add_project(name, classifiers):
        dbapp.engine.execute(packages.insert().values(name=name))
        dbapp.engine.execute(releases.insert().values(name=name, version="1"))
        for trove_id in classifiers:
            dbapp.engine.execute(release_classifiers.insert().values(
                name=name,
                version="1",
                trove_id=trove_id,
            ))

    add_project('one', [1])
    add_project('two', [2])
    add_project('four-six', [4, 6])
    add_project('seven', [7])

    response = dbapp.db.packaging.search_by_classifier(search)
    assert sorted(response) == sorted(result)


@pytest.mark.parametrize("pgp", [True, False])
def test_get_downloads(pgp, dbapp, monkeypatch):
    dbapp.engine.execute(packages.insert().values(name="test-project"))
    dbapp.engine.execute(releases.insert().values(
        name="test-project",
        version="1.0",
    ))
    dbapp.engine.execute(release_files.insert().values(
        name="test-project",
        version="1.0",
        filename="test-project-1.0.tar.gz",
        python_version="source",
        packagetype="sdist",
        md5_digest="0cc175b9c0f1b6a831c399e269772661",
        downloads=10,
        upload_time=datetime.datetime(year=2013, month=1, day=30),
    ))

    def os_exists():
        yield       # start
        yield True  # whether download file exists
        yield pgp   # whether .asc pgp file exists
    f = os_exists().send
    f(None)     # start it off
    os_exists = pretend.call_recorder(f)

    monkeypatch.setattr(os.path, "exists", os_exists)
    monkeypatch.setattr(os.path, "getsize", lambda x: 10)

    dbapp.config.paths.packages = "fake"

    downloads = dbapp.db.packaging.get_downloads("test-project", "1.0")

    pgp_url = "/packages/source/t/test-project/test-project-1.0.tar.gz.asc"

    assert downloads == [
        {
            "name": "test-project",
            "version": "1.0",
            "filename": "test-project-1.0.tar.gz",
            "filepath": "fake/source/t/test-project/test-project-1.0.tar.gz",
            "comment_text": None,
            "downloads": 10,
            "upload_time": datetime.datetime(year=2013, month=1, day=30),
            "python_version": "source",
            "md5_digest": "0cc175b9c0f1b6a831c399e269772661",
            "url": "/packages/source/t/test-project/test-project-1.0.tar.gz",
            "packagetype": "sdist",
            "size": 10,
            "pgp_url": pgp_url if pgp else None,
        },
    ]
    assert os_exists.calls == [
        pretend.call(downloads[0]["filepath"]),
        pretend.call(downloads[0]["filepath"] + ".asc")
    ]


def test_get_downloads_missing(dbapp, monkeypatch):
    dbapp.engine.execute(packages.insert().values(name="test-project"))
    dbapp.engine.execute(releases.insert().values(
        name="test-project",
        version="1.0",
    ))
    dbapp.engine.execute(release_files.insert().values(
        name="test-project",
        version="1.0",
        filename="test-project-1.0.tar.gz",
        python_version="source",
        packagetype="sdist",
        md5_digest="0cc175b9c0f1b6a831c399e269772661",
        downloads=10,
        upload_time=datetime.datetime(year=2013, month=1, day=30),
    ))

    # file does not exist
    os_exists = pretend.call_recorder(lambda p: False)

    # we match the specific arguments below - no need forcing them here as well
    log_error = pretend.call_recorder(lambda *a: None)

    monkeypatch.setattr(os.path, "exists", os_exists)
    # log from warehouse.packaging.db
    monkeypatch.setattr(log, "error", log_error)

    dbapp.config.paths.packages = "fake"

    downloads = dbapp.db.packaging.get_downloads("test-project", "1.0")

    assert downloads == []
    filepath = "fake/source/t/test-project/test-project-1.0.tar.gz"
    assert os_exists.calls == [pretend.call(filepath)]

    # actual error message may vary, so just assert that the logging was called
    assert log_error.calls == [
        pretend.call(
            "%s missing for package %s %s",
            filepath,
            "test-project",
            "1.0",
        ),
    ]


def test_get_download_counts(dbapp):
    mget = pretend.call_recorder(lambda *k: ["10", "20"])
    dbapp.db.packaging.redis = pretend.stub(mget=mget)

    counts = dbapp.db.packaging.get_download_counts("test-project")

    assert counts == {"last_day": 30, "last_week": 30, "last_month": 30}
    assert len(mget.calls) == 3


def test_get_full_latest_releases(dbapp):
    created = datetime.datetime.utcnow()

    dbapp.engine.execute(packages.insert().values(name="test-project"))
    dbapp.engine.execute(releases.insert().values(
        created=created,
        name="test-project",
        version="1.0",
        author="John Doe",
        author_email="john.doe@example.com",
        maintainer="Jane Doe",
        maintainer_email="jane.doe@example.com",
        home_page="https://example.com/",
        license="Apache License v2.0",
        summary="A Test Project",
        description="A Longer Test Project",
        keywords="foo,bar,wat",
        platform="All",
        download_url="https://example.com/downloads/test-project-1.0.tar.gz",
        _pypi_ordering=1,
    ))
    dbapp.engine.execute(releases.insert().values(
        created=created,
        name="test-project",
        version="2.0",
        author="John Doe",
        author_email="john.doe@example.com",
        maintainer="Jane Doe",
        maintainer_email="jane.doe@example.com",
        home_page="https://example.com/",
        license="Apache License v2.0",
        summary="A Test Project",
        description="A Longer Test Project",
        keywords="foo,bar,wat",
        platform="All",
        download_url="https://example.com/downloads/test-project-1.0.tar.gz",
        _pypi_ordering=2,
    ))

    assert dbapp.db.packaging.get_full_latest_releases() == [
        {
            "created": created,
            "name": "test-project",
            "version": "2.0",
            "author": "John Doe",
            "author_email": "john.doe@example.com",
            "maintainer": "Jane Doe",
            "maintainer_email": "jane.doe@example.com",
            "home_page": "https://example.com/",
            "license": "Apache License v2.0",
            "summary": "A Test Project",
            "description": "A Longer Test Project",
            "keywords": "foo,bar,wat",
            "platform": "All",
            "download_url": (
                "https://example.com/downloads/test-project-1.0.tar.gz"
            ),
        }
    ]


def test_insert_delete_project(dbapp, user):
    project_name = 'fooproject'
    dbapp.db.packaging.upsert_project(project_name, user['username'],
                                      '0.0.0.0')
    assert dbapp.db.packaging.get_project(project_name)
    dbapp.db.packaging.delete_project(project_name)
    assert not dbapp.db.packaging.get_project(project_name)


def test_upsert_project(dbapp, user, project):
    bugtrack_url = "http://bugtrack.example.com"
    dbapp.db.packaging.upsert_project(project['name'], user['username'],
                                      '0.0.0.0',
                                      bugtrack_url=bugtrack_url)
    project = dbapp.db.packaging.get_project(project['name'])
    assert project['bugtrack_url'] == bugtrack_url


def test_upsert_project_bad_column(dbapp, user):
    with pytest.raises(TypeError):
        dbapp.db.packaging.upsert_project(
            "badproject",
            user['username'],
            "0.0.0.0",
            badcolumn="this is a bad column"
        )


def test_delete_project(dbapp, project, release):
    dbapp.db.packaging.delete_project(
        project['name']
    )
    assert not dbapp.db.packaging.get_project(project['name'])


def test_upsert_release(dbapp, user, project):
    version = '1.0'
    dbapp.db.packaging.upsert_release(
        project["name"], version, user["username"], "0.0.0.0"
    )
    assert dbapp.db.packaging.get_release(project['name'], version)


def test_delete_release(dbapp, project, release):
    dbapp.db.packaging.delete_release(
        project['name'], release['version']
    )
    assert not dbapp.db.packaging.get_release(project['name'],
                                              release['version'])


def test_upsert_release_ordering(dbapp, user, project):
    older_version = '1.0'
    dbapp.db.packaging.upsert_release(
        project["name"], older_version, user["username"], "0.0.0.0"
    )

    newer_version = '1.1'
    dbapp.db.packaging.upsert_release(
        project["name"], newer_version, user["username"], "0.0.0.0"
    )

    versions = dbapp.db.packaging.get_project_versions(
        project['name']
    )

    assert versions == [newer_version, older_version]


def test_upsert_release_full(dbapp, user, project):
    """ test the updating of all of upsert """

    # setup
    dbapp.engine.execute(classifiers.insert().values(
        id=1,
        classifier="foo"
    ))
    release_dependencies = {
        ReleaseDependencyKind.requires_dist.value: ('foo',)
    }

    # test
    version = '1.0'
    dbapp.db.packaging.upsert_release(
        project['name'], version, user['username'], '0.0.0.0',
        classifiers=('foo',),
        release_dependencies=release_dependencies
    )

    assert dbapp.db.packaging.get_release(project['name'], version)

    assert set(dbapp.db.packaging.get_classifiers(
        project['name'],
        version)
    ) == set(('foo',))

    assert set(dbapp.db.packaging.get_classifiers(
        project['name'], version
    )) == set(('foo',))


def test_upsert_release_parse_description(dbapp, user, project):
    dbapp.db.packaging.upsert_project(
        project['name'],
        user['username'],
        '0.0.0.0',
        hosting_mode="pypi-scrape-crawl"
    )

    example_url = "http://description.example.com"
    dbapp.db.packaging.upsert_release(
        project["name"], "1.0", user["username"], "0.0.0.0",
        description="`example <{0}>`_".format(example_url)
    )

    assert set(dbapp.db.packaging.get_release_external_urls(
        project['name'], "1.0"
    )) == set((example_url,))


def test_upsert_release_update(dbapp, user, release):
    new_description = "this is an new dummy description"
    dbapp.db.packaging.upsert_release(
        release['project']['name'], release['version'],
        user['username'], '0.0.0.0',
        description=new_description
    )
    release_info = dbapp.db.packaging.get_release(
        release['project']['name'], release['version']
    )
    assert release_info['description'] == new_description


def test_upsert_release_update_release_dependencies(dbapp, user, release):
    specifier_dict = {
        ReleaseDependencyKind.requires_dist.value: set((
            "foo",
        )),
    }

    dbapp.db.packaging.upsert_release(
        release['project']['name'], release['version'],
        user['username'], '0.0.0.0',
        release_dependencies=specifier_dict
    )

    assert dbapp.db.packaging.get_release_dependencies(
        release['project']['name'], release['version']
    ) == specifier_dict


def test_upsert_bad_parameter(dbapp, user, project):
    with pytest.raises(TypeError):
        dbapp.db.packaging.upsert_release(
            project['name'], '1.0', user['username'], '0.0.0.0',
            badparam="imnotinreleasedb"
        )


def test_upsert_good_parameter(dbapp, user, project):
    author = "imanauthor"
    dbapp.db.packaging.upsert_release(
        project['name'], '1.0', user['username'], '0.0.0.0',
        author=author
    )
    assert dbapp.db.packaging.get_release(
        project['name'], '1.0'
    )['author'] == author


def test_update_release_dependencies(dbapp, release):

    specifier_dict = {
        ReleaseDependencyKind.requires_dist.value: set((
            "foo",
            "bar"
        )),
        ReleaseDependencyKind.provides_dist.value: set((
            "baz",
        ))
    }

    p, v = release['project']['name'], release['version']

    dbapp.db.packaging.update_release_dependencies(
        p, v, specifier_dict
    )

    assert dbapp.db.packaging.get_release_dependencies(
        p, v
    ) == specifier_dict

    specifier_dict = {
        ReleaseDependencyKind.requires_dist.value: set((
            "foo",
            "bar"
        )),
        ReleaseDependencyKind.provides_dist.value: set((
            "boobaz",
        ))
    }

    dbapp.db.packaging.update_release_dependencies(
        p, v, specifier_dict
    )

    assert dbapp.db.packaging.get_release_dependencies(
        p, v
    ) == specifier_dict


def test_update_release_classifiers(dbapp, release):
    dbapp.engine.execute(classifiers.insert().values(
        id=1,
        classifier="foo"
    ))
    dbapp.engine.execute(classifiers.insert().values(
        id=2,
        classifier="bar"
    ))
    dbapp.engine.execute(classifiers.insert().values(
        id=3,
        classifier="baz"
    ))

    dbapp.db.packaging.update_release_classifiers(
        release['project']['name'],
        release['version'],
        set(('foo',))
    )

    assert set(dbapp.db.packaging.get_classifiers(
        release['project']['name'],
        release['version'])
    ) == set(('foo',))

    dbapp.db.packaging.update_release_classifiers(
        release['project']['name'],
        release['version'],
        set(('bar', 'baz'))
    )

    assert set(dbapp.db.packaging.get_classifiers(
        release['project']['name'],
        release['version'])
    ) == set(('bar', 'baz'))


def test_update_external_urls(dbapp, release):
    example_urls = ('http://example.com', 'http://example.com/test')
    dbapp.db.packaging.update_release_external_urls(
        release['project']['name'],
        release['version'],
        example_urls
    )

    assert set(dbapp.db.packaging.get_release_external_urls(
        release['project']['name'],
        release['version'])
    ) == set(example_urls)

########NEW FILE########
__FILENAME__ = test_helpers
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest

from warehouse.packaging.helpers import package_type_display


@pytest.mark.parametrize(("package_type", "display"), [
    ("sdist", "Source"),
    ("bdist_dumb", "\"dumb\" binary"),
    ("bdist_rpm", "RPM"),
    ("bdist_wininst", "Windows Installer"),
    ("bdist_msi", "Windows MSI Installer"),
    ("bdist_egg", "Egg"),
    ("bdist_dmg", "OSX Disk Image"),
    ("bdist_wheel", "Wheel"),
    ("unknown", "unknown"),
])
def test_package_type_display(package_type, display):
    assert package_type_display(package_type) == display

########NEW FILE########
__FILENAME__ = test_search
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pretend
import pytest

from warehouse.packaging.search import ProjectMapping


def test_get_mapping():
    pmap = ProjectMapping(index=pretend.stub())
    assert pmap.get_mapping() == {
        "properties": {
            "name": {"type": "string"},
            "name_keyword": {"type": "string", "index": "not_analyzed"},
            "version": {"type": "string"},
            "author": {"type": "string"},
            "author_email": {"type": "string"},
            "maintainer": {"type": "string"},
            "maintainer_email": {"type": "string"},
            "home_page": {"type": "string"},
            "license": {"type": "string"},
            "summary": {"type": "string"},
            "description": {"type": "string"},
            "keywords": {"type": "string"},
            "platform": {"type": "string"},
            "download_url": {"type": "string"},
            "created": {"type": "string"},
        },
    }


def test_get_indexable():
    index = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_full_latest_releases=pretend.call_recorder(lambda: []),
            ),
        ),
    )
    pmap = ProjectMapping(index=index)
    pmap.get_indexable()

    assert index.db.packaging.get_full_latest_releases.calls == [
        pretend.call(),
    ]


def test_extract_id():
    pmap = ProjectMapping(index=pretend.stub())
    assert pmap.extract_id({"name": "test name"}) == "test name"


def test_extract_document():
    pmap = ProjectMapping(index=pretend.stub())
    document = pmap.extract_document({"name": "Test Name"})

    assert document == {"name": "Test Name", "name_keyword": "test name"}


@pytest.mark.parametrize(("query", "body"), [
    (None, {"query": {"match_all": {}}, "from": 0, "size": 25}),
    (
        "Django",
        {
            "query": {
                "bool": {
                    "should": [
                        {"term": {"name_keyword": {"value": "django"}}},
                        {
                            "match": {
                                "name": {"query": "django", "boost": 2.0},
                            },
                        },
                        {
                            "match": {
                                "summary": {"query": "django", "boost": 1.5},
                            },
                        },
                        {"match": {"description": {"query": "django"}}},
                    ],
                }
            },
            "from": 0,
            "size": 25,
        },
    ),
])
def test_search(query, body):
    index = pretend.stub(
        _index="warehouse",
        es=pretend.stub(
            search=pretend.call_recorder(lambda **kw: []),
        ),
    )
    pmap = ProjectMapping(index=index)
    pmap.search(query)

    assert index.es.search.calls == [
        pretend.call(index="warehouse", doc_type="project", body=body),
    ]

########NEW FILE########
__FILENAME__ = test_views
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import textwrap

import jinja2
import pretend
import pytest

from werkzeug.exceptions import NotFound

from warehouse.packaging.views import project_detail


def test_project_detail_missing_project():
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_project=pretend.call_recorder(lambda proj: None),
            ),
        ),
    )
    request = pretend.stub()

    project_name = "test-project"

    with pytest.raises(NotFound):
        project_detail(app, request, project_name)

    assert app.db.packaging.get_project.calls == [
        pretend.call("test-project"),
    ]


def test_project_detail_no_versions():
    app = pretend.stub(
        db=pretend.stub(
            packaging=pretend.stub(
                get_project=pretend.call_recorder(
                    lambda proj: {"name": "test-project"},
                ),
                get_releases=pretend.call_recorder(lambda proj: []),
            ),
        ),
    )
    request = pretend.stub()

    project_name = "test-project"

    with pytest.raises(NotFound):
        project_detail(app, request, project_name)

    assert app.db.packaging.get_project.calls == [
        pretend.call("test-project"),
    ]
    assert app.db.packaging.get_releases.calls == [
        pretend.call("test-project"),
    ]


def test_project_detail_redirects():
    app = pretend.stub(
        config=pretend.stub(
            cache=pretend.stub(
                browser=False,
                varnish=False,
            ),
        ),
        db=pretend.stub(
            packaging=pretend.stub(
                get_project=pretend.call_recorder(
                    lambda proj: {"name": "test-project"},
                ),
                get_releases=pretend.call_recorder(
                    lambda proj: [{"version": "1.0"}],
                ),
            ),
        ),
    )
    request = pretend.stub(
        url_adapter=pretend.stub(
            build=pretend.call_recorder(
                lambda *a, **kw: "/projects/test-project/",
            ),
        ),
    )

    project_name = "test-Project"
    normalized = "test-project"

    resp = project_detail(app, request, project_name=project_name)

    assert resp.status_code == 301
    assert resp.headers["Location"] == "/projects/test-project/"

    assert resp.headers["Surrogate-Key"] == \
        "project project/{}".format(normalized)

    assert app.db.packaging.get_project.calls == [
        pretend.call("test-Project"),
    ]
    assert app.db.packaging.get_releases.calls == [
        pretend.call("test-project"),
    ]
    assert request.url_adapter.build.calls == [
        pretend.call(
            "warehouse.packaging.views.project_detail",
            {"project_name": "test-project", "version": None},
            force_external=False,
        ),
    ]


def test_project_detail_invalid_version():
    app = pretend.stub(
        config=pretend.stub(
            cache=pretend.stub(
                browser=False,
                varnish=False,
            ),
        ),
        db=pretend.stub(
            packaging=pretend.stub(
                get_project=pretend.call_recorder(
                    lambda proj: {"name": "test-project"},
                ),
                get_releases=pretend.call_recorder(
                    lambda proj: [{"version": "1.0"}],
                ),
            ),
        ),
    )
    request = pretend.stub()

    project_name = "test-project"

    with pytest.raises(NotFound):
        project_detail(app, request, project_name, "2.0")

    assert app.db.packaging.get_project.calls == [
        pretend.call("test-project"),
    ]
    assert app.db.packaging.get_releases.calls == [
        pretend.call("test-project"),
    ]


@pytest.mark.parametrize(("version", "description", "html", "camo"), [
    (
        None,
        textwrap.dedent("""
            Test Project
            ============

            This is a test project
        """),
        jinja2.Markup("<p>This is a test project</p>\n"),
        None,
    ),
    (
        "1.0",
        textwrap.dedent("""
            Test Project
            ============

            This is a test project
        """),
        jinja2.Markup("<p>This is a test project</p>\n"),
        None,
    ),
    (
        None,
        ".. code-fail::\n    wat",
        jinja2.Markup(".. code-fail::<br>    wat"),
        None,
    ),
    (
        "1.0",
        ".. code-fail::\n    wat",
        jinja2.Markup(".. code-fail::<br>    wat"),
        None,
    ),
    (None, None, jinja2.Markup(""), None),
    ("1.0", None, jinja2.Markup(""), None),
    (
        None,
        textwrap.dedent("""
            Test Project
            ============

            This is a test project
        """),
        jinja2.Markup("<p>This is a test project</p>\n"),
        pretend.stub(url="https://camo.example.com/", key="secret key"),
    ),
    (
        "1.0",
        textwrap.dedent("""
            Test Project
            ============

            This is a test project
        """),
        jinja2.Markup("<p>This is a test project</p>\n"),
        pretend.stub(url="https://camo.example.com/", key="secret key"),
    ),
    (
        None,
        ".. code-fail::\n    wat",
        jinja2.Markup(".. code-fail::<br>    wat"),
        pretend.stub(url="https://camo.example.com/", key="secret key"),
    ),
    (
        "1.0",
        ".. code-fail::\n    wat",
        jinja2.Markup(".. code-fail::<br>    wat"),
        pretend.stub(url="https://camo.example.com/", key="secret key"),
    ),
    (
        None,
        None,
        jinja2.Markup(""),
        pretend.stub(url="https://camo.example.com/", key="secret key"),
    ),
    (
        "1.0",
        None,
        jinja2.Markup(""),
        pretend.stub(url="https://camo.example.com/", key="secret key"),
    ),
])
def test_project_detail_valid(app, version, description, html, camo):
    release = {
        "description": description,
        "requires_dist": ["foo", "xyz > 0.1"]
    }

    app.config = pretend.stub(
        cache=pretend.stub(
            browser=False,
            varnish=False,
        ),
        camo=camo,
    )
    app.db = pretend.stub(
        packaging=pretend.stub(
            get_project=pretend.call_recorder(
                lambda proj: {"name": "test-project"},
            ),
            get_releases=pretend.call_recorder(
                lambda proj: [{"version": "2.0"}, {"version": "1.0"}],
            ),
            get_release=pretend.call_recorder(
                lambda proj, version: release,
            ),
            get_download_counts=pretend.call_recorder(
                lambda proj: {
                    "last_day": 1,
                    "last_week": 7,
                    "last_month": 30,
                },
            ),
            get_reverse_dependencies=pretend.call_recorder(
                lambda proj: [{'name': 'foo'}, {'name': 'bar'}]
            ),
            get_downloads=pretend.call_recorder(lambda proj, ver: []),
            get_classifiers=pretend.call_recorder(lambda proj, ver: []),
            get_documentation_url=pretend.call_recorder(
                lambda proj: None,
            ),
            get_bugtrack_url=pretend.call_recorder(lambda proj: None),
            get_users_for_project=pretend.call_recorder(lambda proj: []),
        ),
    )

    request = pretend.stub(
        url_adapter=pretend.stub(build=lambda *a,
                                 **kw: "/projects/test-project/")
    )

    project_name = "test-project"
    normalized = "test-project"

    resp = project_detail(
        app,
        request,
        project_name=project_name,
        version=version,
    )

    assert resp.status_code == 200
    assert resp.headers["Surrogate-Key"] == \
        "project project/{}".format(normalized)
    assert resp.response.context == {
        "bugtracker": None,
        "classifiers": [],
        "description_html": html,
        "documentation": None,
        "download_counts": {
            "last_day": 1,
            "last_week": 7,
            "last_month": 30,
        },
        "downloads": [],
        "maintainers": [],
        "project": "test-project",
        "release": release,
        "releases": [{"version": "2.0"}, {"version": "1.0"}],
        "reverse_dependencies": [
            {'name': 'foo', 'url': '/projects/test-project/'},
            {'name': 'bar', 'url': '/projects/test-project/'}
        ],
        "requirements": [
            {
                "project_name": "foo",
                "other": "",
                "project_url": "/projects/test-project/",
            },
            {
                "project_name": "xyz",
                "other": "> 0.1",
                "project_url": "/projects/test-project/",
            },
        ],
    }

    assert app.db.packaging.get_project.calls == [
        pretend.call("test-project"),
    ]
    assert app.db.packaging.get_releases.calls == [
        pretend.call("test-project"),
    ]
    assert app.db.packaging.get_users_for_project.calls == [
        pretend.call("test-project"),
    ]
    assert app.db.packaging.get_reverse_dependencies.calls == [
        pretend.call("test-project %"),
    ]

########NEW FILE########
__FILENAME__ = test_cli
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pretend

from warehouse.search.cli import ReindexCommand


def test_reindex_command():
    app = pretend.stub(
        search=pretend.stub(
            reindex=pretend.call_recorder(lambda: None),
        ),
    )

    cmd = ReindexCommand()
    cmd(app=app)

    assert app.search.reindex.calls == [pretend.call()]

########NEW FILE########
__FILENAME__ = test_indexes
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os

import pretend
import pytest

from elasticsearch import TransportError

from warehouse.search import indexes
from warehouse.search.indexes import Index, BaseMapping


class TestIndex:

    def test_reindex(self, monkeypatch):
        urandom = pretend.call_recorder(lambda s: b"0" * s)
        monkeypatch.setattr(os, "urandom", urandom)

        models = pretend.stub()
        config = pretend.stub(index="warehouse", hosts=[], get=lambda *a: {})

        index = Index(models, config)
        index.es = pretend.stub(
            indices=pretend.stub(
                create=pretend.call_recorder(lambda idx, body: None),
            ),
        )
        index.types = {
            "fake": pretend.stub(
                _type="fake",
                get_mapping=pretend.call_recorder(lambda: {"foo": "bar"}),
                index_all=pretend.call_recorder(lambda index: None),
            ),
        }
        index.update_alias = pretend.call_recorder(lambda *a, **kw: None)

        index.reindex()

        assert index.es.indices.create.calls == [
            pretend.call(
                "warehouse30303030",
                {"mappings": {"fake": {"foo": "bar"}}},
            ),
        ]
        assert index.update_alias.calls == [
            pretend.call("warehouse", "warehouse30303030", keep_old=False),
        ]
        assert index.types["fake"].index_all.calls == [
            pretend.call(index="warehouse30303030"),
        ]

    def test_reindex_no_alias(self, monkeypatch):
        urandom = pretend.call_recorder(lambda s: b"0" * s)
        monkeypatch.setattr(os, "urandom", urandom)

        models = pretend.stub()
        config = pretend.stub(index="warehouse", hosts=[], get=lambda *a: {})

        index = Index(models, config)
        index.es = pretend.stub(
            indices=pretend.stub(
                create=pretend.call_recorder(lambda idx, body: None),
            ),
        )
        index.types = {
            "fake": pretend.stub(
                _type="fake",
                get_mapping=pretend.call_recorder(lambda: {"foo": "bar"}),
                index_all=pretend.call_recorder(lambda index: None),
            ),
        }
        index.update_alias = pretend.call_recorder(lambda *a, **kw: None)

        index.reindex(alias=False)

        assert index.es.indices.create.calls == [
            pretend.call(
                "warehouse30303030",
                {"mappings": {"fake": {"foo": "bar"}}},
            ),
        ]
        assert index.update_alias.calls == []
        assert index.types["fake"].index_all.calls == [
            pretend.call(index="warehouse30303030"),
        ]

    def test_update_alias(self):
        models = pretend.stub()
        config = pretend.stub(index="warehouse", hosts=[], get=lambda *a: {})

        index = Index(models, config)
        index.es = pretend.stub(
            indices=pretend.stub(
                get_alias=pretend.call_recorder(
                    lambda idx: {"warehouse1234567": "warehouse"},
                ),
                update_aliases=pretend.call_recorder(lambda actions: None),
                delete=pretend.call_recorder(lambda idx: None)
            ),
        )

        index.update_alias("warehouse", "warehouse7654321")

        assert index.es.indices.get_alias.calls == [pretend.call("warehouse")]
        assert index.es.indices.update_aliases.calls == [
            pretend.call({"actions": [
                {
                    "remove": {
                        "index": "warehouse1234567",
                        "alias": "warehouse",
                    },
                },
                {"add": {"index": "warehouse7654321", "alias": "warehouse"}}
            ]}),
        ]
        assert index.es.indices.delete.calls == [
            pretend.call("warehouse1234567"),
        ]

    def test_update_alias_no_old_index(self):
        models = pretend.stub()
        config = pretend.stub(index="warehouse", hosts=[], get=lambda *a: {})

        def _get_alias(idx):
            raise TransportError(404, "Fake 404")

        index = Index(models, config)
        index.es = pretend.stub(
            indices=pretend.stub(
                get_alias=pretend.call_recorder(_get_alias),
                update_aliases=pretend.call_recorder(lambda actions: None),
                delete=pretend.call_recorder(lambda idx: None)
            ),
        )

        index.update_alias("warehouse", "warehouse7654321")

        assert index.es.indices.get_alias.calls == [pretend.call("warehouse")]
        assert index.es.indices.update_aliases.calls == [
            pretend.call({"actions": [
                {"add": {"index": "warehouse7654321", "alias": "warehouse"}}
            ]}),
        ]
        assert index.es.indices.delete.calls == []

    def test_update_alias_exception(self):
        models = pretend.stub()
        config = pretend.stub(index="warehouse", hosts=[], get=lambda *a: {})

        def _get_alias(idx):
            raise TransportError(500, "Fake 500")

        index = Index(models, config)
        index.es = pretend.stub(
            indices=pretend.stub(
                get_alias=pretend.call_recorder(_get_alias),
            ),
        )

        with pytest.raises(TransportError):
            index.update_alias("warehouse", "warehouse7654321")

        assert index.es.indices.get_alias.calls == [pretend.call("warehouse")]


class TestBaseMapping:

    def test_get_mapping(self):
        bmap = BaseMapping(index=pretend.stub())

        with pytest.raises(NotImplementedError):
            bmap.get_mapping()

    def test_get_indexable(self):
        bmap = BaseMapping(index=pretend.stub())

        with pytest.raises(NotImplementedError):
            bmap.get_indexable()

    def test_extract_id(self):
        bmap = BaseMapping(index=pretend.stub())

        with pytest.raises(NotImplementedError):
            bmap.extract_id(None)

    def test_extract_document(self):
        bmap = BaseMapping(index=pretend.stub())

        with pytest.raises(NotImplementedError):
            bmap.extract_document(None)

    def test_search(self):
        bmap = BaseMapping(index=pretend.stub())

        with pytest.raises(NotImplementedError):
            bmap.search(None)

    def test_index_all(self, monkeypatch):
        bulk_index = pretend.call_recorder(lambda es, docs: None)
        monkeypatch.setattr(indexes, "bulk_index", bulk_index)

        index = pretend.stub(
            _index="warehouse",
            es=pretend.stub(),
        )

        bmap = BaseMapping(index=index)
        bmap.get_indexable = pretend.call_recorder(lambda: [])
        bmap.index_all()

        assert bulk_index.calls == [pretend.call(index.es, [])]
        assert bmap.get_indexable.calls == [pretend.call()]

########NEW FILE########
__FILENAME__ = test_views
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from unittest import mock

from werkzeug.exceptions import NotFound
import pretend
import pytest

from warehouse.search.views import search


def test_search_invalid_doctype():
    app = pretend.stub(search=pretend.stub(types={}))

    with pytest.raises(NotFound):
        search(app, pretend.stub(), "fake")


def test_search_page_invalid_page():
    app = pretend.stub(
        search=pretend.stub(types={"fake": pretend.stub(SEARCH_LIMIT=25)}),
    )
    request = pretend.stub(args={"q": "Django", "page": "abc"})

    with pytest.raises(NotFound):
        search(app, request, "fake")


def test_search(app):
    app.search = pretend.stub(
        types={
            "fake": pretend.stub(
                SEARCH_LIMIT=25,
                search=pretend.call_recorder(
                    lambda q, l, o: {"hits": {"hits": []}},
                ),
            ),
        },
    )

    request = pretend.stub(args={"q": "Django"})

    resp = search(app, request, "fake")

    assert resp.response.template.name == "search/results.html"
    assert resp.response.context == {
        "query": "Django",
        "total": 0,
        "pages": mock.ANY,
        "results": [],
    }

    assert app.search.types["fake"].search.calls == [
        pretend.call("Django", 25, 0),
    ]


def test_search_page_less_than_zero(app):
    app.search = pretend.stub(
        types={
            "fake": pretend.stub(
                SEARCH_LIMIT=25,
                search=pretend.call_recorder(
                    lambda q, l, o: {"hits": {"hits": []}},
                ),
            ),
        },
    )

    request = pretend.stub(args={"q": "Django", "page": "-1"})

    resp = search(app, request, "fake")

    assert resp.response.template.name == "search/results.html"
    assert resp.response.context == {
        "query": "Django",
        "total": 0,
        "pages": mock.ANY,
        "results": [],
    }
    assert app.search.types["fake"].search.calls == [
        pretend.call("Django", 25, 0),
    ]

########NEW FILE########
__FILENAME__ = test_application
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from unittest import mock
import os.path

import guard
import importlib
import pretend
import pytest

from werkzeug.exceptions import HTTPException
from werkzeug.test import create_environ

import warehouse

from warehouse import application, cli
from warehouse.application import Warehouse


def test_basic_instantiation():
    Warehouse({
        "debug": False,
        "site": {
            "access_token": "testing",
        },
        "database": {
            "url": "postgres:///test_warehouse",
        },
        "redis": {
            "downloads": "redis://localhost:6379/0",
            "sessions": "redis://localhost:6379/0",
        },
        "search": {
            "index": "warehouse",
            "hosts": [],
        },
        "camo": None,
        "logging": {
            "version": 1,
        },
    })


def test_yaml_instantiation():
    Warehouse.from_yaml(
        os.path.abspath(os.path.join(
            os.path.dirname(__file__),
            "test_config.yml",
        )),
    )


def test_cli_instantiation(capsys):
    with pytest.raises(SystemExit):
        Warehouse.from_cli(["-h"])

    out, err = capsys.readouterr()

    assert "usage: warehouse" in out
    assert not err


def test_running_cli_command(monkeypatch):
    commands = {"serve": pretend.call_recorder(lambda *a, **k: None)}
    monkeypatch.setattr(cli, "__commands__", commands)

    config = os.path.abspath(os.path.join(
        os.path.dirname(__file__),
        "test_config.yml",
    ))

    Warehouse.from_cli(["-c", config, "serve"])

    assert commands["serve"].calls == [pretend.call(mock.ANY)]


def test_calling_application_is_wsgi_app(app):
    app.wsgi_app = pretend.call_recorder(lambda e, s: None)

    environ, start_response = pretend.stub(), pretend.stub()
    app(environ, start_response)

    assert app.wsgi_app.calls == [pretend.call(environ, start_response)]


def test_wsgi_app(app, monkeypatch):
    match = pretend.stub(
        match=pretend.call_recorder(lambda: ("warehouse.fake.view", {}))
    )
    urls = pretend.stub(bind_to_environ=pretend.call_recorder(lambda e: match))
    response = pretend.call_recorder(lambda e, s: None)
    fake_view = pretend.call_recorder(lambda *a, **k: response)
    fake_module = pretend.stub(view=fake_view)
    import_module = pretend.call_recorder(lambda mod: fake_module)

    monkeypatch.setattr(importlib, "import_module", import_module)

    environ = create_environ()
    start_response = pretend.stub(__name__=str("start_response"))

    app.urls = urls
    app.dispatch_view = pretend.call_recorder(app.dispatch_view)
    app.wsgi_app(environ, start_response)

    assert match.match.calls == [pretend.call()]
    assert urls.bind_to_environ.calls == [pretend.call(environ)]
    assert import_module.calls == [pretend.call("warehouse.fake")]
    assert fake_view.calls == [pretend.call(app, mock.ANY)]
    assert response.calls == [pretend.call(environ, mock.ANY)]
    assert app.dispatch_view.calls == [pretend.call(fake_view, app, mock.ANY)]


def test_wsgi_app_exception(app, monkeypatch):
    match = pretend.stub(
        match=pretend.call_recorder(lambda: ("warehouse.fake.view", {}))
    )
    urls = pretend.stub(bind_to_environ=pretend.call_recorder(lambda e: match))
    response = pretend.call_recorder(lambda e, s: None)

    class FakeException(HTTPException):

        def __call__(self, *args, **kwargs):
            return response

    @pretend.call_recorder
    def fake_view(*args, **kwargs):
        raise FakeException("An error has occurred")

    fake_module = pretend.stub(view=fake_view)
    import_module = pretend.call_recorder(lambda mod: fake_module)

    monkeypatch.setattr(importlib, "import_module", import_module)

    environ = create_environ()
    start_response = pretend.stub(__name__=str("start_response"))

    app.urls = urls

    app.wsgi_app(environ, start_response)

    assert match.match.calls == [pretend.call()]
    assert urls.bind_to_environ.calls == [pretend.call(environ)]
    assert import_module.calls == [pretend.call("warehouse.fake")]
    assert fake_view.calls == [pretend.call(app, mock.ANY)]


def test_static_middleware(monkeypatch):
    WhiteNoise = pretend.call_recorder(lambda app, root, prefix, max_age: app)

    monkeypatch.setattr(
        application,
        "WhiteNoise",
        WhiteNoise,
    )

    Warehouse.from_yaml(
        os.path.abspath(os.path.join(
            os.path.dirname(__file__),
            "test_config.yml",
        )),
    )

    assert WhiteNoise.calls == [
        pretend.call(
            mock.ANY,
            root=os.path.abspath(
                os.path.join(
                    os.path.dirname(warehouse.__file__),
                    "static",
                    "compiled",
                ),
            ),
            prefix="/static/",
            max_age=31557600,
        )
    ]


def test_sentry_middleware(monkeypatch):
    Sentry = pretend.call_recorder(lambda app, client: app)
    client_obj = pretend.stub()
    Client = pretend.call_recorder(lambda **kw: client_obj)

    monkeypatch.setattr(application, "Sentry", Sentry)
    monkeypatch.setattr(application, "Client", Client)

    Warehouse.from_yaml(
        os.path.abspath(os.path.join(
            os.path.dirname(__file__),
            "test_config.yml",
        )),
        override={"sentry": {"dsn": "http://public:secret@example.com/1"}}
    )

    assert Sentry.calls == [pretend.call(mock.ANY, client_obj)]
    assert Client.calls == [
        pretend.call(dsn="http://public:secret@example.com/1"),
    ]


def test_guard_middleware(monkeypatch):
    ContentSecurityPolicy = pretend.call_recorder(lambda app, policy: app)

    monkeypatch.setattr(guard, "ContentSecurityPolicy", ContentSecurityPolicy)

    Warehouse.from_yaml(
        os.path.abspath(os.path.join(
            os.path.dirname(__file__),
            "test_config.yml",
        )),
    )

    assert ContentSecurityPolicy.calls == [pretend.call(mock.ANY, mock.ANY)]


def test_camo_settings(monkeypatch):
    ContentSecurityPolicy = pretend.call_recorder(lambda app, policy: app)

    monkeypatch.setattr(guard, "ContentSecurityPolicy", ContentSecurityPolicy)

    Warehouse.from_yaml(
        os.path.abspath(os.path.join(
            os.path.dirname(__file__),
            "test_config.yml",
        )),
        override={"camo": {"url": "https://camo.example.com/", "key": "skey"}},
    )

    assert ContentSecurityPolicy.calls == [pretend.call(mock.ANY, mock.ANY)]
    assert set(ContentSecurityPolicy.calls[0].args[1]["img-src"]) == {
        "'self'",
        "https://camo.example.com",
        "https://secure.gravatar.com",
    }


def test_header_rewrite_middleware(monkeypatch):
    HeaderRewriterFix = pretend.call_recorder(lambda app, **kw: app)

    monkeypatch.setattr(application, "HeaderRewriterFix", HeaderRewriterFix)

    Warehouse.from_yaml(
        os.path.abspath(os.path.join(
            os.path.dirname(__file__),
            "test_config.yml",
        )),
    )

    assert HeaderRewriterFix.calls == [
        pretend.call(
            mock.ANY,
            add_headers=[
                (
                    "X-Powered-By",
                    "Warehouse {__version__} ({__build__})".format(
                        __version__=warehouse.__version__,
                        __build__=warehouse.__build__,
                    ),
                ),
            ],
        ),
    ]


def test_passlib_context():
    app = Warehouse.from_yaml(
        os.path.abspath(os.path.join(
            os.path.dirname(__file__),
            "test_config.yml",
        )),
    )

    assert app.passlib.to_dict() == {
        "schemes": [
            "bcrypt_sha256",
            "bcrypt",
            "django_bcrypt",
            "unix_disabled",
        ],
        "default": "bcrypt_sha256",
        "deprecated": ["auto"],
    }


def test_app_has_session(app):
    assert app.dispatch_view._sessions_handled


def test_app_has_csrf(app):
    assert app.dispatch_view._csrf_handled

########NEW FILE########
__FILENAME__ = test_cli
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pretend

import werkzeug.serving

from warehouse.cli import ServeCommand
from warehouse.serving import WSGIRequestHandler


def test_serve(monkeypatch, tmpdir):
    run_simple = pretend.call_recorder(
        lambda *a, **kw: None,
    )
    monkeypatch.setattr(werkzeug.serving, "run_simple", run_simple)

    with open(str(tmpdir.join("foo.txt")), "w") as fp:
        fp.write("text file")

    app = pretend.stub(static_dir=str(tmpdir))
    host, port, use_reloader, use_debugger = (pretend.stub() for x in range(4))

    ServeCommand()(
        app, host, port,
        reloader=use_reloader,
        debugger=use_debugger,
    )

    assert run_simple.calls == [
        pretend.call(
            host, port, app,
            use_reloader=use_reloader,
            use_debugger=use_debugger,
            request_handler=WSGIRequestHandler,
            extra_files=[str(tmpdir.join("foo.txt"))],
        ),
    ]

########NEW FILE########
__FILENAME__ = test_csrf
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import pretend
import pytest

from werkzeug.exceptions import SecurityError

from warehouse.csrf import (
    _verify_csrf_origin, _verify_csrf_token, _ensure_csrf_token, csrf_protect,
    csrf_exempt, csrf_cycle, handle_csrf,
)
from warehouse.http import Response


class TestHandleCSRF:

    def test_csrf_ensured(self):
        def fn(self, view, app, request, *args, **kwargs):
            return view(app, request, *args, **kwargs)

        view = lambda app, request: Response()
        view._csrf = True
        app = pretend.stub()
        request = pretend.stub(_session={}, method="GET")

        handle_csrf(fn)(pretend.stub(), view, app, request)

        assert "user.csrf" in request._session

    def test_csrf_already_ensured(self):
        def fn(self, view, app, request, *args, **kwargs):
            return view(app, request, *args, **kwargs)

        view = lambda app, request: Response()
        view._csrf = True
        app = pretend.stub()
        request = pretend.stub(_session={"user.csrf": "1234"}, method="GET")

        handle_csrf(fn)(pretend.stub(), view, app, request)

        assert request._session == {"user.csrf": "1234"}

    @pytest.mark.parametrize("method", ["GET", "HEAD", "OPTIONS", "TRACE"])
    def test_csrf_allows_safe(self, method):
        def fn(self, view, app, request, *args, **kwargs):
            return view(app, request, *args, **kwargs)

        view = lambda app, request: Response()
        app = pretend.stub()
        request = pretend.stub(_session={}, method=method)

        handle_csrf(fn)(pretend.stub(), view, app, request)

    @pytest.mark.parametrize("method", ["POST", "PUT", "DELETE"])
    def test_csrf_disallows_unsafe(self, method):
        def fn(self, view, app, request, *args, **kwargs):
            return view(app, request, *args, **kwargs)

        view = lambda app, request: Response()
        app = pretend.stub()
        request = pretend.stub(_session={}, method=method)

        with pytest.raises(SecurityError) as excinfo:
            handle_csrf(fn)(pretend.stub(), view, app, request)

        assert (excinfo.value.description
                == "No CSRF protection applied to view")

    @pytest.mark.parametrize("method", ["POST", "PUT", "DELETE"])
    def test_csrf_checks_csrf_unsafe(self, method):
        def fn(self, view, app, request, *args, **kwargs):
            return view(app, request, *args, **kwargs)

        view = lambda app, request: Response()
        view._csrf = True
        app = pretend.stub()
        request = pretend.stub(_session={}, method=method)

        _verify_origin = pretend.call_recorder(lambda request: None)
        _verify_token = pretend.call_recorder(lambda request: None)

        handle_csrf(
            fn,
            _verify_origin=_verify_origin,
            _verify_token=_verify_token,
        )(pretend.stub(), view, app, request)

        assert _verify_token.calls == [pretend.call(request)]
        assert _verify_token.calls == [pretend.call(request)]

    @pytest.mark.parametrize("method", ["POST", "PUT", "DELETE"])
    def test_csrf_exempts_csrf_unsafe(self, method):
        def fn(self, view, app, request, *args, **kwargs):
            return view(app, request, *args, **kwargs)

        view = lambda app, request: Response()
        view._csrf = False
        app = pretend.stub()
        request = pretend.stub(_session={}, method=method)

        _verify_origin = pretend.call_recorder(lambda request: None)
        _verify_token = pretend.call_recorder(lambda request: None)

        handle_csrf(
            fn,
            _verify_origin=_verify_origin,
            _verify_token=_verify_token,
        )(pretend.stub(), view, app, request)

        assert _verify_token.calls == []
        assert _verify_token.calls == []


@pytest.mark.parametrize(("headers", "host_url", "valid", "error_msg"), [
    ({}, None, False, "Origin checking failed - no Origin or Referer."),
    (
        {"Origin": "null"},
        "https://example.com/",
        False,
        "Origin checking failed - null does not match https://example.com.",
    ),
    (
        {"Origin": "https://attacker.com"},
        "https://example.com/",
        False,
        "Origin checking failed - https://attacker.com does not match "
        "https://example.com.",
    ),
    (
        {"Referer": "https://attacker.com/wat/"},
        "https://example.com/",
        False,
        "Origin checking failed - https://attacker.com does not match "
        "https://example.com.",
    ),
    (
        {"Origin": "http://example.com"},
        "https://example.com/",
        False,
        "Origin checking failed - http://example.com does not match "
        "https://example.com.",
    ),
    (
        {"Referer": "http://example.com/wat/"},
        "https://example.com/",
        False,
        "Origin checking failed - http://example.com does not match "
        "https://example.com.",
    ),
    (
        {"Origin": "https://example.com:9000"},
        "https://example.com/",
        False,
        "Origin checking failed - https://example.com:9000 does not match "
        "https://example.com.",
    ),
    (
        {"Referer": "https://example.com:9000/wat/"},
        "https://example.com/",
        False,
        "Origin checking failed - https://example.com:9000 does not match "
        "https://example.com.",
    ),
    ({"Origin": "https://example.com"}, "https://example.com/", True, None),
    (
        {"Referer": "https://example.com/wat/"},
        "https://example.com/",
        True,
        None,
    ),
    (
        {
            "Origin": "https://example.com",
            "Referer": "https://attacker.com/wat/",
        },
        "https://example.com/",
        True,
        None,
    ),
])
def test_verify_csrf_origin(headers, host_url, valid, error_msg):
    request = pretend.stub(headers=headers, host_url=host_url)

    if valid:
        _verify_csrf_origin(request)
    else:
        with pytest.raises(SecurityError) as excinfo:
            _verify_csrf_origin(request)

        assert excinfo.value.description == error_msg


@pytest.mark.parametrize(
    ("token", "form", "headers", "valid", "error_msg"),
    [
        (None, {}, {}, False, "CSRF token not set."),
        ("1234", {}, {}, False, "CSRF token missing."),
        ("1234", {"csrf_token": "abcd"}, {}, False, "CSRF token incorrect."),
        ("1234", {}, {"X-CSRF-Token": "abcd"}, False, "CSRF token incorrect."),
        ("1234", {"csrf_token": "1234"}, {}, True, None),
        ("1234", {}, {"X-CSRF-Token": "1234"}, True, None),
    ],
)
def test_verify_csrf_token(token, form, headers, valid, error_msg):
    request = pretend.stub(
        _session={"user.csrf": token},
        form=form,
        headers=headers,
        method="POST",
    )

    if valid:
        _verify_csrf_token(request)
    else:
        with pytest.raises(SecurityError) as excinfo:
            _verify_csrf_token(request)

        assert excinfo.value.description == error_msg


@pytest.mark.parametrize("token", ["1234", None])
def test_ensure_csrf_token(token):
    request = pretend.stub(_session={"user.csrf": token})
    _ensure_csrf_token(request)

    if token:
        assert request._session["user.csrf"] == token
    else:
        assert request._session["user.csrf"]

    assert request._csrf


def test_csrf_protect():
    view = lambda app, request: Response()
    view = csrf_protect(view)

    assert view._csrf
    assert "cookie" in view(pretend.stub(), pretend.stub()).vary.as_set()


def test_csrf_exempt():
    view = lambda app, request: Response()
    view = csrf_exempt(view)

    assert not view._csrf


def test_csrf_cycle():
    session = {"user.csrf": "12345"}
    csrf_cycle(session)

    assert session["user.csrf"] != "12345"

########NEW FILE########
__FILENAME__ = test_datastructures
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import pytest

from warehouse.datastructures import AttributeDict


def test_basic_attribute_dict_access():
    adict = AttributeDict({
        "foo": None,
        "bar": "Success!"
    })

    assert adict.foo is adict["foo"]
    assert adict.bar is adict["bar"]


def test_attribute_dict_unknown_access():
    adict = AttributeDict()

    with pytest.raises(AttributeError):
        adict.unknown


def test_convert_to_attribute_dict():
    adict = AttributeDict({"a": {"b": 1, "c": 2}})

    assert adict.a == {"b": 1, "c": 2}
    assert adict.a.b == 1
    assert adict.a.c == 2

########NEW FILE########
__FILENAME__ = test_db
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pretend
import pytest

from warehouse import db


def test_database_basic():
    app, metadata, engine, redis = object(), object(), object(), object()
    m = db.Database(app, metadata, engine, redis)

    assert m.app is app
    assert m.metadata is metadata
    assert m.engine is engine
    assert m.redis is redis


@pytest.mark.parametrize(
    ("value", "default", "expected", "eargs", "ekwargs"),
    [
        (1, None, 1, [], {}),
        (None, None, None, [], {}),
        (None, 10, 10, [], {}),
        (1, None, 1, ["a"], {}),
        (None, None, None, ["a"], {}),
        (None, 10, 10, ["a"], {}),
        (1, None, 1, [], {"a": "b"}),
        (None, None, None, [], {"a": "b"}),
        (None, 10, 10, [], {"a": "b"}),
    ],
)
def test_scalar(value, default, expected, eargs, ekwargs):
    result = pretend.stub(scalar=pretend.call_recorder(lambda: value))
    execute = pretend.call_recorder(lambda q, *a, **kw: result)
    model = pretend.stub(
        engine=pretend.stub(execute=execute)
    )

    sql = db.scalar("SELECT * FROM thing", default=default)

    assert sql(model, *eargs, **ekwargs) == expected
    assert execute.calls == [
        pretend.call("SELECT * FROM thing", *eargs, **ekwargs),
    ]
    assert result.scalar.calls == [pretend.call()]


@pytest.mark.parametrize(
    ("value", "default", "expected", "eargs", "ekwargs"), [
        (None, {'foo': 'bar'}, {'foo': 'bar'}, [], {}),
        ({'baz': 'bazbar'}, {'foo': 'bar'}, {'baz': 'bazbar'}, [], {})
    ]
)
def test_first(value, default, expected, eargs, ekwargs):
    result = pretend.stub(first=pretend.call_recorder(lambda: value))
    execute = pretend.call_recorder(lambda q, *a, **kw: result)
    model = pretend.stub(
        engine=pretend.stub(execute=execute)
    )

    sql = db.first("SELECT * FROM thing LIMIT 1", default=default)

    assert sql(model, *eargs, **ekwargs) == expected
    assert execute.calls == [
        pretend.call("SELECT * FROM thing LIMIT 1", *eargs, **ekwargs)
    ]


@pytest.mark.parametrize(
    ("row_func", "value", "expected", "eargs", "ekwargs"),
    [
        (None, [{"a": "b"}], [{"a": "b"}], [], {}),
        (lambda r: r["a"], [{"a": "b"}], ["b"], [], {}),
        (None, [{"a": "b"}], [{"a": "b"}], ["a"], {}),
        (lambda r: r["a"], [{"a": "b"}], ["b"], ["a"], {}),
        (None, [{"a": "b"}], [{"a": "b"}], [], {"a": "b"}),
        (lambda r: r["a"], [{"a": "b"}], ["b"], [], {"a": "b"}),
    ],
)
def test_rows(row_func, value, expected, eargs, ekwargs):
    execute = pretend.call_recorder(lambda q, *a, **kw: value)
    model = pretend.stub(
        engine=pretend.stub(execute=execute)
    )

    kwargs = {"row_func": row_func} if row_func else {}

    sql = db.rows("SELECT * FROM thing", **kwargs)

    assert sql(model, *eargs, **ekwargs) == expected
    assert execute.calls == [
        pretend.call("SELECT * FROM thing", *eargs, **ekwargs),
    ]


@pytest.mark.parametrize(
    ("key_func", "value_func", "value", "expected", "eargs", "ekwargs"),
    [
        (None, None, [("a", "b")], {"a": "b"}, [], {}),
        (
            lambda r: r["a"],
            lambda r: r["b"],
            [{"a": 1, "b": 2}],
            {1: 2},
            [],
            {},
        ),
        (None, None, [("a", "b")], {"a": "b"}, ["z"], {}),
        (
            lambda r: r["a"],
            lambda r: r["b"],
            [{"a": 1, "b": 2}],
            {1: 2},
            ["z"],
            {},
        ),
        (None, None, [("a", "b")], {"a": "b"}, [], {"z": "g"}),
        (
            lambda r: r["a"],
            lambda r: r["b"],
            [{"a": 1, "b": 2}],
            {1: 2},
            [],
            {"z": "g"},
        ),
    ],
)
def test_mapping(key_func, value_func, value, expected, eargs, ekwargs):
    execute = pretend.call_recorder(lambda q, *a, **kw: value)
    model = pretend.stub(
        engine=pretend.stub(execute=execute)
    )

    kwargs = {}
    if key_func:
        kwargs["key_func"] = key_func
    if value_func:
        kwargs["value_func"] = value_func

    sql = db.mapping("SELECT * FROM thing", **kwargs)

    assert sql(model, *eargs, **ekwargs) == expected
    assert execute.calls == [
        pretend.call("SELECT * FROM thing", *eargs, **ekwargs),
    ]


def test_validate_argument_column_mapping():
    table_stub = pretend.stub(
        columns=(
            pretend.stub(key="foo"),
            pretend.stub(key="bar"),
        ),
        name="foobartable"
    )
    with pytest.raises(TypeError):
        db.validate_argument_column_mapping("baz", table_stub)

########NEW FILE########
__FILENAME__ = test_fastly
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pretend

from warehouse.fastly import FastlyKey, FastlyFormatter


class TestFastlyKey:

    def test_format_keys(self):
        fastly_key = FastlyKey("foo", "foo/{bar}", "foo/{bar!n}")
        assert fastly_key.format_keys(bar="WaT") == [
            "foo",
            "foo/WaT",
            "foo/wat",
        ]

    def test_plain_decorator(self):
        fastly_key = FastlyKey("foo", "foo/{bar}", "foo/{bar!n}")

        @fastly_key
        def tester(app, request, bar=None):
            return pretend.stub(headers={})

        assert (
            tester(None, None, bar="WaT").headers["Surrogate-Key"]
            == "foo foo/WaT foo/wat"
        )

    def test_advanced_decorator(self):
        fastly_key = FastlyKey("foo", "foo/{bar}", "foo/{bar!n}")

        @fastly_key(not_bar="bar")
        def tester(app, request, not_bar=None):
            return pretend.stub(headers={})

        assert (
            tester(None, None, not_bar="WaT").headers["Surrogate-Key"]
            == "foo foo/WaT foo/wat"
        )


def test_fastly_formatter():
    assert FastlyFormatter().format("{0}", "Foo") == "Foo"
    assert FastlyFormatter().format("{0!n}", "Foo") == "foo"

########NEW FILE########
__FILENAME__ = test_forms
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import pretend

import babel.support

from warehouse.forms import Form


class TestForm:

    def test_get_translations(self):
        translations = pretend.stub()
        form = Form(translations=translations)
        assert form._get_translations() is translations

    def test_get_translations_none(self):
        assert isinstance(
            Form(translations=None)._get_translations(),
            babel.support.NullTranslations,
        )

    def test_gettext(self):
        translations = pretend.stub(gettext=pretend.call_recorder(lambda s: s))
        form = Form(translations=translations)

        assert form.gettext("What") == "What"
        assert translations.gettext.calls == [pretend.call("What")]

    def test_ngettext(self):
        translations = pretend.stub(
            ngettext=pretend.call_recorder(lambda s, p, n: s),
        )
        form = Form(translations=translations)

        assert form.ngettext("One Time", "Many Times", 1) == "One Time"
        assert translations.ngettext.calls == [
            pretend.call("One Time", "Many Times", 1),
        ]

########NEW FILE########
__FILENAME__ = test_helpers
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import fnmatch

import pretend
import pytest

from warehouse.application import Warehouse
from warehouse.helpers import gravatar_url, url_for, static_url, csrf_token


@pytest.mark.parametrize(("email", "kwargs", "expected"), [
    (
        "test-user@example.com",
        {},
        ("https://secure.gravatar.com/avatar/3664adb7d1eea0bd7d0b134577663889"
         "?size=80"),
    ),
    (
        "test-user@example.com",
        {"size": 1000},
        ("https://secure.gravatar.com/avatar/3664adb7d1eea0bd7d0b134577663889"
         "?size=1000"),
    ),
    (
        None,
        {},
        ("https://secure.gravatar.com/avatar/d41d8cd98f00b204e9800998ecf8427e"
         "?size=80"),
    ),
])
def test_gravatar_url(email, kwargs, expected):
    assert gravatar_url(email, **kwargs) == expected


@pytest.mark.parametrize(("external",), [(False,), (True,)])
def test_url_for(external):
    request = pretend.stub(
        url_adapter=pretend.stub(
            build=pretend.call_recorder(lambda *a, **k: "/foo/"),
        ),
    )

    assert url_for(
        request,
        "warehouse.test",
        foo="bar",
        _force_external=external,
    ) == "/foo/"

    assert request.url_adapter.build.calls == [
        pretend.call(
            "warehouse.test",
            {"foo": "bar"},
            force_external=external,
        ),
    ]


@pytest.mark.parametrize(("filename", "expected"), [
    ("css/warehouse.css", "/static/css/warehouse.*.css"),
    ("css/fake.css", "/static/css/fake.css"),
])
def test_static_url(filename, expected):
    app = pretend.stub(
        static_dir=Warehouse.static_dir,
        static_path=Warehouse.static_path,
    )

    assert fnmatch.fnmatch(static_url(app, filename), expected)


@pytest.mark.parametrize("request", [
    pretend.stub(),
    pretend.stub(_csrf=False),
])
def test_csrf_token_no_csrf(request):
    with pytest.raises(ValueError):
        csrf_token(request)


def test_csrf_token():
    assert (
        csrf_token(pretend.stub(_csrf=True, _session={"user.csrf": "123456"}))
        == "<input type=hidden name=csrf_token value=\"123456\">"
    )

########NEW FILE########
__FILENAME__ = test_http
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from warehouse.http import Response


def test_response_surrogate_control():
    resp = Response()

    assert "Surrogate-Control" not in resp.headers

    resp.surrogate_control.public = True
    resp.surrogate_control.max_age = 120

    assert set(resp.headers["Surrogate-Control"].split(", ")) == {
        "max-age=120",
        "public",
    }


def test_response_surrogate_control_remove():
    resp = Response(headers={"Surrogate-Control": "max-age=120"})

    assert resp.headers["Surrogate-Control"] == "max-age=120"

    resp.surrogate_control.max_age = None

    assert "Surrogate-Control" not in resp.headers

########NEW FILE########
__FILENAME__ = test_middlewares
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pretend

from warehouse.middlewares import XForwardedTokenMiddleware


def test_xforwardedtokenmiddleware_valid():
    response = pretend.stub()
    start_response = pretend.stub()
    app = pretend.call_recorder(lambda environ, start_response: response)

    middleware = XForwardedTokenMiddleware(app, "1234")
    resp = middleware(
        {
            "HTTP_X_WAREHOUSE_ACCESS_TOKEN": "1234",
            "HTTP_X_FORWARDED_FOR": "192.168.1.1",
        },
        start_response,
    )

    assert resp is response
    assert app.calls == [
        pretend.call(
            {"HTTP_X_FORWARDED_FOR": "192.168.1.1"},
            start_response,
        ),
    ]


def test_xforwardedtokenmiddleware_invalid():
    response = pretend.stub()
    start_response = pretend.stub()
    app = pretend.call_recorder(lambda environ, start_response: response)

    middleware = XForwardedTokenMiddleware(app, "1234")
    resp = middleware(
        {
            "HTTP_X_WAREHOUSE_ACCESS_TOKEN": "invalid",
            "HTTP_X_FORWARDED_FOR": "192.168.1.1",
        },
        start_response,
    )

    assert resp is response
    assert app.calls == [pretend.call({}, start_response)]

########NEW FILE########
__FILENAME__ = test_serving
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pretend

from warehouse import serving
from warehouse.serving import WSGIRequestHandler


def test_request_handler_log(monkeypatch):
    _log = pretend.call_recorder(lambda *a, **kw: None)

    monkeypatch.setattr(serving, "_log", _log)
    monkeypatch.setattr(WSGIRequestHandler, "__init__", lambda *a, **kw: None)

    handler = WSGIRequestHandler()
    handler.address_string = pretend.call_recorder(lambda: "127.0.0.1")

    handler.log("info", "test message")

    assert _log.calls == [pretend.call("info", "127.0.0.1 - test message\n")]
    assert handler.address_string.calls == [pretend.call()]

########NEW FILE########
__FILENAME__ = test_sessions
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from warehouse.http import Response
from warehouse.sessions import (
    RedisSessionStore, Session, handle_session, uses_session,
)

import pretend
import pytest


class TestRedisSessionStore:

    def test_redis_key(self):
        store = RedisSessionStore(pretend.stub())
        assert store._redis_key("123456") == "warehouse/session/data/123456"

    def test_generate_key(self):
        random_token = pretend.call_recorder(
            lambda: "EUmoN-Hsp0CFMcULe2KD5c3LjB_otLG-aXZueTkY3DM"
        )
        store = RedisSessionStore(pretend.stub(), _random_token=random_token)
        assert (store.generate_key()
                == "EUmoN-Hsp0CFMcULe2KD5c3LjB_otLG-aXZueTkY3DM")

    @pytest.mark.parametrize(("key", "valid"), [
        ("EUmoN-Hsp0CFMcULe2KD5c3LjB_otLG-aXZueTkY3DM", True),
        ("invalid", False),
    ])
    def test_is_valid_key(self, key, valid):
        store = RedisSessionStore(pretend.stub())
        assert store.is_valid_key(key) is valid

    def test_get(self):
        store = RedisSessionStore(
            pretend.stub(
                get=lambda key: b"\x81\xa9user.csrf\xa3wat",
            )
        )
        store.refresh = pretend.call_recorder(lambda session: None)

        session = store.get("EUmoN-Hsp0CFMcULe2KD5c3LjB_otLG-aXZueTkY3DM")

        assert store.refresh.calls == [pretend.call(session)]
        assert not session.new
        assert session == {"user.csrf": "wat"}
        assert session.sid == "EUmoN-Hsp0CFMcULe2KD5c3LjB_otLG-aXZueTkY3DM"

    def test_get_invalid_session(self):
        store = RedisSessionStore(pretend.stub())
        assert store.get("invalid key").new

    def test_get_no_data_in_redis(self):
        store = RedisSessionStore(pretend.stub(get=lambda key: None))
        assert store.get("EUmoN-Hsp0CFMcULe2KD5c3LjB_otLG-aXZueTkY3DM").new

    def test_get_invalid_data_in_redis(self):
        store = RedisSessionStore(pretend.stub(get=lambda key: b"asdsa"))
        assert store.get("EUmoN-Hsp0CFMcULe2KD5c3LjB_otLG-aXZueTkY3DM").new

    def test_save(self):
        store = RedisSessionStore(
            pretend.stub(
                setex=pretend.call_recorder(lambda key, ttl, data: None),
            ),
        )
        session = Session({"user.csrf": "wat"}, "EUmoN", False)
        store.save(session)

        assert store.redis.setex.calls == [
            pretend.call(
                "warehouse/session/data/EUmoN",
                12 * 60 * 60,
                b"\x81\xa9user.csrf\xa3wat",
            ),
        ]

    def test_delete(self):
        store = RedisSessionStore(
            pretend.stub(delete=pretend.call_recorder(lambda key: None)),
        )
        store.delete(pretend.stub(sid="EUmoN"))

        assert store.redis.delete.calls == [
            pretend.call("warehouse/session/data/EUmoN"),
        ]

    def test_refresh(self):
        store = RedisSessionStore(
            pretend.stub(expire=pretend.call_recorder(lambda key, ttl: None)),
        )
        store.refresh(pretend.stub(sid="EUmoN"))

        assert store.redis.expire.calls == [
            pretend.call("warehouse/session/data/EUmoN", 12 * 60 * 60),
        ]

    def test_cycle(self):
        store = RedisSessionStore(pretend.stub())
        store.delete = pretend.call_recorder(lambda session: None)

        old_session = Session({"user.csrf": "ok"}, "123456", False)
        new_session = store.cycle(old_session)

        assert store.delete.calls == [pretend.call(old_session)]
        assert new_session == old_session
        assert new_session.new
        assert new_session.sid != old_session.sid


class TestSession:

    def test_cycle(self):
        session = Session({}, "123456", False)
        assert not session.cycled
        session.cycle()
        assert session.cycled

    def test_delete(self):
        session = Session({}, "123456", False)
        assert not session.deleted
        session.delete()
        assert session.deleted


class FakeSessionStore:

    def __init__(self):
        self.saved = []
        self.deleted = []
        self.cycled = []

    def new(self):
        return Session({}, "123456", True)

    def get(self, sid):
        return Session({}, sid, False)

    def save(self, session):
        self.saved.append(session)

    def delete(self, session):
        self.deleted.append(session)

    def cycle(self, session):
        self.cycled.append(session)
        return session


class TestHandleSession:

    def test_no_existing_session(self):
        def fn(self, view, app, request, *args, **kwargs):
            return view(app, request, *args, **kwargs)

        def view(app, request):
            request._session["wat"] = "ok"
            return Response()

        app = pretend.stub(session_store=FakeSessionStore())
        request = pretend.stub(cookies={}, is_secure=False)

        response = handle_session(fn)(pretend.stub(), view, app, request)

        assert app.session_store.saved == [
            Session({"wat": "ok"}, "123456", True),
        ]
        assert response.headers.getlist("Set-Cookie") == [
            "session_id=123456; HttpOnly; Path=/",
        ]

    def test_existing_session(self):
        def fn(self, view, app, request, *args, **kwargs):
            return view(app, request, *args, **kwargs)

        def view(app, request):
            request._session["wat"] = "ok"
            return Response()

        app = pretend.stub(session_store=FakeSessionStore())
        request = pretend.stub(cookies={"session_id": "abcd"}, is_secure=False)

        response = handle_session(fn)(pretend.stub(), view, app, request)

        assert app.session_store.saved == [
            Session({"wat": "ok"}, "abcd", False),
        ]
        assert response.headers.getlist("Set-Cookie") == [
            "session_id=abcd; HttpOnly; Path=/",
        ]

    def test_existing_session_no_save(self):
        def fn(self, view, app, request, *args, **kwargs):
            return view(app, request, *args, **kwargs)

        view = lambda app, request: Response()
        app = pretend.stub(session_store=FakeSessionStore())
        request = pretend.stub(cookies={"session_id": "abcd"}, is_secure=False)

        response = handle_session(fn)(pretend.stub(), view, app, request)

        assert app.session_store.saved == []
        assert response.headers.getlist("Set-Cookie") == []

    def test_delete_session(self):
        def fn(self, view, app, request, *args, **kwargs):
            return view(app, request, *args, **kwargs)

        def view(app, request):
            request._session.delete()
            return Response()

        app = pretend.stub(session_store=FakeSessionStore())
        request = pretend.stub(cookies={"session_id": "abcd"}, is_secure=False)

        response = handle_session(fn)(pretend.stub(), view, app, request)

        assert app.session_store.deleted == [
            Session({}, "abcd", False),
        ]
        assert response.headers.getlist("Set-Cookie") == [
            "session_id=; Expires=Thu, 01-Jan-1970 00:00:00 GMT; Max-Age=0; "
            "Path=/",
        ]

    def test_cycle_session(self):
        def fn(self, view, app, request, *args, **kwargs):
            return view(app, request, *args, **kwargs)

        def view(app, request):
            request._session.cycle()
            return Response()

        app = pretend.stub(session_store=FakeSessionStore())
        request = pretend.stub(cookies={"session_id": "abcd"}, is_secure=False)

        handle_session(fn)(pretend.stub(), view, app, request)

        assert app.session_store.cycled == [Session({}, "abcd", False)]


def test_uses_session():
    view = uses_session(lambda app, request: Response())

    app = pretend.stub()
    request = pretend.stub(_session=pretend.stub())
    response = view(app, request)

    assert request.session is request._session
    assert response.vary.as_set() == {"cookie"}

########NEW FILE########
__FILENAME__ = test_templates
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import collections

from unittest import mock

import pretend
import pytest

from werkzeug.test import create_environ

from warehouse.templates import (
    TemplateRenderer, TemplateResponse, render_response,
)


@pytest.mark.parametrize(("default"), [None, {"foo": pretend.stub()}])
def test_template_renderer(default):
    expected = pretend.stub()
    template = pretend.stub(
        render=pretend.call_recorder(lambda **kw: expected)
    )
    ctx = {
        "wat": pretend.stub(),
    }

    renderer = TemplateRenderer(template, ctx, default_context=default)

    assert renderer.template is template
    assert renderer.context == ctx
    assert renderer.default_context == (default or {})
    assert not renderer.rendered

    assert isinstance(renderer, collections.Iterator)

    rendered = next(renderer)

    assert rendered is expected
    assert renderer.rendered

    with pytest.raises(StopIteration):
        next(renderer)


def test_template_response_repr():
    template = pretend.stub(render=lambda **kw: b"watwat")
    ctx = {"wat": pretend.stub()}

    renderer = TemplateRenderer(template, ctx)

    response = TemplateResponse(renderer)

    assert repr(response) == "<TemplateResponse 6 bytes [200 OK]>"


def test_template_response_get_wsgi_headers():
    template = pretend.stub(render=lambda **kw: b"watwat")
    ctx = {"wat": pretend.stub()}

    renderer = TemplateRenderer(template, ctx)
    response = TemplateResponse(renderer)

    assert dict(response.get_wsgi_headers(create_environ())) == {
        "Content-Type": "text/plain; charset=utf-8",
        "Content-Length": "6",
    }


def test_template_response_is_streaming():
    response = TemplateResponse(iter([]))
    assert not response.is_streamed


def test_render_response():
    template = pretend.stub(render=pretend.call_recorder(lambda **k: "test"))
    app = pretend.stub(
        config=pretend.stub(),
        templates=pretend.stub(
            get_template=pretend.call_recorder(lambda t: template),
        ),
    )
    request = pretend.stub()

    resp = render_response(app, request, "template.html", foo="bar")

    assert resp.get_wsgi_headers(create_environ())["Content-Length"] == "4"
    assert resp.data == b"test"
    assert app.templates.get_template.calls == [pretend.call("template.html")]
    assert template.render.calls == [
        pretend.call(
            foo="bar",
            config=app.config,
            csrf_token=mock.ANY,
            gravatar_url=mock.ANY,
            url_for=mock.ANY,
            static_url=mock.ANY,
        ),
    ]

########NEW FILE########
__FILENAME__ = test_utils
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pretend
import pytest
import six

from warehouse.http import Response
from warehouse.utils import (
    merge_dict, cache, get_wsgi_application, get_mimetype, redirect,
    SearchPagination, is_valid_json_callback_name, generate_camouflage_url,
    camouflage_images, cors, redirect_next, vary_by, random_token, is_safe_url,
    find_links_from_html, normalize_project_name
)


@pytest.mark.parametrize(("base", "additional", "expected"), [
    ({"a": 1}, {"a": 2}, {"a": 2}),
    ({"a": 1}, {"b": 2}, {"a": 1, "b": 2}),
    ({"a": 1, "b": 2}, {"b": 3, "c": 4}, {"a": 1, "b": 3, "c": 4}),
    (None, {"a": 2}, {"a": 2}),
    ({"a": 1}, None, {"a": 1}),
    ("Test", {"a": 7}, {"a": 7}),
    ({"a": 9}, "Test", "Test"),
    ({"a": {"b": 3}}, {"a": {"b": 7, "c": 0}}, {"a": {"b": 7, "c": 0}}),
])
def test_merge_dictionary(base, additional, expected):
    assert merge_dict(base, additional) == expected


@pytest.mark.parametrize(
    ("browser", "varnish", "status"),
    [
        (None, None, 200),
        (1, None, 200),
        (None, 120, 200),
        (1, 120, 200),
        (None, None, 400),
        (1, None, 400),
        (None, 120, 400),
        (1, 120, 400),
    ],
)
def test_cache_deco(browser, varnish, status):
    response = pretend.stub(
        status_code=status,
        cache_control=pretend.stub(),
        surrogate_control=pretend.stub(),
    )
    view = pretend.call_recorder(lambda *a, **kw: response)

    app = pretend.stub()
    request = pretend.stub()

    resp = cache(browser=browser, varnish=varnish)(view)(app, request)

    assert resp is response

    if 200 <= resp.status_code < 400:
        if browser:
            assert resp.cache_control.public
            assert resp.cache_control.max_age == browser

        if varnish:
            assert resp.surrogate_control.public
            assert resp.surrogate_control.max_age == varnish


@pytest.mark.parametrize("environ", [
    {"WAREHOUSE_CONF": "/tmp/config.yml"},
    {},
])
def test_get_wsgi_application(environ):
    obj = pretend.stub()
    klass = pretend.stub(from_yaml=pretend.call_recorder(lambda *a, **k: obj))

    app = get_wsgi_application(environ, klass)
    config = environ.get("WAREHOUSE_CONF")
    configs = [config] if config else []

    assert app is obj
    assert klass.from_yaml.calls == [pretend.call(*configs)]


@pytest.mark.parametrize(("filename", "expected"), [
    ("warehouse-13.10.0.tar.gz", "application/x-tar"),
    ("warehouse-13.10.0-py2.py3-none-any.whl", "application/octet-stream"),
])
def test_get_mimetype(filename, expected):
    assert get_mimetype(filename) == expected


def test_redirect_bytes():
    resp = redirect(b"/foo/")
    assert resp.status_code == 302
    assert resp.headers["Location"] == "/foo/"


def test_redirect_unicode():
    resp = redirect(six.text_type("/foo/"))
    assert resp.status_code == 302
    assert resp.headers["Location"] == "/foo/"


@pytest.mark.parametrize(("values", "host", "kwargs", "expected"), [
    ({}, "example.com", {}, {"location": "/", "code": 303}),
    ({}, "example.com", {"code": 302}, {"location": "/", "code": 302}),
    (
        {},
        "example.com",
        {"default": "/wat/"},
        {"location": "/wat/", "code": 303},
    ),
    (
        {"next": "/wat/"},
        "example.com",
        {},
        {"location": "/wat/", "code": 303},
    ),
    (
        {"next": "/wat/"},
        "example.com",
        {"field_name": "not_next"},
        {"location": "/", "code": 303},
    ),
    (
        {"not_next": "/wat/"},
        "example.com",
        {"field_name": "not_next"},
        {"location": "/wat/", "code": 303},
    ),
    (
        {"next": "http://attacker.com/wat/"},
        "example.com",
        {},
        {"location": "/", "code": 303},
    ),
    (
        {"next": "https://example.com/wat/"},
        "example.com",
        {},
        {"location": "https://example.com/wat/", "code": 303},
    ),
    (
        {"next": "http://example.com/wat/"},
        "example.com",
        {},
        {"location": "http://example.com/wat/", "code": 303},
    ),
])
def test_redirect_next(values, host, kwargs, expected):
    request = pretend.stub(values=values, host=host)
    response = redirect_next(request, **kwargs)

    assert response.headers["Location"] == expected["location"]
    assert response.status_code == expected["code"]


class TestSearchPagination:

    def test_pages(self):
        paginator = SearchPagination(total=100, per_page=10, url=None, page=1)
        assert paginator.pages == 10

    @pytest.mark.parametrize(("total", "per_page", "page", "has"), [
        (100, 10, 1, False),
        (100, 10, 2, True),
        (0, 10, 1, False),
    ])
    def test_has_prev(self, total, per_page, page, has):
        paginator = SearchPagination(
            total=total,
            per_page=per_page,
            url=None,
            page=page,
        )
        assert paginator.has_prev == has

    @pytest.mark.parametrize(("total", "per_page", "page", "has"), [
        (100, 10, 10, False),
        (100, 10, 9, True),
        (0, 10, 1, False),
    ])
    def test_has_next(self, total, per_page, page, has):
        paginator = SearchPagination(
            total=total,
            per_page=per_page,
            url=None,
            page=page,
        )
        assert paginator.has_next == has

    def test_prev_url(self):
        prev_url = pretend.stub()
        url = pretend.call_recorder(lambda **kw: prev_url)
        paginator = SearchPagination(total=100, per_page=10, url=url, page=2)

        assert paginator.prev_url is prev_url
        assert url.calls == [pretend.call(page=1)]

    def test_next_url(self):
        next_url = pretend.stub()
        url = pretend.call_recorder(lambda **kw: next_url)
        paginator = SearchPagination(total=100, per_page=10, url=url, page=1)

        assert paginator.next_url is next_url
        assert url.calls == [pretend.call(page=2)]


@pytest.mark.parametrize(("callback", "expected"), [
    ("", False),
    ("too long" * 50, False),
    ("somehack()", False),
    ("break", False),
    ("valid", True),
])
def test_is_valid_json_callback_name(callback, expected):
    assert is_valid_json_callback_name(callback) == expected


@pytest.mark.parametrize(("camo_url", "camo_key", "url", "expected"), [
    (
        "https://camo.example.com/",
        "123",
        "https://example.com/fake.png",
        "https://camo.example.com/dec25c03d21dc84f233f39c6107d305120746ca0/"
        "68747470733a2f2f6578616d706c652e636f6d2f66616b652e706e67",
    )
])
def test_generate_camouflage_url(camo_url, camo_key, url, expected):
    assert generate_camouflage_url(camo_url, camo_key, url) == expected


@pytest.mark.parametrize(("camo_url", "camo_key", "html", "expected"), [
    (
        "https://camo.example.com/",
        "123",
        '<html><body><img src="http://example.com/fake.png"></body></html>',
        '<img src=https://camo.example.com/d59e450f25b4dad6ef4bc4bd71fef1f10d1'
        '74273/687474703a2f2f6578616d706c652e636f6d2f66616b652e706e67>',
    ),
    (
        "https://camo.example.com/",
        "123",
        '<html><body><img alt="whatever"></body></html>',
        "<img alt=whatever>",
    ),
])
def test_camouflage_images(camo_url, camo_key, html, expected):
    assert camouflage_images(camo_url, camo_key, html) == expected


def test_cors():
    app = pretend.stub()
    request = pretend.stub()
    response = pretend.stub(headers={})

    resp = cors(lambda *a, **kw: response)(app, request)

    assert resp is response
    assert resp.headers == {"Access-Control-Allow-Origin": "*"}


@pytest.mark.parametrize(("varies", "expected"), [
    ([["Cookie"]], {"cookie"}),
    ([["Cookie"], ["Cookie"]], {"cookie"}),
    ([["Cookie", "Accept-Encoding"]], {"accept-encoding", "cookie"}),
    ([["Cookie"], ["Accept-Encoding"]], {"accept-encoding", "cookie"}),
    (
        [["Cookie", "Accept-Encoding"], ["Cookie"]],
        {"accept-encoding", "cookie"},
    ),
])
def test_vary_by(varies, expected):
    view = lambda app, request: Response("")

    for vary in varies:
        view = vary_by(*vary)(view)

    assert view(pretend.stub(), pretend.stub()).vary.as_set() == expected


def test_random_token():
    random_data = (
        b"\xc3_.S\x17u\xa0_b\xa8P\xd9\xe0|j\xe0#\xb9\x9f\xef\x11\xdb\xdf\xf6"
        b"\xa1\xd9[R\xd6\xde'\xef"
    )
    urandom = pretend.call_recorder(lambda size: random_data)

    assert (random_token(_urandom=urandom)
            == "w18uUxd1oF9iqFDZ4Hxq4CO5n-8R29_2odlbUtbeJ-8")
    assert urandom.calls == [pretend.call(32)]


@pytest.mark.parametrize(("url", "host", "expected"), [
    ("", "example.com", False),
    ("/wat/", "example.com", True),
    ("http://example.com/wat/", "example.com", True),
    ("https://example.com/wat/", "example.com", True),
    ("ftp://example.com/wat/", "example.com", False),
    ("http://attacker.com/wat/", "example.com", False),
    ("https://attacker.com/wat/", "example.com", False),
])
def test_is_safe_url(url, host, expected):
    assert is_safe_url(url, host) is expected


@pytest.mark.parametrize(("html", "expected"), [
    ("<a href='foo'>footext</a><div><a href='bar'>bartext</a><div>",
     ["foo", "bar"]),
])
def test_find_links_from_html(html, expected):
    assert find_links_from_html(html) == expected


@pytest.mark.parametrize(("input_string", "expected"), [
    ("imabad-name^^^", ValueError),
    ("CaseInsensitive", "caseinsensitive"),
    ("replace_underscores", "replace-underscores"),
    ("-not-alphanumericstart", ValueError),
    ("not-alphanumericend-", ValueError),
    ("123456789", "123456789"),
    ("hoobs#", ValueError),
    ("q", "q")
])
def test_normalize_project_name(input_string, expected):
    if expected is ValueError:
        with pytest.raises(ValueError):
            normalize_project_name(input_string)
    else:
        assert normalize_project_name(input_string) == expected

########NEW FILE########
__FILENAME__ = test_views
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pretend

from warehouse.views import index

from .lib.db import ProjectFactory, ReleaseFactory, ReleaseFileFactory


def unique(iterable, key=None):
    seen = set()
    for item in iterable:
        k = key(item) if key is not None else item
        if k not in seen:
            seen.add(k)
            yield item


def test_index(dbapp):
    project1 = ProjectFactory.create(engine=dbapp.engine)
    project2 = ProjectFactory.create(engine=dbapp.engine)

    project1_release1 = ReleaseFactory.create(
        name=project1["name"],
        engine=dbapp.engine,
    )
    project1_release2 = ReleaseFactory.create(
        name=project1["name"],
        engine=dbapp.engine,
    )
    project2_release1 = ReleaseFactory.create(
        name=project2["name"],
        engine=dbapp.engine,
    )

    project1_release1_file1 = ReleaseFileFactory.create(
        name=project1["name"],
        version=project1_release1["version"],
        engine=dbapp.engine,
    )
    project1_release2_file1 = ReleaseFileFactory.create(
        name=project1["name"],
        version=project1_release2["version"],
        engine=dbapp.engine,
    )
    project2_release1_file1 = ReleaseFileFactory.create(
        name=project2["name"],
        version=project2_release1["version"],
        engine=dbapp.engine,
    )

    request = pretend.stub()

    resp = index(dbapp, request)

    assert resp.response.template.name == "index.html"
    assert resp.response.context == {
        "project_count": 2,
        "download_count": sum(
            x["downloads"]
            for x in [
                project1_release1_file1,
                project1_release2_file1,
                project2_release1_file1,
            ]
        ),
        "recently_updated": list(unique(
            sorted(
                [
                    project1_release1,
                    project1_release2,
                    project2_release1,
                ],
                key=lambda r: r["created"],
                reverse=True,
            ),
            key=lambda r: r["name"],
        )),
    }

########NEW FILE########
__FILENAME__ = db
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import logging

from warehouse import db


logger = logging.getLogger(__name__)


class Database(db.Database):

    get_user_id = db.scalar(
        """ SELECT id
            FROM accounts_user
            WHERE username = %s
            LIMIT 1
        """
    )

    get_user_id_by_email = db.scalar(
        """ SELECT user_id
            FROM accounts_email
            WHERE email = %s
            LIMIT 1
        """
    )

    def get_user(self, username):
        query = \
            """ SELECT accounts_user.id, username, name, date_joined, email
                FROM accounts_user
                LEFT OUTER JOIN accounts_email ON (
                    accounts_email.user_id = accounts_user.id
                )
                WHERE username = %(username)s
                LIMIT 1
            """

        result = self.engine.execute(query, username=username).first()

        if result is not None:
            result = dict(result)

        return result

    def user_authenticate(self, username, password):
        # Get the user with the given username
        query = \
            """ SELECT password
                FROM accounts_user
                WHERE username = %(username)s
                LIMIT 1
            """

        with self.engine.begin():
            password_hash = self.engine.execute(query, username=username).\
                scalar()

            # If the user was not found, then return None
            if password_hash is None:
                return

            try:
                valid, new_hash = self.app.passlib.verify_and_update(
                    password,
                    password_hash,
                )
            except ValueError:
                logger.exception(
                    "An exception occurred attempting to validate the "
                    "password for '%s'",
                    username,
                )
                return

            if valid:
                if new_hash:
                    self.engine.execute(
                        """ UPDATE accounts_user
                            SET password = %(password)s
                            WHERE username = %(username)s
                        """,
                        password=new_hash,
                        username=username,
                    )
                return True

# data modification methods

    def insert_user(self, username, email, password,
                    is_superuser=False, is_staff=False, is_active=False):
        if self.get_user_id_by_email(email) is not None:
            raise ValueError(
                "Email address already belongs to a different user!"
            )
        hashed_password = self.app.passlib.encrypt(password)

        query = \
            """ INSERT INTO accounts_user(
                    username, password,
                    last_login, is_superuser,
                    name, is_staff, date_joined, is_active
                ) VALUES (
                    %(username)s, %(password)s,
                    current_timestamp, %(is_superuser)s,
                    '', %(is_staff)s, current_timestamp, %(is_active)s
                ) RETURNING id
            """
        # Insert the actual row into the user table
        user_id = self.engine.execute(
            query,
            username=username,
            password=hashed_password,
            is_superuser=str(is_superuser).upper(),
            is_staff=str(is_staff).upper(),
            is_active=str(is_active).upper()
        ).scalar()
        self.update_user(user_id, email=email)

    def update_user(self, user_id, password=None, email=None):
        if password is not None:
            self.update_user_password(user_id, password)
        if email is not None:
            self.update_user_email(user_id, email)

    def delete_user(self, username):
        self.engine.execute(
            "DELETE FROM accounts_user WHERE username = %s",
            username
        )

    def update_user_password(self, user_id, password):
        query = \
            """ UPDATE accounts_user
                SET password = %s
                WHERE id = %s
            """
        hashed_password = self.app.passlib.encrypt(password)
        self.engine.execute(query, hashed_password, user_id)

    def update_user_email(self, user_id, email):
        query = \
            """ WITH new_values (user_id, email, "primary", verified) AS (
                VALUES
                    (%(user_id)s, %(email)s, TRUE, FALSE)
                ),
                UPSERT AS (
                    UPDATE accounts_email ae
                        set email = nv.email,
                        verified = nv.verified
                    FROM new_values nv
                    WHERE ae.user_id = nv.user_id
                    AND ae.primary = nv.primary
                    RETURNING ae.*
                )
                INSERT INTO accounts_email
                    (user_id, email, "primary", verified)
                SELECT user_id, email, "primary", verified
                FROM new_values
                WHERE NOT EXISTS (
                    SELECT 1
                    FROM upsert up
                    WHERE up.user_id = new_values.user_id
                    AND up.primary = new_values.primary
        )"""
        self.engine.execute(query, user_id=user_id, email=email)

########NEW FILE########
__FILENAME__ = forms
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from warehouse import forms


class LoginForm(forms.Form):

    username = forms.StringField(
        [
            forms.validators.Required(),
            forms.validators.Length(min=4, max=25),
        ],
    )

    password = forms.PasswordField()

    def __init__(self, *args, authenticator, **kwargs):
        super(LoginForm, self).__init__(*args, **kwargs)

        self.authenticate = authenticator

    def validate_username(self, field):
        if not self.authenticate(field.data, self.password.data):
            raise forms.ValidationError(
                self.gettext("Invalid username or password")
            )

########NEW FILE########
__FILENAME__ = tables
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from citext import CIText
from sqlalchemy import (
    Table, Column, CheckConstraint, ForeignKey, Index, UniqueConstraint,
)
from sqlalchemy import Boolean, DateTime, Integer, String, Unicode
from sqlalchemy import sql

from warehouse import db


users = Table(
    "accounts_user",
    db.metadata,

    Column("id", Integer(), primary_key=True, nullable=False),
    Column("password", String(length=128), nullable=False),
    Column("last_login", DateTime(), nullable=False),
    Column("is_superuser", Boolean(), nullable=False),
    Column("username", CIText(), nullable=False, unique=True),
    Column("name", Unicode(length=100), nullable=False),
    Column("is_staff", Boolean(), nullable=False),
    Column("is_active", Boolean(), nullable=False),
    Column("date_joined", DateTime(), server_default=sql.func.now()),

    CheckConstraint("length(username) <= 50", name="packages_valid_name"),
    CheckConstraint(
        "username ~* '^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$'",
        name="accounts_user_valid_username",
    ),
)

emails = Table(
    "accounts_email",
    db.metadata,

    Column("id", Integer(), primary_key=True, nullable=False),
    Column(
        "user_id",
        Integer(),
        ForeignKey(
            "accounts_user.id",
            deferrable=True,
            initially="DEFERRED",
        ),
        nullable=False,
    ),
    Column("email", Unicode(length=254), nullable=False),
    Column("primary", Boolean(), nullable=False),
    Column("verified", Boolean(), nullable=False),

    UniqueConstraint("email", name="accounts_email_email_key"),

    Index("accounts_email_email_like", "email"),
    Index("accounts_email_user_id", "user_id"),
)

########NEW FILE########
__FILENAME__ = urls
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from werkzeug.routing import Rule, EndpointPrefix


urls = [
    EndpointPrefix("warehouse.accounts.views.", [
        Rule(
            "/account/login/",
            methods=["GET", "POST"],
            endpoint="login",
        ),
        Rule(
            "/account/logout/",
            methods=["GET", "POST"],
            endpoint="logout",
        ),
        Rule(
            "/user/<username>/",
            methods=["GET"],
            endpoint="user_profile",
        ),
    ]),
]

########NEW FILE########
__FILENAME__ = views
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from werkzeug.exceptions import NotFound

from warehouse import fastly
from warehouse.accounts.forms import LoginForm
from warehouse.csrf import csrf_cycle, csrf_protect
from warehouse.helpers import url_for
from warehouse.sessions import uses_session
from warehouse.templates import render_response
from warehouse.utils import cache, redirect, redirect_next


@cache(browser=1, varnish=120)
@fastly.users
def user_profile(app, request, username):
    user = app.db.accounts.get_user(username)

    if user is None:
        raise NotFound("Could not find user {}".format(username))

    if user["username"] != username:
        return redirect(
            url_for(
                request,
                "warehouse.accounts.views.user_profile",
                username=user["username"],
            ),
            code=301,
        )

    return render_response(
        app, request, "accounts/profile.html",
        user=user,
        projects=app.db.packaging.get_projects_for_user(user["username"]),
    )


@csrf_protect
@uses_session
def login(app, request):
    form = LoginForm(
        request.form,
        authenticator=app.db.accounts.user_authenticate,
        translations=app.translations,
    )

    if request.method == "POST" and form.validate():
        # Get the user's ID, this is what we will use as the identifier anytime
        # we need to securely reference the user within the database.
        user_id = app.db.accounts.get_user_id(form.username.data)

        if request.session.get("user.id") != user_id:
            # To avoid reusing another user's session data, clear the session
            # data if the existing session corresponds to a different
            # authenticated user.
            request.session.clear()

        # Cycle the session key to prevent session fixation attacks from
        # crossing an authentication boundary
        request.session.cycle()

        # Cycle the CSRF token to prevent a CSRF via session fixation attack
        # from crossing an authentication boundary
        csrf_cycle(request.session)

        # Log the user in by storing their user id in their session
        request.session["user.id"] = user_id

        # We'll want to redirect the user with a 303 once we've completed the
        # log in process.
        resp = redirect_next(
            request,
            default=url_for(request, "warehouse.views.index"),
        )

        # Store the user's name in a cookie so that the client side can use
        # it for display purposes. This value **MUST** not be used for any
        # sort of access control.
        resp.set_cookie("username", form.username.data)

        # Return our prepared response to the user
        return resp

    # Either this is a GET request or it is a POST request with a failing form
    # validation. Either way we want to simply render our template with the
    # form available.
    return render_response(
        app, request, "accounts/login.html",
        form=form,
        next=request.values.get("next"),
    )


@csrf_protect
@uses_session
def logout(app, request):
    if request.method == "POST":
        # Delete our session, the user is logging out and we no longer want it
        request.session.delete()

        # We'll want to redirect the user with a 303 once we've completed the
        # log in process.
        resp = redirect_next(
            request,
            default=url_for(request, "warehouse.views.index"),
        )

        # Delete the username cookie, the user is logging out and we no longer
        # want to store the username that they used when they were logged in.
        resp.delete_cookie("username")

        # Return our prepared response to the now logged out user
        return resp

    # This is a simple GET request, so we just want to render the template
    return render_response(
        app, request, "accounts/logout.html",
        next=request.values.get("next"),
    )

########NEW FILE########
__FILENAME__ = application
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import collections
import importlib
import logging.config
import os.path
import urllib.parse

import babel.dates
import babel.numbers
import babel.support

import guard
import passlib.context

import jinja2

import redis

import sqlalchemy
import yaml

from raven import Client
from raven.middleware import Sentry
from werkzeug.contrib.fixers import HeaderRewriterFix
from werkzeug.exceptions import HTTPException
from werkzeug.wsgi import responder
from whitenoise import WhiteNoise

import warehouse
import warehouse.cli

from warehouse import urls
from warehouse import db
from warehouse.csrf import handle_csrf
from warehouse.datastructures import AttributeDict
from warehouse.http import Request
from warehouse.legacy.middlewares import LegacyRewriteMiddleware
from warehouse.middlewares import XForwardedTokenMiddleware
from warehouse.packaging import helpers as packaging_helpers
from warehouse.packaging.search import ProjectMapping
from warehouse.search.indexes import Index
from warehouse.sessions import RedisSessionStore, Session, handle_session
from warehouse.utils import merge_dict

# Register the SQLAlchemy tables by importing them
import warehouse.accounts.tables
import warehouse.packaging.tables

# Get the various models
import warehouse.accounts.db
import warehouse.packaging.db


class Warehouse(object):

    db_classes = {
        "accounts": warehouse.accounts.db.Database,
        "packaging": warehouse.packaging.db.Database,
    }

    static_dir = os.path.abspath(
        os.path.join(os.path.dirname(warehouse.__file__), "static", "compiled")
    )
    static_path = "/static/"

    def __init__(self, config, engine=None, redis_class=redis.StrictRedis):
        self.config = AttributeDict(config)

        self.metadata = db.metadata

        # configure logging
        logging.config.dictConfig(self.config.logging)

        # Connect to the database
        if engine is None and self.config.get("database", {}).get("url"):
            engine = sqlalchemy.create_engine(self.config.database.url)
        self.engine = engine

        # Create our redis connections
        self.redises = {
            key: redis_class.from_url(url)
            for key, url in self.config.redis.items()
        }

        # Create our Store instance and associate our store modules with it
        self.db = AttributeDict()
        for name, klass in self.db_classes.items():
            self.db[name] = klass(
                self,
                self.metadata,
                self.engine,
                self.redises["downloads"],
            )

        # Create our Search Index instance and associate our mappings with it
        self.search = Index(self.db, self.config.search)
        self.search.register(ProjectMapping)

        # Set up our URL routing
        self.urls = urls.urls

        # Initialize our Translations engine
        self.translations = babel.support.NullTranslations()

        # Setup our Jinja2 Environment
        self.templates = jinja2.Environment(
            autoescape=True,
            auto_reload=self.config.debug,
            extensions=[
                "jinja2.ext.i18n",
            ],
            loader=jinja2.PackageLoader("warehouse"),
        )

        # Install Babel
        self.templates.filters.update({
            "package_type_display": packaging_helpers.package_type_display,
            "format_number": babel.numbers.format_number,
            "format_decimal": babel.numbers.format_decimal,
            "format_percent": babel.numbers.format_percent,
            "format_date": babel.dates.format_date,
            "format_datetime": babel.dates.format_datetime,
            "format_time": babel.dates.format_time,
        })

        # Install our translations
        self.templates.install_gettext_translations(
            self.translations,
            newstyle=True,
        )

        # Setup our password hasher
        self.passlib = passlib.context.CryptContext(
            schemes=[
                "bcrypt_sha256",
                "bcrypt",
                "django_bcrypt",
                "unix_disabled",
            ],
            default="bcrypt_sha256",
            deprecated=["auto"],
        )

        # Setup our session storage
        self.session_store = RedisSessionStore(
            self.redises["sessions"],
            session_class=Session,
        )

        # Add our Content Security Policy Middleware
        img_src = ["'self'"]
        if self.config.camo:
            camo_parsed = urllib.parse.urlparse(self.config.camo.url)
            img_src += [
                "{}://{}".format(camo_parsed.scheme, camo_parsed.netloc),
                "https://secure.gravatar.com",
            ]
        else:
            img_src += ["*"]

        self.wsgi_app = guard.ContentSecurityPolicy(
            self.wsgi_app,
            {
                "default-src": ["'self'"],
                "font-src": ["'self'", "data:"],
                "img-src": img_src,
                "style-src": ["'self'", "cloud.typography.com"],
            },
        )

        if "sentry" in self.config:
            self.wsgi_app = Sentry(self.wsgi_app, Client(**self.config.sentry))

        # Serve the static files that are packaged as part of Warehouse
        self.wsgi_app = WhiteNoise(
            self.wsgi_app,
            root=self.static_dir,
            prefix=self.static_path,
            max_age=31557600,
        )

        # Add our Powered By Middleware
        self.wsgi_app = HeaderRewriterFix(
            self.wsgi_app,
            add_headers=[
                (
                    "X-Powered-By",
                    "Warehouse {__version__} ({__build__})".format(
                        __version__=warehouse.__version__,
                        __build__=warehouse.__build__,
                    ),
                ),
            ],
        )

        # Previously PyPI used a hand written disaptch method which depended
        # on things like the request's content type or url parameters. In order
        # to sanely support that in Warehouse we use this middleware to rewrite
        # those to "internal" URLs which we can then dispatch based on.
        self.wsgi_app = LegacyRewriteMiddleware(self.wsgi_app)

        # This is last because we want it processed first in the stack of
        # middlewares. This will ensure that we strip X-Forwarded-* headers
        # if the request doesn't come from Fastly
        self.wsgi_app = XForwardedTokenMiddleware(
            self.wsgi_app,
            self.config.site.access_token,
        )

    def __call__(self, environ, start_response):
        """
        Shortcut for :attr:`wsgi_app`.
        """
        return self.wsgi_app(environ, start_response)

    @classmethod
    def from_yaml(cls, *paths, **kwargs):
        # Pull out other keyword arguments
        override = kwargs.pop("override", None)

        default = os.path.abspath(os.path.join(
            os.path.dirname(warehouse.__file__),
            "config.yml",
        ))

        paths = [default] + list(paths)

        config = {}
        for path in paths:
            with open(path) as configfile:
                # Use no cover to work around a coverage bug
                config = merge_dict(  # pragma: no cover
                    config,
                    yaml.safe_load(configfile)
                )

        if override:
            config = merge_dict(config, override)

        return cls(config=config, **kwargs)

    @classmethod
    def from_cli(cls, argv):
        def _generate_parser(parser, commands):
            # Generate our commands
            subparsers = parser.add_subparsers()
            for name, command in commands.items():
                cmd_parser = subparsers.add_parser(name)

                if hasattr(command, "create_parser"):
                    command.create_parser(cmd_parser)

                if isinstance(command, collections.Mapping):
                    _generate_parser(cmd_parser, command)
                else:
                    cmd_parser.set_defaults(_cmd=command)

        parser = argparse.ArgumentParser(prog="warehouse")
        parser.add_argument("-c", "--config", action="append", dest="_configs")

        _generate_parser(parser, warehouse.cli.__commands__)

        args = parser.parse_args(argv)

        configs = args._configs if args._configs is not None else []
        app = cls.from_yaml(*configs)

        return args._cmd(
            app,
            *args._get_args(),
            **{k: v for k, v in args._get_kwargs() if not k.startswith("_")}
        )

    # The order of these decorators matter. We need @handle_session to come
    # before anything that depends on it, like @handle_csrf
    @handle_session
    @handle_csrf
    def dispatch_view(self, view, *args, **kwargs):
        return view(*args, **kwargs)

    @responder
    def wsgi_app(self, environ, start_response):
        """
        The actual WSGI application.  This is not implemented in
        `__call__` so that middlewares can be applied without losing a
        reference to the class.  So instead of doing this::

            app = MyMiddleware(app)

        It's a better idea to do this instead::

            app.wsgi_app = MyMiddleware(app.wsgi_app)

        Then you still have the original application object around and
        can continue to call methods on it.

        :param environ: a WSGI environment
        :param start_response: a callable accepting a status code,
                               a list of headers and an optional
                               exception context to start the response
        """
        try:
            # Figure out what endpoint to call
            urls = self.urls.bind_to_environ(environ)
            endpoint, kwargs = urls.match()

            # Load our view function
            modname, viewname = endpoint.rsplit(".", 1)
            module = importlib.import_module(modname)
            view = getattr(module, viewname)

            # Create our request object
            request = Request(environ)
            request.url_adapter = urls

            # Attach our trusted hosts to this request
            request.trusted_hosts = self.config.site.hosts

            # Access request.host to trigger a check against our trusted_hosts
            request.host

            # Dispatch to the loaded view function
            return self.dispatch_view(view, self, request, **kwargs)
        except HTTPException as exc:
            return exc

########NEW FILE########
__FILENAME__ = cli
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import glob
import os

import werkzeug.serving

import warehouse
import warehouse.migrations.cli
import warehouse.search.cli

from warehouse.serving import WSGIRequestHandler


class ServeCommand:

    def __call__(self, app, host, port, reloader, debugger):
        werkzeug.serving.run_simple(
            host, port, app,
            use_reloader=reloader,
            use_debugger=debugger,
            request_handler=WSGIRequestHandler,
            extra_files=(
                glob.glob(os.path.join(app.static_dir, "*.*")) +
                glob.glob(os.path.join(app.static_dir, "*/*.*"))
            ),
        )

    def create_parser(self, parser):
        parser.add_argument(
            "-H", "--host",
            default="localhost",
            help="The host to bind the server to, defaults to localhost",
        )
        parser.add_argument(
            "-p", "--port",
            default=9000,
            type=int,
            help="The port to bind the server to, defaults to 6000",
        )
        parser.add_argument(
            "--no-reload",
            default=True,
            action="store_false",
            dest="reloader",
            help="Disable automatic reloader",
        )
        parser.add_argument(
            "--no-debugger",
            default=True,
            action="store_false",
            dest="debugger",
            help="Disable Werkzeug debugger",
        )


__commands__ = {
    "migrate": warehouse.migrations.cli.__commands__,
    "search": warehouse.search.cli.__commands__,
    "serve": ServeCommand(),
}

########NEW FILE########
__FILENAME__ = csrf
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import functools
import hmac
import urllib.parse

from werkzeug.exceptions import SecurityError

from warehouse.utils import random_token, vary_by


def _verify_csrf_origin(request):
    # Determine the origin of this request
    origin = request.headers.get("Origin", request.headers.get("Referer"))

    # Fail if we were not able to locate an origin at all
    if origin is None:
        raise SecurityError("Origin checking failed - no Origin or Referer.")

    # Parse the origin and host for comparison
    origin_parsed = urllib.parse.urlparse(origin)
    host_parsed = urllib.parse.urlparse(request.host_url)

    # Fail if our origin is null
    if origin == "null":
        raise SecurityError(
            "Origin checking failed - null does not match {}.".format(
                urllib.parse.urlunparse(host_parsed[:2] + ("", "", "", ""))
            )
        )

    # Fail if the received origin does not match the host
    if ((origin_parsed.scheme, origin_parsed.hostname, origin_parsed.port) !=
            (host_parsed.scheme, host_parsed.hostname, host_parsed.port)):
        raise SecurityError(
            "Origin checking failed - {} does not match {}.".format(
                urllib.parse.urlunparse(origin_parsed[:2] + ("", "", "", "")),
                urllib.parse.urlunparse(host_parsed[:2] + ("", "", "", "")),
            )
        )


def _verify_csrf_token(request):
    # Get the token out of the session
    #   Note: We have to use the private request._session because
    #         request.session is not guaranteed to exist when this function is
    #         called.
    csrf_token = request._session.get("user.csrf")

    # Validate that we have a stored token, if we do not then we have nothing
    # to compare the incoming token against.
    if csrf_token is None:
        raise SecurityError("CSRF token not set.")

    # Attempt to look in the form data
    request_token = request.form.get("csrf_token")

    # Also attempt to look in the headers, this makes things like Ajax easier
    # and PUT/DELETE possible.
    request_token = request.headers.get("X-CSRF-Token", request_token)

    # Validate that we have a token attached to this request somehow
    if not request_token:
        raise SecurityError("CSRF token missing.")

    # Validate that the stored token and the request token match each other
    if not hmac.compare_digest(csrf_token, request_token):
        raise SecurityError("CSRF token incorrect.")


def _ensure_csrf_token(request):
    # Store a token in the session if one doesn't exist there already
    #   Note: We have to use the private request._session because
    #         request.session is not guaranteed to exist when this function is
    #         called.
    if not request._session.get("user.csrf"):
        request._session["user.csrf"] = random_token()

    # Store the fact that CSRF is in use for this request on the request
    request._csrf = True


def handle_csrf(fn,
                _verify_origin=_verify_csrf_origin,
                _verify_token=_verify_csrf_token):

    @functools.wraps(fn)
    def wrapped(self, view, app, request, *args, **kwargs):
        # Assume that anything not defined as 'safe' by RFC2616 needs
        # protection
        if request.method not in {"GET", "HEAD", "OPTIONS", "TRACE"}:
            # We have 3 potential states for a view function to be in, it could
            # have asked for CSRF, exempted for CSRF, or done none of these.
            if getattr(view, "_csrf", None) is None:
                # CSRF influences the response and thus we cannot know if it is
                # safe to access the session or if that will inadvertently
                # trigger the response to require a Vary: Cookie so if the
                # function has not explicitly told us one way or another we
                # will always hard fail on an unsafe method.
                raise SecurityError("No CSRF protection applied to view")
            elif getattr(view, "_csrf", None):
                # The function has explicitly opted in to the CSRF protection
                # and we can assume that it has handled setting up the CSRF
                # token as well as making sure that a Vary: Cookie header has
                # been added.
                _verify_origin(request)
                _verify_token(request)

        # Ensure that the session has a token stored for this request. This is
        # purposely done *after* we've validated the CSRF above. If there is
        # no CSRF token stored we want that to be a distinct messages from if
        # the given token doesn't match a new, random, token.
        if getattr(view, "_csrf", None):
            _ensure_csrf_token(request)

        # If we've gotten to this point, than either the request was a "safe"
        # method, the view has opted out of CSRF, or the CSRF has been
        # verified. In any case it *should* be safe to actually process this
        # request.
        return fn(self, view, app, request, *args, **kwargs)

    # Set an attribute so that we can verify the dispatch_view has had CSRF
    # enabled
    wrapped._csrf_handled = True

    return wrapped


def csrf_protect(fn):
    # Mark the view function as requiring CSRF
    fn._csrf = True

    # Return the original view function, but varied by Cookie
    return vary_by("Cookie")(fn)


def csrf_exempt(fn):
    # Mark the view function as exempt from CSRF
    fn._csrf = False

    # Return the original view function
    return fn


def csrf_cycle(session):
    # Store a token in the session if one doesn't exist there already
    #   Note: We have to use the session inside of the environ dictionary
    #         because request.session does not exist when this function runs
    session["user.csrf"] = random_token()

########NEW FILE########
__FILENAME__ = datastructures
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import collections


class AttributeDict(dict):

    def __init__(self, initial_data=None):
        if initial_data:
            for key, value in initial_data.items():
                if isinstance(value, collections.Mapping):
                    self[key] = AttributeDict(value)
                else:
                    self[key] = value

    def __getattr__(self, name):
        if name not in self:
            raise AttributeError("'{}' object has no attribute '{}'".format(
                self.__class__,
                name,
            ))

        return self[name]

########NEW FILE########
__FILENAME__ = db
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sqlalchemy


metadata = sqlalchemy.MetaData()


class Database(object):

    def __init__(self, app, metadata, engine, redis):
        self.app = app
        self.metadata = metadata
        self.engine = engine
        self.redis = redis


def scalar(query, default=None):
    """
    A helper function that takes a query and returns a function that will query
    the database and return a scalar.
    """
    def inner(model, *args, **kwargs):
        val = model.engine.execute(query, *args, **kwargs).scalar()

        if default is not None and val is None:
            return default
        else:
            return val

    return inner


def first(query, default=None):
    """
    A helper function that takes a query and returns a function that will query
    the database and return the first row
    """
    def inner(model, *args, **kwargs):
        val = model.engine.execute(query, *args, **kwargs).first()

        if default is not None and val is None:
            return default
        else:
            return val

    return inner


def rows(query, row_func=dict):
    """
    A helper function that takes a query and returns a function that will query
    the database and return a list of rows with the row_func applied to each.
    """
    def inner(model, *args, **kwargs):
        return [row_func(r) for r in
                model.engine.execute(query, *args, **kwargs)]

    return inner


def mapping(query, key_func=lambda r: r[0], value_func=lambda r: r[1]):
    """
    A helper function that takes a query, a key_func, and a value_func and will
    created a mapping that maps each row to a key: value pair.
    """
    def inner(model, *args, **kwargs):
        return {
            key_func(r): value_func(r)
            for r in model.engine.execute(query, *args, **kwargs)
        }

    return inner


def validate_argument_column_mapping(argument_dict, table,
                                     blacklist=None):
    """
    Validate that the keys of the argument_dict passed match columns in table
    that are not in the blacklist list.

    return TypeError if there is a key where this condition is not met.
    """
    if blacklist is None:
        blacklist = []
    columns = set((c.key for c in table.columns if c.key not in blacklist))
    for argument_name in argument_dict:
        if argument_name not in columns:
            raise TypeError("Key {0} does not match a column in {1}".format(
                argument_name, table.name
            ))

########NEW FILE########
__FILENAME__ = fastly
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import functools
import string

from warehouse.utils import normalize_project_name


class FastlyFormatter(string.Formatter):

    def convert_field(self, value, conversion):
        if conversion == "n":
            return normalize_project_name(value)
        return super(FastlyFormatter, self).convert_field(value, conversion)


class FastlyKey:

    def __init__(self, *keys):
        self.keys = keys

    def __call__(self, fn=None, **names):
        def decorator(fn):
            @functools.wraps(fn)
            def wrapped(app, request, *args, **kwargs):
                # Get the response from the view
                resp = fn(app, request, *args, **kwargs)

                # Resolve our surrogate keys
                view_kwargs = {"app": app, "request": request}
                view_kwargs.update(kwargs)
                ctx = {
                    names.get(k, k): v
                    for k, v in view_kwargs.items()
                }

                # Set our Fastly Surrogate-Key header
                resp.headers["Surrogate-Key"] = " ".join(
                    self.format_keys(**ctx)
                )

                # Return the modified response
                return resp
            return wrapped

        if fn is not None:
            return decorator(fn)
        else:
            return decorator

    def format_keys(self, **context):
        return [
            FastlyFormatter().format(key, **context)
            for key in self.keys
        ]


projects = FastlyKey("project", "project/{project!n}")


users = FastlyKey("user", "user/{username!n}")


rss = FastlyKey("rss")

########NEW FILE########
__FILENAME__ = forms
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import babel.support

from wtforms import validators, widgets  # noqa
from wtforms.fields import *  # noqa
from wtforms.form import Form as _Form
from wtforms.validators import ValidationError  # noqa


class Form(_Form):

    def __init__(self, *args, translations=None, **kwargs):
        if translations is None:
            translations = babel.support.NullTranslations()

        self._translations = translations

        super(Form, self).__init__(*args, **kwargs)

    def _get_translations(self):
        return self._translations

    def gettext(self, string):
        return self._translations.gettext(string)

    def ngettext(self, singular, plural, n):
        return self._translations.ngettext(singular, plural, n)

########NEW FILE########
__FILENAME__ = helpers
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import functools
import hashlib
import json
import os.path
import urllib.parse

import markupsafe


def url_for(request, endpoint, **values):
    force_external = values.pop("_force_external", False)
    return request.url_adapter.build(
        endpoint, values,
        force_external=force_external,
    )


def gravatar_url(email, size=80):
    if email is None:
        email = ""

    email_hash = hashlib.md5(email.strip().lower().encode("utf8")).hexdigest()

    url = "https://secure.gravatar.com/avatar/{}".format(email_hash)
    params = {
        "size": size,
    }

    return "?".join([url, urllib.parse.urlencode(params)])


@functools.lru_cache()
def _load_assets_json(path):
    with open(path, "r") as fp:
        return json.load(fp)


def static_url(app, filename):
    """
    static_url('css/bootstrap.css')
    """
    assets = _load_assets_json(os.path.join(app.static_dir, "assets.json"))

    return urllib.parse.urljoin(
        app.static_path,
        assets.get(filename, filename),
    )


def csrf_token(request):
    if not getattr(request, "_csrf", False):
        raise ValueError("CSRF not available")

    return markupsafe.Markup(
        "<input type=hidden name=csrf_token value=\"{}\">".format(
            markupsafe.escape(request._session["user.csrf"]),
        )
    )

########NEW FILE########
__FILENAME__ = http
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from werkzeug.datastructures import ResponseCacheControl
from werkzeug.http import parse_cache_control_header
from werkzeug.wrappers import (
    BaseRequest, AcceptMixin, ETagRequestMixin, UserAgentMixin,
    AuthorizationMixin, CommonRequestDescriptorsMixin,
    BaseResponse, ETagResponseMixin, ResponseStreamMixin,
    CommonResponseDescriptorsMixin, WWWAuthenticateMixin,
)


class Request(BaseRequest, AcceptMixin, ETagRequestMixin,
              UserAgentMixin, AuthorizationMixin,
              CommonRequestDescriptorsMixin):
    """
    Full featured request object implementing the following mixins:

    - :class:`AcceptMixin` for accept header parsing
    - :class:`ETagRequestMixin` for etag and cache control handling
    - :class:`UserAgentMixin` for user agent introspection
    - :class:`AuthorizationMixin` for http auth handling
    - :class:`CommonRequestDescriptorsMixin` for common headers
    """


class Response(BaseResponse, ETagResponseMixin, ResponseStreamMixin,
               CommonResponseDescriptorsMixin,
               WWWAuthenticateMixin):
    """
    Full featured response object implementing the following mixins:

    - :class:`ETagResponseMixin` for etag and cache control handling
    - :class:`ResponseStreamMixin` to add support for the `stream` property
    - :class:`CommonResponseDescriptorsMixin` for various HTTP descriptors
    - :class:`WWWAuthenticateMixin` for HTTP authentication support
    """

    @property
    def surrogate_control(self):
        """
        The Cache-Control general-header field is used to specify
        directives that MUST be obeyed by all caching mechanisms along the
        request/response chain.
        """
        def on_update(surrogate_control):
            if not surrogate_control and "surrogate-control" in self.headers:
                del self.headers["surrogate-control"]
            elif surrogate_control:  # pragma: no cover
                self.headers["Surrogate-Control"] = \
                    surrogate_control.to_header()
        return parse_cache_control_header(
            self.headers.get("surrogate-control"),
            on_update,
            ResponseCacheControl,
        )

########NEW FILE########
__FILENAME__ = middlewares
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from warehouse.http import Request


class LegacyRewriteMiddleware:
    """
    This middleware handles rewriting the legacy URLs and requests in order to
    make it possible to dispatch them to different functions using the standard
    Werkzeug dispatcher.
    """

    def __init__(self, app):
        self.app = app

    def __call__(self, environ, start_response):
        request = Request(environ, populate_request=False, shallow=True)

        # Our Legacy URLs are *always* under /pypi
        if request.path[1:].split("/")[0] == "pypi":
            # if the MIME type of the request is XML then we rewrite to our
            # XMLRPC URL
            if request.headers.get('Content-Type') == 'text/xml':
                environ["PATH_INFO"] = "/_legacy/xmlrpc/"

        return self.app(environ, start_response)

########NEW FILE########
__FILENAME__ = pypi
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import json
import time

from werkzeug.utils import redirect
from werkzeug.exceptions import NotFound, BadRequest

from warehouse import fastly
from warehouse.helpers import url_for
from warehouse.http import Response
from warehouse.legacy import xmlrpc
from warehouse.templates import render_response
from warehouse.utils import cache, cors, is_valid_json_callback_name


_action_methods = {}


def register(name):
    """Register a handler for a legacy :action style dispatch.

    Most of the dispatch in legacy PyPI was implemented using a :action
    parameter in the GET or POST arguments.

    This doesn't actually decorate the function or alter it in any way, it
    simply registers it with the legacy routing mapping.
    """
    if name in _action_methods:
        raise KeyError('Attempt to re-register name %r' % (name, ))

    def deco(fn):
        _action_methods[name] = fn
        return fn
    return deco


def pypi(app, request):
    # check for the legacy :action-style dispatch
    action = request.args.get(':action')
    if action in _action_methods:
        return _action_methods[action](app, request)

    # No :action means we render the index, or at least we redirect to where it
    # moved to
    return redirect(
        url_for(
            request,
            "warehouse.views.index",
        ),
        code=301,
    )


def daytime(app, request):
    response = time.strftime("%Y%m%dT%H:%M:%S\n", time.gmtime(time.time()))
    return Response(response, mimetype="text/plain")


@cors
@cache(browser=1, varnish=120)
@fastly.projects(project_name="project")
def project_json(app, request, project_name, version=None):
    # fail early if callback is invalid
    callback = request.args.get('callback')
    if callback:
        if not is_valid_json_callback_name(callback):
            raise BadRequest('invalid JSONP callback name')

    # Get the real project name for this project
    project = app.db.packaging.get_project(project_name)

    if project is None:
        raise NotFound("{} does not exist".format(project_name))

    # we're looking for the latest version
    versions = app.db.packaging.get_project_versions(project['name'])
    if version is None:
        if not versions:
            raise NotFound("{} has no releases".format(project_name))
        version = versions[0]
    elif version not in versions:
        raise NotFound("{} has no release {}".format(project_name, version))

    rpc = xmlrpc.Interface(app, request)

    d = dict(
        info=rpc.release_data(project['name'], version),
        urls=rpc.release_urls(project['name'], version),
        releases=rpc.all_release_urls(project['name']),
    )
    time_format = '%Y-%m-%dT%H:%M:%S'
    for url in d['urls']:
        url['upload_time'] = url['upload_time'].strftime(time_format)
    for release, urls in d['releases'].items():
        for url in urls:
            url['upload_time'] = url['upload_time'].strftime(time_format)

    data = json.dumps(d, sort_keys=True)

    # write the JSONP extra crap if necessary
    if callback:
        data = '/**/ %s(%s);' % (callback, data)

    serial = app.db.packaging.get_last_serial()

    response = Response(data, mimetype="application/json")
    response.headers['Content-Disposition'] = 'inline'
    response.headers.add("X-PyPI-Last-Serial", serial)
    return response


@register('rss')
@cache(browser=1, varnish=120)
@fastly.rss
def rss(app, request):
    """Dump the last N days' updates as an RSS feed.
    """
    releases = app.db.packaging.get_recently_updated(num=40)
    for release in releases:
        # TODO update _force_external to _external when Flask-ification is done
        url = url_for(request, 'warehouse.packaging.views.project_detail',
                      project_name=release['name'], version=release['version'],
                      _force_external=True)
        release.update(dict(url=url))

    response = render_response(
        app, request, "legacy/rss.xml",
        description='package updates',
        releases=releases,
        site=app.config.site,
    )
    response.mimetype = 'text/xml; charset=utf-8'
    # TODO: throw in a last-modified header too?
    return response


@register('packages_rss')
@cache(browser=1, varnish=120)
@fastly.rss
def packages_rss(app, request):
    """Dump the last N days' new projects as an RSS feed.
    """
    releases = app.db.packaging.get_recent_projects(num=40)
    for release in releases:
        # TODO update _force_external to _external when Flask-ification is done
        url = url_for(request, 'warehouse.packaging.views.project_detail',
                      project_name=release['name'], _force_external=True)
        release.update(dict(url=url))

    response = render_response(
        app, request, "legacy/rss.xml",
        description='new projects',
        releases=releases,
        site=app.config.site,
    )
    response.mimetype = 'text/xml; charset=utf-8'
    # TODO: throw in a last-modified header too?
    return response

########NEW FILE########
__FILENAME__ = simple
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os.path

from werkzeug.exceptions import NotFound
from werkzeug.security import safe_join
from werkzeug.wsgi import wrap_file

from warehouse import fastly
from warehouse.helpers import url_for
from warehouse.http import Response
from warehouse.templates import render_response
from warehouse.utils import cache, get_mimetype


@cache(browser=1, varnish=120)
def index(app, request):
    projects = app.db.packaging.all_projects()
    resp = render_response(
        app, request, "legacy/simple/index.html",
        projects=projects,
    )

    # Add a header that points to the last serial
    serial = app.db.packaging.get_last_serial()
    resp.headers.add("X-PyPI-Last-Serial", serial)

    return resp


@cache(browser=1, varnish=120)
@fastly.projects(project_name="project")
def project(app, request, project_name):
    # Get the real project name for this project
    project = app.db.packaging.get_project(project_name)

    if project is None:
        raise NotFound("{} does not exist".format(project_name))

    # Generate the Package URLs for the packages we've hosted
    file_urls = app.db.packaging.get_file_urls(project['name'])

    # Determine what the hosting mode is for this package
    hosting_mode = app.db.packaging.get_hosting_mode(project['name'])

    project_urls = []
    if hosting_mode in {"pypi-scrape-crawl", "pypi-scrape"}:
        rel_prefix = "" if hosting_mode == "pypi-scrape-crawl" else "ext-"
        home_rel = "{}homepage".format(rel_prefix)
        download_rel = "{}download".format(rel_prefix)

        # Generate the Homepage and Download URL links
        release_urls = app.db.packaging.get_release_urls(project['name'])
        for version, (home_page, download_url) in release_urls.items():
            if home_page and home_page != "UNKNOWN":
                project_urls.append({
                    "rel": home_rel,
                    "url": home_page,
                    "name": "{} home_page".format(version),
                })

            if download_url and download_url != "UNKNOWN":
                project_urls.append({
                    "rel": download_rel,
                    "url": download_url,
                    "name": "{} download_url".format(version),
                })

    # Fetch the explicitly provided URLs
    external_urls = app.db.packaging.get_external_urls(project['name'])

    resp = render_response(
        app, request,
        "legacy/simple/detail.html",
        project=project['name'],
        files=file_urls,
        project_urls=project_urls,
        external_urls=external_urls,
    )

    # Add a header that points to the last serial
    serial = app.db.packaging.get_last_serial(project['name'])
    resp.headers.add("X-PyPI-Last-Serial", serial)

    # Add a Link header to point at the canonical URL
    can_url = url_for(
        request, "warehouse.legacy.simple.project",
        project_name=project['name'],
        _force_external=True,
    )
    resp.headers.add("Link", "<" + can_url + ">", rel="canonical")

    return resp


@cache(browser=1, varnish=120)
def package(app, request, path):
    # Get our filename and filepath from the request path
    filename = os.path.basename(path)
    filepath = safe_join(
        os.path.abspath(app.config.paths.packages),
        path
    )

    # If we cannot safely join the requested path with our directory
    #   return a 404
    if filepath is None:
        raise NotFound("{} was not found".format(filename))

    # Open the file and attempt to wrap in the wsgi.file_wrapper if it's
    #   available, otherwise read it directly.
    try:
        fp = open(filepath, "rb")
        data = wrap_file(request.environ, fp)
    except IOError:
        raise NotFound("{} was not found".format(filename))

    # Get the project name and normalize it
    lookup_filename = filename[:-4] if filename.endswith(".asc") else filename
    project = app.db.packaging.get_project_for_filename(lookup_filename)

    # Get the MD5 hash of the file
    content_md5 = app.db.packaging.get_filename_md5(filename)

    headers = {}

    # Add in additional headers if we're using Fastly
    headers["Surrogate-Key"] = " ".join(
        fastly.projects.format_keys(project=project),
    )

    # Look up the last serial for this file
    serial = app.db.packaging.get_last_serial(project)
    if serial is not None:
        headers["X-PyPI-Last-Serial"] = serial

    # Pass through the data directly to the response object
    resp = Response(
        data,
        headers=headers,
        mimetype=get_mimetype(filename),
        direct_passthrough=True,
    )

    # Setup the Last-Modified header
    resp.last_modified = os.path.getmtime(filepath)

    # Setup the Content-Length header
    resp.content_length = os.path.getsize(filepath)

    if content_md5:
        # Setup the Content-MD5 headers
        resp.content_md5 = content_md5

        # Setup Conditional Responses
        resp.set_etag(content_md5)
        resp.make_conditional(request)

    return resp

########NEW FILE########
__FILENAME__ = urls
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from werkzeug.routing import Rule, EndpointPrefix, Submount

urls = [
    EndpointPrefix("warehouse.legacy.simple.", [
        Submount("/simple", [
            Rule("/", methods=["GET"], endpoint="index"),
            Rule("/<project_name>/", methods=["GET"], endpoint="project"),
        ]),
        Rule("/packages/<path:path>", methods=["GET"], endpoint="package"),
    ]),
    EndpointPrefix("warehouse.legacy.pypi.", [
        Rule("/pypi", methods=["GET", "POST"], endpoint="pypi"),
        Rule("/pypi/<project_name>/json", methods=["GET"],
             endpoint="project_json"),
        Rule("/pypi/<project_name>/<version>/json", methods=["GET"],
             endpoint="project_json"),
        Rule("/daytime", methods=["GET"], endpoint="daytime"),
    ]),
    EndpointPrefix("warehouse.legacy.xmlrpc.", [
        Rule("/_legacy/xmlrpc/", methods=["POST"], endpoint="handler"),
    ]),
]

########NEW FILE########
__FILENAME__ = xmlrpc
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from xmlrpc.server import SimpleXMLRPCDispatcher

import arrow

from werkzeug.exceptions import BadRequest

from warehouse.csrf import csrf_exempt
from warehouse.http import Response


@csrf_exempt
def handler(app, request):
    '''Wrap an invocation of the XML-RPC dispatcher.
    '''
    # unicode strings will be encoded in utf-8 by xmlrpclib
    dispatcher = SimpleXMLRPCDispatcher()
    dispatcher.register_instance(Interface(app, request))

    # read in the XML-RPC request data, limiting to a sensible size
    if int(request.headers['Content-Length']) > 10 * 1024 * 1024:
        raise BadRequest('request data too large')
    xml_request = request.get_data(cache=False, as_text=True)

    # errors here are handled by _marshaled_dispatch
    response = dispatcher._marshaled_dispatch(xml_request)

    # legacy; remove non-printable ASCII control codes from the response
    # RJ: disabled this as it's a giant, unreliable hack that doesn't work and
    # I can't even remember why it's in here to start with
    # response = re.sub('([\x00-\x08]|[\x0b-\x0c]|[\x0e-\x1f])+', '', response)

    return Response(response, mimetype="text/xml; charset=utf-8")


class Interface(object):
    def __init__(self, app, request):
        self.app = app
        self.request = request

    def list_packages(self):
        return self.app.db.packaging.all_projects()

    def list_packages_with_serial(self):
        return self.app.db.packaging.get_projects_with_serial()

    def top_packages(self, num=None):
        return self.app.db.packaging.get_top_projects(num)

    def user_packages(self, user):
        result = self.app.db.packaging.get_roles_for_user(user)
        return [[r['package_name'], r['role_name']] for r in result]

    def package_releases(self, name, show_hidden=False):
        return self.app.db.packaging.get_project_versions(name)

    def package_roles(self, name):
        result = self.app.db.packaging.get_roles_for_project(name)
        return [[r['user_name'], r['role_name']] for r in result]

    def package_hosting_mode(self, name):
        return self.app.db.packaging.get_hosting_mode(name)

    def updated_releases(self, since):
        since = arrow.get(since).datetime
        result = self.app.db.packaging.get_releases_since(since)
        return [[row['name'], row['version']] for row in result]

    def changed_packages(self, since):
        since = arrow.get(since).datetime
        return self.app.db.packaging.get_changed_since(since)

    def changelog(self, since, with_ids=False):
        since = arrow.get(since).datetime
        result = self.app.db.packaging.get_changelog(since)
        keys = ['name', 'version', 'submitted_date', 'action']
        if with_ids:
            keys.append('id')
        mapped = []
        for row in result:
            row['submitted_date'] = arrow.get(row['submitted_date']).timestamp
            mapped.append(list(row[key] for key in keys))
        return mapped

    def changelog_last_serial(self):
        return self.app.db.packaging.get_last_changelog_serial()

    def changelog_since_serial(self, since):
        result = self.app.db.packaging.get_changelog_serial(since)
        keys = ['name', 'version', 'submitted_date', 'action', 'id']
        mapped = []
        for row in result:
            row['submitted_date'] = arrow.get(row['submitted_date']).timestamp
            mapped.append(list(row[key] for key in keys))
        return mapped

    def release_urls(self, name, version):
        l = []
        for r in self.app.db.packaging.get_downloads(name, version):
            l.append(dict(
                url=r['url'],
                packagetype=r['packagetype'],
                filename=r['filename'],
                size=r['size'],
                md5_digest=r['md5_digest'],
                downloads=r['downloads'],
                has_sig=r['pgp_url'] is not None,
                python_version=r['python_version'],
                comment_text=r['comment_text'],
                upload_time=r['upload_time'],
            ))
        return l

    def all_release_urls(self, name):
        d = {}
        for version in self.app.db.packaging.get_project_versions(name):
            d[version] = self.release_urls(name, version)
        return d

    def release_downloads(self, name, version):
        results = self.app.db.packaging.get_downloads(name, version)
        return [[r['filename'], r['downloads']] for r in results]

    def release_data(self, name, version):
        db = self.app.db.packaging
        try:
            info = db.get_release(name, version)
        except IndexError:
            # the CURRENT model code will raise an IndexError on missing
            # package but this should be altered
            return {}

        info['stable_version'] = ''     # legacy; never actually correct
        info['classifiers'] = db.get_classifiers(name, version)
        info['package_url'] = 'http://pypi.python.org/pypi/%s' % name
        info['release_url'] = 'http://pypi.python.org/pypi/%s/%s' % (name,
                                                                     version)
        info['docs_url'] = db.get_documentation_url(name)
        info['downloads'] = db.get_download_counts(name)

        # XML-RPC has no datetime; work only with UNIX timestamps
        info['created'] = arrow.get(info['created']).timestamp

        # make the data XML-RPC-happy (no explicit null allowed here!)
        for k in info:
            if info[k] is None:
                info[k] = ''

        return info

    def browse(self, categories):
        if not isinstance(categories, list):
            raise TypeError("Parameter categories must be a list")

        db = self.app.db.packaging
        classifier_ids = db.get_classifier_ids(categories)
        if len(classifier_ids) != len(categories):
            missing = list(set(categories) - set(classifier_ids))
            missing = ', '.join("%s" % c for c in missing)
            raise ValueError('Unknown classifier(s): ' + missing)

        return db.search_by_classifier(set(classifier_ids.values()))

    def search(self, spec, operator="and"):
        if operator == "and":
            query = {"match": {}}
            for field, value in spec.items():
                if not isinstance(value, str):
                    value = " ".join(value)
                query["match"][field] = value
        elif operator == "or":
            query = {"bool": {"should": []}}
            for field, values in spec.items():
                if isinstance(values, str):
                    values = [values]
                query["bool"]["should"] += [
                    {"match": {field: {"query": value}}} for value in values
                ]
        else:
            raise TypeError("operator must be 'and' or 'or'")

        hits = []
        from_ = 0
        while True:
            results = self.app.search.es.search(
                index=self.app.search._index,
                doc_type=self.app.search.types.project._type,
                body={"query": query, "from": from_, "size": 1000},
            )

            hits.extend(
                {
                    "name": x["_source"]["name"] or "",
                    "version": x["_source"]["version"] or "",
                    "summary": x["_source"]["summary"] or "",
                    "_pypi_ordering": 0,
                }
                for x in results["hits"]["hits"]
            )

            from_ += 1000

            if len(hits) >= results["hits"]["total"]:
                break

        return hits

########NEW FILE########
__FILENAME__ = middlewares
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import hmac


class XForwardedTokenMiddleware:

    header = "HTTP_X_WAREHOUSE_ACCESS_TOKEN"

    def __init__(self, app, token):
        self.app = app
        self.token = token

    def __call__(self, environ, start_response):
        # Filter out X-Forwarded-* headers from the request if the secret token
        # does not exist or does not match.
        if not hmac.compare_digest(environ.pop(self.header, ""), self.token):
            for key in set(environ.keys()):
                if key.startswith("HTTP_X_FORWARDED_"):
                    del environ[key]

        return self.app(environ, start_response)

########NEW FILE########
__FILENAME__ = cli
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import alembic.config
import alembic.command


class AlembicCommand(object):

    def __call__(self, app, *args, **kwargs):
        cfg = self._create_alembic_config(app)
        return self.command.__func__(cfg, *args, **kwargs)

    def _create_alembic_config(self, app):
        alembic_cfg = alembic.config.Config()
        alembic_cfg.set_main_option(
            "script_location",
            "warehouse:migrations",
        )
        alembic_cfg.set_main_option("url", app.config.database.url)

        return alembic_cfg


class BranchesCommand(AlembicCommand):

    command = alembic.command.branches


class CurrentCommand(AlembicCommand):

    command = alembic.command.current

    def create_parser(self, parser):
        parser.add_argument(
            "--head-only",
            action="store_true",
            dest="head_only",
            help=("Only show current version and whether or not this is the "
                  "head revision."),
        )


class DowngradeCommand(AlembicCommand):

    command = alembic.command.downgrade

    def create_parser(self, parser):
        parser.add_argument(
            "revision",
            help="revision identifier",
        )


class HistoryCommand(AlembicCommand):

    command = alembic.command.history

    def create_parser(self, parser):
        parser.add_argument(
            "-r", "--rev-range",
            dest="rev_range",
            help="Specify a revision range; format is [start]:[end]",
        )


class RevisionCommand(AlembicCommand):

    command = alembic.command.revision

    def create_parser(self, parser):
        parser.add_argument(
            "-m", "--message",
            dest="message",
            help="Message string to use with 'revision'",
        )
        parser.add_argument(
            "-a", "--autogenerate",
            action="store_true",
            dest="autogenerate",
            help=("Populate revision script with candidate migration "
                  "operations, based on comparison of database to model."),
        )


class StampCommand(AlembicCommand):

    command = alembic.command.stamp

    def create_parser(self, parser):
        parser.add_argument("revision", help="revision identifier")


class UpgradeCommand(AlembicCommand):

    command = alembic.command.upgrade

    def create_parser(self, parser):
        parser.add_argument("revision", help="revision identifier")


__commands__ = {
    "branches": BranchesCommand(),
    "current": CurrentCommand(),
    "downgrade": DowngradeCommand(),
    "history": HistoryCommand(),
    "revision": RevisionCommand(),
    "stamp": StampCommand(),
    "upgrade": UpgradeCommand(),
}

########NEW FILE########
__FILENAME__ = env
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from alembic import context
from sqlalchemy import create_engine, pool

from warehouse import db


# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = db.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline():
    """
    Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.
    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(url=url)

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """
    Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.
    """
    options = config.get_section(config.config_ini_section)
    url = options.pop("url")
    engine = create_engine(url, poolclass=pool.NullPool)

    connection = engine.connect()
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    try:
        with context.begin_transaction():
            context.run_migrations()
    finally:
        connection.close()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

########NEW FILE########
__FILENAME__ = 23515b7500af_add_an_index_on_rele
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Add an index on (releases.name, releases.created)

Revision ID: 23515b7500af
Revises: 3175e1bdb1b5
Create Date: 2013-10-31 10:51:16.152183
"""

# revision identifiers, used by Alembic.
revision = '23515b7500af'
down_revision = '3175e1bdb1b5'

from alembic import op


def upgrade():
    op.execute(
        "CREATE INDEX release_name_created_idx ON releases(name, created DESC)"
    )


def downgrade():
    op.drop_index("release_name_created_idx")

########NEW FILE########
__FILENAME__ = 27f10b4acd27_added_download_statistics_table
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Added download_statistics table

Revision ID: 27f10b4acd27
Revises: 23515b7500af
Create Date: 2014-01-01 14:20:04.899624
"""

# revision identifiers, used by Alembic.
revision = '27f10b4acd27'
down_revision = '23515b7500af'

from alembic import op

import sqlalchemy as sa
from sqlalchemy.dialects import postgresql
from sqlalchemy.sql import func


def upgrade():
    op.create_table('downloads',
        sa.Column(
            'id',
            postgresql.UUID(),
            server_default=func.uuid_generate_v4(),
            nullable=False
        ),
        sa.Column('package_name', sa.UnicodeText(), nullable=False),
        sa.Column('package_version', sa.UnicodeText(), nullable=True),
        sa.Column(
            'distribution_type',
            sa.Enum(
                u'sdist',
                u'wheel',
                u'exe',
                u'egg',
                u'msi',
                name='distribution_type'
            ),
            nullable=True
        ),
        sa.Column(
            'python_type',
            sa.Enum(
                u'cpython',
                u'pypy',
                u'jython',
                u'ironpython',
                name='python_type'
            ),
            nullable=True
        ),
        sa.Column('python_release', sa.Text(), nullable=True),
        sa.Column('python_version', sa.Text(), nullable=True),
        sa.Column(
            'installer_type',
            sa.Enum(
                u'browser',
                u'pip',
                u'setuptools',
                u'distribute',
                u'bandersnatch',
                u'z3c.pypimirror',
                u'pep381client',
                name='installer_type'
            ),
            nullable=True
        ),
        sa.Column('installer_version', sa.Text(), nullable=True),
        sa.Column('operating_system', sa.Text(), nullable=True),
        sa.Column('operating_system_version', sa.Text(), nullable=True),
        sa.Column('download_time', sa.DateTime(), nullable=False),
        sa.Column('raw_user_agent', sa.Text(), nullable=False),
        sa.PrimaryKeyConstraint('id')
    )


def downgrade():
    op.drop_table('downloads')

########NEW FILE########
__FILENAME__ = 3175e1bdb1b5_disable_timezone_supp
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Disable timezone support

Revision ID: 3175e1bdb1b5
Revises: 47e27f268fc2
Create Date: 2013-10-30 21:57:31.502797
"""

# revision identifiers, used by Alembic.
revision = '3175e1bdb1b5'
down_revision = '47e27f268fc2'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.alter_column("accounts_user", "last_login", type_=sa.DateTime())
    op.alter_column("accounts_user", "date_joined", type_=sa.DateTime())


def downgrade():
    op.alter_column(
        "accounts_user", "last_login",
        type_=sa.DateTime(timezone=True),
    )
    op.alter_column(
        "accounts_user", "date_joined",
        type_=sa.DateTime(timezone=True),
    )

########NEW FILE########
__FILENAME__ = 47e27f268fc2_clean_up_the_user_ac
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Clean up the user accounts somewhat

Revision ID: 47e27f268fc2
Revises: 4cdc5a748370
Create Date: 2013-10-28 20:57:14.210704
"""

# revision identifiers, used by Alembic.
revision = '47e27f268fc2'
down_revision = '4cdc5a748370'

import sqlalchemy as sa

from alembic import op
from sqlalchemy.dialects import postgresql


def upgrade():
    op.alter_column(
        "accounts_user",
        "date_joined",
        existing_type=postgresql.TIMESTAMP(timezone=True),
        nullable=True,
        server_default=sa.func.now(),
    )

    # Set anything with a -infinity date_joined to NULL
    op.execute("""
        UPDATE accounts_user
        SET date_joined = NULL
        WHERE date_joined = '-infinity'
    """)


def downgrade():
    # Set anything with a NULL date to -infinity
    op.execute("""
        UPDATE accounts_user
        SET date_joined = NULL
        WHERE date_joined = '-infinity'
    """)

    op.alter_column(
        "accounts_user",
        "date_joined",
        existing_type=postgresql.TIMESTAMP(timezone=True),
        nullable=False,
    )

########NEW FILE########
__FILENAME__ = 4c8b2dd27587_use_the_real_names_f
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Use the real names for distribution types

Revision ID: 4c8b2dd27587
Revises: 55eda9672691
Create Date: 2014-01-11 22:17:16.139038
"""

# revision identifiers, used by Alembic.
revision = '4c8b2dd27587'
down_revision = '55eda9672691'

from alembic import op


def upgrade():
    op.execute(
        """ ALTER TABLE downloads
            ALTER COLUMN distribution_type
                TYPE text USING distribution_type::text
        """
    )
    op.execute("DROP TYPE distribution_type")
    op.execute(
        """ UPDATE downloads
            SET distribution_type = 'bdist_egg'
            WHERE distribution_type = 'egg'
        """
    )
    op.execute(
        """ UPDATE downloads
            SET distribution_type = 'bdist_msi'
            WHERE distribution_type = 'msi'
        """
    )
    op.execute(
        """ UPDATE downloads
            SET distribution_type = 'bdist_wheel'
            WHERE distribution_type = 'wheel'
        """
    )
    op.execute(
        """ UPDATE downloads
            SET distribution_type = 'bdist_wininst'
            WHERE distribution_type = 'exe'
        """
    )
    op.execute(
        """ CREATE TYPE distribution_type AS ENUM
            (
                'bdist_dmg',
                'bdist_dumb',
                'bdist_egg',
                'bdist_msi',
                'bdist_rpm',
                'bdist_wheel',
                'bdist_wininst',
                'sdist'
            )
        """
    )
    op.execute(
        """ ALTER TABLE downloads
            ALTER COLUMN distribution_type
                TYPE distribution_type
                USING distribution_type::distribution_type
        """
    )


def downgrade():
    raise RuntimeError("This migration cannot be downgraded")

########NEW FILE########
__FILENAME__ = 4cdc5a748370_add_created_column_t
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Add created column to packages and releases table

Revision ID: 4cdc5a748370
Revises: 77e04097be5
Create Date: 2013-10-24 20:41:22.847711
"""

# revision identifiers, used by Alembic.
revision = "4cdc5a748370"
down_revision = "77e04097be5"

from alembic import op
import sqlalchemy as sa

from warehouse.packaging.tables import packages


def upgrade():
    # Migrate Schema
    op.add_column(
        "packages",
        sa.Column("created", sa.DateTime(), nullable=True),
    )
    op.alter_column("packages", "created", server_default=sa.func.now())

    op.add_column(
        "releases",
        sa.Column("created", sa.DateTime(), nullable=True),
    )
    op.alter_column("releases", "created", server_default=sa.func.now())

    # Backfill data
    op.execute("""
        UPDATE packages AS pkg
        SET created = j.submitted_date
        FROM (
            SELECT name, submitted_date
            FROM journals
            WHERE action = 'create'
        ) j
        WHERE j.name = pkg.name
    """)

    op.execute("""
        UPDATE releases AS r
        SET created = j.submitted_date
        FROM (
            SELECT name, version, max(submitted_date) submitted_date
            FROM journals
            WHERE action = 'new release'
            GROUP BY name, version
        ) j
        WHERE j.name = r.name AND j.version = r.version
    """)

    # Clean up Invalid Data
    op.execute(
        "UPDATE packages SET created = '-infinity' WHERE created IS NULL"
    )
    op.execute(
        "UPDATE releases SET created = '-infinity' WHERE created IS NULL"
    )

    # Modify tables so NULLs are not allowed
    op.alter_column("packages", "created", nullable=False)
    op.alter_column("releases", "created", nullable=False)


def downgrade():
    op.drop_column("packages", "created")
    op.drop_column("releases", "created")

########NEW FILE########
__FILENAME__ = 55eda9672691_added_devpi_to_installer_type_enum
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Added devpi to installer_type enum

Revision ID: 55eda9672691
Revises: 27f10b4acd27
Create Date: 2014-01-05 19:30:18.451636
"""

# revision identifiers, used by Alembic.
revision = '55eda9672691'
down_revision = '27f10b4acd27'

from alembic import op


def upgrade():
    op.execute("COMMIT")  # See https://bitbucket.org/zzzeek/alembic/issue/123
    op.execute("""ALTER TYPE installer_type ADD VALUE 'devpi'""")


def downgrade():
    raise RuntimeError("This migration cannot be downgraded")

########NEW FILE########
__FILENAME__ = 77e04097be5_import_initial_datab
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Import initial database layout from PyPI

Revision ID: 77e04097be5
Revises: None
Create Date: 2013-09-22 15:11:30.966213
"""

# revision identifiers, used by Alembic.
revision = "77e04097be5"
down_revision = None

import sqlalchemy as sa

from alembic import op
from citext import CIText
from sqlalchemy.dialects.postgresql import BYTEA


def upgrade():
    op.create_table("timestamps",
        sa.Column("name", sa.TEXT(), primary_key=True, nullable=False),
        sa.Column("value", sa.TIMESTAMP()),
    )

    op.create_table("accounts_user",
        sa.Column("id", sa.INTEGER(), primary_key=True, nullable=False),
        sa.Column("password", sa.VARCHAR(length=128), nullable=False),
        sa.Column("last_login", sa.TIMESTAMP(timezone=True), nullable=False),
        sa.Column("is_superuser", sa.BOOLEAN(), nullable=False),
        sa.Column("username", CIText(), nullable=False, unique=True),
        sa.Column("name", sa.VARCHAR(length=100), nullable=False),
        sa.Column("is_staff", sa.BOOLEAN(), nullable=False),
        sa.Column("is_active", sa.BOOLEAN(), nullable=False),
        sa.Column("date_joined", sa.TIMESTAMP(timezone=True), nullable=False),
    )

    op.create_check_constraint("accounts_user_username_length",
        "accounts_user",
        sa.text("length(username) <= 50"),
    )

    op.create_check_constraint("accounts_user_valid_username",
        "accounts_user",
        sa.text("username ~* '^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$'"),
    )

    op.create_table("cookies",
        sa.Column("cookie", sa.TEXT(), primary_key=True, nullable=False),
        sa.Column("name",
            CIText(),
            sa.ForeignKey("accounts_user.username",
                onupdate="CASCADE",
                ondelete="CASCADE",
            ),
        ),
        sa.Column("last_seen", sa.TIMESTAMP()),
    )

    op.create_index("cookies_last_seen", "cookies", ["last_seen"])

    op.create_table("oauth_consumers",
        sa.Column("consumer",
            sa.VARCHAR(length=32),
            primary_key=True,
            nullable=False,
        ),
        sa.Column("secret", sa.VARCHAR(length=64), nullable=False),
        sa.Column("date_created", sa.DATE(), nullable=False),
        sa.Column("created_by",
            CIText(),
            sa.ForeignKey("accounts_user.username", onupdate="CASCADE"),
        ),
        sa.Column("last_modified", sa.DATE(), nullable=False),
        sa.Column("description", sa.VARCHAR(length=255), nullable=False),
    )

    op.create_table("cheesecake_main_indices",
        sa.Column("id", sa.INTEGER(), primary_key=True, nullable=False),
        sa.Column("absolute", sa.INTEGER(), nullable=False),
        sa.Column("relative", sa.INTEGER(), nullable=False),
    )

    op.create_table("packages",
        sa.Column("name", sa.TEXT(), primary_key=True, nullable=False),
        sa.Column("stable_version", sa.TEXT()),
        sa.Column("normalized_name", sa.TEXT()),
        sa.Column("autohide", sa.BOOLEAN(), server_default=sa.text("TRUE")),
        sa.Column("comments", sa.BOOLEAN(), server_default=sa.text("TRUE")),
        sa.Column("bugtrack_url", sa.TEXT()),
        sa.Column("hosting_mode", sa.TEXT(),
            nullable=False,
            server_default="pypi-explicit",
        ),
    )

    op.create_check_constraint("packages_valid_name",
        "packages",
        sa.text("name ~* '^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$'"),
    )

    op.create_table("releases",
        sa.Column("name",
            sa.TEXT(),
            sa.ForeignKey("packages.name", onupdate="CASCADE"),
            primary_key=True,
            nullable=False,
        ),
        sa.Column("version", sa.TEXT(), primary_key=True, nullable=False),
        sa.Column("author", sa.TEXT()),
        sa.Column("author_email", sa.TEXT()),
        sa.Column("maintainer", sa.TEXT()),
        sa.Column("maintainer_email", sa.TEXT()),
        sa.Column("home_page", sa.TEXT()),
        sa.Column("license", sa.TEXT()),
        sa.Column("summary", sa.TEXT()),
        sa.Column("description", sa.TEXT()),
        sa.Column("keywords", sa.TEXT()),
        sa.Column("platform", sa.TEXT()),
        sa.Column("download_url", sa.TEXT()),
        sa.Column("_pypi_ordering", sa.INTEGER()),
        sa.Column("_pypi_hidden", sa.BOOLEAN()),
        sa.Column("description_html", sa.TEXT()),
        sa.Column("cheesecake_installability_id",
            sa.INTEGER(),
            sa.ForeignKey("cheesecake_main_indices.id"),
        ),
        sa.Column("cheesecake_documentation_id",
            sa.INTEGER(),
            sa.ForeignKey("cheesecake_main_indices.id"),
        ),
        sa.Column("cheesecake_code_kwalitee_id",
            sa.INTEGER(),
            sa.ForeignKey("cheesecake_main_indices.id"),
        ),
        sa.Column("requires_python", sa.TEXT()),
        sa.Column("description_from_readme", sa.BOOLEAN()),
    )

    op.create_index("release_name_idx", "releases", ["name"])

    op.create_index("release_version_idx", "releases", ["version"])

    op.create_index("release_pypi_hidden_idx", "releases", ["_pypi_hidden"])

    op.create_table("release_dependencies",
        sa.Column("name", sa.TEXT()),
        sa.Column("version", sa.TEXT()),
        sa.Column("kind", sa.INTEGER()),
        sa.Column("specifier", sa.TEXT()),
    )

    op.create_index("rel_dep_name_idx", "release_dependencies", ["name"])

    op.create_index("rel_dep_name_version_idx",
        "release_dependencies",
        ["name", "version"],
    )

    op.create_index("rel_dep_name_version_kind_idx",
        "release_dependencies",
        ["name", "version", "kind"],
    )

    op.create_foreign_key(
        None,
        "release_dependencies",
        "releases",
        ["name", "version"],
        ["name", "version"],
        onupdate="CASCADE",
    )

    op.create_table("ratings",
        sa.Column("name", sa.TEXT(), nullable=False),
        sa.Column("version", sa.TEXT(), nullable=False),
        sa.Column("user_name",
            CIText(),
            sa.ForeignKey("accounts_user.username", ondelete="CASCADE"),
            nullable=False,
        ),
        sa.Column("date", sa.TIMESTAMP()),
        sa.Column("rating", sa.INTEGER()),
        sa.Column("id", sa.INTEGER(), primary_key=True, nullable=False),
    )

    op.create_unique_constraint("ratings_id_key", "ratings", ["id"])

    op.create_unique_constraint("ratings_name_key",
        "ratings",
        ["name", "version", "user_name"],
    )

    op.create_foreign_key(
        None,
        "ratings",
        "releases",
        ["name", "version"],
        ["name", "version"],
        onupdate="CASCADE",
        ondelete="CASCADE",
    )

    op.create_index("rating_name_version", "ratings", ["name", "version"])

    op.create_table("comments",
        sa.Column("id", sa.INTEGER(), primary_key=True, nullable=False),
        sa.Column("rating",
            sa.INTEGER(),
            sa.ForeignKey("ratings.id",
                ondelete="CASCADE",
            ),
        ),
        sa.Column("user_name",
            CIText(),
            sa.ForeignKey("accounts_user.username", ondelete="CASCADE"),
        ),
        sa.Column("date", sa.TIMESTAMP()),
        sa.Column("message", sa.TEXT()),
        sa.Column("in_reply_to",
            sa.INTEGER(),
            sa.ForeignKey("comments.id",
                ondelete="CASCADE",
            ),
        ),
    )

    op.create_table("oauth_access_tokens",
        sa.Column("token",
            sa.VARCHAR(length=32),
            primary_key=True,
            nullable=False,
        ),
        sa.Column("secret", sa.VARCHAR(length=64), nullable=False),
        sa.Column("consumer", sa.VARCHAR(length=32), nullable=False),
        sa.Column("date_created", sa.DATE(), nullable=False),
        sa.Column("last_modified", sa.DATE(), nullable=False),
        sa.Column("user_name",
            CIText(),
            sa.ForeignKey("accounts_user.username",
                onupdate="CASCADE",
                ondelete="CASCADE",
            ),
        ),
    )

    op.create_table("openid_nonces",
        sa.Column("created", sa.TIMESTAMP()),
        sa.Column("nonce", sa.TEXT()),
    )

    op.create_index("openid_nonces_created", "openid_nonces", ["created"])

    op.create_index("openid_nonces_nonce", "openid_nonces", ["nonce"])

    op.create_table("openid_sessions",
        sa.Column("id", sa.INTEGER(), primary_key=True, nullable=False),
        sa.Column("url", sa.TEXT()),
        sa.Column("assoc_handle", sa.TEXT()),
        sa.Column("expires", sa.TIMESTAMP()),
        sa.Column("mac_key", sa.TEXT()),
    )

    op.create_table("oauth_request_tokens",
        sa.Column("token",
            sa.VARCHAR(length=32),
            primary_key=True,
            nullable=False,
        ),
        sa.Column("secret", sa.VARCHAR(length=64), nullable=False),
        sa.Column("consumer", sa.VARCHAR(length=32), nullable=False),
        sa.Column("callback", sa.TEXT()),
        sa.Column("date_created", sa.DATE(), nullable=False),
        sa.Column("user_name",
            CIText(),
            sa.ForeignKey("accounts_user.username",
                onupdate="CASCADE",
                ondelete="CASCADE",
            ),
        ),
    )

    op.create_table("oid_nonces",
        sa.Column("server_url",
            sa.VARCHAR(length=2047),
            primary_key=True,
            nullable=False,
        ),
        sa.Column("timestamp",
            sa.INTEGER(),
            autoincrement=False,
            primary_key=True,
            nullable=False,
        ),
        sa.Column("salt",
            sa.CHAR(length=40),
            primary_key=True,
            nullable=False,
        ),
    )

    op.create_table("mirrors",
        sa.Column("ip", sa.TEXT(), primary_key=True, nullable=False),
        sa.Column("user_name",
            CIText(),
            sa.ForeignKey("accounts_user.username"),
        ),
        sa.Column("index_url", sa.TEXT()),
        sa.Column("last_modified_url", sa.TEXT()),
        sa.Column("local_stats_url", sa.TEXT()),
        sa.Column("stats_url", sa.TEXT()),
        sa.Column("mirrors_url", sa.TEXT()),
    )

    op.create_table("trove_classifiers",
        sa.Column("id",
            sa.INTEGER(),
            autoincrement=False,
            primary_key=True,
            nullable=False,
        ),
        sa.Column("classifier", sa.TEXT()),
        sa.Column("l2", sa.INTEGER()),
        sa.Column("l3", sa.INTEGER()),
        sa.Column("l4", sa.INTEGER()),
        sa.Column("l5", sa.INTEGER()),
    )

    op.create_index("trove_class_class_idx",
        "trove_classifiers",
        ["classifier"],
    )

    op.create_index("trove_class_id_idx", "trove_classifiers", ["id"])

    op.create_unique_constraint("trove_classifiers_classifier_key",
        "trove_classifiers",
        ["classifier"],
    )

    op.create_table("roles",
        sa.Column("role_name", sa.TEXT()),
        sa.Column("user_name",
            CIText(),
            sa.ForeignKey("accounts_user.username", onupdate="CASCADE"),
        ),
        sa.Column("package_name",
            sa.TEXT(),
            sa.ForeignKey("packages.name", onupdate="CASCADE"),
        ),
    )

    op.create_index("roles_pack_name_idx", "roles", ["package_name"])

    op.create_index("roles_user_name_idx", "roles", ["user_name"])

    op.create_table("release_requires_python",
        sa.Column("name", sa.TEXT()),
        sa.Column("version", sa.TEXT()),
        sa.Column("specifier", sa.TEXT()),
    )

    op.create_foreign_key(
        None,
        "release_requires_python",
        "releases",
        ["name", "version"],
        ["name", "version"],
        onupdate="CASCADE",
    )

    op.create_index("rel_req_python_name_idx",
        "release_requires_python",
        ["name"],
    )

    op.create_index("rel_req_python_name_version_idx",
        "release_requires_python",
        ["name", "version"],
    )

    op.create_index("rel_req_python_version_id_idx",
        "release_requires_python",
        ["version"],
    )

    op.create_table("browse_tally",
        sa.Column("trove_id",
            sa.INTEGER(),
            autoincrement=False,
            primary_key=True,
            nullable=False,
        ),
        sa.Column("tally", sa.INTEGER()),
    )

    op.create_table("dual",
        sa.Column("dummy", sa.INTEGER()),
    )

    op.create_table("release_urls",
        sa.Column("name", sa.TEXT()),
        sa.Column("version", sa.TEXT()),
        sa.Column("url", sa.TEXT()),
        sa.Column("packagetype", sa.TEXT()),
    )

    op.create_foreign_key(
        None,
        "release_urls",
        "releases",
        ["name", "version"],
        ["name", "version"],
        onupdate="CASCADE",
    )

    op.create_index("release_urls_name_idx", "release_urls", ["name"])

    op.create_index("release_urls_packagetype_idx",
        "release_urls",
        ["packagetype"],
    )

    op.create_index("release_urls_version_idx", "release_urls", ["version"])

    op.create_table("description_urls",
        sa.Column("name", sa.TEXT()),
        sa.Column("version", sa.TEXT()),
        sa.Column("url", sa.TEXT()),
        sa.Column("id", sa.INTEGER(), primary_key=True, nullable=False),
    )

    op.create_index("description_urls_name_idx", "description_urls", ["name"])

    op.create_index("description_urls_name_version_idx",
        "description_urls",
        ["name", "version"],
    )

    op.create_foreign_key(
        None,
        "description_urls",
        "releases",
        ["name", "version"],
        ["name", "version"],
        onupdate="CASCADE",
    )

    op.create_table("oauth_nonce",
        sa.Column("timestamp", sa.INTEGER(), nullable=False),
        sa.Column("consumer", sa.VARCHAR(length=32), nullable=False),
        sa.Column("nonce", sa.VARCHAR(length=32), nullable=False),
        sa.Column("token", sa.VARCHAR(length=32)),
    )

    op.create_table("journals",
        sa.Column("name", sa.TEXT()),
        sa.Column("version", sa.TEXT()),
        sa.Column("action", sa.TEXT()),
        sa.Column("submitted_date", sa.TIMESTAMP()),
        sa.Column("submitted_by",
            CIText(),
            sa.ForeignKey("accounts_user.username", onupdate="CASCADE"),
        ),
        sa.Column("submitted_from", sa.TEXT()),
    )
    op.execute("ALTER TABLE journals ADD COLUMN id SERIAL")

    op.create_index("journals_name_idx", "journals", ["name"])

    op.create_index("journals_changelog",
        "journals",
        ["submitted_date", "name", "version", "action"],
    )

    op.create_index("journals_latest_releases",
        "journals",
        ["submitted_date", "name", "version"],
    )

    op.create_index("journals_version_idx", "journals", ["version"])

    op.create_table("rego_otk",
        sa.Column("name",
            CIText(),
            sa.ForeignKey("accounts_user.username", ondelete="CASCADE"),
        ),
        sa.Column("otk", sa.TEXT()),
        sa.Column("date", sa.TIMESTAMP()),
    )

    op.create_index("rego_otk_otk_idx", "rego_otk", ["otk"])

    op.create_index("rego_otk_name_idx", "rego_otk", ["name"])

    op.create_unique_constraint("rego_otk_unique", "rego_otk", ["otk"])

    op.create_table("release_files",
        sa.Column("name", sa.TEXT()),
        sa.Column("version", sa.TEXT()),
        sa.Column("python_version", sa.TEXT()),
        sa.Column("packagetype", sa.TEXT()),
        sa.Column("comment_text", sa.TEXT()),
        sa.Column("filename", sa.TEXT()),
        sa.Column("md5_digest", sa.TEXT()),
        sa.Column("downloads", sa.INTEGER(), server_default=sa.text("0")),
        sa.Column("upload_time", sa.TIMESTAMP()),
    )

    op.create_index("release_files_name_idx", "release_files", ["name"])

    op.create_index("release_files_name_version_idx",
        "release_files",
        ["name", "version"],
    )

    op.create_index("release_files_version_idx", "release_files", ["version"])

    op.create_index("release_files_packagetype_idx",
        "release_files",
        ["packagetype"],
    )

    op.create_unique_constraint("release_files_filename_key",
        "release_files",
        ["filename"],
    )

    op.create_unique_constraint("release_files_md5_digest_key",
        "release_files",
        ["md5_digest"],
    )

    op.create_foreign_key(
        None,
        "release_files",
        "releases",
        ["name", "version"],
        ["name", "version"],
        onupdate="CASCADE",
    )

    op.create_table("openid_whitelist",
        sa.Column("name", sa.TEXT(), primary_key=True, nullable=False),
        sa.Column("trust_root", sa.TEXT(), primary_key=True, nullable=False),
        sa.Column("created", sa.TIMESTAMP()),
    )

    op.create_table("comments_journal",
        sa.Column("name", sa.TEXT()),
        sa.Column("version", sa.TEXT()),
        sa.Column("id", sa.INTEGER()),
        sa.Column("submitted_by",
            CIText(),
            sa.ForeignKey("accounts_user.username", ondelete="CASCADE"),
        ),
        sa.Column("date", sa.TIMESTAMP()),
        sa.Column("action", sa.TEXT()),
    )

    op.create_foreign_key(
        None,
        "comments_journal",
        "releases",
        ["name", "version"],
        ["name", "version"],
        onupdate="CASCADE",
        ondelete="CASCADE",
    )

    op.create_table("csrf_tokens",
        sa.Column("name",
            CIText(),
            sa.ForeignKey("accounts_user.username",
                onupdate="CASCADE",
                ondelete="CASCADE",
            ),
            primary_key=True,
            nullable=False,
        ),
        sa.Column("token", sa.TEXT()),
        sa.Column("end_date", sa.TIMESTAMP()),
    )

    op.create_table("oid_associations",
        sa.Column("server_url",
            sa.VARCHAR(length=2047),
            primary_key=True,
            nullable=False,
        ),
        sa.Column("handle",
            sa.VARCHAR(length=255),
            primary_key=True,
            nullable=False,
        ),
        sa.Column("secret", BYTEA(), nullable=False),
        sa.Column("issued", sa.INTEGER(), nullable=False),
        sa.Column("lifetime", sa.INTEGER(), nullable=False),
        sa.Column("assoc_type", sa.VARCHAR(length=64), nullable=False),
    )

    op.create_check_constraint("secret_length_constraint",
        "oid_associations",
        sa.text("length(secret) <= 128"),
    )

    op.create_table("cheesecake_subindices",
        sa.Column("main_index_id",
            sa.INTEGER(),
            sa.ForeignKey("cheesecake_main_indices.id"),
            primary_key=True,
            nullable=False,
        ),
        sa.Column("name", sa.TEXT(), primary_key=True, nullable=False),
        sa.Column("value", sa.INTEGER(), nullable=False),
        sa.Column("details", sa.TEXT(), nullable=False),
    )

    op.create_table("accounts_email",
        sa.Column("id", sa.INTEGER(), primary_key=True, nullable=False),
        sa.Column("user_id",
            sa.INTEGER(),
            sa.ForeignKey("accounts_user.id",
                deferrable=True,
                initially="DEFERRED",
            ),
            nullable=False,
        ),
        sa.Column("email", sa.VARCHAR(length=254), nullable=False),
        sa.Column("primary", sa.BOOLEAN(), nullable=False),
        sa.Column("verified", sa.BOOLEAN(), nullable=False),
    )

    op.create_index("accounts_email_email_like", "accounts_email", ["email"])

    op.create_index("accounts_email_user_id", "accounts_email", ["user_id"])

    op.create_unique_constraint("accounts_email_email_key",
        "accounts_email",
        ["email"],
    )

    op.create_table("sshkeys",
        sa.Column("id", sa.INTEGER(), primary_key=True, nullable=False),
        sa.Column("name",
            CIText(),
            sa.ForeignKey("accounts_user.username",
                onupdate="CASCADE",
                ondelete="CASCADE",
            ),
        ),
        sa.Column("key", sa.TEXT()),
    )

    op.create_index("sshkeys_name", "sshkeys", ["name"])

    op.create_table("accounts_gpgkey",
        sa.Column("id", sa.INTEGER(), primary_key=True, nullable=False),
        sa.Column("user_id",
            sa.INTEGER(),
            sa.ForeignKey("accounts_user.id",
                deferrable=True,
                initially="DEFERRED",
            ),
            nullable=False,
        ),
        sa.Column("key_id", CIText(), nullable=False),
        sa.Column("verified", sa.BOOLEAN(), nullable=False),
    )

    op.create_unique_constraint("accounts_gpgkey_key_id_key",
        "accounts_gpgkey",
        ["key_id"],
    )

    op.create_check_constraint("accounts_gpgkey_valid_key_id",
        "accounts_gpgkey",
        sa.text("key_id ~* '^[A-F0-9]{8}$'"),
    )

    op.create_index("accounts_gpgkey_user_id", "accounts_gpgkey", ["user_id"])

    op.create_table("openid_discovered",
        sa.Column("created", sa.TIMESTAMP()),
        sa.Column("url", sa.TEXT(), primary_key=True, nullable=False),
        sa.Column("services", BYTEA()),
        sa.Column("op_endpoint", sa.TEXT()),
        sa.Column("op_local", sa.TEXT()),
    )

    op.create_table("release_classifiers",
        sa.Column("name", sa.TEXT()),
        sa.Column("version", sa.TEXT()),
        sa.Column("trove_id",
            sa.INTEGER(),
            sa.ForeignKey("trove_classifiers.id"),
        ),
    )

    op.create_index("rel_class_name_idx", "release_classifiers", ["name"])

    op.create_index("rel_class_name_version_idx",
        "release_classifiers",
        ["name", "version"],
    )

    op.create_index("rel_class_version_id_idx",
        "release_classifiers",
        ["version"],
    )

    op.create_index("rel_class_trove_id_idx",
        "release_classifiers",
        ["trove_id"],
    )

    op.create_foreign_key(
        None,
        "release_classifiers",
        "releases",
        ["name", "version"],
        ["name", "version"],
        onupdate="CASCADE",
    )

    op.create_table("openids",
        sa.Column("id", sa.TEXT(), primary_key=True, nullable=False),
        sa.Column("name",
            CIText(),
            sa.ForeignKey("accounts_user.username",
                onupdate="CASCADE",
                ondelete="CASCADE",
            ),
        ),
    )


def downgrade():
    op.drop_table("openids")
    op.drop_table("release_classifiers")
    op.drop_table("openid_discovered")
    op.drop_table("accounts_gpgkey")
    op.drop_table("sshkeys")
    op.drop_table("accounts_email")
    op.drop_table("cheesecake_subindices")
    op.drop_table("oid_associations")
    op.drop_table("csrf_tokens")
    op.drop_table("comments_journal")
    op.drop_table("openid_whitelist")
    op.drop_table("release_files")
    op.drop_table("rego_otk")
    op.drop_table("journals")
    op.drop_table("oauth_nonce")
    op.drop_table("description_urls")
    op.drop_table("release_urls")
    op.drop_table("dual")
    op.drop_table("browse_tally")
    op.drop_table("release_requires_python")
    op.drop_table("roles")
    op.drop_table("trove_classifiers")
    op.drop_table("mirrors")
    op.drop_table("oid_nonces")
    op.drop_table("oauth_request_tokens")
    op.drop_table("openid_sessions")
    op.drop_table("openid_nonces")
    op.drop_table("oauth_access_tokens")
    op.drop_table("comments")
    op.drop_table("ratings")
    op.drop_table("release_dependencies")
    op.drop_table("releases")
    op.drop_table("packages")
    op.drop_table("cheesecake_main_indices")
    op.drop_table("oauth_consumers")
    op.drop_table("cookies")
    op.drop_table("accounts_user")
    op.drop_table("timestamps")

########NEW FILE########
__FILENAME__ = 8f38eea7678_remove_the_download_statistics
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
Remove the download statistics

Revision ID: 8f38eea7678
Revises: 4c8b2dd27587
Create Date: 2014-03-02 21:19:24.642402
"""

# revision identifiers, used by Alembic.
revision = '8f38eea7678'
down_revision = '4c8b2dd27587'

from alembic import op
import sqlalchemy as sa
from sqlalchemy.dialects import postgresql


def upgrade():
    op.drop_table('downloads')
    op.execute("DROP TYPE distribution_type")
    op.execute("DROP TYPE python_type")
    op.execute("DROP TYPE installer_type")


def downgrade():
    op.create_table(
        'downloads',
        sa.Column(
            'id',
            postgresql.UUID(),
            server_default=sa.text('uuid_generate_v4()'),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            'package_name',
            sa.TEXT(),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            'package_version',
            sa.TEXT(),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            'distribution_type',
            postgresql.ENUM(
                u'bdist_dmg',
                u'bdist_dumb',
                u'bdist_egg',
                u'bdist_msi',
                u'bdist_rpm',
                u'bdist_wheel',
                u'bdist_wininst',
                u'sdist',
                name='distribution_type',
            ),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            'python_type',
            postgresql.ENUM(
                u'cpython',
                u'pypy',
                u'jython',
                u'ironpython',
                name='python_type',
            ),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            'python_release',
            sa.TEXT(),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            'python_version',
            sa.TEXT(),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            'installer_type',
            postgresql.ENUM(
                u'browser',
                u'pip',
                u'setuptools',
                u'distribute',
                u'bandersnatch',
                u'z3c.pypimirror',
                u'pep381client',
                u'devpi',
                name='installer_type',
            ),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            'installer_version',
            sa.TEXT(),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            'operating_system',
            sa.TEXT(),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            'operating_system_version',
            sa.TEXT(),
            autoincrement=False,
            nullable=True,
        ),
        sa.Column(
            'download_time',
            postgresql.TIMESTAMP(),
            autoincrement=False,
            nullable=False,
        ),
        sa.Column(
            'raw_user_agent',
            sa.TEXT(),
            autoincrement=False,
            nullable=False,
        ),
        sa.PrimaryKeyConstraint('id', name=u'downloads_pkey'),
    )

########NEW FILE########
__FILENAME__ = db
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import logging
import os.path
import urllib.parse
import pkg_resources
import readme.rst

from collections import defaultdict

from warehouse import db
from warehouse import utils
from warehouse.packaging.tables import (ReleaseDependencyKind,
                                        packages,
                                        releases)


log = logging.getLogger(__name__)


class Database(db.Database):

    get_project_count = db.scalar(
        "SELECT COUNT(*) FROM packages"
    )

    get_download_count = db.scalar(
        "SELECT SUM(downloads) FROM release_files",
        default=0,
    )

    get_recently_updated = db.rows(
        # We only consider releases made in the last 7 days, otherwise we have
        # to do a Sequence Scan against the entire table and it takes 5+
        # seconds to complete. This shouldn't be a big deal as it is highly
        # unlikely we'll have a week without at least 10 releases.
        """ SELECT *
            FROM (
                SELECT DISTINCT ON (name) name, version, summary, created
                FROM releases
                WHERE created >= now() - interval '7 days'
                ORDER BY name, created DESC
            ) r
            ORDER BY r.created DESC
            LIMIT 10
        """
    )

    get_recent_projects = db.rows(
        # We only consider projects registered in the last 7 days (see
        # get_recently_updated for reasoning)
        """ SELECT
                p.name, r.version, p.created, r.summary
            FROM releases r, (
                SELECT packages.name, max_order, packages.created
                FROM packages
                JOIN (
                   SELECT name, max(_pypi_ordering) AS max_order
                     FROM releases
                    WHERE created >= now() - interval '7 days'
                    GROUP BY name
                ) mo ON packages.name = mo.name
            ) p
            WHERE p.name = r.name
              AND p.max_order = r._pypi_ordering
              AND p.created >= now() - interval '7 days'
            ORDER BY p.created DESC
            LIMIT %(num)s
        """
    )

    get_releases_since = db.rows(
        """ SELECT name, version, created, summary
            FROM releases
            WHERE created > %s
            ORDER BY created DESC
        """
    )

    get_reverse_dependencies = db.rows(
        """ SELECT DISTINCT name
            FROM release_dependencies
            WHERE specifier LIKE %s
        """
    )

    get_changed_since = db.rows(
        """ SELECT name, max(submitted_date) FROM journals
            WHERE submitted_date > %s
            GROUP BY name
            ORDER BY max(submitted_date) DESC
        """,
        row_func=lambda r: r[0]
    )

    all_projects = db.rows(
        "SELECT name FROM packages ORDER BY lower(name)",
        row_func=lambda r: r["name"]
    )

    def get_top_projects(self, num=None):
        query = \
            """ SELECT name, sum(downloads)
                FROM release_files
                GROUP BY name
                ORDER BY sum(downloads) DESC
            """
        if num:
            query += "LIMIT %(limit)s"

        return [tuple(r) for r in self.engine.execute(query, limit=num)]

    get_project = db.first(
        """ SELECT *
            FROM packages
            WHERE normalized_name = lower(
                regexp_replace(%s, '_', '-', 'ig')
            )
        """
    )

    get_projects_for_user = db.rows(
        """ SELECT DISTINCT ON (lower(name)) name, summary
            FROM (
                SELECT package_name
                FROM roles
                WHERE user_name = %s
            ) roles
            INNER JOIN (
                SELECT name, summary
                FROM releases
                ORDER BY _pypi_ordering DESC
            ) releases
            ON (releases.name = roles.package_name)
            ORDER BY lower(name)
        """
    )

    get_users_for_project = db.rows(
        """ SELECT DISTINCT ON (u.username) u.username, u.email
            FROM (
                SELECT username, email
                FROM accounts_user
                LEFT OUTER JOIN accounts_email ON (
                    accounts_email.user_id = accounts_user.id
                )
            ) u
            INNER JOIN roles ON (u.username = roles.user_name)
            WHERE roles.package_name = %s
        """
    )

    get_roles_for_project = db.rows(
        """ SELECT user_name, role_name
            FROM roles
            WHERE package_name = %s
            ORDER BY role_name, user_name
        """
    )

    get_roles_for_user = db.rows(
        """ SELECT package_name, role_name
            FROM roles
            WHERE user_name = %s
            ORDER BY package_name, role_name
        """
    )

    get_hosting_mode = db.scalar(
        "SELECT hosting_mode FROM packages WHERE name = %s"
    )

    get_release_urls = db.mapping(
        """ SELECT version, home_page, download_url
            FROM releases
            WHERE name = %s
            ORDER BY version DESC
        """,
        key_func=lambda r: r["version"],
        value_func=lambda r: (r["home_page"], r["download_url"]),
    )

    def get_release_dependencies(self, project_name, version):
        query = \
            """
            SELECT * FROM release_dependencies
            WHERE name = %(name)s
            AND version = %(version)s
            """
        specifier_dict = defaultdict(set)
        for row in self.engine.execute(query, name=project_name,
                                       version=version):
            specifier_dict[row['kind']].add(row['specifier'])
        return specifier_dict

    get_external_urls = db.rows(
        """ SELECT DISTINCT ON (url) url
            FROM description_urls
            WHERE name = %s
            ORDER BY url
        """,
        row_func=lambda r: r["url"]
    )

    get_release_external_urls = db.rows(
        """ SELECT DISTINCT ON (url) url
            FROM description_urls
            WHERE name = %s
            AND version = %s
            ORDER BY url
        """,
        row_func=lambda r: r["url"]
    )

    get_file_urls = db.rows(
        """ SELECT name, filename, python_version, md5_digest
            FROM release_files
            WHERE name = %s
            ORDER BY filename DESC
        """,
        lambda r: {
            "filename": r["filename"],
            "url": urllib.parse.urljoin(
                "/".join([
                    "../../packages",
                    r["python_version"],
                    r["name"][0],
                    r["name"],
                    r["filename"],
                ]),
                "#md5={}".format(r["md5_digest"]),
            ),
        }
    )

    get_project_for_filename = db.scalar(
        "SELECT name FROM release_files WHERE filename = %s"
    )

    get_filename_md5 = db.scalar(
        "SELECT md5_digest FROM release_files WHERE filename = %s"
    )

    def get_last_serial(self, name=None):
        if name is not None:
            query = "SELECT MAX(id) FROM journals WHERE name = %(name)s"
        else:
            query = "SELECT MAX(id) FROM journals"

        return db.scalar(query)(self, name=name)

    get_projects_with_serial = db.mapping(
        "SELECT name, max(id) FROM journals GROUP BY name",
    )

    get_project_versions = db.rows(
        """ SELECT version
            FROM releases
            WHERE name = %s
            ORDER BY _pypi_ordering DESC
        """,
        row_func=lambda r: r["version"]
    )

    def get_downloads(self, project, version):
        query = \
            """ SELECT
                    name, version, python_version, packagetype, comment_text,
                    filename, md5_digest, downloads, upload_time
                FROM release_files
                WHERE name = %(project)s AND version = %(version)s
                ORDER BY packagetype, python_version, upload_time
            """

        results = []
        for r in self.engine.execute(query, project=project, version=version):
            result = dict(r)
            result["filepath"] = os.path.join(
                self.app.config.paths.packages,
                result["python_version"],
                result["name"][0],
                result["name"],
                result["filename"],
            )
            if not os.path.exists(result["filepath"]):
                log.error(
                    "%s missing for package %s %s",
                    result["filepath"],
                    result["name"],
                    result["version"])
                continue
            result["url"] = "/".join([
                "/packages",
                result["python_version"],
                result["name"][0],
                result["name"],
                result["filename"],
            ])
            result["size"] = os.path.getsize(result["filepath"])

            if os.path.exists(result["filepath"] + ".asc"):
                result["pgp_url"] = result["url"] + ".asc"
            else:
                result["pgp_url"] = None

            results.append(result)

        return results

    def get_release(self, project, version):
        query = \
            """ SELECT
                    name, version, author, author_email, maintainer,
                    maintainer_email, home_page, license, summary, description,
                    keywords, platform, download_url, created
                FROM releases
                WHERE name = %(project)s AND version = %(version)s
                ORDER BY _pypi_ordering DESC
                LIMIT 1
            """

        result = [
            dict(r)
            for r in self.engine.execute(query, project=project,
                                         version=version)
        ]
        if len(result) == 0:
            return None
        else:
            result = result[0]

        # Load dependency information
        query = \
            """ SELECT name, version, kind, specifier
                FROM release_dependencies
                WHERE name = %(project)s AND version = %(version)s
                ORDER BY kind, specifier
            """

        dependency_data = {}
        for dependency in self.engine.execute(
                query,
                project=project,
                version=version):
            kind = ReleaseDependencyKind(dependency["kind"])

            if kind in {
                    ReleaseDependencyKind.requires_dist,
                    ReleaseDependencyKind.provides_dist,
                    ReleaseDependencyKind.obsoletes_dist}:
                value = dependency_data.setdefault(kind.name, [])
                value.append(dependency["specifier"])

            if kind is ReleaseDependencyKind.project_url:
                value = dependency_data.setdefault(kind.name, {})
                value.update(dict([dependency["specifier"].split(",", 1)]))
        result.update(dependency_data)

        return result

    get_releases = db.rows(
        """ SELECT
                name, version, author, author_email, maintainer,
                maintainer_email, home_page, license, summary, keywords,
                platform, download_url, created
            FROM releases
            WHERE name = %s
            ORDER BY _pypi_ordering DESC
        """
    )

    get_full_latest_releases = db.rows(
        """ SELECT DISTINCT ON (name)
                name, version, author, author_email, maintainer,
                maintainer_email, home_page, license, summary, description,
                keywords, platform, download_url, created
            FROM releases
            ORDER BY name, _pypi_ordering DESC
        """
    )

    def get_download_counts(self, project):
        def _make_key(precision, datetime, key):
            return "downloads:{}:{}:{}".format(
                precision[0],
                datetime.strftime(precision[1]),
                key,
            )

        precisions = [
            ("hour", "%y-%m-%d-%H"),
            ("daily", "%y-%m-%d"),
        ]

        # Get the current utc time
        current = datetime.datetime.utcnow()

        # Get the download count for the last 24 hours (roughly)
        keys = [
            _make_key(
                precisions[0],
                current - datetime.timedelta(hours=x),
                project,
            )
            for x in range(25)
        ]
        last_1 = sum(
            [int(x) for x in self.redis.mget(*keys) if x is not None]
        )

        # Get the download count for the last 7 days (roughly)
        keys = [
            _make_key(
                precisions[1],
                current - datetime.timedelta(days=x),
                project,
            )
            for x in range(8)
        ]
        last_7 = sum(
            [int(x) for x in self.redis.mget(*keys) if x is not None]
        )

        # Get the download count for the last month (roughly)
        keys = [
            _make_key(
                precisions[1],
                current - datetime.timedelta(days=x),
                project,
            )
            for x in range(31)
        ]
        last_30 = sum(
            [int(x) for x in self.redis.mget(*keys) if x is not None]
        )

        return {
            "last_day": last_1,
            "last_week": last_7,
            "last_month": last_30,
        }

    get_classifiers = db.rows(
        """ SELECT classifier
            FROM release_classifiers
            INNER JOIN trove_classifiers ON (
                release_classifiers.trove_id = trove_classifiers.id
            )
            WHERE name = %s AND version = %s
            ORDER BY classifier
        """,
        row_func=lambda r: r["classifier"]
    )

    def get_classifier_ids(self, classifiers):
        query = \
            """ SELECT classifier, id
                FROM trove_classifiers
                WHERE classifier IN %(classifiers)s
            """

        return {
            r["classifier"]: r["id"]
            for r in self.engine.execute(query, classifiers=tuple(classifiers))
        }

    def search_by_classifier(self, selected_classifiers):
        # Note: selected_classifiers is a list of ids from trove_classifiers
        if not selected_classifiers:
            return []

        # generate trove id -> level mapping
        trove = {}
        query = "SELECT * FROM trove_classifiers"
        for id, classifier, l2, l3, l4, l5 in self.engine.execute(query):
            if id == l2:
                trove[id] = 2
            elif id == l3:
                trove[id] = 3
            elif id == l4:
                trove[id] = 4
            else:
                trove[id] = 5

        # compute a statement to produce all packages selected
        query = "SELECT name, version FROM releases"
        for c in selected_classifiers:
            level = trove[c]
            query = \
                """ SELECT DISTINCT a.name, a.version
                    FROM (%s) a, release_classifiers rc, trove_classifiers t
                    WHERE a.name=rc.name
                    AND a.version=rc.version
                    AND rc.trove_id=t.id
                    AND t.l%d=%d
                """ % (query, level, c)

        releases = []
        for name, version in self.engine.execute(query):
            releases.append((name, version))

        return releases

    def get_documentation_url(self, project):
        path_parts = [
            self.app.config.paths.documentation,
            project,
            "index.html",
        ]
        if os.path.exists(os.path.join(*path_parts)):
            return urllib.parse.urljoin(
                self.app.config.urls.documentation,
                project
            ) + "/"

    get_bugtrack_url = db.scalar(
        "SELECT bugtrack_url FROM packages WHERE name = %s"
    )

    get_changelog = db.rows(
        """ SELECT name, version, submitted_date, action, id
            FROM journals
            WHERE journals.submitted_date > %s
            ORDER BY submitted_date DESC
        """
    )

    get_last_changelog_serial = db.scalar(
        "SELECT max(id) FROM journals"
    )

    get_changelog_serial = db.rows(
        """ SELECT name, version, submitted_date, action, id
            FROM journals
            WHERE journals.id > %s
            ORDER BY submitted_date DESC
        """
    )

# data Modification Methods

    def upsert_project(self, name, username, user_ip, **additional_columns):
        # NOTE: pypi behaviour is to assign the first submitter of a
        # project the "owner" role. this code does not
        # perform that behaviour (implement in the view instead)
        db.validate_argument_column_mapping(additional_columns, packages)

        existing_project = self.get_project(name)

        if existing_project:
            message = "updating project {0}".format(existing_project['name'])
            query = (packages.update()
                     .where(packages.c.name == existing_project['name']))
        else:
            message = "create"
            query = packages.insert()

        self.engine.execute(query.values(
            name=name,
            normalized_name=utils.normalize_project_name(name),
            **additional_columns
        ))

        self._insert_journal_entry(name, None, message, username, user_ip)

    def delete_project(self, name):
        for release in self.get_releases(name):
            self.delete_release(name, release['version'])
        self.engine.execute("DELETE FROM packages WHERE name = %(name)s",
                            name=name)

    def upsert_release(self, project_name, version, username, user_ip,
                       classifiers=None, release_dependencies=None,
                       description=None, **additional_db_values):
        """
        Takes in the following:

        * project_name: the name of the package to insert
        * version: the version of the package to insert
        * username: username of the user upserting the package
        * user_ip: ip address of the user upserting the package
        * classifiers: a list of the classifiers to classify the release with
        * release_dependencies: a dictionary of
            'ReleaseDependencyKind.value: [specifier]' pairs.
        * description: a restructured text description of the release/project
        * additional_db_values: any other column in the release table,
            as specified by get_settable_release_columns

        and inserts the release (if one doesn't exist), or updates otherwise
        """
        is_update = self.get_release(project_name, version) is not None
        modified_elements = list(additional_db_values.keys())

        db.validate_argument_column_mapping(
            additional_db_values,
            releases,
            blacklist=['name', 'version', 'description', 'description_html',
                       '_pypi_ordering', '_pypi_hidden']
        )

        if not is_update:
            additional_db_values['name'] = project_name
            additional_db_values['version'] = version

        if description:
            modified_elements += ['description', 'description_html']
            additional_db_values['description'] = description
            additional_db_values['description_html'] = \
                readme.rst.render(description)[0]

        if len(additional_db_values) > 0:
            if is_update:
                self.engine.execute(
                    releases
                    .update()
                    .where(releases.columns.name == project_name)
                    .where(releases.columns.version == version)
                    .values(**additional_db_values)
                )
            else:
                self.engine.execute(
                    releases.insert().values(**additional_db_values)
                )

        # external tables

        # this is legacy behavior. According to PEP-438, we should
        # no longer support parsing urls from descriptions
        hosting_mode = self.get_hosting_mode(project_name)
        if hosting_mode in ('pypi-scrape-crawl', 'pypi-scrape') \
           and 'description_html' in additional_db_values:

            self.update_release_external_urls(
                project_name, version,
                utils.find_links_from_html(
                    additional_db_values['description_html']
                )
            )

        if classifiers:
            modified_elements.append('classifiers')
            self.update_release_classifiers(project_name, version,
                                            classifiers)

        if release_dependencies:
            self.update_release_dependencies(project_name, version,
                                             release_dependencies)

        if is_update:
            journal_message = 'update {0}'.format(','.join(modified_elements))
        else:
            journal_message = "new release"

        self._insert_journal_entry(project_name, version, journal_message,
                                   username, user_ip)

        # insert specific actions

        if not is_update:
            self._update_release_ordering(project_name)

    def delete_release(self, project_name, version):
        # delete FK rows first
        for kind in ReleaseDependencyKind:
            self._delete_release_dependencies_of_kind(project_name,
                                                      version, kind.value)

        self._delete_release_classifiers(project_name, version)
        self._delete_release_external_urls(project_name, version)

        # actual deletion from the release table
        delete_statement = \
            """
            DELETE FROM releases
            WHERE name = %(name)s
            AND version = %(version)s
            """
        self.engine.execute(
            delete_statement,
            name=project_name,
            version=version
        )

    def _update_release_ordering(self, project_name):
        query = \
            """
            SELECT version, _pypi_ordering
            FROM releases
            WHERE name = %(name)s
            """
        project_versions = [project for project in
                            self.engine.execute(query, name=project_name)]
        sorted_versions = sorted(
            project_versions,
            key=(lambda x: pkg_resources.parse_version(x[0]))
        )
        query = \
            """
            UPDATE releases
            SET _pypi_ordering = %(order)s
            WHERE name = %(name)s
            AND version = %(version)s
            """
        for order, (version, current) in enumerate(sorted_versions):
            if current != order:
                self.engine.execute(query, name=project_name,
                                    order=order, version=version)

    def update_release_classifiers(self, name, version, classifiers):
        self._delete_release_classifiers(name, version)
        insert_query = \
            """ INSERT INTO release_classifiers
                    (name, version, trove_id)
                VALUES
                    (%(name)s, %(version)s, %(trove_id)s)
            """
        classifier_id_dict = self.get_classifier_ids(classifiers)
        for classifier in classifiers:
            trove_id = classifier_id_dict[classifier]
            self.engine.execute(insert_query, name=name,
                                version=version, trove_id=trove_id)

    def _delete_release_classifiers(self, name, version):
        query = \
            """ DELETE FROM release_classifiers
                WHERE name = %(name)s
                AND version = %(version)s
            """
        self.engine.execute(
            query,
            name=name,
            version=version
        )

    def update_release_external_urls(self, project_name, version, urls):
        self._delete_release_external_urls(project_name, version)
        insert_query = \
            """ INSERT INTO description_urls
                    (name, version, url)
                VALUES
                    (%(name)s, %(version)s, %(url)s)
            """
        for url in urls:
            self.engine.execute(insert_query, name=project_name,
                                version=version, url=url)

    def _delete_release_external_urls(self, project_name, version):
        query = \
            """ DELETE FROM description_urls
                WHERE name = %(name)s
                AND version = %(version)s
            """
        self.engine.execute(
            query,
            name=project_name,
            version=version
        )

    def update_release_dependencies(self, project_name, version,
                                    specifier_dict):
        """
        Takes in a project_name, version, and a release_dict of the format:
        { ReleaseDependencyKind: [specifier_name_foo, specifier_name_bar] }

        and updates the release dependencies with the desired table
        """
        insert_query = \
            """
            INSERT INTO release_dependencies
                (name, version, kind, specifier)
            VALUES
                (%(name)s, %(version)s, %(kind)s, %(specifier)s)
            """

        old_specifier = self.get_release_dependencies(project_name,
                                                      version)
        for kind, specifiers in specifier_dict.items():

            # no need to update if the state is already there
            if kind in old_specifier and specifiers == old_specifier[kind]:
                continue

            self._delete_release_dependencies_of_kind(project_name, version,
                                                      kind)
            for specifier in specifiers:
                self.engine.execute(
                    insert_query,
                    name=project_name,
                    version=version,
                    kind=kind,
                    specifier=specifier
                )

    def _delete_release_dependencies_of_kind(self, project_name, version,
                                             kind):
        query = \
            """
            DELETE FROM release_dependencies
            WHERE name = %(name)s
            AND version = %(version)s
            AND kind = %(kind)s
            """
        self.engine.execute(
            query,
            name=project_name,
            version=version,
            kind=kind
        )

    def _insert_journal_entry(self, project_name, version, message,
                              username, userip):
        date = datetime.datetime.now()
        query = \
            """
            INSERT INTO journals
                (name, version, action, submitted_date,
                 submitted_by, submitted_from)
            VALUES
                (%(name)s, %(version)s, %(action)s, %(submitted_date)s,
                 %(submitted_by)s, %(submitted_from)s)
            """
        self.engine.execute(
            query,
            name=project_name,
            version=version,
            action=message,
            submitted_date=date.strftime('%Y-%m-%d %H:%M:%S'),
            submitted_by=username,
            submitted_from=userip
        )

########NEW FILE########
__FILENAME__ = helpers
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


def package_type_display(package_type):
    return {
        "sdist": "Source",
        "bdist_dumb": "\"dumb\" binary",
        "bdist_rpm": "RPM",
        "bdist_wininst": "Windows Installer",
        "bdist_msi": "Windows MSI Installer",
        "bdist_egg": "Egg",
        "bdist_dmg": "OSX Disk Image",
        "bdist_wheel": "Wheel",
    }.get(package_type, package_type)

########NEW FILE########
__FILENAME__ = search
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from warehouse.search.indexes import BaseMapping


class ProjectMapping(BaseMapping):

    _type = "project"

    def get_mapping(self):
        return {
            "properties": {
                "name": {"type": "string"},
                "name_keyword": {"type": "string", "index": "not_analyzed"},
                "version": {"type": "string"},
                "author": {"type": "string"},
                "author_email": {"type": "string"},
                "maintainer": {"type": "string"},
                "maintainer_email": {"type": "string"},
                "home_page": {"type": "string"},
                "license": {"type": "string"},
                "summary": {"type": "string"},
                "description": {"type": "string"},
                "keywords": {"type": "string"},
                "platform": {"type": "string"},
                "download_url": {"type": "string"},
                "created": {"type": "string"},
            },
        }

    def get_indexable(self):
        return self.index.db.packaging.get_full_latest_releases()

    def extract_id(self, item):
        return item["name"]

    def extract_document(self, item):
        item['name_keyword'] = item['name'].lower()
        return item

    def search(self, query, limit=None, offset=0):
        # TODO: Faceting
        # TODO: Other Features?

        limit = limit or self.SEARCH_LIMIT

        if query:
            query = query.lower()
            body = {
                "query": {
                    "bool": {
                        "should": [
                            # An extra boost for exact matches.
                            {
                                "term": {
                                    "name_keyword": {"value": query},
                                }
                            },
                            {
                                "match": {
                                    "name": {"query": query, "boost": 2.0},
                                },
                            },
                            {
                                "match": {
                                    "summary": {"query": query, "boost": 1.5},
                                },
                            },
                            {"match": {"description": {"query": query}}},
                        ],
                    }
                },
                "from": offset,
                "size": limit,
            }
        else:
            body = {
                "query": {"match_all": {}},
                "from": offset,
                "size": limit,
            }

        return self.index.es.search(
            index=self.index._index,
            doc_type=self._type,
            body=body
        )

########NEW FILE########
__FILENAME__ = tables
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import enum

from citext import CIText
from sqlalchemy import (
    Table, Column, CheckConstraint, ForeignKey, Index, UniqueConstraint,
    ForeignKeyConstraint, Sequence,
)
from sqlalchemy import Boolean, DateTime, Integer, UnicodeText
from sqlalchemy import sql

from warehouse import db


class ReleaseDependencyKind(int, enum.Enum):

    requires = 1  # Unused
    provides = 2  # Unused
    obsoletes = 3  # Unused
    requires_dist = 4
    provides_dist = 5
    obsoletes_dist = 6  # Unused
    requires_external = 7  # Unused

    # WHY +1
    project_url = 8


classifiers = Table(
    "trove_classifiers",
    db.metadata,

    Column(
        "id",
        Integer(),
        autoincrement=False,
        primary_key=True,
        nullable=False,
    ),
    Column("classifier", UnicodeText()),
    Column("l2", Integer()),
    Column("l3", Integer()),
    Column("l4", Integer()),
    Column("l5", Integer()),

    UniqueConstraint("classifier", name="trove_classifiers_classifier_key"),

    Index("trove_class_id_idx", "id"),
    Index("trove_class_class_idx", "classifier"),
)


release_classifiers = Table(
    "release_classifiers",
    db.metadata,

    Column("name", UnicodeText()),
    Column("version", UnicodeText()),
    Column("trove_id", Integer(), ForeignKey("trove_classifiers.id")),

    ForeignKeyConstraint(
        ["name", "version"],
        ["releases.name", "releases.version"],
        onupdate="CASCADE",
    ),

    Index("rel_class_name_idx", "name"),
    Index("rel_class_version_id_idx", "version"),
    Index("rel_class_name_version_idx", "name", "version"),
    Index("rel_class_trove_id_idx", "trove_id"),
)


packages = Table(
    "packages",
    db.metadata,

    Column("name", UnicodeText(), primary_key=True, nullable=False),
    Column("stable_version", UnicodeText()),
    Column("normalized_name", UnicodeText()),
    Column("autohide", Boolean(), server_default=sql.true()),
    Column("comments", Boolean(), server_default=sql.true()),
    Column("bugtrack_url", UnicodeText()),
    Column(
        "hosting_mode",
        UnicodeText(),
        nullable=False,
        server_default="pypi-explicit",
    ),
    Column(
        "created",
        DateTime(),
        nullable=False,
        server_default=sql.func.now(),
    ),

    # Validate that packages begin and end with an alpha numeric and contain
    #   only alpha numeric, ., _, and -.
    CheckConstraint(
        "name ~* '^([A-Z0-9]|[A-Z0-9][A-Z0-9._-]*[A-Z0-9])$'",
        name="packages_valid_name",
    ),
)

releases = Table(
    "releases",
    db.metadata,

    Column(
        "name",
        UnicodeText(),
        ForeignKey("packages.name", onupdate="CASCADE"),
        primary_key=True,
        nullable=False,
    ),
    Column("version", UnicodeText(), primary_key=True, nullable=False),
    Column("author", UnicodeText()),
    Column("author_email", UnicodeText()),
    Column("maintainer", UnicodeText()),
    Column("maintainer_email", UnicodeText()),
    Column("home_page", UnicodeText()),
    Column("license", UnicodeText()),
    Column("summary", UnicodeText()),
    Column("description", UnicodeText()),
    Column("keywords", UnicodeText()),
    Column("platform", UnicodeText()),
    Column("download_url", UnicodeText()),
    Column("_pypi_ordering", Integer()),
    Column("_pypi_hidden", Boolean()),
    Column("description_html", UnicodeText()),
    Column(
        "cheesecake_installability_id",
        Integer(),
        ForeignKey("cheesecake_main_indices.id"),
    ),
    Column(
        "cheesecake_documentation_id",
        Integer(),
        ForeignKey("cheesecake_main_indices.id"),
    ),
    Column(
        "cheesecake_code_kwalitee_id",
        Integer(),
        ForeignKey("cheesecake_main_indices.id"),
    ),
    Column("requires_python", UnicodeText()),
    Column("description_from_readme", Boolean()),
    Column(
        "created",
        DateTime(),
        nullable=False,
        server_default=sql.func.now(),
    ),

    Index("release_name_idx", "name"),
    Index("release_version_idx", "version"),
    Index("release_name_created_idx", "name", "version"),
    Index("release_pypi_hidden_idx", "_pypi_hidden"),
)


release_dependencies = Table(
    "release_dependencies",
    db.metadata,

    Column("name", UnicodeText()),
    Column("version", UnicodeText()),
    Column("kind", Integer()),
    Column("specifier", UnicodeText()),

    ForeignKeyConstraint(
        ["name", "version"],
        ["releases.name", "releases.version"],
        onupdate="CASCADE",
    ),

    Index("rel_dep_name_idx", "name"),
    Index("rel_dep_name_version_idx", "name", "version"),
    Index("rel_dep_name_version_kind_idx", "name", "version", "kind"),
)


release_files = Table(
    "release_files",
    db.metadata,

    Column("name", UnicodeText()),
    Column("version", UnicodeText()),
    Column("python_version", UnicodeText()),
    Column("packagetype", UnicodeText()),
    Column("comment_text", UnicodeText()),
    Column("filename", UnicodeText()),
    Column("md5_digest", UnicodeText()),
    Column("downloads", Integer(), server_default=sql.text("0")),
    Column("upload_time", DateTime()),

    UniqueConstraint("filename", name="release_files_filename_key"),
    UniqueConstraint("md5_digest", name="release_files_md5_digest_key"),

    ForeignKeyConstraint(
        ["name", "version"],
        ["releases.name", "releases.version"],
        onupdate="CASCADE",
    ),

    Index("release_files_name_idx", "name"),
    Index("release_files_version_idx", "version"),
    Index("release_files_name_version_idx", "name", "version"),
    Index("release_files_packagetype_idx", "packagetype"),
)


description_urls = Table(
    "description_urls",
    db.metadata,

    Column("id", Integer(), primary_key=True, nullable=False),
    Column("name", UnicodeText()),
    Column("version", UnicodeText()),
    Column("url", UnicodeText()),

    ForeignKeyConstraint(
        ["name", "version"],
        ["releases.name", "releases.version"],
        onupdate="CASCADE",
    ),

    Index("description_urls_name_idx", "name"),
    Index("description_urls_name_version_idx", "name", "version"),
)


roles = Table(
    "roles",
    db.metadata,

    Column("role_name", UnicodeText()),
    Column(
        "user_name",
        CIText(),
        ForeignKey("accounts_user.username", onupdate="CASCADE"),
    ),
    Column(
        "package_name",
        UnicodeText(),
        ForeignKey("packages.name", onupdate="CASCADE"),
    ),

    Index("roles_pack_name_idx", "package_name"),
    Index("roles_user_name_idx", "user_name"),
)


journals = Table(
    "journals",
    db.metadata,

    Column("id", Integer(), Sequence("journals_id_seq")),
    Column("name", UnicodeText()),
    Column("version", UnicodeText()),
    Column("action", UnicodeText()),
    Column("submitted_date", DateTime()),
    Column("submitted_by", CIText()),  # Needs a FK to accounts_user
    Column("submitted_from", UnicodeText()),

    Index("journals_name_idx", "name"),
    Index("journals_version_idx", "version"),
    Index("journals_changelog", "submitted_date", "name", "version", "action"),
    Index("journals_latest_releases", "submitted_date", "name", "version"),
)


cheesecake_main_indices = Table(
    "cheesecake_main_indices",
    db.metadata,

    Column("id", Integer(), primary_key=True, nullable=False),
    Column("absolute", Integer(), nullable=False),
    Column("relative", Integer(), nullable=False),
)

########NEW FILE########
__FILENAME__ = urls
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from werkzeug.routing import Rule, EndpointPrefix

urls = [
    EndpointPrefix("warehouse.packaging.views.", [
        Rule(
            "/project/<project_name>/",
            methods=["GET"],
            endpoint="project_detail",
        ),
        Rule(
            "/project/<project_name>/<version>/",
            methods=["GET"],
            endpoint="project_detail",
        ),
    ]),
]

########NEW FILE########
__FILENAME__ = views
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import jinja2
import readme.rst

from werkzeug.exceptions import NotFound

from warehouse import fastly
from warehouse.helpers import url_for
from warehouse.templates import render_response
from warehouse.utils import cache, redirect, camouflage_images


@cache(browser=1, varnish=120)
@fastly.projects(project_name="project")
def project_detail(app, request, project_name, version=None):
    # Get the real project name for this project
    project = app.db.packaging.get_project(project_name)

    if project is None:
        raise NotFound("Cannot find a project named {}".format(project_name))

    # Look up all the releases for the given project
    releases = app.db.packaging.get_releases(project["name"])

    if not releases:
        # If there are no releases then we need to return a simpler response
        # that simply states the project exists but that there is no versions
        # registered.
        raise NotFound(
            "There are no releases registered for the {} project".format(
                project["name"],
            ),
        )

    if project["name"] != project_name:
        # We've found the project, and the version exists, but the project name
        # isn't quite right so we'll redirect them to the correct one.
        return redirect(
            url_for(
                request,
                "warehouse.packaging.views.project_detail",
                project_name=project["name"],
                version=version,
            ),
            code=301,
        )

    if version is None:
        # If there's no version specified, then we use the latest version
        version = releases[0]["version"]
    elif version not in (r["version"] for r in releases):
        # If a version was specified then we need to ensure it's one of the
        # versions this project has, else raise a NotFound
        raise NotFound(
            "Cannot find the {} version of the {} project".format(
                version,
                project["name"],
            ),
        )

    # Get the release data for the version
    release = app.db.packaging.get_release(project["name"], version)

    # Get the number of reverse dependencies for this project
    project_url = lambda name: url_for(
        request, 'warehouse.packaging.views.project_detail',
        project_name=name)
    reverse_dependencies = [
        {'name': row['name'], 'url': project_url(row['name'])}
        for row in app.db.packaging.get_reverse_dependencies(
            project["name"] + ' %'
        )
    ]

    if release.get("description"):
        # Render the project description
        description_html, rendered = readme.rst.render(release["description"])

        if not rendered:
            description_html = description_html.replace("\n", "<br>")

        if app.config.camo:
            description_html = camouflage_images(
                app.config.camo.url,
                app.config.camo.key,
                description_html,
            )
    else:
        description_html = ""

    # Mark our description_html as safe as it's already been cleaned by bleach
    description_html = jinja2.Markup(description_html)

    # Split the requirement string to (project name, the rest)
    requirements = []
    for req in release.get('requires_dist', []):
        project_name, *other = req.split(' ', 1)
        url = url_for(request, 'warehouse.packaging.views.project_detail',
                      project_name=project_name)
        requirements.append({
            'project_name': project_name,
            'project_url': url,
            'other': other[0] if other else ''
        })

    return render_response(
        app, request, "projects/detail.html",
        project=project["name"],
        release=release,
        releases=releases,
        requirements=requirements,
        reverse_dependencies=reverse_dependencies,
        description_html=description_html,
        download_counts=app.db.packaging.get_download_counts(project["name"]),
        downloads=app.db.packaging.get_downloads(project["name"], version),
        classifiers=app.db.packaging.get_classifiers(project["name"], version),
        documentation=app.db.packaging.get_documentation_url(project["name"]),
        bugtracker=app.db.packaging.get_bugtrack_url(project["name"]),
        maintainers=app.db.packaging.get_users_for_project(project["name"]),
    )

########NEW FILE########
__FILENAME__ = cli
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


class ReindexCommand(object):

    def __call__(self, app):
        app.search.reindex()


__commands__ = {
    "reindex": ReindexCommand(),
}

########NEW FILE########
__FILENAME__ = indexes
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import binascii
import os

from elasticsearch import Elasticsearch, TransportError
from elasticsearch.helpers import bulk_index

from warehouse.datastructures import AttributeDict


class Index(object):

    def __init__(self, db, config):
        self.db = db
        self.config = config
        self.es = Elasticsearch(
            hosts=self.config.hosts,
            **self.config.get("client_options", {})
        )

        self.types = AttributeDict()

        self._index = config.index

    def register(self, type_):
        obj = type_(self)
        self.types[obj._type] = obj

    def reindex(self, alias=True, keep_old=False):
        # Generate an Index Name for Warehouse
        index = "".join([
            self._index,
            binascii.hexlify(os.urandom(4)).decode("ascii"),
        ])

        # Create this index
        self.es.indices.create(index, {
            "mappings": {
                doc_type._type: doc_type.get_mapping()
                for doc_type in self.types.values()
            },
        })

        # Index everything into the new index
        for doc_type in self.types.values():
            doc_type.index_all(index=index)

        # Update the alias unless we've been told not to
        if alias:
            self.update_alias(self._index, index, keep_old=keep_old)

    def update_alias(self, alias, index, keep_old=False):
        # Get the old index from ElasticSearch
        try:
            old_index = list(self.es.indices.get_alias(self._index))[0]
        except TransportError as exc:
            if not exc.status_code == 404:
                raise
            old_index = None

        # Remove the alias to the old index if it exists
        if old_index is not None:
            actions = [{"remove": {"index": old_index, "alias": alias}}]
        else:
            actions = []

        # Add the alias to the new index
        actions += [{"add": {"index": index, "alias": alias}}]

        # Update To the New Index
        self.es.indices.update_aliases({"actions": actions})

        # Delete the old index if it exists and unless we're keeping it
        if not keep_old and old_index is not None:
            self.es.indices.delete(old_index)


class BaseMapping(object):

    SEARCH_LIMIT = 25

    def __init__(self, index):
        self.index = index

    def get_mapping(self):
        raise NotImplementedError

    def get_indexable(self):
        raise NotImplementedError

    def extract_id(self, item):
        raise NotImplementedError

    def extract_document(self, item):
        raise NotImplementedError

    def index_all(self, index=None):
        # Determine which index we are indexing into
        _index = index if index is not None else self.index._index

        # Bulk Index our documents
        bulk_index(
            self.index.es,
            [
                {
                    "_index": _index,
                    "_type": self._type,
                    "_id": self.extract_id(item),
                    "_source": self.extract_document(item),
                }
                for item in self.get_indexable()
            ],
        )

    def search(self, query):
        raise NotImplementedError

########NEW FILE########
__FILENAME__ = urls
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from werkzeug.routing import Rule


urls = [
    Rule(
        "/search/<doctype>/",
        methods=["GET"],
        endpoint="warehouse.search.views.search",
    ),
]

########NEW FILE########
__FILENAME__ = views
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import functools

from werkzeug.exceptions import NotFound

from warehouse.helpers import url_for
from warehouse.templates import render_response
from warehouse.utils import SearchPagination


def search(app, request, doctype):
    if doctype not in app.search.types:
        raise NotFound

    limit = app.search.types[doctype].SEARCH_LIMIT

    query = request.args.get("q")
    try:
        page = int(request.args.get("page", 1))
    except ValueError:
        raise NotFound
    if page <= 0:
        page = 1
    offset = (page - 1) * limit

    results = app.search.types[doctype].search(query, limit, offset)
    total = results.get("hits", {}).get("total", 0)

    url_partial = functools.partial(
        url_for, request, 'warehouse.search.views.search', doctype='project',
        q=query)
    pages = SearchPagination(page, total, limit, url_partial)

    return render_response(
        app,
        request,
        "search/results.html",
        query=query, total=total, pages=pages,
        results=[r["_source"] for r in results["hits"]["hits"]],
    )

########NEW FILE########
__FILENAME__ = serving
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from werkzeug.serving import WSGIRequestHandler as _WSGIRequestHandler
from werkzeug._internal import _log


class WSGIRequestHandler(_WSGIRequestHandler):

    def log(self, level, message, *args):
        _log(level, '%s - %s\n' % (
            self.address_string(),
            message % args),
        )

########NEW FILE########
__FILENAME__ = sessions
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import functools
import re

import msgpack
import msgpack.exceptions

from werkzeug.contrib.sessions import SessionStore, Session as _Session

from warehouse.utils import random_token, vary_by


SESSION_COOKIE_NAME = "session_id"


class RedisSessionStore(SessionStore):

    valid_key_regex = re.compile(r"^[a-zA-Z0-9_-]{43}$")

    max_age = 12 * 60 * 60  # 12 hours

    def __init__(self, redis, session_class=None, _random_token=random_token):
        super(RedisSessionStore, self).__init__(session_class=session_class)

        self.redis = redis
        self._random_token = _random_token

    def _redis_key(self, sid):
        return "warehouse/session/data/{}".format(sid)

    def generate_key(self, salt=None):
        return self._random_token()

    def is_valid_key(self, key):
        return self.valid_key_regex.search(key) is not None

    def get(self, sid):
        # Ensure we have a valid key, if not generate a new one
        if not self.is_valid_key(sid):
            return self.new()

        # Fetch the serialized data from redis
        bdata = self.redis.get(self._redis_key(sid))

        # If the session doesn't exist in redis, we'll give the user a new
        # session
        if bdata is None:
            return self.new()

        try:
            data = msgpack.unpackb(bdata, encoding="utf8", use_list=True)
        except (
                msgpack.exceptions.UnpackException,
                msgpack.exceptions.ExtraData):
            # If the session data was invalid we'll give the user a new session
            return self.new()

        # If we were able to load existing session data, load it into a
        # Session class
        session = self.session_class(data, sid, False)

        # Refresh the session in redis to prevent early expiration
        self.refresh(session)

        # Finally return our saved session
        return session

    def save(self, session):
        # Save the session in redis
        self.redis.setex(
            self._redis_key(session.sid),
            self.max_age,
            msgpack.packb(session, encoding="utf8", use_bin_type=True),
        )

    def delete(self, session):
        # Delete the session in redis
        self.redis.delete(self._redis_key(session.sid))

    def refresh(self, session):
        # Refresh the session in redis
        self.redis.expire(self._redis_key(session.sid), self.max_age)

    def cycle(self, session):
        # Create a new session with all of the data from the old one
        new_session = self.new()
        new_session.update(session)

        # Delete the old session now that we've copied the data
        self.delete(session)

        # Return the new session
        return new_session


class Session(_Session):

    def __init__(self, *args, **kwargs):
        super(Session, self).__init__(*args, **kwargs)

        self.cycled = False
        self.deleted = False

    def cycle(self):
        self.cycled = True

    def delete(self):
        self.deleted = True


def handle_session(fn):

    @functools.wraps(fn)
    def wrapped(self, view, app, request, *args, **kwargs):
        # Short little alias for the session store to make it easier to refer
        # to
        store = app.session_store

        # Look up the session id from the request, and either create a new
        # session or fetch the existing one from the session store
        sid = request.cookies.get(SESSION_COOKIE_NAME, None)
        session = store.new() if sid is None else store.get(sid)

        # Stick the session on the request, but in a private variable. If
        # a view wants to use the session it should use @uses_session to move
        # it to request.session and appropriately vary by Cookie
        request._session = session

        # Call our underlying function in order to get the response to this
        # request
        resp = fn(self, view, app, request, *args, **kwargs)

        # Check to see if the session has been marked to be deleted, if it has
        # tell our session store to delete it, and tell our response to delete
        # the session cookie as well, and then finally short circuit and return
        # our response.
        if session.deleted:
            # Delete in our session store
            store.delete(session)

            # Delete the cookie in the browser
            resp.delete_cookie(SESSION_COOKIE_NAME)

        # Check to see if the session has been marked to be cycled or not.
        # When cycling a session we copy all of the data into a new session
        # and delete the old one.
        if session.cycled:
            session = store.cycle(session)

        # Check to see if the session has been marked to be saved, generally
        # this means that the session data has been modified and thus we need
        # to store the new data.
        if session.should_save:
            store.save(session)

            # Whenever we store new data for our session, we want to issue a
            # new Set-Cookie header so that our expiration date for this
            # session gets reset.
            resp.set_cookie(
                SESSION_COOKIE_NAME,
                session.sid,
                secure=request.is_secure,
                httponly=True,
            )

        # Finally return our response
        return resp

    # Set an attribute so that we can verify the dispatch_view has had session
    # support enabled
    wrapped._sessions_handled = True

    return wrapped


def uses_session(fn):

    @functools.wraps(fn)
    @vary_by("Cookie")
    def wrapper(app, request, *args, **kwargs):
        # Add the session onto the request object
        request.session = request._session

        # Call the underlying function
        return fn(app, request, *args, **kwargs)

    return wrapper

########NEW FILE########
__FILENAME__ = templates
# Copyright 2014 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import functools

from warehouse import helpers
from warehouse.http import Response


class TemplateRenderer:
    """
    TemplateRenderer is small iterator which will lazily render
    a template when consumed.

    This allows inspecting or even modifying the context of the template, or
    even the template itself, at anytime prior to the template finally being
    rendered. Specifically it allows tests to easily test that a view has
    rendered a particular template with a particular context, but it also
    additionally allows decorators to modify the response without having to
    resort to parsing HTML.

    It also allows you to conceptually separate a ``default_context`` from the
    actual ``context``. This distinction is useful because ``render_response``
    always adds some default context to the template but that isn't useful for
    testing or modification of what the view itself has done.
    """

    def __init__(self, template, context, default_context=None):
        if default_context is None:
            default_context = {}

        self.template = template
        self.context = context
        self.default_context = default_context
        self.rendered = False

    def __iter__(self):
        return self

    def __next__(self):
        if self.rendered:
            raise StopIteration

        self.rendered = True

        ctx = self.default_context.copy()
        ctx.update(self.context)

        return self.template.render(**ctx)


class TemplateResponse(Response):
    """
    TemplateResponse is a Response subclass which ensures that a
    TemplateRenderer instance does not cause the request to be streaming but
    instead causes it to be a typical request.
    """

    def __repr__(self):
        self._ensure_sequence()
        return super(TemplateResponse, self).__repr__()

    def get_wsgi_headers(self, environ):
        headers = super(TemplateResponse, self).get_wsgi_headers(environ)
        headers["Content-Length"] = self.calculate_content_length()

        return headers

    @property
    def is_streamed(self):
        return False


def render_response(app, request, template, **context):
    """
    A simple helper that takes an app, request, template, and some context and
    constructs a TemplateResponse that will lazily render the template with
    the given context when the Response is evaluated.
    """
    template = app.templates.get_template(template)

    default_context = {
        "config": app.config,
        "csrf_token": functools.partial(helpers.csrf_token, request),
        "gravatar_url": helpers.gravatar_url,
        "static_url": functools.partial(helpers.static_url, app),
        "url_for": functools.partial(helpers.url_for, request),
    }

    return TemplateResponse(
        TemplateRenderer(template, context, default_context=default_context),
        mimetype="text/html",
    )

########NEW FILE########
__FILENAME__ = urls
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from werkzeug.routing import Map, Rule

from warehouse.accounts.urls import urls as accounts_urls
from warehouse.packaging.urls import urls as packaging_urls
from warehouse.search.urls import urls as search_urls
from warehouse.legacy.urls import urls as legacy_urls


# Top level URL rules
urls = [
    Rule("/", methods=["GET"], endpoint="warehouse.views.index"),
]

# Extend the URL rules with our other applications
urls += accounts_urls + packaging_urls + search_urls + legacy_urls

# Map our urls
urls = Map(urls)

########NEW FILE########
__FILENAME__ = utils
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import base64
import binascii
import collections
import functools
import hashlib
import hmac
import mimetypes
import os
import re
import urllib.parse

import html5lib
import html5lib.serializer
import html5lib.treewalkers

from werkzeug.urls import iri_to_uri
from werkzeug.utils import escape

from warehouse.http import Response


def merge_dict(base, additional):
    if base is None:
        return additional

    if additional is None:
        return base

    if not (isinstance(base, collections.Mapping)
            and isinstance(additional, collections.Mapping)):
        return additional

    merged = base
    for key, value in additional.items():
        if isinstance(value, collections.Mapping):
            merged[key] = merge_dict(merged.get(key), value)
        else:
            merged[key] = value

    return merged


def cache(browser=None, varnish=None):
    def deco(fn):
        @functools.wraps(fn)
        def wrapper(app, request, *args, **kwargs):
            resp = fn(app, request, *args, **kwargs)

            if 200 <= resp.status_code < 400:
                # Add in our standard Cache-Control headers
                if browser is not None:
                    resp.cache_control.public = True
                    resp.cache_control.max_age = browser

                # Add in additional headers if we're using varnish
                if varnish is not None:
                    resp.surrogate_control.public = True
                    resp.surrogate_control.max_age = varnish

            return resp
        return wrapper
    return deco


def get_wsgi_application(environ, app_class):
    if "WAREHOUSE_CONF" in environ:
        configs = [environ["WAREHOUSE_CONF"]]
    else:
        configs = []

    return app_class.from_yaml(*configs)


def get_mimetype(filename):
    # Figure out our mimetype
    mimetype = mimetypes.guess_type(filename)[0]
    if not mimetype:
        mimetype = "application/octet-stream"
    return mimetype


def redirect(location, code=302):
    """Return a response object (a WSGI application) that, if called,
    redirects the client to the target location.  Supported codes are 301,
    302, 303, 305, and 307.  300 is not supported because it's not a real
    redirect and 304 because it's the answer for a request with a request
    with defined If-Modified-Since headers.

    .. versionadded:: 0.6
       The location can now be a unicode string that is encoded using
       the :func:`iri_to_uri` function.

    :param location: the location the response should redirect to.
    :param code: the redirect status code. defaults to 302.
    """
    display_location = escape(location)
    if isinstance(location, str):
        location = iri_to_uri(location)
    response = Response(
        '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n'
        '<title>Redirecting...</title>\n'
        '<h1>Redirecting...</h1>\n'
        '<p>You should be redirected automatically to target URL: '
        '<a href="%s">%s</a>.  If not click the link.' %
        (escape(location), display_location), code, mimetype="text/html")
    response.headers["Location"] = location
    return response


def redirect_next(request, default="/", field_name="next", code=303):
    next = request.values.get(field_name)

    if not is_safe_url(next, request.host):
        next = default

    return redirect(next, code=code)


PACKAGE_REGEX = {
    "permitted_characters": re.compile("^[a-zA-Z0-9_\-.]+$"),
    "start_with_alphanumeric": re.compile("^[a-zA-Z0-9].*"),
    "end_with_alphanumeric": re.compile(".*[a-zA-Z0-9]$")
}


def normalize_project_name(name):
    """
    Normalizes a package name as per PEP-426
    """
    name = re.sub("_", "-", name).lower()
    if not PACKAGE_REGEX["permitted_characters"].match(name):
        raise ValueError("name contains illegal characters! (See PEP-426)")
    if not (PACKAGE_REGEX["start_with_alphanumeric"].match(name) and
            PACKAGE_REGEX["end_with_alphanumeric"].match(name)):
        raise ValueError(
            "Distribution names MUST start with and end with " +
            "an ASCII letter or digit (See PEP-426)"
        )
    return name


class SearchPagination(object):

    def __init__(self, page, total, per_page, url):
        self.page = page
        self.total = total
        self.per_page = per_page
        self.url = url

    @property
    def pages(self):
        return max(0, self.total - 1) // self.per_page + 1

    @property
    def has_prev(self):
        return self.page > 1

    @property
    def has_next(self):
        return self.page < self.pages

    @property
    def prev_url(self):
        return self.url(page=self.page - 1)

    @property
    def next_url(self):
        return self.url(page=self.page + 1)


VALID_CALLBACK_RE = re.compile(r'^[$a-z_][0-9a-z_\.\[\]]*$', re.I)

# Reserved words list from http://javascript.about.com/library/blreserved.htm
JSONP_RESERVED_WORDS = frozenset((
    'abstract', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class',
    'const', 'continue', 'debugger', 'default', 'delete', 'do', 'double',
    'else', 'enum', 'export', 'extends', 'false', 'final', 'finally', 'float',
    'for', 'function', 'goto', 'if', 'implements', 'import', 'in',
    'instanceof', 'int', 'interface', 'long', 'native', 'new', 'null',
    'package', 'private', 'protected', 'public', 'return', 'short', 'static',
    'super', 'switch', 'synchronized', 'this', 'throw', 'throws', 'transient',
    'true', 'try', 'typeof', 'var', 'void', 'volatile', 'while', 'with',
))


def is_valid_json_callback_name(callback_name):
    if not callback_name:
        return False

    # Callbacks longer than 50 characters are suspicious.
    # There isn't a legit reason for a callback longer.
    # The length is arbitrary too.
    # It's technically possible to construct malicious payloads using
    # only ascii characters, so we just block this.
    if len(callback_name) > 50:
        return False

    if not VALID_CALLBACK_RE.match(callback_name):
        return False

    if callback_name in JSONP_RESERVED_WORDS:
        return False

    return True


def generate_camouflage_url(camo_url, camo_key, url):
    digest = hmac.new(
        camo_key.encode("utf8"),
        url.encode("utf8"),
        digestmod=hashlib.sha1,
    ).hexdigest()
    return "".join([
        camo_url,
        "/".join([
            digest,
            binascii.hexlify(url.encode("utf8")).decode("utf8")
        ]),
    ])


def camouflage_images(camo_url, camo_key, html):
    # Parse SRC as HTML.
    tree_builder = html5lib.treebuilders.getTreeBuilder("dom")
    parser = html5lib.html5parser.HTMLParser(tree=tree_builder)
    dom = parser.parse(html)

    for e in dom.getElementsByTagName("img"):
        u = e.getAttribute("src")
        if u:
            e.setAttribute(
                "src",
                generate_camouflage_url(camo_url, camo_key, u),
            )

    tree_walker = html5lib.treewalkers.getTreeWalker("dom")
    html_serializer = html5lib.serializer.htmlserializer.HTMLSerializer()
    return "".join(html_serializer.serialize(tree_walker(dom)))


def cors(fn):
    @functools.wraps(fn)
    def wrapper(app, request, *args, **kwargs):
        # Get the response from the view
        resp = fn(app, request, *args, **kwargs)

        # Add our CORS headers
        resp.headers["Access-Control-Allow-Origin"] = "*"

        # Return the modified response
        return resp
    return wrapper


def vary_by(*varies):
    def deco(fn):
        @functools.wraps(fn)
        def wrapper(app, request, *args, **kwargs):
            # Get the response from the view
            resp = fn(app, request, *args, **kwargs)

            # Add our Vary headers
            resp.vary.update(varies)

            # Return the modified response
            return resp
        return wrapper
    return deco


def random_token(_urandom=os.urandom):
    token = base64.urlsafe_b64encode(_urandom(32)).rstrip(b"=")
    return token.decode("utf8")


def is_safe_url(url, host):
    """
    Return ``True`` if the url is a safe redirection (i.e. it doesn't point to
    a different host and uses a safe scheme).

    Always returns ``False`` on an empty url.
    """
    if not url:
        return False

    parsed = urllib.parse.urlparse(url)

    return ((not parsed.netloc or parsed.netloc == host) and
            (not parsed.scheme or parsed.scheme in ["http", "https"]))


def find_links_from_html(html_body):
    """
    Return a list of links, extracted from all <a href="{{ url
    }}">...</a> elements found.
    """
    document = html5lib.parse(html_body)
    return [a.attrib.get('href', None)
            for a in document.iter("{http://www.w3.org/1999/xhtml}a")
            if 'href' in a.attrib]

########NEW FILE########
__FILENAME__ = views
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from warehouse.templates import render_response
from warehouse.utils import cache


@cache(browser=1, varnish=120)
def index(app, request):
    return render_response(
        app, request, "index.html",
        project_count=app.db.packaging.get_project_count(),
        download_count=app.db.packaging.get_download_count(),
        recently_updated=app.db.packaging.get_recently_updated(),
    )

########NEW FILE########
__FILENAME__ = wsgi
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os

from warehouse.application import Warehouse
from warehouse.utils import get_wsgi_application


application = get_wsgi_application(os.environ, Warehouse)

########NEW FILE########
__FILENAME__ = __about__
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file is automatically generated, do not edit it


__all__ = [
    "__title__", "__summary__", "__uri__", "__version__",
    "__author__", "__email__", "__license__", "__copyright__",
]

__title__ = "warehouse"
__summary__ = "Next Generation Python Package Repository"
__uri__ = "https://github.com/pypa/warehouse"

__version__ = "14.2.1"
__build__ = "b388c51"

__author__ = "Donald Stufft"
__email__ = "donald@stufft.io"

__license__ = "Apache License, Version 2.0"
__copyright__ = "Copyright 2013 Donald Stufft"

########NEW FILE########
__FILENAME__ = __about__.tmpl
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This file is automatically generated, do not edit it


__all__ = [
    "__title__", "__summary__", "__uri__", "__version__",
    "__author__", "__email__", "__license__", "__copyright__",
]

__title__ = "warehouse"
__summary__ = "Next Generation Python Package Repository"
__uri__ = "https://github.com/pypa/warehouse"

__version__ = "{version}"
__build__ = "{build}"

__author__ = "Donald Stufft"
__email__ = "donald@stufft.io"

__license__ = "Apache License, Version 2.0"
__copyright__ = "Copyright 2013 Donald Stufft"

########NEW FILE########
__FILENAME__ = __main__
# Copyright 2013 Donald Stufft
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys

from warehouse.application import Warehouse


def main():
    return Warehouse.from_cli(sys.argv[1:])


if __name__ == "__main__":
    sys.exit(main())

########NEW FILE########
