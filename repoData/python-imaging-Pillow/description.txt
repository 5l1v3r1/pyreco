Original PIL README
===================

What follows is the original PIL 1.1.7 README file contents.

::

    The Python Imaging Library
    $Id$

    Release 1.1.7 (November 15, 2009)

    ====================================================================
    The Python Imaging Library 1.1.7
    ====================================================================

    Contents
    --------

    + Introduction
    + Support Options
      - Commercial support
      - Free support
    + Software License
    + Build instructions (all platforms)
      - Additional notes for Mac OS X
      - Additional notes for Windows

    --------------------------------------------------------------------
    Introduction
    --------------------------------------------------------------------

    The Python Imaging Library (PIL) adds image processing capabilities
    to your Python environment.  This library provides extensive file
    format support, an efficient internal representation, and powerful
    image processing capabilities.

    This source kit has been built and tested with Python 2.0 and newer,
    on Windows, Mac OS X, and major Unix platforms.  Large parts of the
    library also work on 1.5.2 and 1.6.

    The main distribution site for this software is:

            http://www.pythonware.com/products/pil/

    That site also contains information about free and commercial support
    options, PIL add-ons, answers to frequently asked questions, and more.


    Development versions (alphas, betas) are available here:

            http://effbot.org/downloads/


    The PIL handbook is not included in this distribution; to get the
    latest version, check:

            http://www.pythonware.com/library/
            http://effbot.org/books/imagingbook/ (drafts)


    For installation and licensing details, see below.


    --------------------------------------------------------------------
    Support Options
    --------------------------------------------------------------------

    + Commercial Support

    Secret Labs (PythonWare) offers support contracts for companies using
    the Python Imaging Library in commercial applications, and in mission-
    critical environments.  The support contract includes technical support,
    bug fixes, extensions to the PIL library, sample applications, and more.

    For the full story, check:

            http://www.pythonware.com/products/pil/support.htm


    + Free Support

    For support and general questions on the Python Imaging Library, send
    e-mail to the Image SIG mailing list:

            image-sig@python.org

    You can join the Image SIG by sending a mail to:

            image-sig-request@python.org

    Put "subscribe" in the message body to automatically subscribe to the
    list, or "help" to get additional information.  Alternatively, you can
    send your questions to the Python mailing list, python-list@python.org,
    or post them to the newsgroup comp.lang.python.  DO NOT SEND SUPPORT
    QUESTIONS TO PYTHONWARE ADDRESSES.


    --------------------------------------------------------------------
    Software License
    --------------------------------------------------------------------

    The Python Imaging Library is

    Copyright (c) 1997-2009 by Secret Labs AB
    Copyright (c) 1995-2009 by Fredrik Lundh

    By obtaining, using, and/or copying this software and/or its
    associated documentation, you agree that you have read, understood,
    and will comply with the following terms and conditions:

    Permission to use, copy, modify, and distribute this software and its
    associated documentation for any purpose and without fee is hereby
    granted, provided that the above copyright notice appears in all
    copies, and that both that copyright notice and this permission notice
    appear in supporting documentation, and that the name of Secret Labs
    AB or the author not be used in advertising or publicity pertaining to
    distribution of the software without specific, written prior
    permission.

    SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO
    THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
    FITNESS.  IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR
    ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
    OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.


    --------------------------------------------------------------------
    Build instructions (all platforms)
    --------------------------------------------------------------------

    For a list of changes in this release, see the CHANGES document.

    0. If you're in a hurry, try this:

            $ tar xvfz Imaging-1.1.7.tar.gz
            $ cd Imaging-1.1.7
            $ python setup.py install

       If you prefer to know what you're doing, read on.


    1. Prerequisites.

       If you need any of the features described below, make sure you
       have the necessary libraries before building PIL.

       feature              library
       -----------------------------------------------------------------
       JPEG support         libjpeg (6a or 6b)

                            http://www.ijg.org
                            http://www.ijg.org/files/jpegsrc.v6b.tar.gz
                            ftp://ftp.uu.net/graphics/jpeg/

       PNG support          zlib (1.2.3 or later is recommended)

                            http://www.gzip.org/zlib/

       OpenType/TrueType    freetype2 (2.3.9 or later is recommended)
       support
                            http://www.freetype.org
                            http://freetype.sourceforge.net

       CMS support          littleCMS (1.1.5 or later is recommended)
       support
                            http://www.littlecms.com/

       If you have a recent Linux version, the libraries provided with the
       operating system usually work just fine.  If some library is
       missing, installing a prebuilt version (jpeg-devel, zlib-devel,
       etc) is usually easier than building from source.  For example, for
       Ubuntu 9.10 (karmic), you can install the following libraries:

           sudo apt-get install libjpeg62-dev
           sudo apt-get install zlib1g-dev
           sudo apt-get install libfreetype6-dev
           sudo apt-get install liblcms1-dev

       If you're using Mac OS X, you can use the 'fink' tool to install
       missing libraries (also see the Mac OS X section below).

       Similar tools are available for many other platforms.


    2. To build under Python 1.5.2, you need to install the stand-alone
       version of the distutils library:

           http://www.python.org/sigs/distutils-sig/download.html

       You can fetch distutils 1.0.2 from the Python source repository:

           svn export http://svn.python.org/projects/python/tags/Distutils-1_0_2/Lib/distutils/

       For newer releases, the distutils library is included in the
       Python standard library.

       NOTE: Version 1.1.7 is not fully compatible with 1.5.2.  Some
       more recent additions to the library may not work, but the core
       functionality is available.


    3. If you didn't build Python from sources, make sure you have
       Python's build support files on your machine.  If you've down-
       loaded a prebuilt package (e.g. a Linux RPM), you probably
       need additional developer packages.  Look for packages named
       "python-dev", "python-devel", or similar.  For example, for
       Ubuntu 9.10 (karmic), use the following command:

           sudo apt-get install python-dev


    4. When you have everything you need, unpack the PIL distribution
       (the file Imaging-1.1.7.tar.gz) in a suitable work directory:

            $ cd MyExtensions # example
            $ gunzip Imaging-1.1.7.tar.gz
            $ tar xvf Imaging-1.1.7.tar


    5. Build the library.  We recommend that you do an in-place build,
       and run the self test before installing.

            $ cd Imaging-1.1.7
            $ python setup.py build_ext -i
            $ python selftest.py

       During the build process, the setup.py will display a summary
       report that lists what external components it found.  The self-
       test will display a similar report, with what external components
       the tests found in the actual build files:

            ----------------------------------------------------------------
            PIL 1.1.7 SETUP SUMMARY
            ----------------------------------------------------------------
            *** TKINTER support not available (Tcl/Tk 8.5 libraries needed)
            --- JPEG support available
            --- ZLIB (PNG/ZIP) support available
            --- FREETYPE support available
            ----------------------------------------------------------------

       Make sure that the optional components you need are included.

       If the build script won't find a given component, you can edit the
       setup.py file and set the appropriate ROOT variable.  For details,
       see instructions in the file.

       If the build script finds the component, but the tests cannot
       identify it, try rebuilding *all* modules:

            $ python setup.py clean
            $ python setup.py build_ext -i


    6. If the setup.py and selftest.py commands finish without any
       errors, you're ready to install the library:

            $ python setup.py install

       (depending on how Python has been installed on your machine,
       you might have to log in as a superuser to run the 'install'
       command, or use the 'sudo' command to run 'install'.)


    --------------------------------------------------------------------
    Additional notes for Mac OS X
    --------------------------------------------------------------------

    On Mac OS X you will usually install additional software such as
    libjpeg or freetype with the "fink" tool, and then it ends up in
    "/sw".  If you have installed the libraries elsewhere, you may have
    to tweak the "setup.py" file before building.


    --------------------------------------------------------------------
    Additional notes for Windows
    --------------------------------------------------------------------

    On Windows, you need to tweak the ROOT settings in the "setup.py"
    file, to make it find the external libraries.  See comments in the
    file for details.

    Make sure to build PIL and the external libraries with the same
    runtime linking options as was used for the Python interpreter
    (usually /MD, under Visual Studio).


    Note that most Python distributions for Windows include libraries
    compiled for Microsoft Visual Studio.  You can get the free Express
    edition of Visual Studio from:

        http://www.microsoft.com/Express/

    To build extensions using other tool chains, see the "Using
    non-Microsoft compilers on Windows" section in the distutils handbook:

        http://www.python.org/doc/current/inst/non-ms-compilers.html

    For additional information on how to build extensions using the
    popular MinGW compiler, see:

        http://mingw.org (compiler)
        http://sebsauvage.net/python/mingw.html (build instructions)
        http://sourceforge.net/projects/gnuwin32 (prebuilt libraries)

OleFileIO_PL
============

[OleFileIO_PL](http://www.decalage.info/python/olefileio) is a Python module to parse and read [Microsoft OLE2 files (also called Structured Storage, Compound File Binary Format or Compound Document File Format)](http://en.wikipedia.org/wiki/Compound_File_Binary_Format), such as Microsoft Office documents, Image Composer and FlashPix files, Outlook messages, StickyNotes, several Microscopy file formats ...

This is an improved version of the OleFileIO module from [PIL](http://www.pythonware.com/products/pil/index.htm), the excellent Python Imaging Library, created and maintained by Fredrik Lundh. The API is still compatible with PIL, but since 2005 I have improved the internal implementation significantly, with new features, bugfixes and a more robust design.

As far as I know, this module is now the most complete and robust Python implementation to read MS OLE2 files, portable on several operating systems. (please tell me if you know other similar Python modules)

OleFileIO_PL can be used as an independent module or with PIL. The goal is to have it integrated into [Pillow](http://python-imaging.github.io/), the friendly fork of PIL.

OleFileIO\_PL is mostly meant for developers. If you are looking for tools to analyze OLE files or to extract data, then please also check [python-oletools](http://www.decalage.info/python/oletools), which are built upon OleFileIO_PL.

News
----

Follow all updates and news on Twitter: <https://twitter.com/decalage2>

- **2014-02-04 v0.30**: now compatible with Python 3.x, thanks to Martin Panter who did most of the hard work.
- 2013-07-24 v0.26: added methods to parse stream/storage timestamps, improved listdir to include storages, fixed parsing of direntry timestamps
- 2013-05-27 v0.25: improved metadata extraction, properties parsing and exception handling, fixed [issue #12](https://bitbucket.org/decalage/olefileio_pl/issue/12/error-when-converting-timestamps-in-ole)
- 2013-05-07 v0.24: new features to extract metadata (get\_metadata method and OleMetadata class), improved getproperties to convert timestamps to Python datetime
- 2012-10-09: published [python-oletools](http://www.decalage.info/python/oletools), a package of analysis tools based on OleFileIO_PL
- 2012-09-11 v0.23: added support for file-like objects, fixed [issue #8](https://bitbucket.org/decalage/olefileio_pl/issue/8/bug-with-file-object)
- 2012-02-17 v0.22: fixed issues #7 (bug in getproperties) and #2 (added close method)
- 2011-10-20: code hosted on bitbucket to ease contributions and bug tracking
- 2010-01-24 v0.21: fixed support for big-endian CPUs, such as PowerPC Macs.
- 2009-12-11 v0.20: small bugfix in OleFileIO.open when filename is not plain str.
- 2009-12-10 v0.19: fixed support for 64 bits platforms (thanks to Ben G. and Martijn for reporting the bug)
- see changelog in source code for more info.

Download
--------

The archive is available on [the project page](https://bitbucket.org/decalage/olefileio_pl/downloads).

Features
--------

- Parse and read any OLE file such as Microsoft Office 97-2003 legacy document formats (Word .doc, Excel .xls, PowerPoint .ppt, Visio .vsd, Project .mpp), Image Composer and FlashPix files, Outlook messages, StickyNotes, Zeiss AxioVision ZVI files, Olympus FluoView OIB files, ...
- List all the streams and storages contained in an OLE file
- Open streams as files
- Parse and read property streams, containing metadata of the file
- Portable, pure Python module, no dependency


Main improvements over the original version of OleFileIO in PIL:
----------------------------------------------------------------

- Compatible with Python 3.x and 2.6+
- Many bug fixes
- Support for files larger than 6.8MB
- Support for 64 bits platforms and big-endian CPUs
- Robust: many checks to detect malformed files
- Runtime option to choose if malformed files should be parsed or raise exceptions
- Improved API
- Metadata extraction, stream/storage timestamps (e.g. for document forensics)
- Can open file-like objects
- Added setup.py and install.bat to ease installation
- More convenient slash-based syntax for stream paths



How to use this module
----------------------

OleFileIO_PL can be used as an independent module or with PIL. The main functions and methods are explained below.

For more information, see also the file **OleFileIO_PL.html**, sample code at the end of the module itself, and docstrings within the code.

### About the structure of OLE files ###

An OLE file can be seen as a mini file system or a Zip archive: It contains **streams** of data that look like files embedded within the OLE file. Each stream has a name. For example, the main stream of a MS Word document containing its text is named "WordDocument".

An OLE file can also contain **storages**. A storage is a folder that contains streams or other storages. For example, a MS Word document with VBA macros has a storage called "Macros".

Special streams can contain **properties**. A property is a specific value that can be used to store information such as the metadata of a document (title, author, creation date, etc). Property stream names usually start with the character '\x05'.

For example, a typical MS Word document may look like this:

	\x05DocumentSummaryInformation (stream)
	\x05SummaryInformation (stream)
	WordDocument (stream)
	Macros (storage)
		PROJECT (stream)
		PROJECTwm (stream)
		VBA (storage)
			Module1 (stream)
			ThisDocument (stream)
			_VBA_PROJECT (stream)
			dir (stream)
	ObjectPool (storage)



### Import OleFileIO_PL ###

	:::python
		import OleFileIO_PL

As of version 0.30, the code has been changed to be compatible with Python 3.x. As a consequence, compatibility with Python 2.5 or older is not provided anymore. However, a copy of v0.26 is available as OleFileIO_PL2.py. If your application needs to be compatible with Python 2.5 or older, you may use the following code to load the old version when needed:

	:::python
		try:
			import OleFileIO_PL
		except:
			import OleFileIO_PL2 as OleFileIO_PL

If you think OleFileIO_PL should stay compatible with Python 2.5 or older, please [contact me](http://decalage.info/contact).


### Test if a file is an OLE container ###

Use isOleFile to check if the first bytes of the file contain the Magic for OLE files, before opening it. isOleFile returns True if it is an OLE file, False otherwise (new in v0.16).

	:::python
		assert OleFileIO_PL.isOleFile('myfile.doc')


### Open an OLE file from disk ###

Create an OleFileIO object with the file path as parameter:

	:::python
		ole = OleFileIO_PL.OleFileIO('myfile.doc')

### Open an OLE file from a file-like object ###

This is useful if the file is not on disk, e.g. already stored in a string or as a file-like object.

	:::python
		ole = OleFileIO_PL.OleFileIO(f)

For example the code below reads a file into a string, then uses BytesIO to turn it into a file-like object.

	:::python
		data = open('myfile.doc', 'rb').read()
		f = io.BytesIO(data) # or StringIO.StringIO for Python 2.x
		ole = OleFileIO_PL.OleFileIO(f)

### How to handle malformed OLE files ###

By default, the parser is configured to be as robust and permissive as possible, allowing to parse most malformed OLE files. Only fatal errors will raise an exception. It is possible to tell the parser to be more strict in order to raise exceptions for files that do not fully conform to the OLE specifications, using the raise_defect option (new in v0.14):

	:::python
		ole = OleFileIO_PL.OleFileIO('myfile.doc', raise_defects=DEFECT_INCORRECT)

When the parsing is done, the list of non-fatal issues detected is available as a list in the parsing_issues attribute of the OleFileIO object (new in 0.25):

	:::python
        print('Non-fatal issues raised during parsing:')
        if ole.parsing_issues:
            for exctype, msg in ole.parsing_issues:
                print('- %s: %s' % (exctype.__name__, msg))
        else:
            print('None')


### Syntax for stream and storage path ###

Two different syntaxes are allowed for methods that need or return the path of streams and storages:

1) Either a **list of strings** including all the storages from the root up to the stream/storage name. For example a stream called "WordDocument" at the root will have ['WordDocument'] as full path. A stream called "ThisDocument" located in the storage "Macros/VBA" will be ['Macros', 'VBA', 'ThisDocument']. This is the original syntax from PIL. While hard to read and not very convenient, this syntax works in all cases.

2) Or a **single string with slashes** to separate storage and stream names (similar to the Unix path syntax). The previous examples would be 'WordDocument' and 'Macros/VBA/ThisDocument'. This syntax is easier, but may fail if a stream or storage name contains a slash. (new in v0.15)

Both are case-insensitive.

Switching between the two is easy:

	:::python
		slash_path = '/'.join(list_path)
		list_path  = slash_path.split('/')


### Get the list of streams ###

listdir() returns a list of all the streams contained in the OLE file, including those stored in storages. Each stream is listed itself as a list, as described above.

	:::python
		print(ole.listdir())

Sample result:

	:::python
		[['\x01CompObj'], ['\x05DocumentSummaryInformation'], ['\x05SummaryInformation']
		, ['1Table'], ['Macros', 'PROJECT'], ['Macros', 'PROJECTwm'], ['Macros', 'VBA',
		'Module1'], ['Macros', 'VBA', 'ThisDocument'], ['Macros', 'VBA', '_VBA_PROJECT']
		, ['Macros', 'VBA', 'dir'], ['ObjectPool'], ['WordDocument']]

As an option it is possible to choose if storages should also be listed, with or without streams (new in v0.26):

	:::python
		ole.listdir (streams=False, storages=True)


### Test if known streams/storages exist: ###

exists(path) checks if a given stream or storage exists in the OLE file (new in v0.16).

	:::python
		if ole.exists('worddocument'):
		    print("This is a Word document.")
		    if ole.exists('macros/vba'):
		         print("This document seems to contain VBA macros.")


### Read data from a stream ###

openstream(path) opens a stream as a file-like object.

The following example extracts the "Pictures" stream from a PPT file:

	:::python
	    pics = ole.openstream('Pictures')
	    data = pics.read()


### Get information about a stream/storage ###

Several methods can provide the size, type and timestamps of a given stream/storage:

get_size(path) returns the size of a stream in bytes (new in v0.16):

	:::python
		s = ole.get_size('WordDocument')

get_type(path) returns the type of a stream/storage, as one of the following constants: STGTY\_STREAM for a stream, STGTY\_STORAGE for a storage, STGTY\_ROOT for the root entry, and False for a non existing path (new in v0.15).

	:::python
		t = ole.get_type('WordDocument')

get\_ctime(path) and get\_mtime(path) return the creation and modification timestamps of a stream/storage, as a Python datetime object with UTC timezone. Please note that these timestamps are only present if the application that created the OLE file explicitly stored them, which is rarely the case. When not present, these methods return None (new in v0.26).

	:::python
		c = ole.get_ctime('WordDocument')
		m = ole.get_mtime('WordDocument')

The root storage is a special case: You can get its creation and modification timestamps using the OleFileIO.root attribute (new in v0.26):

	:::python
		c = ole.root.getctime()
		m = ole.root.getmtime()

### Extract metadata ###

get_metadata() will check if standard property streams exist, parse all the properties they contain, and return an OleMetadata object with the found properties as attributes (new in v0.24).

	:::python
		meta = ole.get_metadata()
		print('Author:', meta.author)
		print('Title:', meta.title)
		print('Creation date:', meta.create_time)
		# print all metadata:
		meta.dump()

Available attributes include:

    codepage, title, subject, author, keywords, comments, template,
    last_saved_by, revision_number, total_edit_time, last_printed, create_time,
    last_saved_time, num_pages, num_words, num_chars, thumbnail,
    creating_application, security, codepage_doc, category, presentation_target,
    bytes, lines, paragraphs, slides, notes, hidden_slides, mm_clips,
    scale_crop, heading_pairs, titles_of_parts, manager, company, links_dirty,
    chars_with_spaces, unused, shared_doc, link_base, hlinks, hlinks_changed,
    version, dig_sig, content_type, content_status, language, doc_version

See the source code of the OleMetadata class for more information.


### Parse a property stream ###

get\_properties(path) can be used to parse any property stream that is not handled by get\_metadata. It returns a dictionary indexed by integers. Each integer is the index of the property, pointing to its value. For example in the standard property stream '\x05SummaryInformation', the document title is property #2, and the subject is #3.

	:::python
		p = ole.getproperties('specialprops')

By default as in the original PIL version, timestamp properties are converted into a number of seconds since Jan 1,1601. With the option convert\_time, you can obtain more convenient Python datetime objects (UTC timezone). If some time properties should not be converted (such as total editing time in '\x05SummaryInformation'), the list of indexes can be passed as no_conversion (new in v0.25):

	:::python
		p = ole.getproperties('specialprops', convert_time=True, no_conversion=[10])


### Close the OLE file ###

Unless your application is a simple script that terminates after processing an OLE file, do not forget to close each OleFileIO object after parsing to close the file on disk. (new in v0.22)

	:::python
		ole.close()

### Use OleFileIO_PL as a script ###

OleFileIO_PL can also be used as a script from the command-line to display the structure of an OLE file and its metadata, for example:

	OleFileIO_PL.py myfile.doc

You can use the option -c to check that all streams can be read fully, and -d to generate very verbose debugging information.

## Real-life examples ##

A real-life example: [using OleFileIO_PL for malware analysis and forensics](http://blog.gregback.net/2011/03/using-remnux-for-forensic-puzzle-6/).

See also [this paper](https://computer-forensics.sans.org/community/papers/gcfa/grow-forensic-tools-taxonomy-python-libraries-helpful-forensic-analysis_6879) about python tools for forensics, which features OleFileIO_PL.

About Python 2 and 3
--------------------

OleFileIO\_PL used to support only Python 2.x. As of version 0.30, the code has been changed to be compatible with Python 3.x. As a consequence, compatibility with Python 2.5 or older is not provided anymore. However, a copy of v0.26 is available as OleFileIO_PL2.py. See above the "import" section for a workaround.

If you think OleFileIO_PL should stay compatible with Python 2.5 or older, please [contact me](http://decalage.info/contact).

How to contribute
-----------------

The code is available in [a Mercurial repository on bitbucket](https://bitbucket.org/decalage/olefileio_pl). You may use it to submit enhancements or to report any issue.

If you would like to help us improve this module, or simply provide feedback, please [contact me](http://decalage.info/contact). You can help in many ways:

- test this module on different platforms / Python versions
- find and report bugs
- improve documentation, code samples, docstrings
- write unittest test cases
- provide tricky malformed files

How to report bugs
------------------

To report a bug, for example a normal file which is not parsed correctly, please use the [issue reporting page](https://bitbucket.org/decalage/olefileio_pl/issues?status=new&status=open), or if you prefer to do it privately, use this [contact form](http://decalage.info/contact). Please provide all the information about the context and how to reproduce the bug.

If possible please join the debugging output of OleFileIO_PL. For this, launch the following command :

	OleFileIO_PL.py -d -c file >debug.txt

License
-------

OleFileIO_PL is open-source.

OleFileIO_PL changes are Copyright (c) 2005-2014 by Philippe Lagadec.

The Python Imaging Library (PIL) is

- Copyright (c) 1997-2005 by Secret Labs AB

- Copyright (c) 1995-2005 by Fredrik Lundh

By obtaining, using, and/or copying this software and/or its associated documentation, you agree that you have read, understood, and will comply with the following terms and conditions:

Permission to use, copy, modify, and distribute this software and its associated documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appears in all copies, and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Secret Labs AB or the author not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.

SECRET LABS AB AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL SECRET LABS AB OR THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
Pillow
======

*Python Imaging Library (Fork)*

Pillow is the "friendly" PIL fork by Alex Clark and Contributors. PIL is the Python Imaging Library by Fredrik Lundh and Contributors.

.. image:: https://travis-ci.org/python-imaging/Pillow.svg?branch=master
   :target: https://travis-ci.org/python-imaging/Pillow
   :alt: Travis CI build status

.. image:: https://pypip.in/v/Pillow/badge.png
    :target: https://pypi.python.org/pypi/Pillow/
    :alt: Latest PyPI version

.. image:: https://pypip.in/d/Pillow/badge.png
    :target: https://pypi.python.org/pypi/Pillow/
    :alt: Number of PyPI downloads

.. image:: https://coveralls.io/repos/python-imaging/Pillow/badge.png?branch=master
  :target: https://coveralls.io/r/python-imaging/Pillow?branch=master

The documentation is hosted at http://pillow.readthedocs.org/. It contains installation instructions, tutorials, reference, compatibility details, and more.


Python SANE module V1.1 (30 Sep. 2004)

The SANE module provides an interface to the SANE scanner and frame
grabber interface for Linux.  This module was contributed by Andrew
Kuchling and is extended and currently maintained by Ralph Heinkel
(rheinkel-at-email.de). If you write to me please make sure to have the
word 'SANE' or 'sane' in the subject of your mail, otherwise it might
be classified as spam in the future.


To build this module, type (in the Sane directory):

	python setup.py build

In order to install the module type:

	python setup.py install


For some basic documentation please look at the file sanedoc.txt
The two demo_*.py scripts give basic examples on how to use the software.

-------
Scripts
-------

This directory contains a number of more or less trivial utilities
and demo programs.

Comments and contributions are welcome.

</F>

--------------------------------------------------------------------
pildriver.py (by Eric S. Raymond)

A class implementing an image-processing calculator for scripts.
Parses lists of commnds (or, called interactively, command-line
arguments) into image loads, transformations, and saves.

--------------------------------------------------------------------
viewer.py

A simple image viewer.  Can display all file formats handled by
PIL.  Transparent images are properly handled.

--------------------------------------------------------------------
thresholder.py

A simple utility that demonstrates how a transparent 1-bit overlay
can be used to show the current thresholding of an 8-bit image.

--------------------------------------------------------------------
enhancer.py

Illustrates the ImageEnhance module.  Drag the sliders to modify the
images.  This might be very slow on some platforms, depending on the
Tk version.

--------------------------------------------------------------------
painter.py

Illustrates how a painting program could be based on PIL and Tk.
Press the left mouse button and drag over the image to remove the
colour.  Some clever tricks have been used to get decent performance
when updating the screen; see the sources for details.

--------------------------------------------------------------------
player.py

A simple image sequence player.  You can use either a sequence format
like FLI/FLC, GIF, or ARG, or give a number of images which are
interpreted as frames in a sequence.  All frames must have the same
size.

--------------------------------------------------------------------
gifmaker.py

Convert a sequence file to a GIF animation.

Note that the GIF encoder provided with this release of PIL writes
uncompressed GIF files only, so the resulting animations are rather
large compared with these created by other tools.

--------------------------------------------------------------------
explode.py

Split a sequence file into individual frames.

--------------------------------------------------------------------
image2py.py

Convert an image to a Python module containing an IMAGE variable.
Note that the module using the module must include JPEG and ZIP
decoders, unless the -u option is used.

--------------------------------------------------------------------
olesummary.py

Uses the OleFileIO module to dump the summary information from an OLE
structured storage file.  This works with most OLE files, including
Word documents, FlashPix images, etc.

Note that datetime fields currently show the number of seconds since
January 1st, 1601.

These images are from the bmpsuite:
https://github.com/jsummers/bmpsuite and are in the public domain
according to the readme in the project.

Minimalistic PIL test framework.

Test scripts are named "test_xxx" and are supposed to output "ok". That's it. To run the tests::

    python setup.py develop

Run the tests from the root of the Pillow source distribution:

    python selftest.py
    python Tests/run.py --installed

To run an individual test:

    python Tests/test_image.py

