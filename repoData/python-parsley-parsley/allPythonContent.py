__FILENAME__ = calc
import math
from parsley import makeGrammar

def calculate(start, pairs):
        result = start
        for op, value in pairs:
            if op == '+':
                result += value
            elif op == '-':
                result -= value
            elif op == '*':
                result *= value
            elif op == '/':
                result /= value
        return result

calcGrammar = """
number = <digit+>:ds -> int(ds)
parens = '(' ws expr:e ws ')' -> e
value = number | parens
ws = ' '*
add = '+' ws expr2:n -> ('+', n)
sub = '-' ws expr2:n -> ('-', n)
mul = '*' ws value:n -> ('*', n)
div = '/' ws value:n -> ('/', n)

addsub = ws (add | sub)
muldiv = ws (mul | div)

expr = expr2:left addsub*:right -> calculate(left, right)
expr2 = value:left muldiv*:right -> calculate(left, right)
"""

Calc = makeGrammar(calcGrammar, {"calculate": calculate}, name="Calc")

calcGrammarEx = """
value = super | constant
constant = 'pi' -> math.pi
         | 'e' -> math.e
"""
CalcEx = makeGrammar(calcGrammarEx, {"math": math}, name="CalcEx",
                     extends=Calc)

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Parsley documentation build configuration file, created by
# sphinx-quickstart on Tue Aug 21 09:46:24 2012.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Parsley'
copyright = u'2013, Allen Short'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.2'
# The full version, including alpha/beta/rc tags.
release = '1.2'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Parsleydoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Parsley.tex', u'Parsley Documentation',
   u'Allen Short', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'parsley', u'Parsley Documentation',
     [u'Allen Short'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'Parsley', u'Parsley Documentation',
   u'Allen Short', 'Parsley', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = test_calc
from calc import Calc
import unittest

class CalcTest(unittest.TestCase):

    def test_calc(self):
        self.assertEqual(Calc("2 * (3 + 4 * 5)").expr(), 46)
        self.assertEqual(Calc("2 *( 3 + 40 /   5)").expr(), 22)
        self.assertEqual(Calc("2 + (4 * 3 + 40 /   5)").expr(), 22)

########NEW FILE########
__FILENAME__ = tutorial3-netstring-reversal
from twisted.internet.defer import Deferred
from twisted.internet.endpoints import TCP4ServerEndpoint
from twisted.internet.protocol import Factory
from twisted.internet.task import react

from parsley import makeProtocol, stack


grammar = """
nonzeroDigit = digit:x ?(x != '0')
digits = <'0' | nonzeroDigit digit*>:i -> int(i)

netstring = digits:length ':' <anything{length}>:string ',' -> string

receiveNetstring = netstring:string -> receiver.netstringReceived(string)
"""


class NetstringReversalWrapper(object):
    def __init__(self, wrapped):
        self.wrapped = wrapped

    def sendNetstring(self, string):
        self.wrapped.sendNetstring(string[::-1])


class NetstringSender(object):
    def __init__(self, transport):
        self.transport = transport

    def sendNetstring(self, string):
        self.transport.write('%d:%s,' % (len(string), string))


class NetstringSplittingWrapper(object):
    def __init__(self, wrapped):
        self.wrapped = wrapped

    def netstringReceived(self, string):
        splitpoint = len(string) // 2
        self.wrapped.netstringFirstHalfReceived(string[:splitpoint])
        self.wrapped.netstringSecondHalfReceived(string[splitpoint:])

    def __getattr__(self, attr):
        return getattr(self.wrapped, attr)


class SplitNetstringReceiver(object):
    currentRule = 'receiveNetstring'

    def __init__(self, sender):
        self.sender = sender

    def prepareParsing(self, parser):
        pass

    def finishParsing(self, reason):
        pass

    def netstringFirstHalfReceived(self, string):
        self.sender.sendNetstring(string)

    def netstringSecondHalfReceived(self, string):
        pass

pass  # begin protocol definition
NetstringProtocol = makeProtocol(
    grammar,
    stack(NetstringReversalWrapper, NetstringSender),
    stack(NetstringSplittingWrapper, SplitNetstringReceiver))

class NetstringFactory(Factory):
    protocol = NetstringProtocol


def main(reactor):
    server = TCP4ServerEndpoint(reactor, 1234)
    d = server.listen(NetstringFactory())
    d.addCallback(lambda p: Deferred())  # listen forever
    return d


react(main, [])

########NEW FILE########
__FILENAME__ = tutorial3-netstrings
from twisted.internet.defer import Deferred
from twisted.internet.endpoints import TCP4ServerEndpoint
from twisted.internet.protocol import Factory
from twisted.internet.task import react

from parsley import makeProtocol


grammar = """
nonzeroDigit = digit:x ?(x != '0')
digits = <'0' | nonzeroDigit digit*>:i -> int(i)

netstring = digits:length ':' <anything{length}>:string ',' -> string
receiveNetstring = netstring:string -> receiver.netstringReceived(string)
"""


class NetstringSender(object):
    def __init__(self, transport):
        self.transport = transport

    def sendNetstring(self, string):
        self.transport.write('%d:%s,' % (len(string), string))


class NetstringReceiver(object):
    currentRule = 'receiveNetstring'

    def __init__(self, sender):
        self.sender = sender

    def prepareParsing(self, parser):
        pass

    def finishParsing(self, reason):
        pass

    def netstringReceived(self, string):
        self.sender.sendNetstring(string)


NetstringProtocol = makeProtocol(
    grammar, NetstringSender, NetstringReceiver)


class NetstringFactory(Factory):
    protocol = NetstringProtocol


def main(reactor):
    server = TCP4ServerEndpoint(reactor, 1234)
    d = server.listen(NetstringFactory())
    d.addCallback(lambda p: Deferred())  # listen forever
    return d


react(main, [])

########NEW FILE########
__FILENAME__ = tutorial3-netstrings2
from twisted.internet.defer import Deferred
from twisted.internet.endpoints import TCP4ServerEndpoint
from twisted.internet.protocol import Factory
from twisted.internet.task import react

from parsley import makeProtocol


grammar = """
nonzeroDigit = digit:x ?(x != '0')
digits = <'0' | nonzeroDigit digit*>:i -> int(i)
netstring :delimiter = digits:length delimiter <anything{length}>:string ',' -> string

colon = digits:length ':' <anything{length}>:string ',' -> receiver.netstringReceived(':', string)
semicolon = digits:length ';' <anything{length}>:string ',' -> receiver.netstringReceived(';', string)
"""


class NetstringSender(object):
    def __init__(self, transport):
        self.transport = transport

    def sendNetstring(self, string):
        print 'received', repr(string)


class NetstringReceiver(object):
    currentRule = 'colon'

    def __init__(self, sender):
        self.sender = sender

    def prepareParsing(self, parser):
        pass

    def finishParsing(self, reason):
        reason.printTraceback()

    def netstringReceived(self, delimiter, string):
        self.sender.sendNetstring(string)
        if delimiter == ':':
            self.currentRule = 'semicolon'
        else:
            self.currentRule = 'colon'


NetstringProtocol = makeProtocol(
    grammar, NetstringSender, NetstringReceiver)


class NetstringFactory(Factory):
    protocol = NetstringProtocol


def main(reactor):
    server = TCP4ServerEndpoint(reactor, 1234)
    d = server.listen(NetstringFactory())
    d.addCallback(lambda p: Deferred())  # listen forever
    return d


react(main, [])

########NEW FILE########
__FILENAME__ = exceptions
"""
A grammar for parsing a tiny HTML-like language, plus a transformer for it.
"""
from parsley import makeGrammar, term, termMaker as t, unwrapGrammar
from itertools import chain

tinyHTMLGrammar = r"""

name = <letterOrDigit+>

tag = ((('<' spaces name:n spaces attribute*:attrs '>')
         html:c
         ('<' '/' token(n) spaces '>')
             -> t.Element(n.lower(), dict(attrs), c))) ^ (valid tag)

html = (text | tag)*

text = <(~('<') anything)+>

attribute = spaces name:k token('=') quotedString:v -> (k, v)

quotedString = ((('"' | '\''):q <(~exactly(q) anything)*>:xs exactly(q))
                     -> xs)

"""
TinyHTML = makeGrammar(tinyHTMLGrammar, globals(), name="TinyHTML")

testSource = "<html<title>Yes</title><body><h1>Man, HTML is <i>great</i>.</h1><p>How could you even <b>think</b> otherwise?</p><img src='HIPPO.JPG'></img><a href='http://twistedmatrix.com'>A Good Website</a></body></html>"

print(unwrapGrammar(TinyHTML)(testSource).apply('tag'))

# The "tag" rule uses the custom label construct "^ (valid tag)".
# When this rule fails, the exception raised will say
# "expected a valid tag".
#
# <html<title>Yes</title><body><h1>Man, HTML is <i>great</i>.</h1><p>How could you even <b>think</b> otherwise?</p><img src='HIPPO.JPG'></img><a href='http://twistedmatrix.com'>A Good Website</a></body></html>
# ^
# Parse error at line 1, column 5: expected a valid tag. trail: [name attribute tag]

########NEW FILE########
__FILENAME__ = iso8601
import datetime
import pytz

from parsley import makeGrammar

# See www.ietf.org/rfc/rfc3339.txt

_iso_8601_definition = r"""
year = <digit{4}>:Y -> int(Y)
month = <digit{2}>:m -> int(m)
day = <digit{2}>:d -> int(d)

hour = <digit{2}>:H -> int(H)
minute = <digit{2}>:M -> int(M)
second = <digit{2}>:S -> int(S)
fraction = '.' <digit+>:frac -> int(float('0.' + frac) * 10 ** 6)

sign = ('-' -> -1) | ('+' -> 1)
numeric_offset = sign:s hour:h ':' minute:m -> FixedOffset(s * (h * 60 + m))
utc = 'Z' -> UTC
offset = utc | numeric_offset

naive_time = hour:h ':' minute:m ':' second:s (fraction | -> 0):ms
             -> time(h, m, s, ms)
time = naive_time:t offset:o -> t.replace(tzinfo=o)
date = year:y '-' month:m '-' day:d -> date(y, m, d)

datetime = date:d 'T' time:t -> datetime.combine(d, t)
"""


DateTimeParser = makeGrammar(
    _iso_8601_definition,
    {
        'FixedOffset': pytz.FixedOffset,
        'date': datetime.date,
        'time': datetime.time,
        'datetime': datetime.datetime,
        'UTC': pytz.UTC,
    },
)

########NEW FILE########
__FILENAME__ = minml
"""
A grammar for parsing a tiny HTML-like language, plus a transformer for it.
"""
from parsley import makeGrammar, term, termMaker as t
from itertools import chain

tinyHTMLGrammar = r"""

name = <letterOrDigit+>

tag = ('<' spaces name:n spaces attribute*:attrs '>'
         html:c
         '<' '/' token(n) spaces '>'
             -> t.Element(n.lower(), dict(attrs), c))

html = (text | tag)*

text = <(~('<') anything)+>

attribute = spaces name:k token('=') quotedString:v -> (k, v)

quotedString = (('"' | '\''):q <(~exactly(q) anything)*>:xs exactly(q))
                     -> xs

"""
TinyHTML = makeGrammar(tinyHTMLGrammar, globals(), name="TinyHTML")

testSource = "<html><title>Yes</title><body><h1>Man, HTML is <i>great</i>.</h1><p>How could you even <b>think</b> otherwise?</p><img src='HIPPO.JPG'></img><a href='http://twistedmatrix.com'>A Good Website</a></body></html>"

print(TinyHTML(testSource).html())

########NEW FILE########
__FILENAME__ = parsley_json
from parsley import makeGrammar
jsonGrammar = r"""
ws = (' ' | '\r' | '\n' | '\t')*
object = ws '{' members:m ws '}' ws -> dict(m)
members = (pair:first (ws ',' pair)*:rest -> [first] + rest) | -> []
pair = ws string:k ws ':' value:v -> (k, v)
array = '[' elements:xs ws ']' -> xs
elements = (value:first (ws ',' value)*:rest -> [first] + rest) | -> []
value = ws (string | number | object | array
           | 'true'  -> True
           | 'false' -> False
           | 'null'  -> None)
string = '"' (escapedChar | ~'"' anything)*:c '"' -> ''.join(c)
escapedChar = '\\' (('"' -> '"')    |('\\' -> '\\')
                   |('/' -> '/')    |('b' -> '\b')
                   |('f' -> '\f')   |('n' -> '\n')
                   |('r' -> '\r')   |('t' -> '\t')
                   |('\'' -> '\'')  | escapedUnicode)
hexdigit = :x ?(x in '0123456789abcdefABCDEF') -> x
escapedUnicode = 'u' <hexdigit{4}>:hs -> unichr(int(hs, 16))
number = ('-' | -> ''):sign (intPart:ds (floatPart(sign ds)
                            | -> int(sign + ds)))
digit = :x ?(x in '0123456789') -> x
digits = <digit*>
digit1_9 = :x ?(x in '123456789') -> x
intPart = (digit1_9:first digits:rest -> first + rest) | digit
floatPart :sign :ds = <('.' digits exponent?) | exponent>:tail
                    -> float(sign + ds + tail)
exponent = ('e' | 'E') ('+' | '-')? digits

top = (object | array) ws
"""

JSONParser = makeGrammar(jsonGrammar, {})

########NEW FILE########
__FILENAME__ = netstrings
grammar = """

nonzeroDigit = digit:x ?(x != '0')
digits = <'0' | nonzeroDigit digit*>:i -> int(i)

netstring = digits:length ':' <anything{length}>:string ',' -> string

receiveNetstring = netstring:string -> receiver.netstringReceived(string)

"""

class NetstringSender(object):
    def __init__(self, transport):
        self.transport = transport

    def sendNetstring(self, string):
        self.transport.write('%d:%s,' % (len(string), string))

########NEW FILE########
__FILENAME__ = netstring_reversal
from twisted.internet.defer import Deferred
from twisted.internet.endpoints import TCP4ServerEndpoint
from twisted.internet.protocol import ServerFactory
from twisted.internet.task import react

from parsley import makeProtocol
from netstrings import grammar, NetstringSender


class NetstringReverserReceiver(object):
    currentRule = 'receiveNetstring'

    def __init__(self, sender):
        self.sender = sender

    def prepareParsing(self, parser):
        pass

    def finishParsing(self, reason):
        pass

    def netstringReceived(self, string):
        self.sender.sendNetstring(string[::-1])


NetstringReverser = makeProtocol(
    grammar, NetstringSender, NetstringReverserReceiver)


class NetstringReverserFactory(ServerFactory):
    protocol = NetstringReverser


def main(reactor):
    server = TCP4ServerEndpoint(reactor, 1234)
    d = server.listen(NetstringReverserFactory())
    d.addCallback(lambda p: Deferred())
    return d

react(main, [])

########NEW FILE########
__FILENAME__ = test_netstrings
import parsley
import pytest
import netstrings

proto_helpers = pytest.importorskip('twisted.test.proto_helpers')
StringTransport = proto_helpers.StringTransport


netstringGrammar = parsley.makeGrammar(netstrings.grammar, {})

def stringParserFromRule(rule):
    def parseString(s):
        return getattr(netstringGrammar(s), rule)()
    return parseString

def test_digits_parsing():
    parse = stringParserFromRule('digits')

    assert parse('0') == 0
    assert parse('1') == 1
    assert parse('1234567890') == 1234567890
    with pytest.raises(parsley.ParseError):
        parse('01')
    with pytest.raises(parsley.ParseError):
        parse('0001')

def test_netstring_parsing():
    parse = stringParserFromRule('netstring')

    assert parse('0:,') == ''
    assert parse('1:x,') == 'x'
    assert parse('10:abcdefghij,') == 'abcdefghij'


def build_testing_sender():
    transport = StringTransport()
    sender = netstrings.NetstringSender(transport)
    return sender, transport

def test_sending_empty_netstring():
    sender, transport = build_testing_sender()
    sender.sendNetstring('')
    assert transport.value() == '0:,'

def test_sending_one_netstring():
    sender, transport = build_testing_sender()
    sender.sendNetstring('foobar')
    assert transport.value() == '6:foobar,'

def test_sending_two_netstrings():
    sender, transport = build_testing_sender()
    sender.sendNetstring('spam')
    sender.sendNetstring('egggs')
    assert transport.value() == '4:spam,5:egggs,'


class FakeReceiver(object):
    currentRule = 'receiveNetstring'

    def __init__(self, sender):
        self.sender = sender
        self.netstrings = []
        self.connected = False
        self.lossReason = None

    def netstringReceived(self, s):
        self.netstrings.append(s)

    def prepareParsing(self, parser):
        self.connected = True

    def finishParsing(self, reason):
        self.lossReason = reason

TestingNetstringProtocol = parsley.makeProtocol(
    netstrings.grammar, netstrings.NetstringSender, FakeReceiver)

def build_testing_protocol():
    protocol = TestingNetstringProtocol()
    transport = StringTransport()
    protocol.makeConnection(transport)
    return protocol, transport

def test_receiving_empty_netstring():
    protocol, transport = build_testing_protocol()
    protocol.dataReceived('0:,')
    assert protocol.receiver.netstrings == ['']

def test_receiving_one_netstring_by_byte():
    protocol, transport = build_testing_protocol()
    for c in '4:spam,':
        protocol.dataReceived(c)
    assert protocol.receiver.netstrings == ['spam']

def test_receiving_two_netstrings_by_byte():
    protocol, transport = build_testing_protocol()
    for c in '4:spam,4:eggs,':
        protocol.dataReceived(c)
    assert protocol.receiver.netstrings == ['spam', 'eggs']

def test_receiving_two_netstrings_in_chunks():
    protocol, transport = build_testing_protocol()
    for c in ['4:', 'spa', 'm,4', ':eg', 'gs,']:
        protocol.dataReceived(c)
    assert protocol.receiver.netstrings == ['spam', 'eggs']

def test_receiving_two_netstrings_at_once():
    protocol, transport = build_testing_protocol()
    protocol.dataReceived('4:spam,4:eggs,')
    assert protocol.receiver.netstrings == ['spam', 'eggs']

def test_establishing_connection():
    assert not FakeReceiver(None).connected
    protocol, transport = build_testing_protocol()
    assert protocol.receiver.connected

def test_losing_connection():
    protocol, transport = build_testing_protocol()
    reason = object()
    protocol.connectionLost(reason)
    assert protocol.receiver.lossReason == reason

########NEW FILE########
__FILENAME__ = test_iso8601
import datetime
import unittest

import pytest

pytz = pytest.importorskip('pytz')
from iso8601 import DateTimeParser


class TestDatetimeParsing(unittest.TestCase):
    def test_date(self):
        self.assertEqual(
            datetime.date(2001, 12, 25),
            DateTimeParser('2001-12-25').date())

    def test_naive_time(self):
        self.assertEqual(
            datetime.time(13, 59, 43),
            DateTimeParser('13:59:43').naive_time())

    def test_fractional_naive_time(self):
        self.assertEqual(
            datetime.time(13, 59, 43, 880000),
            DateTimeParser('13:59:43.88').naive_time())

    def test_utc_time(self):
        self.assertEqual(
            datetime.time(13, 59, 43, tzinfo=pytz.UTC),
            DateTimeParser('13:59:43Z').time())

    def test_fractional_utc_time(self):
        self.assertEqual(
            datetime.time(13, 59, 43, 880000, tzinfo=pytz.UTC),
            DateTimeParser('13:59:43.88Z').time())

    def test_timezone_time(self):
        self.assertEqual(
            datetime.time(13, 59, 43, tzinfo=pytz.FixedOffset(60)),
            DateTimeParser('13:59:43+01:00').time())

    def test_fractional_timezone_time(self):
        self.assertEqual(
            datetime.time(13, 59, 43, 770000, tzinfo=pytz.FixedOffset(60)),
            DateTimeParser('13:59:43.77+01:00').time())

    def test_numeric_offset(self):
        get_offset = lambda x: DateTimeParser(x).numeric_offset()
        self.assertEqual(pytz.FixedOffset(0), get_offset('+00:00'))
        self.assertEqual(pytz.FixedOffset(90), get_offset('+01:30'))
        self.assertEqual(pytz.FixedOffset(-150), get_offset('-02:30'))

    def test_datetime(self):
        self.assertEqual(
            datetime.datetime(
                2001, 12, 25, 13, 59, 43, 770000, tzinfo=pytz.UTC),
            DateTimeParser('2001-12-25T13:59:43.77Z').datetime())

########NEW FILE########
__FILENAME__ = test_parsley_json
from __future__ import unicode_literals

from parsley_json import JSONParser
import unittest

class JSONParserTests(unittest.TestCase):


    def test_integer(self):
        self.assertEqual(JSONParser("123").number(), 123)
        self.assertEqual(JSONParser("-123").number(), -123)
        self.assertEqual(JSONParser("0").number(), 0)

    def test_float(self):
        self.assertEqual(JSONParser("0.5").number(), 0.5)
        self.assertEqual(JSONParser("1.0").number(), 1.0)
        self.assertEqual(JSONParser("-3.5").number(), -3.5)
        self.assertEqual(JSONParser("2e7").number(), 2e7)
        self.assertEqual(JSONParser("1.2E6").number(), 1.2E6)

    def test_string(self):
        self.assertEqual(JSONParser('u2603').escapedUnicode(), "\u2603")
        self.assertEqual(JSONParser('"foo"').string(), "foo")
        self.assertEqual(JSONParser(r'"foo\n"').string(), "foo\n")
        self.assertEqual(JSONParser(r'"foo\rbaz\u2603"').string(), "foo\rbaz\u2603")
        self.assertEqual(JSONParser(r'"\\\/\b\"\f\t"').string(), '\\/\b"\f\t')

    def test_literals(self):
        self.assertEqual(JSONParser(r'true').value(), True)
        self.assertEqual(JSONParser(r'false').value(), False)
        self.assertEqual(JSONParser(r'null').value(), None)

    def test_array(self):
        self.assertEqual(JSONParser(r'[1, 2]').array(), [1, 2])
        self.assertEqual(JSONParser(r'["foo", []]').array(), ["foo", []])

    def test_object(self):
        self.assertEqual(JSONParser(r'{"foo": 1}').object(), {"foo": 1})
        self.assertEqual(JSONParser(r'{"foo": "baz", "x": {}}').object(),
                         {"foo": "baz", "x": {}})


########NEW FILE########
__FILENAME__ = trace_json
from parsley import makeGrammar
from parsley_json import jsonGrammar


def traceparse(jsonData):
    trace = []
    def traceit(*a):
        trace.append(a)
    JSONParser = makeGrammar(jsonGrammar, {},
                             tracefunc=traceit)
    return JSONParser(jsonData).top(), trace

########NEW FILE########
__FILENAME__ = trace_visualiser
from tkinter.scrolledtext import ScrolledText
import tkinter as tk

from trace_json import traceparse
from parsley_json import jsonGrammar

jsonData = open('337141-steamcube.json').read()


class Tracer(object):

    def __init__(self, grammarWin, inputWin, logWin, trace):
        self.grammarWin = grammarWin
        self.inputWin = inputWin
        self.logWin = logWin
        self.trace = trace
        self.position = 0

    def advance(self):
        if self.position < len(self.trace):
            self.position += 1
            self.display()

    def rewind(self):
        if self.position > 0:
            self.position -= 1
            self.display()

    def display(self):
        def updateHighlight(w, start, end=None):
            w.tag_remove("highlight", "1.0", tk.END)
            start = "1.0+%sc" % (start,)
            if end is not None:
                end = "1.0+%sc" % (end,)
            w.tag_add("highlight", start, end)
            w.tag_configure("highlight", background="yellow")

        _, (grammarStart, grammarEnd), inputPos = self.trace[self.position]
        updateHighlight(self.grammarWin, grammarStart, grammarEnd)
        updateHighlight(self.inputWin, inputPos)


def display(grammar, src, trace):
    r = tk.Tk()
    f = tk.Frame(master=r)
    lt = ScrolledText(master=f)
    rt = ScrolledText(master=f)
    lt.pack(side="left", expand=True, fill="both")
    rt.pack(side="right", expand=True, fill="both")

    bot = ScrolledText(master=r, height=5)
    tracer = Tracer(lt, rt, bot, trace)
    toolbar = tk.Frame(master=r)
    tk.Button(toolbar, text="Next", width=5, command=tracer.advance).pack(
        side="left")
    tk.Button(toolbar, text="Prev", width=5, command=tracer.rewind).pack(
        side="left")
    f.pack(expand=1, fill="both")
    toolbar.pack(fill=tk.X)
    bot.pack(fill=tk.X)

    lt.insert(tk.END, grammar)
    rt.insert(tk.END, src)
    tracer.display()
    return r

_, trace = traceparse(jsonData)
root = display(jsonGrammar, jsonData, trace)

root.mainloop()

########NEW FILE########
__FILENAME__ = builder
# -*- test-case-name: ometa.test.test_builder -*-
import ast
try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO
from types import ModuleType as module
import linecache, sys
from terml.nodes import Term, Tag, coerceToTerm

class TextWriter(object):

    stepSize = 4

    def __init__(self, f, indentSteps=0):
        self.file = f
        self.indentSteps = indentSteps


    def writeln(self, data):
        if data:
            self.file.write(" " * (self.indentSteps * self.stepSize))
            self.file.write(data)
        self.file.write("\n")

    def indent(self):
        return TextWriter(self.file, self.indentSteps + 1)


class PythonWriter(object):
    """
    Converts an OMeta syntax tree into Python source.
    """
    def __init__(self, tree, grammarText):
        self.tree = tree
        self.grammarText = grammarText
        self.gensymCounter = 0
        self.compiledExprCache = None


    def _generate(self, out, expr, retrn=False, debugname=None):
        result = self._generateNode(out, expr, debugname=debugname)
        if retrn:
            out.writeln("return (%s, self.currentError)" % (result,))
        elif result:
            out.writeln(result)

    def output(self, out):
        self._generate(out, self.tree)


    def _generateNode(self, out, node, debugname=None):
        name = node.tag.name
        args = node.args
        if name == 'null':
            return 'None'
        if node.span:
            out.writeln("self._trace(%r, %r, self.input.position)"
                        % (self.grammarText[slice(*node.span)], node.span))
        return getattr(self, "generate_"+name)(out, *args, debugname=debugname)


    def _gensym(self, name):
        """
        Produce a unique name for a variable in generated code.
        """
        self.gensymCounter += 1
        return "_G_%s_%s" % (name, self.gensymCounter)


    def _newThunkFor(self, out, name, expr):
        """
        Define a new function of no arguments.
        @param name: The name of the rule generating this thunk.
        @param expr: A list of lines of Python code.
        """

        fname = self._gensym(name)
        self._writeFunction(out, fname, (),  expr)
        return fname


    def _expr(self, out, typ, e, debugname=None):
        """
        Generate the code needed to execute the expression, and return the
        variable name bound to its value.
        """
        name = self._gensym(typ)
        out.writeln("%s, lastError = %s" % (name, e))
        out.writeln("self.considerError(lastError, %r)" % (debugname and debugname.data,))
        return name


    def _writeFunction(self, out, fname, arglist, expr):
        """
        Generate a function.
        @param out: the TextWriter used for output.
        @param fname: The name of the function generated.
        @param arglist: A list of parameter names.
        @param expr: The term tree to generate the function body from.
        """

        out.writeln("def %s(%s):" % (fname, ", ".join(arglist)))
        self._generate(out.indent(), expr, retrn=True)
        return fname


    def compilePythonExpr(self, out, expr, debugname=None):
        """
        Generate code for running embedded Python expressions.
        """
        try:
            ast.literal_eval(expr)
            return self._expr(out, 'python', '(' + expr + '), None', debugname)
        except ValueError:
            if self.compiledExprCache is None:
                return self._expr(out, 'python',
                                'eval(%r, self.globals, _locals), None' % (expr,),
                                debugname)
            else:
                if expr in self.compiledExprCache:
                    sym = self.compiledExprCache[expr]
                else:
                    sym = self.compiledExprCache[expr] = self._gensym('expr')

                return self._expr(out, 'python',
                                'eval(self.%s, self.globals, _locals), None' % (sym,),
                                debugname)

    def _convertArgs(self, out, rawArgs, debugname):
        return [self._generateNode(out, x, debugname) for x in rawArgs]


    def generate_Apply(self, out, ruleName, codeName, rawArgs, debugname=None):
        """
        Create a call to self.apply(ruleName, *args).
        """
        ruleName = ruleName.data
        args = self._convertArgs(out, rawArgs.args, debugname)
        if ruleName == 'super':
            return self._expr(out, 'apply', 'self.superApply("%s", %s)'
                              % (codeName.data, ', '.join(args)),
                              debugname)
        return self._expr(out, 'apply', 'self._apply(self.rule_%s, "%s", [%s])'
                          % (ruleName, ruleName, ', '.join(args)),
                          debugname)

    def generate_ForeignApply(self, out, grammarName, ruleName, codeName,
            rawArgs, debugname=None):
        """
        Create a call to self.foreignApply(ruleName, *args)
        """
        grammarName = grammarName.data
        ruleName = ruleName.data
        args = self._convertArgs(out, rawArgs.args, debugname)
        call = ('self.foreignApply("%s", "%s", self.globals, _locals, %s)'
                            % (grammarName, ruleName, ', '.join(args)))
        return self._expr(out, 'apply', call, debugname)

    def generate_Exactly(self, out, literal, debugname=None):
        """
        Create a call to self.exactly(expr).
        """
        return self._expr(out, 'exactly', 'self.exactly(%r)' % (literal.data,), debugname)


    def generate_Token(self, out, literal, debugname=None):
        if self.takesTreeInput:
            return self.generate_Exactly(out, literal, debugname)
        else:
            return self._expr(out, 'apply',
                              'self._apply(self.rule_token, "token", ["%s"])'
                              % (literal.data,),
                              debugname)


    def generate_Many(self, out, expr, debugname=None):
        """
        Create a call to self.many(lambda: expr).
        """
        fname = self._newThunkFor(out, "many", expr)
        return self._expr(out, 'many', 'self.many(%s)' % (fname,), debugname)


    def generate_Many1(self, out, expr, debugname=None):
        """
        Create a call to self.many(lambda: expr).
        """
        fname = self._newThunkFor(out, "many1", expr)
        return self._expr(out, 'many1', 'self.many(%s, %s())' % (fname, fname), debugname)


    def generate_Repeat(self, out, min, max, expr, debugname=None):
        """
        Create a call to self.repeat(min, max, lambda: expr).
        """
        fname = self._newThunkFor(out, "repeat", expr)
        if min.tag.name == '.int.':
            min = min.data
        else:
            min = '_locals["%s"]' % min.data
        if max.tag.name == '.int.':
            max = max.data
        else:
            max = '_locals["%s"]' % max.data
        if min == max == 0:
            return "''"
        return self._expr(out, 'repeat', 'self.repeat(%s, %s, %s)'
                          % (min, max, fname))

    def generate_Optional(self, out, expr, debugname=None):
        """
        Try to parse an expr and continue if it fails.
        """
        realf = self._newThunkFor(out, "optional", expr)
        passf = self._gensym("optional")
        out.writeln("def %s():" % (passf,))
        out.indent().writeln("return (None, self.input.nullError())")
        return self._expr(out, 'or', 'self._or([%s])'
                          % (', '.join([realf, passf])),
                          debugname)


    def generate_Or(self, out, exprs, debugname=None):
        """
        Create a call to
        self._or([lambda: expr1, lambda: expr2, ... , lambda: exprN]).
        """
        if len(exprs.args) > 1:
            fnames = [self._newThunkFor(out, "or", expr) for expr in exprs.args]
            return self._expr(out, 'or', 'self._or([%s])' % (', '.join(fnames)), debugname)
        else:
            return self._generateNode(out, exprs.args[0], debugname)


    def generate_Not(self, out, expr, debugname=None):
        """
        Create a call to self._not(lambda: expr).
        """
        fname = self._newThunkFor(out, "not", expr)
        return self._expr(out, "not", "self._not(%s)" % (fname,), debugname)


    def generate_Lookahead(self, out, expr, debugname=None):
        """
        Create a call to self.lookahead(lambda: expr).
        """
        fname = self._newThunkFor(out, "lookahead", expr)
        return self._expr(out, "lookahead", "self.lookahead(%s)" %(fname,), debugname)


    def generate_And(self, out, exprs, debugname=None):
        """
        Generate code for each statement in order.
        """
        v = None
        for ex in exprs.args:
            v = self._generateNode(out, ex, debugname)
        return v


    def generate_Bind(self, out, name, expr, debugname=None):
        """
        Bind the value of 'expr' to a name in the _locals dict.
        """
        v = self._generateNode(out, expr, debugname)
        if name.data:
            ref = "_locals['%s']" % (name.data,)
            out.writeln("%s = %s" % (ref, v))
        else:
            for i, n in enumerate(name.args):
                ref = "_locals['%s']" % (n.data,)
                out.writeln("%s = %s[%i]" %(ref, v, i))
        return v


    def generate_Predicate(self, out, expr, debugname=None):
        """
        Generate a call to self.pred(lambda: expr).
        """

        fname = self._newThunkFor(out, "pred", expr)
        return self._expr(out, "pred", "self.pred(%s)" %(fname,), debugname)


    def generate_Action(self, out, expr, debugname=None):
        """
        Generate this embedded Python expression on its own line.
        """
        return self.compilePythonExpr(out, expr.data, debugname)


    def generate_Python(self, out, expr, debugname=None):
        """
        Generate this embedded Python expression on its own line.
        """
        return self.compilePythonExpr(out, expr.data, debugname)


    def generate_List(self, out, expr, debugname=None):
        """
        Generate a call to self.listpattern(lambda: expr).
        """
        fname = self._newThunkFor(out, "listpattern", expr)
        return  self._expr(out, "listpattern", "self.listpattern(%s)" %(fname,),
                           debugname)

    def generate_Label(self, out, expr, label, debugname=None):
        """
        Generate code for expr, and create label.
        """
        fname = self._newThunkFor(out, "label", expr)
        return self._expr(out, 'label', 'self.label(%s, "%s")' % (fname, label.data, ), debugname)

    def generate_TermPattern(self, out, name, expr, debugname=None):
        fname = self._newThunkFor(out, "termpattern", expr)
        return self._expr(out, 'termpattern', 'self.termpattern(%r, %s)' % (name.data, fname),
                          debugname)

    def generate_StringTemplate(self, out, template, debugname=None):
        out.writeln("from terml.parser import parseTerm as term")
        return self._expr(out, 'stringtemplate', 'self.stringtemplate(%s, _locals)' % (template,))

    def generate_ConsumedBy(self, out, expr, debugname=None):
        """
        Generate a call to self.consumedBy(lambda: expr).
        """
        fname = self._newThunkFor(out, "consumedby", expr)
        return  self._expr(out, "consumedby", "self.consumedby(%s)" %(fname,),
                           debugname)


    def generate_Rule(self, prevOut, name, expr, debugname=None):
        prevOut.writeln("def rule_%s(self):" % (name.data,))
        out = prevOut.indent()
        out.writeln("_locals = {'self': self}")
        out.writeln("self.locals[%r] = _locals" % (name.data,))
        self._generate(prevOut.indent(), expr, retrn=True, debugname=name)

    def generate_Grammar(self, out, name, takesTreeInput, rules,
                         debugname=None):
        self.compiledExprCache = {}
        self.takesTreeInput = takesTreeInput.tag.name == 'true'
        out.writeln("def createParserClass(GrammarBase, ruleGlobals):")
        funcOut = out.indent()
        funcOut.writeln("if ruleGlobals is None:")
        funcOut.indent().writeln("ruleGlobals = {}")
        funcOut.writeln("class %s(GrammarBase):" % (name.data,))
        out = funcOut.indent()
        for rule in rules.args:
            self._generateNode(out, rule, debugname)
            out.writeln("")
            out.writeln("")
        if self.takesTreeInput:
            out.writeln("tree = %s" % self.takesTreeInput)
        for expr, sym in self.compiledExprCache.items():
            out.writeln("%s = compile(%r, '<string>', 'eval')" % (sym, expr))
        funcOut.writeln(
            "if %s.globals is not None:" % (name.data,))
        out.writeln("%s.globals = %s.globals.copy()" % (name.data,
                                                        name.data))
        out.writeln("%s.globals.update(ruleGlobals)" % (name.data,))
        funcOut.writeln(
            "else:")
        out.writeln("%s.globals = ruleGlobals" % (name.data,))
        funcOut.writeln("return " + name.data)
        self.compiledExprCache = None


class _Term2PythonAction(object):
    def leafData(bldr, data, span):
        return repr(data)

    def leafTag(bldr, tag, span):
        return tag.name

    def term(bldr, tag, args):
        if tag == '.tuple.':
            return "[%s]" % (', '.join(args),)
        elif tag == '.attr.':
            return "(%s)" % (', '.join(args),)
        elif tag == '.bag.':
            return "dict(%s)" % (', '.join(args),)
        if not args:
            return tag
        return "%s(%s)" % (tag, ', '.join(args))


class TermActionPythonWriter(PythonWriter):
    builder = _Term2PythonAction

    def _convertArgs(self, out, termArgs, debugname):
        return [self._termAsPython(out, a, debugname) for a in termArgs]


    def generate_Predicate(self, out, term, debugname=None):
        """
        Generate a call to self.pred(lambda: expr).
        """

        fname = self._newThunkFor(out, "pred", Term(Tag("Action"), None,
                                                    [term], None))
        return self._expr(out, "pred", "self.pred(%s)" %(fname,), debugname)

    def generate_Action(self, out, term, debugname=None):
        return self._termAsPython(out, term, debugname)

    generate_Python = generate_Action

    def _termAsPython(self, out, term, debugname):
        if not term.args:
            if term.data is None:
                return self.compilePythonExpr(out, term.tag.name, debugname)
            else:
                name = self._gensym("literal")
                out.writeln("%s = %r" % (name, term.data))
                return name
        else:
            return self.compilePythonExpr(out, term.build(self.builder()), debugname)


def writePython(tree, txt):
    f = StringIO()
    out = TextWriter(f)
    pw = PythonWriter(tree, txt)
    pw.output(out)
    return f.getvalue().strip()


class GeneratedCodeLoader(object):
    """
    Object for use as a module's __loader__, to display generated
    source.
    """
    def __init__(self, source):
        self.source = source
    def get_source(self, name):
        return self.source



def moduleFromGrammar(source, className, modname, filename):
    mod = module(str(modname))
    mod.__name__ = modname
    mod.__loader__ = GeneratedCodeLoader(source)
    code = compile(source, filename, "exec")
    eval(code, mod.__dict__)
    sys.modules[modname] = mod
    linecache.getlines(filename, mod.__dict__)
    return mod


########NEW FILE########
__FILENAME__ = compat
import ometa
from ometa.runtime import OMetaGrammarBase
from ometa.grammar import OMeta
from ometa.grammar import loadGrammar
from terml.nodes import termMaker as t

OMeta1 = loadGrammar(ometa, "pymeta_v1",
                     globals(), OMetaGrammarBase)

########NEW FILE########
__FILENAME__ = grammar
# -*- test-case-name: ometa.test.test_pymeta -*-
"""
Public interface to OMeta, as well as the grammars used to compile grammar
definitions.
"""
import os.path
import string
try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

from terml.nodes import termMaker as t
import ometa
from ometa._generated.parsley import createParserClass as makeBootGrammar
from ometa.builder import TermActionPythonWriter, moduleFromGrammar, TextWriter
from ometa.runtime import OMetaBase, OMetaGrammarBase

OMeta = makeBootGrammar(OMetaGrammarBase, globals())


def loadGrammar(pkg, name, globals, superclass=OMetaBase):
    try:
        m = __import__('.'.join([pkg.__name__, '_generated', name]),
                       fromlist=[name], level=0)
    except ImportError:
        base = os.path.dirname(os.path.abspath(pkg.__file__))
        src = open(os.path.join(base, name + ".parsley")).read()
        m = OMeta.makeGrammar(src, name)

    return m.createParserClass(superclass, globals)

class TermOMeta(loadGrammar(
        ometa, "parsley_termactions",
        globals(), superclass=OMeta)):

    _writer = TermActionPythonWriter

    @classmethod
    def makeGrammar(cls, grammar, name):
        """
        Define a new parser class with the rules in the given grammar.

        @param grammar: A string containing a PyMeta grammar.
        @param globals: A dict of names that should be accessible by this
        grammar.
        @param name: The name of the class to be generated.
        @param superclass: The class the generated class is a child of.
        """
        g = cls(grammar)
        tree = g.parseGrammar(name)
        modname = "pymeta_grammar__" + name
        filename = "/pymeta_generated_code/" + modname + ".py"
        source = g.writeTerm(tree, grammar)
        return moduleFromGrammar(source, name, modname, filename)

    def writeTerm(self, term, grammar):
        f = StringIO()
        pw = self._writer(term, grammar)
        out = TextWriter(f)
        pw.output(out)
        return f.getvalue().strip()

    def rule_term(self):
        from terml.parser import TermLParser
        tp = TermLParser('')
        tp.input = self.input
        self.input.setMemo('term', None)
        val, err = tp.apply('term')
        self.input = tp.input
        return val, err

    def rule_term_arglist(self):
        from terml.parser import TermLParser
        tp = TermLParser('')
        tp.input = self.input
        val, err = tp.apply('argList')
        self.input = tp.input
        return val, err

TreeTransformerGrammar = loadGrammar(
    ometa, "parsley_tree_transformer",
    globals(), superclass=OMeta)

########NEW FILE########
__FILENAME__ = interp
import string
from ometa.runtime import (InputStream, ParseError, EOFError, ArgInput,
                           joinErrors, expected, LeftRecursion)

def decomposeGrammar(grammar):
    rules = {}
    #XXX remove all these asserts once we have quasiterms
    assert grammar.tag.name == 'Grammar'
    for rule in grammar.args[2].args:
        assert rule.tag.name == 'Rule'
        rules[rule.args[0].data] = rule.args[1]
    return rules

# after 12, i'm worse than a gremlin
_feed_me = object()


class TrampolinedGrammarInterpreter(object):
    """
    An interpreter for OMeta grammars that processes input
    incrementally.
    """
    def __init__(self, grammar, rule, callback=None, globals=None):
        self.grammar = grammar
        self.position = 0
        self.callback = callback
        self.globals = globals or {}
        self.rules = decomposeGrammar(grammar)
        self.next = self.setNext(rule)
        self._localsStack = []
        self.currentResult = None
        self.input = InputStream([], 0)
        self.ended = False
        self._spanStart = 0


    def receive(self, buf):
        """
        Feed data to the parser.
        """
        if not buf:
            # No data. Nothing to do.
            return
        if self.ended:
            raise ValueError("Can't feed a parser that's been ended.")
        self.input.data.extend(buf)
        x = None
        for x in self.next:
            if x is _feed_me:
                return x
        if self.callback:
            self.callback(*x)
        self.ended = True


    def end(self):
        """
        Close the input stream, indicating to the grammar that no more
        input will arrive.
        """
        if self.ended:
            return
        self.ended = True
        x = None
        for x in self.next:
            pass
        if self.callback:
            self.callback(*x)


    def setNext(self, rule):
        if not isinstance(rule, tuple):
            rule = (rule, )
        return self.apply(rule[0], None, rule[1:])


    ## Implementation note: each method, instead of being a function
    ## returning a value, is a generator that will yield '_feed_me' an
    ## arbitrary number of times, then finally yield the value of the
    ## expression being evaluated.


    def _apply(self, rule, ruleName, args):
        """
        Apply a rule method to some args.
        @param rule: A method of this object.
        @param ruleName: The name of the rule invoked.
        @param args: A sequence of arguments to it.
        """
        if args:
            if ((not getattr(rule, 'func_code', None))
                 or rule.func_code.co_argcount - 1 != len(args)):
                for arg in args[::-1]:
                    self.input = ArgInput(arg, self.input)
                g = rule()
            else:
                g = rule(*args)
            for x in g:
                if x is _feed_me: yield x
            yield x
            return
        memoRec = self.input.getMemo(ruleName)
        if memoRec is None:
            oldPosition = self.input
            lr = LeftRecursion()
            memoRec = self.input.setMemo(ruleName, lr)

            try:
                inp = self.input
                for x in rule():
                    if x is _feed_me: yield x
                memoRec = inp.setMemo(ruleName, [x, self.input])
            except ParseError:
                raise
            if lr.detected:
                sentinel = self.input
                while True:
                    try:
                        self.input = oldPosition
                        for x in rule():
                            if x is _feed_me: yield x
                        ans = x
                        if (self.input == sentinel):
                            break

                        memoRec = oldPosition.setMemo(ruleName,
                                                     [ans, self.input])
                    except ParseError:
                        break
            self.input = oldPosition

        elif isinstance(memoRec, LeftRecursion):
            memoRec.detected = True
            raise self.input.nullError()
        self.input = memoRec[1]
        yield memoRec[0]


    def _eval(self, expr):
        """
        Dispatch to a parse_<term name> method for the given grammar expression.
        """
        return getattr(self, "parse_" + expr.tag.name)(*expr.args)


    def parse_Apply(self, ruleName, codeName, args):
        for x in self.apply(ruleName.data, codeName.data, args.args):
            if x is _feed_me: yield x
        yield x


    def apply(self, ruleName, codeName, args):
        """
        Invoke a rule, optionally with arguments.
        """
        argvals = []
        # we tell whether a rule is a manually set one by the codeName
        # if it's None, then we think it's set by setNext
        if codeName is None:
            argvals = args
        else:
            for a in args:
                for x in self._eval(a):
                    if x is _feed_me: yield x
                argvals.append(x[0])
        _locals = {}
        self._localsStack.append(_locals)
        try:
            #XXX super
            rul = self.rules.get(ruleName)
            if rul:
                def f():
                    return self._eval(rul)
            else:
                #ruleName may be a Twine, so gotta call str()
                f = getattr(self, str('rule_' + ruleName))
            for x in self._apply(f, ruleName, argvals):
                if x is _feed_me: yield x
            yield x
        finally:
            self._localsStack.pop()


    def parse_Exactly(self, spec):
        """
        Accept a one or more characters that equal the given spec.
        """
        wanted = spec.data
        result = []
        for c in wanted:
            try:
                val, p = self.input.head()
            except EOFError:
                yield _feed_me
                val, p = self.input.head()
            result.append(val)
            if val == c:
                self.input = self.input.tail()
            else:
                raise self.err(p.withMessage(expected(None, wanted)))
        yield ''.join(result), p


    def parse_Token(self, spec):
        """
        Consume leading whitespace then the given string.
        """
        val = ' '
        while val.isspace():
            try:
                val, p = self.input.head()
            except EOFError:
                yield _feed_me
                val, p = self.input.head()
            if val.isspace():
                self.input = self.input.tail()
        wanted = spec.data
        result = []
        for c in wanted:
            try:
                val, p = self.input.head()
            except EOFError:
                yield _feed_me
                val, p = self.input.head()
            result.append(val)
            if val == c:
                self.input = self.input.tail()
            else:
                raise self.err(p.withMessage(expected("token", wanted)))
        yield ''.join(result), p


    def parse_And(self, expr):
        """
        Execute multiple subexpressions in order, returning the result
        of the last one.
        """
        seq = expr.args
        x = None, self.input.nullError()
        for subexpr in seq:
            for x in self._eval(subexpr):
                if x is _feed_me: yield x
            self.currentError = x[1]
        yield x


    def parse_Or(self, expr):
        """
        Execute multiple subexpressions, returning the result of the
        first one that succeeds.
        """
        errors = []
        i = self.input
        for subexpr in expr.args:
            try:
                for x in self._eval(subexpr):
                    if x is _feed_me: yield x
                val, p = x
                errors.append(p)
                self.currentError = joinErrors(errors)
                yield x
                return
            except ParseError as err:
                errors.append(err)
                self.input = i
        raise self.err(joinErrors(errors))


    def parse_Many(self, expr, ans=None):
        """
        Execute an expression repeatedly until it fails to match,
        collecting the results into a list. Implementation of '*'.
        """
        ans = ans or []
        err = None
        while True:
            try:
                m = self.input
                for x in self._eval(expr):
                    if x is _feed_me: yield x
                ans.append(x[0])
                self.currentError = x[1]
            except ParseError as error:
                err = error
                self.input = m
                break
        yield ans, err


    def parse_Many1(self, expr):
        """
        Execute an expression one or more times, collecting the
        results into a list. Implementation of '+'.
        """
        for x in self._eval(expr):
            if x is _feed_me: yield x
        for x in self.parse_Many(expr, ans=[x[0]]):
            if x is _feed_me: yield x
        yield x


    def parse_Repeat(self, min, max, expr):
        """
        Execute an expression between C{min} and C{max} times,
        collecting the results into a list. Implementation of '{}'.
        """
        if min.tag.name == '.int.':
            min = min.data
        else:
            min = self._localsStack[-1][min.data]
        if max.tag.name == '.int.':
            max = max.data
        elif max.tag.name == 'null':
            max = None
        else:
            max = self._localsStack[-1][max.data]

        e = None

        if min == max == 0:
            yield '', None
            return
        ans = []
        for i in range(min):
            for x in self._eval(expr):
                if x is _feed_me: yield x
            v, e = x
            ans.append(v)

        if max is not None:
            repeats = range(min, max)
            for i in repeats:
                try:
                    m = self.input
                    for x in self._eval(expr):
                        if x is _feed_me: yield x
                    v, e = x
                    ans.append(v)
                except ParseError as err:
                    e = err
                    self.input = m
                    break
        yield ans, e



    def parse_Optional(self, expr):
        """
        Execute an expression, returning None if it
        fails. Implementation of '?'.
        """
        i = self.input
        try:
            for x in self._eval(expr):
                if x is _feed_me: yield x
            yield x
        except ParseError:
            self.input = i
            yield (None, self.input.nullError())


    def parse_Not(self, expr):
        """
        Execute an expression, returning True if it fails and failing
        otherwise. Implementation of '~'.
        """
        m = self.input
        try:
            for x in self._eval(expr):
                if x is _feed_me: yield x
        except ParseError:
            self.input = m
            yield True, self.input.nullError()
        else:
            raise self.err(self.input.nullError())


    def parse_Label(self, expr, label_term):
        """
        Execute an expression , if it fails apply the label to the exception.
        """
        label = label_term.data
        try:
            for x in self._eval(expr):
                if x is _feed_me:
                    yield x
            print ("^^", label)
            self.currentError = x[1].withMessage([("Custom Exception:", label, None)])
            yield x[0], self.currentError
        except ParseError as e:
            err=e
            raise self.err(e.withMessage([("Custom Exception:", label, None)]))


    def parse_Lookahead(self, expr):
        """
        Execute an expression, then reset the input stream to the
        position before execution. Implementation of '~~'.
        """
        try:
            i = self.input
            for x in self._eval(expr):
                if x is _feed_me: yield x
        finally:
            self.input = i


    def parse_Bind(self, name, expr):
        """
        Execute an expression and bind its result to the given name.
        """
        for x in self._eval(expr):
            if x is _feed_me: yield x
        v, err = x
        if name.data:
            self._localsStack[-1][name.data] = v
        else:
            for n, val in zip(name.args, v):
                self._localsStack[-1][n.data] = val
        yield v, err


    def parse_Predicate(self, expr):
        """
        Run a Python expression and fail if it returns False.
        """
        for x in self._eval(expr):
            if x is _feed_me: yield x
        val, err = x
        if not val:
            raise self.err(err)
        else:
            yield True, err


    def parse_Action(self, expr):
        """
        Run a Python expression, return its result.
        """
        val = eval(expr.data, self.globals, self._localsStack[-1])
        yield val, self.input.nullError()


    def parse_ConsumedBy(self, expr):
        """
        Run an expression. Return the literal contents of the input
        stream it consumed.
        """
        oldInput = self.input
        for x in self._eval(expr):
            if x is _feed_me: yield x
        slice = oldInput.data[oldInput.position:self.input.position]
        yield "".join(slice), x[1]

    def rule_anything(self):
        """
        Match a single character.
        """
        try:
            val, p = self.input.head()
        except EOFError:
            yield _feed_me
            val, p = self.input.head()
        self.input = self.input.tail()
        yield val, p

    def rule_letter(self):
        """
        Match a single letter.
        """
        try:
            val, p = self.input.head()
        except EOFError:
            yield _feed_me
            val, p = self.input.head()
        if val in string.ascii_letters:
            self.input = self.input.tail()
            yield val, p
        else:
            raise self.err(p.withMessage(expected("letter")))

    def rule_digit(self):
        """
        Match a digit.
        """
        try:
            val, p = self.input.head()
        except EOFError:
            yield _feed_me
            val, p = self.input.head()
        if val in string.digits:
            self.input = self.input.tail()
            yield val, p
        else:
            raise self.err(p.withMessage(expected("digit")))

    def err(self, e):
        e.input = ''.join(str(i) for i in e.input)
        raise e

class GrammarInterpreter(object):

    def __init__(self, grammar, base, globals=None):
        """
        grammar: A term tree representing a grammar.
        """
        self.grammar = grammar
        self.base = base
        self.rules = {}
        self._localsStack = []
        self._globals = globals or {}
        self.rules = decomposeGrammar(grammar)
        self.run = None
        self._spanStart = 0

    def apply(self, input, rulename, tree=False):
        self.run = self.base(input, self._globals, tree=tree)
        #XXX hax, fix grammar parser to distinguish tree from nontree grammars
        if not isinstance(self.run.input.data, str):
            tree = True
            self.run.tree = True
        v, err = self._apply(self.run, rulename, ())
        return self.run.input, v, err


    def _apply(self, run, ruleName, args):
        argvals = [self._eval(run, a)[0] for a in args]
        _locals = {'self': run}
        self._localsStack.append(_locals)
        try:
            if ruleName == 'super':
                return run.superApply(ruleName, argvals)
            else:
                rul = self.rules.get(ruleName)
                if rul:
                    return run._apply(
                        (lambda: self._eval(run, rul)),
                        ruleName, argvals)
                else:
                    #ruleName may be a Twine, so calling str()
                    x = run._apply(getattr(run, str('rule_' + ruleName)),
                                   ruleName, argvals)
                    return x
        finally:
            self._localsStack.pop()


    def _eval(self, run, expr):
        name = expr.tag.name
        args = expr.args
        if name == "Apply":
            ruleName = args[0].data
            return self._apply(run, ruleName, args[2].args)

        elif name == "Exactly":
            return run.exactly(args[0].data)

        elif name == "Label":
            label = args[1].data
            try:
                val, err = self._eval(run, args[0])
                return val, err.withMessage([("Custom Exception:", label, None)])
            except ParseError as err:
                e=err
                raise e.withMessage([("Custom Exception:", label, None)])

        elif name == "Token":
            if run.tree:
                return run._apply(run.rule_exactly, "exactly", [args[0].data])
            else:
                return run._apply(run.rule_token, "token", [args[0].data])

        elif name in ("Many", "Many1"):
            ans = [self._eval(run, args[0])[0]] if name == "Many1" else []
            err = None
            while True:
                try:
                    m = run.input
                    v, _ = self._eval(run, args[0])
                    ans.append(v)
                except ParseError as e:
                    err = e
                    run.input = m
                    break
            return ans, err

        elif name == "Repeat":
            if args[0].tag.name == '.int.':
                min = args[0].data
            else:
                min = self._localsStack[-1][args[0].data]
            if args[1].tag.name == '.int.':
                max = args[1].data
            elif args[1].tag.name == 'null':
                max = None
            else:
                max = self._localsStack[-1][args[1].data]
            if min == max == 0:
                return "", None
            ans = []
            e = None
            for i in range(min):
                v, e = self._eval(run, args[2])
                ans.append(v)

            for i in range(min, max):
                try:
                    m = run.input
                    v, e = self._eval(run, args[2])
                    ans.append(v)
                except ParseError as err:
                    e = err
                    run.input = m
                    break
            return ans, e

        elif name == "Optional":
            i = run.input
            try:
                return self._eval(run, args[0])
            except ParseError:
                run.input = i
                return (None, run.input.nullError())

        elif name == "Or":
            errors = []
            for e in args[0].args:
                try:
                    m = run.input
                    x = self._eval(run, e)
                    ret, err = x
                    errors.append(err)
                    return ret, joinErrors(errors)
                except ParseError as err:
                    errors.append(err)
                    run.input = m
            raise joinErrors(errors)


        elif name == "Not":
            m = run.input
            try:
                self._eval(run, args[0])
            except ParseError as err:
                run.input = m
                return True, run.input.nullError()
            else:
                raise run.input.nullError()


        elif name == "Lookahead":
            try:
                m = run.input
                return self._eval(run, args[0])
            finally:
                run.input = m

        elif name == "And":
            v = None, run.input.nullError()
            for e in args[0].args:
                v = self._eval(run, e)
            return v

        elif name == "Bind":
            v, err =  self._eval(run, args[1])
            if args[0].data:
                self._localsStack[-1][args[0].data] = v
            else:
                for n, val in zip(args[0].args, v):
                    self._localsStack[-1][n.data] = val
            return v, err

        elif name == "Predicate":
            val, err = self._eval(run, args[0])
            if not val:
                raise err
            else:
                return True, err

        elif name == "List":
            v, e = run.rule_anything()
            oldInput = run.input
            try:
                run.input = InputStream.fromIterable(v)
            except TypeError:
                raise e.withMessage(expected("an iterable"))
            self._eval(run, args[0])
            run.end()
            run.input = oldInput
            return v, e

        elif name in ("Action", "Python"):
            lo = self._localsStack[-1]
            val = eval(args[0].data, self._globals, lo)
            return (val, run.input.nullError())

        elif name == "ConsumedBy":
            oldInput = run.input
            _, err = self._eval(run, args[0])
            slice = oldInput.data[oldInput.position:run.input.position]
            return slice, err

        else:
            raise ValueError("Unrecognized term: %r" % (name,))

########NEW FILE########
__FILENAME__ = protocol
from twisted.internet.protocol import Protocol
from twisted.python.failure import Failure

from ometa.tube import TrampolinedParser


class ParserProtocol(Protocol):
    """
    A Twisted ``Protocol`` subclass for parsing stream protocols.
    """


    def __init__(self, grammar, senderFactory, receiverFactory, bindings):
        """
        Initialize the parser.

        :param grammar: An OMeta grammar to use for parsing.
        :param senderFactory: A unary callable that returns a sender given a
                              transport.
        :param receiverFactory: A unary callable that returns a receiver given
                                a sender.
        :param bindings: A dict of additional globals for the grammar rules.
        """

        self._grammar = grammar
        self._bindings = dict(bindings)
        self._senderFactory = senderFactory
        self._receiverFactory = receiverFactory
        self._disconnecting = False

    def connectionMade(self):
        """
        Start parsing, since the connection has been established.
        """

        self.sender = self._senderFactory(self.transport)
        self.receiver = self._receiverFactory(self.sender)
        self.receiver.prepareParsing(self)
        self._parser = TrampolinedParser(
            self._grammar, self.receiver, self._bindings)

    def dataReceived(self, data):
        """
        Receive and parse some data.

        :param data: A ``str`` from Twisted.
        """

        if self._disconnecting:
            return

        try:
            self._parser.receive(data)
        except Exception:
            self.connectionLost(Failure())
            self.transport.abortConnection()
            return

    def connectionLost(self, reason):
        """
        Stop parsing, since the connection has been lost.

        :param reason: A ``Failure`` instance from Twisted.
        """

        if self._disconnecting:
            return
        self.receiver.finishParsing(reason)
        self._disconnecting = True

########NEW FILE########
__FILENAME__ = runtime
# -*- test-case-name: ometa.test.test_runtime -*-
"""
Code needed to run a grammar after it has been compiled.
"""
import time
from textwrap import dedent
from terml.nodes import coerceToTerm, Term, termMaker as t
from ometa.builder import moduleFromGrammar, writePython

try:
    basestring
except NameError:
    basestring = str
    unicode = str

TIMING = False

class ParseError(Exception):
    """
    ?Redo from start
    """

    def __init__(self, input, position, message, trail=None):
        Exception.__init__(self, position, message)
        self.position = position
        self.error = message or []
        self.input = input
        self.trail = trail or []


    def __eq__(self, other):
        if other.__class__ == self.__class__:
            return (self.position, self.error) == (other.position, other.error)


    def mergeWith(self, other):
        """
        Merges in another error's error and trail.
        """
        self.error = list(set(self.error + other.error))
        self.args = (self.position, self.error)
        self.trail = other.trail or self.trail or []


    def formatReason(self):
        if not self.error:
            return "Syntax error"
        if len(self.error) == 1:
            if self.error[0][0] == 'message':
                return self.error[0][1]
            if self.error[0][2] == None:
                return 'expected a %s' % (self.error[0][1])
            else:
                typ = self.error[0][1]
                if typ is None:
                    if isinstance(self.input, basestring):
                        typ = 'character'
                    else:
                        typ = 'object'
                return 'expected the %s %r' % (typ, self.error[0][2])
        else:
            bits = []
            for s in self.error:
                if s[0] == 'message':
                    desc = s[1]
                elif s[2] is None:
                    desc = "a " + s[1]
                else:
                    desc = repr(s[2])
                    if s[1] is not None:
                        desc = "%s %s" % (s[1], desc)
                bits.append(desc)
            bits.sort()
            return "expected one of %s, or %s" % (', '.join(bits[:-1]),
                                                  bits[-1])


    def formatError(self):
        """
        Return a pretty string containing error info about string
        parsing failure.
        """
        #de-twineifying
        lines = str(self.input).split('\n')
        counter = 0
        lineNo = 1
        columnNo = 0
        for line in lines:
            newCounter = counter + len(line)
            if newCounter > self.position:
                columnNo = self.position - counter
                break
            else:
                counter += len(line) + 1
                lineNo += 1
        reason = self.formatReason()
        return ('\n' + line + '\n' + (' ' * columnNo + '^') +
                "\nParse error at line %s, column %s: %s. trail: [%s]\n"
                % (lineNo, columnNo, reason, ' '.join(self.trail)))


    def __str__(self):
        return self.formatError()


    def withMessage(self, msg):
        return ParseError(self.input, self.position, msg, self.trail)


class EOFError(ParseError):
    """
    Raised when the end of input is encountered.
    """
    def __init__(self, input, position):
        ParseError.__init__(self, input, position, eof())


def expected(typ, val=None):
    """
    Return an indication of expected input and the position where it was
    expected and not encountered.
    """

    return [("expected", typ, val)]


def eof():
    """
    Return an indication that the end of the input was reached.
    """
    return [("message", "end of input")]


def joinErrors(errors):
    """
    Return the error from the branch that matched the most of the input.
    """
    if len(errors) == 1:
        return errors[0]

    highestPos = -1
    results = set()
    trail = None

    for err in errors:
        pos = err.position
        if pos < highestPos:
            continue
        elif pos > highestPos:
            highestPos = pos
            trail = err.trail or None
            results = set(err.error)
        else:
            trail = err.trail or trail
            results.update(err.error)

    return ParseError(errors[0].input, highestPos, list(results), trail)


class character(str):
    """
    Type to allow distinguishing characters from strings.
    """

    def __iter__(self):
        """
        Prevent string patterns and list patterns from matching single
        characters.
        """
        raise TypeError("Characters are not iterable")



class unicodeCharacter(unicode):
    """
    Type to distinguish characters from Unicode strings.
    """
    def __iter__(self):
        """
        Prevent string patterns and list patterns from matching single
        characters.
        """
        raise TypeError("Characters are not iterable")



class InputStream(object):
    """
    The basic input mechanism used by OMeta grammars.
    """

    def fromIterable(cls, iterable):
        """
        @param iterable: Any iterable Python object.
        """
        if isinstance(iterable, (character, unicodeCharacter)):
            raise TypeError("Characters are not iterable")
        if isinstance(iterable, bytes):
            return WrappedValueInputStream(iterable, 0, wrapper=character)
        elif isinstance(iterable, unicode):
            return WrappedValueInputStream(iterable, 0,
                                           wrapper=unicodeCharacter)
        else:
            return cls(list(iterable), 0)
    fromIterable = classmethod(fromIterable)


    def fromFile(cls, f, encoding='utf-8'):
        if getattr(f, 'seek', None) and getattr(f, 'tell', None):
            position = f.tell()
        else:
            position = 0
        txt = f.read()
        return cls(txt, position)
    fromFile = classmethod(fromFile)


    def fromText(cls, t, name="<string>"):
        return cls(t, 0)

    fromText = classmethod(fromText)


    def __init__(self, data, position):
        self.data = data
        self.position = position
        self.memo = {}
        self.tl = None
        self.error = ParseError(self.data, self.position, None)

    def head(self):
        if self.position >= len(self.data):
            if getattr(self.data, 'join', None):
                data = self.data.__class__('').join(self.data)
            else:
                data = self.data
            raise EOFError(data, self.position + 1)
        return self.data[self.position], self.error

    def nullError(self, msg=None):
        if msg:
            return self.error.withMessage(msg)
        else:
            return self.error

    def tail(self):
        if self.tl is None:
            self.tl = InputStream(self.data, self.position+1)
        return self.tl

    def advanceBy(self, n):
        return InputStream(self.data, self.position + n)

    def slice(self, n):
        data = self.data[self.position:self.position + n]
        tail = self.advanceBy(n)
        return data, self.nullError(), tail

    def prev(self):
        return InputStream(self.data, self.position-1)

    def getMemo(self, name):
        """
        Returns the memo record for the named rule.
        @param name: A rule name.
        """
        return self.memo.get(name, None)


    def setMemo(self, name, rec):
        """
        Store a memo record for the given value and position for the given
        rule.
        @param name: A rule name.
        @param rec: A memo record.
        """
        self.memo[name] = rec
        return rec

    def __cmp__(self, other):
        return cmp((self.data, self.position), (other.data, other.position))


class WrappedValueInputStream(InputStream):

    def __init__(self, data, position, wrapper=None):
        InputStream.__init__(self, data, position)
        self.wrapper = wrapper

    def head(self):
        v, e = InputStream.head(self)
        return self.wrapper(v), e

    def tail(self):
        if self.tl is None:
            self.tl = WrappedValueInputStream(self.data, self.position+1,
                                              self.wrapper)
        return self.tl

    def advanceBy(self, n):
        return InputStream(self.data, self.position + n, self.wrapper)

    def slice(self, n):
        data = self.data[self.position:self.position + n]
        tail = self.advanceBy(n)
        return [self.wrapper(x) for x in data], self.nullError(), tail

class ArgInput(object):
    def __init__(self, arg, parent):
        self.arg = arg
        self.parent = parent
        self.memo = {}
        self.err = parent.nullError()

    @property
    def position(self):
        return self.parent.position + 1j

    @property
    def data(self):
        return self.parent.data

    def head(self):
        return self.arg, self.err

    def tail(self):
        return self.parent

    def advanceBy(self, n):
        return self.parent.advanceBy(n - 1)

    def slice(self, n):
        prevVal, _, input =  self.parent.slice(n - 1)
        return [self.arg] + list(prevVal), self.err, input

    def nullError(self):
        return self.parent.nullError()


    def getMemo(self, name):
        """
        Returns the memo record for the named rule.
        @param name: A rule name.
        """
        return self.memo.get(name, None)


    def setMemo(self, name, rec):
        """
        Store a memo record for the given value and position for the given
        rule.
        @param name: A rule name.
        @param rec: A memo record.
        """
        self.memo[name] = rec
        return rec


class LeftRecursion(object):
    """
    Marker for left recursion in a grammar rule.
    """
    detected = False


class OMetaBase(object):
    """
    Base class providing implementations of the fundamental OMeta
    operations. Built-in rules are defined here.
    """
    globals = None
    tree = False
    def __init__(self, input, globals=None, name='<string>', tree=False,
            stream=False):
        """
        @param input: The string or input object (if stream=True) to be parsed.

        @param globals: A dictionary of names to objects, for use in evaluating
        embedded Python expressions.

        @param tree: Whether the input should be treated as part of a
        tree of nested iterables, rather than being a standalone
        string.

        @param stream: Whether the input should be treated as an existing
        InputStream object.
        """
        if stream:
            self.input = input
        elif self.tree or tree:
            self.input = InputStream.fromIterable(input)
        else:
            self.input = InputStream.fromText(input)
        self.locals = {}
        if self.globals is None:
            if globals is None:
                self.globals = {}
            else:
                self.globals = globals
        if basestring is str:
            self.globals['basestring'] = str
            self.globals['unichr'] = chr
        self.currentError = self.input.nullError()

    def considerError(self, error, typ=None):
        if error:
            newPos = error.position
            curPos = self.currentError.position
            if newPos > curPos:
                self.currentError = error
            elif newPos == curPos:
                self.currentError.mergeWith(error)


    def _trace(self, src, span, inputPos):
        pass

    def superApply(self, ruleName, *args):
        """
        Apply the named rule as defined on this object's superclass.

        @param ruleName: A rule name.
        """
        r = getattr(super(self.__class__, self), "rule_"+ruleName, None)
        if r is not None:
            self.input.setMemo(ruleName, None)
            return self._apply(r, ruleName, args)
        else:
            raise NameError("No rule named '%s'" %(ruleName,))

    def foreignApply(self, grammarName, ruleName, globals_, locals_, *args):
        """
        Apply the named rule of a foreign grammar.

        @param grammarName: name to look up in locals/globals for grammar
        @param ruleName: rule name
        """
        grammar = locals_.get(grammarName, None)
        if grammar is None:
            grammar = globals_[grammarName]

        grammar = getattr(grammar, "_grammarClass", grammar)
        instance = grammar(self.input, stream=True)
        rule = getattr(instance, "rule_" + ruleName, None)
        if rule is not None:
            self.input.setMemo(ruleName, None)
            result = instance._apply(rule, ruleName, args)
            self.input = instance.input
            return result
        else:
            raise NameError("No rule named '%s' on grammar '%s'" %
                    (ruleName, grammarName))

    def apply(self, ruleName, *args):
        """
        Apply the named rule, optionally with some arguments.

        @param ruleName: A rule name.
        """
        r = getattr(self, "rule_"+ruleName, None)
        if r is not None:
            val, err = self._apply(r, ruleName, args)
            return val, err

        else:
            raise NameError("No rule named '%s'" %(ruleName,))


    def _apply(self, rule, ruleName, args):
        """
        Apply a rule method to some args.
        @param rule: A method of this object.
        @param ruleName: The name of the rule invoked.
        @param args: A sequence of arguments to it.
        """
        if args:
            if basestring is str:
                attrname = '__code__'
            else:
                attrname = 'func_code'
            if ((not getattr(rule, attrname, None))
                 or getattr(rule, attrname).co_argcount - 1 != len(args)):
                for arg in args[::-1]:
                    self.input = ArgInput(arg, self.input)
                return rule()
            else:
                return rule(*args)
        memoRec = self.input.getMemo(ruleName)
        if memoRec is None:
            oldPosition = self.input
            lr = LeftRecursion()
            memoRec = self.input.setMemo(ruleName, lr)
            try:
                memoRec = self.input.setMemo(ruleName,
                                         [rule(), self.input])
            except ParseError as e:
                e.trail.append(ruleName)
                raise
            if lr.detected:
                sentinel = self.input
                while True:
                    try:
                        self.input = oldPosition
                        ans = rule()
                        if (self.input == sentinel):
                            break

                        memoRec = oldPosition.setMemo(ruleName,
                                                     [ans, self.input])
                    except ParseError:
                        break
            self.input = oldPosition

        elif isinstance(memoRec, LeftRecursion):
            memoRec.detected = True
            raise self.input.nullError()
        self.input = memoRec[1]
        return memoRec[0]


    def exactly(self, wanted):
        """
        Match a single item from the input equal to the given
        specimen, or a sequence of characters if the input is string.
        @param wanted: What to match.
        """
        i = self.input
        if not self.tree and len(wanted) > 1:
            val, p, self.input = self.input.slice(len(wanted))
        else:
            val, p = self.input.head()
            self.input = self.input.tail()
        if wanted == val:
            return val, p
        else:
            self.input = i
            raise p.withMessage(expected(None, wanted))


    def many(self, fn, *initial):
        """
        Call C{fn} until it fails to match the input. Collect the resulting
        values into a list.

        @param fn: A callable of no arguments.
        @param initial: Initial values to populate the returned list with.
        """
        ans = []
        for x, e in initial:
            ans.append(x)
        while True:
            try:
                m = self.input
                v, _ = fn()
                ans.append(v)
            except ParseError as err:
                e = err
                self.input = m
                break
        return ans, e


    def repeat(self, min, max, fn):
        """
        Call C{fn} C{max} times or until it fails to match the
        input. Fail if less than C{min} matches were made.
        Collect the results into a list.
        """
        if min == max == 0:
            return '', None
        ans = []
        for i in range(min):
            v, e = fn()
            ans.append(v)

        for i in range(min, max):
            try:
                m = self.input
                v, e = fn()
                ans.append(v)
            except ParseError as err:
                e = err
                self.input = m
                break
        return ans, e

    def _or(self, fns):
        """
        Call each of a list of functions in sequence until one succeeds,
        rewinding the input between each.

        @param fns: A list of no-argument callables.
        """
        errors = []
        for f in fns:
            try:
                m = self.input
                ret, err = f()
                errors.append(err)
                return ret, joinErrors(errors)
            except ParseError as e:
                errors.append(e)
                self.input = m
        raise joinErrors(errors)


    def _not(self, fn):
        """
        Call the given function. Raise ParseError iff it does not.

        @param fn: A callable of no arguments.
        """
        m = self.input
        try:
            fn()
        except ParseError:
            self.input = m
            return True, self.input.nullError()
        else:
            raise self.input.nullError()


    def eatWhitespace(self):
        """
        Consume input until a non-whitespace character is reached.
        """
        while True:
            try:
                c, e = self.input.head()
            except EOFError as err:
                e = err
                break
            tl = self.input.tail()
            if c.isspace():
                self.input = tl
            else:
                break
        return True, e


    def pred(self, expr):
        """
        Call the given function, raising ParseError if it returns false.

        @param expr: A callable of no arguments.
        """
        val, e = expr()
        if not val:
            raise e
        else:
            return True, e


    def listpattern(self, expr):
        """
        Call the given function, treating the next object on the stack as an
        iterable to be used for input.

        @param expr: A callable of no arguments.
        """
        v, e = self.rule_anything()
        oldInput = self.input
        try:
            self.input = InputStream.fromIterable(v)
        except TypeError:
            raise e.withMessage(expected("an iterable"))

        expr()
        self.end()
        self.input = oldInput
        return v, e


    def consumedby(self, expr):
        oldInput = self.input
        _, e = expr()
        slice = oldInput.data[oldInput.position:self.input.position]
        return slice, e


    def stringtemplate(self, template, vals):
        output = []
        checkIndent = False
        currentIndent = ""
        for chunk in template.args:
            if chunk.tag.name == ".String.":
                output.append(chunk.data)
                if checkIndent and chunk.data.isspace():
                    currentIndent = chunk.data
                    checkIndent = False
                if chunk.data.endswith('\n'):
                    checkIndent = True
            elif chunk.tag.name == "QuasiExprHole":
                v = vals[chunk.args[0].data]
                if not isinstance(v, basestring):
                    try:
                        vs = list(v)
                    except TypeError:
                        raise TypeError("Only know how to templatize strings and lists of strings")
                    lines = []
                    for x in vs:
                        lines.extend(x.split('\n'))
                    compacted_lines = []
                    for line in lines:
                        if line:
                            compacted_lines.append(line)
                        elif compacted_lines:
                            compacted_lines[-1] = compacted_lines[-1] + '\n'
                    v = ("\n" + currentIndent).join(compacted_lines)
                output.append(v)
            else:
                raise TypeError("didn't expect %r in string template" % chunk)
        return ''.join(output).rstrip('\n'), None

    def end(self):
        """
        Match the end of the stream.
        """
        return self._not(self.rule_anything)


    def lookahead(self, f):
        """
        Execute the given callable, rewinding the stream no matter whether it
        returns successfully or not.

        @param f: A callable of no arguments.
        """
        try:
            m = self.input
            x = f()
            return x
        finally:
            self.input = m


    def token(self, tok):
        """
        Match and return the given string, consuming any preceding whitespace.
        """
        m = self.input
        try:
            self.eatWhitespace()
            for c in tok:
                v, e = self.exactly(c)
            return tok, e
        except ParseError as e:
            self.input = m
            raise e.withMessage(expected("token", tok))

    def label(self, foo, label):
        """
        Wrap a function and add label to expected message.
        """
        try:
            val, err = foo()
            err2 = err.withMessage([("Custom Exception:", label, None)])
            if self.currentError == err:
                self.currentError = err2
            return val, err2
        except ParseError as e:
            raise e.withMessage([("Custom Exception:", label, None)])


    def letter(self):
        """
        Match a single letter.
        """
        x, e = self.rule_anything()
        if x.isalpha():
            return x, e
        else:
            raise e.withMessage(expected("letter"))


    def letterOrDigit(self):
        """
        Match a single alphanumeric character.
        """
        x, e = self.rule_anything()
        if x.isalnum():
            return x, e
        else:
            raise e.withMessage(expected("letter or digit"))

    def digit(self):
        """
        Match a single digit.
        """
        x, e = self.rule_anything()
        if x.isdigit():
            return x, e
        else:
            raise e.withMessage(expected("digit"))

    rule_digit = digit

    rule_letterOrDigit = letterOrDigit
    rule_letter = letter
    rule_end = end
    rule_ws = eatWhitespace
    rule_exactly = exactly

    #Deprecated.
    rule_spaces = eatWhitespace
    rule_token = token


    def rule_anything(self):
        """
        Match a single item from the input of any kind.
        """
        h, p = self.input.head()
        self.input = self.input.tail()
        return h, p



class OMetaGrammarBase(OMetaBase):
    """
    Common methods for the OMeta grammar parser itself, and its variants.
    """
    tree_target = False

    @classmethod
    def makeGrammar(cls, grammar, name='Grammar'):
        """
        Define a new parser class with the rules in the given grammar.

        @param grammar: A string containing a PyMeta grammar.
        @param name: The name of the class to be generated.
        @param superclass: The class the generated class is a child of.
        """
        g = cls(grammar)
        if TIMING:
            start = time.time()
        tree = g.parseGrammar(name)
        if TIMING:
            print("Grammar %r parsed in %g secs" % (name, time.time() - start))
            def cnt(n):
                count = sum(cnt(a) for a in n.args) + 1
                return count
            print("%d nodes." % (cnt(tree)))
            start = time.time()
        modname = "pymeta_grammar__" + name
        filename = "/pymeta_generated_code/" + modname + ".py"
        source = writePython(tree, grammar)
        if TIMING:
            print("Grammar %r generated in %g secs" % (name, time.time() - start))
        return moduleFromGrammar(source, name, modname, filename)


    def __init__(self, grammar, *a, **kw):
        OMetaBase.__init__(self, dedent(grammar), *a, **kw)
        self._spanStart = 0


    def parseGrammar(self, name):
        """
        Entry point for converting a grammar to code (of some variety).

        @param name: The name for this grammar.

        @param builder: A class that implements the grammar-building interface
        (interface to be explicitly defined later)
        """
        self.name = name
        res, err = self.apply("grammar")
        try:
            self.input.head()
        except EOFError:
            pass
        else:
            raise err
        return res


    def startSpan(self):
        self._spanStart = self.input.position

    def getSpan(self):
        return (self._spanStart, self.input.position)

    def applicationArgs(self, finalChar):
        """
        Collect rule arguments, a list of Python expressions separated by
        spaces.
        """
        args = []
        while True:
            try:
                (arg, endchar), err = self.pythonExpr(" " + finalChar)
                if not arg:
                    break
                args.append(t.Action(arg))
                if endchar == finalChar:
                    break
                if endchar == ' ':
                    self.rule_anything()
            except ParseError:
                break
        if args:
            return args
        else:
            raise self.input.nullError()

    def ruleValueExpr(self, singleLine, span=None):
        """
        Find and generate code for a Python expression terminated by a close
        paren/brace or end of line.
        """
        (expr, endchar), err = self.pythonExpr(endChars="\r\n)]")
        # if str(endchar) in ")]" or (singleLine and endchar):
        #     self.input = self.input.prev()
        return t.Action(expr, span=span)

    def semanticActionExpr(self, span=None):
        """
        Find and generate code for a Python expression terminated by a
        close-paren, whose return value is ignored.
        """
        val = t.Action(self.pythonExpr(')')[0][0], span=span)
        self.exactly(')')
        return val

    def semanticPredicateExpr(self, span=None):
        """
        Find and generate code for a Python expression terminated by a
        close-paren, whose return value determines the success of the pattern
        it's in.
        """
        expr = t.Action(self.pythonExpr(')')[0][0], span=span)
        self.exactly(')')
        return t.Predicate(expr, span=span)


    def eatWhitespace(self):
        """
        Consume input until a non-whitespace character is reached.
        """
        consumingComment = False
        while True:
            try:
                c, e = self.input.head()
            except EOFError as e:
                break
            t = self.input.tail()
            if c.isspace() or consumingComment:
                self.input = t
                if c == '\n':
                    consumingComment = False
            elif c == '#':
                consumingComment = True
            else:
                break
        return True, e
    rule_spaces = eatWhitespace


    def pythonExpr(self, endChars="\r\n"):
        """
        Extract a Python expression from the input and return it.

        @arg endChars: A set of characters delimiting the end of the expression.
        """
        delimiters = { "(": ")", "[": "]", "{": "}"}
        stack = []
        expr = []
        endchar = None
        while True:
            try:
                c, e = self.rule_anything()
                endchar = c
            except ParseError as err:
                e = err
                endchar = None
                break
            if c in endChars and len(stack) == 0:
                self.input = self.input.prev()
                break
            else:
                expr.append(c)
                if c in delimiters:
                    stack.append(delimiters[c])
                elif len(stack) > 0 and c == stack[-1]:
                    stack.pop()
                elif c in delimiters.values():
                    raise ParseError(self.input.data, self.input.position,
                                     expected("Python expression"))
                elif c in "\"'":
                    while True:
                        strc, stre = self.rule_anything()
                        expr.append(strc)
                        slashcount = 0
                        while strc == '\\':
                            strc, stre = self.rule_anything()
                            expr.append(strc)
                            slashcount += 1
                        if strc == c and slashcount % 2 == 0:
                            break

        if len(stack) > 0:
            raise ParseError(self.input.data, self.input.position,
                             expected("Python expression"))
        return (''.join(expr).strip(), endchar), e


    def isTree(self):
        self.tree_target = True


class TreeTransformerBase(OMetaBase):

    @classmethod
    def transform(cls, term):
        g = cls([term])
        return g.apply("transform")

    def _transform_data(self, tt):
        if tt.data is not None:
            return tt.data
        name = tt.tag.name
        if name == 'null':
            return None
        if name == 'true':
            return True
        if name == 'false':
            return False
        raise ValueError()

    def rule_transform(self):
        tt, e = self.rule_anything()
        if isinstance(tt, Term):
            try:
                return self._transform_data(tt), e
            except ValueError:
                name = tt.tag.name
                if name == '.tuple.':
                    return self._transform_iterable(tt.args)
                else:
                    if getattr(self, 'rule_' + name, None):
                        return self.apply(name, tt)
                    else:
                        return self.apply("unknown_term", tt)
        else:
            return self._transform_iterable(tt)

    def _transform_iterable(self, contents):
        oldInput = self.input
        self.input = InputStream.fromIterable(contents)
        v = self.many(self.rule_transform)
        self.end()
        self.input = oldInput
        return v

    def rule_unknown_term(self):
        tt, _ = self.rule_anything()
        oldInput = self.input
        self.input = InputStream.fromIterable(tt.args)
        newargs, e = self.many(self.rule_transform)
        self.end()
        self.input = oldInput
        return Term(tt.tag, None, tuple(coerceToTerm(a) for a in newargs),
                    tt.span), e

    def rule_null(self):
        tt, e = self.rule_anything()
        if not tt.tag.name == "null":
            raise self.input.nullError()
        return None, self.input.nullError()

    def termpattern(self, name, expr):
        v, e = self.rule_anything()
        if name == ".tuple." and getattr(v, 'tag', None) is None:
            newInput = v
        elif name != v.tag.name:
            raise e.withMessage(expected("a Term named " + name))
        else:
            newInput = v.args
        oldInput = self.input
        try:
            self.input = InputStream.fromIterable(newInput)
        except TypeError:
            raise e.withMessage(expected("a Term"))

        expr()
        self.end()
        self.input = oldInput
        return v, e

    def exactly(self, wanted):
        """
        Match a single item from the input equal to the given
        specimen, or a sequence of characters if the input is string.
        @param wanted: What to match.
        """
        i = self.input
        if not self.tree and len(wanted) > 1:
            val, p, self.input = self.input.slice(len(wanted))
        else:
            val, p = self.input.head()
            self.input = self.input.tail()
        if getattr(val, 'data', None) is not None:
            val = val.data
        if wanted == val:
            return val, p
        else:
            self.input = i
            raise p.withMessage(expected(None, wanted))

    rule_exactly = exactly

########NEW FILE########
__FILENAME__ = helpers
import unittest


class TestCase(unittest.TestCase):
    def assertRaises(self, ex, f, *args, **kwargs):
        try:
            f(*args, **kwargs)
        except ex as e:
            return e
        else:
            assert False, "%r didn't raise %r" % (f, ex)

########NEW FILE########
__FILENAME__ = test_builder
from textwrap import dedent
import unittest

from ometa.builder import writePython
from terml.nodes import termMaker as t
from terml.parser import parseTerm as term

def dd(txt):
    return dedent(txt).strip()

class PythonWriterTests(unittest.TestCase):
    """
    Tests for generating Python source from an AST.
    """

    def test_exactly(self):
        """
        Test generation of code for the 'exactly' pattern.
        """

        x = t.Exactly("x")
        self.assertEqual(writePython(x ,""),
                         dd("""
                            _G_exactly_1, lastError = self.exactly('x')
                            self.considerError(lastError, None)
                            _G_exactly_1
                            """))



    def test_apply(self):
        """
        Test generation of code for rule application.
        """

        one = t.Action("1")
        x = t.Action("x")
        a = t.Apply("foo", "main", [one, x])
        self.assertEqual(writePython(a, ""),
                         dd("""
                            _G_python_1, lastError = (1), None
                            self.considerError(lastError, None)
                            _G_python_2, lastError = eval('x', self.globals, _locals), None
                            self.considerError(lastError, None)
                            _G_apply_3, lastError = self._apply(self.rule_foo, "foo", [_G_python_1, _G_python_2])
                            self.considerError(lastError, None)
                            _G_apply_3
                            """))

    def test_foreignApply(self):
        """
        Test generation of code for calling foreign grammar's rules.
        """
        one = t.Action("1")
        x = t.Action("x")
        a = t.ForeignApply("thegrammar", "foo", "main", [one, x])
        self.assertEqual(writePython(a, ""),
                         dd("""
                            _G_python_1, lastError = (1), None
                            self.considerError(lastError, None)
                            _G_python_2, lastError = eval('x', self.globals, _locals), None
                            self.considerError(lastError, None)
                            _G_apply_3, lastError = self.foreignApply("thegrammar", "foo", self.globals, _locals, _G_python_1, _G_python_2)
                            self.considerError(lastError, None)
                            _G_apply_3
                            """))

    def test_superApply(self):
        """
        Test generation of code for calling the superclass' implementation of
        the current rule.
        """
        one = t.Action("1")
        x = t.Action("x")
        a = t.Apply("super", "main", [one, x])
        self.assertEqual(writePython(a, ""),
                         dd("""
                            _G_python_1, lastError = (1), None
                            self.considerError(lastError, None)
                            _G_python_2, lastError = eval('x', self.globals, _locals), None
                            self.considerError(lastError, None)
                            _G_apply_3, lastError = self.superApply("main", _G_python_1, _G_python_2)
                            self.considerError(lastError, None)
                            _G_apply_3
                            """))


    def test_many(self):
        """
        Test generation of code for matching zero or more instances of
        a pattern.
        """

        xs = t.Many(t.Exactly("x"))
        self.assertEqual(writePython(xs, ""),
                         dd("""
                            def _G_many_1():
                                _G_exactly_2, lastError = self.exactly('x')
                                self.considerError(lastError, None)
                                return (_G_exactly_2, self.currentError)
                            _G_many_3, lastError = self.many(_G_many_1)
                            self.considerError(lastError, None)
                            _G_many_3
                            """))


    def test_many1(self):
        """
        Test generation of code for matching one or more instances of
        a pattern.
        """

        xs = t.Many1(t.Exactly("x"))
        self.assertEqual(writePython(xs, ""),
                         dd("""
                            def _G_many1_1():
                                _G_exactly_2, lastError = self.exactly('x')
                                self.considerError(lastError, None)
                                return (_G_exactly_2, self.currentError)
                            _G_many1_3, lastError = self.many(_G_many1_1, _G_many1_1())
                            self.considerError(lastError, None)
                            _G_many1_3
                            """))



    def test_or(self):
        """
        Test code generation for a sequence of alternatives.
        """

        xy = t.Or([t.Exactly("x"),
                               t.Exactly("y")])
        self.assertEqual(writePython(xy, ""),
                         dd("""
                            def _G_or_1():
                                _G_exactly_2, lastError = self.exactly('x')
                                self.considerError(lastError, None)
                                return (_G_exactly_2, self.currentError)
                            def _G_or_3():
                                _G_exactly_4, lastError = self.exactly('y')
                                self.considerError(lastError, None)
                                return (_G_exactly_4, self.currentError)
                            _G_or_5, lastError = self._or([_G_or_1, _G_or_3])
                            self.considerError(lastError, None)
                            _G_or_5
                            """))

    def test_singleOr(self):
        """
        Test code generation for a sequence of alternatives.
        """

        x1 = t.Or([t.Exactly("x")])
        x = t.Exactly("x")
        self.assertEqual(writePython(x, ""), writePython(x1, ""))


    def test_optional(self):
        """
        Test code generation for optional terms.
        """
        x = t.Optional(t.Exactly("x"))
        self.assertEqual(writePython(x, ""),
                         dd("""
                            def _G_optional_1():
                                _G_exactly_2, lastError = self.exactly('x')
                                self.considerError(lastError, None)
                                return (_G_exactly_2, self.currentError)
                            def _G_optional_3():
                                return (None, self.input.nullError())
                            _G_or_4, lastError = self._or([_G_optional_1, _G_optional_3])
                            self.considerError(lastError, None)
                            _G_or_4
                            """))


    def test_not(self):
        """
        Test code generation for negated terms.
        """
        x = t.Not(t.Exactly("x"))
        self.assertEqual(writePython(x ,""),
                         dd("""
                            def _G_not_1():
                                _G_exactly_2, lastError = self.exactly('x')
                                self.considerError(lastError, None)
                                return (_G_exactly_2, self.currentError)
                            _G_not_3, lastError = self._not(_G_not_1)
                            self.considerError(lastError, None)
                            _G_not_3
                            """))


    def test_lookahead(self):
        """
        Test code generation for lookahead expressions.
        """
        x = t.Lookahead(t.Exactly("x"))
        self.assertEqual(writePython(x, ""),
                         dd("""
                            def _G_lookahead_1():
                                _G_exactly_2, lastError = self.exactly('x')
                                self.considerError(lastError, None)
                                return (_G_exactly_2, self.currentError)
                            _G_lookahead_3, lastError = self.lookahead(_G_lookahead_1)
                            self.considerError(lastError, None)
                            _G_lookahead_3
                            """))



    def test_sequence(self):
        """
        Test generation of code for sequence patterns.
        """
        x = t.Exactly("x")
        y = t.Exactly("y")
        z = t.And([x, y])
        self.assertEqual(writePython(z, ""),
                         dd("""
                            _G_exactly_1, lastError = self.exactly('x')
                            self.considerError(lastError, None)
                            _G_exactly_2, lastError = self.exactly('y')
                            self.considerError(lastError, None)
                            _G_exactly_2
                            """))


    def test_bind(self):
        """
        Test code generation for variable assignment.
        """
        x = t.Exactly("x")
        b = t.Bind("var", x)
        self.assertEqual(writePython(b, ""),
                         dd("""
                            _G_exactly_1, lastError = self.exactly('x')
                            self.considerError(lastError, None)
                            _locals['var'] = _G_exactly_1
                            _G_exactly_1
                            """))


    def test_pred(self):
        """
        Test code generation for predicate expressions.
        """
        x = t.Predicate(t.Exactly("x"))
        self.assertEqual(writePython(x, ""),
                         dd("""
                            def _G_pred_1():
                                _G_exactly_2, lastError = self.exactly('x')
                                self.considerError(lastError, None)
                                return (_G_exactly_2, self.currentError)
                            _G_pred_3, lastError = self.pred(_G_pred_1)
                            self.considerError(lastError, None)
                            _G_pred_3
                            """))


    def test_action(self):
        """
        Test code generation for semantic actions.
        """
        x = t.Action("doStuff()")
        self.assertEqual(writePython(x, ""),
                         dd("""
                            _G_python_1, lastError = eval('doStuff()', self.globals, _locals), None
                            self.considerError(lastError, None)
                            _G_python_1
                            """))


    def test_expr(self):
        """
        Test code generation for semantic predicates.
        """
        x = t.Action("returnStuff()")
        self.assertEqual(writePython(x, ""),
                         dd("""
                            _G_python_1, lastError = eval('returnStuff()', self.globals, _locals), None
                            self.considerError(lastError, None)
                            _G_python_1
                            """))

    def test_label(self):
        """
        Test code generation for custom labels.
        """
        xs = t.Label(t.Exactly("x"), 'CustomLabel')
        self.assertEqual(writePython(xs, ""),
                         dd("""
                                def _G_label_1():
                                    _G_exactly_2, lastError = self.exactly('x')
                                    self.considerError(lastError, None)
                                    return (_G_exactly_2, self.currentError)
                                _G_label_3, lastError = self.label(_G_label_1, "CustomLabel")
                                self.considerError(lastError, None)
                                _G_label_3
                                """))

    def test_listpattern(self):
        """
        Test code generation for list patterns.
        """
        x = t.List(t.Exactly("x"))
        self.assertEqual(writePython(x, ""),
                         dd("""
                            def _G_listpattern_1():
                                _G_exactly_2, lastError = self.exactly('x')
                                self.considerError(lastError, None)
                                return (_G_exactly_2, self.currentError)
                            _G_listpattern_3, lastError = self.listpattern(_G_listpattern_1)
                            self.considerError(lastError, None)
                            _G_listpattern_3
                            """))


    def test_markAsTree(self):
        """
        Grammars containing list patterns are marked as taking
        tree-shaped input rather than character streams.
        """
        x = t.Rule("foo", t.List(
                t.Exactly("x")))
        g = t.Grammar("TestGrammar", True, [x])
        self.assert_("\n        tree = True\n" in writePython(g, ""))


    def test_rule(self):
        """
        Test generation of entire rules.
        """

        x = t.Rule("foo", t.Exactly("x"))
        self.assertEqual(writePython(x, ""),
                         dd("""
                            def rule_foo(self):
                                _locals = {'self': self}
                                self.locals['foo'] = _locals
                                _G_exactly_1, lastError = self.exactly('x')
                                self.considerError(lastError, 'foo')
                                return (_G_exactly_1, self.currentError)
                            """))


    def test_grammar(self):
        """
        Test generation of an entire grammar.
        """
        r1 = t.Rule("foo", t.Exactly("x"))
        r2 = t.Rule("baz", t.Exactly("y"))
        x = t.Grammar("BuilderTest", False, [r1, r2])
        self.assertEqual(
            writePython(x, ""),
            dd("""
               def createParserClass(GrammarBase, ruleGlobals):
                   if ruleGlobals is None:
                       ruleGlobals = {}
                   class BuilderTest(GrammarBase):
                       def rule_foo(self):
                           _locals = {'self': self}
                           self.locals['foo'] = _locals
                           _G_exactly_1, lastError = self.exactly('x')
                           self.considerError(lastError, 'foo')
                           return (_G_exactly_1, self.currentError)


                       def rule_baz(self):
                           _locals = {'self': self}
                           self.locals['baz'] = _locals
                           _G_exactly_2, lastError = self.exactly('y')
                           self.considerError(lastError, 'baz')
                           return (_G_exactly_2, self.currentError)


                   if BuilderTest.globals is not None:
                       BuilderTest.globals = BuilderTest.globals.copy()
                       BuilderTest.globals.update(ruleGlobals)
                   else:
                       BuilderTest.globals = ruleGlobals
                   return BuilderTest
                            """))

########NEW FILE########
__FILENAME__ = test_protocol
import unittest

import pytest

from ometa.grammar import OMeta
from ometa.runtime import ParseError


protocol = pytest.importorskip('ometa.protocol')
ParserProtocol = protocol.ParserProtocol

testingGrammarSource = """

someA = ('a' 'a') -> receiver('a')
someB = ('b' 'b') -> receiver('b')
someC = ('c' 'c') -> receiver('c')
someExc = 'e' -> receiver.raiseSomething()

initial = someA | someExc

"""
testGrammar = OMeta(testingGrammarSource).parseGrammar('testGrammar')


class SenderFactory(object):
    def __init__(self, transport):
        self.transport = transport


class SomeException(Exception):
    pass


class ReceiverFactory(object):
    currentRule = 'initial'

    def __init__(self, sender):
        self.sender = sender
        self.calls = []
        self.returnMap = {}
        self.connected = False
        self.lossReason = None
        self.parser = None

    def prepareParsing(self, parser):
        self.connected = True
        self.parser = parser

    def __call__(self, v):
        self.calls.append(v)
        if v in self.returnMap:
            self.currentRule = self.returnMap[v]

    def raiseSomething(self):
        raise SomeException()

    def finishParsing(self, reason):
        self.lossReason = reason


class FakeTransport(object):
    def __init__(self):
        self.aborted = False

    def abortConnection(self):
        self.aborted = True


class ParserProtocolTestCase(unittest.TestCase):
    def setUp(self):
        self.protocol = ParserProtocol(
            testGrammar, SenderFactory, ReceiverFactory, {})

    def test_transportPassed(self):
        """The sender is passed the transport recieved by the protocol."""
        transport = object()
        self.protocol.makeConnection(transport)
        self.assertEqual(transport, self.protocol.sender.transport)

    def test_senderPassed(self):
        """The sender is passed to the receiver."""
        self.protocol.makeConnection(None)
        self.assertEqual(self.protocol.sender, self.protocol.receiver.sender)

    def test_parserPassed(self):
        """The parser is passed in the prepareParsing method."""
        self.protocol.makeConnection(None)
        self.assertEqual(self.protocol, self.protocol.receiver.parser)

    def test_connectionEstablishes(self):
        """prepareParsing is called on the receiver after connection establishment."""
        self.protocol.makeConnection(None)
        self.assert_(self.protocol.receiver.connected)

    def test_basicParsing(self):
        """Rules can be parsed multiple times for the same effect."""
        self.protocol.makeConnection(None)
        self.protocol.dataReceived('aa')
        self.assertEqual(self.protocol.receiver.calls, ['a'])
        self.protocol.dataReceived('aa')
        self.assertEqual(self.protocol.receiver.calls, ['a', 'a'])

    def test_parsingChunks(self):
        """Any number of rules can be called from one dataRecived."""
        self.protocol.makeConnection(None)
        self.protocol.dataReceived('a')
        self.assertEqual(self.protocol.receiver.calls, [])
        self.protocol.dataReceived('aa')
        self.assertEqual(self.protocol.receiver.calls, ['a'])
        self.protocol.dataReceived('aaa')
        self.assertEqual(self.protocol.receiver.calls, ['a', 'a', 'a'])

    def test_ruleSwitching(self):
        """The rule being parsed can specify the next rule to be parsed."""
        self.protocol.makeConnection(None)
        self.protocol.receiver.returnMap.update(dict(a='someB', b='someA'))
        self.protocol.dataReceived('aa')
        self.assertEqual(self.protocol.receiver.calls, ['a'])
        self.protocol.dataReceived('bb')
        self.assertEqual(self.protocol.receiver.calls, ['a', 'b'])
        self.protocol.dataReceived('aa')
        self.assertEqual(self.protocol.receiver.calls, ['a', 'b', 'a'])

    def test_ruleSwitchingWithChunks(self):
        """Any number of rules can be called even during rule switching."""
        self.protocol.makeConnection(None)
        self.protocol.receiver.returnMap.update(dict(a='someB', b='someA'))
        self.protocol.dataReceived('a')
        self.assertEqual(self.protocol.receiver.calls, [])
        self.protocol.dataReceived('ab')
        self.assertEqual(self.protocol.receiver.calls, ['a'])
        self.protocol.dataReceived('baa')
        self.assertEqual(self.protocol.receiver.calls, ['a', 'b', 'a'])

    def test_rulesCannotBeSwitchedDuringParsing(self):
        """
        One can set a new rule during parsing, but it won't change the rule
        currently being parsed.
        """
        self.protocol.makeConnection(None)
        self.protocol.dataReceived('aa')
        self.assertEqual(self.protocol.receiver.calls, ['a'])
        self.protocol.dataReceived('a')
        self.assertEqual(self.protocol.receiver.calls, ['a'])
        self.protocol.receiver.currentRule = 'someC'
        self.protocol.dataReceived('acc')
        self.assertEqual(self.protocol.receiver.calls, ['a', 'a', 'c'])

    def test_connectionLoss(self):
        """The reason for connection loss is forwarded to the receiver."""
        self.protocol.makeConnection(None)
        reason = object()
        self.protocol.connectionLost(reason)
        self.assertEqual(self.protocol.receiver.lossReason, reason)

    def test_parseFailure(self):
        """
        Parse failures cause connection abortion with the parse error as the
        reason.
        """
        transport = FakeTransport()
        self.protocol.makeConnection(transport)
        self.protocol.dataReceived('b')
        self.failIfEqual(self.protocol.receiver.lossReason, None)
        self.assertTrue(
            isinstance(self.protocol.receiver.lossReason.value, ParseError))
        self.assert_(transport.aborted)

    def test_exceptionsRaisedFromReceiver(self):
        """
        Raising an exception from receiver methods called from the grammar
        propagate to finishParsing.
        """
        transport = FakeTransport()
        self.protocol.makeConnection(transport)
        self.protocol.dataReceived('e')
        self.failIfEqual(self.protocol.receiver.lossReason, None)
        self.assertTrue(
            isinstance(self.protocol.receiver.lossReason.value, SomeException))
        self.assert_(transport.aborted)

    def test_dataIgnoredAfterDisconnection(self):
        """After connectionLost is called, all incoming data is ignored."""
        transport = FakeTransport()
        self.protocol.makeConnection(transport)
        reason = object()
        self.protocol.connectionLost(reason)
        self.protocol.dataReceived('d')
        self.assertEqual(self.protocol.receiver.lossReason, reason)
        self.assert_(not transport.aborted)

########NEW FILE########
__FILENAME__ = test_pymeta
#from __future__ import unicode_literals

import operator
from textwrap import dedent

import pytest

from ometa.grammar import OMeta, TermOMeta, TreeTransformerGrammar
from ometa.compat import OMeta1
from ometa.runtime import (ParseError, OMetaBase, OMetaGrammarBase, EOFError,
                           expected, TreeTransformerBase)
from ometa.interp import GrammarInterpreter, TrampolinedGrammarInterpreter
from terml.parser import parseTerm as term
from ometa.test.helpers import TestCase

try:
    basestring
except NameError:
    basestring = str


class HandyWrapper(object):
    """
    Convenient grammar wrapper for parsing strings.
    """
    def __init__(self, klass):
        """
        @param klass: The grammar class to be wrapped.
        """
        self.klass = klass


    def __getattr__(self, name):
        """
        Return a function that will instantiate a grammar and invoke the named
        rule.
        @param: Rule name.
        """
        def doIt(s):
            """
            @param s: The string to be parsed by the wrapped grammar.
            """
            obj = self.klass(s)
            ret, err = obj.apply(name)
            try:
                extra, _ = obj.input.head()
            except EOFError:
                try:
                    return ''.join(ret)
                except TypeError:
                    return ret
            else:
                raise err
        return doIt



class OMeta1TestCase(TestCase):
    """
    Tests of OMeta grammar compilation, with v1 syntax.
    """

    classTested = OMeta1

    def compile(self, grammar):
        """
        Produce an object capable of parsing via this grammar.

        @param grammar: A string containing an OMeta grammar.
        """
        m = self.classTested.makeGrammar(dedent(grammar), 'TestGrammar')
        g = m.createParserClass(OMetaBase, globals())
        return HandyWrapper(g)



    def test_literals(self):
        """
        Input matches can be made on literal characters.
        """
        g = self.compile("digit ::= '1'")
        self.assertEqual(g.digit("1"), "1")
        self.assertRaises(ParseError, g.digit, "4")


    def test_multipleRules(self):
        """
        Grammars with more than one rule work properly.
        """
        g = self.compile("""
                          digit ::= '1'
                          aLetter ::= 'a'
                          """)
        self.assertEqual(g.digit("1"), "1")
        self.assertRaises(ParseError, g.digit, "4")


    def test_escapedLiterals(self):
        """
        Input matches can be made on escaped literal characters.
        """
        g = self.compile(r"newline ::= '\n'")
        self.assertEqual(g.newline("\n"), "\n")


    def test_integers(self):
        """
        Input matches can be made on literal integers.
        """
        g = self.compile("stuff ::= 17 0x1F -2 0177")
        self.assertEqual(g.stuff([17, 0x1f, -2, 0o177]), 0o177)
        self.assertRaises(ParseError, g.stuff, [1, 2, 3])


    def test_star(self):
        """
        Input matches can be made on zero or more repetitions of a pattern.
        """
        g = self.compile("xs ::= 'x'*")
        self.assertEqual(g.xs(""), "")
        self.assertEqual(g.xs("x"), "x")
        self.assertEqual(g.xs("xxxx"), "xxxx")
        self.assertRaises(ParseError, g.xs, "xy")


    def test_plus(self):
        """
        Input matches can be made on one or more repetitions of a pattern.
        """
        g = self.compile("xs ::= 'x'+")
        self.assertEqual(g.xs("x"), "x")
        self.assertEqual(g.xs("xxxx"), "xxxx")
        self.assertRaises(ParseError, g.xs, "xy")
        self.assertRaises(ParseError, g.xs, "")


    def test_sequencing(self):
        """
        Input matches can be made on a sequence of patterns.
        """
        g = self.compile("twelve ::= '1' '2'")
        self.assertEqual(g.twelve("12"), "2");
        self.assertRaises(ParseError, g.twelve, "1")


    def test_alternatives(self):
        """
        Input matches can be made on one of a set of alternatives.
        """
        g = self.compile("digit ::= '0' | '1' | '2'")
        self.assertEqual(g.digit("0"), "0")
        self.assertEqual(g.digit("1"), "1")
        self.assertEqual(g.digit("2"), "2")
        self.assertRaises(ParseError, g.digit, "3")


    def test_optional(self):
        """
        Subpatterns can be made optional.
        """
        g = self.compile("foo ::= 'x' 'y'? 'z'")
        self.assertEqual(g.foo("xyz"), 'z')
        self.assertEqual(g.foo("xz"), 'z')


    def test_apply(self):
        """
        Other productions can be invoked from within a production.
        """
        g = self.compile("""
              digit ::= '0' | '1'
              bits ::= <digit>+
            """)
        self.assertEqual(g.bits('0110110'), '0110110')


    def test_negate(self):
        """
        Input can be matched based on its failure to match a pattern.
        """
        g = self.compile("foo ::= ~'0' <anything>")
        self.assertEqual(g.foo("1"), "1")
        self.assertRaises(ParseError, g.foo, "0")


    def test_ruleValue(self):
        """
        Productions can specify a Python expression that provides the result
        of the parse.
        """
        g = self.compile("foo ::= '1' => 7")
        self.assertEqual(g.foo('1'), 7)


    def test_ruleValueEscapeQuotes(self):
        """
        Escaped quotes are handled properly in Python expressions.
        """
        g = self.compile(r"""escapedChar ::= '\'' => '\\\''""")
        self.assertEqual(g.escapedChar("'"), "\\'")


    def test_ruleValueEscapeSlashes(self):
        """
        Escaped slashes are handled properly in Python expressions.
        """
        g = self.compile(r"""escapedChar ::= '\\' => '\\'""")
        self.assertEqual(g.escapedChar("\\"), "\\")


    def test_lookahead(self):
        """
        Doubled negation does lookahead.
        """
        g = self.compile("""
                         foo ::= ~~(:x) <bar x>
                         bar :x ::= :a :b ?(x == a == b) => x
                         """)
        self.assertEqual(g.foo("11"), '1')
        self.assertEqual(g.foo("22"), '2')


    def test_binding(self):
        """
        The result of a parsing expression can be bound to a name.
        """
        g = self.compile("foo ::= '1':x => int(x) * 2")
        self.assertEqual(g.foo("1"), 2)


    def test_bindingAccess(self):
        """
        Bound names in a rule can be accessed on the grammar's "locals" dict.
        """
        G = self.classTested.makeGrammar(
            "stuff ::= '1':a ('2':b | '3':c)", 'TestGrammar').createParserClass(OMetaBase, {})
        g = G("12")
        self.assertEqual(g.apply("stuff")[0], '2')
        self.assertEqual(g.locals['stuff']['a'], '1')
        self.assertEqual(g.locals['stuff']['b'], '2')
        g = G("13")
        self.assertEqual(g.apply("stuff")[0], '3')
        self.assertEqual(g.locals['stuff']['a'], '1')
        self.assertEqual(g.locals['stuff']['c'], '3')


    def test_predicate(self):
        """
        Python expressions can be used to determine the success or failure of a
        parse.
        """
        g = self.compile("""
              digit ::= '0' | '1'
              double_bits ::= <digit>:a <digit>:b ?(a == b) => int(b)
           """)
        self.assertEqual(g.double_bits("00"), 0)
        self.assertEqual(g.double_bits("11"), 1)
        self.assertRaises(ParseError, g.double_bits, "10")
        self.assertRaises(ParseError, g.double_bits, "01")


    def test_parens(self):
        """
        Parens can be used to group subpatterns.
        """
        g = self.compile("foo ::= 'a' ('b' | 'c')")
        self.assertEqual(g.foo("ab"), "b")
        self.assertEqual(g.foo("ac"), "c")


    def test_action(self):
        """
        Python expressions can be run as actions with no effect on the result
        of the parse.
        """
        g = self.compile("""foo ::= ('1'*:ones !(False) !(ones.insert(0, '0')) => ''.join(ones))""")
        self.assertEqual(g.foo("111"), "0111")


    def test_bindNameOnly(self):
        """
        A pattern consisting of only a bind name matches a single element and
        binds it to that name.
        """
        g = self.compile("foo ::= '1' :x '2' => x")
        self.assertEqual(g.foo("132"), "3")


    def test_args(self):
        """
        Productions can take arguments.
        """
        g = self.compile("""
              digit ::= ('0' | '1' | '2'):d => int(d)
              foo :x :ignored ::= (?(int(x) > 1) '9' | ?(int(x) <= 1) '8'):d => int(d)
              baz ::= <digit>:a <foo a None>:b => [a, b]
            """)
        self.assertEqual(g.baz("18"), [1, 8])
        self.assertEqual(g.baz("08"), [0, 8])
        self.assertEqual(g.baz("29"), [2, 9])
        self.assertRaises(ParseError, g.baz, "28")


    def test_patternMatch(self):
        """
        Productions can pattern-match on arguments.
        Also, multiple definitions of a rule can be done in sequence.
        """
        g = self.compile("""
              fact 0                       => 1
              fact :n ::= <fact (n - 1)>:m => n * m
           """)
        self.assertEqual(g.fact([3]), 6)


    def test_listpattern(self):
        """
        Brackets can be used to match contents of lists.
        """
        g = self.compile("""
             digit  ::= :x ?(x.isdigit())          => int(x)
             interp ::= [<digit>:x '+' <digit>:y] => x + y
           """)
        self.assertEqual(g.interp([['3', '+', '5']]), 8)

    def test_listpatternresult(self):
        """
        The result of a list pattern is the entire list.
        """
        g = self.compile("""
             digit  ::= :x ?(x.isdigit())          => int(x)
             interp ::= [<digit>:x '+' <digit>:y]:z => (z, x + y)
        """)
        e = ['3', '+', '5']
        self.assertEqual(g.interp([e]), (e, 8))

    def test_recursion(self):
        """
        Rules can call themselves.
        """
        g = self.compile("""
             interp ::= (['+' <interp>:x <interp>:y] => x + y
                       | ['*' <interp>:x <interp>:y] => x * y
                       | :x ?(isinstance(x, str) and x.isdigit()) => int(x))
             """)
        self.assertEqual(g.interp([['+', '3', ['*', '5', '2']]]), 13)


    def test_leftrecursion(self):
         """
         Left-recursion is detected and compiled appropriately.
         """
         g = self.compile("""
               num ::= (<num>:n <digit>:d   => n * 10 + d
                      | <digit>)
               digit ::= :x ?(x.isdigit()) => int(x)
              """)
         self.assertEqual(g.num("3"), 3)
         self.assertEqual(g.num("32767"), 32767)


    def test_characterVsSequence(self):
        """
        Characters (in single-quotes) are not regarded as sequences.
        """
        g = self.compile("""
        interp ::= ([<interp>:x '+' <interp>:y] => x + y
                  | [<interp>:x '*' <interp>:y] => x * y
                  | :x ?(isinstance(x, basestring) and x.isdigit()) => int(x))
        """)
        self.assertEqual(g.interp([['3', '+', ['5', '*', '2']]]), 13)
        self.assertEqual(g.interp([['3', '+', ['5', '*', '2']]]), 13)


    def test_string(self):
        """
        Strings in double quotes match string objects.
        """
        g = self.compile("""
             interp ::= ["Foo" 1 2] => 3
           """)
        self.assertEqual(g.interp([["Foo", 1, 2]]), 3)

    def test_argEscape(self):
        """
        Regression test for bug #239344.
        """
        g = self.compile("""
            memo_arg :arg ::= <anything> ?(False)
            trick ::= <letter> <memo_arg 'c'>
            broken ::= <trick> | <anything>*
        """)
        self.assertEqual(g.broken('ab'), 'ab')


    def test_comments(self):
        """
        Comments in grammars are accepted and ignored.
        """
        g = self.compile("""
        #comment here
        digit ::= ( '0' #second comment
                  | '1') #another one
        #comments after rules are cool too
        bits ::= <digit>+   #last one
        """)
        self.assertEqual(g.bits('0110110'), '0110110')


    def test_accidental_bareword(self):
        """
        Accidental barewords are treated as syntax errors in the grammar.
        """
        self.assertRaises(ParseError,
                          self.compile, """
                          atom ::= ~('|') :a => Regex_Atom(a)
                                   | ' ' atom:a
                          """)




class OMetaTestCase(TestCase):
    """
    Tests of OMeta grammar compilation.
    """

    classTested = OMeta


    def compile(self, grammar, globals=None):
        """
        Produce an object capable of parsing via this grammar.

        @param grammar: A string containing an OMeta grammar.
        """
        g = self.classTested.makeGrammar(grammar, 'TestGrammar').createParserClass(OMetaBase, globals or {})
        return HandyWrapper(g)


    def test_literals(self):
        """
        Input matches can be made on literal characters.
        """
        g = self.compile("digit = '1'")
        self.assertEqual(g.digit("1"), "1")
        self.assertRaises(ParseError, g.digit, "4")


    def test_escaped_char(self):
        """
        Hex escapes are supported in strings in grammars.
        """
        g = self.compile(r"bel = '\x07'")
        self.assertEqual(g.bel("\x07"), "\x07")


    def test_literals_multi(self):
        """
        Input matches can be made on multiple literal characters at
        once.
        """
        g = self.compile("foo = 'foo'")
        self.assertEqual(g.foo("foo"), "foo")
        self.assertRaises(ParseError, g.foo, "for")

    def test_token(self):
        """
        Input matches can be made on tokens, which default to
        consuming leading whitespace.
        """
        g = self.compile('foo = "foo"')
        self.assertEqual(g.foo("    foo"), "foo")
        self.assertRaises(ParseError, g.foo, "fog")


    def test_multipleRules(self):
        """
        Grammars with more than one rule work properly.
        """
        g = self.compile("""
                          digit = '1'
                          aLetter = 'a'
                          """)
        self.assertEqual(g.digit("1"), "1")
        self.assertRaises(ParseError, g.digit, "4")


    def test_escapedLiterals(self):
        """
        Input matches can be made on escaped literal characters.
        """
        g = self.compile(r"newline = '\n'")
        self.assertEqual(g.newline("\n"), "\n")


    def test_integers(self):
        """
        Input matches can be made on literal integers.
        """
        g = self.compile("stuff = 17 0x1F -2 0177")
        self.assertEqual(g.stuff([17, 0x1f, -2, 0o177]), 0o177)
        self.assertRaises(ParseError, g.stuff, [1, 2, 3])


    def test_star(self):
        """
        Input matches can be made on zero or more repetitions of a pattern.
        """
        g = self.compile("xs = 'x'*")
        self.assertEqual(g.xs(""), "")
        self.assertEqual(g.xs("x"), "x")
        self.assertEqual(g.xs("xxxx"), "xxxx")
        self.assertRaises(ParseError, g.xs, "xy")


    def test_plus(self):
        """
        Input matches can be made on one or more repetitions of a pattern.
        """
        g = self.compile("xs = 'x'+")
        self.assertEqual(g.xs("x"), "x")
        self.assertEqual(g.xs("xxxx"), "xxxx")
        self.assertRaises(ParseError, g.xs, "xy")
        self.assertRaises(ParseError, g.xs, "")


    def test_repeat(self):
        """
        Match repetitions can be specifically numbered.
        """
        g = self.compile("xs = 'x'{2, 4}:n 'x'* -> n")
        self.assertEqual(g.xs("xx"), "xx")
        self.assertEqual(g.xs("xxxx"), "xxxx")
        self.assertEqual(g.xs("xxxxxx"), "xxxx")
        self.assertRaises(ParseError, g.xs, "x")
        self.assertRaises(ParseError, g.xs, "")


    def test_repeat_single(self):
        """
        Match repetitions can be specifically numbered.
        """
        g = self.compile("xs = 'x'{3}:n 'x'* -> n")
        self.assertEqual(g.xs("xxx"), "xxx")
        self.assertEqual(g.xs("xxxxxx"), "xxx")
        self.assertRaises(ParseError, g.xs, "xx")

    def test_repeat_zero(self):
        """
        Match repetitions can be specifically numbered.
        """
        g = self.compile("xs = 'x'{0}:n 'y' -> n")
        self.assertEqual(g.xs("y"), "")
        self.assertRaises(ParseError, g.xs, "xy")

    def test_repeat_zero_n(self):
        """
        Match repetitions can be specifically numbered.
        """
        g = self.compile("""
                         xs :n = 'x'{n}:a 'y' -> a
                         start = xs(0)
                         """)
        self.assertEqual(g.start("y"), "")
        self.assertRaises(ParseError, g.start, "xy")


    def test_repeat_var(self):
        """
        Match repetitions can be variables.
        """
        g = self.compile("xs = (:v -> int(v)):n 'x'{n}:xs 'x'* -> xs")
        self.assertEqual(g.xs("2xx"), "xx")
        self.assertEqual(g.xs("4xxxx"), "xxxx")
        self.assertEqual(g.xs("3xxxxxx"), "xxx")
        self.assertRaises(ParseError, g.xs, "2x")
        self.assertRaises(ParseError, g.xs, "1")


    def test_sequencing(self):
        """
        Input matches can be made on a sequence of patterns.
        """
        g = self.compile("twelve = '1' '2'")
        self.assertEqual(g.twelve("12"), "2");
        self.assertRaises(ParseError, g.twelve, "1")


    def test_alternatives(self):
        """
        Input matches can be made on one of a set of alternatives.
        """
        g = self.compile("digit = '0' | '1' | '2'")
        self.assertEqual(g.digit("0"), "0")
        self.assertEqual(g.digit("1"), "1")
        self.assertEqual(g.digit("2"), "2")
        self.assertRaises(ParseError, g.digit, "3")


    def test_optional(self):
        """
        Subpatterns can be made optional.
        """
        g = self.compile("foo = 'x' 'y'? 'z'")
        self.assertEqual(g.foo("xyz"), 'z')
        self.assertEqual(g.foo("xz"), 'z')


    def test_apply(self):
        """
        Other productions can be invoked from within a production.
        """
        g = self.compile("""
              digit = '0' | '1'
              bits = digit+
            """)
        self.assertEqual(g.bits('0110110'), '0110110')


    def test_negate(self):
        """
        Input can be matched based on its failure to match a pattern.
        """
        g = self.compile("foo = ~'0' anything")
        self.assertEqual(g.foo("1"), "1")
        self.assertRaises(ParseError, g.foo, "0")


    def test_ruleValue(self):
        """
        Productions can specify a Python expression that provides the result
        of the parse.
        """
        g = self.compile("foo = '1' -> 7")
        self.assertEqual(g.foo('1'), 7)


    def test_lookahead(self):
        """
        Doubled negation does lookahead.
        """
        g = self.compile("""
                         foo = ~~(:x) bar(x)
                         bar :x = :a :b ?(x == a == b) -> x
                         """)
        self.assertEqual(g.foo("11"), '1')
        self.assertEqual(g.foo("22"), '2')


    def test_binding(self):
        """
        The result of a parsing expression can be bound to a single name
        or names surrounded by parentheses.
        """
        g = self.compile("foo = '1':x -> int(x) * 2")
        self.assertEqual(g.foo("1"), 2)
        g = self.compile("foo = '1':(x) -> int(x) * 2")
        self.assertEqual(g.foo("1"), 2)
        g = self.compile("foo = (-> 3, 4):(x, y) -> x")
        self.assertEqual(g.foo(""), 3)
        g = self.compile("foo = (-> 1, 2):(x, y) -> int(x) * 2 + int(y)")
        self.assertEqual(g.foo(""), 4)


    def test_bindingAccess(self):
        """
        Bound names in a rule can be accessed on the grammar's "locals" dict.
        """
        G = self.classTested.makeGrammar(
            "stuff = '1':a ('2':b | '3':c)", 'TestGrammar').createParserClass(OMetaBase, {})
        g = G("12")
        self.assertEqual(g.apply("stuff")[0], '2')
        self.assertEqual(g.locals['stuff']['a'], '1')
        self.assertEqual(g.locals['stuff']['b'], '2')
        g = G("13")
        self.assertEqual(g.apply("stuff")[0], '3')
        self.assertEqual(g.locals['stuff']['a'], '1')
        self.assertEqual(g.locals['stuff']['c'], '3')
        G = self.classTested.makeGrammar(
            "stuff = '1':a ('2':(b) | '345':(c, d, e))", 'TestGrammar').createParserClass(OMetaBase, {})
        g = G("12")
        self.assertEqual(g.apply("stuff")[0], '2')
        self.assertEqual(g.locals['stuff']['a'], '1')
        self.assertEqual(g.locals['stuff']['b'], '2')
        g = G("1345")
        self.assertEqual(g.apply("stuff")[0], '345')
        self.assertEqual(g.locals['stuff']['a'], '1')
        self.assertEqual(g.locals['stuff']['c'], '3')
        self.assertEqual(g.locals['stuff']['d'], '4')
        self.assertEqual(g.locals['stuff']['e'], '5')


    def test_predicate(self):
        """
        Python expressions can be used to determine the success or
        failure of a parse.
        """
        g = self.compile("""
              digit = '0' | '1'
              double_bits = digit:a digit:b ?(a == b) -> int(b)
           """)
        self.assertEqual(g.double_bits("00"), 0)
        self.assertEqual(g.double_bits("11"), 1)
        self.assertRaises(ParseError, g.double_bits, "10")
        self.assertRaises(ParseError, g.double_bits, "01")


    def test_parens(self):
        """
        Parens can be used to group subpatterns.
        """
        g = self.compile("foo = 'a' ('b' | 'c')")
        self.assertEqual(g.foo("ab"), "b")
        self.assertEqual(g.foo("ac"), "c")


    def test_action(self):
        """
        Python expressions can be run as actions with no effect on the
        result of the parse.
        """
        g = self.compile("""foo = ('1'*:ones !(False) !(ones.insert(0, '0')) -> ''.join(ones))""")
        self.assertEqual(g.foo("111"), "0111")


    def test_bindNameOnly(self):
        """
        A pattern consisting of only a bind name matches a single element and
        binds it to that name.
        """
        g = self.compile("foo = '1' :x '2' -> x")
        self.assertEqual(g.foo("132"), "3")


    def test_args(self):
        """
        Productions can take arguments.
        """
        g = self.compile("""
              digit = ('0' | '1' | '2'):d -> int(d)
              foo :x = (?(int(x) > 1) '9' | ?(int(x) <= 1) '8'):d -> int(d)
              baz = digit:a foo(a):b -> [a, b]
            """)
        self.assertEqual(g.baz("18"), [1, 8])
        self.assertEqual(g.baz("08"), [0, 8])
        self.assertEqual(g.baz("29"), [2, 9])
        self.assertRaises(ParseError, g.baz, "28")


    def test_patternMatch(self):
        """
        Productions can pattern-match on arguments.
        Also, multiple definitions of a rule can be done in sequence.
        """
        g = self.compile("""
              fact 0                    -> 1
              fact :n = fact((n - 1)):m -> n * m
           """)
        self.assertEqual(g.fact([3]), 6)


    def test_listpattern(self):
        """
        Brackets can be used to match contents of lists.
        """
        g = self.compile("""
             digit  = :x ?(x.isdigit())     -> int(x)
             interp = [digit:x '+' digit:y] -> x + y
           """)
        self.assertEqual(g.interp([['3', '+', '5']]), 8)

    def test_listpatternresult(self):
        """
        The result of a list pattern is the entire list.
        """
        g = self.compile("""
             digit  = :x ?(x.isdigit())       -> int(x)
             interp = [digit:x '+' digit:y]:z -> (z, x + y)
        """)
        e = ['3', '+', '5']
        self.assertEqual(g.interp([e]), (e, 8))

    def test_recursion(self):
        """
        Rules can call themselves.
        """
        g = self.compile("""
             interp = (['+' interp:x interp:y] -> x + y
                       | ['*' interp:x interp:y] -> x * y
                       | :x ?(isinstance(x, str) and x.isdigit()) -> int(x))
             """)
        self.assertEqual(g.interp([['+', '3', ['*', '5', '2']]]), 13)


    def test_leftrecursion(self):
         """
         Left-recursion is detected and compiled appropriately.
         """
         g = self.compile("""
               num = (num:n digit:d   -> n * 10 + d
                      | digit)
               digit = :x ?(x.isdigit()) -> int(x)
              """)
         self.assertEqual(g.num("3"), 3)
         self.assertEqual(g.num("32767"), 32767)


    def test_characterVsSequence(self):
        """
        Characters (in single-quotes) are not regarded as sequences.
        """
        g = self.compile("""
        interp = ([interp:x '+' interp:y] -> x + y
                  | [interp:x '*' interp:y] -> x * y
                  | :x ?(isinstance(x, basestring) and x.isdigit()) -> int(x))
        """)
        self.assertEqual(g.interp([['3', '+', ['5', '*', '2']]]), 13)
        self.assertEqual(g.interp([['3', '+', ['5', '*', '2']]]), 13)


    def test_stringConsumedBy(self):
        """
        OMeta2's "consumed-by" operator works on strings.
        """
        g = self.compile("""
        ident = <letter (letter | digit)*>
        """)
        self.assertEqual(g.ident("a"), "a")
        self.assertEqual(g.ident("abc"), "abc")
        self.assertEqual(g.ident("a1z"), "a1z")
        self.assertRaises(ParseError, g.ident, "1a")


    def test_label(self):
        """
        Custom labels change the 'expected' in the raised exceptions.
        """
        label = 'Letter not starting with digit'
        g = self.compile("ident = (<letter (letter | digit)*>) ^ (" + label + ")")
        self.assertEqual(g.ident("a"), "a")
        self.assertEqual(g.ident("abc"), "abc")
        self.assertEqual(g.ident("a1z"), "a1z")

        e = self.assertRaises(ParseError, g.ident, "1a")
        self.assertEqual(e, ParseError(0, 0, expected(label)).withMessage([("Custom Exception:", label, None)]))

    def test_label2(self):
        """
        Custom labels change the 'expected' in the raised exceptions.
        """
        label = 'lots of xs'
        g = self.compile("xs = ('x'*) ^ (" + label + ")")
        self.assertEqual(g.xs(""), "")
        self.assertEqual(g.xs("x"), "x")
        self.assertEqual(g.xs("xxx"), "xxx")
        e = self.assertRaises(ParseError, g.xs, "xy")
        self.assertEqual(e, ParseError(0, 1, expected(label)).withMessage([("Custom Exception:", label, None)]))


    def test_listConsumedBy(self):
        """
        OMeta2's "consumed-by" operator works on lists.
        """
        g = self.compile("""
        ands = [<"And" (ors | vals)*>:x] -> x
        ors = [<"Or" vals*:x>] -> x
        vals = 1 | 0
        """)
        self.assertEqual(g.ands([["And", ["Or", 1, 0], 1]]),
                         ["And", ["Or", 1, 0], 1])


    def test_string(self):
        """
        Strings in double quotes match string objects.
        """
        g = self.compile("""
             interp = ["Foo" 1 2] -> 3
           """)
        self.assertEqual(g.interp([["Foo", 1, 2]]), 3)

    def test_argEscape(self):
        """
        Regression test for bug #239344.
        """
        g = self.compile("""
            memo_arg :arg = anything ?(False)
            trick = letter memo_arg('c')
            broken = trick | anything*
        """)
        self.assertEqual(g.broken('ab'), 'ab')


class TermActionGrammarTests(OMetaTestCase):

    classTested = TermOMeta

    def test_binding(self):
        """
        The result of a parsing expression can be bound to a name.
        """
        g = self.compile("foo = '1':x -> mul(int(x), 2)",
                         {"mul": operator.mul})
        self.assertEqual(g.foo("1"), 2)


    def test_bindingAccess(self):
        """
        Bound names in a rule can be accessed on the grammar's "locals" dict.
        """
        G = self.classTested.makeGrammar(
            "stuff = '1':a ('2':b | '3':c)", 'TestGrammar').createParserClass(OMetaBase, {})
        g = G("12")
        self.assertEqual(g.apply("stuff")[0], '2')
        self.assertEqual(g.locals['stuff']['a'], '1')
        self.assertEqual(g.locals['stuff']['b'], '2')
        g = G("13")
        self.assertEqual(g.apply("stuff")[0], '3')
        self.assertEqual(g.locals['stuff']['a'], '1')
        self.assertEqual(g.locals['stuff']['c'], '3')


    def test_predicate(self):
        """
        Term actions can be used to determine the success or
        failure of a parse.
        """
        g = self.compile("""
              digit = '0' | '1'
              double_bits = digit:a digit:b ?(equal(a, b)) -> int(b)
           """, {"equal": operator.eq})
        self.assertEqual(g.double_bits("00"), 0)
        self.assertEqual(g.double_bits("11"), 1)
        self.assertRaises(ParseError, g.double_bits, "10")
        self.assertRaises(ParseError, g.double_bits, "01")


    def test_action(self):
        """
        Term actions can be run as actions with no effect on the
        result of the parse.
        """
        g = self.compile(
            """foo = ('1'*:ones !(False)
                     !(nconc(ones, '0')) -> join(ones))""",
            {"nconc": lambda lst, val: lst.insert(0, val),
             "join": ''.join})
        self.assertEqual(g.foo("111"), "0111")


    def test_patternMatch(self):
        """
        Productions can pattern-match on arguments.
        Also, multiple definitions of a rule can be done in sequence.
        """
        g = self.compile("""
              fact 0                    -> 1
              fact :n = fact(decr(n)):m -> mul(n, m)
           """, {"mul": operator.mul, "decr": lambda x: x -1})
        self.assertEqual(g.fact([3]), 6)


    def test_listpattern(self):
        """
        Brackets can be used to match contents of lists.
        """
        g = self.compile("""
             digit  = :x ?(x.isdigit())     -> int(x)
             interp = [digit:x '+' digit:y] -> add(x, y)
           """, {"add": operator.add})
        self.assertEqual(g.interp([['3', '+', '5']]), 8)


    def test_listpatternresult(self):
        """
        The result of a list pattern is the entire list.
        """
        g = self.compile("""
             digit  = :x ?(x.isdigit())       -> int(x)
             interp = [digit:x '+' digit:y]:z -> [z, plus(x, y)]
        """, {"plus": operator.add})
        e = ['3', '+', '5']
        self.assertEqual(g.interp([e]), [e, 8])


    def test_recursion(self):
        """
        Rules can call themselves.
        """
        g = self.compile("""
             interp = (['+' interp:x interp:y]   -> add(x, y)
                       | ['*' interp:x interp:y] -> mul(x, y)
                       | :x ?(isdigit(x)) -> int(x))
             """, {"mul": operator.mul,
                   "add": operator.add,
                   "isdigit": lambda x: str(x).isdigit()})
        self.assertEqual(g.interp([['+', '3', ['*', '5', '2']]]), 13)


    def test_leftrecursion(self):
         """
         Left-recursion is detected and compiled appropriately.
         """
         g = self.compile("""
               num = (num:n digit:d   -> makeInt(n, d)
                      | digit)
               digit = :x ?(isdigit(x)) -> int(x)
              """, {"makeInt": lambda x, y: x * 10 + y,
                    "isdigit": lambda x: x.isdigit()})
         self.assertEqual(g.num("3"), 3)
         self.assertEqual(g.num("32767"), 32767)

    def test_characterVsSequence(self):
        """
        Characters (in single-quotes) are not regarded as sequences.
        """
        g = self.compile(
            """
        interp = ([interp:x '+' interp:y] -> add(x, y)
                  | [interp:x '*' interp:y] -> mul(x, y)
                  | :x ?(isdigit(x)) -> int(x))
        """,
            {"add": operator.add, "mul": operator.mul,
             "isdigit": lambda x: isinstance(x, basestring) and x.isdigit()})

        self.assertEqual(g.interp([['3', '+', ['5', '*', '2']]]), 13)
        self.assertEqual(g.interp([['3', '+', ['5', '*', '2']]]), 13)


    def test_string(self):
        """
        Strings in double quotes match string objects.
        """
        g = self.compile("""
             interp = ["Foo" 1 2] -> 3
           """)
        self.assertEqual(g.interp([["Foo", 1, 2]]), 3)

    def test_argEscape(self):
        """
        Regression test for bug #239344.
        """
        g = self.compile("""
            memo_arg :arg = anything ?(False)
            trick = letter memo_arg('c')
            broken = trick | anything*
        """)
        self.assertEqual(g.broken('ab'), 'ab')


    def test_lookahead(self):
        """
        Doubled negation does lookahead.
        """
        g = self.compile("""
                         foo = ~~(:x) bar(x)
                         bar :x = :a :b ?(equal(x, a, b)) -> x
                         """,
                         {"equal": lambda i, j, k: i == j == k})
        self.assertEqual(g.foo("11"), '1')
        self.assertEqual(g.foo("22"), '2')


    def test_args(self):
        """
        Productions can take arguments.
        """
        g = self.compile("""
              digit = ('0' | '1' | '2'):d -> int(d)
              foo :x = (?(gt(int(x), 1)) '9' | ?(lte(int(x), 1)) '8'):d -> int(d)
              baz = digit:a foo(a):b -> [a, b]
            """, {"lte": operator.le, "gt": operator.gt})
        self.assertEqual(g.baz("18"), [1, 8])
        self.assertEqual(g.baz("08"), [0, 8])
        self.assertEqual(g.baz("29"), [2, 9])
        self.assertRaises(ParseError, g.foo, "28")



class PyExtractorTest(TestCase):
    """
    Tests for finding Python expressions in OMeta grammars.
    """

    def findInGrammar(self, expr):
        """
        L{OMeta.pythonExpr()} can extract a single Python expression from a
        string, ignoring the text following it.
        """
        o = OMetaGrammarBase(expr + "\nbaz = ...\n")
        self.assertEqual(o.pythonExpr()[0][0], expr)


    def test_expressions(self):
        """
        L{OMeta.pythonExpr()} can recognize various paired delimiters properly
        and include newlines in expressions where appropriate.
        """
        self.findInGrammar("x")
        self.findInGrammar("(x + 1)")
        self.findInGrammar("{x: (y)}")
        self.findInGrammar("x, '('")
        self.findInGrammar('x, "("')
        self.findInGrammar('x, """("""')
        self.findInGrammar('(x +\n 1)')
        self.findInGrammar('[x, "]",\n 1]')
        self.findInGrammar('{x: "]",\ny: "["}')

        o = OMetaGrammarBase("foo(x[1]])\nbaz = ...\n")
        self.assertRaises(ParseError, o.pythonExpr)
        o = OMetaGrammarBase("foo(x[1]\nbaz = ...\n")
        self.assertRaises(ParseError, o.pythonExpr)


class MakeGrammarTest(TestCase):
    """
    Test the definition of grammars via the 'makeGrammar' method.
    """


    def test_makeGrammar(self):
        results = []
        grammar = """
        digit = :x ?('0' <= x <= '9') -> int(x)
        num = (num:n digit:d !(results.append(True)) -> n * 10 + d
               | digit)
        """
        TestGrammar = OMeta.makeGrammar(grammar, "G").createParserClass(OMetaBase, {'results':results})
        g = TestGrammar("314159")
        self.assertEqual(g.apply("num")[0], 314159)
        self.assertNotEqual(len(results), 0)


    def test_brokenGrammar(self):
        grammar = """
        andHandler = handler:h1 'and handler:h2 -> And(h1, h2)
        """
        e = self.assertRaises(ParseError, OMeta.makeGrammar, grammar,
                              "Foo")
        self.assertEquals(e.position, 57)
        self.assertEquals(e.error, [("message", "end of input")])


    def test_subclassing(self):
        """
        A subclass of an OMeta subclass should be able to call rules on its
        parent, and access variables in its scope.
        """
        grammar1 = """
        dig = :x ?(a <= x <= b) -> int(x)
        """
        TestGrammar1 = OMeta.makeGrammar(grammar1, "G").createParserClass(OMetaBase, {'a':'0', 'b':'9'})

        grammar2 = """
        num = (num:n dig:d -> n * base + d
                | dig)
        """
        TestGrammar2 = OMeta.makeGrammar(grammar2, "G2").createParserClass(TestGrammar1, {'base':10})
        g = TestGrammar2("314159")
        self.assertEqual(g.apply("num")[0], 314159)

        grammar3 = """
        dig = :x ?(a <= x <= b or c <= x <= d) -> int(x, base)
        """
        TestGrammar3 = OMeta.makeGrammar(grammar3, "G3").createParserClass(
            TestGrammar2, {'c':'a', 'd':'f', 'base':16})
        g = TestGrammar3("abc123")
        self.assertEqual(g.apply("num")[0], 11256099)


    def test_super(self):
        """
        Rules can call the implementation in a superclass.
        """
        grammar1 = "expr = letter"
        TestGrammar1 = OMeta.makeGrammar(grammar1, "G").createParserClass(OMetaBase, {})
        grammar2 = "expr = super | digit"
        TestGrammar2 = OMeta.makeGrammar(grammar2, "G2").createParserClass(TestGrammar1, {})
        self.assertEqual(TestGrammar2("x").apply("expr")[0], "x")
        self.assertEqual(TestGrammar2("3").apply("expr")[0], "3")

    def test_foreign(self):
        """
        Rules can call the implementation in a superclass.
        """
        grammar_letter = "expr = letter"
        GrammarLetter = OMeta.makeGrammar(grammar_letter, "G").createParserClass(OMetaBase, {})

        grammar_digit = "expr '5' = digit"
        GrammarDigit = OMeta.makeGrammar(grammar_digit, "H").createParserClass(OMetaBase, {})

        grammar = ("expr = !(grammar_digit_global):grammar_digit "
                        "grammar_letter.expr | grammar_digit.expr('5')")
        TestGrammar = OMeta.makeGrammar(grammar, "I").createParserClass(
            OMetaBase,
            {"grammar_letter": GrammarLetter,
             "grammar_digit_global": GrammarDigit
         })

        self.assertEqual(TestGrammar("x").apply("expr")[0], "x")
        self.assertEqual(TestGrammar("3").apply("expr")[0], "3")


class HandyInterpWrapper(object):
    """
    Convenient grammar wrapper for parsing strings.
    """
    def __init__(self, interp):
        self._interp = interp


    def __getattr__(self, name):
        """
        Return a function that will instantiate a grammar and invoke the named
        rule.
        @param: Rule name.
        """
        def doIt(s):
            """
            @param s: The string to be parsed by the wrapped grammar.
            """
            # totally cheating
            tree = not isinstance(s, basestring)

            input, ret, err = self._interp.apply(s, name, tree)
            try:
                extra, _ = input.head()
            except EOFError:
                try:
                    return ''.join(ret)
                except TypeError:
                    return ret
            else:
                raise err
        return doIt


class InterpTestCase(OMetaTestCase):

    def compile(self, grammar, globals=None):
        """
        Produce an object capable of parsing via this grammar.

        @param grammar: A string containing an OMeta grammar.
        """
        g = OMeta(grammar)
        tree = g.parseGrammar('TestGrammar')
        g = GrammarInterpreter(tree, OMetaBase, globals)
        return HandyInterpWrapper(g)


class TrampolinedInterpWrapper(object):
    """
    Convenient grammar wrapper for parsing strings.
    """
    def __init__(self, tree, globals):
        self._tree = tree
        self._globals = globals


    def __getattr__(self, name):
        """
        Return a function that will instantiate a grammar and invoke the named
        rule.
        @param: Rule name.
        """
        def doIt(s):
            """
            @param s: The string to be parsed by the wrapped grammar.
            """
            tree = not isinstance(s, basestring)
            if tree:
                pytest.skip("Not applicable for push parsing")
            results = []
            def whenDone(val, err):
                results.append(val)
            parser = TrampolinedGrammarInterpreter(self._tree, name, whenDone,
                                                   self._globals)
            for i, c in enumerate(s):
                assert len(results) == 0
                parser.receive(c)
            parser.end()
            if results and parser.input.position == len(parser.input.data):
                try:
                    return ''.join(results[0])
                except TypeError:
                    return results[0]
            else:
                raise parser.currentError
        return doIt



class TrampolinedInterpreterTestCase(OMetaTestCase):

    def compile(self, grammar, globals=None):
        g = OMeta(grammar)
        tree = g.parseGrammar('TestGrammar')
        return TrampolinedInterpWrapper(tree, globals)


    def test_failure(self):
        g = OMeta("""
           foo = 'a':one baz:two 'd'+ 'e' -> (one, two)
           baz = 'b' | 'c'
           """, {})
        tree = g.parseGrammar('TestGrammar')
        i = TrampolinedGrammarInterpreter(
            tree, 'foo', callback=lambda x: setattr(self, 'result', x))
        e = self.assertRaises(ParseError, i.receive, 'foobar')
        self.assertEqual(str(e),
        "\nfoobar\n^\nParse error at line 1, column 0:"
        " expected the character 'a'. trail: []\n")


    def test_stringConsumedBy(self):
        called = []
        grammarSource = "rule = <'x'+>:y -> y"
        grammar = OMeta(grammarSource).parseGrammar("Parser")
        def interp(result, error):
            called.append(result)
        trampoline = TrampolinedGrammarInterpreter(grammar, "rule", interp)
        trampoline.receive("xxxxx")
        trampoline.end()
        self.assertEqual(called, ["xxxxx"])



class TreeTransformerTestCase(TestCase):

    def compile(self, grammar, namespace=None):
        """
        Produce an object capable of parsing via this grammar.

        @param grammar: A string containing an OMeta grammar.
        """
        if namespace is None:
            namespace = globals()
        g = TreeTransformerGrammar.makeGrammar(
            dedent(grammar), 'TestGrammar').createParserClass(
                TreeTransformerBase, namespace)
        return g

    def test_termForm(self):
        g = self.compile("Foo(:left :right) -> left.data + right.data")
        self.assertEqual(g.transform(term("Foo(1, 2)"))[0], 3)

    def test_termFormNest(self):
        g = self.compile("Foo(:left Baz(:right)) -> left.data + right.data")
        self.assertEqual(g.transform(term("Foo(1, Baz(2))"))[0], 3)

    def test_listForm(self):
        g = self.compile("Foo(:left [:first :second]) -> left.data + first.data + second.data")
        self.assertEqual(g.transform(term("Foo(1, [2, 3])"))[0], 6)

    def test_emptyList(self):
        g = self.compile("Foo([]) -> 6")
        self.assertEqual(g.transform(term("Foo([])"))[0], 6)

    def test_emptyArgs(self):
        g = self.compile("Foo() -> 6")
        self.assertEqual(g.transform(term("Foo()"))[0], 6)

    def test_emptyArgsMeansEmpty(self):
        g = self.compile("""
                         Foo() -> 6
                         Foo(:x) -> x
                         """)
        self.assertEqual(g.transform(term("Foo(3)"))[0].data, 3)

    def test_subTransform(self):
        g = self.compile("""
                         Foo(:left @right) -> left.data + right
                         Baz(:front :back) -> front.data * back.data
                         """)
        self.assertEqual(g.transform(term("Foo(1, Baz(2, 3))"))[0], 7)

    def test_defaultExpand(self):
        g = self.compile("""
                         Foo(:left @right) -> left.data + right
                         Baz(:front :back) -> front.data * back.data
                         """)
        self.assertEqual(g.transform(term("Blee(Foo(1, 2), Baz(2, 3))"))[0],
                         term("Blee(3, 6)"))

    def test_wide_template(self):
        g = self.compile(
            """
            Pair(@left @right) --> $left, $right
            Name(@n) = ?(n == "a") --> foo
                     |             --> baz
            """)
        self.assertEqual(g.transform(term('Pair(Name("a"), Name("b"))'))[0],
                         "foo, baz")

    def test_tall_template(self):
        g = self.compile(
            """
            Name(@n) = ?(n == "a") --> foo
                     |             --> baz
            Pair(@left @right) {{{
            $left
            also, $right
            }}}
            """)
        self.assertEqual(g.transform(term('Pair(Name("a"), Name("b"))'))[0],
                         "foo\nalso, baz")

    def test_tall_template_suite(self):
        g = self.compile(
            """
            Name(@n) -> n
            If(@test @suite) {{{
            if $test:
              $suite
            }}}
            """)
        self.assertEqual(g.transform(term('If(Name("a"), [Name("foo"), Name("baz")])'))[0],
                         "if a:\n  foo\n  baz")

    def test_foreign(self):
        """
        Rules can call the implementation in a superclass.
        """
        grammar_letter = "expr = letter"
        GrammarLetter = self.compile(grammar_letter, {})

        grammar_digit = "expr '5' = digit"
        GrammarDigit = self.compile(grammar_digit, {})

        grammar = ("expr = !(grammar_digit_global):grammar_digit "
                   "GrammarLetter.expr | grammar_digit.expr('5')")
        TestGrammar = self.compile(grammar, {
            "GrammarLetter": GrammarLetter,
            "grammar_digit_global": GrammarDigit
        })

        self.assertEqual(TestGrammar("x").apply("expr")[0], "x")
        self.assertEqual(TestGrammar("3").apply("expr")[0], "3")



class ErrorReportingTests(TestCase):


    def compile(self, grammar):
        """
        Produce an object capable of parsing via this grammar.

        @param grammar: A string containing an OMeta grammar.
        """
        g = OMeta.makeGrammar(grammar, 'TestGrammar').createParserClass(OMetaBase, {})
        return HandyWrapper(g)


    def test_rawReporting(self):
        """
        Errors from parsing contain enough info to figure out what was
        expected and where.
        """
        g = self.compile("""

        start = ( (person feeling target)
                  | (adjective animal feeling token("some") target))
        adjective = token("crazy") | token("clever") | token("awesome")
        feeling = token("likes") | token("loves") | token("hates")
        animal = token("monkey") | token("horse") | token("unicorn")
        person = token("crazy horse") | token("hacker")
        target = (token("bananas") | token("robots") | token("americans")
                   | token("bacon"))
        """)

        #some warmup
        g.start("clever monkey hates some robots")
        g.start("awesome unicorn loves some bacon")
        g.start("crazy horse hates americans")
        g.start("hacker likes robots")

        e = self.assertRaises(ParseError, g.start,
                              "clever hacker likes bacon")
        self.assertEqual(e.position, 8)
        self.assertEqual(e.error, [('expected', "token", "horse")])

        e = self.assertRaises(ParseError, g.start,
                              "crazy horse likes some grass")

        #matching "some" means second branch of 'start' is taken
        self.assertEqual(e.position, 23)
        self.assertEqual(set(e.error),
                set([('expected', "token", "bananas"),
                     ('expected', 'token', "bacon"),
                     ('expected', "token", "robots"),
                     ('expected', "token", "americans")]))

        e = self.assertRaises(ParseError, g.start,
                              "crazy horse likes mountains")

        #no "some" means first branch of 'start' is taken...
        #but second is also viable
        self.assertEqual(e.position, 18)
        self.assertEqual(set(e.error),
                set([('expected', "token", "some"),
                     ('expected', "token", "bananas"),
                     ('expected', 'token', "bacon"),
                     ('expected', "token", "robots"),
                     ('expected', "token", "americans")]))


    def test_formattedReporting(self):
        """
        Parse errors can be formatted into a nice human-readable view
        containing the erroneous input and possible fixes.
        """
        g = self.compile("""
        dig = '1' | '2' | '3'
        bits = <dig>+
        """)

        input = "123x321"
        e = self.assertRaises(ParseError, g.bits, input)
        self.assertEqual(e.formatError(),
                         dedent("""
                         123x321
                            ^
                         Parse error at line 1, column 3: expected one of '1', '2', or '3'. trail: [dig]
                         """))
        input = "foo\nbaz\nboz\ncharlie\nbuz"
        e = ParseError(input, 12, expected('token', 'foo') + expected(None, 'b'))
        self.assertEqual(e.formatError(),
                         dedent("""
                         charlie
                         ^
                         Parse error at line 4, column 0: expected one of 'b', or token 'foo'. trail: []
                         """))

        input = '123x321'
        e = ParseError(input, 3, expected('digit'))
        self.assertEqual(e.formatError(),
                         dedent("""
                         123x321
                            ^
                         Parse error at line 1, column 3: expected a digit. trail: []
                         """))

    def test_customLabels(self):
        """
        Custom labels replace the 'expected' part of the exception.
        """
        g = self.compile("""
        dig = ('1' | '2' | '3') ^ (1 2 or 3)
        bits = <dig>+
        """)

        input = "123x321"
        e = self.assertRaises(ParseError, g.bits, input)
        self.assertEqual(e.formatError(),
                         dedent("""
                         123x321
                            ^
                         Parse error at line 1, column 3: expected a 1 2 or 3. trail: [dig]
                         """))

    def test_customLabelsFormatting(self):
        """
        Custom labels replace the 'expected' part of the exception.
        """

        input = "foo\nbaz\nboz\ncharlie\nbuz"
        label = 'Fizz Buzz'
        e = ParseError(input, 12, None).withMessage([("Custom Exception:", label, None)])
        self.assertEqual(e.formatError(),
                         dedent("""
                         charlie
                         ^
                         Parse error at line 4, column 0: expected a Fizz Buzz. trail: []
                         """))

    def test_eof(self):
        """
        EOF should raise a nice error.
        """
        import parsley
        g = parsley.makeGrammar("""
        dig = '1' | '2' | '3'
        bits = <dig>+
        """, {})

        input = '123x321'
        e = self.assertRaises(ParseError, g(input).dig)
        self.assertEqual(e.formatError(),
                         dedent("""
                         123x321
                          ^
                         Parse error at line 1, column 1: expected EOF. trail: []
                         """))

########NEW FILE########
__FILENAME__ = test_runtime
from ometa.runtime import OMetaBase, ParseError, expected, eof
from ometa.test.helpers import TestCase

class RuntimeTests(TestCase):
    """
    Tests for L{pymeta.runtime}.
    """

    def test_anything(self):
        """
        L{OMetaBase.rule_anything} returns each item from the input
        along with its position.
        """

        data = "foo"
        o = OMetaBase(data)

        for i, c in enumerate(data):
            v, e = o.rule_anything()
            self.assertEqual((c, i), (v, e.args[0]))


    def test_exactly(self):
        """
        L{OMetaBase.rule_exactly} returns the requested item from the input
        string along with its position, if it's there.
        """

        data = "foo"
        o = OMetaBase(data)
        v, e = o.rule_exactly("f")
        self.assertEqual(v, "f")
        self.assertEqual(e.args[0], 0)

    def test_exactly_multi(self):
        """
        L{OMetaBase.rule_exactly} returns the requested item from the input
        string along with its position, if it's there.
        """

        data = "foo"
        o = OMetaBase(data)
        v, e = o.rule_exactly("fo")
        self.assertEqual(v, "fo")
        self.assertEqual(e.args[0], 0)

    def test_exactlyFail(self):
        """
        L{OMetaBase.rule_exactly} raises L{ParseError} when the requested item
        doesn't match the input. The error contains info on what was expected
        and the position.
        """

        data = "foo"
        o = OMetaBase(data)
        exc = self.assertRaises(ParseError, o.rule_exactly, "g")
        self.assertEquals(exc.args[1], expected(None, "g"))
        self.assertEquals(exc.args[0], 0)



    def test_token(self):
        """
        L{OMetaBase.rule_token} matches all the characters in the given string
        plus any preceding whitespace.
        """

        data = "  foo bar"
        o = OMetaBase(data)
        v, e = o.rule_token("foo")
        self.assertEqual(v, "foo")
        self.assertEqual(e.args[0], 4)
        v, e = o.rule_token("bar")
        self.assertEqual(v, "bar")
        self.assertEqual(e.args[0], 8)


    def test_tokenFailed(self):
        """
        On failure, L{OMetaBase.rule_token} produces an error indicating the
        position where match failure occurred and the expected character.
        """
        data = "foozle"
        o = OMetaBase(data)
        exc = self.assertRaises(ParseError, o.rule_token, "fog")
        self.assertEqual(exc.args[0], 2)
        self.assertEqual(exc.args[1], expected("token", "fog"))


    def test_many(self):
        """
        L{OMetaBase.many} returns a list of parsed values and the error that
        caused the end of the loop.
        """

        data = "ooops"
        o  = OMetaBase(data)
        self.assertEqual(o.many(lambda: o.rule_exactly('o')),
                         (['o'] * 3, ParseError(o.input, 3,
                                                expected(None, 'o'))))


    def test_or(self):
        """
        L{OMetaBase._or} returns the result of the first of its
        arguments to succeed.
        """

        data = "a"

        o = OMetaBase(data)
        called = [False, False, False]
        targets = ['b', 'a', 'c']
        matchers = []
        for i, m in enumerate(targets):
            def match(i=i, m=m):
                called[i] = True
                return o.exactly(m)
            matchers.append(match)

        v, e = o._or(matchers)
        self.assertEqual(called, [True, True, False])
        self.assertEqual(v, 'a')
        self.assertEqual(e.args[0], 0)


    def test_orSimpleFailure(self):
        """
        When none of the alternatives passed to L{OMetaBase._or} succeed, the
        one that got the furthest is returned.
        """

        data = "foozle"
        o = OMetaBase(data)

        exc = self.assertRaises(
            ParseError, o._or, [
                lambda: o.token("fog"),
                lambda: o.token("foozik"),
                lambda: o.token("woozle")
            ]
        )
        self.assertEqual(exc.args[0], 4)
        self.assertEqual(exc.args[1], expected("token",  "foozik"))


    def test_orFalseSuccess(self):
        """
        When a failing branch of L{OMetaBase._or} gets further than a
        succeeding one, its error is returned instead of the success branch's.
        """

        data = "foozle"
        o = OMetaBase(data)

        v, e = o._or( [lambda: o.token("fog"),
                               lambda: o.token("foozik"),
                               lambda: o.token("f")])
        self.assertEqual(e.args[0], 4)
        self.assertEqual(e.args[1], expected("token", "foozik"))

    def test_orErrorTie(self):
        """
        When branches of L{OMetaBase._or} produce errors that tie for rightmost
        position, they are merged.
        """

        data = "foozle"
        o = OMetaBase(data)

        v, e = o._or( [lambda: o.token("fog"),
                               lambda: o.token("foz"),
                               lambda: o.token("f")])
        self.assertEqual(e.args[0], 2)
        self.assertEqual(set(e.args[1]),
                set([expected("token", "fog")[0],
                     expected("token", "foz")[0]]))


    def test_notError(self):
        """
        When L{OMetaBase._not} fails, its error contains the current
        input position and no error info.
        """

        data = "xy"
        o = OMetaBase(data)
        exc = self.assertRaises(ParseError, o._not, lambda: o.exactly("x"))
        self.assertEqual(exc.args[0], 1)
        self.assertEqual(exc.args[1], None)


    def test_spaces(self):
        """
        L{OMetaBase.rule_spaces} provides error information.
        """

        data = "  xyz"
        o = OMetaBase(data)
        v, e = o.rule_spaces()

        self.assertEqual(e.args[0], 2)

    def test_predSuccess(self):
        """
        L{OMetaBase.pred} returns True and empty error info on success.
        """

        o = OMetaBase("")
        v, e = o.pred(lambda: (True, ParseError(o.input, 0, None)))
        self.assertEqual((v, e), (True, ParseError(o.input, 0, None)))


    def test_predFailure(self):
        """
        L{OMetaBase.pred} returns True and empty error info on success.
        """

        o = OMetaBase("")
        exc = self.assertRaises(
            ParseError, o.pred, lambda: (False, ParseError(o.input, 0, None)))
        self.assertEqual(exc, ParseError(o.input, 0, None))


    def test_end(self):
        """
        L{OMetaBase.rule_end} matches the end of input and raises L{ParseError}
        if input is left.
        """
        o = OMetaBase("abc")
        exc = self.assertRaises(ParseError, o.rule_end)
        self.assertEqual(exc, ParseError(o.input, 1, None))
        o.many(o.rule_anything)
        self.assertEqual(o.rule_end(), (True, ParseError("abc", 3, None)))

    def test_label(self):
        """
        L{OMetaBase.label} returns a list of parsed values and the error that
        caused the end of the loop.
        """

        data = "ooops"
        label = 'CustomLabel'
        o = OMetaBase(data)
        exc = self.assertRaises(
            ParseError, o.label, lambda: o.rule_exactly('x'), label)
        self.assertEqual(exc,
                         ParseError(o.input, 0, expected(label)).withMessage([("Custom Exception:", label, None)]))

    def test_letter(self):
        """
        L{OMetaBase.rule_letter} matches letters.
        """
        o = OMetaBase("a1")
        v, e = o.rule_letter()
        self.assertEqual((v, e), ("a", ParseError(o.input, 0, None)))
        exc = self.assertRaises(ParseError, o.rule_letter)
        self.assertEqual(exc, ParseError(o.input, 1,
                                                 expected("letter")))


    def test_letterOrDigit(self):
        """
        L{OMetaBase.rule_letterOrDigit} matches alphanumerics.
        """
        o = OMetaBase("a1@")
        v, e = o.rule_letterOrDigit()
        self.assertEqual((v, e), ("a", ParseError(None, 0, None)))
        v, e = o.rule_letterOrDigit()
        self.assertEqual((v, e), ("1", ParseError(None, 1, None)))
        exc = self.assertRaises(ParseError, o.rule_letterOrDigit)
        self.assertEqual(exc,
                         ParseError(o.input, 2, expected("letter or digit")))


    def test_digit(self):
        """
        L{OMetaBase.rule_digit} matches digits.
        """
        o = OMetaBase("1a")
        v, e = o.rule_digit()
        self.assertEqual((v, e), ("1", ParseError("1a", 0, None)))
        exc = self.assertRaises(ParseError, o.rule_digit)
        self.assertEqual(exc, ParseError(o.input, 1, expected("digit")))



    def test_listpattern(self):
        """
        L{OMetaBase.rule_listpattern} matches contents of lists.
        """
        o = OMetaBase([["a"]], tree=True)
        v, e = o.listpattern(lambda: o.exactly("a"))
        self.assertEqual((v, e), (["a"], ParseError("a", 0, None)))

########NEW FILE########
__FILENAME__ = test_tube
from __future__ import absolute_import, unicode_literals

import unittest

from ometa.grammar import OMeta
from ometa.tube import TrampolinedParser


def iterbytes(originalBytes):
    for i in range(len(originalBytes)):
        yield originalBytes[i:i+1]


class TrampolinedReceiver():
    """
    Receive and store the passed in data.
    """

    currentRule = 'initial'

    def __init__(self):
        self.received = []

    def receive(self, data):
        self.received.append(data)


class TrampolinedParserTestCase(unittest.TestCase):
    """
    Tests for L{ometa.tube.TrampolinedParser}
    """

    def _parseGrammar(self, grammar, name="Grammar"):
        return OMeta(grammar).parseGrammar(name)

    def setUp(self):
        _grammar =  r"""
            delimiter = '\r\n'
            initial = <(~delimiter anything)*>:val delimiter -> receiver.receive(val)
            witharg :arg1 :arg2 = <(~delimiter anything)*>:a delimiter -> receiver.receive(arg1+arg2+a)
        """
        self.grammar = self._parseGrammar(_grammar)

    def test_dataNotFullyReceived(self):
        """
        Since the initial rule inside the grammar is not matched, the receiver
        shouldn't receive any byte.
        """
        receiver = TrampolinedReceiver()
        trampolinedParser = TrampolinedParser(self.grammar, receiver, {})
        buf = 'foobarandnotreachdelimiter'
        for c in iterbytes(buf):
            trampolinedParser.receive(c)
        self.assertEqual(receiver.received, [])


    def test_dataFullyReceived(self):
        """
        The receiver should receive the data according to the grammar.
        """
        receiver = TrampolinedReceiver()
        trampolinedParser = TrampolinedParser(self.grammar, receiver, {})
        buf = '\r\n'.join(('foo', 'bar', 'foo', 'bar'))
        for c in iterbytes(buf):
            trampolinedParser.receive(c)
        self.assertEqual(receiver.received, ['foo', 'bar', 'foo'])
        trampolinedParser.receive('\r\n')
        self.assertEqual(receiver.received, ['foo', 'bar', 'foo', 'bar'])


    def test_bindings(self):
        """
        The passed-in bindings should be accessible inside the grammar.
        """
        receiver = TrampolinedReceiver()
        grammar = r"""
            initial = digit:d (-> int(d)+SMALL_INT):val -> receiver.receive(val)
        """
        bindings = {'SMALL_INT': 3}
        TrampolinedParser(self._parseGrammar(grammar), receiver, bindings).receive('0')
        self.assertEqual(receiver.received, [3])


    def test_currentRuleWithArgs(self):
        """
        TrampolinedParser should be able to invoke curruent rule with args.
        """
        receiver = TrampolinedReceiver()
        receiver.currentRule = "witharg", "nice ", "day"
        trampolinedParser = TrampolinedParser(self.grammar, receiver, {})
        buf = ' oh yes\r\n'
        for c in iterbytes(buf):
            trampolinedParser.receive(c)
        self.assertEqual(receiver.received, ["nice day oh yes"])

########NEW FILE########
__FILENAME__ = test_vm_builder
from unittest import TestCase
from terml.nodes import termMaker as t
from ometa.vm_builder import writeBytecode, writeBytecodeRule, writeBytecodeGrammar


class TestVMBuilder(TestCase):
    def test_exactly(self):
        x = t.Exactly("a")
        self.assertEqual(writeBytecode(x),
                         [t.Match("a")])

    def test_apply(self):
        one = t.Action("1")
        x = t.Action("x")
        a = t.Apply("foo", "main", [one, x])
        self.assertEqual(writeBytecode(a),
                         [t.Python('1'),
                          t.Push(),
                          t.Python('x'),
                          t.Push(),
                          t.Call('foo')])

    def test_foreignApply(self):
        one = t.Action("1")
        x = t.Action("x")
        a = t.ForeignApply("thegrammar", "foo", "main", [one, x])
        self.assertEqual(writeBytecode(a),
                         [t.Python('1'),
                          t.Push(),
                          t.Python('x'),
                          t.Push(),
                          t.ForeignCall('thegrammar', 'foo')])

    def test_superApply(self):
        one = t.Action("1")
        x = t.Action("x")
        a = t.Apply("super", "main", [one, x])
        self.assertEqual(writeBytecode(a),
                         [t.Python('1'),
                          t.Push(),
                          t.Python('x'),
                          t.Push(),
                          t.SuperCall('main')])

    def test_many(self):
        xs = t.Many(t.Exactly("x"))
        self.assertEqual(writeBytecode(xs),
                         [t.Choice(3),
                          t.Match("x"),
                          t.Commit(-2)])
        # self.assertEqual(writeBytecode(xs),
        #                  [t.Choice(3),
        #                   t.Match("x"),
        #                   t.PartialCommit(0)])

    def test_many1(self):
        xs = t.Many1(t.Exactly("x"))
        self.assertEqual(writeBytecode(xs),
                         [t.Match('x'),
                          t.Choice(3),
                          t.Match('x'),
                          t.Commit(-2)])

        # self.assertEqual(writeBytecode(xs),
        #                  [t.Match('x'),
        #                   t.Choice(4),
        #                   t.Match('x'),
        #                   t.PartialCommit(1)])

    def test_tripleOr(self):
        xy = t.Or([t.Exactly("x"),
                   t.Exactly("y"),
                   t.Exactly("z")])
        self.assertEqual(writeBytecode(xy),
                         [t.Choice(3),
                          t.Match('x'),
                          t.Commit(5),
                          t.Choice(3),
                          t.Match('y'),
                          t.Commit(2),
                          t.Match('z')])

    def test_doubleOr(self):
        xy = t.Or([t.Exactly("x"),
                   t.Exactly("y")])
        self.assertEqual(writeBytecode(xy),
                         [t.Choice(3),
                          t.Match('x'),
                          t.Commit(2),
                          t.Match('y')])

    def test_singleOr(self):
        x1 = t.Or([t.Exactly("x")])
        x = t.Exactly("x")
        self.assertEqual(writeBytecode(x1),
                         writeBytecode(x))

    def test_optional(self):
        x = t.Optional(t.Exactly("x"))
        self.assertEqual(writeBytecode(x),
                         [t.Choice(3),
                          t.Match('x'),
                          t.Commit(2),
                          t.Python("None")])

    def test_not(self):
        x = t.Not(t.Exactly("x"))
        self.assertEqual(writeBytecode(x),
                         [t.Choice(4),
                          t.Match('x'),
                          t.Commit(1),
                          t.Fail()])

        # self.assertEqual(writeBytecode(x),
        #                  [t.Choice(3),
        #                   t.Match('x'),
        #                   t.FailTwice()])

    def test_lookahead(self):
        x = t.Lookahead(t.Exactly("x"))
        self.assertEqual(writeBytecode(x),
                         [t.Choice(7),
                          t.Choice(4),
                          t.Match('x'),
                          t.Commit(1),
                          t.Fail(),
                          t.Commit(1),
                          t.Fail()])

        # self.assertEqual(writeBytecode(x),
        #                  [t.Choice(5),
        #                   t.Choice(2),
        #                   t.Match('x'),
        #                   t.Commit(1),
        #                   t.Fail()])

    def test_sequence(self):
        x = t.Exactly("x")
        y = t.Exactly("y")
        z = t.And([x, y])
        self.assertEqual(writeBytecode(z),
                         [t.Match('x'),
                          t.Match('y')])

    def test_bind(self):
        x = t.Exactly("x")
        b = t.Bind("var", x)
        self.assertEqual(writeBytecode(b),
                         [t.Match('x'),
                          t.Bind('var')])

    def test_bind_apply(self):
        x = t.Apply("members", "object", [])
        b = t.Bind("m", x)
        self.assertEqual(writeBytecode(b),
                         [t.Call('members'),
                          t.Bind('m')])

    def test_pred(self):
        x = t.Predicate(t.Action("doStuff()"))
        self.assertEqual(writeBytecode(x),
                         [t.Python('doStuff()'),
                          t.Predicate()])

    def test_listpattern(self):
        x = t.List(t.Exactly("x"))
        self.assertEqual(writeBytecode(x),
                         [t.Descend(),
                          t.Match('x'),
                          t.Ascend()])

    def test_rule(self):
        x = t.Rule("foo", t.Exactly("x"))
        k, v = writeBytecodeRule(x)
        self.assertEqual(k, "foo")
        self.assertEqual(v, [t.Match('x')])

    def test_grammar(self):
        r1 = t.Rule("foo", t.Exactly("x"))
        r2 = t.Rule("baz", t.Exactly("y"))
        x = t.Grammar("BuilderTest", False, [r1, r2])
        g = writeBytecodeGrammar(x)
        self.assertEqual(sorted(g.keys()), ['baz', 'foo'])
        self.assertEqual(g['foo'], [t.Match('x')])
        self.assertEqual(g['baz'], [t.Match('y')])

    def test_repeat(self):
        x = t.Repeat(3, 4, t.Exactly('x'))
        self.assertEqual(writeBytecode(x),
                         [t.Python("3"),
                          t.Push(),
                          t.Python("4"),
                          t.Push(),
                          t.RepeatChoice(3),
                          t.Match('x'),
                          t.Commit(-2)])

    def test_consumedby(self):
        x = t.ConsumedBy(t.Exactly('x'))
        self.assertEqual(writeBytecode(x),
                         [t.StartSlice(),
                          t.Match('x'),
                          t.EndSlice()])

########NEW FILE########
__FILENAME__ = tube
from ometa.interp import TrampolinedGrammarInterpreter, _feed_me

class TrampolinedParser:
    """
    A parser that incrementally parses incoming data.
    """
    def __init__(self, grammar, receiver, bindings):
        """
        Initializes the parser.

        @param grammar: The grammar used to parse the incoming data.
        @param receiver: Responsible for logic operation on the parsed data.
            Typically, the logic operation will be invoked inside the grammar,
            e.g., rule = expr1 expr2 (-> receiver.doSomeStuff())
        @param bindings: The namespace that can be accessed inside the grammar.
        """
        self.grammar = grammar
        self.bindings = dict(bindings)
        self.bindings['receiver'] = self.receiver = receiver
        self._setupInterp()


    def _setupInterp(self):
        """
        Resets the parser. The parser will begin parsing with the rule named
        'initial'.
        """
        self._interp = TrampolinedGrammarInterpreter(
            grammar=self.grammar, rule=self.receiver.currentRule,
            callback=None, globals=self.bindings)


    def receive(self, data):
        """
        Receive the incoming data and begin parsing. The parser will parse the
        data incrementally according to the 'initial' rule in the grammar.

        @param data: The raw data received.
        """
        while data:
            status = self._interp.receive(data)
            if status is _feed_me:
                return
            data = ''.join(self._interp.input.data[self._interp.input.position:])
            self._setupInterp()

########NEW FILE########
__FILENAME__ = vm_builder
import os
try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

from terml.nodes import Term, coerceToTerm, termMaker as t

HERE = os.path.dirname(__file__)

def writeBytecode(expr):
    print("Gonna compile %s" % (expr,))
    from ometa.grammar import TreeTransformerGrammar
    from ometa.runtime import TreeTransformerBase
    path = os.path.join(HERE, 'vm.parsley')
    Compiler = TreeTransformerGrammar.makeGrammar(open(path).read(),
            "Compiler").createParserClass(TreeTransformerBase, {"t": t})
    return Compiler.transform(expr)[0]


def bytecodeToPython(expr):
    print("Gonna emit %s" % (expr,))
    from ometa.grammar import TreeTransformerGrammar
    from ometa.runtime import TreeTransformerBase
    Emitter = TreeTransformerGrammar.makeGrammar(open("ometa/vm_emit.parsley").read(),
            "Emitter").createParserClass(TreeTransformerBase, {"t": t})
    return Emitter.transform(expr)[0]


def writeBytecodeRule(expr):
    e = GrammarEmitter()
    p = PythonWriter(expr)
    p.output(e)
    return list(e.rules.items())[0]


def writeBytecodeGrammar(expr):
    e = GrammarEmitter()
    p = PythonWriter(expr)
    p.output(e)
    return e.rules


class GrammarEmitter(object):
    def __init__(self):
        self.rules = {}
        self.tree = False

    def emitterForRule(self, name):
        e = Emitter()
        self.rules[name] = e.instrs
        return e


class Emitter(object):

    def __init__(self):
        self.instrs = []

    def emit(self, i, label=None):
        self.instrs.append(i)
        if label is not None:
            self.backpatch(label, len(self.instrs) - 1)
        return len(self.instrs) - 1

    def backpatch(self, fromIdx, toIdx):
        old = self.instrs[fromIdx]
        self.instrs[fromIdx] = Term(old.tag, None, [coerceToTerm(toIdx)])

    def patchNext(self, target):
        self.backpatch(target, len(self.instrs))


class PythonWriter(object):
    """
    Converts an OMeta syntax tree into Python source.
    """
    def __init__(self, tree):
        self.tree = tree

    def output(self, out):
        self._generateNode(out, self.tree)

    def _generateNode(self, out, node, debugname=None):
        name = node.tag.name
        args = node.args
        if node.data is not None:
            out.emit(t.Literal(node.data))
            return
        if name == 'null':
            out.emit(t.Python("None"))
        return getattr(self, "generate_"+name)(out, *args, debugname=debugname)

    def generate_Rule(self, out, name, expr, debugname=None):
        e = out.emitterForRule(name.data)
        self._generateNode(e, expr, name.data)

    def generate_Grammar(self, out, name, takesTreeInput, rules,
                         debugname=None):
        for rule in rules.args:
            self._generateNode(out, rule, debugname)
        out.tree = takesTreeInput

    def generate_Apply(self, out, ruleName, codeName, rawArgs, debugname=None):
        for arg in rawArgs.args:
            self._generateNode(out, arg, debugname)
            out.emit(t.Push())
        if ruleName.data == "super":
            out.emit(t.SuperCall(codeName))
        else:
            out.emit(t.Call(ruleName))

    def generate_ForeignApply(self, out, grammarName, ruleName, codeName,
                              rawArgs, debugname=None):
        for arg in rawArgs.args:
            self._generateNode(out, arg, debugname)
            out.emit(t.Push())
        out.emit(t.ForeignCall(grammarName, ruleName))

    def generate_Exactly(self, out, literal, debugname=None):
        out.emit(t.Match(literal.data))

    def generate_Token(self, out, literal, debugname=None):
        self.generate_Exactly(out, literal)

    def generate_Many(self, out, expr, debugname=None):
        L = out.emit(t.Choice())
        self._generateNode(out, expr, debugname)
        L2 = out.emit(t.Commit())
        out.patchNext(L)
        out.backpatch(L2, L)

    def generate_Many1(self, out, expr, debugname=None):
        self._generateNode(out, expr, debugname)
        self.generate_Many(out, expr, debugname)

    def generate_Repeat(self, out, min, max, expr, debugname=None):
        out.emit(t.Python(str(min.data)))
        out.emit(t.Push())
        out.emit(t.Python(str(max.data)))
        out.emit(t.Push())
        L = out.emit(t.RepeatChoice())
        self._generateNode(out, expr, debugname)
        L2 = out.emit(t.Commit())
        out.patchNext(L)
        out.backpatch(L2, L)

    def generate_Optional(self, out, expr, debugname=None):
        """
        Try to parse an expr and continue if it fails.
        """
        L = out.emit(t.Choice())
        self._generateNode(out, expr, debugname)
        L2 = out.emit(t.Commit())
        out.emit(t.Python("None"), label=L)
        out.patchNext(L2)

    def generate_Or(self, out, exprs, debugname=None):
        if len(exprs.args) == 1:
            self._generateNode(out, exprs.args[0])
            return
        L = None
        lcs = []
        for ex in exprs.args[:-1]:
            L = out.emit(t.Choice(), label=L)
            self._generateNode(out, ex)
            lcs.append(out.emit(t.Commit()))
        out.patchNext(L)
        self._generateNode(out, exprs.args[-1])
        for LC in lcs:
            out.patchNext(LC)

    def generate_Not(self, out, expr, debugname=None):
        L1 = out.emit(t.Choice())
        self._generateNode(out, expr)
        L2 = out.emit(t.Commit())
        out.emit(t.Fail(), label=L1)
        out.patchNext(L2)

    def generate_Lookahead(self, out, expr, debugname=None):
        L1 = out.emit(t.Choice())
        L2 = out.emit(t.Choice())
        self._generateNode(out, expr)
        L3 = out.emit(t.Commit(), label=L2)
        out.emit(t.Fail(), label=L3)
        out.patchNext(L1)

    def generate_And(self, out, exprs, debugname=None):
        for ex in exprs.args:
            self._generateNode(out, ex)

    def generate_Bind(self, out, name, expr, debugname=None):
        self._generateNode(out, expr)
        out.emit(t.Bind(name))

    def generate_Predicate(self, out, expr, debugname=None):
        self._generateNode(out, expr)
        out.emit(t.Predicate())

    def generate_Action(self, out, expr, debugname=None):
        out.emit(t.Python(expr.data))

    def generate_Python(self, out, expr, debugname=None):
        out.emit(t.Python(expr.data))

    def generate_List(self, out, expr, debugname=None):
        out.emit(t.Descend())
        self._generateNode(out, expr)
        out.emit(t.Ascend())

    def generate_TermPattern(self, out, name, expr, debugname=None):
        raise NotImplementedError()

    def generate_StringTemplate(self, out, template, debugname=None):
        raise NotImplementedError()

    def generate_ConsumedBy(self, out, expr, debugname=None):
        out.emit(t.StartSlice())
        self._generateNode(out, expr, debugname)
        out.emit(t.EndSlice())

########NEW FILE########
__FILENAME__ = parsley
def createParserClass(GrammarBase, ruleGlobals):
    if ruleGlobals is None:
        ruleGlobals = {}
    class parsley(GrammarBase):
        def rule_comment(self):
            _locals = {'self': self}
            self.locals['comment'] = _locals
            self._trace(" '#'", (9, 13), self.input.position)
            _G_exactly_1, lastError = self.exactly('#')
            self.considerError(lastError, 'comment')
            def _G_many_2():
                def _G_not_3():
                    self._trace("'\\n'", (16, 20), self.input.position)
                    _G_exactly_4, lastError = self.exactly('\n')
                    self.considerError(lastError, None)
                    return (_G_exactly_4, self.currentError)
                _G_not_5, lastError = self._not(_G_not_3)
                self.considerError(lastError, None)
                self._trace(' anything', (20, 29), self.input.position)
                _G_apply_6, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                return (_G_apply_6, self.currentError)
            _G_many_7, lastError = self.many(_G_many_2)
            self.considerError(lastError, 'comment')
            return (_G_many_7, self.currentError)


        def rule_hspace(self):
            _locals = {'self': self}
            self.locals['hspace'] = _locals
            def _G_or_8():
                self._trace(" ' '", (40, 44), self.input.position)
                _G_exactly_9, lastError = self.exactly(' ')
                self.considerError(lastError, None)
                return (_G_exactly_9, self.currentError)
            def _G_or_10():
                self._trace(" '\\t'", (46, 51), self.input.position)
                _G_exactly_11, lastError = self.exactly('\t')
                self.considerError(lastError, None)
                return (_G_exactly_11, self.currentError)
            def _G_or_12():
                self._trace(' comment', (53, 61), self.input.position)
                _G_apply_13, lastError = self._apply(self.rule_comment, "comment", [])
                self.considerError(lastError, None)
                return (_G_apply_13, self.currentError)
            _G_or_14, lastError = self._or([_G_or_8, _G_or_10, _G_or_12])
            self.considerError(lastError, 'hspace')
            return (_G_or_14, self.currentError)


        def rule_vspace(self):
            _locals = {'self': self}
            self.locals['vspace'] = _locals
            def _G_or_15():
                self._trace("  '\\r\\n'", (70, 78), self.input.position)
                _G_exactly_16, lastError = self.exactly('\r\n')
                self.considerError(lastError, None)
                return (_G_exactly_16, self.currentError)
            def _G_or_17():
                self._trace(" '\\r'", (80, 85), self.input.position)
                _G_exactly_18, lastError = self.exactly('\r')
                self.considerError(lastError, None)
                return (_G_exactly_18, self.currentError)
            def _G_or_19():
                self._trace(" '\\n'", (87, 92), self.input.position)
                _G_exactly_20, lastError = self.exactly('\n')
                self.considerError(lastError, None)
                return (_G_exactly_20, self.currentError)
            _G_or_21, lastError = self._or([_G_or_15, _G_or_17, _G_or_19])
            self.considerError(lastError, 'vspace')
            return (_G_or_21, self.currentError)


        def rule_ws(self):
            _locals = {'self': self}
            self.locals['ws'] = _locals
            def _G_many_22():
                def _G_or_23():
                    self._trace('hspace', (99, 105), self.input.position)
                    _G_apply_24, lastError = self._apply(self.rule_hspace, "hspace", [])
                    self.considerError(lastError, None)
                    return (_G_apply_24, self.currentError)
                def _G_or_25():
                    self._trace(' vspace', (107, 114), self.input.position)
                    _G_apply_26, lastError = self._apply(self.rule_vspace, "vspace", [])
                    self.considerError(lastError, None)
                    return (_G_apply_26, self.currentError)
                def _G_or_27():
                    self._trace(' comment', (116, 124), self.input.position)
                    _G_apply_28, lastError = self._apply(self.rule_comment, "comment", [])
                    self.considerError(lastError, None)
                    return (_G_apply_28, self.currentError)
                _G_or_29, lastError = self._or([_G_or_23, _G_or_25, _G_or_27])
                self.considerError(lastError, None)
                return (_G_or_29, self.currentError)
            _G_many_30, lastError = self.many(_G_many_22)
            self.considerError(lastError, 'ws')
            return (_G_many_30, self.currentError)


        def rule_emptyline(self):
            _locals = {'self': self}
            self.locals['emptyline'] = _locals
            def _G_many_31():
                self._trace(' hspace', (139, 146), self.input.position)
                _G_apply_32, lastError = self._apply(self.rule_hspace, "hspace", [])
                self.considerError(lastError, None)
                return (_G_apply_32, self.currentError)
            _G_many_33, lastError = self.many(_G_many_31)
            self.considerError(lastError, 'emptyline')
            self._trace(' vspace', (147, 154), self.input.position)
            _G_apply_34, lastError = self._apply(self.rule_vspace, "vspace", [])
            self.considerError(lastError, 'emptyline')
            return (_G_apply_34, self.currentError)


        def rule_indentation(self):
            _locals = {'self': self}
            self.locals['indentation'] = _locals
            def _G_many_35():
                self._trace(' emptyline', (168, 178), self.input.position)
                _G_apply_36, lastError = self._apply(self.rule_emptyline, "emptyline", [])
                self.considerError(lastError, None)
                return (_G_apply_36, self.currentError)
            _G_many_37, lastError = self.many(_G_many_35)
            self.considerError(lastError, 'indentation')
            def _G_many1_38():
                self._trace(' hspace', (179, 186), self.input.position)
                _G_apply_39, lastError = self._apply(self.rule_hspace, "hspace", [])
                self.considerError(lastError, None)
                return (_G_apply_39, self.currentError)
            _G_many1_40, lastError = self.many(_G_many1_38, _G_many1_38())
            self.considerError(lastError, 'indentation')
            return (_G_many1_40, self.currentError)


        def rule_noindentation(self):
            _locals = {'self': self}
            self.locals['noindentation'] = _locals
            def _G_many_41():
                self._trace(' emptyline', (203, 213), self.input.position)
                _G_apply_42, lastError = self._apply(self.rule_emptyline, "emptyline", [])
                self.considerError(lastError, None)
                return (_G_apply_42, self.currentError)
            _G_many_43, lastError = self.many(_G_many_41)
            self.considerError(lastError, 'noindentation')
            def _G_lookahead_44():
                def _G_not_45():
                    self._trace('hspace', (218, 224), self.input.position)
                    _G_apply_46, lastError = self._apply(self.rule_hspace, "hspace", [])
                    self.considerError(lastError, None)
                    return (_G_apply_46, self.currentError)
                _G_not_47, lastError = self._not(_G_not_45)
                self.considerError(lastError, None)
                return (_G_not_47, self.currentError)
            _G_lookahead_48, lastError = self.lookahead(_G_lookahead_44)
            self.considerError(lastError, 'noindentation')
            return (_G_lookahead_48, self.currentError)


        def rule_number(self):
            _locals = {'self': self}
            self.locals['number'] = _locals
            self._trace(' ws', (234, 237), self.input.position)
            _G_apply_49, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'number')
            def _G_or_50():
                self._trace("'-'", (254, 257), self.input.position)
                _G_exactly_51, lastError = self.exactly('-')
                self.considerError(lastError, None)
                self._trace(' barenumber', (257, 268), self.input.position)
                _G_apply_52, lastError = self._apply(self.rule_barenumber, "barenumber", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_52
                _G_python_53, lastError = eval('t.Exactly(-x, span=self.getSpan())', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_53, self.currentError)
            def _G_or_54():
                self._trace('barenumber', (331, 341), self.input.position)
                _G_apply_55, lastError = self._apply(self.rule_barenumber, "barenumber", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_55
                _G_python_56, lastError = eval('t.Exactly(x, span=self.getSpan())', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_56, self.currentError)
            _G_or_57, lastError = self._or([_G_or_50, _G_or_54])
            self.considerError(lastError, 'number')
            return (_G_or_57, self.currentError)


        def rule_barenumber(self):
            _locals = {'self': self}
            self.locals['barenumber'] = _locals
            def _G_or_58():
                self._trace(" '0'", (394, 398), self.input.position)
                _G_exactly_59, lastError = self.exactly('0')
                self.considerError(lastError, None)
                def _G_or_60():
                    def _G_or_61():
                        self._trace("'x'", (401, 404), self.input.position)
                        _G_exactly_62, lastError = self.exactly('x')
                        self.considerError(lastError, None)
                        return (_G_exactly_62, self.currentError)
                    def _G_or_63():
                        self._trace("'X'", (405, 408), self.input.position)
                        _G_exactly_64, lastError = self.exactly('X')
                        self.considerError(lastError, None)
                        return (_G_exactly_64, self.currentError)
                    _G_or_65, lastError = self._or([_G_or_61, _G_or_63])
                    self.considerError(lastError, None)
                    def _G_consumedby_66():
                        def _G_many1_67():
                            self._trace('hexdigit', (411, 419), self.input.position)
                            _G_apply_68, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                            self.considerError(lastError, None)
                            return (_G_apply_68, self.currentError)
                        _G_many1_69, lastError = self.many(_G_many1_67, _G_many1_67())
                        self.considerError(lastError, None)
                        return (_G_many1_69, self.currentError)
                    _G_consumedby_70, lastError = self.consumedby(_G_consumedby_66)
                    self.considerError(lastError, None)
                    _locals['hs'] = _G_consumedby_70
                    _G_python_71, lastError = eval('int(hs, 16)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_71, self.currentError)
                def _G_or_72():
                    def _G_consumedby_73():
                        def _G_many1_74():
                            self._trace('octaldigit', (462, 472), self.input.position)
                            _G_apply_75, lastError = self._apply(self.rule_octaldigit, "octaldigit", [])
                            self.considerError(lastError, None)
                            return (_G_apply_75, self.currentError)
                        _G_many1_76, lastError = self.many(_G_many1_74, _G_many1_74())
                        self.considerError(lastError, None)
                        return (_G_many1_76, self.currentError)
                    _G_consumedby_77, lastError = self.consumedby(_G_consumedby_73)
                    self.considerError(lastError, None)
                    _locals['ds'] = _G_consumedby_77
                    _G_python_78, lastError = eval('int(ds, 8)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_78, self.currentError)
                _G_or_79, lastError = self._or([_G_or_60, _G_or_72])
                self.considerError(lastError, None)
                return (_G_or_79, self.currentError)
            def _G_or_80():
                def _G_consumedby_81():
                    def _G_many1_82():
                        self._trace('digit', (510, 515), self.input.position)
                        _G_apply_83, lastError = self._apply(self.rule_digit, "digit", [])
                        self.considerError(lastError, None)
                        return (_G_apply_83, self.currentError)
                    _G_many1_84, lastError = self.many(_G_many1_82, _G_many1_82())
                    self.considerError(lastError, None)
                    return (_G_many1_84, self.currentError)
                _G_consumedby_85, lastError = self.consumedby(_G_consumedby_81)
                self.considerError(lastError, None)
                _locals['ds'] = _G_consumedby_85
                _G_python_86, lastError = eval('int(ds)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_86, self.currentError)
            _G_or_87, lastError = self._or([_G_or_58, _G_or_80])
            self.considerError(lastError, 'barenumber')
            return (_G_or_87, self.currentError)


        def rule_octaldigit(self):
            _locals = {'self': self}
            self.locals['octaldigit'] = _locals
            _G_apply_88, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'octaldigit')
            _locals['x'] = _G_apply_88
            def _G_pred_89():
                _G_python_90, lastError = eval("x in '01234567'", self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_90, self.currentError)
            _G_pred_91, lastError = self.pred(_G_pred_89)
            self.considerError(lastError, 'octaldigit')
            _G_python_92, lastError = eval('x', self.globals, _locals), None
            self.considerError(lastError, 'octaldigit')
            return (_G_python_92, self.currentError)


        def rule_hexdigit(self):
            _locals = {'self': self}
            self.locals['hexdigit'] = _locals
            _G_apply_93, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'hexdigit')
            _locals['x'] = _G_apply_93
            def _G_pred_94():
                _G_python_95, lastError = eval("x in '0123456789ABCDEFabcdef'", self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_95, self.currentError)
            _G_pred_96, lastError = self.pred(_G_pred_94)
            self.considerError(lastError, 'hexdigit')
            _G_python_97, lastError = eval('x', self.globals, _locals), None
            self.considerError(lastError, 'hexdigit')
            return (_G_python_97, self.currentError)


        def rule_escapedChar(self):
            _locals = {'self': self}
            self.locals['escapedChar'] = _locals
            self._trace(" '\\\\'", (639, 644), self.input.position)
            _G_exactly_98, lastError = self.exactly('\\')
            self.considerError(lastError, 'escapedChar')
            def _G_or_99():
                self._trace("'n'", (646, 649), self.input.position)
                _G_exactly_100, lastError = self.exactly('n')
                self.considerError(lastError, None)
                _G_python_101, lastError = ("\n"), None
                self.considerError(lastError, None)
                return (_G_python_101, self.currentError)
            def _G_or_102():
                self._trace("'r'", (680, 683), self.input.position)
                _G_exactly_103, lastError = self.exactly('r')
                self.considerError(lastError, None)
                _G_python_104, lastError = ("\r"), None
                self.considerError(lastError, None)
                return (_G_python_104, self.currentError)
            def _G_or_105():
                self._trace("'t'", (714, 717), self.input.position)
                _G_exactly_106, lastError = self.exactly('t')
                self.considerError(lastError, None)
                _G_python_107, lastError = ("\t"), None
                self.considerError(lastError, None)
                return (_G_python_107, self.currentError)
            def _G_or_108():
                self._trace("'b'", (748, 751), self.input.position)
                _G_exactly_109, lastError = self.exactly('b')
                self.considerError(lastError, None)
                _G_python_110, lastError = ("\b"), None
                self.considerError(lastError, None)
                return (_G_python_110, self.currentError)
            def _G_or_111():
                self._trace("'f'", (782, 785), self.input.position)
                _G_exactly_112, lastError = self.exactly('f')
                self.considerError(lastError, None)
                _G_python_113, lastError = ("\f"), None
                self.considerError(lastError, None)
                return (_G_python_113, self.currentError)
            def _G_or_114():
                self._trace('\'"\'', (816, 819), self.input.position)
                _G_exactly_115, lastError = self.exactly('"')
                self.considerError(lastError, None)
                _G_python_116, lastError = ('"'), None
                self.considerError(lastError, None)
                return (_G_python_116, self.currentError)
            def _G_or_117():
                self._trace("'\\''", (849, 853), self.input.position)
                _G_exactly_118, lastError = self.exactly("'")
                self.considerError(lastError, None)
                _G_python_119, lastError = ("'"), None
                self.considerError(lastError, None)
                return (_G_python_119, self.currentError)
            def _G_or_120():
                self._trace("'x'", (883, 886), self.input.position)
                _G_exactly_121, lastError = self.exactly('x')
                self.considerError(lastError, None)
                def _G_consumedby_122():
                    self._trace('hexdigit', (888, 896), self.input.position)
                    _G_apply_123, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    self._trace(' hexdigit', (896, 905), self.input.position)
                    _G_apply_124, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    return (_G_apply_124, self.currentError)
                _G_consumedby_125, lastError = self.consumedby(_G_consumedby_122)
                self.considerError(lastError, None)
                _locals['d'] = _G_consumedby_125
                _G_python_126, lastError = eval('chr(int(d, 16))', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_126, self.currentError)
            def _G_or_127():
                self._trace("'\\\\'", (950, 954), self.input.position)
                _G_exactly_128, lastError = self.exactly('\\')
                self.considerError(lastError, None)
                _G_python_129, lastError = ("\\"), None
                self.considerError(lastError, None)
                return (_G_python_129, self.currentError)
            _G_or_130, lastError = self._or([_G_or_99, _G_or_102, _G_or_105, _G_or_108, _G_or_111, _G_or_114, _G_or_117, _G_or_120, _G_or_127])
            self.considerError(lastError, 'escapedChar')
            return (_G_or_130, self.currentError)


        def rule_character(self):
            _locals = {'self': self}
            self.locals['character'] = _locals
            self._trace(' ws', (976, 979), self.input.position)
            _G_apply_131, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'character')
            self._trace(" '\\''", (979, 984), self.input.position)
            _G_exactly_132, lastError = self.exactly("'")
            self.considerError(lastError, 'character')
            def _G_many1_133():
                def _G_not_134():
                    self._trace("'\\''", (987, 991), self.input.position)
                    _G_exactly_135, lastError = self.exactly("'")
                    self.considerError(lastError, None)
                    return (_G_exactly_135, self.currentError)
                _G_not_136, lastError = self._not(_G_not_134)
                self.considerError(lastError, None)
                def _G_or_137():
                    self._trace('escapedChar', (993, 1004), self.input.position)
                    _G_apply_138, lastError = self._apply(self.rule_escapedChar, "escapedChar", [])
                    self.considerError(lastError, None)
                    return (_G_apply_138, self.currentError)
                def _G_or_139():
                    self._trace(' anything', (1006, 1015), self.input.position)
                    _G_apply_140, lastError = self._apply(self.rule_anything, "anything", [])
                    self.considerError(lastError, None)
                    return (_G_apply_140, self.currentError)
                _G_or_141, lastError = self._or([_G_or_137, _G_or_139])
                self.considerError(lastError, None)
                return (_G_or_141, self.currentError)
            _G_many1_142, lastError = self.many(_G_many1_133, _G_many1_133())
            self.considerError(lastError, 'character')
            _locals['c'] = _G_many1_142
            self._trace('\n            ws', (1020, 1035), self.input.position)
            _G_apply_143, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'character')
            self._trace(" '\\''", (1035, 1040), self.input.position)
            _G_exactly_144, lastError = self.exactly("'")
            self.considerError(lastError, 'character')
            _G_python_145, lastError = eval("t.Exactly(''.join(c), span=self.getSpan())", self.globals, _locals), None
            self.considerError(lastError, 'character')
            return (_G_python_145, self.currentError)


        def rule_string(self):
            _locals = {'self': self}
            self.locals['string'] = _locals
            self._trace(' ws', (1096, 1099), self.input.position)
            _G_apply_146, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'string')
            self._trace(' \'"\'', (1099, 1103), self.input.position)
            _G_exactly_147, lastError = self.exactly('"')
            self.considerError(lastError, 'string')
            def _G_many_148():
                def _G_or_149():
                    self._trace('escapedChar', (1105, 1116), self.input.position)
                    _G_apply_150, lastError = self._apply(self.rule_escapedChar, "escapedChar", [])
                    self.considerError(lastError, None)
                    return (_G_apply_150, self.currentError)
                def _G_or_151():
                    def _G_not_152():
                        self._trace('\'"\'', (1121, 1124), self.input.position)
                        _G_exactly_153, lastError = self.exactly('"')
                        self.considerError(lastError, None)
                        return (_G_exactly_153, self.currentError)
                    _G_not_154, lastError = self._not(_G_not_152)
                    self.considerError(lastError, None)
                    self._trace(' anything', (1125, 1134), self.input.position)
                    _G_apply_155, lastError = self._apply(self.rule_anything, "anything", [])
                    self.considerError(lastError, None)
                    return (_G_apply_155, self.currentError)
                _G_or_156, lastError = self._or([_G_or_149, _G_or_151])
                self.considerError(lastError, None)
                return (_G_or_156, self.currentError)
            _G_many_157, lastError = self.many(_G_many_148)
            self.considerError(lastError, 'string')
            _locals['c'] = _G_many_157
            self._trace('\n         ws', (1138, 1150), self.input.position)
            _G_apply_158, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'string')
            self._trace(' \'"\'', (1150, 1154), self.input.position)
            _G_exactly_159, lastError = self.exactly('"')
            self.considerError(lastError, 'string')
            _G_python_160, lastError = eval("t.Token(''.join(c), span=self.getSpan())", self.globals, _locals), None
            self.considerError(lastError, 'string')
            return (_G_python_160, self.currentError)


        def rule_name(self):
            _locals = {'self': self}
            self.locals['name'] = _locals
            def _G_consumedby_161():
                self._trace('letter', (1208, 1214), self.input.position)
                _G_apply_162, lastError = self._apply(self.rule_letter, "letter", [])
                self.considerError(lastError, None)
                def _G_many_163():
                    def _G_or_164():
                        self._trace("'_'", (1216, 1219), self.input.position)
                        _G_exactly_165, lastError = self.exactly('_')
                        self.considerError(lastError, None)
                        return (_G_exactly_165, self.currentError)
                    def _G_or_166():
                        self._trace('letterOrDigit', (1221, 1234), self.input.position)
                        _G_apply_167, lastError = self._apply(self.rule_letterOrDigit, "letterOrDigit", [])
                        self.considerError(lastError, None)
                        return (_G_apply_167, self.currentError)
                    _G_or_168, lastError = self._or([_G_or_164, _G_or_166])
                    self.considerError(lastError, None)
                    return (_G_or_168, self.currentError)
                _G_many_169, lastError = self.many(_G_many_163)
                self.considerError(lastError, None)
                return (_G_many_169, self.currentError)
            _G_consumedby_170, lastError = self.consumedby(_G_consumedby_161)
            self.considerError(lastError, 'name')
            return (_G_consumedby_170, self.currentError)


        def rule_args(self):
            _locals = {'self': self}
            self.locals['args'] = _locals
            def _G_or_171():
                self._trace("'('", (1247, 1250), self.input.position)
                _G_exactly_172, lastError = self.exactly('(')
                self.considerError(lastError, None)
                _G_python_173, lastError = eval("self.applicationArgs(finalChar=')')", self.globals, _locals), None
                self.considerError(lastError, None)
                _locals['args'] = _G_python_173
                self._trace(" ')'", (1294, 1298), self.input.position)
                _G_exactly_174, lastError = self.exactly(')')
                self.considerError(lastError, None)
                _G_python_175, lastError = eval('args', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_175, self.currentError)
            def _G_or_176():
                _G_python_177, lastError = ([]), None
                self.considerError(lastError, None)
                return (_G_python_177, self.currentError)
            _G_or_178, lastError = self._or([_G_or_171, _G_or_176])
            self.considerError(lastError, 'args')
            return (_G_or_178, self.currentError)


        def rule_application(self):
            _locals = {'self': self}
            self.locals['application'] = _locals
            def _G_optional_179():
                self._trace(' indentation', (1352, 1364), self.input.position)
                _G_apply_180, lastError = self._apply(self.rule_indentation, "indentation", [])
                self.considerError(lastError, None)
                return (_G_apply_180, self.currentError)
            def _G_optional_181():
                return (None, self.input.nullError())
            _G_or_182, lastError = self._or([_G_optional_179, _G_optional_181])
            self.considerError(lastError, 'application')
            self._trace(' name', (1365, 1370), self.input.position)
            _G_apply_183, lastError = self._apply(self.rule_name, "name", [])
            self.considerError(lastError, 'application')
            _locals['name'] = _G_apply_183
            self._trace(' args', (1375, 1380), self.input.position)
            _G_apply_184, lastError = self._apply(self.rule_args, "args", [])
            self.considerError(lastError, 'application')
            _locals['args'] = _G_apply_184
            _G_python_185, lastError = eval('t.Apply(name, self.rulename, args, span=self.getSpan())', self.globals, _locals), None
            self.considerError(lastError, 'application')
            return (_G_python_185, self.currentError)


        def rule_foreignApply(self):
            _locals = {'self': self}
            self.locals['foreignApply'] = _locals
            def _G_optional_186():
                self._trace(' indentation', (1476, 1488), self.input.position)
                _G_apply_187, lastError = self._apply(self.rule_indentation, "indentation", [])
                self.considerError(lastError, None)
                return (_G_apply_187, self.currentError)
            def _G_optional_188():
                return (None, self.input.nullError())
            _G_or_189, lastError = self._or([_G_optional_186, _G_optional_188])
            self.considerError(lastError, 'foreignApply')
            self._trace(' name', (1489, 1494), self.input.position)
            _G_apply_190, lastError = self._apply(self.rule_name, "name", [])
            self.considerError(lastError, 'foreignApply')
            _locals['grammar_name'] = _G_apply_190
            self._trace(" '.'", (1507, 1511), self.input.position)
            _G_exactly_191, lastError = self.exactly('.')
            self.considerError(lastError, 'foreignApply')
            self._trace(' name', (1511, 1516), self.input.position)
            _G_apply_192, lastError = self._apply(self.rule_name, "name", [])
            self.considerError(lastError, 'foreignApply')
            _locals['rule_name'] = _G_apply_192
            self._trace(' args', (1526, 1531), self.input.position)
            _G_apply_193, lastError = self._apply(self.rule_args, "args", [])
            self.considerError(lastError, 'foreignApply')
            _locals['args'] = _G_apply_193
            _G_python_194, lastError = eval('t.ForeignApply(grammar_name, rule_name, self.rulename, args, span=self.getSpan())', self.globals, _locals), None
            self.considerError(lastError, 'foreignApply')
            return (_G_python_194, self.currentError)


        def rule_traceable(self):
            _locals = {'self': self}
            self.locals['traceable'] = _locals
            _G_python_195, lastError = eval('self.startSpan()', self.globals, _locals), None
            self.considerError(lastError, 'traceable')
            def _G_or_196():
                self._trace('  foreignApply', (1682, 1696), self.input.position)
                _G_apply_197, lastError = self._apply(self.rule_foreignApply, "foreignApply", [])
                self.considerError(lastError, None)
                return (_G_apply_197, self.currentError)
            def _G_or_198():
                self._trace(' application', (1708, 1720), self.input.position)
                _G_apply_199, lastError = self._apply(self.rule_application, "application", [])
                self.considerError(lastError, None)
                return (_G_apply_199, self.currentError)
            def _G_or_200():
                self._trace(' ruleValue', (1732, 1742), self.input.position)
                _G_apply_201, lastError = self._apply(self.rule_ruleValue, "ruleValue", [])
                self.considerError(lastError, None)
                return (_G_apply_201, self.currentError)
            def _G_or_202():
                self._trace(' semanticPredicate', (1754, 1772), self.input.position)
                _G_apply_203, lastError = self._apply(self.rule_semanticPredicate, "semanticPredicate", [])
                self.considerError(lastError, None)
                return (_G_apply_203, self.currentError)
            def _G_or_204():
                self._trace(' semanticAction', (1784, 1799), self.input.position)
                _G_apply_205, lastError = self._apply(self.rule_semanticAction, "semanticAction", [])
                self.considerError(lastError, None)
                return (_G_apply_205, self.currentError)
            def _G_or_206():
                self._trace(' number', (1811, 1818), self.input.position)
                _G_apply_207, lastError = self._apply(self.rule_number, "number", [])
                self.considerError(lastError, None)
                _locals['n'] = _G_apply_207
                _G_python_208, lastError = eval('self.isTree()', self.globals, _locals), None
                self.considerError(lastError, None)
                _G_python_209, lastError = eval('n', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_209, self.currentError)
            def _G_or_210():
                self._trace(' character', (1854, 1864), self.input.position)
                _G_apply_211, lastError = self._apply(self.rule_character, "character", [])
                self.considerError(lastError, None)
                return (_G_apply_211, self.currentError)
            def _G_or_212():
                self._trace(' string', (1876, 1883), self.input.position)
                _G_apply_213, lastError = self._apply(self.rule_string, "string", [])
                self.considerError(lastError, None)
                return (_G_apply_213, self.currentError)
            _G_or_214, lastError = self._or([_G_or_196, _G_or_198, _G_or_200, _G_or_202, _G_or_204, _G_or_206, _G_or_210, _G_or_212])
            self.considerError(lastError, 'traceable')
            return (_G_or_214, self.currentError)


        def rule_expr1(self):
            _locals = {'self': self}
            self.locals['expr1'] = _locals
            def _G_or_215():
                self._trace(' traceable', (1893, 1903), self.input.position)
                _G_apply_216, lastError = self._apply(self.rule_traceable, "traceable", [])
                self.considerError(lastError, None)
                return (_G_apply_216, self.currentError)
            def _G_or_217():
                self._trace(' ws', (1911, 1914), self.input.position)
                _G_apply_218, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '('", (1914, 1918), self.input.position)
                _G_exactly_219, lastError = self.exactly('(')
                self.considerError(lastError, None)
                self._trace(' expr', (1918, 1923), self.input.position)
                _G_apply_220, lastError = self._apply(self.rule_expr, "expr", [])
                self.considerError(lastError, None)
                _locals['e'] = _G_apply_220
                self._trace(' ws', (1925, 1928), self.input.position)
                _G_apply_221, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" ')'", (1928, 1932), self.input.position)
                _G_exactly_222, lastError = self.exactly(')')
                self.considerError(lastError, None)
                _G_python_223, lastError = eval('e', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_223, self.currentError)
            def _G_or_224():
                self._trace(' ws', (1945, 1948), self.input.position)
                _G_apply_225, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '<'", (1948, 1952), self.input.position)
                _G_exactly_226, lastError = self.exactly('<')
                self.considerError(lastError, None)
                self._trace(' expr', (1952, 1957), self.input.position)
                _G_apply_227, lastError = self._apply(self.rule_expr, "expr", [])
                self.considerError(lastError, None)
                _locals['e'] = _G_apply_227
                self._trace(' ws', (1959, 1962), self.input.position)
                _G_apply_228, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '>'", (1962, 1966), self.input.position)
                _G_exactly_229, lastError = self.exactly('>')
                self.considerError(lastError, None)
                _G_python_230, lastError = eval('t.ConsumedBy(e)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_230, self.currentError)
            def _G_or_231():
                self._trace(' ws', (2002, 2005), self.input.position)
                _G_apply_232, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '['", (2005, 2009), self.input.position)
                _G_exactly_233, lastError = self.exactly('[')
                self.considerError(lastError, None)
                def _G_optional_234():
                    self._trace(' expr', (2009, 2014), self.input.position)
                    _G_apply_235, lastError = self._apply(self.rule_expr, "expr", [])
                    self.considerError(lastError, None)
                    return (_G_apply_235, self.currentError)
                def _G_optional_236():
                    return (None, self.input.nullError())
                _G_or_237, lastError = self._or([_G_optional_234, _G_optional_236])
                self.considerError(lastError, None)
                _locals['e'] = _G_or_237
                self._trace(' ws', (2017, 2020), self.input.position)
                _G_apply_238, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" ']'", (2020, 2024), self.input.position)
                _G_exactly_239, lastError = self.exactly(']')
                self.considerError(lastError, None)
                _G_python_240, lastError = eval('self.isTree()', self.globals, _locals), None
                self.considerError(lastError, None)
                _G_python_241, lastError = eval('t.List(e) if e else t.List()', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_241, self.currentError)
            _G_or_242, lastError = self._or([_G_or_215, _G_or_217, _G_or_224, _G_or_231])
            self.considerError(lastError, 'expr1')
            return (_G_or_242, self.currentError)


        def rule_expr2(self):
            _locals = {'self': self}
            self.locals['expr2'] = _locals
            def _G_or_243():
                self._trace('ws', (2093, 2095), self.input.position)
                _G_apply_244, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '~'", (2095, 2099), self.input.position)
                _G_exactly_245, lastError = self.exactly('~')
                self.considerError(lastError, None)
                def _G_or_246():
                    self._trace("'~'", (2101, 2104), self.input.position)
                    _G_exactly_247, lastError = self.exactly('~')
                    self.considerError(lastError, None)
                    self._trace(' expr2', (2104, 2110), self.input.position)
                    _G_apply_248, lastError = self._apply(self.rule_expr2, "expr2", [])
                    self.considerError(lastError, None)
                    _locals['e'] = _G_apply_248
                    _G_python_249, lastError = eval('t.Lookahead(e)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_249, self.currentError)
                def _G_or_250():
                    self._trace('    expr2', (2148, 2157), self.input.position)
                    _G_apply_251, lastError = self._apply(self.rule_expr2, "expr2", [])
                    self.considerError(lastError, None)
                    _locals['e'] = _G_apply_251
                    _G_python_252, lastError = eval('t.Not(e)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_252, self.currentError)
                _G_or_253, lastError = self._or([_G_or_246, _G_or_250])
                self.considerError(lastError, None)
                return (_G_or_253, self.currentError)
            def _G_or_254():
                self._trace('expr1', (2199, 2204), self.input.position)
                _G_apply_255, lastError = self._apply(self.rule_expr1, "expr1", [])
                self.considerError(lastError, None)
                return (_G_apply_255, self.currentError)
            _G_or_256, lastError = self._or([_G_or_243, _G_or_254])
            self.considerError(lastError, 'expr2')
            return (_G_or_256, self.currentError)


        def rule_repeatTimes(self):
            _locals = {'self': self}
            self.locals['repeatTimes'] = _locals
            def _G_or_257():
                self._trace('barenumber', (2222, 2232), self.input.position)
                _G_apply_258, lastError = self._apply(self.rule_barenumber, "barenumber", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_258
                _G_python_259, lastError = eval('int(x)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_259, self.currentError)
            def _G_or_260():
                self._trace(' name', (2247, 2252), self.input.position)
                _G_apply_261, lastError = self._apply(self.rule_name, "name", [])
                self.considerError(lastError, None)
                return (_G_apply_261, self.currentError)
            _G_or_262, lastError = self._or([_G_or_257, _G_or_260])
            self.considerError(lastError, 'repeatTimes')
            return (_G_or_262, self.currentError)


        def rule_expr3(self):
            _locals = {'self': self}
            self.locals['expr3'] = _locals
            def _G_or_263():
                self._trace('expr2', (2263, 2268), self.input.position)
                _G_apply_264, lastError = self._apply(self.rule_expr2, "expr2", [])
                self.considerError(lastError, None)
                _locals['e'] = _G_apply_264
                def _G_or_265():
                    self._trace("'*'", (2294, 2297), self.input.position)
                    _G_exactly_266, lastError = self.exactly('*')
                    self.considerError(lastError, None)
                    _G_python_267, lastError = eval('t.Many(e)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_267, self.currentError)
                def _G_or_268():
                    self._trace("'+'", (2334, 2337), self.input.position)
                    _G_exactly_269, lastError = self.exactly('+')
                    self.considerError(lastError, None)
                    _G_python_270, lastError = eval('t.Many1(e)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_270, self.currentError)
                def _G_or_271():
                    self._trace("'?'", (2375, 2378), self.input.position)
                    _G_exactly_272, lastError = self.exactly('?')
                    self.considerError(lastError, None)
                    _G_python_273, lastError = eval('t.Optional(e)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_273, self.currentError)
                def _G_or_274():
                    self._trace('customLabel', (2419, 2430), self.input.position)
                    _G_apply_275, lastError = self._apply(self.rule_customLabel, "customLabel", [])
                    self.considerError(lastError, None)
                    _locals['l'] = _G_apply_275
                    _G_python_276, lastError = eval('t.Label(e, l)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_276, self.currentError)
                def _G_or_277():
                    self._trace("'{'", (2473, 2476), self.input.position)
                    _G_exactly_278, lastError = self.exactly('{')
                    self.considerError(lastError, None)
                    self._trace(' ws', (2476, 2479), self.input.position)
                    _G_apply_279, lastError = self._apply(self.rule_ws, "ws", [])
                    self.considerError(lastError, None)
                    self._trace(' repeatTimes', (2479, 2491), self.input.position)
                    _G_apply_280, lastError = self._apply(self.rule_repeatTimes, "repeatTimes", [])
                    self.considerError(lastError, None)
                    _locals['start'] = _G_apply_280
                    self._trace(' ws', (2497, 2500), self.input.position)
                    _G_apply_281, lastError = self._apply(self.rule_ws, "ws", [])
                    self.considerError(lastError, None)
                    def _G_or_282():
                        self._trace("','", (2526, 2529), self.input.position)
                        _G_exactly_283, lastError = self.exactly(',')
                        self.considerError(lastError, None)
                        self._trace(' ws', (2529, 2532), self.input.position)
                        _G_apply_284, lastError = self._apply(self.rule_ws, "ws", [])
                        self.considerError(lastError, None)
                        self._trace(' repeatTimes', (2532, 2544), self.input.position)
                        _G_apply_285, lastError = self._apply(self.rule_repeatTimes, "repeatTimes", [])
                        self.considerError(lastError, None)
                        _locals['end'] = _G_apply_285
                        self._trace(' ws', (2548, 2551), self.input.position)
                        _G_apply_286, lastError = self._apply(self.rule_ws, "ws", [])
                        self.considerError(lastError, None)
                        self._trace(" '}'", (2551, 2555), self.input.position)
                        _G_exactly_287, lastError = self.exactly('}')
                        self.considerError(lastError, None)
                        _G_python_288, lastError = eval('t.Repeat(start, end, e)', self.globals, _locals), None
                        self.considerError(lastError, None)
                        return (_G_python_288, self.currentError)
                    def _G_or_289():
                        self._trace(' ws', (2637, 2640), self.input.position)
                        _G_apply_290, lastError = self._apply(self.rule_ws, "ws", [])
                        self.considerError(lastError, None)
                        self._trace(" '}'", (2640, 2644), self.input.position)
                        _G_exactly_291, lastError = self.exactly('}')
                        self.considerError(lastError, None)
                        _G_python_292, lastError = eval('t.Repeat(start, start, e)', self.globals, _locals), None
                        self.considerError(lastError, None)
                        return (_G_python_292, self.currentError)
                    _G_or_293, lastError = self._or([_G_or_282, _G_or_289])
                    self.considerError(lastError, None)
                    return (_G_or_293, self.currentError)
                def _G_or_294():
                    _G_python_295, lastError = eval('e', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_295, self.currentError)
                _G_or_296, lastError = self._or([_G_or_265, _G_or_268, _G_or_271, _G_or_274, _G_or_277, _G_or_294])
                self.considerError(lastError, None)
                _locals['r'] = _G_or_296
                def _G_or_297():
                    self._trace("':'", (2748, 2751), self.input.position)
                    _G_exactly_298, lastError = self.exactly(':')
                    self.considerError(lastError, None)
                    self._trace(' name', (2751, 2756), self.input.position)
                    _G_apply_299, lastError = self._apply(self.rule_name, "name", [])
                    self.considerError(lastError, None)
                    _locals['n'] = _G_apply_299
                    _G_python_300, lastError = eval('t.Bind(n, r)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_300, self.currentError)
                def _G_or_301():
                    self._trace(" ':('", (2787, 2792), self.input.position)
                    _G_exactly_302, lastError = self.exactly(':(')
                    self.considerError(lastError, None)
                    self._trace(' name', (2792, 2797), self.input.position)
                    _G_apply_303, lastError = self._apply(self.rule_name, "name", [])
                    self.considerError(lastError, None)
                    _locals['n'] = _G_apply_303
                    def _G_many_304():
                        self._trace("','", (2801, 2804), self.input.position)
                        _G_exactly_305, lastError = self.exactly(',')
                        self.considerError(lastError, None)
                        self._trace(' ws', (2804, 2807), self.input.position)
                        _G_apply_306, lastError = self._apply(self.rule_ws, "ws", [])
                        self.considerError(lastError, None)
                        self._trace(' name', (2807, 2812), self.input.position)
                        _G_apply_307, lastError = self._apply(self.rule_name, "name", [])
                        self.considerError(lastError, None)
                        return (_G_apply_307, self.currentError)
                    _G_many_308, lastError = self.many(_G_many_304)
                    self.considerError(lastError, None)
                    _locals['others'] = _G_many_308
                    self._trace(' ws', (2821, 2824), self.input.position)
                    _G_apply_309, lastError = self._apply(self.rule_ws, "ws", [])
                    self.considerError(lastError, None)
                    self._trace(" ')'", (2824, 2828), self.input.position)
                    _G_exactly_310, lastError = self.exactly(')')
                    self.considerError(lastError, None)
                    _G_python_311, lastError = eval('[n] + others if others else n', self.globals, _locals), None
                    self.considerError(lastError, None)
                    _locals['n'] = _G_python_311
                    _G_python_312, lastError = eval('t.Bind(n, r)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_312, self.currentError)
                def _G_or_313():
                    _G_python_314, lastError = eval('r', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_314, self.currentError)
                _G_or_315, lastError = self._or([_G_or_297, _G_or_301, _G_or_313])
                self.considerError(lastError, None)
                return (_G_or_315, self.currentError)
            def _G_or_316():
                self._trace('ws', (2928, 2930), self.input.position)
                _G_apply_317, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" ':'", (2930, 2934), self.input.position)
                _G_exactly_318, lastError = self.exactly(':')
                self.considerError(lastError, None)
                self._trace(' name', (2934, 2939), self.input.position)
                _G_apply_319, lastError = self._apply(self.rule_name, "name", [])
                self.considerError(lastError, None)
                _locals['n'] = _G_apply_319
                _G_python_320, lastError = eval('t.Bind(n, t.Apply("anything", self.rulename, []))', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_320, self.currentError)
            _G_or_321, lastError = self._or([_G_or_263, _G_or_316])
            self.considerError(lastError, 'expr3')
            return (_G_or_321, self.currentError)


        def rule_expr4(self):
            _locals = {'self': self}
            self.locals['expr4'] = _locals
            def _G_many1_322():
                self._trace(' expr3', (3013, 3019), self.input.position)
                _G_apply_323, lastError = self._apply(self.rule_expr3, "expr3", [])
                self.considerError(lastError, None)
                return (_G_apply_323, self.currentError)
            _G_many1_324, lastError = self.many(_G_many1_322, _G_many1_322())
            self.considerError(lastError, 'expr4')
            _locals['es'] = _G_many1_324
            _G_python_325, lastError = eval('es[0] if len(es) == 1 else t.And(es)', self.globals, _locals), None
            self.considerError(lastError, 'expr4')
            return (_G_python_325, self.currentError)


        def rule_expr(self):
            _locals = {'self': self}
            self.locals['expr'] = _locals
            self._trace(' expr4', (3071, 3077), self.input.position)
            _G_apply_326, lastError = self._apply(self.rule_expr4, "expr4", [])
            self.considerError(lastError, 'expr')
            _locals['e'] = _G_apply_326
            def _G_many_327():
                self._trace('ws', (3081, 3083), self.input.position)
                _G_apply_328, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '|'", (3083, 3087), self.input.position)
                _G_exactly_329, lastError = self.exactly('|')
                self.considerError(lastError, None)
                self._trace(' expr4', (3087, 3093), self.input.position)
                _G_apply_330, lastError = self._apply(self.rule_expr4, "expr4", [])
                self.considerError(lastError, None)
                return (_G_apply_330, self.currentError)
            _G_many_331, lastError = self.many(_G_many_327)
            self.considerError(lastError, 'expr')
            _locals['es'] = _G_many_331
            _G_python_332, lastError = eval('t.Or([e] + es) if es else e', self.globals, _locals), None
            self.considerError(lastError, 'expr')
            return (_G_python_332, self.currentError)


        def rule_ruleValue(self):
            _locals = {'self': self}
            self.locals['ruleValue'] = _locals
            self._trace(' ws', (3152, 3155), self.input.position)
            _G_apply_333, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'ruleValue')
            self._trace(" '->'", (3155, 3160), self.input.position)
            _G_exactly_334, lastError = self.exactly('->')
            self.considerError(lastError, 'ruleValue')
            _G_python_335, lastError = eval('self.ruleValueExpr(True)', self.globals, _locals), None
            self.considerError(lastError, 'ruleValue')
            return (_G_python_335, self.currentError)


        def rule_customLabel(self):
            _locals = {'self': self}
            self.locals['customLabel'] = _locals
            def _G_label_336():
                self._trace('ws', (3205, 3207), self.input.position)
                _G_apply_337, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '^'", (3207, 3211), self.input.position)
                _G_exactly_338, lastError = self.exactly('^')
                self.considerError(lastError, None)
                self._trace(' ws', (3211, 3214), self.input.position)
                _G_apply_339, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '('", (3214, 3218), self.input.position)
                _G_exactly_340, lastError = self.exactly('(')
                self.considerError(lastError, None)
                def _G_consumedby_341():
                    def _G_many1_342():
                        def _G_not_343():
                            self._trace("')'", (3222, 3225), self.input.position)
                            _G_exactly_344, lastError = self.exactly(')')
                            self.considerError(lastError, None)
                            return (_G_exactly_344, self.currentError)
                        _G_not_345, lastError = self._not(_G_not_343)
                        self.considerError(lastError, None)
                        self._trace(' anything', (3225, 3234), self.input.position)
                        _G_apply_346, lastError = self._apply(self.rule_anything, "anything", [])
                        self.considerError(lastError, None)
                        return (_G_apply_346, self.currentError)
                    _G_many1_347, lastError = self.many(_G_many1_342, _G_many1_342())
                    self.considerError(lastError, None)
                    return (_G_many1_347, self.currentError)
                _G_consumedby_348, lastError = self.consumedby(_G_consumedby_341)
                self.considerError(lastError, None)
                _locals['e'] = _G_consumedby_348
                self._trace(" ')'", (3239, 3243), self.input.position)
                _G_exactly_349, lastError = self.exactly(')')
                self.considerError(lastError, None)
                _G_python_350, lastError = eval('e', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_350, self.currentError)
            _G_label_351, lastError = self.label(_G_label_336, "customLabelException")
            self.considerError(lastError, 'customLabel')
            return (_G_label_351, self.currentError)


        def rule_semanticPredicate(self):
            _locals = {'self': self}
            self.locals['semanticPredicate'] = _locals
            self._trace(' ws', (3295, 3298), self.input.position)
            _G_apply_352, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'semanticPredicate')
            self._trace(" '?('", (3298, 3303), self.input.position)
            _G_exactly_353, lastError = self.exactly('?(')
            self.considerError(lastError, 'semanticPredicate')
            _G_python_354, lastError = eval('self.semanticPredicateExpr()', self.globals, _locals), None
            self.considerError(lastError, 'semanticPredicate')
            return (_G_python_354, self.currentError)


        def rule_semanticAction(self):
            _locals = {'self': self}
            self.locals['semanticAction'] = _locals
            self._trace(' ws', (3353, 3356), self.input.position)
            _G_apply_355, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'semanticAction')
            self._trace(" '!('", (3356, 3361), self.input.position)
            _G_exactly_356, lastError = self.exactly('!(')
            self.considerError(lastError, 'semanticAction')
            _G_python_357, lastError = eval('self.semanticActionExpr()', self.globals, _locals), None
            self.considerError(lastError, 'semanticAction')
            return (_G_python_357, self.currentError)


        def rule_ruleEnd(self):
            _locals = {'self': self}
            self.locals['ruleEnd'] = _locals
            def _G_label_358():
                def _G_or_359():
                    def _G_many_360():
                        self._trace('hspace', (3404, 3410), self.input.position)
                        _G_apply_361, lastError = self._apply(self.rule_hspace, "hspace", [])
                        self.considerError(lastError, None)
                        return (_G_apply_361, self.currentError)
                    _G_many_362, lastError = self.many(_G_many_360)
                    self.considerError(lastError, None)
                    def _G_many1_363():
                        self._trace(' vspace', (3411, 3418), self.input.position)
                        _G_apply_364, lastError = self._apply(self.rule_vspace, "vspace", [])
                        self.considerError(lastError, None)
                        return (_G_apply_364, self.currentError)
                    _G_many1_365, lastError = self.many(_G_many1_363, _G_many1_363())
                    self.considerError(lastError, None)
                    return (_G_many1_365, self.currentError)
                def _G_or_366():
                    self._trace(' end', (3422, 3426), self.input.position)
                    _G_apply_367, lastError = self._apply(self.rule_end, "end", [])
                    self.considerError(lastError, None)
                    return (_G_apply_367, self.currentError)
                _G_or_368, lastError = self._or([_G_or_359, _G_or_366])
                self.considerError(lastError, None)
                return (_G_or_368, self.currentError)
            _G_label_369, lastError = self.label(_G_label_358, "rule end")
            self.considerError(lastError, 'ruleEnd')
            return (_G_label_369, self.currentError)


        def rule_rulePart(self):
            _locals = {'self': self}
            self.locals['rulePart'] = _locals
            _G_apply_370, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'rulePart')
            _locals['requiredName'] = _G_apply_370
            self._trace(' noindentation', (3466, 3480), self.input.position)
            _G_apply_371, lastError = self._apply(self.rule_noindentation, "noindentation", [])
            self.considerError(lastError, 'rulePart')
            self._trace(' name', (3480, 3485), self.input.position)
            _G_apply_372, lastError = self._apply(self.rule_name, "name", [])
            self.considerError(lastError, 'rulePart')
            _locals['n'] = _G_apply_372
            def _G_pred_373():
                _G_python_374, lastError = eval('n == requiredName', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_374, self.currentError)
            _G_pred_375, lastError = self.pred(_G_pred_373)
            self.considerError(lastError, 'rulePart')
            _G_python_376, lastError = eval('setattr(self, "rulename", n)', self.globals, _locals), None
            self.considerError(lastError, 'rulePart')
            def _G_optional_377():
                self._trace('\n                            expr4', (3568, 3602), self.input.position)
                _G_apply_378, lastError = self._apply(self.rule_expr4, "expr4", [])
                self.considerError(lastError, None)
                return (_G_apply_378, self.currentError)
            def _G_optional_379():
                return (None, self.input.nullError())
            _G_or_380, lastError = self._or([_G_optional_377, _G_optional_379])
            self.considerError(lastError, 'rulePart')
            _locals['args'] = _G_or_380
            def _G_or_381():
                self._trace('ws', (3638, 3640), self.input.position)
                _G_apply_382, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '='", (3640, 3644), self.input.position)
                _G_exactly_383, lastError = self.exactly('=')
                self.considerError(lastError, None)
                self._trace(' expr', (3644, 3649), self.input.position)
                _G_apply_384, lastError = self._apply(self.rule_expr, "expr", [])
                self.considerError(lastError, None)
                _locals['e'] = _G_apply_384
                self._trace(' ruleEnd', (3651, 3659), self.input.position)
                _G_apply_385, lastError = self._apply(self.rule_ruleEnd, "ruleEnd", [])
                self.considerError(lastError, None)
                _G_python_386, lastError = eval('t.And([args, e]) if args else e', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_386, self.currentError)
            def _G_or_387():
                self._trace(' ruleEnd', (3755, 3763), self.input.position)
                _G_apply_388, lastError = self._apply(self.rule_ruleEnd, "ruleEnd", [])
                self.considerError(lastError, None)
                _G_python_389, lastError = eval('args', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_389, self.currentError)
            _G_or_390, lastError = self._or([_G_or_381, _G_or_387])
            self.considerError(lastError, 'rulePart')
            return (_G_or_390, self.currentError)


        def rule_rule(self):
            _locals = {'self': self}
            self.locals['rule'] = _locals
            self._trace(' noindentation', (3780, 3794), self.input.position)
            _G_apply_391, lastError = self._apply(self.rule_noindentation, "noindentation", [])
            self.considerError(lastError, 'rule')
            def _G_lookahead_392():
                self._trace('name', (3798, 3802), self.input.position)
                _G_apply_393, lastError = self._apply(self.rule_name, "name", [])
                self.considerError(lastError, None)
                _locals['n'] = _G_apply_393
                return (_locals['n'], self.currentError)
            _G_lookahead_394, lastError = self.lookahead(_G_lookahead_392)
            self.considerError(lastError, 'rule')
            def _G_many1_395():
                self._trace(' rulePart(n)', (3805, 3817), self.input.position)
                _G_python_396, lastError = eval('n', self.globals, _locals), None
                self.considerError(lastError, None)
                _G_apply_397, lastError = self._apply(self.rule_rulePart, "rulePart", [_G_python_396])
                self.considerError(lastError, None)
                return (_G_apply_397, self.currentError)
            _G_many1_398, lastError = self.many(_G_many1_395, _G_many1_395())
            self.considerError(lastError, 'rule')
            _locals['rs'] = _G_many1_398
            _G_python_399, lastError = eval('t.Rule(n, t.Or(rs))', self.globals, _locals), None
            self.considerError(lastError, 'rule')
            return (_G_python_399, self.currentError)


        def rule_grammar(self):
            _locals = {'self': self}
            self.locals['grammar'] = _locals
            def _G_many_400():
                self._trace(' rule', (3856, 3861), self.input.position)
                _G_apply_401, lastError = self._apply(self.rule_rule, "rule", [])
                self.considerError(lastError, None)
                return (_G_apply_401, self.currentError)
            _G_many_402, lastError = self.many(_G_many_400)
            self.considerError(lastError, 'grammar')
            _locals['rs'] = _G_many_402
            self._trace(' ws', (3865, 3868), self.input.position)
            _G_apply_403, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'grammar')
            _G_python_404, lastError = eval('t.Grammar(self.name, self.tree_target, rs)', self.globals, _locals), None
            self.considerError(lastError, 'grammar')
            return (_G_python_404, self.currentError)


    if parsley.globals is not None:
        parsley.globals = parsley.globals.copy()
        parsley.globals.update(ruleGlobals)
    else:
        parsley.globals = ruleGlobals
    return parsley
########NEW FILE########
__FILENAME__ = parsley_termactions
def createParserClass(GrammarBase, ruleGlobals):
    if ruleGlobals is None:
        ruleGlobals = {}
    class parsley_termactions(GrammarBase):
        def rule_ruleValue(self):
            _locals = {'self': self}
            self.locals['ruleValue'] = _locals
            self._trace(' ws', (11, 14), self.input.position)
            _G_apply_1, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'ruleValue')
            self._trace(" '->'", (14, 19), self.input.position)
            _G_exactly_2, lastError = self.exactly('->')
            self.considerError(lastError, 'ruleValue')
            self._trace(' term', (19, 24), self.input.position)
            _G_apply_3, lastError = self._apply(self.rule_term, "term", [])
            self.considerError(lastError, 'ruleValue')
            _locals['tt'] = _G_apply_3
            _G_python_4, lastError = eval('t.Action(tt)', self.globals, _locals), None
            self.considerError(lastError, 'ruleValue')
            return (_G_python_4, self.currentError)


        def rule_semanticPredicate(self):
            _locals = {'self': self}
            self.locals['semanticPredicate'] = _locals
            self._trace(' ws', (64, 67), self.input.position)
            _G_apply_5, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'semanticPredicate')
            self._trace(" '?('", (67, 72), self.input.position)
            _G_exactly_6, lastError = self.exactly('?(')
            self.considerError(lastError, 'semanticPredicate')
            self._trace(' term', (72, 77), self.input.position)
            _G_apply_7, lastError = self._apply(self.rule_term, "term", [])
            self.considerError(lastError, 'semanticPredicate')
            _locals['tt'] = _G_apply_7
            self._trace(' ws', (80, 83), self.input.position)
            _G_apply_8, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'semanticPredicate')
            self._trace(" ')'", (83, 87), self.input.position)
            _G_exactly_9, lastError = self.exactly(')')
            self.considerError(lastError, 'semanticPredicate')
            _G_python_10, lastError = eval('t.Predicate(tt)', self.globals, _locals), None
            self.considerError(lastError, 'semanticPredicate')
            return (_G_python_10, self.currentError)


        def rule_semanticAction(self):
            _locals = {'self': self}
            self.locals['semanticAction'] = _locals
            self._trace(' ws', (124, 127), self.input.position)
            _G_apply_11, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'semanticAction')
            self._trace(" '!('", (127, 132), self.input.position)
            _G_exactly_12, lastError = self.exactly('!(')
            self.considerError(lastError, 'semanticAction')
            self._trace(' term', (132, 137), self.input.position)
            _G_apply_13, lastError = self._apply(self.rule_term, "term", [])
            self.considerError(lastError, 'semanticAction')
            _locals['tt'] = _G_apply_13
            self._trace(' ws', (140, 143), self.input.position)
            _G_apply_14, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'semanticAction')
            self._trace(" ')'", (143, 147), self.input.position)
            _G_exactly_15, lastError = self.exactly(')')
            self.considerError(lastError, 'semanticAction')
            _G_python_16, lastError = eval('t.Action(tt)', self.globals, _locals), None
            self.considerError(lastError, 'semanticAction')
            return (_G_python_16, self.currentError)


        def rule_application(self):
            _locals = {'self': self}
            self.locals['application'] = _locals
            def _G_optional_17():
                self._trace(' indentation', (178, 190), self.input.position)
                _G_apply_18, lastError = self._apply(self.rule_indentation, "indentation", [])
                self.considerError(lastError, None)
                return (_G_apply_18, self.currentError)
            def _G_optional_19():
                return (None, self.input.nullError())
            _G_or_20, lastError = self._or([_G_optional_17, _G_optional_19])
            self.considerError(lastError, 'application')
            self._trace(' name', (191, 196), self.input.position)
            _G_apply_21, lastError = self._apply(self.rule_name, "name", [])
            self.considerError(lastError, 'application')
            _locals['name'] = _G_apply_21
            def _G_or_22():
                self._trace("'('", (221, 224), self.input.position)
                _G_exactly_23, lastError = self.exactly('(')
                self.considerError(lastError, None)
                self._trace(' term_arglist', (224, 237), self.input.position)
                _G_apply_24, lastError = self._apply(self.rule_term_arglist, "term_arglist", [])
                self.considerError(lastError, None)
                _locals['args'] = _G_apply_24
                self._trace(" ')'", (242, 246), self.input.position)
                _G_exactly_25, lastError = self.exactly(')')
                self.considerError(lastError, None)
                _G_python_26, lastError = eval('t.Apply(name, self.rulename, args)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_26, self.currentError)
            def _G_or_27():
                _G_python_28, lastError = eval('t.Apply(name, self.rulename, [])', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_28, self.currentError)
            _G_or_29, lastError = self._or([_G_or_22, _G_or_27])
            self.considerError(lastError, 'application')
            return (_G_or_29, self.currentError)


    if parsley_termactions.globals is not None:
        parsley_termactions.globals = parsley_termactions.globals.copy()
        parsley_termactions.globals.update(ruleGlobals)
    else:
        parsley_termactions.globals = ruleGlobals
    return parsley_termactions
########NEW FILE########
__FILENAME__ = parsley_tree_transformer
def createParserClass(GrammarBase, ruleGlobals):
    if ruleGlobals is None:
        ruleGlobals = {}
    class parsley_tree_transformer(GrammarBase):
        def rule_termPattern(self):
            _locals = {'self': self}
            self.locals['termPattern'] = _locals
            def _G_optional_1():
                self._trace(' indentation', (13, 25), self.input.position)
                _G_apply_2, lastError = self._apply(self.rule_indentation, "indentation", [])
                self.considerError(lastError, None)
                return (_G_apply_2, self.currentError)
            def _G_optional_3():
                return (None, self.input.nullError())
            _G_or_4, lastError = self._or([_G_optional_1, _G_optional_3])
            self.considerError(lastError, 'termPattern')
            self._trace(' name', (26, 31), self.input.position)
            _G_apply_5, lastError = self._apply(self.rule_name, "name", [])
            self.considerError(lastError, 'termPattern')
            _locals['name'] = _G_apply_5
            def _G_pred_6():
                _G_python_7, lastError = eval('name[0].isupper()', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_7, self.currentError)
            _G_pred_8, lastError = self.pred(_G_pred_6)
            self.considerError(lastError, 'termPattern')
            self._trace("\n              '('", (57, 75), self.input.position)
            _G_exactly_9, lastError = self.exactly('(')
            self.considerError(lastError, 'termPattern')
            def _G_optional_10():
                self._trace(' expr', (75, 80), self.input.position)
                _G_apply_11, lastError = self._apply(self.rule_expr, "expr", [])
                self.considerError(lastError, None)
                return (_G_apply_11, self.currentError)
            def _G_optional_12():
                return (None, self.input.nullError())
            _G_or_13, lastError = self._or([_G_optional_10, _G_optional_12])
            self.considerError(lastError, 'termPattern')
            _locals['patts'] = _G_or_13
            self._trace(" ')'", (87, 91), self.input.position)
            _G_exactly_14, lastError = self.exactly(')')
            self.considerError(lastError, 'termPattern')
            _G_python_15, lastError = eval('t.TermPattern(name, patts)', self.globals, _locals), None
            self.considerError(lastError, 'termPattern')
            return (_G_python_15, self.currentError)


        def rule_subtransform(self):
            _locals = {'self': self}
            self.locals['subtransform'] = _locals
            self._trace(' ws', (137, 140), self.input.position)
            _G_apply_16, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'subtransform')
            self._trace(" '@'", (140, 144), self.input.position)
            _G_exactly_17, lastError = self.exactly('@')
            self.considerError(lastError, 'subtransform')
            self._trace(' name', (144, 149), self.input.position)
            _G_apply_18, lastError = self._apply(self.rule_name, "name", [])
            self.considerError(lastError, 'subtransform')
            _locals['n'] = _G_apply_18
            _G_python_19, lastError = eval("t.Bind(n, t.Apply('transform', self.rulename, []))", self.globals, _locals), None
            self.considerError(lastError, 'subtransform')
            return (_G_python_19, self.currentError)


        def rule_wide_templatedValue(self):
            _locals = {'self': self}
            self.locals['wide_templatedValue'] = _locals
            self._trace(' ws', (228, 231), self.input.position)
            _G_apply_20, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'wide_templatedValue')
            self._trace(" '-->'", (231, 237), self.input.position)
            _G_exactly_21, lastError = self.exactly('-->')
            self.considerError(lastError, 'wide_templatedValue')
            def _G_many_22():
                self._trace(" ' '", (237, 241), self.input.position)
                _G_exactly_23, lastError = self.exactly(' ')
                self.considerError(lastError, None)
                return (_G_exactly_23, self.currentError)
            _G_many_24, lastError = self.many(_G_many_22)
            self.considerError(lastError, 'wide_templatedValue')
            self._trace(' wideTemplateBits', (242, 259), self.input.position)
            _G_apply_25, lastError = self._apply(self.rule_wideTemplateBits, "wideTemplateBits", [])
            self.considerError(lastError, 'wide_templatedValue')
            _locals['contents'] = _G_apply_25
            _G_python_26, lastError = eval('t.StringTemplate(contents)', self.globals, _locals), None
            self.considerError(lastError, 'wide_templatedValue')
            return (_G_python_26, self.currentError)


        def rule_tall_templatedValue(self):
            _locals = {'self': self}
            self.locals['tall_templatedValue'] = _locals
            def _G_optional_27():
                self._trace(' hspace', (320, 327), self.input.position)
                _G_apply_28, lastError = self._apply(self.rule_hspace, "hspace", [])
                self.considerError(lastError, None)
                return (_G_apply_28, self.currentError)
            def _G_optional_29():
                return (None, self.input.nullError())
            _G_or_30, lastError = self._or([_G_optional_27, _G_optional_29])
            self.considerError(lastError, 'tall_templatedValue')
            self._trace(" '{{{'", (328, 334), self.input.position)
            _G_exactly_31, lastError = self.exactly('{{{')
            self.considerError(lastError, 'tall_templatedValue')
            def _G_many_32():
                def _G_or_33():
                    self._trace("' '", (336, 339), self.input.position)
                    _G_exactly_34, lastError = self.exactly(' ')
                    self.considerError(lastError, None)
                    return (_G_exactly_34, self.currentError)
                def _G_or_35():
                    self._trace(" '\\t'", (341, 346), self.input.position)
                    _G_exactly_36, lastError = self.exactly('\t')
                    self.considerError(lastError, None)
                    return (_G_exactly_36, self.currentError)
                _G_or_37, lastError = self._or([_G_or_33, _G_or_35])
                self.considerError(lastError, None)
                return (_G_or_37, self.currentError)
            _G_many_38, lastError = self.many(_G_many_32)
            self.considerError(lastError, 'tall_templatedValue')
            def _G_optional_39():
                self._trace(' vspace', (348, 355), self.input.position)
                _G_apply_40, lastError = self._apply(self.rule_vspace, "vspace", [])
                self.considerError(lastError, None)
                return (_G_apply_40, self.currentError)
            def _G_optional_41():
                return (None, self.input.nullError())
            _G_or_42, lastError = self._or([_G_optional_39, _G_optional_41])
            self.considerError(lastError, 'tall_templatedValue')
            self._trace(' tallTemplateBits', (356, 373), self.input.position)
            _G_apply_43, lastError = self._apply(self.rule_tallTemplateBits, "tallTemplateBits", [])
            self.considerError(lastError, 'tall_templatedValue')
            _locals['contents'] = _G_apply_43
            self._trace(" '}}}'", (382, 388), self.input.position)
            _G_exactly_44, lastError = self.exactly('}}}')
            self.considerError(lastError, 'tall_templatedValue')
            _G_python_45, lastError = eval('t.StringTemplate(contents)', self.globals, _locals), None
            self.considerError(lastError, 'tall_templatedValue')
            return (_G_python_45, self.currentError)


        def rule_tallTemplateBits(self):
            _locals = {'self': self}
            self.locals['tallTemplateBits'] = _locals
            def _G_many_46():
                def _G_or_47():
                    self._trace('exprHole', (440, 448), self.input.position)
                    _G_apply_48, lastError = self._apply(self.rule_exprHole, "exprHole", [])
                    self.considerError(lastError, None)
                    return (_G_apply_48, self.currentError)
                def _G_or_49():
                    self._trace(' tallTemplateText', (450, 467), self.input.position)
                    _G_apply_50, lastError = self._apply(self.rule_tallTemplateText, "tallTemplateText", [])
                    self.considerError(lastError, None)
                    return (_G_apply_50, self.currentError)
                _G_or_51, lastError = self._or([_G_or_47, _G_or_49])
                self.considerError(lastError, None)
                return (_G_or_51, self.currentError)
            _G_many_52, lastError = self.many(_G_many_46)
            self.considerError(lastError, 'tallTemplateBits')
            return (_G_many_52, self.currentError)


        def rule_tallTemplateText(self):
            _locals = {'self': self}
            self.locals['tallTemplateText'] = _locals
            def _G_or_53():
                def _G_consumedby_54():
                    def _G_many1_55():
                        def _G_or_56():
                            def _G_not_57():
                                def _G_or_58():
                                    self._trace("'}}}'", (493, 498), self.input.position)
                                    _G_exactly_59, lastError = self.exactly('}}}')
                                    self.considerError(lastError, None)
                                    return (_G_exactly_59, self.currentError)
                                def _G_or_60():
                                    self._trace(" '$'", (500, 504), self.input.position)
                                    _G_exactly_61, lastError = self.exactly('$')
                                    self.considerError(lastError, None)
                                    return (_G_exactly_61, self.currentError)
                                def _G_or_62():
                                    self._trace(" '\\r'", (506, 511), self.input.position)
                                    _G_exactly_63, lastError = self.exactly('\r')
                                    self.considerError(lastError, None)
                                    return (_G_exactly_63, self.currentError)
                                def _G_or_64():
                                    self._trace(" '\\n'", (513, 518), self.input.position)
                                    _G_exactly_65, lastError = self.exactly('\n')
                                    self.considerError(lastError, None)
                                    return (_G_exactly_65, self.currentError)
                                _G_or_66, lastError = self._or([_G_or_58, _G_or_60, _G_or_62, _G_or_64])
                                self.considerError(lastError, None)
                                return (_G_or_66, self.currentError)
                            _G_not_67, lastError = self._not(_G_not_57)
                            self.considerError(lastError, None)
                            self._trace(' anything', (519, 528), self.input.position)
                            _G_apply_68, lastError = self._apply(self.rule_anything, "anything", [])
                            self.considerError(lastError, None)
                            return (_G_apply_68, self.currentError)
                        def _G_or_69():
                            self._trace(" '$'", (530, 534), self.input.position)
                            _G_exactly_70, lastError = self.exactly('$')
                            self.considerError(lastError, None)
                            self._trace(" '$'", (534, 538), self.input.position)
                            _G_exactly_71, lastError = self.exactly('$')
                            self.considerError(lastError, None)
                            return (_G_exactly_71, self.currentError)
                        _G_or_72, lastError = self._or([_G_or_56, _G_or_69])
                        self.considerError(lastError, None)
                        return (_G_or_72, self.currentError)
                    _G_many1_73, lastError = self.many(_G_many1_55, _G_many1_55())
                    self.considerError(lastError, None)
                    def _G_many_74():
                        self._trace(' vspace', (540, 547), self.input.position)
                        _G_apply_75, lastError = self._apply(self.rule_vspace, "vspace", [])
                        self.considerError(lastError, None)
                        return (_G_apply_75, self.currentError)
                    _G_many_76, lastError = self.many(_G_many_74)
                    self.considerError(lastError, None)
                    return (_G_many_76, self.currentError)
                _G_consumedby_77, lastError = self.consumedby(_G_consumedby_54)
                self.considerError(lastError, None)
                return (_G_consumedby_77, self.currentError)
            def _G_or_78():
                self._trace(' vspace', (551, 558), self.input.position)
                _G_apply_79, lastError = self._apply(self.rule_vspace, "vspace", [])
                self.considerError(lastError, None)
                return (_G_apply_79, self.currentError)
            _G_or_80, lastError = self._or([_G_or_53, _G_or_78])
            self.considerError(lastError, 'tallTemplateText')
            return (_G_or_80, self.currentError)


        def rule_wideTemplateBits(self):
            _locals = {'self': self}
            self.locals['wideTemplateBits'] = _locals
            def _G_many_81():
                def _G_or_82():
                    self._trace('exprHole', (580, 588), self.input.position)
                    _G_apply_83, lastError = self._apply(self.rule_exprHole, "exprHole", [])
                    self.considerError(lastError, None)
                    return (_G_apply_83, self.currentError)
                def _G_or_84():
                    self._trace(' wideTemplateText', (590, 607), self.input.position)
                    _G_apply_85, lastError = self._apply(self.rule_wideTemplateText, "wideTemplateText", [])
                    self.considerError(lastError, None)
                    return (_G_apply_85, self.currentError)
                _G_or_86, lastError = self._or([_G_or_82, _G_or_84])
                self.considerError(lastError, None)
                return (_G_or_86, self.currentError)
            _G_many_87, lastError = self.many(_G_many_81)
            self.considerError(lastError, 'wideTemplateBits')
            return (_G_many_87, self.currentError)


        def rule_wideTemplateText(self):
            _locals = {'self': self}
            self.locals['wideTemplateText'] = _locals
            def _G_consumedby_88():
                def _G_many1_89():
                    def _G_or_90():
                        def _G_not_91():
                            def _G_or_92():
                                self._trace('vspace', (633, 639), self.input.position)
                                _G_apply_93, lastError = self._apply(self.rule_vspace, "vspace", [])
                                self.considerError(lastError, None)
                                return (_G_apply_93, self.currentError)
                            def _G_or_94():
                                self._trace(' end', (641, 645), self.input.position)
                                _G_apply_95, lastError = self._apply(self.rule_end, "end", [])
                                self.considerError(lastError, None)
                                return (_G_apply_95, self.currentError)
                            def _G_or_96():
                                self._trace("'$'", (647, 650), self.input.position)
                                _G_exactly_97, lastError = self.exactly('$')
                                self.considerError(lastError, None)
                                return (_G_exactly_97, self.currentError)
                            _G_or_98, lastError = self._or([_G_or_92, _G_or_94, _G_or_96])
                            self.considerError(lastError, None)
                            return (_G_or_98, self.currentError)
                        _G_not_99, lastError = self._not(_G_not_91)
                        self.considerError(lastError, None)
                        self._trace(' anything', (651, 660), self.input.position)
                        _G_apply_100, lastError = self._apply(self.rule_anything, "anything", [])
                        self.considerError(lastError, None)
                        return (_G_apply_100, self.currentError)
                    def _G_or_101():
                        self._trace(" '$'", (662, 666), self.input.position)
                        _G_exactly_102, lastError = self.exactly('$')
                        self.considerError(lastError, None)
                        self._trace(" '$'", (666, 670), self.input.position)
                        _G_exactly_103, lastError = self.exactly('$')
                        self.considerError(lastError, None)
                        return (_G_exactly_103, self.currentError)
                    _G_or_104, lastError = self._or([_G_or_90, _G_or_101])
                    self.considerError(lastError, None)
                    return (_G_or_104, self.currentError)
                _G_many1_105, lastError = self.many(_G_many1_89, _G_many1_89())
                self.considerError(lastError, None)
                return (_G_many1_105, self.currentError)
            _G_consumedby_106, lastError = self.consumedby(_G_consumedby_88)
            self.considerError(lastError, 'wideTemplateText')
            return (_G_consumedby_106, self.currentError)


        def rule_exprHole(self):
            _locals = {'self': self}
            self.locals['exprHole'] = _locals
            self._trace(" '$'", (685, 689), self.input.position)
            _G_exactly_107, lastError = self.exactly('$')
            self.considerError(lastError, 'exprHole')
            self._trace(' name', (689, 694), self.input.position)
            _G_apply_108, lastError = self._apply(self.rule_name, "name", [])
            self.considerError(lastError, 'exprHole')
            _locals['n'] = _G_apply_108
            _G_python_109, lastError = eval('t.QuasiExprHole(n)', self.globals, _locals), None
            self.considerError(lastError, 'exprHole')
            return (_G_python_109, self.currentError)


        def rule_expr1(self):
            _locals = {'self': self}
            self.locals['expr1'] = _locals
            def _G_or_110():
                self._trace(' foreignApply', (727, 740), self.input.position)
                _G_apply_111, lastError = self._apply(self.rule_foreignApply, "foreignApply", [])
                self.considerError(lastError, None)
                return (_G_apply_111, self.currentError)
            def _G_or_112():
                self._trace('termPattern', (749, 760), self.input.position)
                _G_apply_113, lastError = self._apply(self.rule_termPattern, "termPattern", [])
                self.considerError(lastError, None)
                return (_G_apply_113, self.currentError)
            def _G_or_114():
                self._trace('subtransform', (769, 781), self.input.position)
                _G_apply_115, lastError = self._apply(self.rule_subtransform, "subtransform", [])
                self.considerError(lastError, None)
                return (_G_apply_115, self.currentError)
            def _G_or_116():
                self._trace('application', (790, 801), self.input.position)
                _G_apply_117, lastError = self._apply(self.rule_application, "application", [])
                self.considerError(lastError, None)
                return (_G_apply_117, self.currentError)
            def _G_or_118():
                self._trace('ruleValue', (810, 819), self.input.position)
                _G_apply_119, lastError = self._apply(self.rule_ruleValue, "ruleValue", [])
                self.considerError(lastError, None)
                return (_G_apply_119, self.currentError)
            def _G_or_120():
                self._trace('wide_templatedValue', (828, 847), self.input.position)
                _G_apply_121, lastError = self._apply(self.rule_wide_templatedValue, "wide_templatedValue", [])
                self.considerError(lastError, None)
                return (_G_apply_121, self.currentError)
            def _G_or_122():
                self._trace('tall_templatedValue', (856, 875), self.input.position)
                _G_apply_123, lastError = self._apply(self.rule_tall_templatedValue, "tall_templatedValue", [])
                self.considerError(lastError, None)
                return (_G_apply_123, self.currentError)
            def _G_or_124():
                self._trace('semanticPredicate', (884, 901), self.input.position)
                _G_apply_125, lastError = self._apply(self.rule_semanticPredicate, "semanticPredicate", [])
                self.considerError(lastError, None)
                return (_G_apply_125, self.currentError)
            def _G_or_126():
                self._trace('semanticAction', (910, 924), self.input.position)
                _G_apply_127, lastError = self._apply(self.rule_semanticAction, "semanticAction", [])
                self.considerError(lastError, None)
                return (_G_apply_127, self.currentError)
            def _G_or_128():
                self._trace('number', (933, 939), self.input.position)
                _G_apply_129, lastError = self._apply(self.rule_number, "number", [])
                self.considerError(lastError, None)
                _locals['n'] = _G_apply_129
                _G_python_130, lastError = eval('self.isTree()', self.globals, _locals), None
                self.considerError(lastError, None)
                _G_python_131, lastError = eval('n', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_131, self.currentError)
            def _G_or_132():
                self._trace('character', (972, 981), self.input.position)
                _G_apply_133, lastError = self._apply(self.rule_character, "character", [])
                self.considerError(lastError, None)
                return (_G_apply_133, self.currentError)
            def _G_or_134():
                self._trace('string', (990, 996), self.input.position)
                _G_apply_135, lastError = self._apply(self.rule_string, "string", [])
                self.considerError(lastError, None)
                return (_G_apply_135, self.currentError)
            def _G_or_136():
                self._trace('ws', (1005, 1007), self.input.position)
                _G_apply_137, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '('", (1007, 1011), self.input.position)
                _G_exactly_138, lastError = self.exactly('(')
                self.considerError(lastError, None)
                def _G_optional_139():
                    self._trace(' expr', (1011, 1016), self.input.position)
                    _G_apply_140, lastError = self._apply(self.rule_expr, "expr", [])
                    self.considerError(lastError, None)
                    return (_G_apply_140, self.currentError)
                def _G_optional_141():
                    return (None, self.input.nullError())
                _G_or_142, lastError = self._or([_G_optional_139, _G_optional_141])
                self.considerError(lastError, None)
                _locals['e'] = _G_or_142
                self._trace(' ws', (1019, 1022), self.input.position)
                _G_apply_143, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" ')'", (1022, 1026), self.input.position)
                _G_exactly_144, lastError = self.exactly(')')
                self.considerError(lastError, None)
                _G_python_145, lastError = eval('e', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_145, self.currentError)
            def _G_or_146():
                self._trace('ws', (1040, 1042), self.input.position)
                _G_apply_147, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '['", (1042, 1046), self.input.position)
                _G_exactly_148, lastError = self.exactly('[')
                self.considerError(lastError, None)
                def _G_optional_149():
                    self._trace(' expr', (1046, 1051), self.input.position)
                    _G_apply_150, lastError = self._apply(self.rule_expr, "expr", [])
                    self.considerError(lastError, None)
                    return (_G_apply_150, self.currentError)
                def _G_optional_151():
                    return (None, self.input.nullError())
                _G_or_152, lastError = self._or([_G_optional_149, _G_optional_151])
                self.considerError(lastError, None)
                _locals['e'] = _G_or_152
                self._trace(' ws', (1054, 1057), self.input.position)
                _G_apply_153, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" ']'", (1057, 1061), self.input.position)
                _G_exactly_154, lastError = self.exactly(']')
                self.considerError(lastError, None)
                _G_python_155, lastError = eval('t.TermPattern(".tuple.", e or t.And([]))', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_155, self.currentError)
            _G_or_156, lastError = self._or([_G_or_110, _G_or_112, _G_or_114, _G_or_116, _G_or_118, _G_or_120, _G_or_122, _G_or_124, _G_or_126, _G_or_128, _G_or_132, _G_or_134, _G_or_136, _G_or_146])
            self.considerError(lastError, 'expr1')
            return (_G_or_156, self.currentError)


        def rule_grammar(self):
            _locals = {'self': self}
            self.locals['grammar'] = _locals
            def _G_many_157():
                self._trace(' rule', (1116, 1121), self.input.position)
                _G_apply_158, lastError = self._apply(self.rule_rule, "rule", [])
                self.considerError(lastError, None)
                return (_G_apply_158, self.currentError)
            _G_many_159, lastError = self.many(_G_many_157)
            self.considerError(lastError, 'grammar')
            _locals['rs'] = _G_many_159
            self._trace(' ws', (1125, 1128), self.input.position)
            _G_apply_160, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'grammar')
            _G_python_161, lastError = eval('t.Grammar(self.name, True, rs)', self.globals, _locals), None
            self.considerError(lastError, 'grammar')
            return (_G_python_161, self.currentError)


        def rule_rule(self):
            _locals = {'self': self}
            self.locals['rule'] = _locals
            self._trace(' noindentation', (1169, 1183), self.input.position)
            _G_apply_162, lastError = self._apply(self.rule_noindentation, "noindentation", [])
            self.considerError(lastError, 'rule')
            def _G_lookahead_163():
                self._trace('name', (1187, 1191), self.input.position)
                _G_apply_164, lastError = self._apply(self.rule_name, "name", [])
                self.considerError(lastError, None)
                _locals['n'] = _G_apply_164
                return (_locals['n'], self.currentError)
            _G_lookahead_165, lastError = self.lookahead(_G_lookahead_163)
            self.considerError(lastError, 'rule')
            def _G_or_166():
                def _G_many1_167():
                    self._trace('termRulePart(n)', (1196, 1211), self.input.position)
                    _G_python_168, lastError = eval('n', self.globals, _locals), None
                    self.considerError(lastError, None)
                    _G_apply_169, lastError = self._apply(self.rule_termRulePart, "termRulePart", [_G_python_168])
                    self.considerError(lastError, None)
                    return (_G_apply_169, self.currentError)
                _G_many1_170, lastError = self.many(_G_many1_167, _G_many1_167())
                self.considerError(lastError, None)
                _locals['rs'] = _G_many1_170
                return (_locals['rs'], self.currentError)
            def _G_or_171():
                def _G_many1_172():
                    self._trace(' rulePart(n)', (1217, 1229), self.input.position)
                    _G_python_173, lastError = eval('n', self.globals, _locals), None
                    self.considerError(lastError, None)
                    _G_apply_174, lastError = self._apply(self.rule_rulePart, "rulePart", [_G_python_173])
                    self.considerError(lastError, None)
                    return (_G_apply_174, self.currentError)
                _G_many1_175, lastError = self.many(_G_many1_172, _G_many1_172())
                self.considerError(lastError, None)
                _locals['rs'] = _G_many1_175
                return (_locals['rs'], self.currentError)
            _G_or_176, lastError = self._or([_G_or_166, _G_or_171])
            self.considerError(lastError, 'rule')
            _G_python_177, lastError = eval('t.Rule(n, t.Or(rs))', self.globals, _locals), None
            self.considerError(lastError, 'rule')
            return (_G_python_177, self.currentError)


        def rule_termRulePart(self):
            _locals = {'self': self}
            self.locals['termRulePart'] = _locals
            _G_apply_178, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'termRulePart')
            _locals['requiredName'] = _G_apply_178
            self._trace('  noindentation', (1288, 1303), self.input.position)
            _G_apply_179, lastError = self._apply(self.rule_noindentation, "noindentation", [])
            self.considerError(lastError, 'termRulePart')
            _G_python_180, lastError = eval('setattr(self, "rulename", requiredName)', self.globals, _locals), None
            self.considerError(lastError, 'termRulePart')
            self._trace('\n                             termPattern', (1346, 1387), self.input.position)
            _G_apply_181, lastError = self._apply(self.rule_termPattern, "termPattern", [])
            self.considerError(lastError, 'termRulePart')
            _locals['tt'] = _G_apply_181
            def _G_pred_182():
                _G_python_183, lastError = eval('tt.args[0].data == requiredName', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_183, self.currentError)
            _G_pred_184, lastError = self.pred(_G_pred_182)
            self.considerError(lastError, 'termRulePart')
            def _G_optional_185():
                self._trace(' token("=")', (1425, 1436), self.input.position)
                _G_python_186, lastError = ("="), None
                self.considerError(lastError, None)
                _G_apply_187, lastError = self._apply(self.rule_token, "token", [_G_python_186])
                self.considerError(lastError, None)
                return (_G_apply_187, self.currentError)
            def _G_optional_188():
                return (None, self.input.nullError())
            _G_or_189, lastError = self._or([_G_optional_185, _G_optional_188])
            self.considerError(lastError, 'termRulePart')
            self._trace(' expr', (1437, 1442), self.input.position)
            _G_apply_190, lastError = self._apply(self.rule_expr, "expr", [])
            self.considerError(lastError, 'termRulePart')
            _locals['tail'] = _G_apply_190
            _G_python_191, lastError = eval('t.And([tt, tail])', self.globals, _locals), None
            self.considerError(lastError, 'termRulePart')
            return (_G_python_191, self.currentError)


    if parsley_tree_transformer.globals is not None:
        parsley_tree_transformer.globals = parsley_tree_transformer.globals.copy()
        parsley_tree_transformer.globals.update(ruleGlobals)
    else:
        parsley_tree_transformer.globals = ruleGlobals
    return parsley_tree_transformer
########NEW FILE########
__FILENAME__ = pymeta_v1
def createParserClass(GrammarBase, ruleGlobals):
    if ruleGlobals is None:
        ruleGlobals = {}
    class pymeta_v1(GrammarBase):
        def rule_comment(self):
            _locals = {'self': self}
            self.locals['comment'] = _locals
            self._trace(" '#'", (9, 13), self.input.position)
            _G_exactly_1, lastError = self.exactly('#')
            self.considerError(lastError, 'comment')
            def _G_many_2():
                def _G_not_3():
                    self._trace("'\\n'", (16, 20), self.input.position)
                    _G_exactly_4, lastError = self.exactly('\n')
                    self.considerError(lastError, None)
                    return (_G_exactly_4, self.currentError)
                _G_not_5, lastError = self._not(_G_not_3)
                self.considerError(lastError, None)
                self._trace(' anything', (20, 29), self.input.position)
                _G_apply_6, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                return (_G_apply_6, self.currentError)
            _G_many_7, lastError = self.many(_G_many_2)
            self.considerError(lastError, 'comment')
            return (_G_many_7, self.currentError)


        def rule_hspace(self):
            _locals = {'self': self}
            self.locals['hspace'] = _locals
            def _G_or_8():
                self._trace(" ' '", (40, 44), self.input.position)
                _G_exactly_9, lastError = self.exactly(' ')
                self.considerError(lastError, None)
                return (_G_exactly_9, self.currentError)
            def _G_or_10():
                self._trace(" '\\t'", (46, 51), self.input.position)
                _G_exactly_11, lastError = self.exactly('\t')
                self.considerError(lastError, None)
                return (_G_exactly_11, self.currentError)
            def _G_or_12():
                self._trace(' comment', (53, 61), self.input.position)
                _G_apply_13, lastError = self._apply(self.rule_comment, "comment", [])
                self.considerError(lastError, None)
                return (_G_apply_13, self.currentError)
            _G_or_14, lastError = self._or([_G_or_8, _G_or_10, _G_or_12])
            self.considerError(lastError, 'hspace')
            return (_G_or_14, self.currentError)


        def rule_vspace(self):
            _locals = {'self': self}
            self.locals['vspace'] = _locals
            def _G_or_15():
                self._trace("  '\\r\\n'", (70, 78), self.input.position)
                _G_exactly_16, lastError = self.exactly('\r\n')
                self.considerError(lastError, None)
                return (_G_exactly_16, self.currentError)
            def _G_or_17():
                self._trace(" '\\r'", (80, 85), self.input.position)
                _G_exactly_18, lastError = self.exactly('\r')
                self.considerError(lastError, None)
                return (_G_exactly_18, self.currentError)
            def _G_or_19():
                self._trace(" '\\n'", (87, 92), self.input.position)
                _G_exactly_20, lastError = self.exactly('\n')
                self.considerError(lastError, None)
                return (_G_exactly_20, self.currentError)
            _G_or_21, lastError = self._or([_G_or_15, _G_or_17, _G_or_19])
            self.considerError(lastError, 'vspace')
            return (_G_or_21, self.currentError)


        def rule_ws(self):
            _locals = {'self': self}
            self.locals['ws'] = _locals
            def _G_many_22():
                def _G_or_23():
                    self._trace('hspace', (99, 105), self.input.position)
                    _G_apply_24, lastError = self._apply(self.rule_hspace, "hspace", [])
                    self.considerError(lastError, None)
                    return (_G_apply_24, self.currentError)
                def _G_or_25():
                    self._trace(' vspace', (107, 114), self.input.position)
                    _G_apply_26, lastError = self._apply(self.rule_vspace, "vspace", [])
                    self.considerError(lastError, None)
                    return (_G_apply_26, self.currentError)
                def _G_or_27():
                    self._trace(' comment', (116, 124), self.input.position)
                    _G_apply_28, lastError = self._apply(self.rule_comment, "comment", [])
                    self.considerError(lastError, None)
                    return (_G_apply_28, self.currentError)
                _G_or_29, lastError = self._or([_G_or_23, _G_or_25, _G_or_27])
                self.considerError(lastError, None)
                return (_G_or_29, self.currentError)
            _G_many_30, lastError = self.many(_G_many_22)
            self.considerError(lastError, 'ws')
            return (_G_many_30, self.currentError)


        def rule_number(self):
            _locals = {'self': self}
            self.locals['number'] = _locals
            self._trace(' ws', (136, 139), self.input.position)
            _G_apply_31, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'number')
            def _G_or_32():
                self._trace("'-'", (141, 144), self.input.position)
                _G_exactly_33, lastError = self.exactly('-')
                self.considerError(lastError, None)
                self._trace(' barenumber', (144, 155), self.input.position)
                _G_apply_34, lastError = self._apply(self.rule_barenumber, "barenumber", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_34
                _G_python_35, lastError = eval('t.Exactly(-x)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_35, self.currentError)
            def _G_or_36():
                self._trace('barenumber', (192, 202), self.input.position)
                _G_apply_37, lastError = self._apply(self.rule_barenumber, "barenumber", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_37
                _G_python_38, lastError = eval('t.Exactly(x)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_38, self.currentError)
            _G_or_39, lastError = self._or([_G_or_32, _G_or_36])
            self.considerError(lastError, 'number')
            return (_G_or_39, self.currentError)


        def rule_barenumber(self):
            _locals = {'self': self}
            self.locals['barenumber'] = _locals
            def _G_or_40():
                self._trace(" '0'", (234, 238), self.input.position)
                _G_exactly_41, lastError = self.exactly('0')
                self.considerError(lastError, None)
                def _G_or_42():
                    def _G_or_43():
                        self._trace("'x'", (241, 244), self.input.position)
                        _G_exactly_44, lastError = self.exactly('x')
                        self.considerError(lastError, None)
                        return (_G_exactly_44, self.currentError)
                    def _G_or_45():
                        self._trace("'X'", (245, 248), self.input.position)
                        _G_exactly_46, lastError = self.exactly('X')
                        self.considerError(lastError, None)
                        return (_G_exactly_46, self.currentError)
                    _G_or_47, lastError = self._or([_G_or_43, _G_or_45])
                    self.considerError(lastError, None)
                    def _G_consumedby_48():
                        def _G_many1_49():
                            self._trace('hexdigit', (251, 259), self.input.position)
                            _G_apply_50, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                            self.considerError(lastError, None)
                            return (_G_apply_50, self.currentError)
                        _G_many1_51, lastError = self.many(_G_many1_49, _G_many1_49())
                        self.considerError(lastError, None)
                        return (_G_many1_51, self.currentError)
                    _G_consumedby_52, lastError = self.consumedby(_G_consumedby_48)
                    self.considerError(lastError, None)
                    _locals['hs'] = _G_consumedby_52
                    _G_python_53, lastError = eval('int(hs, 16)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_53, self.currentError)
                def _G_or_54():
                    def _G_consumedby_55():
                        def _G_many1_56():
                            self._trace('octaldigit', (302, 312), self.input.position)
                            _G_apply_57, lastError = self._apply(self.rule_octaldigit, "octaldigit", [])
                            self.considerError(lastError, None)
                            return (_G_apply_57, self.currentError)
                        _G_many1_58, lastError = self.many(_G_many1_56, _G_many1_56())
                        self.considerError(lastError, None)
                        return (_G_many1_58, self.currentError)
                    _G_consumedby_59, lastError = self.consumedby(_G_consumedby_55)
                    self.considerError(lastError, None)
                    _locals['ds'] = _G_consumedby_59
                    _G_python_60, lastError = eval('int(ds, 8)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_60, self.currentError)
                _G_or_61, lastError = self._or([_G_or_42, _G_or_54])
                self.considerError(lastError, None)
                return (_G_or_61, self.currentError)
            def _G_or_62():
                def _G_consumedby_63():
                    def _G_many1_64():
                        self._trace('digit', (350, 355), self.input.position)
                        _G_apply_65, lastError = self._apply(self.rule_digit, "digit", [])
                        self.considerError(lastError, None)
                        return (_G_apply_65, self.currentError)
                    _G_many1_66, lastError = self.many(_G_many1_64, _G_many1_64())
                    self.considerError(lastError, None)
                    return (_G_many1_66, self.currentError)
                _G_consumedby_67, lastError = self.consumedby(_G_consumedby_63)
                self.considerError(lastError, None)
                _locals['ds'] = _G_consumedby_67
                _G_python_68, lastError = eval('int(ds)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_68, self.currentError)
            _G_or_69, lastError = self._or([_G_or_40, _G_or_62])
            self.considerError(lastError, 'barenumber')
            return (_G_or_69, self.currentError)


        def rule_octaldigit(self):
            _locals = {'self': self}
            self.locals['octaldigit'] = _locals
            _G_apply_70, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'octaldigit')
            _locals['x'] = _G_apply_70
            def _G_pred_71():
                _G_python_72, lastError = eval("x in '01234567'", self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_72, self.currentError)
            _G_pred_73, lastError = self.pred(_G_pred_71)
            self.considerError(lastError, 'octaldigit')
            _G_python_74, lastError = eval('x', self.globals, _locals), None
            self.considerError(lastError, 'octaldigit')
            return (_G_python_74, self.currentError)


        def rule_hexdigit(self):
            _locals = {'self': self}
            self.locals['hexdigit'] = _locals
            _G_apply_75, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'hexdigit')
            _locals['x'] = _G_apply_75
            def _G_pred_76():
                _G_python_77, lastError = eval("x in '0123456789ABCDEFabcdef'", self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_77, self.currentError)
            _G_pred_78, lastError = self.pred(_G_pred_76)
            self.considerError(lastError, 'hexdigit')
            _G_python_79, lastError = eval('x', self.globals, _locals), None
            self.considerError(lastError, 'hexdigit')
            return (_G_python_79, self.currentError)


        def rule_escapedChar(self):
            _locals = {'self': self}
            self.locals['escapedChar'] = _locals
            self._trace(" '\\\\'", (479, 484), self.input.position)
            _G_exactly_80, lastError = self.exactly('\\')
            self.considerError(lastError, 'escapedChar')
            def _G_or_81():
                self._trace("'n'", (486, 489), self.input.position)
                _G_exactly_82, lastError = self.exactly('n')
                self.considerError(lastError, None)
                _G_python_83, lastError = ("\n"), None
                self.considerError(lastError, None)
                return (_G_python_83, self.currentError)
            def _G_or_84():
                self._trace("'r'", (520, 523), self.input.position)
                _G_exactly_85, lastError = self.exactly('r')
                self.considerError(lastError, None)
                _G_python_86, lastError = ("\r"), None
                self.considerError(lastError, None)
                return (_G_python_86, self.currentError)
            def _G_or_87():
                self._trace("'t'", (554, 557), self.input.position)
                _G_exactly_88, lastError = self.exactly('t')
                self.considerError(lastError, None)
                _G_python_89, lastError = ("\t"), None
                self.considerError(lastError, None)
                return (_G_python_89, self.currentError)
            def _G_or_90():
                self._trace("'b'", (588, 591), self.input.position)
                _G_exactly_91, lastError = self.exactly('b')
                self.considerError(lastError, None)
                _G_python_92, lastError = ("\b"), None
                self.considerError(lastError, None)
                return (_G_python_92, self.currentError)
            def _G_or_93():
                self._trace("'f'", (622, 625), self.input.position)
                _G_exactly_94, lastError = self.exactly('f')
                self.considerError(lastError, None)
                _G_python_95, lastError = ("\f"), None
                self.considerError(lastError, None)
                return (_G_python_95, self.currentError)
            def _G_or_96():
                self._trace('\'"\'', (656, 659), self.input.position)
                _G_exactly_97, lastError = self.exactly('"')
                self.considerError(lastError, None)
                _G_python_98, lastError = ('"'), None
                self.considerError(lastError, None)
                return (_G_python_98, self.currentError)
            def _G_or_99():
                self._trace("'\\''", (689, 693), self.input.position)
                _G_exactly_100, lastError = self.exactly("'")
                self.considerError(lastError, None)
                _G_python_101, lastError = ("'"), None
                self.considerError(lastError, None)
                return (_G_python_101, self.currentError)
            def _G_or_102():
                self._trace("'\\\\'", (723, 727), self.input.position)
                _G_exactly_103, lastError = self.exactly('\\')
                self.considerError(lastError, None)
                _G_python_104, lastError = ("\\"), None
                self.considerError(lastError, None)
                return (_G_python_104, self.currentError)
            _G_or_105, lastError = self._or([_G_or_81, _G_or_84, _G_or_87, _G_or_90, _G_or_93, _G_or_96, _G_or_99, _G_or_102])
            self.considerError(lastError, 'escapedChar')
            return (_G_or_105, self.currentError)


        def rule_character(self):
            _locals = {'self': self}
            self.locals['character'] = _locals
            self._trace(' ws', (749, 752), self.input.position)
            _G_apply_106, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'character')
            self._trace(" '\\''", (752, 757), self.input.position)
            _G_exactly_107, lastError = self.exactly("'")
            self.considerError(lastError, 'character')
            def _G_or_108():
                self._trace('escapedChar', (759, 770), self.input.position)
                _G_apply_109, lastError = self._apply(self.rule_escapedChar, "escapedChar", [])
                self.considerError(lastError, None)
                return (_G_apply_109, self.currentError)
            def _G_or_110():
                self._trace(' anything', (772, 781), self.input.position)
                _G_apply_111, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                return (_G_apply_111, self.currentError)
            _G_or_112, lastError = self._or([_G_or_108, _G_or_110])
            self.considerError(lastError, 'character')
            _locals['c'] = _G_or_112
            self._trace(' ws', (784, 787), self.input.position)
            _G_apply_113, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'character')
            self._trace(" '\\''", (787, 792), self.input.position)
            _G_exactly_114, lastError = self.exactly("'")
            self.considerError(lastError, 'character')
            _G_python_115, lastError = eval('t.Exactly(c)', self.globals, _locals), None
            self.considerError(lastError, 'character')
            return (_G_python_115, self.currentError)


        def rule_string(self):
            _locals = {'self': self}
            self.locals['string'] = _locals
            self._trace(' ws', (818, 821), self.input.position)
            _G_apply_116, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'string')
            self._trace(' \'"\'', (821, 825), self.input.position)
            _G_exactly_117, lastError = self.exactly('"')
            self.considerError(lastError, 'string')
            def _G_many_118():
                def _G_or_119():
                    self._trace('escapedChar', (827, 838), self.input.position)
                    _G_apply_120, lastError = self._apply(self.rule_escapedChar, "escapedChar", [])
                    self.considerError(lastError, None)
                    return (_G_apply_120, self.currentError)
                def _G_or_121():
                    def _G_not_122():
                        self._trace('\'"\'', (843, 846), self.input.position)
                        _G_exactly_123, lastError = self.exactly('"')
                        self.considerError(lastError, None)
                        return (_G_exactly_123, self.currentError)
                    _G_not_124, lastError = self._not(_G_not_122)
                    self.considerError(lastError, None)
                    self._trace(' anything', (847, 856), self.input.position)
                    _G_apply_125, lastError = self._apply(self.rule_anything, "anything", [])
                    self.considerError(lastError, None)
                    return (_G_apply_125, self.currentError)
                _G_or_126, lastError = self._or([_G_or_119, _G_or_121])
                self.considerError(lastError, None)
                return (_G_or_126, self.currentError)
            _G_many_127, lastError = self.many(_G_many_118)
            self.considerError(lastError, 'string')
            _locals['c'] = _G_many_127
            self._trace(' \'"\'', (860, 864), self.input.position)
            _G_exactly_128, lastError = self.exactly('"')
            self.considerError(lastError, 'string')
            _G_python_129, lastError = eval("t.Exactly(''.join(c))", self.globals, _locals), None
            self.considerError(lastError, 'string')
            return (_G_python_129, self.currentError)


        def rule_name(self):
            _locals = {'self': self}
            self.locals['name'] = _locals
            def _G_consumedby_130():
                self._trace('letter', (899, 905), self.input.position)
                _G_apply_131, lastError = self._apply(self.rule_letter, "letter", [])
                self.considerError(lastError, None)
                def _G_many_132():
                    def _G_or_133():
                        self._trace('letterOrDigit', (907, 920), self.input.position)
                        _G_apply_134, lastError = self._apply(self.rule_letterOrDigit, "letterOrDigit", [])
                        self.considerError(lastError, None)
                        return (_G_apply_134, self.currentError)
                    def _G_or_135():
                        self._trace(" '_'", (922, 926), self.input.position)
                        _G_exactly_136, lastError = self.exactly('_')
                        self.considerError(lastError, None)
                        return (_G_exactly_136, self.currentError)
                    _G_or_137, lastError = self._or([_G_or_133, _G_or_135])
                    self.considerError(lastError, None)
                    return (_G_or_137, self.currentError)
                _G_many_138, lastError = self.many(_G_many_132)
                self.considerError(lastError, None)
                return (_G_many_138, self.currentError)
            _G_consumedby_139, lastError = self.consumedby(_G_consumedby_130)
            self.considerError(lastError, 'name')
            return (_G_consumedby_139, self.currentError)


        def rule_application(self):
            _locals = {'self': self}
            self.locals['application'] = _locals
            self._trace('ws', (945, 947), self.input.position)
            _G_apply_140, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'application')
            self._trace(" '<'", (947, 951), self.input.position)
            _G_exactly_141, lastError = self.exactly('<')
            self.considerError(lastError, 'application')
            self._trace(' ws', (951, 954), self.input.position)
            _G_apply_142, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'application')
            self._trace(' name', (954, 959), self.input.position)
            _G_apply_143, lastError = self._apply(self.rule_name, "name", [])
            self.considerError(lastError, 'application')
            _locals['name'] = _G_apply_143
            def _G_or_144():
                self._trace("' '", (984, 987), self.input.position)
                _G_exactly_145, lastError = self.exactly(' ')
                self.considerError(lastError, None)
                _G_python_146, lastError = eval("self.applicationArgs(finalChar='>')", self.globals, _locals), None
                self.considerError(lastError, None)
                _locals['args'] = _G_python_146
                self._trace(" '>'", (1031, 1035), self.input.position)
                _G_exactly_147, lastError = self.exactly('>')
                self.considerError(lastError, None)
                _G_python_148, lastError = eval('t.Apply(name, self.rulename, args)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_148, self.currentError)
            def _G_or_149():
                self._trace('ws', (1114, 1116), self.input.position)
                _G_apply_150, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '>'", (1116, 1120), self.input.position)
                _G_exactly_151, lastError = self.exactly('>')
                self.considerError(lastError, None)
                _G_python_152, lastError = eval('t.Apply(name, self.rulename, [])', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_152, self.currentError)
            _G_or_153, lastError = self._or([_G_or_144, _G_or_149])
            self.considerError(lastError, 'application')
            return (_G_or_153, self.currentError)


        def rule_expr1(self):
            _locals = {'self': self}
            self.locals['expr1'] = _locals
            def _G_or_154():
                self._trace('application', (1190, 1201), self.input.position)
                _G_apply_155, lastError = self._apply(self.rule_application, "application", [])
                self.considerError(lastError, None)
                return (_G_apply_155, self.currentError)
            def _G_or_156():
                self._trace('ruleValue', (1213, 1222), self.input.position)
                _G_apply_157, lastError = self._apply(self.rule_ruleValue, "ruleValue", [])
                self.considerError(lastError, None)
                return (_G_apply_157, self.currentError)
            def _G_or_158():
                self._trace('semanticPredicate', (1234, 1251), self.input.position)
                _G_apply_159, lastError = self._apply(self.rule_semanticPredicate, "semanticPredicate", [])
                self.considerError(lastError, None)
                return (_G_apply_159, self.currentError)
            def _G_or_160():
                self._trace('semanticAction', (1263, 1277), self.input.position)
                _G_apply_161, lastError = self._apply(self.rule_semanticAction, "semanticAction", [])
                self.considerError(lastError, None)
                return (_G_apply_161, self.currentError)
            def _G_or_162():
                self._trace('number', (1289, 1295), self.input.position)
                _G_apply_163, lastError = self._apply(self.rule_number, "number", [])
                self.considerError(lastError, None)
                _locals['n'] = _G_apply_163
                _G_python_164, lastError = eval('self.isTree()', self.globals, _locals), None
                self.considerError(lastError, None)
                _G_python_165, lastError = eval('n', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_165, self.currentError)
            def _G_or_166():
                self._trace('character', (1331, 1340), self.input.position)
                _G_apply_167, lastError = self._apply(self.rule_character, "character", [])
                self.considerError(lastError, None)
                return (_G_apply_167, self.currentError)
            def _G_or_168():
                self._trace('string', (1352, 1358), self.input.position)
                _G_apply_169, lastError = self._apply(self.rule_string, "string", [])
                self.considerError(lastError, None)
                return (_G_apply_169, self.currentError)
            def _G_or_170():
                self._trace('ws', (1370, 1372), self.input.position)
                _G_apply_171, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '('", (1372, 1376), self.input.position)
                _G_exactly_172, lastError = self.exactly('(')
                self.considerError(lastError, None)
                self._trace(' expr', (1376, 1381), self.input.position)
                _G_apply_173, lastError = self._apply(self.rule_expr, "expr", [])
                self.considerError(lastError, None)
                _locals['e'] = _G_apply_173
                self._trace(' ws', (1383, 1386), self.input.position)
                _G_apply_174, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" ')'", (1386, 1390), self.input.position)
                _G_exactly_175, lastError = self.exactly(')')
                self.considerError(lastError, None)
                _G_python_176, lastError = eval('e', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_176, self.currentError)
            def _G_or_177():
                self._trace('ws', (1408, 1410), self.input.position)
                _G_apply_178, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '['", (1410, 1414), self.input.position)
                _G_exactly_179, lastError = self.exactly('[')
                self.considerError(lastError, None)
                self._trace(' expr', (1414, 1419), self.input.position)
                _G_apply_180, lastError = self._apply(self.rule_expr, "expr", [])
                self.considerError(lastError, None)
                _locals['e'] = _G_apply_180
                self._trace(' ws', (1421, 1424), self.input.position)
                _G_apply_181, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" ']'", (1424, 1428), self.input.position)
                _G_exactly_182, lastError = self.exactly(']')
                self.considerError(lastError, None)
                _G_python_183, lastError = eval('self.isTree()', self.globals, _locals), None
                self.considerError(lastError, None)
                _G_python_184, lastError = eval('t.List(e)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_184, self.currentError)
            _G_or_185, lastError = self._or([_G_or_154, _G_or_156, _G_or_158, _G_or_160, _G_or_162, _G_or_166, _G_or_168, _G_or_170, _G_or_177])
            self.considerError(lastError, 'expr1')
            return (_G_or_185, self.currentError)


        def rule_expr2(self):
            _locals = {'self': self}
            self.locals['expr2'] = _locals
            def _G_or_186():
                self._trace('ws', (1485, 1487), self.input.position)
                _G_apply_187, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '~'", (1487, 1491), self.input.position)
                _G_exactly_188, lastError = self.exactly('~')
                self.considerError(lastError, None)
                def _G_or_189():
                    self._trace("'~'", (1493, 1496), self.input.position)
                    _G_exactly_190, lastError = self.exactly('~')
                    self.considerError(lastError, None)
                    self._trace(' expr2', (1496, 1502), self.input.position)
                    _G_apply_191, lastError = self._apply(self.rule_expr2, "expr2", [])
                    self.considerError(lastError, None)
                    _locals['e'] = _G_apply_191
                    _G_python_192, lastError = eval('t.Lookahead(e)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_192, self.currentError)
                def _G_or_193():
                    self._trace('expr2', (1568, 1573), self.input.position)
                    _G_apply_194, lastError = self._apply(self.rule_expr2, "expr2", [])
                    self.considerError(lastError, None)
                    _locals['e'] = _G_apply_194
                    _G_python_195, lastError = eval('t.Not(e)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_195, self.currentError)
                _G_or_196, lastError = self._or([_G_or_189, _G_or_193])
                self.considerError(lastError, None)
                return (_G_or_196, self.currentError)
            def _G_or_197():
                self._trace('expr1', (1598, 1603), self.input.position)
                _G_apply_198, lastError = self._apply(self.rule_expr1, "expr1", [])
                self.considerError(lastError, None)
                return (_G_apply_198, self.currentError)
            _G_or_199, lastError = self._or([_G_or_186, _G_or_197])
            self.considerError(lastError, 'expr2')
            return (_G_or_199, self.currentError)


        def rule_expr3(self):
            _locals = {'self': self}
            self.locals['expr3'] = _locals
            def _G_or_200():
                self._trace(' expr2', (1613, 1619), self.input.position)
                _G_apply_201, lastError = self._apply(self.rule_expr2, "expr2", [])
                self.considerError(lastError, None)
                _locals['e'] = _G_apply_201
                def _G_or_202():
                    self._trace("'*'", (1637, 1640), self.input.position)
                    _G_exactly_203, lastError = self.exactly('*')
                    self.considerError(lastError, None)
                    _G_python_204, lastError = eval('t.Many(e)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_204, self.currentError)
                def _G_or_205():
                    self._trace("'+'", (1669, 1672), self.input.position)
                    _G_exactly_206, lastError = self.exactly('+')
                    self.considerError(lastError, None)
                    _G_python_207, lastError = eval('t.Many1(e)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_207, self.currentError)
                def _G_or_208():
                    self._trace("'?'", (1702, 1705), self.input.position)
                    _G_exactly_209, lastError = self.exactly('?')
                    self.considerError(lastError, None)
                    _G_python_210, lastError = eval('t.Optional(e)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_210, self.currentError)
                def _G_or_211():
                    _G_python_212, lastError = eval('e', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_212, self.currentError)
                _G_or_213, lastError = self._or([_G_or_202, _G_or_205, _G_or_208, _G_or_211])
                self.considerError(lastError, None)
                _locals['r'] = _G_or_213
                def _G_or_214():
                    self._trace("':'", (1759, 1762), self.input.position)
                    _G_exactly_215, lastError = self.exactly(':')
                    self.considerError(lastError, None)
                    self._trace(' name', (1762, 1767), self.input.position)
                    _G_apply_216, lastError = self._apply(self.rule_name, "name", [])
                    self.considerError(lastError, None)
                    _locals['n'] = _G_apply_216
                    _G_python_217, lastError = eval('t.Bind(n, r)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_217, self.currentError)
                def _G_or_218():
                    _G_python_219, lastError = eval('r', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_219, self.currentError)
                _G_or_220, lastError = self._or([_G_or_214, _G_or_218])
                self.considerError(lastError, None)
                return (_G_or_220, self.currentError)
            def _G_or_221():
                self._trace('ws', (1818, 1820), self.input.position)
                _G_apply_222, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" ':'", (1820, 1824), self.input.position)
                _G_exactly_223, lastError = self.exactly(':')
                self.considerError(lastError, None)
                self._trace(' name', (1824, 1829), self.input.position)
                _G_apply_224, lastError = self._apply(self.rule_name, "name", [])
                self.considerError(lastError, None)
                _locals['n'] = _G_apply_224
                _G_python_225, lastError = eval('t.Bind(n, t.Apply("anything", self.rulename, []))', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_225, self.currentError)
            _G_or_226, lastError = self._or([_G_or_200, _G_or_221])
            self.considerError(lastError, 'expr3')
            return (_G_or_226, self.currentError)


        def rule_expr4(self):
            _locals = {'self': self}
            self.locals['expr4'] = _locals
            def _G_many_227():
                self._trace(' expr3', (1894, 1900), self.input.position)
                _G_apply_228, lastError = self._apply(self.rule_expr3, "expr3", [])
                self.considerError(lastError, None)
                return (_G_apply_228, self.currentError)
            _G_many_229, lastError = self.many(_G_many_227)
            self.considerError(lastError, 'expr4')
            _locals['es'] = _G_many_229
            _G_python_230, lastError = eval('t.And(es)', self.globals, _locals), None
            self.considerError(lastError, 'expr4')
            return (_G_python_230, self.currentError)


        def rule_expr(self):
            _locals = {'self': self}
            self.locals['expr'] = _locals
            self._trace('  expr4', (1925, 1932), self.input.position)
            _G_apply_231, lastError = self._apply(self.rule_expr4, "expr4", [])
            self.considerError(lastError, 'expr')
            _locals['e'] = _G_apply_231
            def _G_many_232():
                self._trace('ws', (1936, 1938), self.input.position)
                _G_apply_233, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '|'", (1938, 1942), self.input.position)
                _G_exactly_234, lastError = self.exactly('|')
                self.considerError(lastError, None)
                self._trace(' expr4', (1942, 1948), self.input.position)
                _G_apply_235, lastError = self._apply(self.rule_expr4, "expr4", [])
                self.considerError(lastError, None)
                return (_G_apply_235, self.currentError)
            _G_many_236, lastError = self.many(_G_many_232)
            self.considerError(lastError, 'expr')
            _locals['es'] = _G_many_236
            _G_python_237, lastError = eval('t.Or([e] + es)', self.globals, _locals), None
            self.considerError(lastError, 'expr')
            return (_G_python_237, self.currentError)


        def rule_ruleValue(self):
            _locals = {'self': self}
            self.locals['ruleValue'] = _locals
            self._trace(' ws', (1994, 1997), self.input.position)
            _G_apply_238, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'ruleValue')
            self._trace(" '=>'", (1997, 2002), self.input.position)
            _G_exactly_239, lastError = self.exactly('=>')
            self.considerError(lastError, 'ruleValue')
            _G_python_240, lastError = eval('self.ruleValueExpr(False)', self.globals, _locals), None
            self.considerError(lastError, 'ruleValue')
            return (_G_python_240, self.currentError)


        def rule_semanticPredicate(self):
            _locals = {'self': self}
            self.locals['semanticPredicate'] = _locals
            self._trace('  ws', (2052, 2056), self.input.position)
            _G_apply_241, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'semanticPredicate')
            self._trace(" '?('", (2056, 2061), self.input.position)
            _G_exactly_242, lastError = self.exactly('?(')
            self.considerError(lastError, 'semanticPredicate')
            _G_python_243, lastError = eval('self.semanticPredicateExpr()', self.globals, _locals), None
            self.considerError(lastError, 'semanticPredicate')
            return (_G_python_243, self.currentError)


        def rule_semanticAction(self):
            _locals = {'self': self}
            self.locals['semanticAction'] = _locals
            self._trace(' ws', (2111, 2114), self.input.position)
            _G_apply_244, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'semanticAction')
            self._trace(" '!('", (2114, 2119), self.input.position)
            _G_exactly_245, lastError = self.exactly('!(')
            self.considerError(lastError, 'semanticAction')
            _G_python_246, lastError = eval('self.semanticActionExpr()', self.globals, _locals), None
            self.considerError(lastError, 'semanticAction')
            return (_G_python_246, self.currentError)


        def rule_ruleEnd(self):
            _locals = {'self': self}
            self.locals['ruleEnd'] = _locals
            def _G_or_247():
                def _G_many_248():
                    self._trace('hspace', (2161, 2167), self.input.position)
                    _G_apply_249, lastError = self._apply(self.rule_hspace, "hspace", [])
                    self.considerError(lastError, None)
                    return (_G_apply_249, self.currentError)
                _G_many_250, lastError = self.many(_G_many_248)
                self.considerError(lastError, None)
                def _G_many1_251():
                    self._trace(' vspace', (2168, 2175), self.input.position)
                    _G_apply_252, lastError = self._apply(self.rule_vspace, "vspace", [])
                    self.considerError(lastError, None)
                    return (_G_apply_252, self.currentError)
                _G_many1_253, lastError = self.many(_G_many1_251, _G_many1_251())
                self.considerError(lastError, None)
                return (_G_many1_253, self.currentError)
            def _G_or_254():
                self._trace(' end', (2179, 2183), self.input.position)
                _G_apply_255, lastError = self._apply(self.rule_end, "end", [])
                self.considerError(lastError, None)
                return (_G_apply_255, self.currentError)
            _G_or_256, lastError = self._or([_G_or_247, _G_or_254])
            self.considerError(lastError, 'ruleEnd')
            return (_G_or_256, self.currentError)


        def rule_rulePart(self):
            _locals = {'self': self}
            self.locals['rulePart'] = _locals
            _G_apply_257, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'rulePart')
            _locals['requiredName'] = _G_apply_257
            self._trace(' ws', (2208, 2211), self.input.position)
            _G_apply_258, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'rulePart')
            self._trace(' name', (2211, 2216), self.input.position)
            _G_apply_259, lastError = self._apply(self.rule_name, "name", [])
            self.considerError(lastError, 'rulePart')
            _locals['n'] = _G_apply_259
            def _G_pred_260():
                _G_python_261, lastError = eval('n == requiredName', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_261, self.currentError)
            _G_pred_262, lastError = self.pred(_G_pred_260)
            self.considerError(lastError, 'rulePart')
            _G_python_263, lastError = eval('setattr(self, "rulename", n)', self.globals, _locals), None
            self.considerError(lastError, 'rulePart')
            self._trace('\n                            expr4', (2299, 2333), self.input.position)
            _G_apply_264, lastError = self._apply(self.rule_expr4, "expr4", [])
            self.considerError(lastError, 'rulePart')
            _locals['args'] = _G_apply_264
            def _G_or_265():
                self._trace('ws', (2368, 2370), self.input.position)
                _G_apply_266, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '::='", (2370, 2376), self.input.position)
                _G_exactly_267, lastError = self.exactly('::=')
                self.considerError(lastError, None)
                self._trace(' expr', (2376, 2381), self.input.position)
                _G_apply_268, lastError = self._apply(self.rule_expr, "expr", [])
                self.considerError(lastError, None)
                _locals['e'] = _G_apply_268
                self._trace(' ruleEnd', (2383, 2391), self.input.position)
                _G_apply_269, lastError = self._apply(self.rule_ruleEnd, "ruleEnd", [])
                self.considerError(lastError, None)
                _G_python_270, lastError = eval('t.And([args, e])', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_270, self.currentError)
            def _G_or_271():
                self._trace(' ruleEnd', (2472, 2480), self.input.position)
                _G_apply_272, lastError = self._apply(self.rule_ruleEnd, "ruleEnd", [])
                self.considerError(lastError, None)
                _G_python_273, lastError = eval('args', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_273, self.currentError)
            _G_or_274, lastError = self._or([_G_or_265, _G_or_271])
            self.considerError(lastError, 'rulePart')
            return (_G_or_274, self.currentError)


        def rule_rule(self):
            _locals = {'self': self}
            self.locals['rule'] = _locals
            self._trace('ws', (2498, 2500), self.input.position)
            _G_apply_275, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'rule')
            def _G_lookahead_276():
                self._trace('name', (2504, 2508), self.input.position)
                _G_apply_277, lastError = self._apply(self.rule_name, "name", [])
                self.considerError(lastError, None)
                _locals['n'] = _G_apply_277
                return (_locals['n'], self.currentError)
            _G_lookahead_278, lastError = self.lookahead(_G_lookahead_276)
            self.considerError(lastError, 'rule')
            self._trace(' rulePart(n)', (2511, 2523), self.input.position)
            _G_python_279, lastError = eval('n', self.globals, _locals), None
            self.considerError(lastError, 'rule')
            _G_apply_280, lastError = self._apply(self.rule_rulePart, "rulePart", [_G_python_279])
            self.considerError(lastError, 'rule')
            _locals['r'] = _G_apply_280
            def _G_or_281():
                def _G_many1_282():
                    self._trace('rulePart(n)', (2537, 2548), self.input.position)
                    _G_python_283, lastError = eval('n', self.globals, _locals), None
                    self.considerError(lastError, None)
                    _G_apply_284, lastError = self._apply(self.rule_rulePart, "rulePart", [_G_python_283])
                    self.considerError(lastError, None)
                    return (_G_apply_284, self.currentError)
                _G_many1_285, lastError = self.many(_G_many1_282, _G_many1_282())
                self.considerError(lastError, None)
                _locals['rs'] = _G_many1_285
                _G_python_286, lastError = eval('t.Rule(n, t.Or([r] + rs))', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_286, self.currentError)
            def _G_or_287():
                _G_python_288, lastError = eval('t.Rule(n, r)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_288, self.currentError)
            _G_or_289, lastError = self._or([_G_or_281, _G_or_287])
            self.considerError(lastError, 'rule')
            return (_G_or_289, self.currentError)


        def rule_grammar(self):
            _locals = {'self': self}
            self.locals['grammar'] = _locals
            def _G_many_290():
                self._trace(' rule', (2642, 2647), self.input.position)
                _G_apply_291, lastError = self._apply(self.rule_rule, "rule", [])
                self.considerError(lastError, None)
                return (_G_apply_291, self.currentError)
            _G_many_292, lastError = self.many(_G_many_290)
            self.considerError(lastError, 'grammar')
            _locals['rs'] = _G_many_292
            self._trace(' ws', (2651, 2654), self.input.position)
            _G_apply_293, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'grammar')
            _G_python_294, lastError = eval('t.Grammar(self.name, self.tree_target, rs)', self.globals, _locals), None
            self.considerError(lastError, 'grammar')
            return (_G_python_294, self.currentError)


    if pymeta_v1.globals is not None:
        pymeta_v1.globals = pymeta_v1.globals.copy()
        pymeta_v1.globals.update(ruleGlobals)
    else:
        pymeta_v1.globals = ruleGlobals
    return pymeta_v1
########NEW FILE########
__FILENAME__ = vm
def createParserClass(GrammarBase, ruleGlobals):
    if ruleGlobals is None:
        ruleGlobals = {}
    class vm(GrammarBase):
        def rule_Exactly(self):
            _locals = {'self': self}
            self.locals['Exactly'] = _locals
            def _G_termpattern_1():
                _G_apply_2, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_2
                return (_locals['x'], self.currentError)
            _G_termpattern_3, lastError = self.termpattern('Exactly', _G_termpattern_1)
            self.considerError(lastError, 'Exactly')
            _G_python_4, lastError = eval('[t.Match(x)]', self.globals, _locals), None
            self.considerError(lastError, 'Exactly')
            return (_G_python_4, self.currentError)


        def rule_Token(self):
            _locals = {'self': self}
            self.locals['Token'] = _locals
            def _G_termpattern_5():
                _G_apply_6, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_6
                return (_locals['x'], self.currentError)
            _G_termpattern_7, lastError = self.termpattern('Token', _G_termpattern_5)
            self.considerError(lastError, 'Token')
            _G_python_8, lastError = eval('[t.Match(x)]', self.globals, _locals), None
            self.considerError(lastError, 'Token')
            return (_G_python_8, self.currentError)


        def rule_Many(self):
            _locals = {'self': self}
            self.locals['Many'] = _locals
            def _G_termpattern_9():
                _G_apply_10, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_10
                return (_locals['x'], self.currentError)
            _G_termpattern_11, lastError = self.termpattern('Many', _G_termpattern_9)
            self.considerError(lastError, 'Many')
            _G_python_12, lastError = eval('[t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]', self.globals, _locals), None
            self.considerError(lastError, 'Many')
            return (_G_python_12, self.currentError)


        def rule_Many1(self):
            _locals = {'self': self}
            self.locals['Many1'] = _locals
            def _G_termpattern_13():
                _G_apply_14, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_14
                return (_locals['x'], self.currentError)
            _G_termpattern_15, lastError = self.termpattern('Many1', _G_termpattern_13)
            self.considerError(lastError, 'Many1')
            _G_python_16, lastError = eval('x + [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]', self.globals, _locals), None
            self.considerError(lastError, 'Many1')
            return (_G_python_16, self.currentError)


        def rule_Repeat(self):
            _locals = {'self': self}
            self.locals['Repeat'] = _locals
            def _G_termpattern_17():
                _G_apply_18, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['min'] = _G_apply_18
                _G_apply_19, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['max'] = _G_apply_19
                _G_apply_20, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_20
                return (_locals['x'], self.currentError)
            _G_termpattern_21, lastError = self.termpattern('Repeat', _G_termpattern_17)
            self.considerError(lastError, 'Repeat')
            _G_python_22, lastError = eval('[t.Python(repr(int(min))), t.Push(), t.Python(repr(int(max))),\n        t.Push(), t.RepeatChoice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]', self.globals, _locals), None
            self.considerError(lastError, 'Repeat')
            return (_G_python_22, self.currentError)


        def rule_Optional(self):
            _locals = {'self': self}
            self.locals['Optional'] = _locals
            def _G_termpattern_23():
                _G_apply_24, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_24
                return (_locals['x'], self.currentError)
            _G_termpattern_25, lastError = self.termpattern('Optional', _G_termpattern_23)
            self.considerError(lastError, 'Optional')
            _G_python_26, lastError = eval('[t.Choice(len(x) + 2)] + x + [t.Commit(2), t.Python("None")]', self.globals, _locals), None
            self.considerError(lastError, 'Optional')
            return (_G_python_26, self.currentError)


        def rule_Or(self):
            _locals = {'self': self}
            self.locals['Or'] = _locals
            def _G_or_27():
                def _G_termpattern_28():
                    _G_apply_29, lastError = self._apply(self.rule_transform, "transform", [])
                    self.considerError(lastError, None)
                    _locals['xs'] = _G_apply_29
                    return (_locals['xs'], self.currentError)
                _G_termpattern_30, lastError = self.termpattern('Or', _G_termpattern_28)
                self.considerError(lastError, None)
                def _G_or_31():
                    def _G_pred_32():
                        _G_python_33, lastError = eval('len(xs) == 1', self.globals, _locals), None
                        self.considerError(lastError, None)
                        return (_G_python_33, self.currentError)
                    _G_pred_34, lastError = self.pred(_G_pred_32)
                    self.considerError(lastError, None)
                    self._trace('#TreeTransformer\nExactly(:x) -> [t.Match(x)]\nToken(:x) -> [t.Match(x)]\nMany(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nMany1(@x) -> x + [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nRepeat(:min :max @x)\n    -> [t.Python(repr(int(min))), t.Push(), t.Python(repr(int(max))),\n        t.Push(), t.RepeatChoice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nOptional(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(2), t.Python("None")]\n# Right-associate Or() as needed. Note that Or() can have a list of a single\n# element.\nOr(@xs) = ?(len(xs) == 1) transform(xs[0])', (0, 580), self.input.position)
                    _G_python_35, lastError = eval('xs[0]', self.globals, _locals), None
                    self.considerError(lastError, None)
                    _G_apply_36, lastError = self._apply(self.rule_transform, "transform", [_G_python_35])
                    self.considerError(lastError, None)
                    return (_G_apply_36, self.currentError)
                def _G_or_37():
                    def _G_pred_38():
                        _G_python_39, lastError = eval('len(xs) == 2', self.globals, _locals), None
                        self.considerError(lastError, None)
                        return (_G_python_39, self.currentError)
                    _G_pred_40, lastError = self.pred(_G_pred_38)
                    self.considerError(lastError, None)
                    self._trace('#TreeTransformer\nExactly(:x) -> [t.Match(x)]\nToken(:x) -> [t.Match(x)]\nMany(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nMany1(@x) -> x + [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nRepeat(:min :max @x)\n    -> [t.Python(repr(int(min))), t.Push(), t.Python(repr(int(max))),\n        t.Push(), t.RepeatChoice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nOptional(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(2), t.Python("None")]\n# Right-associate Or() as needed. Note that Or() can have a list of a single\n# element.\nOr(@xs) = ?(len(xs) == 1) transform(xs[0])\n        | ?(len(xs) == 2) transform(t.Or(xs[0], xs[1]))', (0, 636), self.input.position)
                    _G_python_41, lastError = eval('t.Or(xs[0], xs[1])', self.globals, _locals), None
                    self.considerError(lastError, None)
                    _G_apply_42, lastError = self._apply(self.rule_transform, "transform", [_G_python_41])
                    self.considerError(lastError, None)
                    return (_G_apply_42, self.currentError)
                def _G_or_43():
                    self._trace('#TreeTransformer\nExactly(:x) -> [t.Match(x)]\nToken(:x) -> [t.Match(x)]\nMany(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nMany1(@x) -> x + [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nRepeat(:min :max @x)\n    -> [t.Python(repr(int(min))), t.Push(), t.Python(repr(int(max))),\n        t.Push(), t.RepeatChoice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nOptional(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(2), t.Python("None")]\n# Right-associate Or() as needed. Note that Or() can have a list of a single\n# element.\nOr(@xs) = ?(len(xs) == 1) transform(xs[0])\n        | ?(len(xs) == 2) transform(t.Or(xs[0], xs[1]))\n        |                 transform(t.Or(xs[0], t.Or(xs[1:])))', (0, 699), self.input.position)
                    _G_python_44, lastError = eval('t.Or(xs[0], t.Or(xs[1:]))', self.globals, _locals), None
                    self.considerError(lastError, None)
                    _G_apply_45, lastError = self._apply(self.rule_transform, "transform", [_G_python_44])
                    self.considerError(lastError, None)
                    return (_G_apply_45, self.currentError)
                _G_or_46, lastError = self._or([_G_or_31, _G_or_37, _G_or_43])
                self.considerError(lastError, None)
                return (_G_or_46, self.currentError)
            def _G_or_47():
                def _G_termpattern_48():
                    _G_apply_49, lastError = self._apply(self.rule_transform, "transform", [])
                    self.considerError(lastError, None)
                    _locals['left'] = _G_apply_49
                    _G_apply_50, lastError = self._apply(self.rule_transform, "transform", [])
                    self.considerError(lastError, None)
                    _locals['right'] = _G_apply_50
                    return (_locals['right'], self.currentError)
                _G_termpattern_51, lastError = self.termpattern('Or', _G_termpattern_48)
                self.considerError(lastError, None)
                _G_python_52, lastError = eval('[t.Choice(len(left) + 2)] + left + [t.Commit(len(right) + 1)] + right', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_52, self.currentError)
            _G_or_53, lastError = self._or([_G_or_27, _G_or_47])
            self.considerError(lastError, 'Or')
            return (_G_or_53, self.currentError)


        def rule_Not(self):
            _locals = {'self': self}
            self.locals['Not'] = _locals
            def _G_termpattern_54():
                _G_apply_55, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_55
                return (_locals['x'], self.currentError)
            _G_termpattern_56, lastError = self.termpattern('Not', _G_termpattern_54)
            self.considerError(lastError, 'Not')
            _G_python_57, lastError = eval('[t.Choice(len(x) + 3)] + x + [t.Commit(1), t.Fail()]', self.globals, _locals), None
            self.considerError(lastError, 'Not')
            return (_G_python_57, self.currentError)


        def rule_Lookahead(self):
            _locals = {'self': self}
            self.locals['Lookahead'] = _locals
            def _G_termpattern_58():
                _G_apply_59, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_59
                return (_locals['x'], self.currentError)
            _G_termpattern_60, lastError = self.termpattern('Lookahead', _G_termpattern_58)
            self.considerError(lastError, 'Lookahead')
            self._trace('#TreeTransformer\nExactly(:x) -> [t.Match(x)]\nToken(:x) -> [t.Match(x)]\nMany(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nMany1(@x) -> x + [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nRepeat(:min :max @x)\n    -> [t.Python(repr(int(min))), t.Push(), t.Python(repr(int(max))),\n        t.Push(), t.RepeatChoice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nOptional(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(2), t.Python("None")]\n# Right-associate Or() as needed. Note that Or() can have a list of a single\n# element.\nOr(@xs) = ?(len(xs) == 1) transform(xs[0])\n        | ?(len(xs) == 2) transform(t.Or(xs[0], xs[1]))\n        |                 transform(t.Or(xs[0], t.Or(xs[1:])))\nOr(@left @right)\n    -> [t.Choice(len(left) + 2)] + left + [t.Commit(len(right) + 1)] + right\nNot(@x) -> [t.Choice(len(x) + 3)] + x + [t.Commit(1), t.Fail()]\nLookahead(:x) = transform(t.Not(t.Not(x)))', (0, 900), self.input.position)
            _G_python_61, lastError = eval('t.Not(t.Not(x))', self.globals, _locals), None
            self.considerError(lastError, 'Lookahead')
            _G_apply_62, lastError = self._apply(self.rule_transform, "transform", [_G_python_61])
            self.considerError(lastError, 'Lookahead')
            return (_G_apply_62, self.currentError)


        def rule_And(self):
            _locals = {'self': self}
            self.locals['And'] = _locals
            def _G_termpattern_63():
                _G_apply_64, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['xs'] = _G_apply_64
                return (_locals['xs'], self.currentError)
            _G_termpattern_65, lastError = self.termpattern('And', _G_termpattern_63)
            self.considerError(lastError, 'And')
            _G_python_66, lastError = eval('sum(xs, [])', self.globals, _locals), None
            self.considerError(lastError, 'And')
            return (_G_python_66, self.currentError)


        def rule_Bind(self):
            _locals = {'self': self}
            self.locals['Bind'] = _locals
            def _G_termpattern_67():
                _G_apply_68, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['name'] = _G_apply_68
                _G_apply_69, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_69
                return (_locals['x'], self.currentError)
            _G_termpattern_70, lastError = self.termpattern('Bind', _G_termpattern_67)
            self.considerError(lastError, 'Bind')
            _G_python_71, lastError = eval('x + [t.Bind(name)]', self.globals, _locals), None
            self.considerError(lastError, 'Bind')
            return (_G_python_71, self.currentError)


        def rule_Predicate(self):
            _locals = {'self': self}
            self.locals['Predicate'] = _locals
            def _G_termpattern_72():
                _G_apply_73, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_73
                return (_locals['x'], self.currentError)
            _G_termpattern_74, lastError = self.termpattern('Predicate', _G_termpattern_72)
            self.considerError(lastError, 'Predicate')
            _G_python_75, lastError = eval('x + [t.Predicate()]', self.globals, _locals), None
            self.considerError(lastError, 'Predicate')
            return (_G_python_75, self.currentError)


        def rule_Action(self):
            _locals = {'self': self}
            self.locals['Action'] = _locals
            def _G_termpattern_76():
                _G_apply_77, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_77
                return (_locals['x'], self.currentError)
            _G_termpattern_78, lastError = self.termpattern('Action', _G_termpattern_76)
            self.considerError(lastError, 'Action')
            _G_python_79, lastError = eval('[t.Python(x.data)]', self.globals, _locals), None
            self.considerError(lastError, 'Action')
            return (_G_python_79, self.currentError)


        def rule_Python(self):
            _locals = {'self': self}
            self.locals['Python'] = _locals
            def _G_termpattern_80():
                _G_apply_81, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_81
                return (_locals['x'], self.currentError)
            _G_termpattern_82, lastError = self.termpattern('Python', _G_termpattern_80)
            self.considerError(lastError, 'Python')
            _G_python_83, lastError = eval('[t.Python(x.data)]', self.globals, _locals), None
            self.considerError(lastError, 'Python')
            return (_G_python_83, self.currentError)


        def rule_List(self):
            _locals = {'self': self}
            self.locals['List'] = _locals
            def _G_termpattern_84():
                _G_apply_85, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_85
                return (_locals['x'], self.currentError)
            _G_termpattern_86, lastError = self.termpattern('List', _G_termpattern_84)
            self.considerError(lastError, 'List')
            _G_python_87, lastError = eval('[t.Descend()] + x + [t.Ascend()]', self.globals, _locals), None
            self.considerError(lastError, 'List')
            return (_G_python_87, self.currentError)


        def rule_ConsumedBy(self):
            _locals = {'self': self}
            self.locals['ConsumedBy'] = _locals
            def _G_termpattern_88():
                _G_apply_89, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_89
                return (_locals['x'], self.currentError)
            _G_termpattern_90, lastError = self.termpattern('ConsumedBy', _G_termpattern_88)
            self.considerError(lastError, 'ConsumedBy')
            _G_python_91, lastError = eval('[t.StartSlice()] + x + [t.EndSlice()]', self.globals, _locals), None
            self.considerError(lastError, 'ConsumedBy')
            return (_G_python_91, self.currentError)


        def rule_pushes(self):
            _locals = {'self': self}
            self.locals['pushes'] = _locals
            _G_apply_92, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'pushes')
            _locals['xs'] = _G_apply_92
            _G_python_93, lastError = eval('[inner for x in xs for inner in [x[0], t.Push()]]', self.globals, _locals), None
            self.considerError(lastError, 'pushes')
            return (_G_python_93, self.currentError)


        def rule_Apply(self):
            _locals = {'self': self}
            self.locals['Apply'] = _locals
            def _G_or_94():
                def _G_termpattern_95():
                    self._trace('#TreeTransformer\nExactly(:x) -> [t.Match(x)]\nToken(:x) -> [t.Match(x)]\nMany(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nMany1(@x) -> x + [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nRepeat(:min :max @x)\n    -> [t.Python(repr(int(min))), t.Push(), t.Python(repr(int(max))),\n        t.Push(), t.RepeatChoice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nOptional(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(2), t.Python("None")]\n# Right-associate Or() as needed. Note that Or() can have a list of a single\n# element.\nOr(@xs) = ?(len(xs) == 1) transform(xs[0])\n        | ?(len(xs) == 2) transform(t.Or(xs[0], xs[1]))\n        |                 transform(t.Or(xs[0], t.Or(xs[1:])))\nOr(@left @right)\n    -> [t.Choice(len(left) + 2)] + left + [t.Commit(len(right) + 1)] + right\nNot(@x) -> [t.Choice(len(x) + 3)] + x + [t.Commit(1), t.Fail()]\nLookahead(:x) = transform(t.Not(t.Not(x)))\nAnd(@xs) -> sum(xs, [])\nBind(:name @x) -> x + [t.Bind(name)]\nPredicate(@x) -> x + [t.Predicate()]\nAction(:x) -> [t.Python(x.data)]\nPython(:x) -> [t.Python(x.data)]\nList(@x) -> [t.Descend()] + x + [t.Ascend()]\nConsumedBy(@x) -> [t.StartSlice()] + x + [t.EndSlice()]\n\npushes :xs -> [inner for x in xs for inner in [x[0], t.Push()]]\nApply("super"', (0, 1244), self.input.position)
                    _G_exactly_96, lastError = self.exactly('super')
                    self.considerError(lastError, None)
                    _G_apply_97, lastError = self._apply(self.rule_anything, "anything", [])
                    self.considerError(lastError, None)
                    _locals['code'] = _G_apply_97
                    _G_apply_98, lastError = self._apply(self.rule_transform, "transform", [])
                    self.considerError(lastError, None)
                    _locals['args'] = _G_apply_98
                    return (_locals['args'], self.currentError)
                _G_termpattern_99, lastError = self.termpattern('Apply', _G_termpattern_95)
                self.considerError(lastError, None)
                self._trace('#TreeTransformer\nExactly(:x) -> [t.Match(x)]\nToken(:x) -> [t.Match(x)]\nMany(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nMany1(@x) -> x + [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nRepeat(:min :max @x)\n    -> [t.Python(repr(int(min))), t.Push(), t.Python(repr(int(max))),\n        t.Push(), t.RepeatChoice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nOptional(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(2), t.Python("None")]\n# Right-associate Or() as needed. Note that Or() can have a list of a single\n# element.\nOr(@xs) = ?(len(xs) == 1) transform(xs[0])\n        | ?(len(xs) == 2) transform(t.Or(xs[0], xs[1]))\n        |                 transform(t.Or(xs[0], t.Or(xs[1:])))\nOr(@left @right)\n    -> [t.Choice(len(left) + 2)] + left + [t.Commit(len(right) + 1)] + right\nNot(@x) -> [t.Choice(len(x) + 3)] + x + [t.Commit(1), t.Fail()]\nLookahead(:x) = transform(t.Not(t.Not(x)))\nAnd(@xs) -> sum(xs, [])\nBind(:name @x) -> x + [t.Bind(name)]\nPredicate(@x) -> x + [t.Predicate()]\nAction(:x) -> [t.Python(x.data)]\nPython(:x) -> [t.Python(x.data)]\nList(@x) -> [t.Descend()] + x + [t.Ascend()]\nConsumedBy(@x) -> [t.StartSlice()] + x + [t.EndSlice()]\n\npushes :xs -> [inner for x in xs for inner in [x[0], t.Push()]]\nApply("super" :code @args) pushes(args)', (0, 1270), self.input.position)
                _G_python_100, lastError = eval('args', self.globals, _locals), None
                self.considerError(lastError, None)
                _G_apply_101, lastError = self._apply(self.rule_pushes, "pushes", [_G_python_100])
                self.considerError(lastError, None)
                _locals['xs'] = _G_apply_101
                _G_python_102, lastError = eval('xs + [t.SuperCall(code)]', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_102, self.currentError)
            def _G_or_103():
                def _G_termpattern_104():
                    _G_apply_105, lastError = self._apply(self.rule_anything, "anything", [])
                    self.considerError(lastError, None)
                    _locals['rule'] = _G_apply_105
                    _G_apply_106, lastError = self._apply(self.rule_anything, "anything", [])
                    self.considerError(lastError, None)
                    _locals['code'] = _G_apply_106
                    _G_apply_107, lastError = self._apply(self.rule_transform, "transform", [])
                    self.considerError(lastError, None)
                    _locals['args'] = _G_apply_107
                    return (_locals['args'], self.currentError)
                _G_termpattern_108, lastError = self.termpattern('Apply', _G_termpattern_104)
                self.considerError(lastError, None)
                self._trace('#TreeTransformer\nExactly(:x) -> [t.Match(x)]\nToken(:x) -> [t.Match(x)]\nMany(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nMany1(@x) -> x + [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nRepeat(:min :max @x)\n    -> [t.Python(repr(int(min))), t.Push(), t.Python(repr(int(max))),\n        t.Push(), t.RepeatChoice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nOptional(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(2), t.Python("None")]\n# Right-associate Or() as needed. Note that Or() can have a list of a single\n# element.\nOr(@xs) = ?(len(xs) == 1) transform(xs[0])\n        | ?(len(xs) == 2) transform(t.Or(xs[0], xs[1]))\n        |                 transform(t.Or(xs[0], t.Or(xs[1:])))\nOr(@left @right)\n    -> [t.Choice(len(left) + 2)] + left + [t.Commit(len(right) + 1)] + right\nNot(@x) -> [t.Choice(len(x) + 3)] + x + [t.Commit(1), t.Fail()]\nLookahead(:x) = transform(t.Not(t.Not(x)))\nAnd(@xs) -> sum(xs, [])\nBind(:name @x) -> x + [t.Bind(name)]\nPredicate(@x) -> x + [t.Predicate()]\nAction(:x) -> [t.Python(x.data)]\nPython(:x) -> [t.Python(x.data)]\nList(@x) -> [t.Descend()] + x + [t.Ascend()]\nConsumedBy(@x) -> [t.StartSlice()] + x + [t.EndSlice()]\n\npushes :xs -> [inner for x in xs for inner in [x[0], t.Push()]]\nApply("super" :code @args) pushes(args):xs -> xs + [t.SuperCall(code)]\nApply(:rule :code @args) pushes(args)', (0, 1339), self.input.position)
                _G_python_109, lastError = eval('args', self.globals, _locals), None
                self.considerError(lastError, None)
                _G_apply_110, lastError = self._apply(self.rule_pushes, "pushes", [_G_python_109])
                self.considerError(lastError, None)
                _locals['xs'] = _G_apply_110
                _G_python_111, lastError = eval('xs + [t.Call(rule)]', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_111, self.currentError)
            _G_or_112, lastError = self._or([_G_or_94, _G_or_103])
            self.considerError(lastError, 'Apply')
            return (_G_or_112, self.currentError)


        def rule_ForeignApply(self):
            _locals = {'self': self}
            self.locals['ForeignApply'] = _locals
            def _G_termpattern_113():
                _G_apply_114, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['grammar'] = _G_apply_114
                _G_apply_115, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['rule'] = _G_apply_115
                _G_apply_116, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['code'] = _G_apply_116
                _G_apply_117, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['args'] = _G_apply_117
                return (_locals['args'], self.currentError)
            _G_termpattern_118, lastError = self.termpattern('ForeignApply', _G_termpattern_113)
            self.considerError(lastError, 'ForeignApply')
            self._trace('#TreeTransformer\nExactly(:x) -> [t.Match(x)]\nToken(:x) -> [t.Match(x)]\nMany(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nMany1(@x) -> x + [t.Choice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nRepeat(:min :max @x)\n    -> [t.Python(repr(int(min))), t.Push(), t.Python(repr(int(max))),\n        t.Push(), t.RepeatChoice(len(x) + 2)] + x + [t.Commit(-len(x) - 1)]\nOptional(@x) -> [t.Choice(len(x) + 2)] + x + [t.Commit(2), t.Python("None")]\n# Right-associate Or() as needed. Note that Or() can have a list of a single\n# element.\nOr(@xs) = ?(len(xs) == 1) transform(xs[0])\n        | ?(len(xs) == 2) transform(t.Or(xs[0], xs[1]))\n        |                 transform(t.Or(xs[0], t.Or(xs[1:])))\nOr(@left @right)\n    -> [t.Choice(len(left) + 2)] + left + [t.Commit(len(right) + 1)] + right\nNot(@x) -> [t.Choice(len(x) + 3)] + x + [t.Commit(1), t.Fail()]\nLookahead(:x) = transform(t.Not(t.Not(x)))\nAnd(@xs) -> sum(xs, [])\nBind(:name @x) -> x + [t.Bind(name)]\nPredicate(@x) -> x + [t.Predicate()]\nAction(:x) -> [t.Python(x.data)]\nPython(:x) -> [t.Python(x.data)]\nList(@x) -> [t.Descend()] + x + [t.Ascend()]\nConsumedBy(@x) -> [t.StartSlice()] + x + [t.EndSlice()]\n\npushes :xs -> [inner for x in xs for inner in [x[0], t.Push()]]\nApply("super" :code @args) pushes(args):xs -> xs + [t.SuperCall(code)]\nApply(:rule :code @args) pushes(args):xs -> xs + [t.Call(rule)]\nForeignApply(:grammar :rule :code @args) pushes(args)', (0, 1419), self.input.position)
            _G_python_119, lastError = eval('args', self.globals, _locals), None
            self.considerError(lastError, 'ForeignApply')
            _G_apply_120, lastError = self._apply(self.rule_pushes, "pushes", [_G_python_119])
            self.considerError(lastError, 'ForeignApply')
            _locals['xs'] = _G_apply_120
            _G_python_121, lastError = eval('(xs +\n    [t.ForeignCall(grammar, rule)])', self.globals, _locals), None
            self.considerError(lastError, 'ForeignApply')
            return (_G_python_121, self.currentError)


        def rule_Rule(self):
            _locals = {'self': self}
            self.locals['Rule'] = _locals
            def _G_termpattern_122():
                _G_apply_123, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['name'] = _G_apply_123
                _G_apply_124, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['xs'] = _G_apply_124
                return (_locals['xs'], self.currentError)
            _G_termpattern_125, lastError = self.termpattern('Rule', _G_termpattern_122)
            self.considerError(lastError, 'Rule')
            _G_python_126, lastError = eval('t.Rule(name, xs)', self.globals, _locals), None
            self.considerError(lastError, 'Rule')
            return (_G_python_126, self.currentError)


        def rule_Grammar(self):
            _locals = {'self': self}
            self.locals['Grammar'] = _locals
            def _G_termpattern_127():
                _G_apply_128, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['name'] = _G_apply_128
                _G_apply_129, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                _locals['tree'] = _G_apply_129
                _G_apply_130, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['rules'] = _G_apply_130
                return (_locals['rules'], self.currentError)
            _G_termpattern_131, lastError = self.termpattern('Grammar', _G_termpattern_127)
            self.considerError(lastError, 'Grammar')
            _G_python_132, lastError = eval('t.Grammar(name, tree, rules)', self.globals, _locals), None
            self.considerError(lastError, 'Grammar')
            return (_G_python_132, self.currentError)


        tree = True
    if vm.globals is not None:
        vm.globals = vm.globals.copy()
        vm.globals.update(ruleGlobals)
    else:
        vm.globals = ruleGlobals
    return vm
########NEW FILE########
__FILENAME__ = vm_emit
def createParserClass(GrammarBase, ruleGlobals):
    if ruleGlobals is None:
        ruleGlobals = {}
    class vm_emit(GrammarBase):
        def rule_Grammar(self):
            _locals = {'self': self}
            self.locals['Grammar'] = _locals
            def _G_termpattern_1():
                self._trace('#TreeTransformer\nGrammar(str', (0, 28), self.input.position)
                _G_apply_2, lastError = self._apply(self.rule_str, "str", [])
                self.considerError(lastError, None)
                _locals['name'] = _G_apply_2
                self._trace('#TreeTransformer\nGrammar(str:name str', (0, 37), self.input.position)
                _G_apply_3, lastError = self._apply(self.rule_str, "str", [])
                self.considerError(lastError, None)
                _locals['tree'] = _G_apply_3
                _G_apply_4, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['rules'] = _G_apply_4
                return (_locals['rules'], self.currentError)
            _G_termpattern_5, lastError = self.termpattern('Grammar', _G_termpattern_1)
            self.considerError(lastError, 'Grammar')
            from terml.parser import parseTerm as term
            _G_stringtemplate_6, lastError = self.stringtemplate(term('["class ", QuasiExprHole("name"), ":\n", "    tree = ", QuasiExprHole("tree"), "\n", "    ", QuasiExprHole("rules"), "\n"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_6, self.currentError)


        def rule_Rule(self):
            _locals = {'self': self}
            self.locals['Rule'] = _locals
            def _G_termpattern_7():
                self._trace('#TreeTransformer\nGrammar(str:name str:tree @rules) {{{\nclass $name:\n    tree = $tree\n    $rules\n}}}\nRule(str', (0, 108), self.input.position)
                _G_apply_8, lastError = self._apply(self.rule_str, "str", [])
                self.considerError(lastError, None)
                _locals['name'] = _G_apply_8
                _G_apply_9, lastError = self._apply(self.rule_transform, "transform", [])
                self.considerError(lastError, None)
                _locals['rules'] = _G_apply_9
                return (_locals['rules'], self.currentError)
            _G_termpattern_10, lastError = self.termpattern('Rule', _G_termpattern_7)
            self.considerError(lastError, 'Rule')
            from terml.parser import parseTerm as term
            _G_stringtemplate_11, lastError = self.stringtemplate(term('[QuasiExprHole("name"), " = [\n", "    ", QuasiExprHole("rules"), "\n", "]\n"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_11, self.currentError)


        def rule_Ascend(self):
            _locals = {'self': self}
            self.locals['Ascend'] = _locals
            def _G_termpattern_12():
                return (None, self.currentError)
            _G_termpattern_13, lastError = self.termpattern('Ascend', _G_termpattern_12)
            self.considerError(lastError, 'Ascend')
            from terml.parser import parseTerm as term
            _G_stringtemplate_14, lastError = self.stringtemplate(term('["t.Ascend(),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_14, self.currentError)


        def rule_Bind(self):
            _locals = {'self': self}
            self.locals['Bind'] = _locals
            def _G_termpattern_15():
                self._trace('#TreeTransformer\nGrammar(str:name str:tree @rules) {{{\nclass $name:\n    tree = $tree\n    $rules\n}}}\nRule(str:name @rules) {{{\n$name = [\n    $rules\n]\n}}}\n\nAscend() --> t.Ascend(),\nBind(str', (0, 187), self.input.position)
                _G_apply_16, lastError = self._apply(self.rule_str, "str", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_16
                return (_locals['x'], self.currentError)
            _G_termpattern_17, lastError = self.termpattern('Bind', _G_termpattern_15)
            self.considerError(lastError, 'Bind')
            from terml.parser import parseTerm as term
            _G_stringtemplate_18, lastError = self.stringtemplate(term('["t.Bind(", QuasiExprHole("x"), "),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_18, self.currentError)


        def rule_Call(self):
            _locals = {'self': self}
            self.locals['Call'] = _locals
            def _G_termpattern_19():
                self._trace('#TreeTransformer\nGrammar(str:name str:tree @rules) {{{\nclass $name:\n    tree = $tree\n    $rules\n}}}\nRule(str:name @rules) {{{\n$name = [\n    $rules\n]\n}}}\n\nAscend() --> t.Ascend(),\nBind(str:x) --> t.Bind($x),\nCall(str', (0, 215), self.input.position)
                _G_apply_20, lastError = self._apply(self.rule_str, "str", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_20
                return (_locals['x'], self.currentError)
            _G_termpattern_21, lastError = self.termpattern('Call', _G_termpattern_19)
            self.considerError(lastError, 'Call')
            from terml.parser import parseTerm as term
            _G_stringtemplate_22, lastError = self.stringtemplate(term('["t.Call(", QuasiExprHole("x"), "),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_22, self.currentError)


        def rule_Choice(self):
            _locals = {'self': self}
            self.locals['Choice'] = _locals
            def _G_termpattern_23():
                self._trace('#TreeTransformer\nGrammar(str:name str:tree @rules) {{{\nclass $name:\n    tree = $tree\n    $rules\n}}}\nRule(str:name @rules) {{{\n$name = [\n    $rules\n]\n}}}\n\nAscend() --> t.Ascend(),\nBind(str:x) --> t.Bind($x),\nCall(str:x) --> t.Call($x),\nChoice(str', (0, 245), self.input.position)
                _G_apply_24, lastError = self._apply(self.rule_str, "str", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_24
                return (_locals['x'], self.currentError)
            _G_termpattern_25, lastError = self.termpattern('Choice', _G_termpattern_23)
            self.considerError(lastError, 'Choice')
            from terml.parser import parseTerm as term
            _G_stringtemplate_26, lastError = self.stringtemplate(term('["t.Choice(", QuasiExprHole("x"), "),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_26, self.currentError)


        def rule_Commit(self):
            _locals = {'self': self}
            self.locals['Commit'] = _locals
            def _G_termpattern_27():
                self._trace('#TreeTransformer\nGrammar(str:name str:tree @rules) {{{\nclass $name:\n    tree = $tree\n    $rules\n}}}\nRule(str:name @rules) {{{\n$name = [\n    $rules\n]\n}}}\n\nAscend() --> t.Ascend(),\nBind(str:x) --> t.Bind($x),\nCall(str:x) --> t.Call($x),\nChoice(str:x) --> t.Choice($x),\nCommit(str', (0, 277), self.input.position)
                _G_apply_28, lastError = self._apply(self.rule_str, "str", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_28
                return (_locals['x'], self.currentError)
            _G_termpattern_29, lastError = self.termpattern('Commit', _G_termpattern_27)
            self.considerError(lastError, 'Commit')
            from terml.parser import parseTerm as term
            _G_stringtemplate_30, lastError = self.stringtemplate(term('["t.Commit(", QuasiExprHole("x"), "),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_30, self.currentError)


        def rule_Descend(self):
            _locals = {'self': self}
            self.locals['Descend'] = _locals
            def _G_termpattern_31():
                return (None, self.currentError)
            _G_termpattern_32, lastError = self.termpattern('Descend', _G_termpattern_31)
            self.considerError(lastError, 'Descend')
            from terml.parser import parseTerm as term
            _G_stringtemplate_33, lastError = self.stringtemplate(term('["t.Descend(),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_33, self.currentError)


        def rule_EndSlice(self):
            _locals = {'self': self}
            self.locals['EndSlice'] = _locals
            def _G_termpattern_34():
                return (None, self.currentError)
            _G_termpattern_35, lastError = self.termpattern('EndSlice', _G_termpattern_34)
            self.considerError(lastError, 'EndSlice')
            from terml.parser import parseTerm as term
            _G_stringtemplate_36, lastError = self.stringtemplate(term('["t.EndSlice(),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_36, self.currentError)


        def rule_Fail(self):
            _locals = {'self': self}
            self.locals['Fail'] = _locals
            def _G_termpattern_37():
                return (None, self.currentError)
            _G_termpattern_38, lastError = self.termpattern('Fail', _G_termpattern_37)
            self.considerError(lastError, 'Fail')
            from terml.parser import parseTerm as term
            _G_stringtemplate_39, lastError = self.stringtemplate(term('["t.Fail(),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_39, self.currentError)


        def rule_ForeignCall(self):
            _locals = {'self': self}
            self.locals['ForeignCall'] = _locals
            def _G_termpattern_40():
                self._trace('#TreeTransformer\nGrammar(str:name str:tree @rules) {{{\nclass $name:\n    tree = $tree\n    $rules\n}}}\nRule(str:name @rules) {{{\n$name = [\n    $rules\n]\n}}}\n\nAscend() --> t.Ascend(),\nBind(str:x) --> t.Bind($x),\nCall(str:x) --> t.Call($x),\nChoice(str:x) --> t.Choice($x),\nCommit(str:x) --> t.Commit($x),\nDescend() --> t.Descend(),\nEndSlice() --> t.EndSlice(),\nFail() --> t.Fail(),\nForeignCall(str', (0, 391), self.input.position)
                _G_apply_41, lastError = self._apply(self.rule_str, "str", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_41
                self._trace('#TreeTransformer\nGrammar(str:name str:tree @rules) {{{\nclass $name:\n    tree = $tree\n    $rules\n}}}\nRule(str:name @rules) {{{\n$name = [\n    $rules\n]\n}}}\n\nAscend() --> t.Ascend(),\nBind(str:x) --> t.Bind($x),\nCall(str:x) --> t.Call($x),\nChoice(str:x) --> t.Choice($x),\nCommit(str:x) --> t.Commit($x),\nDescend() --> t.Descend(),\nEndSlice() --> t.EndSlice(),\nFail() --> t.Fail(),\nForeignCall(str:x str', (0, 397), self.input.position)
                _G_apply_42, lastError = self._apply(self.rule_str, "str", [])
                self.considerError(lastError, None)
                _locals['y'] = _G_apply_42
                return (_locals['y'], self.currentError)
            _G_termpattern_43, lastError = self.termpattern('ForeignCall', _G_termpattern_40)
            self.considerError(lastError, 'ForeignCall')
            from terml.parser import parseTerm as term
            _G_stringtemplate_44, lastError = self.stringtemplate(term('["t.ForeignCall(", QuasiExprHole("x"), ", ", QuasiExprHole("y"), "),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_44, self.currentError)


        def rule_Match(self):
            _locals = {'self': self}
            self.locals['Match'] = _locals
            def _G_termpattern_45():
                self._trace('#TreeTransformer\nGrammar(str:name str:tree @rules) {{{\nclass $name:\n    tree = $tree\n    $rules\n}}}\nRule(str:name @rules) {{{\n$name = [\n    $rules\n]\n}}}\n\nAscend() --> t.Ascend(),\nBind(str:x) --> t.Bind($x),\nCall(str:x) --> t.Call($x),\nChoice(str:x) --> t.Choice($x),\nCommit(str:x) --> t.Commit($x),\nDescend() --> t.Descend(),\nEndSlice() --> t.EndSlice(),\nFail() --> t.Fail(),\nForeignCall(str:x str:y) --> t.ForeignCall($x, $y),\nMatch(str', (0, 437), self.input.position)
                _G_apply_46, lastError = self._apply(self.rule_str, "str", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_46
                return (_locals['x'], self.currentError)
            _G_termpattern_47, lastError = self.termpattern('Match', _G_termpattern_45)
            self.considerError(lastError, 'Match')
            from terml.parser import parseTerm as term
            _G_stringtemplate_48, lastError = self.stringtemplate(term('["t.Match(", QuasiExprHole("x"), "),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_48, self.currentError)


        def rule_Predicate(self):
            _locals = {'self': self}
            self.locals['Predicate'] = _locals
            def _G_termpattern_49():
                return (None, self.currentError)
            _G_termpattern_50, lastError = self.termpattern('Predicate', _G_termpattern_49)
            self.considerError(lastError, 'Predicate')
            from terml.parser import parseTerm as term
            _G_stringtemplate_51, lastError = self.stringtemplate(term('["t.Predicate(),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_51, self.currentError)


        def rule_Push(self):
            _locals = {'self': self}
            self.locals['Push'] = _locals
            def _G_termpattern_52():
                return (None, self.currentError)
            _G_termpattern_53, lastError = self.termpattern('Push', _G_termpattern_52)
            self.considerError(lastError, 'Push')
            from terml.parser import parseTerm as term
            _G_stringtemplate_54, lastError = self.stringtemplate(term('["t.Push(),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_54, self.currentError)


        def rule_Python(self):
            _locals = {'self': self}
            self.locals['Python'] = _locals
            def _G_termpattern_55():
                self._trace('#TreeTransformer\nGrammar(str:name str:tree @rules) {{{\nclass $name:\n    tree = $tree\n    $rules\n}}}\nRule(str:name @rules) {{{\n$name = [\n    $rules\n]\n}}}\n\nAscend() --> t.Ascend(),\nBind(str:x) --> t.Bind($x),\nCall(str:x) --> t.Call($x),\nChoice(str:x) --> t.Choice($x),\nCommit(str:x) --> t.Commit($x),\nDescend() --> t.Descend(),\nEndSlice() --> t.EndSlice(),\nFail() --> t.Fail(),\nForeignCall(str:x str:y) --> t.ForeignCall($x, $y),\nMatch(str:x) --> t.Match($x),\nPredicate() --> t.Predicate(),\nPush() --> t.Push(),\nPython(str', (0, 520), self.input.position)
                _G_apply_56, lastError = self._apply(self.rule_str, "str", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_56
                return (_locals['x'], self.currentError)
            _G_termpattern_57, lastError = self.termpattern('Python', _G_termpattern_55)
            self.considerError(lastError, 'Python')
            from terml.parser import parseTerm as term
            _G_stringtemplate_58, lastError = self.stringtemplate(term('["t.Python(", QuasiExprHole("x"), "),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_58, self.currentError)


        def rule_StartSlice(self):
            _locals = {'self': self}
            self.locals['StartSlice'] = _locals
            def _G_termpattern_59():
                return (None, self.currentError)
            _G_termpattern_60, lastError = self.termpattern('StartSlice', _G_termpattern_59)
            self.considerError(lastError, 'StartSlice')
            from terml.parser import parseTerm as term
            _G_stringtemplate_61, lastError = self.stringtemplate(term('["t.StartSlice(),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_61, self.currentError)


        def rule_SuperCall(self):
            _locals = {'self': self}
            self.locals['SuperCall'] = _locals
            def _G_termpattern_62():
                self._trace('#TreeTransformer\nGrammar(str:name str:tree @rules) {{{\nclass $name:\n    tree = $tree\n    $rules\n}}}\nRule(str:name @rules) {{{\n$name = [\n    $rules\n]\n}}}\n\nAscend() --> t.Ascend(),\nBind(str:x) --> t.Bind($x),\nCall(str:x) --> t.Call($x),\nChoice(str:x) --> t.Choice($x),\nCommit(str:x) --> t.Commit($x),\nDescend() --> t.Descend(),\nEndSlice() --> t.EndSlice(),\nFail() --> t.Fail(),\nForeignCall(str:x str:y) --> t.ForeignCall($x, $y),\nMatch(str:x) --> t.Match($x),\nPredicate() --> t.Predicate(),\nPush() --> t.Push(),\nPython(str:x) --> t.Python($x),\nStartSlice() --> t.StartSlice(),\nSuperCall(str', (0, 588), self.input.position)
                _G_apply_63, lastError = self._apply(self.rule_str, "str", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_63
                return (_locals['x'], self.currentError)
            _G_termpattern_64, lastError = self.termpattern('SuperCall', _G_termpattern_62)
            self.considerError(lastError, 'SuperCall')
            from terml.parser import parseTerm as term
            _G_stringtemplate_65, lastError = self.stringtemplate(term('["t.SuperCall(", QuasiExprHole("x"), "),"]'), _locals)
            self.considerError(lastError, None)
            return (_G_stringtemplate_65, self.currentError)


        def rule_str(self):
            _locals = {'self': self}
            self.locals['str'] = _locals
            self._trace('#TreeTransformer\nGrammar(str:name str:tree @rules) {{{\nclass $name:\n    tree = $tree\n    $rules\n}}}\nRule(str:name @rules) {{{\n$name = [\n    $rules\n]\n}}}\n\nAscend() --> t.Ascend(),\nBind(str:x) --> t.Bind($x),\nCall(str:x) --> t.Call($x),\nChoice(str:x) --> t.Choice($x),\nCommit(str:x) --> t.Commit($x),\nDescend() --> t.Descend(),\nEndSlice() --> t.EndSlice(),\nFail() --> t.Fail(),\nForeignCall(str:x str:y) --> t.ForeignCall($x, $y),\nMatch(str:x) --> t.Match($x),\nPredicate() --> t.Predicate(),\nPush() --> t.Push(),\nPython(str:x) --> t.Python($x),\nStartSlice() --> t.StartSlice(),\nSuperCall(str:x) --> t.SuperCall($x),\n\nstr = anything', (0, 628), self.input.position)
            _G_apply_66, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'str')
            _locals['s'] = _G_apply_66
            _G_python_67, lastError = eval('str(s.data)', self.globals, _locals), None
            self.considerError(lastError, 'str')
            return (_G_python_67, self.currentError)


        tree = True
    if vm_emit.globals is not None:
        vm_emit.globals = vm_emit.globals.copy()
        vm_emit.globals.update(ruleGlobals)
    else:
        vm_emit.globals = ruleGlobals
    return vm_emit
########NEW FILE########
__FILENAME__ = parsley
import functools

from ometa.grammar import OMeta
from ometa.runtime import ParseError, EOFError, OMetaBase
from terml.parser import parseTerm as term
from terml.quasiterm import quasiterm

__version__ = '1.2'


def wrapGrammar(g, tracefunc=None):
    def makeParser(input):
        """
        Creates a parser for the given input, with methods for
        invoking each rule.

        :param input: The string you want to parse.
        """
        parser = g(input)
        if tracefunc:
            parser._trace = tracefunc
        return _GrammarWrapper(parser, input)
    makeParser._grammarClass = g
    return makeParser


def makeGrammar(source, bindings, name='Grammar', unwrap=False,
                extends=wrapGrammar(OMetaBase), tracefunc=None):
    """
    Create a class from a Parsley grammar.

    :param source: A grammar, as a string.
    :param bindings: A mapping of variable names to objects.
    :param name: Name used for the generated class.

    :param unwrap: If True, return a parser class suitable for
                   subclassing. If False, return a wrapper with the
                   friendly API.
    :param extends: The superclass for the generated parser class.

    :param tracefunc: A 3-arg function which takes a fragment of grammar
                      source, the start/end indexes in the grammar of this
                      fragment, and a position in the input. Invoked for
                      terminals and rule applications.
    """
    g = OMeta.makeGrammar(source, name).createParserClass(
        unwrapGrammar(extends), bindings)
    if unwrap:
        return g
    else:
        return wrapGrammar(g, tracefunc=tracefunc)


def unwrapGrammar(w):
    """
    Access the internal parser class for a Parsley grammar object.
    """
    return getattr(w, '_grammarClass', None) or w


class _GrammarWrapper(object):
    """
    A wrapper for Parsley grammar instances.

    To invoke a Parsley rule, invoke a method with that name -- this
    turns x(input).foo() calls into grammar.apply("foo") calls.
    """
    def __init__(self, grammar, input):
        self._grammar = grammar
        self._input = input
        #so pydoc doesn't get trapped in the __getattr__
        self.__name__ = _GrammarWrapper.__name__

    def __getattr__(self, name):
        """
        Return a function that will instantiate a grammar and invoke the named
        rule.
        :param name: Rule name.
        """
        def invokeRule(*args, **kwargs):
            """
            Invoke a Parsley rule. Passes any positional args to the rule.
            """
            try:
                ret, err = self._grammar.apply(name, *args)
            except ParseError as e:
                self._grammar.considerError(e)
                err = self._grammar.currentError
            else:
                try:
                    extra, _ = self._grammar.input.head()
                except EOFError:
                    return ret
                else:
                    # problem is that input remains, so:
                    err = ParseError(err.input, err.position + 1,
                                     [["message", "expected EOF"]], err.trail)
            raise err
        return invokeRule


def makeProtocol(source, senderFactory, receiverFactory, bindings=None,
                 name='Grammar'):
    """
    Create a Twisted ``Protocol`` factory from a Parsley grammar.

    :param source: A grammar, as a string.
    :param senderFactory: A one-argument callable that takes a twisted
        ``Transport`` and returns a :ref:`sender <senders>`.
    :param receiverFactory: A one-argument callable that takes the sender
        returned by the ``senderFactory`` and returns a :ref:`receiver
        <receivers>`.
    :param bindings: A mapping of variable names to objects which will be
        accessible from python code in the grammar.
    :param name: The name used for the generated grammar class.
    :returns: A nullary callable which will return an instance of
        :class:`~.ParserProtocol`.
    """

    from ometa.protocol import ParserProtocol
    if bindings is None:
        bindings = {}
    grammar = OMeta(source).parseGrammar(name)
    return functools.partial(
        ParserProtocol, grammar, senderFactory, receiverFactory, bindings)


def stack(*wrappers):
    """
    Stack some senders or receivers for ease of wrapping.

    ``stack(x, y, z)`` will return a factory usable as a sender or receiver
    factory which will, when called with a transport or sender as an argument,
    return ``x(y(z(argument)))``.
    """
    if not wrappers:
        raise TypeError('at least one argument is required')
    def factory(arg):
        ret = wrappers[-1](arg)
        for wrapper in wrappers[-2::-1]:
            ret = wrapper(ret)
        return ret
    return factory

__all__ = [
    'makeGrammar', 'wrapGrammar', 'unwrapGrammar', 'term', 'quasiterm',
    'makeProtocol', 'stack',
]

########NEW FILE########
__FILENAME__ = nodes
from collections import namedtuple
import sys

try:
    basestring
    scalar_types = (str, unicode, int, long, float)
    integer_types = (int, long)
except NameError:
    basestring = str
    scalar_types = (str, int, float)
    integer_types = (int,)

_Term = namedtuple("Term", "tag data args span")
class Term(_Term):
    def __new__(cls, tag, data, args, span):
        #XXX AstroTag tracks (name, tag_code) and source span
        if data and not isinstance(data, scalar_types):
            raise ValueError("Term data can't be of type %r" % (type(data),))
        if data and args:
            raise ValueError("Term %s can't have both data and children" % (tag,))
        if args is None:
            args = ()
        return _Term.__new__(cls, tag, data, tuple(args), span)

    def __iter__(self):
        #and now I feel a bit silly subclassing namedtuple
        raise NotImplementedError()

    def __eq__(self, other):
        try:
            if self.tag.name == ".bag." and other.tag.name == ".bag.":
                return (self.data, set(self.args)
                  ) == (other.data, set(other.args))
            return (     self.tag, self.data, self.args
                   ) == (other.tag, other.data, other.args)
        except AttributeError:
            return False


    def __hash__(self):
        return hash((Term, self.tag, self.data, self.args))


    def __repr__(self):
        return "term('%s')" % (self._unparse(4).replace("'", "\\'"))


    def _unparse(self, indentLevel=0):
        newlineAndIndent = '\n' + (' ' * indentLevel)
        if self.data is not None:
            if self.tag.name == '.String.':
                return '"%s"' % repr(self.data)[1:-1].replace("\\'", "'").replace('"', '\\\\"')
            elif self.tag.name == '.char.':
                return "'%s'" % repr(self.data)[1:-1].replace("'", "\\'").replace('\\"', '"')
            else:
                return str(self.data)
        args = ', '.join([a._unparse() for a in self.args])
        if self.tag.name == '.tuple.':
            return "[%s]" % (args,)
        elif self.tag.name == '.attr.':
            return "%s: %s" % (self.args[0]._unparse(indentLevel),
                               self.args[1]._unparse(indentLevel))
        elif self.tag.name == '.bag.':
            return "{%s}" % (args,)
        elif len(self.args) == 1 and self.args[0].tag.name == '.bag.':
            return "%s%s" % (self.tag._unparse(indentLevel), args)
        else:
            if len(self.args) == 0:
                return self.tag._unparse(indentLevel)
            return "%s(%s)" % (self.tag._unparse(indentLevel), args)

    def withSpan(self, span):
        return Term(self.tag, self.data, self.args, span)


    def build(self, builder):
        if self.data is None:
            f = builder.leafTag(self.tag, self.span)
        else:
            f = builder.leafData(self.data, self.span)

        return builder.term(f, [arg.build(builder) for arg in self.args])


    def __cmp__(self, other):
        tagc = cmp(self.tag, other.tag)
        if tagc:
            return tagc
        datac = cmp(self.data, other.data)
        if datac:
            return datac
        if self.tag.name == ".bag." and other.tag.name == ".bag.":
            return cmp(set(self.args), set(other.args))
        return cmp(self.args, other.args)

    def __int__(self):
        return int(self.data)

    def __float__(self):
        return float(self.data)

    def withoutArgs(self):
        return Term(self.tag, self.data, (), self.span)

    def asFunctor(self):
        if self.args:
            raise ValueError("Terms with args can't be used as functors")
        else:
            return self.tag


class Tag(object):
    def __init__(self, name):
        if name[0] == '':
            raise ValueError("Tags must have names")
        self.name = name

    def __eq__(self, other):
        return other.__class__ == self.__class__ and self.name == other.name

    def __ne__(self, other):
        return not self == other

    def __repr__(self):
        return "Tag(%r)" % (self.name,)

    def __hash__(self):
        return hash((Tag, self.name))

    def _unparse(self, indentLevel=0):
        return self.name

def coerceToTerm(val):
    from ometa.runtime import character, unicodeCharacter
    if isinstance(val, Term):
        return val
    if val is None:
        return Term(Tag("null"), None, None, None)
    if val is True:
        return Term(Tag("true"), None, None, None)
    if val is False:
        return Term(Tag("false"), None, None, None)
    if isinstance(val, integer_types):
        return Term(Tag(".int."), val, None, None)
    if isinstance(val, float):
        return Term(Tag(".float64."), val, None, None)
    if isinstance(val, (character, unicodeCharacter)):
        return Term(Tag(".char."), val, None, None)
    if isinstance(val, basestring):
        return Term(Tag(".String."), val, None, None)
    if isinstance(val, (list, tuple)):
        return Term(Tag(".tuple."), None, tuple(coerceToTerm(item) for item in val), None)
    if isinstance(val, set):
        return Term(Tag('.bag.'), None, tuple(coerceToTerm(item) for item in val), None)
    if isinstance(val, dict):
        return Term(Tag('.bag.'), None, tuple(Term(Tag('.attr.'), None,
                                                   (coerceToTerm(k), coerceToTerm(v)), None)
                                         for (k, v) in val.items()),
                    None)
    raise ValueError("Could not coerce %r to Term" % (val,))

class TermMaker(object):
    def __getattr__(self, name):
        def mkterm(*args, **kwargs):
            return Term(Tag(name), None,
                        tuple([coerceToTerm(a) for a in args]),
                        kwargs.get('span', None))
        return mkterm

termMaker = TermMaker()


########NEW FILE########
__FILENAME__ = parser
import string
from ometa.grammar import loadGrammar
from ometa.runtime import character, EOFError
import terml
from terml.nodes import Tag, Term, termMaker

try:
    integer_types = (int, long)
except NameError:
    integer_types = (int,)


## Functions called from grammar actions

def concat(*bits):
    return ''.join(map(str, bits))

Character = termMaker.Character

def makeFloat(sign, ds, tail):
        return float((sign or '') + ds + tail)

def signedInt(sign, x, base=10):
    return int(str((sign or '')+x), base)

def join(x):
    return ''.join(x)

def makeHex(sign, hs):
    return int((sign or '') + ''.join(hs), 16)

def makeOctal(sign, ds):
    return int((sign or '') + '0'+''.join(ds), 8)

def isDigit(x):
    return x in string.digits

def isOctDigit(x):
    return x in string.octdigits

def isHexDigit(x):
    return x in string.hexdigits

def contains(container, value):
    return value in container

def cons(first, rest):
    return [first] + rest

def Character(char):
    return character(char)

def makeTag(nameSegs):
    return Tag('::'.join(nameSegs))

def prefixedTag(tagnameSegs):
    return makeTag([''] + tagnameSegs)

def tagString(string):
    return '"' + string + '"'

def numberType(n):
    if isinstance(n, float):
        return ".float64."
    elif isinstance(n, integer_types):
        return ".int."
    raise ValueError("wtf")

def leafInternal(tag, data, span=None):
    return Term(tag, data, None, None)

def makeTerm(t, args=None, span=None):
    if isinstance(t, Term):
        if t.data is not None:
            if not args:
                return t
            else:
                raise ValueError("Literal terms can't have arguments")
    return Term(t.asFunctor(), None, args and tuple(args), span)


def Tuple(args, span=None):
    return Term(Tag(".tuple."), None, tuple(args), span)

def Bag(args, span=None):
    return Term(Tag(".bag."), None, tuple(args), span)

def LabelledBag(f, arg, span=None):
    return Term(f.asFunctor(), None, (arg,), span)

def Attr(k, v, span=None):
    return Term(Tag(".attr."), None, (k, v), span)

TermLParser = loadGrammar(terml, "terml", globals())


def parseTerm(termString):
    """
    Build a TermL term tree from a string.
    """
    p = TermLParser(termString)
    result, error = p.apply("term")
    try:
        p.input.head()
    except EOFError:
        pass
    else:
        raise error
    return result

########NEW FILE########
__FILENAME__ = qnodes
import itertools
from collections import namedtuple
from terml.nodes import Term, Tag, coerceToTerm

try:
    basestring
except NameError:
    basestring = str


class QTerm(namedtuple("QTerm", "functor data args span")):
    """
    A quasiterm, representing a template or pattern for a term tree.
    """
    @property
    def tag(self):
        return self.functor.tag

    def _substitute(self, map):
        candidate = self.functor._substitute(map)[0]
        args = tuple(itertools.chain.from_iterable(a._substitute(map) for a in self.args))
        term = Term(candidate.tag, candidate.data, args, self.span)
        return [term]

    def substitute(self, map):
        """
        Fill $-holes with named values.

        @param map: A mapping of names to values to be inserted into
        the term tree.
        """
        return self._substitute(map)[0]

    def match(self, specimen, substitutionArgs=()):
        """
        Search a term tree for matches to this pattern. Returns a
        mapping of names to matched values.

        @param specimen: A term tree to extract values from.
        """
        bindings = {}
        if self._match(substitutionArgs, [specimen], bindings, (), 1) == 1:
            return bindings
        raise TypeError("%r doesn't match %r" % (self, specimen))

    def _reserve(self):
        return 1

    def _match(self, args, specimens, bindings, index, max):
        if not specimens:
            return -1
        spec = self._coerce(specimens[0])
        if spec is None:
            return -1
        matches = self.functor._match(args, [spec.withoutArgs()], bindings, index, 1)
        if not matches:
            return -1
        if matches > 1:
            raise TypeError("Functor may only match 0 or 1 specimen")
        num = matchArgs(self.args, spec.args, args, bindings, index, len(spec.args))
        if len(spec.args) == num:
            if max >= 1:
                return 1
        return -1

    def _coerce(self, spec):
        if isinstance(spec, Term):
            newf = coerceToQuasiMatch(spec.withoutArgs(),
                                      self.functor.isFunctorHole,
                                      self.tag)
            if newf is None:
                return None
            return Term(newf.asFunctor(), None, spec.args, None)
        else:
            return coerceToQuasiMatch(spec, self.functor.isFunctorHole,
                                      self.tag)

    def __eq__(self, other):
        return (     self.functor, self.data, self.args
               ) == (other.functor, other.data, other.args)

    def asFunctor(self):
        if self.args:
            raise ValueError("Terms with args can't be used as functors")
        else:
            return self.functor

class QFunctor(namedtuple("QFunctor", "tag data span")):
    isFunctorHole = False
    def _reserve(self):
        return 1

    @property
    def name(self):
        return self.tag.name

    def _unparse(self, indentLevel=0):
        return self.tag._unparse(indentLevel)

    def _substitute(self, map):
        return [Term(self.tag, self.data, None, self.span)]

    def _match(self, args, specimens, bindings, index, max):
        if not specimens:
            return -1
        spec = coerceToQuasiMatch(specimens[0], False, self.tag)
        if spec is None:
            return -1
        if self.data is not None and self.data != spec.data:
            return -1
        if max >= 1:
            return 1
        return -1

    def asFunctor(self):
        return self

def matchArgs(quasiArglist, specimenArglist, args, bindings, index, max):
    specs = specimenArglist
    reserves = [q._reserve() for q in quasiArglist]
    numConsumed = 0
    for i, qarg in enumerate(quasiArglist):
        num = qarg._match(args, specs, bindings, index, max - sum(reserves[i + 1:]))
        if num == -1:
            return -1
        specs = specs[num:]
        max -= num
        numConsumed += num
    return numConsumed


def coerceToQuasiMatch(val, isFunctorHole, tag):
    if isFunctorHole:
        if val is None:
            result = Term(Tag("null"), None, None, None)
        elif isinstance(val, Term):
            if len(val.args) != 0:
                return None
            else:
                result = val
        elif isinstance(val, basestring):
            result = Term(Tag(val), None, None, None)
        elif isinstance(val, bool):
            result = Term(Tag(["false", "true"][val]), None, None, None)
        else:
            return None
    else:
        result = coerceToTerm(val)
    if tag is not None and result.tag != tag:
        return None
    return result

class _Hole(namedtuple("_Hole", "tag name isFunctorHole")):
    def _reserve(self):
        return 1

    def __repr__(self):
        return "term('%s')" % (self._unparse(4).replace("'", "\\'"))

    def match(self, specimen, substitutionArgs=()):
        bindings = {}
        if self._match(substitutionArgs, [specimen], bindings, (), 1) != -1:
            return bindings
        raise TypeError("%r doesn't match %r" % (self, specimen))


def _multiget(args, holenum, index, repeat):
    result = args[holenum]
    for i in index:
        if not isinstance(result, list):
            return result
        result = result[i]
    return result

def _multiput(bindings, holenum, index, newval):
    bits = bindings
    dest = holenum
    for it in index:
        next = bits[dest]
        if next is None:
            next = {}
            bits[dest] = next
        bits = next
        dest = it
    result = None
    if dest in bits:
        result = bits[dest]
    bits[dest] = newval
    return result

class ValueHole(_Hole):
    def _unparse(self, indentLevel=0):
        return "${%s}" % (self.name,)

    def _substitute(self, map):
        termoid = map[self.name]
        val = coerceToQuasiMatch(termoid, self.isFunctorHole, self.tag)
        if val is None:
            raise TypeError("%r doesn't match %r" % (termoid, self))
        return [val]

    def asFunctor(self):
        if self.isFunctorHole:
            return self
        else:
            return ValueHole(self.tag, self.name, True)


class PatternHole(_Hole):

    def _unparse(self, indentLevel=0):
        if self.tag:
            return "%s@{%s}" % (self.tag.name, self.name)
        else:
            return "@{%s}" % (self.name,)

    def _match(self, args, specimens, bindings, index, max):
        if not specimens:
            return -1
        spec = coerceToQuasiMatch(specimens[0], self.isFunctorHole, self.tag)
        if spec is None:
            return -1
        oldval = _multiput(bindings, self.name, index, spec)
        if oldval is None or oldval != spec:
            if max >= 1:
                return 1
        return -1


    def asFunctor(self):
        if self.isFunctorHole:
            return self
        else:
            return PatternHole(self.tag, self.name, True)

class QSome(namedtuple("_QSome", "value quant")):
    def _reserve(self):
        if self.quant == "+":
            return 1
        else:
            return 0

########NEW FILE########
__FILENAME__ = quasiterm
from ometa.grammar import loadGrammar
from ometa.runtime import EOFError
import terml
from terml.parser import TermLParser
from terml.qnodes import ValueHole, PatternHole, QTerm, QSome, QFunctor


def interleave(l, *r):
    if r:
        raise NotImplementedError()
    return l

def _or(l, *r):
    if r:
        raise NotImplementedError()
    return l

def some(value, quant):
    if quant:
        return QSome(value, quant)
    else:
        return value

def dollarHole(i):
    return ValueHole(None, i, False)

def patternHole(i):
    return PatternHole(None, i, False)

def taggedHole(t, h):
    return h.__class__(t, h.name, h.isFunctorHole)

def leafInternal(tag, data, span=None):
    return QFunctor(tag, data, span)


def makeTerm(t, args=None, span=None):
    if args is None:
        return t
    else:
        if isinstance(t, QTerm):
            if t.data:
                if not args:
                    return t
                else:
                    raise ValueError("Literal terms can't have arguments")
    return QTerm(t.asFunctor(), None, args and tuple(args), span)


QTermParser = loadGrammar(terml, "quasiterm", TermLParser.globals, TermLParser)
QTermParser.globals.update(globals())


def quasiterm(termString):
    """
    Build a quasiterm from a string.
    """
    p = QTermParser(termString)
    result, error = p.apply("term")
    try:
        p.input.head()
    except EOFError:
        pass
    else:
        raise error
    return result

########NEW FILE########
__FILENAME__ = test_quasiterm

from unittest import TestCase
from terml.parser import parseTerm as term
from terml.quasiterm import quasiterm

class QuasiTermSubstituteTests(TestCase):

    def test_basic(self):
        x = quasiterm("foo($x, $y)").substitute({"x": 1, "y": term("baz")})
        self.assertEqual(x, term("foo(1, baz)"))
        y = quasiterm("foo($0, ${1})").substitute([1, term("baz")])
        self.assertEqual(y, term("foo(1, baz)"))


    def test_withArgs(self):
        x = quasiterm("$x(3)").substitute({"x": term("foo")})
        self.assertEqual(x, term("foo(3)"))
        x = quasiterm("foo($x)").substitute({"x": term("baz(3)")})
        self.assertEqual(x, term("foo(baz(3))"))
        self.assertRaises(TypeError, quasiterm("$x(3)").substitute,
                          {"x": term("foo(3)")})


class QuasiTermMatchTests(TestCase):

    def test_simple(self):
        self.assertEqual(quasiterm("@foo()").match("hello"),
                         {"foo": term('hello')})
        self.assertEqual(quasiterm("@foo").match("hello"),
                         {"foo": term('"hello"')})
        self.assertEqual(quasiterm("@foo").match(term("hello")),
                         {"foo": term('hello')})
        self.assertRaises(TypeError, quasiterm("hello@foo").match, "hello")
        self.assertEqual(quasiterm(".String.@foo").match(term('"hello"')),
                         {"foo": term('"hello"')})
        self.assertEqual(quasiterm(".String.@foo").match("hello"),
                         {"foo": term('"hello"')})
        self.assertEqual(quasiterm("hello@foo").match(term("hello(3, 4)")),
                         {"foo": term("hello(3, 4)")})
        self.assertEqual(quasiterm("hello@bar()").match(term("hello")),
                         {"bar": term("hello")})
        self.assertEqual(quasiterm("hello@foo()").match("hello"),
                         {"foo": term("hello")})
        self.assertEqual(quasiterm("Foo(@x, Bar(1, @y))").match(
                term("Foo(a, Bar(1, 2))")),
                         {"x": term("a"), "y": term("2")})
        self.assertRaises(TypeError, quasiterm("Foo(@x, Bar(3, @y))").match,
                          term("Foo(a, Bar(1, 2))"))
        self.assertRaises(TypeError, quasiterm("hello@foo()").match,
                          term("hello(3, 4)"))
        self.assertRaises(TypeError, quasiterm("hello@foo").match,
                          "hello")

########NEW FILE########
__FILENAME__ = test_terml
import unittest
from ometa.runtime import ParseError
from terml.nodes import Tag, Term, coerceToTerm, TermMaker, termMaker
from terml.parser import TermLParser, character, parseTerm


class TestCase(unittest.TestCase):
    def assertRaises(self, ex, f, *args, **kwargs):
        try:
            f(*args, **kwargs)
        except ex as e:
            return e
        else:
            assert False, "%r didn't raise %r" % (f, ex)


class TermMakerTests(TestCase):
    def test_make(self):
        m = TermMaker()
        t1 = m.Foo(1, 'a', m.Baz())
        self.assertEqual(t1, parseTerm('Foo(1, "a", Baz)'))


class ParserTest(TestCase):
    """
    Test TermL parser rules.
    """


    def getParser(self, rule):
        def parse(src):
            p = TermLParser(src)
            result, error = p.apply(rule)
            return result
        return parse


    def test_literal(self):
        """
        Literals are parsed to literal terms.
        """
        parse = self.getParser("literal")
        self.assertEqual(parse('"foo bar"'),
                         Term(Tag('.String.'), "foo bar", None, None))
        self.assertEqual(parse("'x'"),
                         Term(Tag('.char.'), 'x', None, None))
        self.assertEqual(parse("0xDECAFC0FFEEBAD"),
                         Term(Tag('.int.'), 0xDECAFC0FFEEBAD, None, None))
        self.assertEqual(parse("0755"),
                         Term(Tag('.int.'), 0o755, None, None))
        self.assertEqual(parse("3.14159E17"),
                         Term(Tag('.float64.'), 3.14159E17, None, None))
        self.assertEqual(parse("1e9"),
                         Term(Tag('.float64.'), 1e9, None, None))
        self.assertEqual(parse("0"), Term(Tag(".int."), 0, None, None))
        self.assertEqual(parse("7"), Term(Tag(".int."), 7, None, None))
        self.assertEqual(parse("-1"), Term(Tag(".int."), -1, None, None))
        self.assertEqual(parse("-3.14"),
                         Term(Tag('.float64.'), -3.14, None, None))
        self.assertEqual(parse("3_000"),
                         Term(Tag('.int.'), 3000, None, None))
        self.assertEqual(parse("0.91"),
                         Term(Tag('.float64.'), 0.91, None, None))
        self.assertEqual(parse("3e-2"),
                         Term(Tag('.float64.'), 3e-2, None, None))
        self.assertEqual(parse("'\\n'"),
                         Term(Tag('.char.'), character("\n"), None, None))
        self.assertEqual(parse('"foo\\nbar"'),
                         Term(Tag('.String.'), "foo\nbar", None, None))
        self.assertEqual(parse("'\\u0061'"),
                         Term(Tag('.char.'), character("a"), None, None))
        self.assertEqual(parse('"z\141p"'),
                         Term(Tag('.String.'), "zap", None, None))
        self.assertEqual(parse('"x\41"'),
                         Term(Tag('.String.'), "x!", None, None))
        self.assertEqual(parse('"foo\\\nbar"'),
                         Term(Tag('.String.'), "foobar", None, None))


    def test_simpleTag(self):
        """
        Tags are parsed properly.
        """

        parse = self.getParser("tag")
        self.assertEqual(parse("foo"), Tag("foo"))
        self.assertEqual(parse('::"foo"'), Tag('::"foo"'))
        self.assertEqual(parse("::foo"), Tag('::foo'))
        self.assertEqual(parse("foo::baz"), Tag('foo::baz'))
        self.assertEqual(parse('foo::"baz"'), Tag('foo::"baz"'))
        self.assertEqual(parse("biz::baz::foo"), Tag('biz::baz::foo'))
        self.assertEqual(parse("foo_yay"), Tag('foo_yay'))
        self.assertEqual(parse("foo$baz32"), Tag('foo$baz32'))
        self.assertEqual(parse("foo-baz.19"), Tag('foo-baz.19'))


    def test_simpleTerm(self):
        """
        Kernel syntax for terms is parsed properly.
        """

        parse = self.getParser("baseTerm")
        self.assertEqual(parse("x"), Term(Tag("x"), None, None, None))
        self.assertEqual(parse("x()"), Term(Tag("x"), None, [], None))
        self.assertEqual(parse("x(1)"), Term(Tag("x"), None,
                                             (Term(Tag(".int."), 1, None, None),),
                                             None))
        self.assertEqual(parse("x(1, 2)"), Term(Tag("x"), None,
                                                (Term(Tag(".int."), 1,
                                                      None, None),
                                                 Term(Tag(".int."), 2,
                                                      None, None)),
                                                None))
        self.assertEqual(parse("1"), Term(Tag(".int."), 1, None, None))
        self.assertEqual(parse('"1"'), Term(Tag(".String."), "1", None, None))
        self.assertRaises(ValueError, parse, "'x'(x)")
        self.assertRaises(ValueError, parse, '3.14(1)')
        self.assertRaises(ValueError, parse, '"foo"(x)')
        self.assertRaises(ValueError, parse, "1(2)")


    def test_fullTerm(self):
        """
        Shortcut syntax for terms is handled.
        """

        self.assertEqual(parseTerm("[x, y, 1]"), parseTerm(".tuple.(x, y, 1)"))
        self.assertEqual(parseTerm("{x, y, 1}"), parseTerm(".bag.(x, y, 1)"))
        self.assertEqual(parseTerm("f {x, y, 1}"), parseTerm("f(.bag.(x, y, 1))"))
        self.assertEqual(parseTerm("a: b"), parseTerm(".attr.(a, b)"))
        self.assertEqual(parseTerm('"a": b'), parseTerm('.attr.("a", b)'))
        self.assertEqual(parseTerm('a: [b]'), parseTerm('.attr.(a, .tuple.(b))'))


    def test_multiline(self):
        """
        Terms spread across multiple lines are parsed correctly.
        """
        single = parseTerm('foo(baz({x: "y", boz: 42}))')
        multi = parseTerm(
                """foo(
                    baz({
                     x: "y",
                     boz: 42}
                   ))""")
        self.assertEqual(multi, single)


    def test_leftovers(self):
        e = self.assertRaises(ParseError, parseTerm, "foo(x) and stuff")
        self.assertEqual(e.position, 7)


    def test_unparse(self):

        def assertRoundtrip(txt):
            self.assertEqual('term(%r)' % (txt,), repr(parseTerm(txt)))
        cases = ["1", "3.25", "f", "f(1)", "f(1, 2)", "f(a, b)",
                  "{a, b}", "[a, b]", "f{1, 2}",  '''{"name": "Robert", attrs: {'c': 3}}''']
        for case in cases:
            assertRoundtrip(case)


    def test_coerce(self):
        self.assertEqual(
            coerceToTerm({3: 4, "a": character('x'), (2, 3): [4, 5]}),
            parseTerm('{"a": \'x\', 3: 4, [2, 3]: [4, 5]}'))


    def test_hash(self):
        t = TermMaker()
        a = t.Arbitrary('foo')
        b = t.Arbitrary('foo')
        self.assertEqual(hash(a), hash(b))

########NEW FILE########
__FILENAME__ = quasiterm
def createParserClass(GrammarBase, ruleGlobals):
    if ruleGlobals is None:
        ruleGlobals = {}
    class quasiterm(GrammarBase):
        def rule_schema(self):
            _locals = {'self': self}
            self.locals['schema'] = _locals
            def _G_many1_1():
                self._trace(' production', (8, 19), self.input.position)
                _G_apply_2, lastError = self._apply(self.rule_production, "production", [])
                self.considerError(lastError, None)
                return (_G_apply_2, self.currentError)
            _G_many1_3, lastError = self.many(_G_many1_1, _G_many1_1())
            self.considerError(lastError, 'schema')
            _locals['ps'] = _G_many1_3
            _G_python_4, lastError = eval('schema(ps)', self.globals, _locals), None
            self.considerError(lastError, 'schema')
            return (_G_python_4, self.currentError)


        def rule_production(self):
            _locals = {'self': self}
            self.locals['production'] = _locals
            self._trace(' tag', (50, 54), self.input.position)
            _G_apply_5, lastError = self._apply(self.rule_tag, "tag", [])
            self.considerError(lastError, 'production')
            _locals['t'] = _G_apply_5
            self._trace(' ws', (56, 59), self.input.position)
            _G_apply_6, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'production')
            self._trace(" '::='", (59, 65), self.input.position)
            _G_exactly_7, lastError = self.exactly('::=')
            self.considerError(lastError, 'production')
            self._trace(' argList', (65, 73), self.input.position)
            _G_apply_8, lastError = self._apply(self.rule_argList, "argList", [])
            self.considerError(lastError, 'production')
            _locals['a'] = _G_apply_8
            self._trace(' ws', (75, 78), self.input.position)
            _G_apply_9, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'production')
            self._trace(" ';'", (78, 82), self.input.position)
            _G_exactly_10, lastError = self.exactly(';')
            self.considerError(lastError, 'production')
            _G_python_11, lastError = eval('production(t, a)', self.globals, _locals), None
            self.considerError(lastError, 'production')
            return (_G_python_11, self.currentError)


        def rule_functor(self):
            _locals = {'self': self}
            self.locals['functor'] = _locals
            def _G_or_12():
                self._trace('spaces', (115, 121), self.input.position)
                _G_apply_13, lastError = self._apply(self.rule_spaces, "spaces", [])
                self.considerError(lastError, None)
                def _G_or_14():
                    self._trace('functorHole', (125, 136), self.input.position)
                    _G_apply_15, lastError = self._apply(self.rule_functorHole, "functorHole", [])
                    self.considerError(lastError, None)
                    self._trace(' functorHole', (136, 148), self.input.position)
                    _G_apply_16, lastError = self._apply(self.rule_functorHole, "functorHole", [])
                    self.considerError(lastError, None)
                    _G_python_17, lastError = eval('reserved("hole-tagged-hole")', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_17, self.currentError)
                def _G_or_18():
                    def _G_optional_19():
                        self._trace("'.'", (203, 206), self.input.position)
                        _G_exactly_20, lastError = self.exactly('.')
                        self.considerError(lastError, None)
                        return (_G_exactly_20, self.currentError)
                    def _G_optional_21():
                        return (None, self.input.nullError())
                    _G_or_22, lastError = self._or([_G_optional_19, _G_optional_21])
                    self.considerError(lastError, None)
                    self._trace(' functorHole', (207, 219), self.input.position)
                    _G_apply_23, lastError = self._apply(self.rule_functorHole, "functorHole", [])
                    self.considerError(lastError, None)
                    return (_G_apply_23, self.currentError)
                def _G_or_24():
                    self._trace('tag', (242, 245), self.input.position)
                    _G_apply_25, lastError = self._apply(self.rule_tag, "tag", [])
                    self.considerError(lastError, None)
                    _locals['t'] = _G_apply_25
                    self._trace(' functorHole', (247, 259), self.input.position)
                    _G_apply_26, lastError = self._apply(self.rule_functorHole, "functorHole", [])
                    self.considerError(lastError, None)
                    _locals['h'] = _G_apply_26
                    _G_python_27, lastError = eval('taggedHole(t, h)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_27, self.currentError)
                _G_or_28, lastError = self._or([_G_or_14, _G_or_18, _G_or_24])
                self.considerError(lastError, None)
                return (_G_or_28, self.currentError)
            def _G_or_29():
                self._trace(' super', (296, 302), self.input.position)
                _G_apply_30, lastError = self.superApply("functor", )
                self.considerError(lastError, None)
                return (_G_apply_30, self.currentError)
            _G_or_31, lastError = self._or([_G_or_12, _G_or_29])
            self.considerError(lastError, 'functor')
            return (_G_or_31, self.currentError)


        def rule_arg(self):
            _locals = {'self': self}
            self.locals['arg'] = _locals
            self._trace(' interleave', (309, 320), self.input.position)
            _G_apply_32, lastError = self._apply(self.rule_interleave, "interleave", [])
            self.considerError(lastError, 'arg')
            _locals['l'] = _G_apply_32
            def _G_many_33():
                self._trace('ws', (324, 326), self.input.position)
                _G_apply_34, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '|'", (326, 330), self.input.position)
                _G_exactly_35, lastError = self.exactly('|')
                self.considerError(lastError, None)
                self._trace(' interleave', (330, 341), self.input.position)
                _G_apply_36, lastError = self._apply(self.rule_interleave, "interleave", [])
                self.considerError(lastError, None)
                return (_G_apply_36, self.currentError)
            _G_many_37, lastError = self.many(_G_many_33)
            self.considerError(lastError, 'arg')
            _locals['r'] = _G_many_37
            _G_python_38, lastError = eval('_or(l, *r)', self.globals, _locals), None
            self.considerError(lastError, 'arg')
            return (_G_python_38, self.currentError)


        def rule_interleave(self):
            _locals = {'self': self}
            self.locals['interleave'] = _locals
            self._trace(' action', (372, 379), self.input.position)
            _G_apply_39, lastError = self._apply(self.rule_action, "action", [])
            self.considerError(lastError, 'interleave')
            _locals['l'] = _G_apply_39
            def _G_many_40():
                self._trace('ws', (383, 385), self.input.position)
                _G_apply_41, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '&'", (385, 389), self.input.position)
                _G_exactly_42, lastError = self.exactly('&')
                self.considerError(lastError, None)
                self._trace(' action', (389, 396), self.input.position)
                _G_apply_43, lastError = self._apply(self.rule_action, "action", [])
                self.considerError(lastError, None)
                return (_G_apply_43, self.currentError)
            _G_many_44, lastError = self.many(_G_many_40)
            self.considerError(lastError, 'interleave')
            _locals['r'] = _G_many_44
            _G_python_45, lastError = eval('interleave(l, *r)', self.globals, _locals), None
            self.considerError(lastError, 'interleave')
            return (_G_python_45, self.currentError)


        def rule_action(self):
            _locals = {'self': self}
            self.locals['action'] = _locals
            self._trace(' pred', (430, 435), self.input.position)
            _G_apply_46, lastError = self._apply(self.rule_pred, "pred", [])
            self.considerError(lastError, 'action')
            _locals['l'] = _G_apply_46
            def _G_or_47():
                self._trace('ws', (439, 441), self.input.position)
                _G_apply_48, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '->'", (441, 446), self.input.position)
                _G_exactly_49, lastError = self.exactly('->')
                self.considerError(lastError, None)
                self._trace(' pred', (446, 451), self.input.position)
                _G_apply_50, lastError = self._apply(self.rule_pred, "pred", [])
                self.considerError(lastError, None)
                _locals['r'] = _G_apply_50
                _G_python_51, lastError = eval('action(l, *r)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_51, self.currentError)
            def _G_or_52():
                _G_python_53, lastError = eval('l', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_53, self.currentError)
            _G_or_54, lastError = self._or([_G_or_47, _G_or_52])
            self.considerError(lastError, 'action')
            return (_G_or_54, self.currentError)


        def rule_pred(self):
            _locals = {'self': self}
            self.locals['pred'] = _locals
            def _G_or_55():
                self._trace(' some', (519, 524), self.input.position)
                _G_apply_56, lastError = self._apply(self.rule_some, "some", [])
                self.considerError(lastError, None)
                return (_G_apply_56, self.currentError)
            def _G_or_57():
                self._trace('ws', (528, 530), self.input.position)
                _G_apply_58, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '!'", (530, 534), self.input.position)
                _G_exactly_59, lastError = self.exactly('!')
                self.considerError(lastError, None)
                self._trace(' some', (534, 539), self.input.position)
                _G_apply_60, lastError = self._apply(self.rule_some, "some", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_60
                _G_python_61, lastError = eval('not(x)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_61, self.currentError)
            _G_or_62, lastError = self._or([_G_or_55, _G_or_57])
            self.considerError(lastError, 'pred')
            return (_G_or_62, self.currentError)


        def rule_some(self):
            _locals = {'self': self}
            self.locals['some'] = _locals
            def _G_or_63():
                self._trace('quant', (561, 566), self.input.position)
                _G_apply_64, lastError = self._apply(self.rule_quant, "quant", [])
                self.considerError(lastError, None)
                _locals['q'] = _G_apply_64
                _G_python_65, lastError = eval('some(None, q)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_65, self.currentError)
            def _G_or_66():
                self._trace(' prim', (596, 601), self.input.position)
                _G_apply_67, lastError = self._apply(self.rule_prim, "prim", [])
                self.considerError(lastError, None)
                _locals['l'] = _G_apply_67
                def _G_optional_68():
                    def _G_or_69():
                        self._trace('ws', (607, 609), self.input.position)
                        _G_apply_70, lastError = self._apply(self.rule_ws, "ws", [])
                        self.considerError(lastError, None)
                        self._trace(" '**'", (609, 614), self.input.position)
                        _G_exactly_71, lastError = self.exactly('**')
                        self.considerError(lastError, None)
                        self._trace(' prim', (614, 619), self.input.position)
                        _G_apply_72, lastError = self._apply(self.rule_prim, "prim", [])
                        self.considerError(lastError, None)
                        _locals['r'] = _G_apply_72
                        _G_python_73, lastError = eval('matchSeparatedSequence(l, r)', self.globals, _locals), None
                        self.considerError(lastError, None)
                        return (_G_python_73, self.currentError)
                    def _G_or_74():
                        self._trace('ws', (676, 678), self.input.position)
                        _G_apply_75, lastError = self._apply(self.rule_ws, "ws", [])
                        self.considerError(lastError, None)
                        self._trace(" '++'", (678, 683), self.input.position)
                        _G_exactly_76, lastError = self.exactly('++')
                        self.considerError(lastError, None)
                        self._trace(' prim', (683, 688), self.input.position)
                        _G_apply_77, lastError = self._apply(self.rule_prim, "prim", [])
                        self.considerError(lastError, None)
                        _locals['r'] = _G_apply_77
                        _G_python_78, lastError = eval('matchSeparatedSequence1(l, r)', self.globals, _locals), None
                        self.considerError(lastError, None)
                        return (_G_python_78, self.currentError)
                    _G_or_79, lastError = self._or([_G_or_69, _G_or_74])
                    self.considerError(lastError, None)
                    return (_G_or_79, self.currentError)
                def _G_optional_80():
                    return (None, self.input.nullError())
                _G_or_81, lastError = self._or([_G_optional_68, _G_optional_80])
                self.considerError(lastError, None)
                _locals['seq'] = _G_or_81
                def _G_optional_82():
                    self._trace('\n           quant', (749, 766), self.input.position)
                    _G_apply_83, lastError = self._apply(self.rule_quant, "quant", [])
                    self.considerError(lastError, None)
                    return (_G_apply_83, self.currentError)
                def _G_optional_84():
                    return (None, self.input.nullError())
                _G_or_85, lastError = self._or([_G_optional_82, _G_optional_84])
                self.considerError(lastError, None)
                _locals['q'] = _G_or_85
                _G_python_86, lastError = eval('some(seq or l, q)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_86, self.currentError)
            _G_or_87, lastError = self._or([_G_or_63, _G_or_66])
            self.considerError(lastError, 'some')
            return (_G_or_87, self.currentError)


        def rule_quant(self):
            _locals = {'self': self}
            self.locals['quant'] = _locals
            self._trace(' ws', (800, 803), self.input.position)
            _G_apply_88, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'quant')
            def _G_or_89():
                self._trace("'?'", (805, 808), self.input.position)
                _G_exactly_90, lastError = self.exactly('?')
                self.considerError(lastError, None)
                return (_G_exactly_90, self.currentError)
            def _G_or_91():
                self._trace("'+'", (810, 813), self.input.position)
                _G_exactly_92, lastError = self.exactly('+')
                self.considerError(lastError, None)
                return (_G_exactly_92, self.currentError)
            def _G_or_93():
                self._trace(" '*'", (815, 819), self.input.position)
                _G_exactly_94, lastError = self.exactly('*')
                self.considerError(lastError, None)
                return (_G_exactly_94, self.currentError)
            _G_or_95, lastError = self._or([_G_or_89, _G_or_91, _G_or_93])
            self.considerError(lastError, 'quant')
            return (_G_or_95, self.currentError)


        def rule_prim(self):
            _locals = {'self': self}
            self.locals['prim'] = _locals
            def _G_or_96():
                self._trace(' term', (827, 832), self.input.position)
                _G_apply_97, lastError = self._apply(self.rule_term, "term", [])
                self.considerError(lastError, None)
                return (_G_apply_97, self.currentError)
            def _G_or_98():
                self._trace("'.'", (841, 844), self.input.position)
                _G_exactly_99, lastError = self.exactly('.')
                self.considerError(lastError, None)
                _G_python_100, lastError = eval('any()', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_100, self.currentError)
            def _G_or_101():
                self._trace('literal', (863, 870), self.input.position)
                _G_apply_102, lastError = self._apply(self.rule_literal, "literal", [])
                self.considerError(lastError, None)
                _locals['l'] = _G_apply_102
                self._trace(' ws', (872, 875), self.input.position)
                _G_apply_103, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '..'", (875, 880), self.input.position)
                _G_exactly_104, lastError = self.exactly('..')
                self.considerError(lastError, None)
                self._trace(' literal', (880, 888), self.input.position)
                _G_apply_105, lastError = self._apply(self.rule_literal, "literal", [])
                self.considerError(lastError, None)
                _locals['r'] = _G_apply_105
                _G_python_106, lastError = eval('range(l, r)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_106, self.currentError)
            def _G_or_107():
                self._trace(' ws', (913, 916), self.input.position)
                _G_apply_108, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '^'", (916, 920), self.input.position)
                _G_exactly_109, lastError = self.exactly('^')
                self.considerError(lastError, None)
                self._trace(' string', (920, 927), self.input.position)
                _G_apply_110, lastError = self._apply(self.rule_string, "string", [])
                self.considerError(lastError, None)
                _locals['s'] = _G_apply_110
                _G_python_111, lastError = eval('anyOf(s)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_111, self.currentError)
            def _G_or_112():
                self._trace(' ws', (948, 951), self.input.position)
                _G_apply_113, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" '('", (951, 955), self.input.position)
                _G_exactly_114, lastError = self.exactly('(')
                self.considerError(lastError, None)
                self._trace(' argList', (955, 963), self.input.position)
                _G_apply_115, lastError = self._apply(self.rule_argList, "argList", [])
                self.considerError(lastError, None)
                _locals['l'] = _G_apply_115
                self._trace(' ws', (965, 968), self.input.position)
                _G_apply_116, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" ')'", (968, 972), self.input.position)
                _G_exactly_117, lastError = self.exactly(')')
                self.considerError(lastError, None)
                _G_python_118, lastError = eval('l', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_118, self.currentError)
            _G_or_119, lastError = self._or([_G_or_96, _G_or_98, _G_or_101, _G_or_107, _G_or_112])
            self.considerError(lastError, 'prim')
            return (_G_or_119, self.currentError)


        def rule_simpleint(self):
            _locals = {'self': self}
            self.locals['simpleint'] = _locals
            self._trace(' decdigits', (990, 1000), self.input.position)
            _G_apply_120, lastError = self._apply(self.rule_decdigits, "decdigits", [])
            self.considerError(lastError, 'simpleint')
            _locals['ds'] = _G_apply_120
            _G_python_121, lastError = eval('int(ds)', self.globals, _locals), None
            self.considerError(lastError, 'simpleint')
            return (_G_python_121, self.currentError)


        def rule_functorHole(self):
            _locals = {'self': self}
            self.locals['functorHole'] = _locals
            def _G_or_122():
                self._trace(" '$'", (1028, 1032), self.input.position)
                _G_exactly_123, lastError = self.exactly('$')
                self.considerError(lastError, None)
                def _G_or_124():
                    self._trace('simpleint', (1041, 1050), self.input.position)
                    _G_apply_125, lastError = self._apply(self.rule_simpleint, "simpleint", [])
                    self.considerError(lastError, None)
                    _locals['i'] = _G_apply_125
                    return (_locals['i'], self.currentError)
                def _G_or_126():
                    self._trace(" '{'", (1054, 1058), self.input.position)
                    _G_exactly_127, lastError = self.exactly('{')
                    self.considerError(lastError, None)
                    self._trace(' simpleint', (1058, 1068), self.input.position)
                    _G_apply_128, lastError = self._apply(self.rule_simpleint, "simpleint", [])
                    self.considerError(lastError, None)
                    _locals['i'] = _G_apply_128
                    self._trace(" '}'", (1070, 1074), self.input.position)
                    _G_exactly_129, lastError = self.exactly('}')
                    self.considerError(lastError, None)
                    return (_G_exactly_129, self.currentError)
                def _G_or_130():
                    self._trace('tag', (1078, 1081), self.input.position)
                    _G_apply_131, lastError = self._apply(self.rule_tag, "tag", [])
                    self.considerError(lastError, None)
                    _locals['t'] = _G_apply_131
                    _G_python_132, lastError = eval('t.name', self.globals, _locals), None
                    self.considerError(lastError, None)
                    _locals['i'] = _G_python_132
                    return (_locals['i'], self.currentError)
                _G_or_133, lastError = self._or([_G_or_124, _G_or_126, _G_or_130])
                self.considerError(lastError, None)
                _G_python_134, lastError = eval('dollarHole(i)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_134, self.currentError)
            def _G_or_135():
                def _G_or_136():
                    self._trace("'@'", (1129, 1132), self.input.position)
                    _G_exactly_137, lastError = self.exactly('@')
                    self.considerError(lastError, None)
                    return (_G_exactly_137, self.currentError)
                def _G_or_138():
                    self._trace(" '='", (1134, 1138), self.input.position)
                    _G_exactly_139, lastError = self.exactly('=')
                    self.considerError(lastError, None)
                    return (_G_exactly_139, self.currentError)
                _G_or_140, lastError = self._or([_G_or_136, _G_or_138])
                self.considerError(lastError, None)
                def _G_or_141():
                    self._trace('simpleint', (1141, 1150), self.input.position)
                    _G_apply_142, lastError = self._apply(self.rule_simpleint, "simpleint", [])
                    self.considerError(lastError, None)
                    _locals['i'] = _G_apply_142
                    return (_locals['i'], self.currentError)
                def _G_or_143():
                    self._trace(" '{'", (1154, 1158), self.input.position)
                    _G_exactly_144, lastError = self.exactly('{')
                    self.considerError(lastError, None)
                    self._trace(' simpleint', (1158, 1168), self.input.position)
                    _G_apply_145, lastError = self._apply(self.rule_simpleint, "simpleint", [])
                    self.considerError(lastError, None)
                    _locals['i'] = _G_apply_145
                    self._trace(" '}'", (1170, 1174), self.input.position)
                    _G_exactly_146, lastError = self.exactly('}')
                    self.considerError(lastError, None)
                    return (_G_exactly_146, self.currentError)
                def _G_or_147():
                    self._trace('tag', (1178, 1181), self.input.position)
                    _G_apply_148, lastError = self._apply(self.rule_tag, "tag", [])
                    self.considerError(lastError, None)
                    _locals['t'] = _G_apply_148
                    _G_python_149, lastError = eval('t.name', self.globals, _locals), None
                    self.considerError(lastError, None)
                    _locals['i'] = _G_python_149
                    return (_locals['i'], self.currentError)
                _G_or_150, lastError = self._or([_G_or_141, _G_or_143, _G_or_147])
                self.considerError(lastError, None)
                _G_python_151, lastError = eval('patternHole(i)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_151, self.currentError)
            _G_or_152, lastError = self._or([_G_or_122, _G_or_135])
            self.considerError(lastError, 'functorHole')
            return (_G_or_152, self.currentError)


    if quasiterm.globals is not None:
        quasiterm.globals = quasiterm.globals.copy()
        quasiterm.globals.update(ruleGlobals)
    else:
        quasiterm.globals = ruleGlobals
    return quasiterm
########NEW FILE########
__FILENAME__ = terml
def createParserClass(GrammarBase, ruleGlobals):
    if ruleGlobals is None:
        ruleGlobals = {}
    class terml(GrammarBase):
        def rule_hspace(self):
            _locals = {'self': self}
            self.locals['hspace'] = _locals
            def _G_or_1():
                self._trace("' '", (10, 13), self.input.position)
                _G_exactly_2, lastError = self.exactly(' ')
                self.considerError(lastError, None)
                return (_G_exactly_2, self.currentError)
            def _G_or_3():
                self._trace("'\\t'", (14, 18), self.input.position)
                _G_exactly_4, lastError = self.exactly('\t')
                self.considerError(lastError, None)
                return (_G_exactly_4, self.currentError)
            def _G_or_5():
                self._trace("'\\f'", (19, 23), self.input.position)
                _G_exactly_6, lastError = self.exactly('\x0c')
                self.considerError(lastError, None)
                return (_G_exactly_6, self.currentError)
            def _G_or_7():
                self._trace("'#'", (25, 28), self.input.position)
                _G_exactly_8, lastError = self.exactly('#')
                self.considerError(lastError, None)
                def _G_many_9():
                    def _G_not_10():
                        self._trace('eol', (31, 34), self.input.position)
                        _G_apply_11, lastError = self._apply(self.rule_eol, "eol", [])
                        self.considerError(lastError, None)
                        return (_G_apply_11, self.currentError)
                    _G_not_12, lastError = self._not(_G_not_10)
                    self.considerError(lastError, None)
                    self._trace(' anything', (34, 43), self.input.position)
                    _G_apply_13, lastError = self._apply(self.rule_anything, "anything", [])
                    self.considerError(lastError, None)
                    return (_G_apply_13, self.currentError)
                _G_many_14, lastError = self.many(_G_many_9)
                self.considerError(lastError, None)
                return (_G_many_14, self.currentError)
            _G_or_15, lastError = self._or([_G_or_1, _G_or_3, _G_or_5, _G_or_7])
            self.considerError(lastError, 'hspace')
            return (_G_or_15, self.currentError)


        def rule_ws(self):
            _locals = {'self': self}
            self.locals['ws'] = _locals
            def _G_many_16():
                def _G_or_17():
                    self._trace("'\\r'", (54, 58), self.input.position)
                    _G_exactly_18, lastError = self.exactly('\r')
                    self.considerError(lastError, None)
                    self._trace(" '\\n'", (58, 63), self.input.position)
                    _G_exactly_19, lastError = self.exactly('\n')
                    self.considerError(lastError, None)
                    return (_G_exactly_19, self.currentError)
                def _G_or_20():
                    self._trace("'\\r'", (64, 68), self.input.position)
                    _G_exactly_21, lastError = self.exactly('\r')
                    self.considerError(lastError, None)
                    return (_G_exactly_21, self.currentError)
                def _G_or_22():
                    self._trace(" '\\n'", (70, 75), self.input.position)
                    _G_exactly_23, lastError = self.exactly('\n')
                    self.considerError(lastError, None)
                    return (_G_exactly_23, self.currentError)
                def _G_or_24():
                    self._trace(' hspace', (77, 84), self.input.position)
                    _G_apply_25, lastError = self._apply(self.rule_hspace, "hspace", [])
                    self.considerError(lastError, None)
                    return (_G_apply_25, self.currentError)
                _G_or_26, lastError = self._or([_G_or_17, _G_or_20, _G_or_22, _G_or_24])
                self.considerError(lastError, None)
                return (_G_or_26, self.currentError)
            _G_many_27, lastError = self.many(_G_many_16)
            self.considerError(lastError, 'ws')
            return (_G_many_27, self.currentError)


        def rule_number(self):
            _locals = {'self': self}
            self.locals['number'] = _locals
            self._trace(' ws', (96, 99), self.input.position)
            _G_apply_28, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'number')
            self._trace(' barenumber', (99, 110), self.input.position)
            _G_apply_29, lastError = self._apply(self.rule_barenumber, "barenumber", [])
            self.considerError(lastError, 'number')
            return (_G_apply_29, self.currentError)


        def rule_barenumber(self):
            _locals = {'self': self}
            self.locals['barenumber'] = _locals
            def _G_optional_30():
                self._trace(" '-'", (123, 127), self.input.position)
                _G_exactly_31, lastError = self.exactly('-')
                self.considerError(lastError, None)
                return (_G_exactly_31, self.currentError)
            def _G_optional_32():
                return (None, self.input.nullError())
            _G_or_33, lastError = self._or([_G_optional_30, _G_optional_32])
            self.considerError(lastError, 'barenumber')
            _locals['sign'] = _G_or_33
            def _G_or_34():
                self._trace("'0'", (136, 139), self.input.position)
                _G_exactly_35, lastError = self.exactly('0')
                self.considerError(lastError, None)
                def _G_or_36():
                    def _G_or_37():
                        self._trace("'x'", (143, 146), self.input.position)
                        _G_exactly_38, lastError = self.exactly('x')
                        self.considerError(lastError, None)
                        return (_G_exactly_38, self.currentError)
                    def _G_or_39():
                        self._trace("'X'", (147, 150), self.input.position)
                        _G_exactly_40, lastError = self.exactly('X')
                        self.considerError(lastError, None)
                        return (_G_exactly_40, self.currentError)
                    _G_or_41, lastError = self._or([_G_or_37, _G_or_39])
                    self.considerError(lastError, None)
                    def _G_many_42():
                        self._trace(' hexdigit', (151, 160), self.input.position)
                        _G_apply_43, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                        self.considerError(lastError, None)
                        return (_G_apply_43, self.currentError)
                    _G_many_44, lastError = self.many(_G_many_42)
                    self.considerError(lastError, None)
                    _locals['hs'] = _G_many_44
                    _G_python_45, lastError = eval('makeHex(sign, hs)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_45, self.currentError)
                def _G_or_46():
                    self._trace("floatPart(sign '0')", (208, 227), self.input.position)
                    _G_python_47, lastError = eval('sign', self.globals, _locals), None
                    self.considerError(lastError, None)
                    _G_python_48, lastError = ('0'), None
                    self.considerError(lastError, None)
                    _G_apply_49, lastError = self._apply(self.rule_floatPart, "floatPart", [_G_python_47, _G_python_48])
                    self.considerError(lastError, None)
                    return (_G_apply_49, self.currentError)
                def _G_or_50():
                    def _G_many_51():
                        self._trace('octaldigit', (249, 259), self.input.position)
                        _G_apply_52, lastError = self._apply(self.rule_octaldigit, "octaldigit", [])
                        self.considerError(lastError, None)
                        return (_G_apply_52, self.currentError)
                    _G_many_53, lastError = self.many(_G_many_51)
                    self.considerError(lastError, None)
                    _locals['ds'] = _G_many_53
                    _G_python_54, lastError = eval('makeOctal(sign, ds)', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_54, self.currentError)
                _G_or_55, lastError = self._or([_G_or_36, _G_or_46, _G_or_50])
                self.considerError(lastError, None)
                return (_G_or_55, self.currentError)
            def _G_or_56():
                self._trace('decdigits', (305, 314), self.input.position)
                _G_apply_57, lastError = self._apply(self.rule_decdigits, "decdigits", [])
                self.considerError(lastError, None)
                _locals['ds'] = _G_apply_57
                self._trace(' floatPart(sign ds)', (317, 336), self.input.position)
                _G_python_58, lastError = eval('sign', self.globals, _locals), None
                self.considerError(lastError, None)
                _G_python_59, lastError = eval('ds', self.globals, _locals), None
                self.considerError(lastError, None)
                _G_apply_60, lastError = self._apply(self.rule_floatPart, "floatPart", [_G_python_58, _G_python_59])
                self.considerError(lastError, None)
                return (_G_apply_60, self.currentError)
            def _G_or_61():
                self._trace('decdigits', (353, 362), self.input.position)
                _G_apply_62, lastError = self._apply(self.rule_decdigits, "decdigits", [])
                self.considerError(lastError, None)
                _locals['ds'] = _G_apply_62
                _G_python_63, lastError = eval('signedInt(sign, ds)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_63, self.currentError)
            _G_or_64, lastError = self._or([_G_or_34, _G_or_56, _G_or_61])
            self.considerError(lastError, 'barenumber')
            return (_G_or_64, self.currentError)


        def rule_exponent(self):
            _locals = {'self': self}
            self.locals['exponent'] = _locals
            def _G_consumedby_65():
                def _G_or_66():
                    self._trace("'e'", (405, 408), self.input.position)
                    _G_exactly_67, lastError = self.exactly('e')
                    self.considerError(lastError, None)
                    return (_G_exactly_67, self.currentError)
                def _G_or_68():
                    self._trace(" 'E'", (410, 414), self.input.position)
                    _G_exactly_69, lastError = self.exactly('E')
                    self.considerError(lastError, None)
                    return (_G_exactly_69, self.currentError)
                _G_or_70, lastError = self._or([_G_or_66, _G_or_68])
                self.considerError(lastError, None)
                def _G_optional_71():
                    def _G_or_72():
                        self._trace("'+'", (417, 420), self.input.position)
                        _G_exactly_73, lastError = self.exactly('+')
                        self.considerError(lastError, None)
                        return (_G_exactly_73, self.currentError)
                    def _G_or_74():
                        self._trace(" '-'", (422, 426), self.input.position)
                        _G_exactly_75, lastError = self.exactly('-')
                        self.considerError(lastError, None)
                        return (_G_exactly_75, self.currentError)
                    _G_or_76, lastError = self._or([_G_or_72, _G_or_74])
                    self.considerError(lastError, None)
                    return (_G_or_76, self.currentError)
                def _G_optional_77():
                    return (None, self.input.nullError())
                _G_or_78, lastError = self._or([_G_optional_71, _G_optional_77])
                self.considerError(lastError, None)
                self._trace(' decdigits', (428, 438), self.input.position)
                _G_apply_79, lastError = self._apply(self.rule_decdigits, "decdigits", [])
                self.considerError(lastError, None)
                return (_G_apply_79, self.currentError)
            _G_consumedby_80, lastError = self.consumedby(_G_consumedby_65)
            self.considerError(lastError, 'exponent')
            return (_G_consumedby_80, self.currentError)


        def rule_floatPart(self):
            _locals = {'self': self}
            self.locals['floatPart'] = _locals
            _G_apply_81, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'floatPart')
            _locals['sign'] = _G_apply_81
            _G_apply_82, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'floatPart')
            _locals['ds'] = _G_apply_82
            def _G_consumedby_83():
                def _G_or_84():
                    self._trace("'.'", (466, 469), self.input.position)
                    _G_exactly_85, lastError = self.exactly('.')
                    self.considerError(lastError, None)
                    self._trace(' decdigits', (469, 479), self.input.position)
                    _G_apply_86, lastError = self._apply(self.rule_decdigits, "decdigits", [])
                    self.considerError(lastError, None)
                    def _G_optional_87():
                        self._trace(' exponent', (479, 488), self.input.position)
                        _G_apply_88, lastError = self._apply(self.rule_exponent, "exponent", [])
                        self.considerError(lastError, None)
                        return (_G_apply_88, self.currentError)
                    def _G_optional_89():
                        return (None, self.input.nullError())
                    _G_or_90, lastError = self._or([_G_optional_87, _G_optional_89])
                    self.considerError(lastError, None)
                    return (_G_or_90, self.currentError)
                def _G_or_91():
                    self._trace(' exponent', (492, 501), self.input.position)
                    _G_apply_92, lastError = self._apply(self.rule_exponent, "exponent", [])
                    self.considerError(lastError, None)
                    return (_G_apply_92, self.currentError)
                _G_or_93, lastError = self._or([_G_or_84, _G_or_91])
                self.considerError(lastError, None)
                return (_G_or_93, self.currentError)
            _G_consumedby_94, lastError = self.consumedby(_G_consumedby_83)
            self.considerError(lastError, 'floatPart')
            _locals['tail'] = _G_consumedby_94
            _G_python_95, lastError = eval('makeFloat(sign, ds, tail)', self.globals, _locals), None
            self.considerError(lastError, 'floatPart')
            return (_G_python_95, self.currentError)


        def rule_decdigits(self):
            _locals = {'self': self}
            self.locals['decdigits'] = _locals
            self._trace(' digit', (549, 555), self.input.position)
            _G_apply_96, lastError = self._apply(self.rule_digit, "digit", [])
            self.considerError(lastError, 'decdigits')
            _locals['d'] = _G_apply_96
            def _G_many_97():
                def _G_or_98():
                    _G_apply_99, lastError = self._apply(self.rule_anything, "anything", [])
                    self.considerError(lastError, None)
                    _locals['x'] = _G_apply_99
                    def _G_pred_100():
                        _G_python_101, lastError = eval('isDigit(x)', self.globals, _locals), None
                        self.considerError(lastError, None)
                        return (_G_python_101, self.currentError)
                    _G_pred_102, lastError = self.pred(_G_pred_100)
                    self.considerError(lastError, None)
                    _G_python_103, lastError = eval('x', self.globals, _locals), None
                    self.considerError(lastError, None)
                    return (_G_python_103, self.currentError)
                def _G_or_104():
                    self._trace(" '_'", (584, 588), self.input.position)
                    _G_exactly_105, lastError = self.exactly('_')
                    self.considerError(lastError, None)
                    _G_python_106, lastError = (""), None
                    self.considerError(lastError, None)
                    return (_G_python_106, self.currentError)
                _G_or_107, lastError = self._or([_G_or_98, _G_or_104])
                self.considerError(lastError, None)
                return (_G_or_107, self.currentError)
            _G_many_108, lastError = self.many(_G_many_97)
            self.considerError(lastError, 'decdigits')
            _locals['ds'] = _G_many_108
            _G_python_109, lastError = eval('concat(d, join(ds))', self.globals, _locals), None
            self.considerError(lastError, 'decdigits')
            return (_G_python_109, self.currentError)


        def rule_octaldigit(self):
            _locals = {'self': self}
            self.locals['octaldigit'] = _locals
            _G_apply_110, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'octaldigit')
            _locals['x'] = _G_apply_110
            def _G_pred_111():
                _G_python_112, lastError = eval('isOctDigit(x)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_112, self.currentError)
            _G_pred_113, lastError = self.pred(_G_pred_111)
            self.considerError(lastError, 'octaldigit')
            _G_python_114, lastError = eval('x', self.globals, _locals), None
            self.considerError(lastError, 'octaldigit')
            return (_G_python_114, self.currentError)


        def rule_hexdigit(self):
            _locals = {'self': self}
            self.locals['hexdigit'] = _locals
            _G_apply_115, lastError = self._apply(self.rule_anything, "anything", [])
            self.considerError(lastError, 'hexdigit')
            _locals['x'] = _G_apply_115
            def _G_pred_116():
                _G_python_117, lastError = eval('isHexDigit(x)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_117, self.currentError)
            _G_pred_118, lastError = self.pred(_G_pred_116)
            self.considerError(lastError, 'hexdigit')
            _G_python_119, lastError = eval('x', self.globals, _locals), None
            self.considerError(lastError, 'hexdigit')
            return (_G_python_119, self.currentError)


        def rule_string(self):
            _locals = {'self': self}
            self.locals['string'] = _locals
            self._trace(' ws', (706, 709), self.input.position)
            _G_apply_120, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'string')
            self._trace(' \'"\'', (709, 713), self.input.position)
            _G_exactly_121, lastError = self.exactly('"')
            self.considerError(lastError, 'string')
            def _G_many_122():
                def _G_or_123():
                    self._trace('escapedChar', (715, 726), self.input.position)
                    _G_apply_124, lastError = self._apply(self.rule_escapedChar, "escapedChar", [])
                    self.considerError(lastError, None)
                    return (_G_apply_124, self.currentError)
                def _G_or_125():
                    def _G_not_126():
                        self._trace('\'"\'', (731, 734), self.input.position)
                        _G_exactly_127, lastError = self.exactly('"')
                        self.considerError(lastError, None)
                        return (_G_exactly_127, self.currentError)
                    _G_not_128, lastError = self._not(_G_not_126)
                    self.considerError(lastError, None)
                    self._trace(' anything', (735, 744), self.input.position)
                    _G_apply_129, lastError = self._apply(self.rule_anything, "anything", [])
                    self.considerError(lastError, None)
                    return (_G_apply_129, self.currentError)
                _G_or_130, lastError = self._or([_G_or_123, _G_or_125])
                self.considerError(lastError, None)
                return (_G_or_130, self.currentError)
            _G_many_131, lastError = self.many(_G_many_122)
            self.considerError(lastError, 'string')
            _locals['c'] = _G_many_131
            self._trace(' \'"\'', (748, 752), self.input.position)
            _G_exactly_132, lastError = self.exactly('"')
            self.considerError(lastError, 'string')
            _G_python_133, lastError = eval('join(c)', self.globals, _locals), None
            self.considerError(lastError, 'string')
            return (_G_python_133, self.currentError)


        def rule_character(self):
            _locals = {'self': self}
            self.locals['character'] = _locals
            self._trace(' ws', (775, 778), self.input.position)
            _G_apply_134, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'character')
            self._trace(" '\\''", (778, 783), self.input.position)
            _G_exactly_135, lastError = self.exactly("'")
            self.considerError(lastError, 'character')
            def _G_or_136():
                self._trace('escapedChar', (785, 796), self.input.position)
                _G_apply_137, lastError = self._apply(self.rule_escapedChar, "escapedChar", [])
                self.considerError(lastError, None)
                return (_G_apply_137, self.currentError)
            def _G_or_138():
                def _G_not_139():
                    def _G_or_140():
                        self._trace("'\\''", (801, 805), self.input.position)
                        _G_exactly_141, lastError = self.exactly("'")
                        self.considerError(lastError, None)
                        return (_G_exactly_141, self.currentError)
                    def _G_or_142():
                        self._trace("'\\n'", (806, 810), self.input.position)
                        _G_exactly_143, lastError = self.exactly('\n')
                        self.considerError(lastError, None)
                        return (_G_exactly_143, self.currentError)
                    def _G_or_144():
                        self._trace("'\\r'", (811, 815), self.input.position)
                        _G_exactly_145, lastError = self.exactly('\r')
                        self.considerError(lastError, None)
                        return (_G_exactly_145, self.currentError)
                    def _G_or_146():
                        self._trace("'\\\\'", (816, 820), self.input.position)
                        _G_exactly_147, lastError = self.exactly('\\')
                        self.considerError(lastError, None)
                        return (_G_exactly_147, self.currentError)
                    _G_or_148, lastError = self._or([_G_or_140, _G_or_142, _G_or_144, _G_or_146])
                    self.considerError(lastError, None)
                    return (_G_or_148, self.currentError)
                _G_not_149, lastError = self._not(_G_not_139)
                self.considerError(lastError, None)
                self._trace(' anything', (821, 830), self.input.position)
                _G_apply_150, lastError = self._apply(self.rule_anything, "anything", [])
                self.considerError(lastError, None)
                return (_G_apply_150, self.currentError)
            _G_or_151, lastError = self._or([_G_or_136, _G_or_138])
            self.considerError(lastError, 'character')
            _locals['c'] = _G_or_151
            self._trace(" '\\''", (833, 838), self.input.position)
            _G_exactly_152, lastError = self.exactly("'")
            self.considerError(lastError, 'character')
            _G_python_153, lastError = eval('Character(c)', self.globals, _locals), None
            self.considerError(lastError, 'character')
            return (_G_python_153, self.currentError)


        def rule_escapedUnicode(self):
            _locals = {'self': self}
            self.locals['escapedUnicode'] = _locals
            def _G_or_154():
                self._trace("'u'", (873, 876), self.input.position)
                _G_exactly_155, lastError = self.exactly('u')
                self.considerError(lastError, None)
                def _G_consumedby_156():
                    self._trace('hexdigit', (878, 886), self.input.position)
                    _G_apply_157, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    self._trace(' hexdigit', (886, 895), self.input.position)
                    _G_apply_158, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    self._trace(' hexdigit', (895, 904), self.input.position)
                    _G_apply_159, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    self._trace(' hexdigit', (904, 913), self.input.position)
                    _G_apply_160, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    return (_G_apply_160, self.currentError)
                _G_consumedby_161, lastError = self.consumedby(_G_consumedby_156)
                self.considerError(lastError, None)
                _locals['hs'] = _G_consumedby_161
                _G_python_162, lastError = eval('unichr(int(hs, 16))', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_162, self.currentError)
            def _G_or_163():
                self._trace("'U'", (961, 964), self.input.position)
                _G_exactly_164, lastError = self.exactly('U')
                self.considerError(lastError, None)
                def _G_consumedby_165():
                    self._trace('hexdigit', (966, 974), self.input.position)
                    _G_apply_166, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    self._trace(' hexdigit', (974, 983), self.input.position)
                    _G_apply_167, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    self._trace(' hexdigit', (983, 992), self.input.position)
                    _G_apply_168, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    self._trace(' hexdigit', (992, 1001), self.input.position)
                    _G_apply_169, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    self._trace('\n                         hexdigit', (1001, 1035), self.input.position)
                    _G_apply_170, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    self._trace(' hexdigit', (1035, 1044), self.input.position)
                    _G_apply_171, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    self._trace(' hexdigit', (1044, 1053), self.input.position)
                    _G_apply_172, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    self._trace(' hexdigit', (1053, 1062), self.input.position)
                    _G_apply_173, lastError = self._apply(self.rule_hexdigit, "hexdigit", [])
                    self.considerError(lastError, None)
                    return (_G_apply_173, self.currentError)
                _G_consumedby_174, lastError = self.consumedby(_G_consumedby_165)
                self.considerError(lastError, None)
                _locals['hs'] = _G_consumedby_174
                _G_python_175, lastError = eval('unichr(int(hs, 16))', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_175, self.currentError)
            _G_or_176, lastError = self._or([_G_or_154, _G_or_163])
            self.considerError(lastError, 'escapedUnicode')
            return (_G_or_176, self.currentError)


        def rule_escapedOctal(self):
            _locals = {'self': self}
            self.locals['escapedOctal'] = _locals
            def _G_or_177():
                def _G_consumedby_178():
                    _G_apply_179, lastError = self._apply(self.rule_anything, "anything", [])
                    self.considerError(lastError, None)
                    _locals['a'] = _G_apply_179
                    def _G_pred_180():
                        _G_python_181, lastError = eval('contains("0123", a)', self.globals, _locals), None
                        self.considerError(lastError, None)
                        return (_G_python_181, self.currentError)
                    _G_pred_182, lastError = self.pred(_G_pred_180)
                    self.considerError(lastError, None)
                    def _G_optional_183():
                        self._trace(' octdigit', (1135, 1144), self.input.position)
                        _G_apply_184, lastError = self._apply(self.rule_octdigit, "octdigit", [])
                        self.considerError(lastError, None)
                        return (_G_apply_184, self.currentError)
                    def _G_optional_185():
                        return (None, self.input.nullError())
                    _G_or_186, lastError = self._or([_G_optional_183, _G_optional_185])
                    self.considerError(lastError, None)
                    def _G_optional_187():
                        self._trace(' octdigit', (1145, 1154), self.input.position)
                        _G_apply_188, lastError = self._apply(self.rule_octdigit, "octdigit", [])
                        self.considerError(lastError, None)
                        return (_G_apply_188, self.currentError)
                    def _G_optional_189():
                        return (None, self.input.nullError())
                    _G_or_190, lastError = self._or([_G_optional_187, _G_optional_189])
                    self.considerError(lastError, None)
                    return (_G_or_190, self.currentError)
                _G_consumedby_191, lastError = self.consumedby(_G_consumedby_178)
                self.considerError(lastError, None)
                return (_G_consumedby_191, self.currentError)
            def _G_or_192():
                def _G_consumedby_193():
                    _G_apply_194, lastError = self._apply(self.rule_anything, "anything", [])
                    self.considerError(lastError, None)
                    _locals['a'] = _G_apply_194
                    def _G_pred_195():
                        _G_python_196, lastError = eval('contains("4567", a)', self.globals, _locals), None
                        self.considerError(lastError, None)
                        return (_G_python_196, self.currentError)
                    _G_pred_197, lastError = self.pred(_G_pred_195)
                    self.considerError(lastError, None)
                    def _G_optional_198():
                        self._trace(' octdigit', (1202, 1211), self.input.position)
                        _G_apply_199, lastError = self._apply(self.rule_octdigit, "octdigit", [])
                        self.considerError(lastError, None)
                        return (_G_apply_199, self.currentError)
                    def _G_optional_200():
                        return (None, self.input.nullError())
                    _G_or_201, lastError = self._or([_G_optional_198, _G_optional_200])
                    self.considerError(lastError, None)
                    return (_G_or_201, self.currentError)
                _G_consumedby_202, lastError = self.consumedby(_G_consumedby_193)
                self.considerError(lastError, None)
                return (_G_consumedby_202, self.currentError)
            _G_or_203, lastError = self._or([_G_or_177, _G_or_192])
            self.considerError(lastError, 'escapedOctal')
            _locals['os'] = _G_or_203
            _G_python_204, lastError = eval('int(os, 8)', self.globals, _locals), None
            self.considerError(lastError, 'escapedOctal')
            return (_G_python_204, self.currentError)


        def rule_escapedChar(self):
            _locals = {'self': self}
            self.locals['escapedChar'] = _locals
            self._trace(" '\\\\'", (1246, 1251), self.input.position)
            _G_exactly_205, lastError = self.exactly('\\')
            self.considerError(lastError, 'escapedChar')
            def _G_or_206():
                self._trace("'n'", (1253, 1256), self.input.position)
                _G_exactly_207, lastError = self.exactly('n')
                self.considerError(lastError, None)
                _G_python_208, lastError = ('\n'), None
                self.considerError(lastError, None)
                return (_G_python_208, self.currentError)
            def _G_or_209():
                self._trace("'r'", (1287, 1290), self.input.position)
                _G_exactly_210, lastError = self.exactly('r')
                self.considerError(lastError, None)
                _G_python_211, lastError = ('\r'), None
                self.considerError(lastError, None)
                return (_G_python_211, self.currentError)
            def _G_or_212():
                self._trace("'t'", (1321, 1324), self.input.position)
                _G_exactly_213, lastError = self.exactly('t')
                self.considerError(lastError, None)
                _G_python_214, lastError = ('\t'), None
                self.considerError(lastError, None)
                return (_G_python_214, self.currentError)
            def _G_or_215():
                self._trace("'b'", (1355, 1358), self.input.position)
                _G_exactly_216, lastError = self.exactly('b')
                self.considerError(lastError, None)
                _G_python_217, lastError = ('\b'), None
                self.considerError(lastError, None)
                return (_G_python_217, self.currentError)
            def _G_or_218():
                self._trace("'f'", (1389, 1392), self.input.position)
                _G_exactly_219, lastError = self.exactly('f')
                self.considerError(lastError, None)
                _G_python_220, lastError = ('\f'), None
                self.considerError(lastError, None)
                return (_G_python_220, self.currentError)
            def _G_or_221():
                self._trace('\'"\'', (1423, 1426), self.input.position)
                _G_exactly_222, lastError = self.exactly('"')
                self.considerError(lastError, None)
                _G_python_223, lastError = ('"'), None
                self.considerError(lastError, None)
                return (_G_python_223, self.currentError)
            def _G_or_224():
                self._trace("'\\''", (1456, 1460), self.input.position)
                _G_exactly_225, lastError = self.exactly("'")
                self.considerError(lastError, None)
                _G_python_226, lastError = ('\''), None
                self.considerError(lastError, None)
                return (_G_python_226, self.currentError)
            def _G_or_227():
                self._trace("'?'", (1491, 1494), self.input.position)
                _G_exactly_228, lastError = self.exactly('?')
                self.considerError(lastError, None)
                _G_python_229, lastError = ('?'), None
                self.considerError(lastError, None)
                return (_G_python_229, self.currentError)
            def _G_or_230():
                self._trace("'\\\\'", (1524, 1528), self.input.position)
                _G_exactly_231, lastError = self.exactly('\\')
                self.considerError(lastError, None)
                _G_python_232, lastError = ('\\'), None
                self.considerError(lastError, None)
                return (_G_python_232, self.currentError)
            def _G_or_233():
                self._trace(' escapedUnicode', (1559, 1574), self.input.position)
                _G_apply_234, lastError = self._apply(self.rule_escapedUnicode, "escapedUnicode", [])
                self.considerError(lastError, None)
                return (_G_apply_234, self.currentError)
            def _G_or_235():
                self._trace(' escapedOctal', (1597, 1610), self.input.position)
                _G_apply_236, lastError = self._apply(self.rule_escapedOctal, "escapedOctal", [])
                self.considerError(lastError, None)
                return (_G_apply_236, self.currentError)
            def _G_or_237():
                self._trace(' eol', (1633, 1637), self.input.position)
                _G_apply_238, lastError = self._apply(self.rule_eol, "eol", [])
                self.considerError(lastError, None)
                _G_python_239, lastError = (""), None
                self.considerError(lastError, None)
                return (_G_python_239, self.currentError)
            _G_or_240, lastError = self._or([_G_or_206, _G_or_209, _G_or_212, _G_or_215, _G_or_218, _G_or_221, _G_or_224, _G_or_227, _G_or_230, _G_or_233, _G_or_235, _G_or_237])
            self.considerError(lastError, 'escapedChar')
            return (_G_or_240, self.currentError)


        def rule_eol(self):
            _locals = {'self': self}
            self.locals['eol'] = _locals
            def _G_many_241():
                self._trace(' hspace', (1651, 1658), self.input.position)
                _G_apply_242, lastError = self._apply(self.rule_hspace, "hspace", [])
                self.considerError(lastError, None)
                return (_G_apply_242, self.currentError)
            _G_many_243, lastError = self.many(_G_many_241)
            self.considerError(lastError, 'eol')
            def _G_or_244():
                self._trace("'\\r'", (1661, 1665), self.input.position)
                _G_exactly_245, lastError = self.exactly('\r')
                self.considerError(lastError, None)
                self._trace(" '\\n'", (1665, 1670), self.input.position)
                _G_exactly_246, lastError = self.exactly('\n')
                self.considerError(lastError, None)
                return (_G_exactly_246, self.currentError)
            def _G_or_247():
                self._trace("'\\r'", (1671, 1675), self.input.position)
                _G_exactly_248, lastError = self.exactly('\r')
                self.considerError(lastError, None)
                return (_G_exactly_248, self.currentError)
            def _G_or_249():
                self._trace(" '\\n'", (1677, 1682), self.input.position)
                _G_exactly_250, lastError = self.exactly('\n')
                self.considerError(lastError, None)
                return (_G_exactly_250, self.currentError)
            _G_or_251, lastError = self._or([_G_or_244, _G_or_247, _G_or_249])
            self.considerError(lastError, 'eol')
            return (_G_or_251, self.currentError)


        def rule_uriBody(self):
            _locals = {'self': self}
            self.locals['uriBody'] = _locals
            def _G_consumedby_252():
                def _G_many1_253():
                    def _G_or_254():
                        self._trace('letterOrDigit', (1697, 1710), self.input.position)
                        _G_apply_255, lastError = self._apply(self.rule_letterOrDigit, "letterOrDigit", [])
                        self.considerError(lastError, None)
                        return (_G_apply_255, self.currentError)
                    def _G_or_256():
                        self._trace("'_'", (1711, 1714), self.input.position)
                        _G_exactly_257, lastError = self.exactly('_')
                        self.considerError(lastError, None)
                        return (_G_exactly_257, self.currentError)
                    def _G_or_258():
                        self._trace("';'", (1715, 1718), self.input.position)
                        _G_exactly_259, lastError = self.exactly(';')
                        self.considerError(lastError, None)
                        return (_G_exactly_259, self.currentError)
                    def _G_or_260():
                        self._trace("'/'", (1719, 1722), self.input.position)
                        _G_exactly_261, lastError = self.exactly('/')
                        self.considerError(lastError, None)
                        return (_G_exactly_261, self.currentError)
                    def _G_or_262():
                        self._trace("'?'", (1723, 1726), self.input.position)
                        _G_exactly_263, lastError = self.exactly('?')
                        self.considerError(lastError, None)
                        return (_G_exactly_263, self.currentError)
                    def _G_or_264():
                        self._trace("':'", (1727, 1730), self.input.position)
                        _G_exactly_265, lastError = self.exactly(':')
                        self.considerError(lastError, None)
                        return (_G_exactly_265, self.currentError)
                    def _G_or_266():
                        self._trace("'@'", (1731, 1734), self.input.position)
                        _G_exactly_267, lastError = self.exactly('@')
                        self.considerError(lastError, None)
                        return (_G_exactly_267, self.currentError)
                    def _G_or_268():
                        self._trace("'&'", (1735, 1738), self.input.position)
                        _G_exactly_269, lastError = self.exactly('&')
                        self.considerError(lastError, None)
                        return (_G_exactly_269, self.currentError)
                    def _G_or_270():
                        self._trace("'='", (1739, 1742), self.input.position)
                        _G_exactly_271, lastError = self.exactly('=')
                        self.considerError(lastError, None)
                        return (_G_exactly_271, self.currentError)
                    def _G_or_272():
                        self._trace("'+'", (1743, 1746), self.input.position)
                        _G_exactly_273, lastError = self.exactly('+')
                        self.considerError(lastError, None)
                        return (_G_exactly_273, self.currentError)
                    def _G_or_274():
                        self._trace("'$'", (1747, 1750), self.input.position)
                        _G_exactly_275, lastError = self.exactly('$')
                        self.considerError(lastError, None)
                        return (_G_exactly_275, self.currentError)
                    def _G_or_276():
                        self._trace("','", (1751, 1754), self.input.position)
                        _G_exactly_277, lastError = self.exactly(',')
                        self.considerError(lastError, None)
                        return (_G_exactly_277, self.currentError)
                    def _G_or_278():
                        self._trace("'-'", (1755, 1758), self.input.position)
                        _G_exactly_279, lastError = self.exactly('-')
                        self.considerError(lastError, None)
                        return (_G_exactly_279, self.currentError)
                    def _G_or_280():
                        self._trace("'.'", (1759, 1762), self.input.position)
                        _G_exactly_281, lastError = self.exactly('.')
                        self.considerError(lastError, None)
                        return (_G_exactly_281, self.currentError)
                    def _G_or_282():
                        self._trace("'!'", (1763, 1766), self.input.position)
                        _G_exactly_283, lastError = self.exactly('!')
                        self.considerError(lastError, None)
                        return (_G_exactly_283, self.currentError)
                    def _G_or_284():
                        self._trace("'~'", (1767, 1770), self.input.position)
                        _G_exactly_285, lastError = self.exactly('~')
                        self.considerError(lastError, None)
                        return (_G_exactly_285, self.currentError)
                    def _G_or_286():
                        self._trace("'*'", (1771, 1774), self.input.position)
                        _G_exactly_287, lastError = self.exactly('*')
                        self.considerError(lastError, None)
                        return (_G_exactly_287, self.currentError)
                    def _G_or_288():
                        self._trace("'\\''", (1775, 1779), self.input.position)
                        _G_exactly_289, lastError = self.exactly("'")
                        self.considerError(lastError, None)
                        return (_G_exactly_289, self.currentError)
                    def _G_or_290():
                        self._trace("'('", (1780, 1783), self.input.position)
                        _G_exactly_291, lastError = self.exactly('(')
                        self.considerError(lastError, None)
                        return (_G_exactly_291, self.currentError)
                    def _G_or_292():
                        self._trace("')'", (1784, 1787), self.input.position)
                        _G_exactly_293, lastError = self.exactly(')')
                        self.considerError(lastError, None)
                        return (_G_exactly_293, self.currentError)
                    def _G_or_294():
                        self._trace("'%'", (1788, 1791), self.input.position)
                        _G_exactly_295, lastError = self.exactly('%')
                        self.considerError(lastError, None)
                        return (_G_exactly_295, self.currentError)
                    def _G_or_296():
                        self._trace("'\\\\'", (1792, 1796), self.input.position)
                        _G_exactly_297, lastError = self.exactly('\\')
                        self.considerError(lastError, None)
                        return (_G_exactly_297, self.currentError)
                    def _G_or_298():
                        self._trace("'|'", (1797, 1800), self.input.position)
                        _G_exactly_299, lastError = self.exactly('|')
                        self.considerError(lastError, None)
                        return (_G_exactly_299, self.currentError)
                    def _G_or_300():
                        self._trace("'#'", (1801, 1804), self.input.position)
                        _G_exactly_301, lastError = self.exactly('#')
                        self.considerError(lastError, None)
                        return (_G_exactly_301, self.currentError)
                    _G_or_302, lastError = self._or([_G_or_254, _G_or_256, _G_or_258, _G_or_260, _G_or_262, _G_or_264, _G_or_266, _G_or_268, _G_or_270, _G_or_272, _G_or_274, _G_or_276, _G_or_278, _G_or_280, _G_or_282, _G_or_284, _G_or_286, _G_or_288, _G_or_290, _G_or_292, _G_or_294, _G_or_296, _G_or_298, _G_or_300])
                    self.considerError(lastError, None)
                    return (_G_or_302, self.currentError)
                _G_many1_303, lastError = self.many(_G_many1_253, _G_many1_253())
                self.considerError(lastError, None)
                return (_G_many1_303, self.currentError)
            _G_consumedby_304, lastError = self.consumedby(_G_consumedby_252)
            self.considerError(lastError, 'uriBody')
            return (_G_consumedby_304, self.currentError)


        def rule_literal(self):
            _locals = {'self': self}
            self.locals['literal'] = _locals
            def _G_or_305():
                self._trace(' string', (1819, 1826), self.input.position)
                _G_apply_306, lastError = self._apply(self.rule_string, "string", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_306
                _G_python_307, lastError = eval('leafInternal(Tag(".String."), x)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_307, self.currentError)
            def _G_or_308():
                self._trace(' character', (1874, 1884), self.input.position)
                _G_apply_309, lastError = self._apply(self.rule_character, "character", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_309
                _G_python_310, lastError = eval('leafInternal(Tag(".char."), x)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_310, self.currentError)
            def _G_or_311():
                self._trace(' number', (1930, 1937), self.input.position)
                _G_apply_312, lastError = self._apply(self.rule_number, "number", [])
                self.considerError(lastError, None)
                _locals['x'] = _G_apply_312
                _G_python_313, lastError = eval('leafInternal(Tag(numberType(x)), x)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_313, self.currentError)
            _G_or_314, lastError = self._or([_G_or_305, _G_or_308, _G_or_311])
            self.considerError(lastError, 'literal')
            return (_G_or_314, self.currentError)


        def rule_tag(self):
            _locals = {'self': self}
            self.locals['tag'] = _locals
            def _G_or_315():
                self._trace('\n          segment', (1988, 2006), self.input.position)
                _G_apply_316, lastError = self._apply(self.rule_segment, "segment", [])
                self.considerError(lastError, None)
                _locals['seg1'] = _G_apply_316
                def _G_many_317():
                    self._trace("':'", (2013, 2016), self.input.position)
                    _G_exactly_318, lastError = self.exactly(':')
                    self.considerError(lastError, None)
                    self._trace(" ':'", (2016, 2020), self.input.position)
                    _G_exactly_319, lastError = self.exactly(':')
                    self.considerError(lastError, None)
                    self._trace(' sos', (2020, 2024), self.input.position)
                    _G_apply_320, lastError = self._apply(self.rule_sos, "sos", [])
                    self.considerError(lastError, None)
                    return (_G_apply_320, self.currentError)
                _G_many_321, lastError = self.many(_G_many_317)
                self.considerError(lastError, None)
                _locals['segs'] = _G_many_321
                _G_python_322, lastError = eval('makeTag(cons(seg1, segs))', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_322, self.currentError)
            def _G_or_323():
                def _G_many1_324():
                    self._trace("':'", (2072, 2075), self.input.position)
                    _G_exactly_325, lastError = self.exactly(':')
                    self.considerError(lastError, None)
                    self._trace(" ':'", (2075, 2079), self.input.position)
                    _G_exactly_326, lastError = self.exactly(':')
                    self.considerError(lastError, None)
                    self._trace(' sos', (2079, 2083), self.input.position)
                    _G_apply_327, lastError = self._apply(self.rule_sos, "sos", [])
                    self.considerError(lastError, None)
                    return (_G_apply_327, self.currentError)
                _G_many1_328, lastError = self.many(_G_many1_324, _G_many1_324())
                self.considerError(lastError, None)
                _locals['segs'] = _G_many1_328
                _G_python_329, lastError = eval('prefixedTag(segs)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_329, self.currentError)
            _G_or_330, lastError = self._or([_G_or_315, _G_or_323])
            self.considerError(lastError, 'tag')
            return (_G_or_330, self.currentError)


        def rule_sos(self):
            _locals = {'self': self}
            self.locals['sos'] = _locals
            def _G_or_331():
                self._trace(' segment', (2119, 2127), self.input.position)
                _G_apply_332, lastError = self._apply(self.rule_segment, "segment", [])
                self.considerError(lastError, None)
                return (_G_apply_332, self.currentError)
            def _G_or_333():
                self._trace('string', (2131, 2137), self.input.position)
                _G_apply_334, lastError = self._apply(self.rule_string, "string", [])
                self.considerError(lastError, None)
                _locals['s'] = _G_apply_334
                _G_python_335, lastError = eval('tagString(s)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_335, self.currentError)
            _G_or_336, lastError = self._or([_G_or_331, _G_or_333])
            self.considerError(lastError, 'sos')
            return (_G_or_336, self.currentError)


        def rule_segment(self):
            _locals = {'self': self}
            self.locals['segment'] = _locals
            def _G_or_337():
                self._trace(' ident', (2167, 2173), self.input.position)
                _G_apply_338, lastError = self._apply(self.rule_ident, "ident", [])
                self.considerError(lastError, None)
                return (_G_apply_338, self.currentError)
            def _G_or_339():
                self._trace(' special', (2175, 2183), self.input.position)
                _G_apply_340, lastError = self._apply(self.rule_special, "special", [])
                self.considerError(lastError, None)
                return (_G_apply_340, self.currentError)
            def _G_or_341():
                self._trace(' uri', (2185, 2189), self.input.position)
                _G_apply_342, lastError = self._apply(self.rule_uri, "uri", [])
                self.considerError(lastError, None)
                return (_G_apply_342, self.currentError)
            _G_or_343, lastError = self._or([_G_or_337, _G_or_339, _G_or_341])
            self.considerError(lastError, 'segment')
            return (_G_or_343, self.currentError)


        def rule_ident(self):
            _locals = {'self': self}
            self.locals['ident'] = _locals
            self._trace(' segStart', (2198, 2207), self.input.position)
            _G_apply_344, lastError = self._apply(self.rule_segStart, "segStart", [])
            self.considerError(lastError, 'ident')
            _locals['i1'] = _G_apply_344
            def _G_many_345():
                self._trace(' segPart', (2210, 2218), self.input.position)
                _G_apply_346, lastError = self._apply(self.rule_segPart, "segPart", [])
                self.considerError(lastError, None)
                return (_G_apply_346, self.currentError)
            _G_many_347, lastError = self.many(_G_many_345)
            self.considerError(lastError, 'ident')
            _locals['ibits'] = _G_many_347
            _G_python_348, lastError = eval('join(cons(i1, ibits))', self.globals, _locals), None
            self.considerError(lastError, 'ident')
            return (_G_python_348, self.currentError)


        def rule_segStart(self):
            _locals = {'self': self}
            self.locals['segStart'] = _locals
            def _G_or_349():
                self._trace(' letter', (2262, 2269), self.input.position)
                _G_apply_350, lastError = self._apply(self.rule_letter, "letter", [])
                self.considerError(lastError, None)
                return (_G_apply_350, self.currentError)
            def _G_or_351():
                self._trace(" '_'", (2271, 2275), self.input.position)
                _G_exactly_352, lastError = self.exactly('_')
                self.considerError(lastError, None)
                return (_G_exactly_352, self.currentError)
            def _G_or_353():
                self._trace(" '$'", (2277, 2281), self.input.position)
                _G_exactly_354, lastError = self.exactly('$')
                self.considerError(lastError, None)
                return (_G_exactly_354, self.currentError)
            _G_or_355, lastError = self._or([_G_or_349, _G_or_351, _G_or_353])
            self.considerError(lastError, 'segStart')
            return (_G_or_355, self.currentError)


        def rule_segPart(self):
            _locals = {'self': self}
            self.locals['segPart'] = _locals
            def _G_or_356():
                self._trace(' letterOrDigit', (2292, 2306), self.input.position)
                _G_apply_357, lastError = self._apply(self.rule_letterOrDigit, "letterOrDigit", [])
                self.considerError(lastError, None)
                return (_G_apply_357, self.currentError)
            def _G_or_358():
                self._trace(" '_'", (2308, 2312), self.input.position)
                _G_exactly_359, lastError = self.exactly('_')
                self.considerError(lastError, None)
                return (_G_exactly_359, self.currentError)
            def _G_or_360():
                self._trace(" '.'", (2314, 2318), self.input.position)
                _G_exactly_361, lastError = self.exactly('.')
                self.considerError(lastError, None)
                return (_G_exactly_361, self.currentError)
            def _G_or_362():
                self._trace(" '-'", (2320, 2324), self.input.position)
                _G_exactly_363, lastError = self.exactly('-')
                self.considerError(lastError, None)
                return (_G_exactly_363, self.currentError)
            def _G_or_364():
                self._trace(" '$'", (2326, 2330), self.input.position)
                _G_exactly_365, lastError = self.exactly('$')
                self.considerError(lastError, None)
                return (_G_exactly_365, self.currentError)
            _G_or_366, lastError = self._or([_G_or_356, _G_or_358, _G_or_360, _G_or_362, _G_or_364])
            self.considerError(lastError, 'segPart')
            return (_G_or_366, self.currentError)


        def rule_special(self):
            _locals = {'self': self}
            self.locals['special'] = _locals
            self._trace(" '.'", (2341, 2345), self.input.position)
            _G_exactly_367, lastError = self.exactly('.')
            self.considerError(lastError, 'special')
            _locals['a'] = _G_exactly_367
            self._trace(' ident', (2347, 2353), self.input.position)
            _G_apply_368, lastError = self._apply(self.rule_ident, "ident", [])
            self.considerError(lastError, 'special')
            _locals['b'] = _G_apply_368
            _G_python_369, lastError = eval('concat(a, b)', self.globals, _locals), None
            self.considerError(lastError, 'special')
            return (_G_python_369, self.currentError)


        def rule_uri(self):
            _locals = {'self': self}
            self.locals['uri'] = _locals
            self._trace(" '<'", (2378, 2382), self.input.position)
            _G_exactly_370, lastError = self.exactly('<')
            self.considerError(lastError, 'uri')
            def _G_many_371():
                self._trace(' uriBody', (2382, 2390), self.input.position)
                _G_apply_372, lastError = self._apply(self.rule_uriBody, "uriBody", [])
                self.considerError(lastError, None)
                return (_G_apply_372, self.currentError)
            _G_many_373, lastError = self.many(_G_many_371)
            self.considerError(lastError, 'uri')
            _locals['uriChars'] = _G_many_373
            self._trace(" '>'", (2400, 2404), self.input.position)
            _G_exactly_374, lastError = self.exactly('>')
            self.considerError(lastError, 'uri')
            _G_python_375, lastError = eval('concat(b, uriChars, e)', self.globals, _locals), None
            self.considerError(lastError, 'uri')
            return (_G_python_375, self.currentError)


        def rule_functor(self):
            _locals = {'self': self}
            self.locals['functor'] = _locals
            self._trace(' ws', (2441, 2444), self.input.position)
            _G_apply_376, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'functor')
            def _G_or_377():
                self._trace('literal', (2446, 2453), self.input.position)
                _G_apply_378, lastError = self._apply(self.rule_literal, "literal", [])
                self.considerError(lastError, None)
                return (_G_apply_378, self.currentError)
            def _G_or_379():
                self._trace(' tag', (2455, 2459), self.input.position)
                _G_apply_380, lastError = self._apply(self.rule_tag, "tag", [])
                self.considerError(lastError, None)
                _locals['t'] = _G_apply_380
                _G_python_381, lastError = eval('leafInternal(t, None)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_381, self.currentError)
            _G_or_382, lastError = self._or([_G_or_377, _G_or_379])
            self.considerError(lastError, 'functor')
            return (_G_or_382, self.currentError)


        def rule_baseTerm(self):
            _locals = {'self': self}
            self.locals['baseTerm'] = _locals
            self._trace(' functor', (2498, 2506), self.input.position)
            _G_apply_383, lastError = self._apply(self.rule_functor, "functor", [])
            self.considerError(lastError, 'baseTerm')
            _locals['f'] = _G_apply_383
            def _G_or_384():
                self._trace("'('", (2510, 2513), self.input.position)
                _G_exactly_385, lastError = self.exactly('(')
                self.considerError(lastError, None)
                self._trace(' argList', (2513, 2521), self.input.position)
                _G_apply_386, lastError = self._apply(self.rule_argList, "argList", [])
                self.considerError(lastError, None)
                _locals['a'] = _G_apply_386
                self._trace(' ws', (2523, 2526), self.input.position)
                _G_apply_387, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                self._trace(" ')'", (2526, 2530), self.input.position)
                _G_exactly_388, lastError = self.exactly(')')
                self.considerError(lastError, None)
                _G_python_389, lastError = eval('makeTerm(f, a)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_389, self.currentError)
            def _G_or_390():
                _G_python_391, lastError = eval('makeTerm(f, None)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_391, self.currentError)
            _G_or_392, lastError = self._or([_G_or_384, _G_or_390])
            self.considerError(lastError, 'baseTerm')
            return (_G_or_392, self.currentError)


        def rule_arg(self):
            _locals = {'self': self}
            self.locals['arg'] = _locals
            self._trace(' term', (2600, 2605), self.input.position)
            _G_apply_393, lastError = self._apply(self.rule_term, "term", [])
            self.considerError(lastError, 'arg')
            return (_G_apply_393, self.currentError)


        def rule_argList(self):
            _locals = {'self': self}
            self.locals['argList'] = _locals
            def _G_or_394():
                self._trace('arg', (2619, 2622), self.input.position)
                _G_apply_395, lastError = self._apply(self.rule_arg, "arg", [])
                self.considerError(lastError, None)
                _locals['t'] = _G_apply_395
                def _G_many_396():
                    self._trace('ws', (2626, 2628), self.input.position)
                    _G_apply_397, lastError = self._apply(self.rule_ws, "ws", [])
                    self.considerError(lastError, None)
                    self._trace(" ','", (2628, 2632), self.input.position)
                    _G_exactly_398, lastError = self.exactly(',')
                    self.considerError(lastError, None)
                    self._trace(' arg', (2632, 2636), self.input.position)
                    _G_apply_399, lastError = self._apply(self.rule_arg, "arg", [])
                    self.considerError(lastError, None)
                    return (_G_apply_399, self.currentError)
                _G_many_400, lastError = self.many(_G_many_396)
                self.considerError(lastError, None)
                _locals['ts'] = _G_many_400
                self._trace(' ws', (2641, 2644), self.input.position)
                _G_apply_401, lastError = self._apply(self.rule_ws, "ws", [])
                self.considerError(lastError, None)
                def _G_optional_402():
                    self._trace(" ','", (2644, 2648), self.input.position)
                    _G_exactly_403, lastError = self.exactly(',')
                    self.considerError(lastError, None)
                    return (_G_exactly_403, self.currentError)
                def _G_optional_404():
                    return (None, self.input.nullError())
                _G_or_405, lastError = self._or([_G_optional_402, _G_optional_404])
                self.considerError(lastError, None)
                _G_python_406, lastError = eval('cons(t, ts)', self.globals, _locals), None
                self.considerError(lastError, None)
                return (_G_python_406, self.currentError)
            def _G_or_407():
                _G_python_408, lastError = ([]), None
                self.considerError(lastError, None)
                return (_G_python_408, self.currentError)
            _G_or_409, lastError = self._or([_G_or_394, _G_or_407])
            self.considerError(lastError, 'argList')
            return (_G_or_409, self.currentError)


        def rule_tupleTerm(self):
            _locals = {'self': self}
            self.locals['tupleTerm'] = _locals
            self._trace(' ws', (2699, 2702), self.input.position)
            _G_apply_410, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'tupleTerm')
            self._trace(" '['", (2702, 2706), self.input.position)
            _G_exactly_411, lastError = self.exactly('[')
            self.considerError(lastError, 'tupleTerm')
            self._trace(' argList', (2706, 2714), self.input.position)
            _G_apply_412, lastError = self._apply(self.rule_argList, "argList", [])
            self.considerError(lastError, 'tupleTerm')
            _locals['a'] = _G_apply_412
            self._trace(' ws', (2716, 2719), self.input.position)
            _G_apply_413, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'tupleTerm')
            self._trace(" ']'", (2719, 2723), self.input.position)
            _G_exactly_414, lastError = self.exactly(']')
            self.considerError(lastError, 'tupleTerm')
            _G_python_415, lastError = eval('Tuple(a)', self.globals, _locals), None
            self.considerError(lastError, 'tupleTerm')
            return (_G_python_415, self.currentError)


        def rule_bagTerm(self):
            _locals = {'self': self}
            self.locals['bagTerm'] = _locals
            self._trace(' ws', (2746, 2749), self.input.position)
            _G_apply_416, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'bagTerm')
            self._trace(" '{'", (2749, 2753), self.input.position)
            _G_exactly_417, lastError = self.exactly('{')
            self.considerError(lastError, 'bagTerm')
            self._trace(' argList', (2753, 2761), self.input.position)
            _G_apply_418, lastError = self._apply(self.rule_argList, "argList", [])
            self.considerError(lastError, 'bagTerm')
            _locals['a'] = _G_apply_418
            self._trace(' ws', (2763, 2766), self.input.position)
            _G_apply_419, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'bagTerm')
            self._trace(" '}'", (2766, 2770), self.input.position)
            _G_exactly_420, lastError = self.exactly('}')
            self.considerError(lastError, 'bagTerm')
            _G_python_421, lastError = eval('Bag(a)', self.globals, _locals), None
            self.considerError(lastError, 'bagTerm')
            return (_G_python_421, self.currentError)


        def rule_labelledBagTerm(self):
            _locals = {'self': self}
            self.locals['labelledBagTerm'] = _locals
            self._trace(' functor', (2799, 2807), self.input.position)
            _G_apply_422, lastError = self._apply(self.rule_functor, "functor", [])
            self.considerError(lastError, 'labelledBagTerm')
            _locals['f'] = _G_apply_422
            self._trace(' bagTerm', (2809, 2817), self.input.position)
            _G_apply_423, lastError = self._apply(self.rule_bagTerm, "bagTerm", [])
            self.considerError(lastError, 'labelledBagTerm')
            _locals['b'] = _G_apply_423
            _G_python_424, lastError = eval('LabelledBag(f, b)', self.globals, _locals), None
            self.considerError(lastError, 'labelledBagTerm')
            return (_G_python_424, self.currentError)


        def rule_extraTerm(self):
            _locals = {'self': self}
            self.locals['extraTerm'] = _locals
            def _G_or_425():
                self._trace(' tupleTerm', (2853, 2863), self.input.position)
                _G_apply_426, lastError = self._apply(self.rule_tupleTerm, "tupleTerm", [])
                self.considerError(lastError, None)
                return (_G_apply_426, self.currentError)
            def _G_or_427():
                self._trace(' labelledBagTerm', (2865, 2881), self.input.position)
                _G_apply_428, lastError = self._apply(self.rule_labelledBagTerm, "labelledBagTerm", [])
                self.considerError(lastError, None)
                return (_G_apply_428, self.currentError)
            def _G_or_429():
                self._trace(' bagTerm', (2884, 2892), self.input.position)
                _G_apply_430, lastError = self._apply(self.rule_bagTerm, "bagTerm", [])
                self.considerError(lastError, None)
                return (_G_apply_430, self.currentError)
            def _G_or_431():
                self._trace(' baseTerm', (2894, 2903), self.input.position)
                _G_apply_432, lastError = self._apply(self.rule_baseTerm, "baseTerm", [])
                self.considerError(lastError, None)
                return (_G_apply_432, self.currentError)
            _G_or_433, lastError = self._or([_G_or_425, _G_or_427, _G_or_429, _G_or_431])
            self.considerError(lastError, 'extraTerm')
            return (_G_or_433, self.currentError)


        def rule_attrTerm(self):
            _locals = {'self': self}
            self.locals['attrTerm'] = _locals
            self._trace(' extraTerm', (2915, 2925), self.input.position)
            _G_apply_434, lastError = self._apply(self.rule_extraTerm, "extraTerm", [])
            self.considerError(lastError, 'attrTerm')
            _locals['k'] = _G_apply_434
            self._trace(' ws', (2927, 2930), self.input.position)
            _G_apply_435, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'attrTerm')
            self._trace(" ':'", (2930, 2934), self.input.position)
            _G_exactly_436, lastError = self.exactly(':')
            self.considerError(lastError, 'attrTerm')
            self._trace(' extraTerm', (2934, 2944), self.input.position)
            _G_apply_437, lastError = self._apply(self.rule_extraTerm, "extraTerm", [])
            self.considerError(lastError, 'attrTerm')
            _locals['v'] = _G_apply_437
            _G_python_438, lastError = eval('Attr(k, v)', self.globals, _locals), None
            self.considerError(lastError, 'attrTerm')
            return (_G_python_438, self.currentError)


        def rule_term(self):
            _locals = {'self': self}
            self.locals['term'] = _locals
            self._trace(' ws', (2968, 2971), self.input.position)
            _G_apply_439, lastError = self._apply(self.rule_ws, "ws", [])
            self.considerError(lastError, 'term')
            def _G_or_440():
                self._trace('attrTerm', (2973, 2981), self.input.position)
                _G_apply_441, lastError = self._apply(self.rule_attrTerm, "attrTerm", [])
                self.considerError(lastError, None)
                return (_G_apply_441, self.currentError)
            def _G_or_442():
                self._trace(' extraTerm', (2983, 2993), self.input.position)
                _G_apply_443, lastError = self._apply(self.rule_extraTerm, "extraTerm", [])
                self.considerError(lastError, None)
                return (_G_apply_443, self.currentError)
            _G_or_444, lastError = self._or([_G_or_440, _G_or_442])
            self.considerError(lastError, 'term')
            return (_G_or_444, self.currentError)


    if terml.globals is not None:
        terml.globals = terml.globals.copy()
        terml.globals.update(ruleGlobals)
    else:
        terml.globals = ruleGlobals
    return terml

########NEW FILE########
__FILENAME__ = test_parsley
import unittest

import parsley


def wrapperFactory(addition):
    def wrapper(wrapped):
        return addition, wrapped
    return wrapper

def nullFactory(*args):
    return args


class StackTestCase(unittest.TestCase):
    def test_onlyBase(self):
        "stack can be called with no wrappers."
        fac = parsley.stack(nullFactory)
        self.assertEqual(fac('a'), ('a',))

    def test_oneWrapper(self):
        "stack can be called with one wrapper."
        fac = parsley.stack(wrapperFactory(0), nullFactory)
        self.assertEqual(fac('a'), (0, ('a',)))

    def test_tenWrappers(self):
        "stack can be called with ten wrappers."
        args = []
        result = 'a',
        for x in range(10):
            args.append(wrapperFactory(x))
            result = 9 - x, result
        args.append(nullFactory)
        fac = parsley.stack(*args)
        self.assertEqual(fac('a'), result)

    def test_failsWithNoBaseSender(self):
        "stack does require at least the base factory."
        self.assertRaises(TypeError, parsley.stack)

    def test_senderFactoriesTakeOneArgument(self):
        "The callable returned by stack takes exactly one argument."
        fac = parsley.stack(nullFactory)
        self.assertRaises(TypeError, fac)
        self.assertRaises(TypeError, fac, 'a', 'b')

########NEW FILE########
