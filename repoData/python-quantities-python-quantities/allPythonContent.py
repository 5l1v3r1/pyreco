__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# quantities documentation build configuration file, created by
# sphinx-quickstart on Sun Oct 25 09:49:05 2009.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath('./sphinxext'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'sphinx.ext.todo',
    'sphinx.ext.coverage', 'sphinx.ext.pngmath', 'sphinx.ext.ifconfig',
    'sphinx.ext.autosummary', 'ipython_console_highlighting', 'numpydoc.numpydoc'
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'quantities'
copyright = u'2009, Darren Dale'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
with open('../quantities/version.py') as f:
    for line in f:
        if line.startswith('__version__'):
            exec(line)
# The short X.Y version.
version = __version__
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

#autosummary_generate = ['reference/intro.rst']

# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'sphinxdoc'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
html_sidebars = {'index': 'indexsidebar.html'}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'quantitiesdoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'quantities.tex', u'quantities Documentation',
   u'Darren Dale', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = ipython_console_highlighting
"""reST directive for syntax-highlighting ipython interactive sessions.

XXX - See what improvements can be made based on the new (as of Sept 2009)
'pycon' lexer for the python console.  At the very least it will give better
highlighted tracebacks.
"""

#-----------------------------------------------------------------------------
# Needed modules

# Standard library
import re

# Third party
from pygments.lexer import Lexer, do_insertions
from pygments.lexers.agile import (PythonConsoleLexer, PythonLexer, 
                                   PythonTracebackLexer)
from pygments.token import Comment, Generic

from sphinx import highlighting

#-----------------------------------------------------------------------------
# Global constants
line_re = re.compile('.*?\n')

#-----------------------------------------------------------------------------
# Code begins - classes and functions

class IPythonConsoleLexer(Lexer):
    """
    For IPython console output or doctests, such as:

    .. sourcecode:: ipython

      In [1]: a = 'foo'

      In [2]: a
      Out[2]: 'foo'

      In [3]: print a
      foo

      In [4]: 1 / 0

    Notes:

      - Tracebacks are not currently supported.

      - It assumes the default IPython prompts, not customized ones.
    """
    
    name = 'IPython console session'
    aliases = ['ipython']
    mimetypes = ['text/x-ipython-console']
    input_prompt = re.compile("(In \[[0-9]+\]: )|(   \.\.\.+:)")
    output_prompt = re.compile("(Out\[[0-9]+\]: )|(   \.\.\.+:)")
    continue_prompt = re.compile("   \.\.\.+:")
    tb_start = re.compile("\-+")

    def get_tokens_unprocessed(self, text):
        pylexer = PythonLexer(**self.options)
        tblexer = PythonTracebackLexer(**self.options)

        curcode = ''
        insertions = []
        for match in line_re.finditer(text):
            line = match.group()
            input_prompt = self.input_prompt.match(line)
            continue_prompt = self.continue_prompt.match(line.rstrip())
            output_prompt = self.output_prompt.match(line)
            if line.startswith("#"):
                insertions.append((len(curcode),
                                   [(0, Comment, line)]))
            elif input_prompt is not None:
                insertions.append((len(curcode),
                                   [(0, Generic.Prompt, input_prompt.group())]))
                curcode += line[input_prompt.end():]
            elif continue_prompt is not None:
                insertions.append((len(curcode),
                                   [(0, Generic.Prompt, continue_prompt.group())]))
                curcode += line[continue_prompt.end():]
            elif output_prompt is not None:
                # Use the 'error' token for output.  We should probably make
                # our own token, but error is typicaly in a bright color like
                # red, so it works fine for our output prompts.
                insertions.append((len(curcode),
                                   [(0, Generic.Error, output_prompt.group())]))
                curcode += line[output_prompt.end():]
            else:
                if curcode:
                    for item in do_insertions(insertions,
                                              pylexer.get_tokens_unprocessed(curcode)):
                        yield item
                        curcode = ''
                        insertions = []
                yield match.start(), Generic.Output, line
        if curcode:
            for item in do_insertions(insertions,
                                      pylexer.get_tokens_unprocessed(curcode)):
                yield item


def setup(app):
    """Setup as a sphinx extension."""

    # This is only a lexer, so adding it below to pygments appears sufficient.
    # But if somebody knows that the right API usage should be to do that via
    # sphinx, by all means fix it here.  At least having this setup.py
    # suppresses the sphinx warning we'd get without it.
    pass

#-----------------------------------------------------------------------------
# Register the extension as a valid pygments lexer
highlighting.lexers['ipython'] = IPythonConsoleLexer()

########NEW FILE########
__FILENAME__ = alpha
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


m_alpha = alpha_particle_mass = UnitConstant(
    'alpha_particle_mass',
    _cd('alpha particle mass'),
    symbol='m_alpha',
    u_symbol='m_α'
)
alpha_particle_mass_energy_equivalent = UnitConstant(
    'alpha_particle_mass_energy_equivalent',
    _cd('alpha particle mass energy equivalent'),
    symbol='(m_alpha*c**2)',
    u_symbol='(m_α·c²)'
)
alpha_particle_mass_energy_equivalent_in_MeV = UnitConstant(
    'alpha_particle_mass_energy_equivalent_in_MeV',
    _cd('alpha particle mass energy equivalent in MeV'),
)
alpha_particle_mass_in_u = UnitConstant(
    'alpha_particle_mass_in_u',
    _cd('alpha particle mass in u')
)
alpha_particle_molar_mass = UnitConstant(
    'alpha_particle_molar_mass',
    _cd('alpha particle molar mass'),
    symbol='M_alpha',
    u_symbol='M_α'
)
alpha_particle_electron_mass_ratio = UnitConstant(
    'alpha_particle_electron_mass_ratio',
    _cd('alpha particle-electron mass ratio'),
    symbol='(m_alpha/m_e)',
    u_symbol='(m_α/mₑ)'
)
alpha_particle_proton_mass_ratio = UnitConstant(
    'alpha_particle_proton_mass_ratio',
    _cd('alpha particle-proton mass ratio'),
    symbol='(m_alpha/m_p)',
    u_symbol='(m_α/m_p)'
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = astronomy
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..uncertainquantity import UncertainQuantity
from ..unitquantity import UnitConstant


au = astronomical_unit = UnitConstant(
    'astronomical_unit',
    UncertainQuantity(149597870700, 'm', 3),
    symbol='au',
    doc='http://en.wikipedia.org/wiki/Astronomical_unit'
)
G = Newtonian_constant_of_gravitation = UnitConstant(
    'Newtonian_constant_of_gravitation',
    _cd('Newtonian constant of gravitation'),
    symbol='G'
)

del UnitConstant, UncertainQuantity, _cd

########NEW FILE########
__FILENAME__ = atomicunits
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


amu = atomic_mass_constant = UnitConstant(
    'atomic_mass_constant',
    _cd('atomic mass constant'),
    symbol='m_u',
    u_symbol='mᵤ'
)
atomic_unit_of_1st_hyperpolarizability = UnitConstant(
    'atomic_unit_of_1st_hyperpolarizability',
    _cd('atomic unit of 1st hyperpolarizability'),
    symbol='(e**3*a_0**3/E_h**2)',
    u_symbol='(e³·a₀³/E_h²)'
)
atomic_unit_of_2nd_hyperpolarizability = UnitConstant(
    'atomic_unit_of_2nd_hyperpolarizability',
    _cd('atomic unit of 2nd hyperpolarizability'),
    symbol='(e**4*a_0**4/E_h**3)',
    u_symbol='(e⁴·a₀⁴/E_h³)'
)
hbar = atomic_unit_of_action = UnitConstant(
    'atomic_unit_of_action',
    _cd('atomic unit of action'),
    symbol='hbar',
    u_symbol='ħ'
)
atomic_unit_of_charge = UnitConstant(
    'atomic_unit_of_charge',
    _cd('atomic unit of charge'),
    symbol='e'
)
atomic_unit_of_charge_density = UnitConstant(
    'atomic_unit_of_charge_density',
    _cd('atomic unit of charge density'),
    symbol='(e/a_0**3)',
    u_symbol='(e/a₀³)'
)
atomic_unit_of_current = UnitConstant(
    'atomic_unit_of_current',
    _cd('atomic unit of current'),
    symbol='(e*E_h/hbar)',
    u_symbol='(e·E_h/ħ)'
)
atomic_unit_of_electric_dipole_moment = UnitConstant(
    'atomic_unit_of_electric_dipole_moment',
    _cd('atomic unit of electric dipole moment'),
    symbol='(e*a_0)',
    u_symbol='(e·a₀)'
)
atomic_unit_of_electric_field = UnitConstant(
    'atomic_unit_of_electric_field',
    _cd('atomic unit of electric field'),
    symbol='(E_h/(e*a_0))',
    u_symbol='(E_h/(e·a₀))'
)
atomic_unit_of_electric_field_gradient = UnitConstant(
    'atomic_unit_of_electric_field_gradient',
    _cd('atomic unit of electric field gradient'),
    symbol='(E_h/(e*a_0**2))',
    u_symbol='(E_h/(e·a₀²))'
)
atomic_unit_of_electric_polarizability = UnitConstant(
    'atomic_unit_of_electric_polarizability',
    _cd('atomic unit of electric polarizability'),
    symbol='(e**2*a_0**2/E_h)',
    u_symbol='(e²·a₀²/E_h)'
)
atomic_unit_of_electric_potential = UnitConstant(
    'atomic_unit_of_electric_potential',
    _cd('atomic unit of electric potential'),
    symbol='(E_h/e)'
)
atomic_unit_of_electric_quadrupole_moment = UnitConstant(
    'atomic_unit_of_electric_quadrupole_moment',
    _cd('atomic unit of electric quadrupole moment'),
    symbol='(e*a_0**2)',
    u_symbol='(e·a₀²)'
)
atomic_unit_of_energy = UnitConstant(
    'atomic_unit_of_energy',
    _cd('atomic unit of energy'),
)
atomic_unit_of_force = UnitConstant(
    'atomic_unit_of_force',
    _cd('atomic unit of force'),
    symbol='(E_h/a_0)',
    u_symbol='(E_h/a₀)'
)
a_0 = atomic_unit_of_length = UnitConstant(
    'atomic_unit_of_length',
    _cd('atomic unit of length'),
    symbol='a_0',
    u_symbol='a₀'
)
Bohr_radius = UnitConstant(
    'Bohr_radius',
    _cd('Bohr radius'),
    symbol='a_0',
    u_symbol='a₀'
)
atomic_unit_of_magnetic_dipole_moment = UnitConstant(
    'atomic_unit_of_magnetic_dipole_moment',
    _cd('atomic unit of magnetic dipole moment'),
    symbol='(hbar*e/m_e)',
    u_symbol='(ħ·e/mₑ)'
)
atomic_unit_of_magnetic_flux_density = UnitConstant(
    'atomic_unit_of_magnetic_flux_density',
    _cd('atomic unit of magnetic flux density'),
    symbol='(hbar*e/a_0**2)',
    u_symbol='(ħ·e/a₀²)'
)
atomic_unit_of_magnetizability = UnitConstant(
    'atomic_unit_of_magnetizability',
    _cd('atomic unit of magnetizability'),
    symbol='(e**2a_0**2/m_e)',
    u_symbol='(e²·a₀²/mₑ)'
)
m_e = atomic_unit_of_mass = UnitConstant(
    'atomic_unit_of_mass',
    _cd('atomic unit of mass'),
    symbol='m_e',
    u_symbol='mₑ'
)
atomic_unit_of_momentum = UnitConstant(
    'atomic_unit_of_momentum',
    _cd('atomic unit of momentum'),
    symbol='(hbar/a_0)',
    u_symbol='(ħ/a₀)'
)
atomic_unit_of_permittivity = UnitConstant(
    'atomic_unit_of_permittivity',
    _cd('atomic unit of permittivity'),
    symbol='(e**2/(a_0*E_h))',
    u_symbol='(e²/(a₀·E_h))'
)
atomic_unit_of_time = UnitConstant(
    'atomic_unit_of_time',
    _cd('atomic unit of time'),
    symbol='(hbar/E_h)',
    u_symbol='(ħ/E_h)'
)
atomic_unit_of_velocity = UnitConstant(
    'atomic_unit_of_velocity',
    _cd('atomic unit of velocity'),
    symbol='(a_0*E_h/hbar)',
    u_symbol='(a₀·E_h/ħ)'
)
E_h = Hartree_energy = UnitConstant(
    'Hartree_energy',
    _cd('Hartree energy'),
    symbol='E_h'
)
u = unified_atomic_mass_unit = UnitConstant(
    'unified_atomic_mass_unit',
    _cd('unified atomic mass unit'),
    symbol='u'
)
molar_mass_of_carbon_12 = UnitConstant(
    'molar_mass_of_carbon_12',
    _cd('molar mass of carbon-12'),
    symbol='M_C12',
    u_symbol='M_¹²C'
)

atomic_mass_constant_energy_equivalent = UnitConstant(
    'atomic_mass_constant_energy_equivalent',
    _cd('atomic mass constant energy equivalent'),
    symbol='(m_u*c**2)',
    u_symbol='(mᵤ·c²)'
)
atomic_mass_constant_energy_equivalent_in_MeV = UnitConstant(
    'atomic_mass_constant_energy_equivalent_in_MeV',
    _cd('atomic mass constant energy equivalent in MeV')
)
Hartree_energy_in_eV = UnitConstant(
    'Hartree_energy_in_eV',
    _cd('Hartree energy in eV')
)

atomic_mass_unit_electron_volt_relationship = UnitConstant(
    'atomic_mass_unit_electron_volt_relationship',
    _cd('atomic mass unit-electron volt relationship'),
)
atomic_mass_unit_hartree_relationship = UnitConstant(
    'atomic_mass_unit_hartree_relationship',
    _cd('atomic mass unit-hartree relationship')
)
atomic_mass_unit_hertz_relationship = UnitConstant(
    'atomic_mass_unit_hertz_relationship',
    _cd('atomic mass unit-hertz relationship')
)
atomic_mass_unit_inverse_meter_relationship = UnitConstant(
    'atomic_mass_unit_inverse_meter_relationship',
    _cd('atomic mass unit-inverse meter relationship')
)
atomic_mass_unit_joule_relationship = UnitConstant(
    'atomic_mass_unit_joule_relationship',
    _cd('atomic mass unit-joule relationship'),
    symbol='(u*c**2)',
    u_symbol='(u·c²)'
)
atomic_mass_unit_kelvin_relationship = UnitConstant(
    'atomic_mass_unit_kelvin_relationship',
    _cd('atomic mass unit-kelvin relationship')
)
atomic_mass_unit_kilogram_relationship = UnitConstant(
    'atomic_mass_unit_kilogram_relationship',
    _cd('atomic mass unit-kilogram relationship')
)

hartree_atomic_mass_unit_relationship = UnitConstant(
    'hartree_atomic_mass_unit_relationship',
    _cd('hartree-atomic mass unit relationship')
)
hartree_electron_volt_relationship = UnitConstant(
    'hartree_electron_volt_relationship',
    _cd('hartree-electron volt relationship')
)
hartree_hertz_relationship = UnitConstant(
    'hartree_hertz_relationship',
    _cd('hartree-hertz relationship')
)
hartree_inverse_meter_relationship = UnitConstant(
    'hartree_inverse_meter_relationship',
    _cd('hartree-inverse meter relationship')
)
hartree_joule_relationship = UnitConstant(
    'hartree_joule_relationship',
    _cd('hartree-joule relationship')
)
hartree_kelvin_relationship = UnitConstant(
    'hartree_kelvin_relationship',
    _cd('hartree-kelvin relationship')
)
hartree_kilogram_relationship = UnitConstant(
    'hartree_kilogram_relationship',
    _cd('hartree-kilogram relationship')
)
hertz_atomic_mass_unit_relationship = UnitConstant(
    'hertz_atomic_mass_unit_relationship',
    _cd('hertz-atomic mass unit relationship')
)
hertz_hartree_relationship = UnitConstant(
    'hertz_hartree_relationship',
    _cd('hertz-hartree relationship')
)
inverse_meter_atomic_mass_unit_relationship = UnitConstant(
    'inverse_meter_atomic_mass_unit_relationship',
    _cd('inverse meter-atomic mass unit relationship')
)
inverse_meter_hartree_relationship = UnitConstant(
    'inverse_meter_hartree_relationship',
    _cd('inverse meter-hartree relationship')
)
joule_atomic_mass_unit_relationship = UnitConstant(
    'joule_atomic_mass_unit_relationship',
    _cd('joule-atomic mass unit relationship')
)
joule_hartree_relationship = UnitConstant(
    'joule_hartree_relationship',
    _cd('joule-hartree relationship')
)
kelvin_atomic_mass_unit_relationship = UnitConstant(
    'kelvin_atomic_mass_unit_relationship',
    _cd('kelvin-atomic mass unit relationship')
)
kelvin_hartree_relationship = UnitConstant(
    'kelvin_hartree_relationship',
    _cd('kelvin-hartree relationship')
)
kilogram_atomic_mass_unit_relationship = UnitConstant(
    'kilogram_atomic_mass_unit_relationship',
    _cd('kilogram-atomic mass unit relationship')
)
kilogram_hartree_relationship = UnitConstant(
    'kilogram_hartree_relationship',
    _cd('kilogram-hartree relationship')
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = deuteron
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


R_d = deuteron_rms_charge_radius = UnitConstant(
    'deuteron_rms_charge_radius',
    _cd('deuteron rms charge radius'),
    symbol='R_d'
)
m_d = deuteron_mass = UnitConstant(
    'deuteron_mass',
    _cd('deuteron mass'),
    symbol='m_d'
)
g_d = deuteron_g_factor = UnitConstant(
    'deuteron_g_factor',
    _cd('deuteron g factor'),
    symbol='g_d'
)
mu_d = deuteron_magnetic_moment = UnitConstant(
    'deuteron_magnetic_moment',
    _cd('deuteron magnetic moment'),
    symbol='mu_d',
    u_symbol='μ_d'
)
deuteron_mass_energy_equivalent = UnitConstant(
    'deuteron_mass_energy_equivalent',
    _cd('deuteron mass energy equivalent'),
    symbol='(m_d*c**2)',
    u_symbol='(m_d·c²)'
)
deuteron_mass_energy_equivalent_in_MeV = UnitConstant(
    'deuteron_mass_energy_equivalent_in_MeV',
    _cd('deuteron mass energy equivalent in MeV')
)
deuteron_mass_in_u = UnitConstant(
    'deuteron_mass_in_u',
    _cd('deuteron mass in u')
)
deuteron_molar_mass = UnitConstant(
    'deuteron_molar_mass',
    _cd('deuteron molar mass'),
    symbol='M_d'
)
deuteron_electron_mass_ratio = UnitConstant(
    'deuteron_electron_mass_ratio',
    _cd('deuteron-electron mass ratio'),
    symbol='(m_d/m_e)',
    u_symbol='(m_d/mₑ)'
)
deuteron_proton_mass_ratio = UnitConstant(
    'deuteron_proton_mass_ratio',
    _cd('deuteron-proton mass ratio'),
    symbol='(m_d/m_n)'
)
deuteron_electron_magnetic_moment_ratio = UnitConstant(
    'deuteron_electron_magnetic_moment_ratio',
    _cd('deuteron-electron magnetic moment ratio'),
    symbol='(mu_d/mu_e)',
    u_symbol='(μ_d/μₑ)'
)
deuteron_magnetic_moment_to_Bohr_magneton_ratio = UnitConstant(
    'deuteron_magnetic_moment_to_Bohr_magneton_ratio',
    _cd('deuteron magnetic moment to Bohr magneton ratio'),
    symbol='(mu_d/mu_B)',
    u_symbol='(μ_d/μ_B)'
)
deuteron_magnetic_moment_to_nuclear_magneton_ratio = UnitConstant(
    'deuteron_magnetic_moment_to_nuclear_magneton_ratio',
    _cd('deuteron magnetic moment to nuclear magneton ratio'),
    symbol='(mu_d/mu_N)',
    u_symbol='(μ_d/μ_N)'
)
deuteron_neutron_magnetic_moment_ratio = UnitConstant(
    'deuteron_neutron_magnetic_moment_ratio',
    _cd('deuteron-neutron magnetic moment ratio'),
    symbol='(mu_d/mu_n)',
    u_symbol='(μ_d/μ_n)'
)
deuteron_proton_magnetic_moment_ratio = UnitConstant(
    'deuteron_proton_magnetic_moment_ratio',
    _cd('deuteron-proton magnetic moment ratio'),
    symbol='(mu_d/mu_p)',
    u_symbol='(μ_d/μ_p)'
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = electromagnetism
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


Z_0 = impedence_of_free_space = characteristic_impedance_of_vacuum = UnitConstant(
    'characteristic_impedance_of_vacuum',
    _cd('characteristic impedance of vacuum'),
    symbol='Z_0',
    u_symbol='Z₀'
)
vacuum_permittivity = epsilon_0 = electric_constant = UnitConstant(
    'electric_constant',
    _cd('electric constant'),
    symbol='epsilon_0',
    u_symbol='ε₀'
)
mu_0 = magnetic_constant = UnitConstant(
    'magnetic_constant',
    _cd('magnetic constant'),
    symbol='mu_0',
    u_symbol='μ₀'
)


del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = electron
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


e = elementary_charge = UnitConstant(
    'elementary_charge',
    _cd('elementary charge'),
    symbol='e'
)
elementary_charge_over_h = UnitConstant(
    'elementary_charge_over_h',
    _cd('elementary charge over h'),
    symbol='e/h'
)
Faraday_constant = UnitConstant(
    'Faraday_constant',
    _cd('Faraday constant'),
    symbol='F'
)
#F_star = Faraday_constant_for_conventional_electric_current = UnitConstant(
#    _cd('Faraday constant for conventional electric current') what is a unit of C_90?
r_e = classical_electron_radius = UnitConstant(
    'classical_electron_radius',
    _cd('classical electron radius'),
    symbol='r_e',
    u_symbol='rₑ'
)
m_e = electron_mass = UnitConstant(
    'electron_mass',
    _cd('electron mass'),
    symbol='m_e',
    u_symbol='mₑ'
)
lambda_C = Compton_wavelength = UnitConstant(
    'Compton_wavelength',
    _cd('Compton wavelength'),
    symbol='lambda_C',
    u_symbol='λ_C'
)
Compton_wavelength_over_2_pi = UnitConstant(
    'Compton_wavelength_over_2_pi',
    _cd('Compton wavelength over 2 pi'),
    symbol='lambdabar_C',
    u_symbol='ƛ_C'
)
electron_charge_to_mass_quotient = UnitConstant(
    'electron_charge_to_mass_quotient',
    _cd('electron charge to mass quotient'),
    symbol='(-e/m_e)',
    u_symbol='(-e/mₑ)'
)
g_e = electron_g_factor = UnitConstant(
    'electron_g_factor',
    _cd('electron g factor'),
    symbol='g_e',
    u_symbol='gₑ'
)
gamma_e = electron_gyromagnetic_ratio = UnitConstant(
    'electron_gyromagnetic_ratio',
    _cd('electron gyromagnetic ratio'),
    symbol='gamma_e',
    u_symbol='γₑ'
)
electron_gyromagnetic_ratio_over_2_pi = UnitConstant(
    'electron_gyromagnetic_ratio_over_2_pi',
    _cd('electron gyromagnetic ratio over 2 pi'),
    symbol='gamma_e/(2*pi)',
    u_symbol='γₑ/(2·π)'
)
mu_e = electron_magnetic_moment = UnitConstant(
    'electron_magnetic_moment',
    _cd('electron magnetic moment'),
    symbol='mu_e',
    u_symbol='μₑ'
)
a_e = electron_magnetic_moment_anomaly = UnitConstant(
    'electron_magnetic_moment_anomaly',
    _cd('electron magnetic moment anomaly'),
    symbol='a_e',
    u_symbol='aₑ'
)
eV = electron_volt = UnitConstant(
    'electron_volt',
    _cd('electron volt'),
    symbol='eV'
)
sigma_e = Thomson_cross_section = UnitConstant(
    'Thomson_cross_section',
    _cd('Thomson cross section'),
    symbol='sigma_e',
    u_symbol='σₑ'
)

mu_B = Bohr_magneton = UnitConstant(
    'Bohr_magneton',
    _cd('Bohr magneton'),
    symbol='mu_B',
    u_symbol='μ_B'
)
Bohr_magneton_in_Hz_per_T = UnitConstant(
    'Bohr_magneton_in_Hz_per_T',
    _cd('Bohr magneton in Hz/T')
)
Bohr_magneton_in_inverse_meters_per_tesla = UnitConstant(
    'Bohr_magneton_in_inverse_meters_per_tesla',
    _cd('Bohr magneton in inverse meters per tesla')
)
Bohr_magneton_in_K_per_T = UnitConstant(
    'Bohr_magneton_in_K_per_T',
    _cd('Bohr magneton in K/T')
)

electron_mass_energy_equivalent = UnitConstant(
    'electron_mass_energy_equivalent',
    _cd('electron mass energy equivalent'),
    symbol='(m_e*c**2)',
    u_symbol='(mₑ·c²)'
)
electron_mass_energy_equivalent_in_MeV = UnitConstant(
    'electron_mass_energy_equivalent_in_MeV',
    _cd('electron mass energy equivalent in MeV')
)
electron_mass_in_u = UnitConstant(
    'electron_mass_in_u',
    _cd('electron mass in u')
)
electron_molar_mass = UnitConstant(
    'electron_molar_mass',
    _cd('electron molar mass'),
    symbol='M_e',
    u_symbol='Mₑ'
)

electron_deuteron_mass_ratio = UnitConstant(
    'electron_deuteron_mass_ratio',
    _cd('electron-deuteron mass ratio'),
    symbol='(m_e/m_d)',
    u_symbol='(mₑ/m_d)'
)
electron_muon_mass_ratio = UnitConstant(
    'electron_muon_mass_ratio',
    _cd('electron-muon mass ratio'),
    symbol='(m_e/m_mu)',
    u_symbol='(mₑ/m_μ)'
)
electron_neutron_mass_ratio = UnitConstant(
    'electron_neutron_mass_ratio',
    _cd('electron-neutron mass ratio'),
    symbol='(m_e/m_n)',
    u_symbol='(mₑ/m_n)'
)
electron_proton_mass_ratio = UnitConstant(
    'electron_proton_mass_ratio',
    _cd('electron-proton mass ratio'),
    symbol='(m_e/m_p)',
    u_symbol='(mₑ/m_p)'
)
electron_tau_mass_ratio = UnitConstant(
    'electron_tau_mass_ratio',
    _cd('electron-tau mass ratio'),
    symbol='(m_e/m_tau)',
    u_symbol='(mₑ/m_τ)'
)
electron_to_alpha_particle_mass_ratio = UnitConstant(
    'electron_to_alpha_particle_mass_ratio',
    _cd('electron to alpha particle mass ratio'),
    symbol='(m_e/m_alpha)',
    u_symbol='(mₑ/m_α)'
)

electron_deuteron_magnetic_moment_ratio = UnitConstant(
    'electron_deuteron_magnetic_moment_ratio',
    _cd('electron-deuteron magnetic moment ratio'),
    symbol='(mu_e/mu_d)',
    u_symbol='(μₑ/μ_d)'
)
electron_magnetic_moment_to_Bohr_magneton_ratio = UnitConstant(
    'electron_magnetic_moment_to_Bohr_magneton_ratio',
    _cd('electron magnetic moment to Bohr magneton ratio'),
    symbol='(mu_e/mu_B)',
    u_symbol='(μₑ/μ_B)'
)
electron_magnetic_moment_to_nuclear_magneton_ratio = UnitConstant(
    'electron_magnetic_moment_to_nuclear_magneton_ratio',
    _cd('electron magnetic moment to nuclear magneton ratio'),
    symbol='(mu_e/mu_N)',
    u_symbol='(μₑ/μ_N)'
)
electron_muon_magnetic_moment_ratio = UnitConstant(
    'electron_muon_magnetic_moment_ratio',
    _cd('electron-muon magnetic moment ratio'),
    symbol='(mu_e/mu_mu)',
    u_symbol='(μₑ/μ_μ)'
)
electron_neutron_magnetic_moment_ratio = UnitConstant(
    'electron_neutron_magnetic_moment_ratio',
    _cd('electron-neutron magnetic moment ratio'),
    symbol='(mu_e/mu_n)',
    u_symbol='(μₑ/μ_n)'
)
electron_proton_magnetic_moment_ratio = UnitConstant(
    'electron_proton_magnetic_moment_ratio',
    _cd('electron-proton magnetic moment ratio'),
    symbol='(mu_e/mu_p)',
    u_symbol='(μₑ/μ_p)'
)
electron_to_shielded_helion_magnetic_moment_ratio = UnitConstant(
    'electron_to_shielded_helion_magnetic_moment_ratio',
    _cd('electron to shielded helion magnetic moment ratio'),
    symbol='(mu_e/muprime_h)',
    u_symbol='(μₑ/μ′_h)'
)
electron_to_shielded_proton_magnetic_moment_ratio = UnitConstant(
    'electron_to_shielded_proton_magnetic_moment_ratio',
    _cd('electron to shielded proton magnetic moment ratio'),
    symbol='(mu_e/muprime_p)',
    u_symbol='(μₑ/μ′_p)'
)


electron_volt_atomic_mass_unit_relationship = UnitConstant(
    'electron_volt_atomic_mass_unit_relationship',
    _cd('electron volt-atomic mass unit relationship')
)
electron_volt_hartree_relationship = UnitConstant(
    'electron_volt_hartree_relationship',
    _cd('electron volt-hartree relationship')
)
electron_volt_hertz_relationship = UnitConstant(
    'electron_volt_hertz_relationship',
    _cd('electron volt-hertz relationship')
)
electron_volt_inverse_meter_relationship = UnitConstant(
    'electron_volt_inverse_meter_relationship',
    _cd('electron volt-inverse meter relationship')
)
electron_volt_joule_relationship = UnitConstant(
    'electron_volt_joule_relationship',
    _cd('electron volt-joule relationship')
)
electron_volt_kelvin_relationship = UnitConstant(
    'electron_volt_kelvin_relationship',
    _cd('electron volt-kelvin relationship')
)
electron_volt_kilogram_relationship = UnitConstant(
    'electron_volt_kilogram_relationship',
    _cd('electron volt-kilogram relationship')
)
hertz_electron_volt_relationship = UnitConstant(
    'hertz_electron_volt_relationship',
    _cd('hertz-electron volt relationship')
)
inverse_meter_electron_volt_relationship = UnitConstant(
    'inverse_meter_electron_volt_relationship',
    _cd('inverse meter-electron volt relationship')
)
joule_electron_volt_relationship = UnitConstant(
    'joule_electron_volt_relationship',
    _cd('joule-electron volt relationship')
)
kelvin_electron_volt_relationship = UnitConstant(
    'kelvin_electron_volt_relationship',
    _cd('kelvin-electron volt relationship')
)
kilogram_electron_volt_relationship = UnitConstant(
    'kilogram_electron_volt_relationship',
    _cd('kilogram-electron volt relationship')
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = helion
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant



m_h = helion_mass = UnitConstant(
    'helion_mass',
    _cd('helion mass'),
    symbol='m_h'
)
gamma_prime_h = shielded_helion_gyromagnetic_ratio = UnitConstant(
    'shielded_helion_gyromagnetic_ratio',
    _cd('shielded helion gyromagnetic ratio'),
    symbol='gammaprime_h',
    u_symbol='γ′_h'
)
shielded_helion_gyromagnetic_ratio_over_2_pi = UnitConstant(
    'shielded_helion_gyromagnetic_ratio_over_2_pi',
    _cd('shielded helion gyromagnetic ratio over 2 pi'),
    symbol='(gammaprime_h/(2*pi))',
    u_symbol='(γ′_h/(2·π))'
)
mu_prime_h = shielded_helion_magnetic_moment = UnitConstant(
    'shielded_helion_magnetic_moment',
    _cd('shielded helion magnetic moment'),
    symbol='muprime_h',
    u_symbol='μ′_h'
)
helion_mass_energy_equivalent = UnitConstant(
    'helion_mass_energy_equivalent',
    _cd('helion mass energy equivalent'),
    symbol='(m_h*c**2)',
    u_symbol='(m_h·c²)'
)
helion_mass_energy_equivalent_in_MeV = UnitConstant(
    'helion_mass_energy_equivalent_in_MeV',
    _cd('helion mass energy equivalent in MeV')
)
helion_mass_in_u = UnitConstant(
    'helion_mass_in_u',
    _cd('helion mass in u')
)
helion_molar_mass = UnitConstant(
    'helion_molar_mass',
    _cd('helion molar mass'),
    symbol='M_h'
)
helion_electron_mass_ratio = UnitConstant(
    'helion_electron_mass_ratio',
    _cd('helion-electron mass ratio'),
    symbol='(m_h/m_e)',
    u_symbol='(m_h/mₑ)'
)
helion_proton_mass_ratio = UnitConstant(
    'helion_proton_mass_ratio',
    _cd('helion-proton mass ratio'),
    symbol='(m_h/m_p)'
)

shielded_helion_to_proton_magnetic_moment_ratio = UnitConstant(
    'shielded_helion_to_proton_magnetic_moment_ratio',
    _cd('shielded helion to proton magnetic moment ratio'),
    symbol='(muprime_h/mu_p)',
    u_symbol='(μ′_h/μ_p)'
)
shielded_helion_magnetic_moment_to_Bohr_magneton_ratio = UnitConstant(
    'shielded_helion_magnetic_moment_to_Bohr_magneton_ratio',
    _cd('shielded helion magnetic moment to Bohr magneton ratio'),
    symbol='(muprime_h/mu_B)',
    u_symbol='(μ′_h/μ_B)'
)
shielded_helion_magnetic_moment_to_nuclear_magneton_ratio = UnitConstant(
    'shielded_helion_magnetic_moment_to_nuclear_magneton_ratio',
    _cd('shielded helion magnetic moment to nuclear magneton ratio'),
    symbol='(muprime_h/mu_N)',
    u_symbol='(μ′_h/μ_N)'
)
shielded_helion_to_shielded_proton_magnetic_moment_ratio = UnitConstant(
    'shielded_helion_to_shielded_proton_magnetic_moment_ratio',
    _cd('shielded helion to shielded proton magnetic moment ratio'),
    symbol='(muprime_h/muprime_p)',
    u_symbol='(μ′_h/μ′_p)'
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = mathematical
# -*- coding: utf-8 -*-

import math as _math

from ..unitquantity import UnitConstant


pi = UnitConstant(
    'pi',
    _math.pi,
    u_symbol='π'
)
golden = golden_ratio = UnitConstant(
    'golden_ratio',
    (1 + _math.sqrt(5)) / 2,
    u_symbol='ϕ',
    aliases='golden'
)

########NEW FILE########
__FILENAME__ = muon
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


m_mu = muon_mass = UnitConstant(
    'muon_mass',
    _cd('muon mass'),
    symbol='m_mu',
    u_symbol='m_μ'
)
lambda_C_mu = muon_Compton_wavelength = UnitConstant(
    'muon_Compton_wavelength',
    _cd('muon Compton wavelength'),
    symbol='lambdabar_C_mu',
    u_symbol='λ_C_μ'
)
muon_Compton_wavelength_over_2_pi = UnitConstant(
    'muon_Compton_wavelength_over_2_pi',
    _cd('muon Compton wavelength over 2 pi'),
    symbol='lambdabar_Cmu',
    u_symbol='ƛ_C_μ'
)
g_mu = muon_g_factor = UnitConstant(
    'muon_g_factor',
    _cd('muon g factor'),
    symbol='g_mu',
    u_symbol='g_μ'
)
mu_mu = muon_magnetic_moment = UnitConstant(
    'muon_magnetic_moment',
    _cd('muon magnetic moment'),
    symbol='mu_mu',
    u_symbol='μ_μ'
)
a_mu = muon_magnetic_moment_anomaly = UnitConstant(
    'muon_magnetic_moment_anomaly',
    _cd('muon magnetic moment anomaly'),
    symbol='a_mu',
    u_symbol='a_μ'
)
muon_mass_energy_equivalent = UnitConstant(
    'muon_mass_energy_equivalent',
    _cd('muon mass energy equivalent'),
    symbol='(m_mu*c**2)',
    u_symbol='(m_μ·c²)'
)
muon_mass_energy_equivalent_in_MeV = UnitConstant(
    'muon_mass_energy_equivalent_in_MeV',
    _cd('muon mass energy equivalent in MeV')
)
muon_mass_in_u = UnitConstant(
    'muon_mass_in_u',
    _cd('muon mass in u')
)
muon_molar_mass = UnitConstant(
    'muon_molar_mass',
    _cd('muon molar mass'),
    symbol='M_mu',
    u_symbol='M_μ'
)

muon_electron_mass_ratio = UnitConstant(
    'muon_electron_mass_ratio',
    _cd('muon-electron mass ratio'),
    symbol='(m_mu/m_e)',
    u_symbol='(m_μ/mₑ)'
)
muon_neutron_mass_ratio = UnitConstant(
    'muon_neutron_mass_ratio',
    _cd('muon-neutron mass ratio'),
    symbol='(m_mu/m_n)',
    u_symbol='(m_μ/m_n)'
)
muon_proton_mass_ratio = UnitConstant(
    'muon_proton_mass_ratio',
    _cd('muon-proton mass ratio'),
    symbol='(m_mu/m_p)',
    u_symbol='(m_μ/m_p)'
)
muon_tau_mass_ratio = UnitConstant(
    'muon_tau_mass_ratio',
    _cd('muon-tau mass ratio'),
    symbol='(m_mu/m_tau)',
    u_symbol='(m_μ/m_τ)'
)

muon_magnetic_moment_to_Bohr_magneton_ratio = UnitConstant(
    'muon_magnetic_moment_to_Bohr_magneton_ratio',
    _cd('muon magnetic moment to Bohr magneton ratio'),
    symbol='(mu_mu/mu_B)',
    u_symbol='(μ_μ/μ_B)'
)
muon_magnetic_moment_to_nuclear_magneton_ratio = UnitConstant(
    'muon_magnetic_moment_to_nuclear_magneton_ratio',
    _cd('muon magnetic moment to nuclear magneton ratio'),
    symbol='(mu_mu/mu_N)',
    u_symbol='(μ_μ/μ_N)'
)
muon_proton_magnetic_moment_ratio = UnitConstant(
    'muon_proton_magnetic_moment_ratio',
    _cd('muon-proton magnetic moment ratio'),
    symbol='(mu_mu/mu_p)',
    u_symbol='(μ_μ/μ_p)'
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = naturalunits
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


natural_unit_of_action = UnitConstant(
    'natural_unit_of_action',
    _cd('natural unit of action'),
    symbol='hbar',
    u_symbol='ħ'
)
natural_unit_of_energy = UnitConstant(
    'natural_unit_of_energy',
    _cd('natural unit of energy'),
    symbol='(m_e*c**2)',
    u_symbol='(mₑ·c²)'
)
natural_unit_of_length = UnitConstant(
    'natural_unit_of_length',
    _cd('natural unit of length'),
    symbol='lambdabar_C',
    u_symbol='ƛ_C'
)
natural_unit_of_mass = UnitConstant(
    'natural_unit_of_mass',
    _cd('natural unit of mass'),
    symbol='m_e',
    u_symbol='mₑ'
)
natural_unit_of_momentum = UnitConstant(
    'natural_unit_of_momentum',
    _cd('natural unit of momentum'),
    symbol='(m_e*c)',
    u_symbol='(mₑ·c)'
)
natural_unit_of_time = UnitConstant(
    'natural_unit_of_time',
    _cd('natural unit of time'),
    symbol='(hbar/(m_e*c**2))',
    u_symbol='(ħ/(mₑ·c²))'
)
natural_unit_of_velocity = UnitConstant(
    'natural_unit_of_velocity',
    _cd('natural unit of velocity'),
    symbol='c'
)

natural_unit_of_action_in_eV_s = UnitConstant(
    'natural_unit_of_action_in_eV_s',
    _cd('natural unit of action in eV s')
)
natural_unit_of_energy_in_MeV = UnitConstant(
    'natural_unit_of_energy_in_MeV',
    _cd('natural unit of energy in MeV')
)
natural_unit_of_momentum_in_MeV_per_c = UnitConstant(
    'natural_unit_of_momentum_in_MeV_per_c',
    _cd('natural unit of momentum in MeV/c')
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = neutron
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


m_n = neutron_mass = UnitConstant(
    'neutron_mass',
    _cd('neutron mass'),
    symbol='m_n'
)
lambda_C_n = neutron_Compton_wavelength = UnitConstant(
    'neutron_Compton_wavelength',
    _cd('neutron Compton wavelength'),
    symbol='lambda_C_n',
    u_symbol='λ_C_n'
)
neutron_Compton_wavelength_over_2_pi = UnitConstant(
    'neutron_Compton_wavelength_over_2_pi',
    _cd('neutron Compton wavelength over 2 pi'),
    symbol='lambdabar_C_n',
    u_symbol='ƛ_C_n'
)
g_n = neutron_g_factor = UnitConstant(
    'neutron_g_factor',
    _cd('neutron g factor'),
    symbol='g_n'
)
gamma_n = neutron_gyromagnetic_ratio = UnitConstant(
    'neutron_gyromagnetic_ratio',
    _cd('neutron gyromagnetic ratio'),
    symbol='gamma_n',
    u_symbol='γ_n'
)
neutron_gyromagnetic_ratio_over_2_pi = UnitConstant(
    'neutron_gyromagnetic_ratio_over_2_pi',
    _cd('neutron gyromagnetic ratio over 2 pi'),
    symbol='(gamma_n/(2*pi))',
    u_symbol='(γ_n/(2·π))'
)
mu_n = neutron_magnetic_moment = UnitConstant(
    'neutron_magnetic_moment',
    _cd('neutron magnetic moment'),
    symbol='mu_n',
    u_symbol='μ_n'
)
neutron_mass_energy_equivalent = UnitConstant(
    'neutron_mass_energy_equivalent',
    _cd('neutron mass energy equivalent'),
    symbol='(m_n*c**2)',
    u_symbol='(m_n·c²)'
)
neutron_mass_energy_equivalent_in_MeV = UnitConstant(
    'neutron_mass_energy_equivalent_in_MeV',
    _cd('neutron mass energy equivalent in MeV')
)
neutron_mass_in_u = UnitConstant(
    'neutron_mass_in_u',
    _cd('neutron mass in u')
)
neutron_molar_mass = UnitConstant(
    'neutron_molar_mass',
    _cd('neutron molar mass'),
    symbol='M_n'
)

neutron_electron_mass_ratio = UnitConstant(
    'neutron_electron_mass_ratio',
    _cd('neutron-electron mass ratio'),
    symbol='(m_n/m_e)',
    u_symbol='(m_n/mₑ)'
)
neutron_muon_mass_ratio = UnitConstant(
    'neutron_muon_mass_ratio',
    _cd('neutron-muon mass ratio'),
    symbol='(m_n/m_mu)',
    u_symbol='(m_n/m_μ)'
)
neutron_proton_mass_ratio = UnitConstant(
    'neutron_proton_mass_ratio',
    _cd('neutron-proton mass ratio'),
    symbol='(m_n/m_p)',
    u_symbol='(m_n/m_p)'
)
neutron_tau_mass_ratio = UnitConstant(
    'neutron_tau_mass_ratio',
    _cd('neutron-tau mass ratio'),
    symbol='(m_n/m_tau)',
    u_symbol='(m_n/m_τ)'
)


neutron_electron_magnetic_moment_ratio = UnitConstant(
    'neutron_electron_magnetic_moment_ratio',
    _cd('neutron-electron magnetic moment ratio'),
    symbol='(mu_n/mu_e)',
    u_symbol='(μ_n/μₑ)'
)
neutron_magnetic_moment_to_Bohr_magneton_ratio = UnitConstant(
    'neutron_magnetic_moment_to_Bohr_magneton_ratio',
    _cd('neutron magnetic moment to Bohr magneton ratio'),
    symbol='(mu_n/mu_B)',
    u_symbol='(μ_n/μ_B)'
)
neutron_magnetic_moment_to_nuclear_magneton_ratio = UnitConstant(
    'neutron_magnetic_moment_to_nuclear_magneton_ratio',
    _cd('neutron magnetic moment to nuclear magneton ratio'),
    symbol='(mu_n/mu_N)',
    u_symbol='(μ_n/μ_N)'
)
neutron_proton_magnetic_moment_ratio = UnitConstant(
    'neutron_proton_magnetic_moment_ratio',
    _cd('neutron-proton magnetic moment ratio'),
    symbol='(mu_n/mu_p)',
    u_symbol='(μ_n/μ_p)'
)
neutron_to_shielded_proton_magnetic_moment_ratio = UnitConstant(
    'neutron_to_shielded_proton_magnetic_moment_ratio',
    _cd('neutron to shielded proton magnetic moment ratio'),
    symbol='(mu_n/muprime_p)',
    u_symbol='(μ_n/μ′_p)'
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = proton
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


m_p = proton_mass = UnitConstant(
    'proton_mass',
    _cd('proton mass'),
    symbol='m_p'
)
lambda_C_p = proton_Compton_wavelength = UnitConstant(
    'proton_Compton_wavelength',
    _cd('proton Compton wavelength'),
    symbol='lambda_C_p',
    u_symbol='λ_C_p'
)
proton_Compton_wavelength_over_2_pi = UnitConstant(
    'proton_Compton_wavelength_over_2_pi',
    _cd('proton Compton wavelength over 2 pi'),
    symbol='lambdabar_C_p',
    u_symbol='ƛ_C_p'
)
R_p = proton_rms_charge_radius = UnitConstant(
    'proton_rms_charge_radius',
    _cd('proton rms charge radius'),
    symbol='R_p'
)
proton_charge_to_mass_quotient = UnitConstant(
    'proton_charge_to_mass_quotient',
    _cd('proton charge to mass quotient'),
    symbol='(e/m_p)'
)
g_p = proton_g_factor = UnitConstant(
    'proton_g_factor',
    _cd('proton g factor'),
    symbol='g_p'
)
gamma_p = proton_gyromagnetic_ratio = UnitConstant(
    'proton_gyromagnetic_ratio',
    _cd('proton gyromagnetic ratio'),
    symbol='gamma_p',
    u_symbol='γ_p'
)
proton_gyromagnetic_ratio_over_2_pi = UnitConstant(
    'proton_gyromagnetic_ratio_over_2_pi',
    _cd('proton gyromagnetic ratio over 2 pi'),
    symbol='(gamma_p/(2*pi))',
    u_symbol='(γ_p/(2·π))'
)
mu_p = proton_magnetic_moment = UnitConstant(
    'proton_magnetic_moment',
    _cd('proton magnetic moment'),
    symbol='mu_p',
    u_symbol='μ_p'
)
sigma_prime_p = proton_magnetic_shielding_correction = UnitConstant(
    'proton_magnetic_shielding_correction',
    _cd('proton magnetic shielding correction'),
    symbol='sigmaprime_p',
    u_symbol='σ′_p'
)
gamma_prime_p = shielded_proton_gyromagnetic_ratio = UnitConstant(
    'shielded_proton_gyromagnetic_ratio',
    _cd('shielded proton gyromagnetic ratio'),
    symbol='gammaprime_p',
    u_symbol='γ′_p'
)
shielded_proton_gyromagnetic_ratio_over_2_pi = UnitConstant(
    'shielded_proton_gyromagnetic_ratio_over_2_pi',
    _cd('shielded proton gyromagnetic ratio over 2 pi'),
    symbol='(gammaprime_p/(2*pi))',
    u_symbol='(γ′_p/(2·π))'
)
mu_prime_p = shielded_proton_magnetic_moment = UnitConstant(
    'shielded_proton_magnetic_moment',
    _cd('shielded proton magnetic moment'),
    symbol='muprime_p',
    u_symbol='μ′_p'
)

mu_N = nuclear_magneton = UnitConstant(
    'nuclear_magneton',
    _cd('nuclear magneton'),
    symbol='mu_N',
    u_symbol='μ_N'
)
nuclear_magneton_in_eV_per_T = UnitConstant(
    'nuclear_magneton_in_eV_per_T',
    _cd('nuclear magneton in eV/T')
)
nuclear_magneton_in_inverse_meters_per_tesla = UnitConstant(
    'nuclear_magneton_in_inverse_meters_per_tesla',
    _cd('nuclear magneton in inverse meters per tesla')
)
nuclear_magneton_in_K_per_T = UnitConstant(
    'nuclear_magneton_in_K_per_T',
    _cd('nuclear magneton in K/T')
)
nuclear_magneton_in_MHz_per_T = UnitConstant(
    'nuclear_magneton_in_MHz_per_T',
    _cd('nuclear magneton in MHz/T')
)

proton_mass_energy_equivalent = UnitConstant(
    'proton_mass_energy_equivalent',
    _cd('proton mass energy equivalent'),
    symbol='(m_p*c**2)',
    u_symbol='(m_p·c²)'
)
proton_mass_energy_equivalent_in_MeV = UnitConstant(
    'proton_mass_energy_equivalent_in_MeV',
    _cd('proton mass energy equivalent in MeV')
)
proton_mass_in_u = UnitConstant(
    'proton_mass_in_u',
    _cd('proton mass in u')
)
proton_molar_mass = UnitConstant(
    'proton_molar_mass',
    _cd('proton molar mass'),
    symbol='M_p'
)

proton_electron_mass_ratio = UnitConstant(
    'proton_electron_mass_ratio',
    _cd('proton-electron mass ratio'),
    symbol='(m_p/m_e)',
    u_symbol='(m_p/mₑ)'
)
proton_muon_mass_ratio = UnitConstant(
    'proton_muon_mass_ratio',
    _cd('proton-muon mass ratio'),
    symbol='(m_p/m_mu)',
    u_symbol='(m_p/m_μ)'
)
proton_neutron_mass_ratio = UnitConstant(
    'proton_neutron_mass_ratio',
    _cd('proton-neutron mass ratio'),
    symbol='(m_p/m_n)',
)
proton_tau_mass_ratio = UnitConstant(
    'proton_tau_mass_ratio',
    _cd('proton-tau mass ratio'),
    symbol='(m_p/m_tau)',
    u_symbol='(m_p/m_τ)'
)

proton_magnetic_moment_to_Bohr_magneton_ratio = UnitConstant(
    'proton_magnetic_moment_to_Bohr_magneton_ratio',
    _cd('proton magnetic moment to Bohr magneton ratio'),
    symbol='(mu_p/mu_B)',
    u_symbol='(μ_p/μ_B)'
)
proton_magnetic_moment_to_nuclear_magneton_ratio = UnitConstant(
    'proton_magnetic_moment_to_nuclear_magneton_ratio',
    _cd('proton magnetic moment to nuclear magneton ratio'),
    symbol='(mu_p/mu_N)',
    u_symbol='(μ_p/μ_N)'
)
proton_neutron_magnetic_moment_ratio = UnitConstant(
    'proton_neutron_magnetic_moment_ratio',
    _cd('proton-neutron magnetic moment ratio'),
    symbol='(mu_p/mu_n)',
    u_symbol='(μ_p/μ_n)'
)
shielded_proton_magnetic_moment_to_Bohr_magneton_ratio = UnitConstant(
    'shielded_proton_magnetic_moment_to_Bohr_magneton_ratio',
    _cd('shielded proton magnetic moment to Bohr magneton ratio'),
    symbol='(muprime_p/mu_B)',
    u_symbol='(μ′_p/μ_B)'
)
shielded_proton_magnetic_moment_to_nuclear_magneton_ratio = UnitConstant(
    'shielded_proton_magnetic_moment_to_nuclear_magneton_ratio',
    _cd('shielded proton magnetic moment to nuclear magneton ratio'),
    symbol='(muprime_p/mu_N)',
    u_symbol='(μ′_p/μ_N)'
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = quantum
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


molar_Planck_constant = UnitConstant(
    'molar_Planck_constant',
    _cd('molar Planck constant'),
    symbol='(N_A*h)',
    u_symbol='(N_A·h)'
)
molar_Planck_constant_times_c = UnitConstant(
    'molar_Planck_constant_times_c',
    _cd('molar Planck constant times c'),
    symbol='(N_A*h*c)',
    u_symbol='(N_A·h·c)'
)
h = Planck_constant = UnitConstant(
    'Planck_constant',
    _cd('Planck constant'),
    symbol='h'
)
hbar = Planck_constant_over_2_pi = UnitConstant(
    'Planck_constant_over_2_pi',
    _cd('Planck constant over 2 pi'),
    symbol='(h/(2*pi))',
    u_symbol='ħ'
)
quantum_of_circulation = UnitConstant(
    'quantum_of_circulation',
    _cd('quantum of circulation'),
    symbol='(h/(2*m_e))',
    u_symbol='(h/(2·mₑ))'
)
quantum_of_circulation_times_2 = UnitConstant(
    'quantum_of_circulation_times_2',
    _cd('quantum of circulation times 2'),
    symbol='(h/m_e)',
    u_symbol='(h/mₑ)'
)

l_P = Planck_length = UnitConstant(
    'Planck_length',
    _cd('Planck length'),
    symbol='l_P'
)
m_P = Planck_mass = UnitConstant(
    'Planck_mass',
    _cd('Planck mass'),
    symbol='m_P'
)
T_P = Planck_temperature = UnitConstant(
    'Planck_temperature',
    _cd('Planck temperature'),
    symbol='T_P'
)
t_P = Planck_time = UnitConstant(
    'Planck_time',
    _cd('Planck time'),
    symbol='t_P'
)

R_infinity = Rydberg_constant = UnitConstant(
    'Rydberg_constant',
    _cd('Rydberg constant'),
    symbol='R_infinity',
    u_symbol='R_∞'
)
Rydberg_constant_times_c_in_Hz = UnitConstant(
    'Rydberg_constant_times_c_in_Hz',
    _cd('Rydberg constant times c in Hz')
)
Rydberg_constant_times_hc_in_eV = UnitConstant(
    'Rydberg_constant_times_hc_in_eV',
    _cd('Rydberg constant times hc in eV')
)
Rydberg_constant_times_hc_in_J = UnitConstant(
    'Rydberg_constant_times_hc_in_J',
    _cd('Rydberg constant times hc in J'),
    symbol='(R_infinity*h*c)',
    u_symbol='(R_∞·h·c)'
)

G_0 = conductance_quantum = UnitConstant(
    'conductance_quantum',
    _cd('conductance quantum'),
    symbol='G_0',
    u_symbol='G₀'
)
K_J90 = conventional_value_of_Josephson_constant = UnitConstant(
    'conventional_value_of_Josephson_constant',
    _cd('conventional value of Josephson constant')
)
R_K90 = conventional_value_of_von_Klitzing_constant = UnitConstant(
    'conventional_value_of_von_Klitzing_constant',
    _cd('conventional value of von Klitzing constant')
)
Fermi_coupling_constant = UnitConstant(
    'Fermi_coupling_constant',
    _cd('Fermi coupling constant'),
    symbol='(G_F/(hbar*c)**3)',
    u_symbol='(G_F/(ħ·c)³)'
)
alpha = fine_structure_constant = UnitConstant(
    'fine_structure_constant',
    _cd('fine-structure constant'),
    symbol='alpha',
    u_symbol='α'
)
inverse_fine_structure_constant = UnitConstant(
    'inverse_fine_structure_constant',
    _cd('inverse fine-structure constant'),
    symbol='alpha**-1',
    u_symbol='α⁻¹'
)
c_1 = first_radiation_constant = UnitConstant(
    'first_radiation_constant',
    _cd('first radiation constant'),
    symbol='c_1',
    u_symbol='c₁'
)
c_1L = first_radiation_constant_for_spectral_radiance = UnitConstant(
    'first_radiation_constant_for_spectral_radiance',
    _cd('first radiation constant for spectral radiance'),
    symbol='c_1L',
    u_symbol='c₁_L'
)
inverse_of_conductance_quantum = UnitConstant(
    'inverse_of_conductance_quantum',
    _cd('inverse of conductance quantum'),
    symbol='G_0**-1',
    u_symbol='G₀⁻¹'
)
Josephson_constant = K_J = UnitConstant(
    'Josephson_constant',
    _cd('Josephson constant'),
    symbol='K_J'
)
Phi_0 = magnetic_flux_quantum = UnitConstant(
    'magnetic_flux_quantum',
    _cd('magnetic flux quantum'),
    symbol='Phi_0',
    u_symbol='Φ₀'
)
Newtonian_constant_of_gravitation_over_h_bar_c = UnitConstant(
    'Newtonian_constant_of_gravitation_over_h_bar_c',
    _cd('Newtonian constant of gravitation over h-bar c'),
    symbol='(G/(hbar*c))',
    u_symbol='(G/(ħ·c))'
)
Sackur_Tetrode_constant_ST_100kPa = UnitConstant(
    'Sackur_Tetrode_constant_ST_100kPa',
    _cd('Sackur-Tetrode constant (1 K, 100 kPa)')
)
Sackur_Tetrode_constant_STP = UnitConstant(
    'Sackur_Tetrode_constant_STP',
    _cd('Sackur-Tetrode constant (1 K, 101.325 kPa)')
)
c_2 = second_radiation_constant = UnitConstant(
    'second_radiation_constant',
    _cd('second radiation constant'),
    symbol='c_2',
    u_symbol='c₂'
)
sigma = Stefan_Boltzmann_constant = UnitConstant(
    'Stefan_Boltzmann_constant',
    _cd('Stefan-Boltzmann constant'),
    symbol='sigma',
    u_symbol='σ'
)
R_K = von_Klitzing_constant = UnitConstant(
    'von_Klitzing_constant',
    _cd('von Klitzing constant'),
    symbol='R_K'
)
b_prime = Wien_frequency_displacement_law_constant = UnitConstant(
    'Wien_frequency_displacement_law_constant',
    _cd('Wien frequency displacement law constant'),
    symbol='bprime',
    u_symbol='b′'
)
b = Wien_wavelength_displacement_law_constant = UnitConstant(
    'Wien_wavelength_displacement_law_constant',
    _cd('Wien wavelength displacement law constant'),
    symbol='b'
)

Planck_constant_in_eV_s = UnitConstant(
    'Planck_constant_in_eV_s',
    _cd('Planck constant in eV s')
)
Planck_constant_over_2_pi_in_eV_s = UnitConstant(
    'Planck_constant_over_2_pi_in_eV_s',
    _cd('Planck constant over 2 pi in eV s')
)
Planck_constant_over_2_pi_times_c_in_MeV_fm = UnitConstant(
    'Planck_constant_over_2_pi_times_c_in_MeV_fm',
    _cd('Planck constant over 2 pi times c in MeV fm')
)
Planck_mass_energy_equivalent_in_GeV = UnitConstant(
    'Planck_mass_energy_equivalent_in_GeV',
    _cd('Planck mass energy equivalent in GeV')
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = relationships
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


hertz_inverse_meter_relationship = UnitConstant(
    'hertz_inverse_meter_relationship',
    _cd('hertz-inverse meter relationship')
)
hertz_joule_relationship = UnitConstant(
    'hertz_joule_relationship',
    _cd('hertz-joule relationship')
)
hertz_kelvin_relationship = UnitConstant(
    'hertz_kelvin_relationship',
    _cd('hertz-kelvin relationship')
)
hertz_kilogram_relationship = UnitConstant(
    'hertz_kilogram_relationship',
    _cd('hertz-kilogram relationship')
)
inverse_meter_hertz_relationship = UnitConstant(
    'inverse_meter_hertz_relationship',
    _cd('inverse meter-hertz relationship')
)
inverse_meter_joule_relationship = UnitConstant(
    'inverse_meter_joule_relationship',
    _cd('inverse meter-joule relationship')
)
inverse_meter_kelvin_relationship = UnitConstant(
    'inverse_meter_kelvin_relationship',
    _cd('inverse meter-kelvin relationship')
)
inverse_meter_kilogram_relationship = UnitConstant(
    'inverse_meter_kilogram_relationship',
    _cd('inverse meter-kilogram relationship')
)
joule_hertz_relationship = UnitConstant(
    'joule_hertz_relationship',
    _cd('joule-hertz relationship')
)
joule_inverse_meter_relationship = UnitConstant(
    'joule_inverse_meter_relationship',
    _cd('joule-inverse meter relationship')
)
joule_kelvin_relationship = UnitConstant(
    'joule_kelvin_relationship',
    _cd('joule-kelvin relationship')
)
joule_kilogram_relationship = UnitConstant(
    'joule_kilogram_relationship',
    _cd('joule-kilogram relationship')
)
kelvin_hertz_relationship = UnitConstant(
    'kelvin_hertz_relationship',
    _cd('kelvin-hertz relationship')
)
kelvin_inverse_meter_relationship = UnitConstant(
    'kelvin_inverse_meter_relationship',
    _cd('kelvin-inverse meter relationship')
)
kelvin_joule_relationship = UnitConstant(
    'kelvin_joule_relationship',
    _cd('kelvin-joule relationship')
)
kelvin_kilogram_relationship = UnitConstant(
    'kelvin_kilogram_relationship',
    _cd('kelvin-kilogram relationship')
)
kilogram_hertz_relationship = UnitConstant(
    'kilogram_hertz_relationship',
    _cd('kilogram-hertz relationship')
)
kilogram_inverse_meter_relationship = UnitConstant(
    'kilogram_inverse_meter_relationship',
    _cd('kilogram-inverse meter relationship')
)
kilogram_joule_relationship = UnitConstant(
    'kilogram_joule_relationship',
    _cd('kilogram-joule relationship')
)
kilogram_kelvin_relationship = UnitConstant(
    'kilogram_kelvin_relationship',
    _cd('kilogram-kelvin relationship')
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = statisticalmechanics
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


N_A = L = Avogadro_constant = UnitConstant(
    'Avogadro_constant',
    _cd('Avogadro constant'),
    symbol='N_A'
)
n_0 = Loschmidt_constant = UnitConstant(
    'Loschmidt_constant',
    _cd('Loschmidt constant (273.15 K, 101.325 kPa)'),
    symbol='n_0',
    u_symbol='n₀'
)
R = molar_gas_constant = UnitConstant(
    'molar_gas_constant',
    _cd('molar gas constant'),
    symbol='R'
)

k = Boltzmann_constant = UnitConstant(
    'Boltzmann_constant',
    _cd('Boltzmann constant'),
    symbol='k'
)
Boltzmann_constant_in_eV_per_K = UnitConstant(
    'Boltzmann_constant_in_eV_per_K',
    _cd('Boltzmann constant in eV/K')
)
Boltzmann_constant_in_Hz_per_K = UnitConstant(
    'Boltzmann_constant_in_Hz_per_K',
    _cd('Boltzmann constant in Hz/K')
)
Boltzmann_constant_in_inverse_meters_per_kelvin = UnitConstant(
    'Boltzmann_constant_in_inverse_meters_per_kelvin',
    _cd('Boltzmann constant in inverse meters per kelvin')
)

M_u = molar_mass_constant = UnitConstant(
    'molar_mass_constant',
    _cd('molar mass constant'),
    symbol='M_u',
    u_symbol='Mᵤ'
)
molar_volume_of_ideal_gas_ST_100kPa = UnitConstant(
    'molar_volume_of_ideal_gas_ST_100kPa',
    _cd('molar volume of ideal gas (273.15 K, 100 kPa)')
)
molar_volume_of_ideal_gas_STP = UnitConstant(
    'molar_volume_of_ideal_gas_STP',
    _cd('molar volume of ideal gas (273.15 K, 101.325 kPa)')
)
molar_volume_of_silicon = UnitConstant(
    'molar_volume_of_silicon',
    _cd('molar volume of silicon')
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = tau
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


m_tau = tau_mass = UnitConstant(
    'tau_mass',
    _cd('tau mass'),
    symbol='m_tau',
    u_symbol='m_τ'
)
lambda_C_tau = tau_Compton_wavelength = UnitConstant(
    'tau_Compton_wavelength',
    _cd('tau Compton wavelength'),
    symbol='lambda_C_tau',
    u_symbol='λ_C_τ'
)
tau_Compton_wavelength_over_2_pi = UnitConstant(
    'tau_Compton_wavelength_over_2_pi',
    _cd('tau Compton wavelength over 2 pi'),
    symbol='lambda_C_tau',
    u_symbol='ƛ_C_τ'
)
tau_mass_energy_equivalent = UnitConstant(
    'tau_mass_energy_equivalent',
    _cd('tau mass energy equivalent'),
    symbol='(m_tau*c**2)',
    u_symbol='(m_τ·c²)'
)
tau_mass_energy_equivalent_in_MeV = UnitConstant(
    'tau_mass_energy_equivalent_in_MeV',
    _cd('tau mass energy equivalent in MeV')
)
tau_mass_in_u = UnitConstant(
    'tau_mass_in_u',
    _cd('tau mass in u')
)
tau_molar_mass = UnitConstant(
    'tau_molar_mass',
    _cd('tau molar mass'),
    symbol='M_tau',
    u_symbol='M_τ'
)

tau_electron_mass_ratio = UnitConstant(
    'tau_electron_mass_ratio',
    _cd('tau-electron mass ratio'),
    symbol='(m_tau/m_e)',
    u_symbol='(m_τ/mₑ)'
)
tau_muon_mass_ratio = UnitConstant(
    'tau_muon_mass_ratio',
    _cd('tau-muon mass ratio'),
    symbol='(m_tau/m_mu)',
    u_symbol='(m_τ/m_μ)'
)
tau_neutron_mass_ratio = UnitConstant(
    'tau_neutron_mass_ratio',
    _cd('tau-neutron mass ratio'),
    symbol='(m_tau/m_n)',
    u_symbol='(m_τ/m_n)'
)
tau_proton_mass_ratio = UnitConstant(
    'tau_proton_mass_ratio',
    _cd('tau-proton mass ratio'),
    symbol='(m_tau/m_p)',
    u_symbol='(m_τ/m_p)'
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = triton
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


m_t = triton_mass = UnitConstant(
    'triton_mass',
    _cd('triton mass'),
    symbol='m_t'
)
g_t = triton_g_factor = UnitConstant(
    'triton_g_factor',
    _cd('triton g factor'),
    symbol='g_t'
)
mu_t = triton_magnetic_moment = UnitConstant(
    'triton_magnetic_moment',
    _cd('triton magnetic moment'),
    symbol='mu_t',
    u_symbol='μ_t'
)
triton_mass_energy_equivalent = UnitConstant(
    'triton_mass_energy_equivalent',
    _cd('triton mass energy equivalent'),
    symbol='(m_t*c**2)',
    u_symbol='(m_t·c²)'
)
triton_mass_energy_equivalent_in_MeV = UnitConstant(
    'triton_mass_energy_equivalent_in_MeV',
    _cd('triton mass energy equivalent in MeV')
)
triton_mass_in_u = UnitConstant(
    'triton_mass_in_u',
    _cd('triton mass in u')
)
triton_molar_mass = UnitConstant(
    'triton_molar_mass',
    _cd('triton molar mass'),
    symbol='M_t'
)

triton_electron_mass_ratio = UnitConstant(
    'triton_electron_mass_ratio',
    _cd('triton-electron mass ratio'),
    symbol='(m_t/m_e)',
    u_symbol='(m_t/mₑ)'
)
triton_proton_mass_ratio = UnitConstant(
    'triton_proton_mass_ratio',
    _cd('triton-proton mass ratio'),
    symbol='(m_t/m_p)',
    u_symbol='(m_t/m_p)'
)

triton_electron_magnetic_moment_ratio = UnitConstant(
    'triton_electron_magnetic_moment_ratio',
    _cd('triton-electron magnetic moment ratio'),
    symbol='(mu_t/mu_e)',
    u_symbol='(μ_t/μₑ)'
)
triton_magnetic_moment_to_Bohr_magneton_ratio = UnitConstant(
    'triton_magnetic_moment_to_Bohr_magneton_ratio',
    _cd('triton magnetic moment to Bohr magneton ratio'),
    symbol='(mu_t/mu_B)',
    u_symbol='(μ_t/μ_B)'
)
triton_magnetic_moment_to_nuclear_magneton_ratio = UnitConstant(
    'triton_magnetic_moment_to_nuclear_magneton_ratio',
    _cd('triton magnetic moment to nuclear magneton ratio'),
    symbol='(mu_t/mu_N)',
    u_symbol='(μ_t/μ_N)'
)
triton_neutron_magnetic_moment_ratio = UnitConstant(
    'triton_neutron_magnetic_moment_ratio',
    _cd('triton-neutron magnetic moment ratio'),
    symbol='(mu_t/mu_n)',
    u_symbol='(μ_t/μ_n)'
)
triton_proton_magnetic_moment_ratio = UnitConstant(
    'triton_proton_magnetic_moment_ratio',
    _cd('triton-proton magnetic moment ratio'),
    symbol='(mu_t/mu_p)',
    u_symbol='(μ_t/μ_p)'
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = weak
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


weak_mixing_angle = UnitConstant(
    'weak_mixing_angle',
    _cd('weak mixing angle')
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = xray
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ._utils import _cd
from ..unitquantity import UnitConstant


Angstrom_star = UnitConstant(
    'Angstrom_star',
    _cd('Angstrom star'),
    symbol='A*',
    u_symbol='Å*'
)
d_220 = a_Si_220 = silicon_220_lattice_spacing = UnitConstant(
    'silicon_220_lattice_spacing',
    _cd('{220} lattice spacing of silicon'),
    symbol='d_220',
    u_symbol='d₂₂₀'
)
Cu_x_unit = UnitConstant(
    'Cu_x_unit',
    _cd('Cu x unit'),
    symbol='CuKalpha_1',
    u_symbol='CuKα₁'
)
a = a_Si_100 = lattice_parameter_of_silicon = UnitConstant(
    'lattice_parameter_of_silicon',
    _cd('lattice parameter of silicon')
)
Mo_x_unit = UnitConstant(
    'Mo_x_unit',
    _cd('Mo x unit'),
    symbol='MoKalpha_1',
    u_symbol='MoKα₁'
)

del UnitConstant, _cd

########NEW FILE########
__FILENAME__ = _codata
# THIS FILE IS AUTOMATICALLY GENERATED
# ANY CHANGES MADE HERE WILL BE LOST

physical_constants = {}

physical_constants['{220} lattice spacing of silicon'] = {'value': 192.0155762e-12, 'precision': 0.0000050e-12, 'units': 'm'}
physical_constants['alpha particle-electron mass ratio'] = {'value': 7294.2995365, 'precision': 0.0000031, 'units': ''}
physical_constants['alpha particle mass'] = {'value': 6.64465620e-27, 'precision': 0.00000033e-27, 'units': 'kg'}
physical_constants['alpha particle mass energy equivalent'] = {'value': 5.97191917e-10, 'precision': 0.00000030e-10, 'units': 'J'}
physical_constants['alpha particle mass energy equivalent in MeV'] = {'value': 3727.379109, 'precision': 0.000093, 'units': 'MeV'}
physical_constants['alpha particle mass in u'] = {'value': 4.001506179127, 'precision': 0.000000000062, 'units': 'u'}
physical_constants['alpha particle molar mass'] = {'value': 4.001506179127e-3, 'precision': 0.000000000062e-3, 'units': 'kg*mol**-1'}
physical_constants['alpha particle-proton mass ratio'] = {'value': 3.97259968951, 'precision': 0.00000000041, 'units': ''}
physical_constants['Angstrom star'] = {'value': 1.00001498e-10, 'precision': 0.00000090e-10, 'units': 'm'}
physical_constants['atomic mass constant'] = {'value': 1.660538782e-27, 'precision': 0.000000083e-27, 'units': 'kg'}
physical_constants['atomic mass constant energy equivalent'] = {'value': 1.492417830e-10, 'precision': 0.000000074e-10, 'units': 'J'}
physical_constants['atomic mass constant energy equivalent in MeV'] = {'value': 931.494028, 'precision': 0.000023, 'units': 'MeV'}
physical_constants['atomic mass unit-electron volt relationship'] = {'value': 931.494028e6, 'precision': 0.000023e6, 'units': 'eV'}
physical_constants['atomic mass unit-hartree relationship'] = {'value': 3.4231777149e7, 'precision': 0.0000000049e7, 'units': 'E_h'}
physical_constants['atomic mass unit-hertz relationship'] = {'value': 2.2523427369e23, 'precision': 0.0000000032e23, 'units': 'Hz'}
physical_constants['atomic mass unit-inverse meter relationship'] = {'value': 7.513006671e14, 'precision': 0.000000011e14, 'units': 'm**-1'}
physical_constants['atomic mass unit-joule relationship'] = {'value': 1.492417830e-10, 'precision': 0.000000074e-10, 'units': 'J'}
physical_constants['atomic mass unit-kelvin relationship'] = {'value': 1.0809527e13, 'precision': 0.0000019e13, 'units': 'K'}
physical_constants['atomic mass unit-kilogram relationship'] = {'value': 1.660538782e-27, 'precision': 0.000000083e-27, 'units': 'kg'}
physical_constants['atomic unit of 1st hyperpolarizability'] = {'value': 3.206361533e-53, 'precision': 0.000000081e-53, 'units': 'C**3*m**3*J**-2'}
physical_constants['atomic unit of 2nd hyperpolarizability'] = {'value': 6.23538095e-65, 'precision': 0.00000031e-65, 'units': 'C**4*m**4*J**-3'}
physical_constants['atomic unit of action'] = {'value': 1.054571628e-34, 'precision': 0.000000053e-34, 'units': 'J*s'}
physical_constants['atomic unit of charge'] = {'value': 1.602176487e-19, 'precision': 0.000000040e-19, 'units': 'C'}
physical_constants['atomic unit of charge density'] = {'value': 1.081202300e12, 'precision': 0.000000027e12, 'units': 'C*m**-3'}
physical_constants['atomic unit of current'] = {'value': 6.62361763e-3, 'precision': 0.00000017e-3, 'units': 'A'}
physical_constants['atomic unit of electric dipole moment'] = {'value': 8.47835281e-30, 'precision': 0.00000021e-30, 'units': 'C*m'}
physical_constants['atomic unit of electric field'] = {'value': 5.14220632e11, 'precision': 0.00000013e11, 'units': 'V*m**-1'}
physical_constants['atomic unit of electric field gradient'] = {'value': 9.71736166e21, 'precision': 0.00000024e21, 'units': 'V*m**-2'}
physical_constants['atomic unit of electric polarizability'] = {'value': 1.6487772536e-41, 'precision': 0.0000000034e-41, 'units': 'C**2*m**2*J**-1'}
physical_constants['atomic unit of electric potential'] = {'value': 27.21138386, 'precision': 0.00000068, 'units': 'V'}
physical_constants['atomic unit of electric quadrupole moment'] = {'value': 4.48655107e-40, 'precision': 0.00000011e-40, 'units': 'C*m**2'}
physical_constants['atomic unit of energy'] = {'value': 4.35974394e-18, 'precision': 0.00000022e-18, 'units': 'J'}
physical_constants['atomic unit of force'] = {'value': 8.23872206e-8, 'precision': 0.00000041e-8, 'units': 'N'}
physical_constants['atomic unit of length'] = {'value': 0.52917720859e-10, 'precision': 0.00000000036e-10, 'units': 'm'}
physical_constants['atomic unit of magnetic dipole moment'] = {'value': 1.854801830e-23, 'precision': 0.000000046e-23, 'units': 'J*T**-1'}
physical_constants['atomic unit of magnetic flux density'] = {'value': 2.350517382e5, 'precision': 0.000000059e5, 'units': 'T'}
physical_constants['atomic unit of magnetizability'] = {'value': 7.891036433e-29, 'precision': 0.000000027e-29, 'units': 'J*T**-2'}
physical_constants['atomic unit of mass'] = {'value': 9.10938215e-31, 'precision': 0.00000045e-31, 'units': 'kg'}
physical_constants['atomic unit of momentum'] = {'value': 1.992851565e-24, 'precision': 0.000000099e-24, 'units': 'kg*m*s**-1'}
physical_constants['atomic unit of permittivity'] = {'value': 1.112650056e-10, 'precision': 0, 'units': 'F*m**-1'}
physical_constants['atomic unit of time'] = {'value': 2.418884326505e-17, 'precision': 0.000000000016e-17, 'units': 's'}
physical_constants['atomic unit of velocity'] = {'value': 2.1876912541e6, 'precision': 0.0000000015e6, 'units': 'm*s**-1'}
physical_constants['Avogadro constant'] = {'value': 6.02214179e23, 'precision': 0.00000030e23, 'units': 'mol**-1'}
physical_constants['Bohr magneton'] = {'value': 927.400915e-26, 'precision': 0.000023e-26, 'units': 'J*T**-1'}
physical_constants['Bohr magneton in eV/T'] = {'value': 5.7883817555e-5, 'precision': 0.0000000079e-5, 'units': 'eV*T**-1'}
physical_constants['Bohr magneton in Hz/T'] = {'value': 13.99624604e9, 'precision': 0.00000035e9, 'units': 'Hz*T**-1'}
physical_constants['Bohr magneton in inverse meters per tesla'] = {'value': 46.6864515, 'precision': 0.0000012, 'units': 'm**-1*T**-1'}
physical_constants['Bohr magneton in K/T'] = {'value': 0.6717131, 'precision': 0.0000012, 'units': 'K*T**-1'}
physical_constants['Bohr radius'] = {'value': 0.52917720859e-10, 'precision': 0.00000000036e-10, 'units': 'm'}
physical_constants['Boltzmann constant'] = {'value': 1.3806504e-23, 'precision': 0.0000024e-23, 'units': 'J*K**-1'}
physical_constants['Boltzmann constant in eV/K'] = {'value': 8.617343e-5, 'precision': 0.000015e-5, 'units': 'eV*K**-1'}
physical_constants['Boltzmann constant in Hz/K'] = {'value': 2.0836644e10, 'precision': 0.0000036e10, 'units': 'Hz*K**-1'}
physical_constants['Boltzmann constant in inverse meters per kelvin'] = {'value': 69.50356, 'precision': 0.00012, 'units': 'm**-1*K**-1'}
physical_constants['characteristic impedance of vacuum'] = {'value': 376.730313461, 'precision': 0, 'units': 'ohm'}
physical_constants['classical electron radius'] = {'value': 2.8179402894e-15, 'precision': 0.0000000058e-15, 'units': 'm'}
physical_constants['Compton wavelength'] = {'value': 2.4263102175e-12, 'precision': 0.0000000033e-12, 'units': 'm'}
physical_constants['Compton wavelength over 2 pi'] = {'value': 386.15926459e-15, 'precision': 0.00000053e-15, 'units': 'm'}
physical_constants['conductance quantum'] = {'value': 7.7480917004e-5, 'precision': 0.0000000053e-5, 'units': 'S'}
physical_constants['conventional value of Josephson constant'] = {'value': 483597.9e9, 'precision': 0, 'units': 'Hz*V**-1'}
physical_constants['conventional value of von Klitzing constant'] = {'value': 25812.807, 'precision': 0, 'units': 'ohm'}
physical_constants['Cu x unit'] = {'value': 1.00207699e-13, 'precision': 0.00000028e-13, 'units': 'm'}
physical_constants['deuteron-electron magnetic moment ratio'] = {'value': -4.664345537e-4, 'precision': 0.000000039e-4, 'units': ''}
physical_constants['deuteron-electron mass ratio'] = {'value': 3670.4829654, 'precision': 0.0000016, 'units': ''}
physical_constants['deuteron g factor'] = {'value': 0.8574382308, 'precision': 0.0000000072, 'units': ''}
physical_constants['deuteron magnetic moment'] = {'value': 0.433073465e-26, 'precision': 0.000000011e-26, 'units': 'J*T**-1'}
physical_constants['deuteron magnetic moment to Bohr magneton ratio'] = {'value': 0.4669754556e-3, 'precision': 0.0000000039e-3, 'units': ''}
physical_constants['deuteron magnetic moment to nuclear magneton ratio'] = {'value': 0.8574382308, 'precision': 0.0000000072, 'units': ''}
physical_constants['deuteron mass'] = {'value': 3.34358320e-27, 'precision': 0.00000017e-27, 'units': 'kg'}
physical_constants['deuteron mass energy equivalent'] = {'value': 3.00506272e-10, 'precision': 0.00000015e-10, 'units': 'J'}
physical_constants['deuteron mass energy equivalent in MeV'] = {'value': 1875.612793, 'precision': 0.000047, 'units': 'MeV'}
physical_constants['deuteron mass in u'] = {'value': 2.013553212724, 'precision': 0.000000000078, 'units': 'u'}
physical_constants['deuteron molar mass'] = {'value': 2.013553212724e-3, 'precision': 0.000000000078e-3, 'units': 'kg*mol**-1'}
physical_constants['deuteron-neutron magnetic moment ratio'] = {'value': -0.44820652, 'precision': 0.00000011, 'units': ''}
physical_constants['deuteron-proton magnetic moment ratio'] = {'value': 0.3070122070, 'precision': 0.0000000024, 'units': ''}
physical_constants['deuteron-proton mass ratio'] = {'value': 1.99900750108, 'precision': 0.00000000022, 'units': ''}
physical_constants['deuteron rms charge radius'] = {'value': 2.1402e-15, 'precision': 0.0028e-15, 'units': 'm'}
physical_constants['electric constant'] = {'value': 8.854187817e-12, 'precision': 0, 'units': 'F*m**-1'}
physical_constants['electron charge to mass quotient'] = {'value': -1.758820150e11, 'precision': 0.000000044e11, 'units': 'C*kg**-1'}
physical_constants['electron-deuteron magnetic moment ratio'] = {'value': -2143.923498, 'precision': 0.000018, 'units': ''}
physical_constants['electron-deuteron mass ratio'] = {'value': 2.7244371093e-4, 'precision': 0.0000000012e-4, 'units': ''}
physical_constants['electron g factor'] = {'value': -2.0023193043622, 'precision': 0.0000000000015, 'units': ''}
physical_constants['electron gyromagnetic ratio'] = {'value': 1.760859770e11, 'precision': 0.000000044e11, 'units': 's**-1*T**-1'}
physical_constants['electron gyromagnetic ratio over 2 pi'] = {'value': 28024.95364, 'precision': 0.00070, 'units': 'MHz*T**-1'}
physical_constants['electron magnetic moment'] = {'value': -928.476377e-26, 'precision': 0.000023e-26, 'units': 'J*T**-1'}
physical_constants['electron magnetic moment anomaly'] = {'value': 1.15965218111e-3, 'precision': 0.00000000074e-3, 'units': ''}
physical_constants['electron magnetic moment to Bohr magneton ratio'] = {'value': -1.00115965218111, 'precision': 0.00000000000074, 'units': ''}
physical_constants['electron magnetic moment to nuclear magneton ratio'] = {'value': -1838.28197092, 'precision': 0.00000080, 'units': ''}
physical_constants['electron mass'] = {'value': 9.10938215e-31, 'precision': 0.00000045e-31, 'units': 'kg'}
physical_constants['electron mass energy equivalent'] = {'value': 8.18710438e-14, 'precision': 0.00000041e-14, 'units': 'J'}
physical_constants['electron mass energy equivalent in MeV'] = {'value': 0.510998910, 'precision': 0.000000013, 'units': 'MeV'}
physical_constants['electron mass in u'] = {'value': 5.4857990943e-4, 'precision': 0.0000000023e-4, 'units': 'u'}
physical_constants['electron molar mass'] = {'value': 5.4857990943e-7, 'precision': 0.0000000023e-7, 'units': 'kg*mol**-1'}
physical_constants['electron-muon magnetic moment ratio'] = {'value': 206.7669877, 'precision': 0.0000052, 'units': ''}
physical_constants['electron-muon mass ratio'] = {'value': 4.83633171e-3, 'precision': 0.00000012e-3, 'units': ''}
physical_constants['electron-neutron magnetic moment ratio'] = {'value': 960.92050, 'precision': 0.00023, 'units': ''}
physical_constants['electron-neutron mass ratio'] = {'value': 5.4386734459e-4, 'precision': 0.0000000033e-4, 'units': ''}
physical_constants['electron-proton magnetic moment ratio'] = {'value': -658.2106848, 'precision': 0.0000054, 'units': ''}
physical_constants['electron-proton mass ratio'] = {'value': 5.4461702177e-4, 'precision': 0.0000000024e-4, 'units': ''}
physical_constants['electron-tau mass ratio'] = {'value': 2.87564e-4, 'precision': 0.00047e-4, 'units': ''}
physical_constants['electron to alpha particle mass ratio'] = {'value': 1.37093355570e-4, 'precision': 0.00000000058e-4, 'units': ''}
physical_constants['electron to shielded helion magnetic moment ratio'] = {'value': 864.058257, 'precision': 0.000010, 'units': ''}
physical_constants['electron to shielded proton magnetic moment ratio'] = {'value': -658.2275971, 'precision': 0.0000072, 'units': ''}
physical_constants['electron volt'] = {'value': 1.602176487e-19, 'precision': 0.000000040e-19, 'units': 'J'}
physical_constants['electron volt-atomic mass unit relationship'] = {'value': 1.073544188e-9, 'precision': 0.000000027e-9, 'units': 'u'}
physical_constants['electron volt-hartree relationship'] = {'value': 3.674932540e-2, 'precision': 0.000000092e-2, 'units': 'E_h'}
physical_constants['electron volt-hertz relationship'] = {'value': 2.417989454e14, 'precision': 0.000000060e14, 'units': 'Hz'}
physical_constants['electron volt-inverse meter relationship'] = {'value': 8.06554465e5, 'precision': 0.00000020e5, 'units': 'm**-1'}
physical_constants['electron volt-joule relationship'] = {'value': 1.602176487e-19, 'precision': 0.000000040e-19, 'units': 'J'}
physical_constants['electron volt-kelvin relationship'] = {'value': 1.1604505e4, 'precision': 0.0000020e4, 'units': 'K'}
physical_constants['electron volt-kilogram relationship'] = {'value': 1.782661758e-36, 'precision': 0.000000044e-36, 'units': 'kg'}
physical_constants['elementary charge'] = {'value': 1.602176487e-19, 'precision': 0.000000040e-19, 'units': 'C'}
physical_constants['elementary charge over h'] = {'value': 2.417989454e14, 'precision': 0.000000060e14, 'units': 'A*J**-1'}
physical_constants['Faraday constant'] = {'value': 96485.3399, 'precision': 0.0024, 'units': 'C*mol**-1'}
physical_constants['Faraday constant for conventional electric current'] = {'value': 96485.3401, 'precision': 0.0048, 'units': 'C_90*mol**-1'}
physical_constants['Fermi coupling constant'] = {'value': 1.16637e-5, 'precision': 0.00001e-5, 'units': 'GeV**-2'}
physical_constants['fine-structure constant'] = {'value': 7.2973525376e-3, 'precision': 0.0000000050e-3, 'units': ''}
physical_constants['first radiation constant'] = {'value': 3.74177118e-16, 'precision': 0.00000019e-16, 'units': 'W*m**2'}
physical_constants['first radiation constant for spectral radiance'] = {'value': 1.191042759e-16, 'precision': 0.000000059e-16, 'units': 'W*m**2*sr**-1'}
physical_constants['hartree-atomic mass unit relationship'] = {'value': 2.9212622986e-8, 'precision': 0.0000000042e-8, 'units': 'u'}
physical_constants['hartree-electron volt relationship'] = {'value': 27.21138386, 'precision': 0.00000068, 'units': 'eV'}
physical_constants['Hartree energy'] = {'value': 4.35974394e-18, 'precision': 0.00000022e-18, 'units': 'J'}
physical_constants['Hartree energy in eV'] = {'value': 27.21138386, 'precision': 0.00000068, 'units': 'eV'}
physical_constants['hartree-hertz relationship'] = {'value': 6.579683920722e15, 'precision': 0.000000000044e15, 'units': 'Hz'}
physical_constants['hartree-inverse meter relationship'] = {'value': 2.194746313705e7, 'precision': 0.000000000015e7, 'units': 'm**-1'}
physical_constants['hartree-joule relationship'] = {'value': 4.35974394e-18, 'precision': 0.00000022e-18, 'units': 'J'}
physical_constants['hartree-kelvin relationship'] = {'value': 3.1577465e5, 'precision': 0.0000055e5, 'units': 'K'}
physical_constants['hartree-kilogram relationship'] = {'value': 4.85086934e-35, 'precision': 0.00000024e-35, 'units': 'kg'}
physical_constants['helion-electron mass ratio'] = {'value': 5495.8852765, 'precision': 0.0000052, 'units': ''}
physical_constants['helion mass'] = {'value': 5.00641192e-27, 'precision': 0.00000025e-27, 'units': 'kg'}
physical_constants['helion mass energy equivalent'] = {'value': 4.49953864e-10, 'precision': 0.00000022e-10, 'units': 'J'}
physical_constants['helion mass energy equivalent in MeV'] = {'value': 2808.391383, 'precision': 0.000070, 'units': 'MeV'}
physical_constants['helion mass in u'] = {'value': 3.0149322473, 'precision': 0.0000000026, 'units': 'u'}
physical_constants['helion molar mass'] = {'value': 3.0149322473e-3, 'precision': 0.0000000026e-3, 'units': 'kg*mol**-1'}
physical_constants['helion-proton mass ratio'] = {'value': 2.9931526713, 'precision': 0.0000000026, 'units': ''}
physical_constants['hertz-atomic mass unit relationship'] = {'value': 4.4398216294e-24, 'precision': 0.0000000064e-24, 'units': 'u'}
physical_constants['hertz-electron volt relationship'] = {'value': 4.13566733e-15, 'precision': 0.00000010e-15, 'units': 'eV'}
physical_constants['hertz-hartree relationship'] = {'value': 1.519829846006e-16, 'precision': 0.000000000010e-16, 'units': 'E_h'}
physical_constants['hertz-inverse meter relationship'] = {'value': 3.335640951e-9, 'precision': 0, 'units': 'm**-1'}
physical_constants['hertz-joule relationship'] = {'value': 6.62606896e-34, 'precision': 0.00000033e-34, 'units': 'J'}
physical_constants['hertz-kelvin relationship'] = {'value': 4.7992374e-11, 'precision': 0.0000084e-11, 'units': 'K'}
physical_constants['hertz-kilogram relationship'] = {'value': 7.37249600e-51, 'precision': 0.00000037e-51, 'units': 'kg'}
physical_constants['inverse fine-structure constant'] = {'value': 137.035999679, 'precision': 0.000000094, 'units': ''}
physical_constants['inverse meter-atomic mass unit relationship'] = {'value': 1.3310250394e-15, 'precision': 0.0000000019e-15, 'units': 'u'}
physical_constants['inverse meter-electron volt relationship'] = {'value': 1.239841875e-6, 'precision': 0.000000031e-6, 'units': 'eV'}
physical_constants['inverse meter-hartree relationship'] = {'value': 4.556335252760e-8, 'precision': 0.000000000030e-8, 'units': 'E_h'}
physical_constants['inverse meter-hertz relationship'] = {'value': 299792458, 'precision': 0, 'units': 'Hz'}
physical_constants['inverse meter-joule relationship'] = {'value': 1.986445501e-25, 'precision': 0.000000099e-25, 'units': 'J'}
physical_constants['inverse meter-kelvin relationship'] = {'value': 1.4387752e-2, 'precision': 0.0000025e-2, 'units': 'K'}
physical_constants['inverse meter-kilogram relationship'] = {'value': 2.21021870e-42, 'precision': 0.00000011e-42, 'units': 'kg'}
physical_constants['inverse of conductance quantum'] = {'value': 12906.4037787, 'precision': 0.0000088, 'units': 'ohm'}
physical_constants['Josephson constant'] = {'value': 483597.891e9, 'precision': 0.012e9, 'units': 'Hz*V**-1'}
physical_constants['joule-atomic mass unit relationship'] = {'value': 6.70053641e9, 'precision': 0.00000033e9, 'units': 'u'}
physical_constants['joule-electron volt relationship'] = {'value': 6.24150965e18, 'precision': 0.00000016e18, 'units': 'eV'}
physical_constants['joule-hartree relationship'] = {'value': 2.29371269e17, 'precision': 0.00000011e17, 'units': 'E_h'}
physical_constants['joule-hertz relationship'] = {'value': 1.509190450e33, 'precision': 0.000000075e33, 'units': 'Hz'}
physical_constants['joule-inverse meter relationship'] = {'value': 5.03411747e24, 'precision': 0.00000025e24, 'units': 'm**-1'}
physical_constants['joule-kelvin relationship'] = {'value': 7.242963e22, 'precision': 0.000013e22, 'units': 'K'}
physical_constants['joule-kilogram relationship'] = {'value': 1.112650056e-17, 'precision': 0, 'units': 'kg'}
physical_constants['kelvin-atomic mass unit relationship'] = {'value': 9.251098e-14, 'precision': 0.000016e-14, 'units': 'u'}
physical_constants['kelvin-electron volt relationship'] = {'value': 8.617343e-5, 'precision': 0.000015e-5, 'units': 'eV'}
physical_constants['kelvin-hartree relationship'] = {'value': 3.1668153e-6, 'precision': 0.0000055e-6, 'units': 'E_h'}
physical_constants['kelvin-hertz relationship'] = {'value': 2.0836644e10, 'precision': 0.0000036e10, 'units': 'Hz'}
physical_constants['kelvin-inverse meter relationship'] = {'value': 69.50356, 'precision': 0.00012, 'units': 'm**-1'}
physical_constants['kelvin-joule relationship'] = {'value': 1.3806504e-23, 'precision': 0.0000024e-23, 'units': 'J'}
physical_constants['kelvin-kilogram relationship'] = {'value': 1.5361807e-40, 'precision': 0.0000027e-40, 'units': 'kg'}
physical_constants['kilogram-atomic mass unit relationship'] = {'value': 6.02214179e26, 'precision': 0.00000030e26, 'units': 'u'}
physical_constants['kilogram-electron volt relationship'] = {'value': 5.60958912e35, 'precision': 0.00000014e35, 'units': 'eV'}
physical_constants['kilogram-hartree relationship'] = {'value': 2.06148616e34, 'precision': 0.00000010e34, 'units': 'E_h'}
physical_constants['kilogram-hertz relationship'] = {'value': 1.356392733e50, 'precision': 0.000000068e50, 'units': 'Hz'}
physical_constants['kilogram-inverse meter relationship'] = {'value': 4.52443915e41, 'precision': 0.00000023e41, 'units': 'm**-1'}
physical_constants['kilogram-joule relationship'] = {'value': 8.987551787e16, 'precision': 0, 'units': 'J'}
physical_constants['kilogram-kelvin relationship'] = {'value': 6.509651e39, 'precision': 0.000011e39, 'units': 'K'}
physical_constants['lattice parameter of silicon'] = {'value': 543.102064e-12, 'precision': 0.000014e-12, 'units': 'm'}
physical_constants['Loschmidt constant (273.15 K, 101.325 kPa)'] = {'value': 2.6867774e25, 'precision': 0.0000047e25, 'units': 'm**-3'}
physical_constants['magnetic constant'] = {'value': 12.566370614e-7, 'precision': 0, 'units': 'N*A**-2'}
physical_constants['magnetic flux quantum'] = {'value': 2.067833667e-15, 'precision': 0.000000052e-15, 'units': 'Wb'}
physical_constants['molar gas constant'] = {'value': 8.314472, 'precision': 0.000015, 'units': 'J*mol**-1*K**-1'}
physical_constants['molar mass constant'] = {'value': 1e-3, 'precision': 0, 'units': 'kg*mol**-1'}
physical_constants['molar mass of carbon-12'] = {'value': 12e-3, 'precision': 0, 'units': 'kg*mol**-1'}
physical_constants['molar Planck constant'] = {'value': 3.9903126821e-10, 'precision': 0.0000000057e-10, 'units': 'J*s*mol**-1'}
physical_constants['molar Planck constant times c'] = {'value': 0.11962656472, 'precision': 0.00000000017, 'units': 'J*m*mol**-1'}
physical_constants['molar volume of ideal gas (273.15 K, 100 kPa)'] = {'value': 22.710981e-3, 'precision': 0.000040e-3, 'units': 'm**3*mol**-1'}
physical_constants['molar volume of ideal gas (273.15 K, 101.325 kPa)'] = {'value': 22.413996e-3, 'precision': 0.000039e-3, 'units': 'm**3*mol**-1'}
physical_constants['molar volume of silicon'] = {'value': 12.0588349e-6, 'precision': 0.0000011e-6, 'units': 'm**3*mol**-1'}
physical_constants['Mo x unit'] = {'value': 1.00209955e-13, 'precision': 0.00000053e-13, 'units': 'm'}
physical_constants['muon Compton wavelength'] = {'value': 11.73444104e-15, 'precision': 0.00000030e-15, 'units': 'm'}
physical_constants['muon Compton wavelength over 2 pi'] = {'value': 1.867594295e-15, 'precision': 0.000000047e-15, 'units': 'm'}
physical_constants['muon-electron mass ratio'] = {'value': 206.7682823, 'precision': 0.0000052, 'units': ''}
physical_constants['muon g factor'] = {'value': -2.0023318414, 'precision': 0.0000000012, 'units': ''}
physical_constants['muon magnetic moment'] = {'value': -4.49044786e-26, 'precision': 0.00000016e-26, 'units': 'J*T**-1'}
physical_constants['muon magnetic moment anomaly'] = {'value': 1.16592069e-3, 'precision': 0.00000060e-3, 'units': ''}
physical_constants['muon magnetic moment to Bohr magneton ratio'] = {'value': -4.84197049e-3, 'precision': 0.00000012e-3, 'units': ''}
physical_constants['muon magnetic moment to nuclear magneton ratio'] = {'value': -8.89059705, 'precision': 0.00000023, 'units': ''}
physical_constants['muon mass'] = {'value': 1.88353130e-28, 'precision': 0.00000011e-28, 'units': 'kg'}
physical_constants['muon mass energy equivalent'] = {'value': 1.692833510e-11, 'precision': 0.000000095e-11, 'units': 'J'}
physical_constants['muon mass energy equivalent in MeV'] = {'value': 105.6583668, 'precision': 0.0000038, 'units': 'MeV'}
physical_constants['muon mass in u'] = {'value': 0.1134289256, 'precision': 0.0000000029, 'units': 'u'}
physical_constants['muon molar mass'] = {'value': 0.1134289256e-3, 'precision': 0.0000000029e-3, 'units': 'kg*mol**-1'}
physical_constants['muon-neutron mass ratio'] = {'value': 0.1124545167, 'precision': 0.0000000029, 'units': ''}
physical_constants['muon-proton magnetic moment ratio'] = {'value': -3.183345137, 'precision': 0.000000085, 'units': ''}
physical_constants['muon-proton mass ratio'] = {'value': 0.1126095261, 'precision': 0.0000000029, 'units': ''}
physical_constants['muon-tau mass ratio'] = {'value': 5.94592e-2, 'precision': 0.00097e-2, 'units': ''}
physical_constants['natural unit of action'] = {'value': 1.054571628e-34, 'precision': 0.000000053e-34, 'units': 'J*s'}
physical_constants['natural unit of action in eV s'] = {'value': 6.58211899e-16, 'precision': 0.00000016e-16, 'units': 'eV*s'}
physical_constants['natural unit of energy'] = {'value': 8.18710438e-14, 'precision': 0.00000041e-14, 'units': 'J'}
physical_constants['natural unit of energy in MeV'] = {'value': 0.510998910, 'precision': 0.000000013, 'units': 'MeV'}
physical_constants['natural unit of length'] = {'value': 386.15926459e-15, 'precision': 0.00000053e-15, 'units': 'm'}
physical_constants['natural unit of mass'] = {'value': 9.10938215e-31, 'precision': 0.00000045e-31, 'units': 'kg'}
physical_constants['natural unit of momentum'] = {'value': 2.73092406e-22, 'precision': 0.00000014e-22, 'units': 'kg*m*s**-1'}
physical_constants['natural unit of momentum in MeV/c'] = {'value': 0.510998910, 'precision': 0.000000013, 'units': 'MeV/c'}
physical_constants['natural unit of time'] = {'value': 1.2880886570e-21, 'precision': 0.0000000018e-21, 'units': 's'}
physical_constants['natural unit of velocity'] = {'value': 299792458, 'precision': 0, 'units': 'm*s**-1'}
physical_constants['neutron Compton wavelength'] = {'value': 1.3195908951e-15, 'precision': 0.0000000020e-15, 'units': 'm'}
physical_constants['neutron Compton wavelength over 2 pi'] = {'value': 0.21001941382e-15, 'precision': 0.00000000031e-15, 'units': 'm'}
physical_constants['neutron-electron magnetic moment ratio'] = {'value': 1.04066882e-3, 'precision': 0.00000025e-3, 'units': ''}
physical_constants['neutron-electron mass ratio'] = {'value': 1838.6836605, 'precision': 0.0000011, 'units': ''}
physical_constants['neutron g factor'] = {'value': -3.82608545, 'precision': 0.00000090, 'units': ''}
physical_constants['neutron gyromagnetic ratio'] = {'value': 1.83247185e8, 'precision': 0.00000043e8, 'units': 's**-1*T**-1'}
physical_constants['neutron gyromagnetic ratio over 2 pi'] = {'value': 29.1646954, 'precision': 0.0000069, 'units': 'MHz*T**-1'}
physical_constants['neutron magnetic moment'] = {'value': -0.96623641e-26, 'precision': 0.00000023e-26, 'units': 'J*T**-1'}
physical_constants['neutron magnetic moment to Bohr magneton ratio'] = {'value': -1.04187563e-3, 'precision': 0.00000025e-3, 'units': ''}
physical_constants['neutron magnetic moment to nuclear magneton ratio'] = {'value': -1.91304273, 'precision': 0.00000045, 'units': ''}
physical_constants['neutron mass'] = {'value': 1.674927211e-27, 'precision': 0.000000084e-27, 'units': 'kg'}
physical_constants['neutron mass energy equivalent'] = {'value': 1.505349505e-10, 'precision': 0.000000075e-10, 'units': 'J'}
physical_constants['neutron mass energy equivalent in MeV'] = {'value': 939.565346, 'precision': 0.000023, 'units': 'MeV'}
physical_constants['neutron mass in u'] = {'value': 1.00866491597, 'precision': 0.00000000043, 'units': 'u'}
physical_constants['neutron molar mass'] = {'value': 1.00866491597e-3, 'precision': 0.00000000043e-3, 'units': 'kg*mol**-1'}
physical_constants['neutron-muon mass ratio'] = {'value': 8.89248409, 'precision': 0.00000023, 'units': ''}
physical_constants['neutron-proton magnetic moment ratio'] = {'value': -0.68497934, 'precision': 0.00000016, 'units': ''}
physical_constants['neutron-proton mass ratio'] = {'value': 1.00137841918, 'precision': 0.00000000046, 'units': ''}
physical_constants['neutron-tau mass ratio'] = {'value': 0.528740, 'precision': 0.000086, 'units': ''}
physical_constants['neutron to shielded proton magnetic moment ratio'] = {'value': -0.68499694, 'precision': 0.00000016, 'units': ''}
physical_constants['Newtonian constant of gravitation'] = {'value': 6.67428e-11, 'precision': 0.00067e-11, 'units': 'm**3*kg**-1*s**-2'}
physical_constants['Newtonian constant of gravitation over h-bar c'] = {'value': 6.70881e-39, 'precision': 0.00067e-39, 'units': '(GeV/c**2)**-2'}
physical_constants['nuclear magneton'] = {'value': 5.05078324e-27, 'precision': 0.00000013e-27, 'units': 'J*T**-1'}
physical_constants['nuclear magneton in eV/T'] = {'value': 3.1524512326e-8, 'precision': 0.0000000045e-8, 'units': 'eV*T**-1'}
physical_constants['nuclear magneton in inverse meters per tesla'] = {'value': 2.542623616e-2, 'precision': 0.000000064e-2, 'units': 'm**-1*T**-1'}
physical_constants['nuclear magneton in K/T'] = {'value': 3.6582637e-4, 'precision': 0.0000064e-4, 'units': 'K*T**-1'}
physical_constants['nuclear magneton in MHz/T'] = {'value': 7.62259384, 'precision': 0.00000019, 'units': 'MHz*T**-1'}
physical_constants['Planck constant'] = {'value': 6.62606896e-34, 'precision': 0.00000033e-34, 'units': 'J*s'}
physical_constants['Planck constant in eV s'] = {'value': 4.13566733e-15, 'precision': 0.00000010e-15, 'units': 'eV*s'}
physical_constants['Planck constant over 2 pi'] = {'value': 1.054571628e-34, 'precision': 0.000000053e-34, 'units': 'J*s'}
physical_constants['Planck constant over 2 pi in eV s'] = {'value': 6.58211899e-16, 'precision': 0.00000016e-16, 'units': 'eV*s'}
physical_constants['Planck constant over 2 pi times c in MeV fm'] = {'value': 197.3269631, 'precision': 0.0000049, 'units': 'MeV*fm'}
physical_constants['Planck length'] = {'value': 1.616252e-35, 'precision': 0.000081e-35, 'units': 'm'}
physical_constants['Planck mass'] = {'value': 2.17644e-8, 'precision': 0.00011e-8, 'units': 'kg'}
physical_constants['Planck mass energy equivalent in GeV'] = {'value': 1.220892e19, 'precision': 0.000061e19, 'units': 'GeV'}
physical_constants['Planck temperature'] = {'value': 1.416785e32, 'precision': 0.000071e32, 'units': 'K'}
physical_constants['Planck time'] = {'value': 5.39124e-44, 'precision': 0.00027e-44, 'units': 's'}
physical_constants['proton charge to mass quotient'] = {'value': 9.57883392e7, 'precision': 0.00000024e7, 'units': 'C*kg**-1'}
physical_constants['proton Compton wavelength'] = {'value': 1.3214098446e-15, 'precision': 0.0000000019e-15, 'units': 'm'}
physical_constants['proton Compton wavelength over 2 pi'] = {'value': 0.21030890861e-15, 'precision': 0.00000000030e-15, 'units': 'm'}
physical_constants['proton-electron mass ratio'] = {'value': 1836.15267247, 'precision': 0.00000080, 'units': ''}
physical_constants['proton g factor'] = {'value': 5.585694713, 'precision': 0.000000046, 'units': ''}
physical_constants['proton gyromagnetic ratio'] = {'value': 2.675222099e8, 'precision': 0.000000070e8, 'units': 's**-1*T**-1'}
physical_constants['proton gyromagnetic ratio over 2 pi'] = {'value': 42.5774821, 'precision': 0.0000011, 'units': 'MHz*T**-1'}
physical_constants['proton magnetic moment'] = {'value': 1.410606662e-26, 'precision': 0.000000037e-26, 'units': 'J*T**-1'}
physical_constants['proton magnetic moment to Bohr magneton ratio'] = {'value': 1.521032209e-3, 'precision': 0.000000012e-3, 'units': ''}
physical_constants['proton magnetic moment to nuclear magneton ratio'] = {'value': 2.792847356, 'precision': 0.000000023, 'units': ''}
physical_constants['proton magnetic shielding correction'] = {'value': 25.694e-6, 'precision': 0.014e-6, 'units': ''}
physical_constants['proton mass'] = {'value': 1.672621637e-27, 'precision': 0.000000083e-27, 'units': 'kg'}
physical_constants['proton mass energy equivalent'] = {'value': 1.503277359e-10, 'precision': 0.000000075e-10, 'units': 'J'}
physical_constants['proton mass energy equivalent in MeV'] = {'value': 938.272013, 'precision': 0.000023, 'units': 'MeV'}
physical_constants['proton mass in u'] = {'value': 1.00727646677, 'precision': 0.00000000010, 'units': 'u'}
physical_constants['proton molar mass'] = {'value': 1.00727646677e-3, 'precision': 0.00000000010e-3, 'units': 'kg*mol**-1'}
physical_constants['proton-muon mass ratio'] = {'value': 8.88024339, 'precision': 0.00000023, 'units': ''}
physical_constants['proton-neutron magnetic moment ratio'] = {'value': -1.45989806, 'precision': 0.00000034, 'units': ''}
physical_constants['proton-neutron mass ratio'] = {'value': 0.99862347824, 'precision': 0.00000000046, 'units': ''}
physical_constants['proton rms charge radius'] = {'value': 0.8768e-15, 'precision': 0.0069e-15, 'units': 'm'}
physical_constants['proton-tau mass ratio'] = {'value': 0.528012, 'precision': 0.000086, 'units': ''}
physical_constants['quantum of circulation'] = {'value': 3.6369475199e-4, 'precision': 0.0000000050e-4, 'units': 'm**2*s**-1'}
physical_constants['quantum of circulation times 2'] = {'value': 7.273895040e-4, 'precision': 0.000000010e-4, 'units': 'm**2*s**-1'}
physical_constants['Rydberg constant'] = {'value': 10973731.568527, 'precision': 0.000073, 'units': 'm**-1'}
physical_constants['Rydberg constant times c in Hz'] = {'value': 3.289841960361e15, 'precision': 0.000000000022e15, 'units': 'Hz'}
physical_constants['Rydberg constant times hc in eV'] = {'value': 13.60569193, 'precision': 0.00000034, 'units': 'eV'}
physical_constants['Rydberg constant times hc in J'] = {'value': 2.17987197e-18, 'precision': 0.00000011e-18, 'units': 'J'}
physical_constants['Sackur-Tetrode constant (1 K, 100 kPa)'] = {'value': -1.1517047, 'precision': 0.0000044, 'units': ''}
physical_constants['Sackur-Tetrode constant (1 K, 101.325 kPa)'] = {'value': -1.1648677, 'precision': 0.0000044, 'units': ''}
physical_constants['second radiation constant'] = {'value': 1.4387752e-2, 'precision': 0.0000025e-2, 'units': 'm*K'}
physical_constants['shielded helion gyromagnetic ratio'] = {'value': 2.037894730e8, 'precision': 0.000000056e8, 'units': 's**-1*T**-1'}
physical_constants['shielded helion gyromagnetic ratio over 2 pi'] = {'value': 32.43410198, 'precision': 0.00000090, 'units': 'MHz*T**-1'}
physical_constants['shielded helion magnetic moment'] = {'value': -1.074552982e-26, 'precision': 0.000000030e-26, 'units': 'J*T**-1'}
physical_constants['shielded helion magnetic moment to Bohr magneton ratio'] = {'value': -1.158671471e-3, 'precision': 0.000000014e-3, 'units': ''}
physical_constants['shielded helion magnetic moment to nuclear magneton ratio'] = {'value': -2.127497718, 'precision': 0.000000025, 'units': ''}
physical_constants['shielded helion to proton magnetic moment ratio'] = {'value': -0.761766558, 'precision': 0.000000011, 'units': ''}
physical_constants['shielded helion to shielded proton magnetic moment ratio'] = {'value': -0.7617861313, 'precision': 0.0000000033, 'units': ''}
physical_constants['shielded proton gyromagnetic ratio'] = {'value': 2.675153362e8, 'precision': 0.000000073e8, 'units': 's**-1*T**-1'}
physical_constants['shielded proton gyromagnetic ratio over 2 pi'] = {'value': 42.5763881, 'precision': 0.0000012, 'units': 'MHz*T**-1'}
physical_constants['shielded proton magnetic moment'] = {'value': 1.410570419e-26, 'precision': 0.000000038e-26, 'units': 'J*T**-1'}
physical_constants['shielded proton magnetic moment to Bohr magneton ratio'] = {'value': 1.520993128e-3, 'precision': 0.000000017e-3, 'units': ''}
physical_constants['shielded proton magnetic moment to nuclear magneton ratio'] = {'value': 2.792775598, 'precision': 0.000000030, 'units': ''}
physical_constants['speed of light in vacuum'] = {'value': 299792458, 'precision': 0, 'units': 'm*s**-1'}
physical_constants['standard acceleration of gravity'] = {'value': 9.80665, 'precision': 0, 'units': 'm*s**-2'}
physical_constants['standard atmosphere'] = {'value': 101325, 'precision': 0, 'units': 'Pa'}
physical_constants['Stefan-Boltzmann constant'] = {'value': 5.670400e-8, 'precision': 0.000040e-8, 'units': 'W*m**-2*K**-4'}
physical_constants['tau Compton wavelength'] = {'value': 0.69772e-15, 'precision': 0.00011e-15, 'units': 'm'}
physical_constants['tau Compton wavelength over 2 pi'] = {'value': 0.111046e-15, 'precision': 0.000018e-15, 'units': 'm'}
physical_constants['tau-electron mass ratio'] = {'value': 3477.48, 'precision': 0.57, 'units': ''}
physical_constants['tau mass'] = {'value': 3.16777e-27, 'precision': 0.00052e-27, 'units': 'kg'}
physical_constants['tau mass energy equivalent'] = {'value': 2.84705e-10, 'precision': 0.00046e-10, 'units': 'J'}
physical_constants['tau mass energy equivalent in MeV'] = {'value': 1776.99, 'precision': 0.29, 'units': 'MeV'}
physical_constants['tau mass in u'] = {'value': 1.90768, 'precision': 0.00031, 'units': 'u'}
physical_constants['tau molar mass'] = {'value': 1.90768e-3, 'precision': 0.00031e-3, 'units': 'kg*mol**-1'}
physical_constants['tau-muon mass ratio'] = {'value': 16.8183, 'precision': 0.0027, 'units': ''}
physical_constants['tau-neutron mass ratio'] = {'value': 1.89129, 'precision': 0.00031, 'units': ''}
physical_constants['tau-proton mass ratio'] = {'value': 1.89390, 'precision': 0.00031, 'units': ''}
physical_constants['Thomson cross section'] = {'value': 0.6652458558e-28, 'precision': 0.0000000027e-28, 'units': 'm**2'}
physical_constants['triton-electron magnetic moment ratio'] = {'value': -1.620514423e-3, 'precision': 0.000000021e-3, 'units': ''}
physical_constants['triton-electron mass ratio'] = {'value': 5496.9215269, 'precision': 0.0000051, 'units': ''}
physical_constants['triton g factor'] = {'value': 5.957924896, 'precision': 0.000000076, 'units': ''}
physical_constants['triton magnetic moment'] = {'value': 1.504609361e-26, 'precision': 0.000000042e-26, 'units': 'J*T**-1'}
physical_constants['triton magnetic moment to Bohr magneton ratio'] = {'value': 1.622393657e-3, 'precision': 0.000000021e-3, 'units': ''}
physical_constants['triton magnetic moment to nuclear magneton ratio'] = {'value': 2.978962448, 'precision': 0.000000038, 'units': ''}
physical_constants['triton mass'] = {'value': 5.00735588e-27, 'precision': 0.00000025e-27, 'units': 'kg'}
physical_constants['triton mass energy equivalent'] = {'value': 4.50038703e-10, 'precision': 0.00000022e-10, 'units': 'J'}
physical_constants['triton mass energy equivalent in MeV'] = {'value': 2808.920906, 'precision': 0.000070, 'units': 'MeV'}
physical_constants['triton mass in u'] = {'value': 3.0155007134, 'precision': 0.0000000025, 'units': 'u'}
physical_constants['triton molar mass'] = {'value': 3.0155007134e-3, 'precision': 0.0000000025e-3, 'units': 'kg*mol**-1'}
physical_constants['triton-neutron magnetic moment ratio'] = {'value': -1.55718553, 'precision': 0.00000037, 'units': ''}
physical_constants['triton-proton magnetic moment ratio'] = {'value': 1.066639908, 'precision': 0.000000010, 'units': ''}
physical_constants['triton-proton mass ratio'] = {'value': 2.9937170309, 'precision': 0.0000000025, 'units': ''}
physical_constants['unified atomic mass unit'] = {'value': 1.660538782e-27, 'precision': 0.000000083e-27, 'units': 'kg'}
physical_constants['von Klitzing constant'] = {'value': 25812.807557, 'precision': 0.000018, 'units': 'ohm'}
physical_constants['weak mixing angle'] = {'value': 0.22255, 'precision': 0.00056, 'units': ''}
physical_constants['Wien frequency displacement law constant'] = {'value': 5.878933e10, 'precision': 0.000010e10, 'units': 'Hz*K**-1'}
physical_constants['Wien wavelength displacement law constant'] = {'value': 2.8977685e-3, 'precision': 0.0000051e-3, 'units': 'm*K'}

########NEW FILE########
__FILENAME__ = _utils
from __future__ import absolute_import

from ._codata import physical_constants
from quantities.quantity import Quantity
from quantities.uncertainquantity import UncertainQuantity


def _cd(name):
    entry = physical_constants[name]
    if False: #entry['precision']:
        return UncertainQuantity(
            entry['value'], entry['units'], entry['precision']
        )
    else:
        return Quantity(entry['value'], entry['units'])

########NEW FILE########
__FILENAME__ = decorators
# -*- coding: utf-8 -*-
from __future__ import absolute_import

import inspect
import os
import re
import string
import sys
import warnings
from functools import partial, wraps


def memoize(f, cache={}):
    @wraps(f)
    def g(*args, **kwargs):
        key = (f, tuple(args), frozenset(kwargs.items()))
        if key not in cache:
            cache[key] = f(*args, **kwargs)
        return cache[key].copy()
    return g


class with_doc:

    """
    This decorator combines the docstrings of the provided and decorated objects
    to produce the final docstring for the decorated object.
    """

    def __init__(self, method, use_header=True):
        self.method = method
        if use_header:
            self.header = \
    """

    Notes
    -----
    """
        else:
            self.header = ''

    def __call__(self, new_method):
        new_doc = new_method.__doc__
        original_doc = self.method.__doc__
        header = self.header

        if original_doc and new_doc:
            new_method.__doc__ = """
    %s
    %s
    %s
        """ % (original_doc, header, new_doc)

        elif original_doc:
            new_method.__doc__ = original_doc

        return new_method

def quantitizer(base_function,
                handler_function = lambda *args, **kwargs: 1.0):
    """
    wraps a function so that it works properly with physical quantities
    (Quantities).
    arguments:
        base_function - the function to be wrapped
        handler_function - a function which takes the same arguments as the
            base_function  and returns a Quantity (or tuple of Quantities)
            which has (have) the units that the output of base_function should
            have.
        returns:
            a wrapped version of base_function that takes the same arguments
            and works with physical quantities. It will have almost the same
            __name__ and almost the same __doc__.
    """

    from .quantity import Quantity

    # define a function which will wrap the base function so that it works
    # with Quantities
    def wrapped_function(*args , **kwargs):

        # run the arguments through the handler function, this should
        # return a tuple of Quantities which have the correct units
        # for the output of the function we are wrapping
        handler_quantities= handler_function( *args, **kwargs)

        # now we need to turn Quantities into ndarrays so they behave
        # correctly
        #
        # first we simplify all units so that  addition and subtraction work
        # there may be another way to ensure this, but I do not have any good
        # ideas

        # in order to modify the args tuple, we have to turn it into a list
        args = list(args)

        #replace all the quantities in the argument list with ndarrays
        for i in range(len(args)):
            #test if the argument is a quantity
            if isinstance(args[i], Quantity):
                #convert the units to the base units
                args[i] = args[i].simplified()

                #view the array as an ndarray
                args[i] = args[i].magnitude

        #convert the list back to a tuple so it can be used as an output
        args = tuple (args)

        #repalce all the quantities in the keyword argument
        #dictionary with ndarrays
        for i in kwargs:
            #test if the argument is a quantity
            if isinstance(kwargs[i], Quantity):
                #convert the units to the base units
                kwargs[i] = kwargs[i].simplifed()

                #view the array as an ndarray
                kwargs[i] = kwargs[i].magnitude


        #get the result for the function
        result = base_function( *args, **kwargs)

        # since we have to modify the result, convert it to a list
        result = list(result)

        #iterate through the handler_quantities and get the correct
        # units


        length = min(   len(handler_quantities)   ,    len(result)   )

        for i in range(length):
            # if the output of the handler is a quantity make the
            # output of the wrapper function be a quantity with correct
            # units
            if isinstance(handler_quantities[i], Quantity):
                # the results should have simplified units since that's what
                # the inputs were (they were simplified earlier)
                # (reasons why this would not be true?)
                result[i] = Quantity(
                                result[i],
                                handler_quantities[i]
                                    .dimensionality.simplified()
                                    )
                #now convert the quantity to the appropriate units
                result[i] = result[i].rescale(
                                        handler_quantities[i].dimensionality)

        #need to convert the result back to a tuple
        result = tuple(result)
        return result

    # give the wrapped function a similar name to the base function
    wrapped_function.__name__ = base_function.__name__ + "_QWrap"
    # give the wrapped function a similar doc string to the base function's
    # doc string but add an annotation to the beginning
    wrapped_function.__doc__ = (
            "this function has been wrapped to work with Quantities\n"
            + base_function.__doc__)

    return wrapped_function

########NEW FILE########
__FILENAME__ = dimensionality
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

import sys
import operator

import numpy as np

from . import markup
from .registry import unit_registry
from .decorators import memoize

def assert_isinstance(obj, types):
    try:
        assert isinstance(obj, types)
    except AssertionError:
        raise TypeError(
            "arg %r must be of type %r, got %r" % (obj, types, type(obj))
        )


class Dimensionality(dict):

    """
    """

    @property
    def ndims(self):
        return sum(abs(i) for i in self.simplified.values())

    @property
    def simplified(self):
        if len(self):
            rq = 1*unit_registry['dimensionless']
            for u, d in self.items():
                rq = rq * u.simplified**d
            return rq.dimensionality
        else:
            return self

    @property
    def string(self):
        return markup.format_units(self)

    @property
    def unicode(self):
        return markup.format_units_unicode(self)
        
    @property
    def latex(self):
        return markup.format_units_latex(self)

    def __hash__(self):
        res = hash(unit_registry['dimensionless'])
        for key in sorted(self.keys(), key=operator.attrgetter('format_order')):
            val = self[key]
            if val < 0:
                # can you believe that hash(-1)==hash(-2)?
                val -= 1
            res ^= hash((key, val))
        return res

    def __add__(self, other):
        assert_isinstance(other, Dimensionality)
        try:
            assert self == other
        except AssertionError:
            raise ValueError(
                'can not add units of %s and %s'\
                %(str(self), str(other))
            )
        return self.copy()

    __radd__ = __add__

    def __iadd__(self, other):
        assert_isinstance(other, Dimensionality)
        try:
            assert self == other
        except AssertionError:
            raise ValueError(
                'can not add units of %s and %s'\
                %(str(self), str(other))
            )
        return self

    def __sub__(self, other):
        assert_isinstance(other, Dimensionality)
        try:
            assert self == other
        except AssertionError:
            raise ValueError(
                'can not subtract units of %s and %s'\
                %(str(self), str(other))
            )
        return self.copy()

    __rsub__ = __sub__

    def __isub__(self, other):
        assert_isinstance(other, Dimensionality)
        try:
            assert self == other
        except AssertionError:
            raise ValueError(
                'can not add units of %s and %s'\
                %(str(self), str(other))
            )
        return self

    def __mul__(self, other):
        assert_isinstance(other, Dimensionality)
        new = Dimensionality(self)
        for unit, power in other.items():
            try:
                new[unit] += power
                if new[unit] == 0:
                    new.pop(unit)
            except KeyError:
                new[unit] = power
        return new

    def __imul__(self, other):
        assert_isinstance(other, Dimensionality)
        for unit, power in other.items():
            try:
                self[unit] += power
                if self[unit] == 0:
                    self.pop(unit)
            except KeyError:
                self[unit] = power
        return self

    def __truediv__(self, other):
        assert_isinstance(other, Dimensionality)
        new = Dimensionality(self)
        for unit, power in other.items():
            try:
                new[unit] -= power
                if new[unit] == 0:
                    new.pop(unit)
            except KeyError:
                new[unit] = -power
        return new

    if sys.version_info[0] < 3:
        def __div__(self, other):
            assert_isinstance(other, Dimensionality)
            return self.__truediv__(other)

    def __itruediv__(self, other):
        assert_isinstance(other, Dimensionality)
        for unit, power in other.items():
            try:
                self[unit] -= power
                if self[unit] == 0:
                    self.pop(unit)
            except KeyError:
                self[unit] = -power
        return self

    if sys.version_info[0] < 3:
        def __idiv__(self, other):
            assert_isinstance(other, Dimensionality)
            return self.__itruediv__(other)

    def __pow__(self, other):
        try:
            assert np.isscalar(other)
        except AssertionError:
            raise TypeError('exponent must be a scalar, got %r' % other)
        if other == 0:
            return Dimensionality()
        new = Dimensionality(self)
        for i in new:
            new[i] *= other
        return new

    def __ipow__(self, other):
        try:
            assert np.isscalar(other)
        except AssertionError:
            raise TypeError('exponent must be a scalar, got %r' % other)
        if other == 0:
            self.clear()
            return self
        for i in self:
            self[i] *= other
        return self

    def __repr__(self):
        return 'Dimensionality({%s})' \
            % ', '.join(['%s: %s'% (u.name, e) for u, e in self.items()])

    def __str__(self):
        if markup.config.use_unicode:
            return self.unicode
        else:
            return self.string

    def __eq__(self, other):
        return hash(self) == hash(other)

    def __ne__(self, other):
        return hash(self) != hash(other)

    __neq__ = __ne__

    def __gt__(self, other):
        return self.ndims > other.ndims

    def __ge__(self, other):
        return self.ndims >= other.ndims

    def __lt__(self, other):
        return self.ndims < other.ndims

    def __le__(self, other):
        return self.ndims <= other.ndims

    def copy(self):
        return Dimensionality(self)


p_dict = {}

def _d_multiply(q1, q2, out=None):
    try:
        return q1._dimensionality * q2._dimensionality
    except AttributeError:
        try:
            return q1.dimensionality
        except:
            return q2.dimensionality
p_dict[np.multiply] = _d_multiply
p_dict[np.cross] = _d_multiply

def _d_divide(q1, q2, out=None):
    try:
        return q1._dimensionality / q2._dimensionality
    except AttributeError:
        try:
            return q1.dimensionality
        except:
            return q2.dimensionality**-1
p_dict[np.divide] = _d_divide
p_dict[np.true_divide] = _d_divide

def _d_check_uniform(q1, q2, out=None):
    try:
        assert q1._dimensionality == q2._dimensionality
        return q1.dimensionality
    except AssertionError:
        raise ValueError(
            'quantities must have identical units, got "%s" and "%s"' %
            (q1.units, q2.units)
        )
    except AttributeError:
        try:
            if hasattr(q1, 'dimensionality'):
                # q2 was not a quantity
                if not q1._dimensionality or not np.asarray(q2).any():
                    return q1.dimensionality
                else:
                    raise ValueError
            elif hasattr(q2, 'dimensionality'):
                # q1 was not a quantity
                if not q2._dimensionality or not np.asarray(q1).any():
                    return q2.dimensionality
                else:
                    raise ValueError
        except ValueError:
            raise ValueError(
                'quantities must have identical units, got "%s" and "%s"' %
                (q1.units, q2.units)
            )

p_dict[np.add] = _d_check_uniform
p_dict[np.subtract] = _d_check_uniform
p_dict[np.mod] = _d_check_uniform
p_dict[np.fmod] = _d_check_uniform
p_dict[np.remainder] = _d_check_uniform
p_dict[np.floor_divide] = _d_check_uniform
p_dict[np.arctan2] = _d_check_uniform
p_dict[np.hypot] = _d_check_uniform

def _d_power(q1, q2, out=None):
    if getattr(q2, 'dimensionality', None):
        raise ValueError("exponent must be dimensionless")
    try:
        q2 = np.array(q2)
        p = q2.min()
        if p != q2.max():
            raise ValueError('Quantities must be raised to a uniform power')
        return q1._dimensionality**p
    except AttributeError:
        return Dimensionality()
p_dict[np.power] = _d_power

def _d_square(q1, out=None):
    return q1._dimensionality**2
p_dict[np.square] = _d_square

def _d_reciprocal(q1, out=None):
    return q1._dimensionality**-1
p_dict[np.reciprocal] = _d_reciprocal

def _d_copy(q1, out=None):
    return q1.dimensionality
p_dict[np.fabs] = _d_copy
p_dict[np.absolute] = _d_copy
p_dict[np.conjugate] = _d_copy
p_dict[np.negative] = _d_copy
p_dict[np.ones_like] = _d_copy
p_dict[np.rint] = _d_copy
p_dict[np.floor] = _d_copy
p_dict[np.fix] = _d_copy
p_dict[np.ceil] = _d_copy

def _d_sqrt(q1, out=None):
    return q1._dimensionality**0.5
p_dict[np.sqrt] = _d_sqrt

def _d_radians(q1, out=None):
    try:
        assert q1.units == unit_registry['degree']
    except AssertionError:
        raise ValueError(
            'expected units of degrees, got "%s"' % q1._dimensionality
        )
    return unit_registry['radian'].dimensionality
p_dict[np.radians] = _d_radians

def _d_degrees(q1, out=None):
    try:
        assert q1.units == unit_registry['radian']
    except AssertionError:
        raise ValueError(
            'expected units of radians, got "%s"' % q1._dimensionality
        )
    return unit_registry['degree'].dimensionality
p_dict[np.degrees] = _d_degrees

def _d_dimensionless(q1, out=None):
    if getattr(q1, 'dimensionality', None):
        raise ValueError("quantity must be dimensionless")
    return Dimensionality()
p_dict[np.log] = _d_dimensionless
p_dict[np.log10] = _d_dimensionless
p_dict[np.log2] = _d_dimensionless
p_dict[np.log1p] = _d_dimensionless
p_dict[np.exp] = _d_dimensionless
p_dict[np.expm1] = _d_dimensionless
p_dict[np.logaddexp] = _d_dimensionless
p_dict[np.logaddexp2] = _d_dimensionless

def _d_trig(q1, out=None):
    try:
        assert q1.units == unit_registry['radian']
    except AssertionError:
        raise ValueError(
            'expected units of radians, got "%s"' % q1._dimensionality
        )
    return Dimensionality()
p_dict[np.sin] = _d_trig
p_dict[np.sinh] = _d_trig
p_dict[np.cos] = _d_trig
p_dict[np.cosh] = _d_trig
p_dict[np.tan] = _d_trig
p_dict[np.tanh] = _d_trig

def _d_arctrig(q1, out=None):
    if getattr(q1, 'dimensionality', None):
        raise ValueError("quantity must be dimensionless")
    return unit_registry['radian'].dimensionality
p_dict[np.arcsin] = _d_arctrig
p_dict[np.arcsinh] = _d_arctrig
p_dict[np.arccos] = _d_arctrig
p_dict[np.arccosh] = _d_arctrig
p_dict[np.arctan] = _d_arctrig
p_dict[np.arctanh] = _d_arctrig

########NEW FILE########
__FILENAME__ = markup
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import, with_statement

import copy
import operator
import re
import threading


class _Config(object):

    @property
    def lock(self):
        return self._lock

    @property
    def use_unicode(self):
        with self.lock:
            return copy.copy(self._use_unicode)
    @use_unicode.setter
    def use_unicode(self, val):
        self._use_unicode = bool(val)

    def __init__(self):
        self._lock = threading.RLock()
        self._use_unicode = False

config = _Config()

superscripts = ['⁰', '¹', '²', '³', '⁴', '⁵', '⁶', '⁷', '⁸', '⁹']

def superscript(val):
    # TODO: use a regexp:
    items = re.split(r'\*{2}([\d]+)(?!\.)', val)
    ret = []
    while items:
        try:
            s = items.pop(0)
            e = items.pop(0)
            ret.append(s+''.join(superscripts[int(i)] for i in e))
        except IndexError:
            ret.append(s)
    return ''.join(ret)

def format_units(udict):
    '''
    create a string representation of the units contained in a dimensionality
    '''
    num = []
    den = []
    keys = [k for k, o in
        sorted(
            [(k, k.format_order) for k in udict],
            key=operator.itemgetter(1)
        )
    ]
    for key in keys:
        d = udict[key]
        if config.use_unicode:
            u = key.u_symbol
        else:
            u = key.symbol
        if d>0:
            if d != 1:
                u = u + ('**%s'%d).rstrip('0').rstrip('.')
            num.append(u)
        elif d<0:
            d = -d
            if d != 1:
                u = u + ('**%s'%d).rstrip('0').rstrip('.')
            den.append(u)
    res = '*'.join(num)
    if len(den):
        if not res: res = '1'
        fmt = '(%s)' if len(den) > 1 else '%s'
        res = res + '/' + fmt%('*'.join(den))
    if not res: res = 'dimensionless'
    return res

def format_units_unicode(udict):
    res = format_units(udict)
    res = superscript(res)
    res = res.replace('**', '^').replace('*','·')

    return res


def format_units_latex(udict,font='mathrm',mult=r'\cdot',paren=False):
    '''
    Replace the units string provided with an equivalent latex string.
    
    Division (a/b) will be replaced by \frac{a}{b}.
    
    Exponentiation (m**2) will be replaced with superscripts (m^{2})
    
    The latex is set  with the font argument, and the default is the normal, 
    non-italicized font mathrm.  Other useful options include 'mathnormal', 
    'mathit', 'mathsf', and 'mathtt'.
    
    Multiplication (*) are replaced with the symbol specified by the mult argument.
    By default this is the latex \cdot symbol.  Other useful
    options may be '' or '*'.
    
    If paren=True, encapsulate the string in '\left(' and '\right)'
    
    The result of format_units_latex is encapsulated in $.  This allows the result
    to be used directly in Latex in normal text mode, or in Matplotlib text via the
    MathText feature.
    
    Restrictions:
    This routine will not put CompoundUnits into a fractional form. 
    '''
    res = format_units(udict)
    if res.startswith('(') and res.endswith(')'):
        # Compound Unit
        compound = True
    else:
        # Not a compound unit
        compound = False
        # Replace division (num/den) with \frac{num}{den}
        res = re.sub(r'(?P<num>.+)/(?P<den>.+)',r'\\frac{\g<num>}{\g<den>}',res)
    # Replace exponentiation (**exp) with ^{exp}
    res = re.sub(r'\*{2,2}(?P<exp>\d+)',r'^{\g<exp>}',res)
    # Remove multiplication signs
    res = re.sub(r'\*','{'+mult+'}',res)
    if paren and not compound:
        res = r'\left(%s\right)' % res
    res = r'$\%s{%s}$' % (font,res)
    return res

########NEW FILE########
__FILENAME__ = quantity
"""
"""
from __future__ import absolute_import

import copy
from functools import wraps
import sys

import numpy as np

from . import markup
from .dimensionality import Dimensionality, p_dict
from .registry import unit_registry
from .decorators import with_doc

if sys.version.startswith('3'):
    unicode = str

def validate_unit_quantity(value):
    try:
        assert isinstance(value, Quantity)
        assert value.shape in ((), (1, ))
        assert value.magnitude == 1
    except AssertionError:
        raise ValueError(
                'units must be a scalar Quantity with unit magnitude, got %s'\
                %value
            )
    return value

def validate_dimensionality(value):
    if isinstance(value, (str, unicode)):
        try:
            return unit_registry[value].dimensionality
        except (KeyError, UnicodeDecodeError):
            return unit_registry[str(value)].dimensionality
    elif isinstance(value, Quantity):
        validate_unit_quantity(value)
        return value.dimensionality
    elif isinstance(value, Dimensionality):
        return value.copy()
    else:
        raise TypeError(
            'units must be a quantity, string, or dimensionality, got %s'\
            %type(value)
        )

def get_conversion_factor(from_u, to_u):
    validate_unit_quantity(from_u)
    validate_unit_quantity(to_u)
    from_u = from_u._reference
    to_u = to_u._reference
    assert from_u.dimensionality == to_u.dimensionality
    return from_u.magnitude / to_u.magnitude

def scale_other_units(f):
    @wraps(f)
    def g(self, other, *args):
        other = np.asanyarray(other)
        if not isinstance(other, Quantity):
            other = other.view(type=Quantity)
        if other._dimensionality != self._dimensionality:
            other = other.rescale(self.units)
        return f(self, other, *args)
    return g

def protected_multiplication(f):
    @wraps(f)
    def g(self, other, *args):
        if getattr(other, 'dimensionality', None):
            try:
                assert not isinstance(self.base, Quantity)
            except AssertionError:
                raise ValueError('can not modify units of a view of a Quantity')
        return f(self, other, *args)
    return g

def check_uniform(f):
    @wraps(f)
    def g(self, other, *args):
        if getattr(other, 'dimensionality', None):
            raise ValueError("exponent must be dimensionless")
        other = np.asarray(other)
        try:
            assert other.min() == other.max()
        except AssertionError:
            raise ValueError('Quantities must be raised to a uniform power')
        return f(self, other, *args)
    return g

def protected_power(f):
    @wraps(f)
    def g(self, other, *args):
        if other != 1:
            try:
                assert not isinstance(self.base, Quantity)
            except AssertionError:
                raise ValueError('can not modify units of a view of a Quantity')
        return f(self, other, *args)
    return g

def wrap_comparison(f):
    @wraps(f)
    def g(self, other):
        if isinstance(other, Quantity):
            if other._dimensionality != self._dimensionality:
                other = other.rescale(self._dimensionality)
            other = other.magnitude
        return f(self, other)
    return g


class Quantity(np.ndarray):

    # TODO: what is an appropriate value?
    __array_priority__ = 21

    def __new__(cls, data, units='', dtype=None, copy=True):
        if isinstance(data, Quantity):
            if units:
                data = data.rescale(units)
            if isinstance(data, unit_registry['UnitQuantity']):
                return 1*data
            return np.array(data, dtype=dtype, copy=copy, subok=True).view(cls)

        ret = np.array(data, dtype=dtype, copy=copy).view(cls)
        ret._dimensionality.update(validate_dimensionality(units))
        return ret

    @property
    def dimensionality(self):
        return self._dimensionality.copy()

    @property
    def _reference(self):
        """The reference quantity used to perform conversions"""
        rq = 1*unit_registry['dimensionless']
        for u, d in self.dimensionality.items():
            rq = rq * u._reference**d
        return rq * self.magnitude

    @property
    def magnitude(self):
        return self.view(type=np.ndarray)

    @property
    def simplified(self):
        rq = 1*unit_registry['dimensionless']
        for u, d in self.dimensionality.items():
            rq = rq * u.simplified**d
        return rq * self.magnitude

    @property
    def units(self):
        return Quantity(1.0, (self.dimensionality))
    @units.setter
    def units(self, units):
        try:
            assert not isinstance(self.base, Quantity)
        except AssertionError:
            raise ValueError('can not modify units of a view of a Quantity')
        try:
            assert self.flags.writeable
        except AssertionError:
            raise ValueError('array is not writeable')
        to_dims = validate_dimensionality(units)
        if self._dimensionality == to_dims:
            return
        to_u = Quantity(1.0, to_dims)
        from_u = Quantity(1.0, self._dimensionality)
        try:
            cf = get_conversion_factor(from_u, to_u)
        except AssertionError:
            raise ValueError(
                'Unable to convert between units of "%s" and "%s"'
                %(from_u._dimensionality, to_u._dimensionality)
            )
        mag = self.magnitude
        mag *= cf
        self._dimensionality = to_u.dimensionality

    def rescale(self, units):
        """
        Return a copy of the quantity converted to the specified units
        """
        to_dims = validate_dimensionality(units)
        if self.dimensionality == to_dims:
            return self.astype(self.dtype)
        to_u = Quantity(1.0, to_dims)
        from_u = Quantity(1.0, self.dimensionality)
        try:
            cf = get_conversion_factor(from_u, to_u)
        except AssertionError:
            raise ValueError(
                'Unable to convert between units of "%s" and "%s"'
                %(from_u._dimensionality, to_u._dimensionality)
            )
        return Quantity(cf*self.magnitude, to_u)

    @with_doc(np.ndarray.astype)
    def astype(self, dtype=None):
        '''Scalars are returned as scalar Quantity arrays.'''
        ret = super(Quantity, self.view(Quantity)).astype(dtype)
        # scalar quantities get converted to plain numbers, so we fix it
        # might be related to numpy ticket # 826
        if not isinstance(ret, type(self)):
            if self.__array_priority__ >= Quantity.__array_priority__:
                ret = type(self)(ret, self._dimensionality)
            else:
                ret = Quantity(ret, self._dimensionality)

        return ret

    def __array_finalize__(self, obj):
        self._dimensionality = getattr(obj, 'dimensionality', Dimensionality())

    def __array_prepare__(self, obj, context=None):
        if self.__array_priority__ >= Quantity.__array_priority__:
            res = obj if isinstance(obj, type(self)) else obj.view(type(self))
        else:
            # don't want a UnitQuantity
            res = obj.view(Quantity)
        if context is None:
            return res

        uf, objs, huh = context
        if uf.__name__.startswith('is'):
            return obj
        #print self, obj, res, uf, objs
        try:
            res._dimensionality = p_dict[uf](*objs)
        except KeyError:
            raise ValueError(
                """ufunc %r not supported by quantities
                please file a bug report at https://github.com/python-quantities
                """ % uf
                )
        return res

    def __array_wrap__(self, obj, context=None):
        if not isinstance(obj, Quantity):
            # backwards compatibility with numpy-1.3
            obj = self.__array_prepare__(obj, context)
        return obj

    @with_doc(np.ndarray.__add__)
    @scale_other_units
    def __add__(self, other):
        return super(Quantity, self).__add__(other)

    @with_doc(np.ndarray.__radd__)
    @scale_other_units
    def __radd__(self, other):
        return np.add(other, self)
        return super(Quantity, self).__radd__(other)

    @with_doc(np.ndarray.__iadd__)
    @scale_other_units
    def __iadd__(self, other):
        return super(Quantity, self).__iadd__(other)

    @with_doc(np.ndarray.__sub__)
    @scale_other_units
    def __sub__(self, other):
        return super(Quantity, self).__sub__(other)

    @with_doc(np.ndarray.__rsub__)
    @scale_other_units
    def __rsub__(self, other):
        return np.subtract(other, self)
        return super(Quantity, self).__rsub__(other)

    @with_doc(np.ndarray.__isub__)
    @scale_other_units
    def __isub__(self, other):
        return super(Quantity, self).__isub__(other)

    @with_doc(np.ndarray.__mod__)
    @scale_other_units
    def __mod__(self, other):
        return super(Quantity, self).__mod__(other)

    @with_doc(np.ndarray.__imod__)
    @scale_other_units
    def __imod__(self, other):
        return super(Quantity, self).__imod__(other)

    @with_doc(np.ndarray.__imul__)
    @protected_multiplication
    def __imul__(self, other):
        return super(Quantity, self).__imul__(other)

    @with_doc(np.ndarray.__rmul__)
    def __rmul__(self, other):
        return np.multiply(other, self)
        return super(Quantity, self).__rmul__(other)

    @with_doc(np.ndarray.__itruediv__)
    @protected_multiplication
    def __itruediv__(self, other):
        return super(Quantity, self).__itruediv__(other)

    @with_doc(np.ndarray.__rtruediv__)
    def __rtruediv__(self, other):
        return np.true_divide(other, self)
        return super(Quantity, self).__rtruediv__(other)

    if sys.version_info[0] < 3:
        @with_doc(np.ndarray.__idiv__)
        @protected_multiplication
        def __idiv__(self, other):
            return super(Quantity, self).__itruediv__(other)

        @with_doc(np.ndarray.__rdiv__)
        def __rdiv__(self, other):
            return np.divide(other, self)

    @with_doc(np.ndarray.__pow__)
    @check_uniform
    def __pow__(self, other):
        return super(Quantity, self).__pow__(other)

    @with_doc(np.ndarray.__ipow__)
    @check_uniform
    @protected_power
    def __ipow__(self, other):
        return super(Quantity, self).__ipow__(other)

    def __round__(self, decimals=0):
        return np.around(self, decimals)

    @with_doc(np.ndarray.__repr__)
    def __repr__(self):
        return '%s * %s'%(
            repr(self.magnitude), self.dimensionality.string
        )

    @with_doc(np.ndarray.__str__)
    def __str__(self):
        if markup.config.use_unicode:
            dims = self.dimensionality.unicode
        else:
            dims = self.dimensionality.string
        return '%s %s'%(str(self.magnitude), dims)

    @with_doc(np.ndarray.__getitem__)
    def __getitem__(self, key):
        ret = super(Quantity, self).__getitem__(key)
        if isinstance(ret, Quantity):
            return ret
        else:
            return Quantity(ret, self._dimensionality)

    @with_doc(np.ndarray.__setitem__)
    def __setitem__(self, key, value):
        if not isinstance(value, Quantity):
            value = Quantity(value)
        if self._dimensionality != value._dimensionality:
            value = value.rescale(self._dimensionality)
        self.magnitude[key] = value

    @with_doc(np.ndarray.__lt__)
    @wrap_comparison
    def __lt__(self, other):
        return self.magnitude < other

    @with_doc(np.ndarray.__le__)
    @wrap_comparison
    def __le__(self, other):
        return self.magnitude <= other

    @with_doc(np.ndarray.__eq__)
    def __eq__(self, other):
        if isinstance(other, Quantity):
            try:
                other = other.rescale(self._dimensionality).magnitude
            except ValueError:
                return np.zeros(self.shape, '?')
        return self.magnitude == other

    @with_doc(np.ndarray.__ne__)
    def __ne__(self, other):
        if isinstance(other, Quantity):
            try:
                other = other.rescale(self._dimensionality).magnitude
            except ValueError:
                return np.ones(self.shape, '?')
        return self.magnitude != other

    @with_doc(np.ndarray.__ge__)
    @wrap_comparison
    def __ge__(self, other):
        return self.magnitude >= other

    @with_doc(np.ndarray.__gt__)
    @wrap_comparison
    def __gt__(self, other):
        return self.magnitude > other

    #I don't think this implementation is particularly efficient,
    #perhaps there is something better
    @with_doc(np.ndarray.tolist)
    def tolist(self):
        #first get a dummy array from the ndarray method
        work_list = self.magnitude.tolist()
        #now go through and replace all numbers with the appropriate Quantity
        self._tolist(work_list)
        return work_list

    def _tolist(self, work_list):
        for i in range(len(work_list)):
            #if it's a list then iterate through that list
            if isinstance(work_list[i], list):
                self._tolist(work_list[i])
            else:
                #if it's a number then replace it
                # with the appropriate quantity
                work_list[i] = Quantity(work_list[i], self.dimensionality)

    #need to implement other Array conversion methods:
    # item, itemset, tofile, dump, byteswap

    @with_doc(np.ndarray.sum)
    def sum(self, axis=None, dtype=None, out=None):
        return Quantity(
            self.magnitude.sum(axis, dtype, out),
            self.dimensionality,
            copy=False
        )

    @with_doc(np.ndarray.fill)
    def fill(self, value):
        self.magnitude.fill(value)
        try:
            self._dimensionality = value.dimensionality
        except AttributeError:
            pass

    @with_doc(np.ndarray.put)
    def put(self, indicies, values, mode='raise'):
        """
        performs the equivalent of ndarray.put() but enforces units
        values - must be an Quantity with the same units as self
        """
        if not isinstance(values, Quantity):
            values = Quantity(values)
        if values._dimensionality != self._dimensionality:
            values = values.rescale(self.units)
        self.magnitude.put(indicies, values, mode)

    # choose does not function correctly, and it is not clear
    # how it would function, so for now it will not be implemented

    @with_doc(np.ndarray.argsort)
    def argsort(self, axis=-1, kind='quick', order=None):
        return self.magnitude.argsort(axis, kind, order)

    @with_doc(np.ndarray.searchsorted)
    def searchsorted(self,values, side='left'):
        if not isinstance (values, Quantity):
            values = Quantity(values, copy=False)

        if values._dimensionality != self._dimensionality:
            raise ValueError("values does not have the same units as self")

        return self.magnitude.searchsorted(values.magnitude, side)

    @with_doc(np.ndarray.nonzero)
    def nonzero(self):
        return self.magnitude.nonzero()

    @with_doc(np.ndarray.max)
    def max(self, axis=None, out=None):
        return Quantity(
            self.magnitude.max(),
            self.dimensionality,
            copy=False
        )

    @with_doc(np.ndarray.min)
    def min(self, axis=None, out=None):
        return Quantity(
            self.magnitude.min(),
            self.dimensionality,
            copy=False
        )

    @with_doc(np.ndarray.argmin)
    def argmin(self,axis=None, out=None):
        return self.magnitude.argmin()

    @with_doc(np.ndarray.ptp)
    def ptp(self, axis=None, out=None):
        return Quantity(
            self.magnitude.ptp(),
            self.dimensionality,
            copy=False
        )

    @with_doc(np.ndarray.clip)
    def clip(self, min=None, max=None, out=None):
        if min is None and max is None:
            raise ValueError("at least one of min or max must be set")
        else:
            if min is None: min = Quantity(-np.Inf, self._dimensionality)
            if max is None: max = Quantity(np.Inf, self._dimensionality)

        if self.dimensionality and not \
                (isinstance(min, Quantity) and isinstance(max, Quantity)):
            raise ValueError(
                "both min and max must be Quantities with compatible units"
            )

        clipped = self.magnitude.clip(
            min.rescale(self._dimensionality).magnitude,
            max.rescale(self._dimensionality).magnitude,
            out
        )
        return Quantity(clipped, self.dimensionality, copy=False)

    @with_doc(np.ndarray.round)
    def round(self, decimals=0, out=None):
        return Quantity(
            self.magnitude.round(decimals, out),
            self.dimensionality,
            copy=False
        )

    @with_doc(np.ndarray.trace)
    def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None):
        return Quantity(
            self.magnitude.trace(offset, axis1, axis2, dtype, out),
            self.dimensionality,
            copy=False
        )

    @with_doc(np.ndarray.squeeze)
    def squeeze(self, axis=None):
        return Quantity(
            self.magnitude.squeeze(axis),
            self.dimensionality,
            copy=False
        )

    @with_doc(np.ndarray.mean)
    def mean(self, axis=None, dtype=None, out=None):
        return Quantity(
            self.magnitude.mean(axis, dtype, out),
            self.dimensionality,
            copy=False)

    @with_doc(np.ndarray.var)
    def var(self, axis=None, dtype=None, out=None, ddof=0):
        return Quantity(
            self.magnitude.var(axis, dtype, out, ddof),
            self._dimensionality**2,
            copy=False
        )

    @with_doc(np.ndarray.std)
    def std(self, axis=None, dtype=None, out=None, ddof=0):
        return Quantity(
            self.magnitude.std(axis, dtype, out, ddof),
            self._dimensionality,
            copy=False
        )

    @with_doc(np.ndarray.prod)
    def prod(self, axis=None, dtype=None, out=None):
        if axis == None:
            power = self.size
        else:
            power = self.shape[axis]

        return Quantity(
            self.magnitude.prod(axis, dtype, out),
            self._dimensionality**power,
            copy=False
        )

    @with_doc(np.ndarray.cumsum)
    def cumsum(self, axis=None, dtype=None, out=None):
        return super(Quantity, self).cumsum(axis, dtype, out)*self.units

    @with_doc(np.ndarray.cumprod)
    def cumprod(self, axis=None, dtype=None, out=None):
        if self._dimensionality:
            # different array elements would have different dimensionality
            raise ValueError(
                "Quantity must be dimensionless, try using simplified"
            )
        else:
            return super(Quantity, self).cumprod(axis, dtype, out)

    # list of unsupported functions: [choose]

    def __getstate__(self):
        """
        Return the internal state of the quantity, for pickling
        purposes.

        """
        cf = 'CF'[self.flags.fnc]
        state = (1,
                 self.shape,
                 self.dtype,
                 self.flags.fnc,
                 self.tostring(cf),
                 self._dimensionality,
                 )
        return state

    def __setstate__(self, state):
        (ver, shp, typ, isf, raw, units) = state
        np.ndarray.__setstate__(self, (shp, typ, isf, raw))
        self._dimensionality = units

    def __reduce__(self):
        """
        Return a tuple for pickling a Quantity.
        """
        return (_reconstruct_quantity,
                (self.__class__, np.ndarray, (0, ), 'b', ),
                self.__getstate__())


def _reconstruct_quantity(subtype, baseclass, baseshape, basetype,):
    """Internal function that builds a new MaskedArray from the
    information stored in a pickle.

    """
    _data = np.ndarray.__new__(baseclass, baseshape, basetype)
    return subtype.__new__(subtype, _data, dtype=basetype,)

########NEW FILE########
__FILENAME__ = registry
# -*- coding: utf-8 -*-
"""
"""

import copy
import re


class UnitRegistry:

    class __Registry:

        __shared_state = {}

        def __init__(self):
            self.__dict__ = self.__shared_state
            self.__context = {}

        def __getitem__(self, string):
            try:
                return eval(string, self.__context)
            except NameError:
                # could return self['UnitQuantity'](string)
                raise LookupError(
                    'Unable to parse units: "%s"'%string
                )

        def __setitem__(self, string, val):
            assert isinstance(string, str)
            try:
                assert string not in self.__context
            except AssertionError:
                if val == self.__context[string]:
                    return
                raise KeyError(
                    '%s has already been registered for %s' 
                    % (string, self.__context[string])
                )
            self.__context[string] = val

    __regex = re.compile(r'([A-Za-z])\.([A-Za-z])')
    __registry = __Registry()

    def __getattr__(self, attr):
        return getattr(self.__registry, attr)

    def __setitem__(self, label, value):
        self.__registry.__setitem__(label, value)

    def __getitem__(self, label):
        """Parses a string description of a unit e.g., 'g/cc'"""

        label = self.__regex.sub(
            r"\g<1>*\g<2>", label.replace('^', '**').replace('·', '*'))

        # make sure we can parse the label ....
        if label == '': label = 'dimensionless'
        if label == "%": label = "percent"
        if label.lower() == "in": label = "inch"

        return self.__registry[label]

unit_registry = UnitRegistry()

########NEW FILE########
__FILENAME__ = common
import sys
if sys.version.startswith('2.6') or sys.version.startswith('3.1'):
    import unittest2 as unittest
else:
    import unittest

import numpy as np

from ..quantity import Quantity
from ..units import set_default_units

class TestCase(unittest.TestCase):

    def setUp(self):
        set_default_units('SI')

    def tearDown(self):
        set_default_units('SI')

    def assertQuantityEqual(self, q1, q2, msg=None, delta=None):
        """
        Make sure q1 and q2 are the same quantities to within the given
        precision.
        """
        delta = 1e-5 if delta is None else delta
        msg = '' if msg is None else ' (%s)' % msg

        q1 = Quantity(q1)
        q2 = Quantity(q2)
        if q1.shape != q2.shape:
            raise self.failureException(
                "Shape mismatch (%s vs %s)%s" % (q1.shape, q2.shape, msg)
                )
        if not np.all(np.abs(q1.magnitude - q2.magnitude) < delta):
            raise self.failureException(
                "Magnitudes differ by more than %g (%s vs %s)%s"
                % (delta, q1.magnitude, q2.magnitude, msg)
                )

        d1 = getattr(q1, '_dimensionality', None)
        d2 = getattr(q2, '_dimensionality', None)
        if (d1 or d2) and not (d1 == d2):
            raise self.failureException(
                "Dimensionalities are not equal (%s vs %s)%s" % (d1, d2, msg)
                )

########NEW FILE########
__FILENAME__ = test_arithmetic
# -*- coding: utf-8 -*-

import operator as op
from functools import partial
import sys

import numpy as np
from .. import units as pq
from ..quantity import Quantity
from .common import TestCase


if sys.version.startswith('3'):
    long = int


def rand(dtype, *args):
    if np.dtype(dtype).kind == 'c':
        return dtype(
            10*np.random.rand(*args)+10j*np.random.rand(*args),
        )
    else:
        return dtype(10*np.random.rand(*args))

def check(f, *args, **kwargs):
    new = partial(f, *args)
    new.__name__ = f.__name__
    new.__module__ = f.__module__

    try:
        new = kwargs['fails_if'](new)
    except KeyError:
        pass
    desc = [f.__name__]
    for arg in args:
        try:
            desc.append(arg[0].dtype.name)
        except AttributeError:
            desc.append(arg[0].__class__.__name__)
        except (IndexError, TypeError):
            try:
                desc.append(arg.dtype.name)
            except AttributeError:
                pass
        c = arg.__class__.__name__
        if c != desc[-1]:
            desc.append(c)

    new.description = '_'.join(desc)
    return (new, )


class iter_dtypes(object):

    def __init__(self):
        self._i = 1
        self._typeDict = np.typeDict.copy()
        self._typeDict[17] = int
        self._typeDict[18] = long
        self._typeDict[19] = float
        self._typeDict[20] = complex

    def __iter__(self):
        return self

    def __next__(self):
        if self._i > 20:
            raise StopIteration

        i = self._i
        self._i += 1
        return self._typeDict[i]

    def next(self):
        return self.__next__()

def get_dtypes():
    return list(iter_dtypes())


class iter_types(object):

    def __init__(self, dtype):
        self._index = -1
        self._dtype = dtype

    def __iter__(self):
        return self

    def __next__(self):
        self._index += 1
        if self._index > 2:
            raise StopIteration
        if self._index > 0 and self._dtype in (int, long, float, complex):
            raise StopIteration
        if self._index == 0:
            return rand(self._dtype)
        if self._index == 1:
            return rand(self._dtype, 5).tolist()
        if self._index == 2:
            return rand(self._dtype, 5)

    def next(self):
        return self.__next__()


class TestDTypes(TestCase):

    def check_mul(self, m1, m2):
        self.assertQuantityEqual(pq.m*m2, Quantity(m2, 'm'))

        q1 = Quantity(m1, 'm')
        q2 = Quantity(m2, 's')
        a1 = np.asarray(m1)
        a2 = np.asarray(m2)
        self.assertQuantityEqual(q1*m2, Quantity(a1*a2, 'm'))
        self.assertQuantityEqual(q1*q2, Quantity(a1*a2, 'm*s'))

    def check_rmul(self, m1, m2):
        self.assertQuantityEqual(m1*pq.m, Quantity(m1, 'm'))

        q2 = Quantity(m2, 's')
        a1 = np.asarray(m1)
        a2 = np.asarray(m2)
        self.assertQuantityEqual(m1*q2, Quantity(a1*a2, 's'))

    def test_mul(self):
        dtypes = get_dtypes()
        for i in get_dtypes()[::3]:
            for j in get_dtypes()[::3]:
                for x in iter_types(i):
                    for y in iter_types(j):
                        self.check_mul(x, y)
                        self.check_rmul(x, y)
            dtypes.pop(0)

    def test_mixed_addition(self):
        self.assertQuantityEqual(1*pq.ft + 1*pq.m, 4.280839895 * pq.ft)
        self.assertQuantityEqual(1*pq.ft + pq.m, 4.280839895 * pq.ft)
        self.assertQuantityEqual(pq.ft + 1*pq.m, 4.280839895 * pq.ft)
        self.assertQuantityEqual(pq.ft + pq.m, 4.280839895 * pq.ft)
        self.assertQuantityEqual(op.iadd(1*pq.ft, 1*pq.m), 4.280839895 * pq.ft)
        self.assertRaises(ValueError, lambda: 10*pq.J + 3*pq.m)
        self.assertRaises(ValueError, lambda: op.iadd(10*pq.J, 3*pq.m))

    def test_mod(self):
        self.assertQuantityEqual(10*pq.m % (3*pq.m), 1*pq.m)
        self.assertQuantityEqual(
            10*pq.m % (3*pq.m).rescale('ft'),
            10*pq.m % (3*pq.m)
        )
        self.assertRaises(ValueError, lambda: 10*pq.J % (3*pq.m))

    def test_imod(self):
        x = 10*pq.m
        x %= 3*pq.m
        self.assertQuantityEqual(x, 1*pq.m)

        x = 10*pq.m
        x %= (3*pq.m).rescale('ft')
        self.assertQuantityEqual(x, 10*pq.m % (3*pq.m))

        self.assertRaises(ValueError, lambda: op.imod(10*pq.J, 3*pq.m))

    def test_fmod(self):
        self.assertQuantityEqual(np.fmod(10*pq.m, (3*pq.m)), 1*pq.m)
        self.assertRaises(ValueError, np.fmod, 10*pq.J, 3*pq.m)

    def test_remainder(self):
        self.assertQuantityEqual(np.remainder(10*pq.m, (3*pq.m)), 1*pq.m)
        self.assertRaises(ValueError, np.remainder, 10*pq.J, 3*pq.m)

    def test_negative(self):
        self.assertQuantityEqual(
            -pq.m,
            Quantity(-1, 'm')
        )
        self.assertQuantityEqual(
            -Quantity(5, 'm'),
            Quantity(-5, 'm')
        )
        self.assertQuantityEqual(
            -Quantity(-5.0, 'm'),
            Quantity(5.0, 'm')
        )

    def test_addition(self):
        self.assertQuantityEqual(
            pq.eV + pq.eV,
            2*pq.eV
        )
        self.assertQuantityEqual(
            pq.eV + -pq.eV,
            0*pq.eV
        )
        self.assertQuantityEqual(
            pq.eV + 5*pq.eV,
            6*pq.eV
        )
        self.assertQuantityEqual(
            5*pq.eV + pq.eV,
            6*pq.eV
        )
        self.assertQuantityEqual(
            5*pq.eV + 6*pq.eV,
            11*pq.eV
        )
        self.assertQuantityEqual(
            pq.rem + [1, 2, 3]*pq.rem,
            [2, 3, 4]*pq.rem
        )
        self.assertQuantityEqual(
            [1, 2, 3]*pq.rem + pq.rem,
            [2, 3, 4]*pq.rem
        )
        self.assertQuantityEqual(
            5*pq.rem + [1, 2, 3]*pq.rem,
            [6, 7, 8]*pq.rem
        )
        self.assertQuantityEqual(
            [1, 2, 3]*pq.rem + 5*pq.rem,
            [6, 7, 8]*pq.rem
        )
        self.assertQuantityEqual(
            [1, 2, 3]*pq.hp + [1, 2, 3]*pq.hp,
            [2, 4, 6]*pq.hp
        )

        self.assertRaises(ValueError, op.add, pq.kPa, pq.lb)
        self.assertRaises(ValueError, op.add, pq.kPa, 10)
        self.assertRaises(ValueError, op.add, 1*pq.kPa, 5*pq.lb)
        self.assertRaises(ValueError, op.add, 1*pq.kPa, pq.lb)
        self.assertRaises(ValueError, op.add, 1*pq.kPa, 5)
        self.assertRaises(ValueError, op.add, [1, 2, 3]*pq.kPa, [1, 2, 3]*pq.lb)
        self.assertRaises(ValueError, op.add, [1, 2, 3]*pq.kPa, 5*pq.lb)
        self.assertRaises(ValueError, op.add, [1, 2, 3]*pq.kPa, pq.lb)
        self.assertRaises(ValueError, op.add, [1, 2, 3]*pq.kPa, 5)

    def test_in_place_addition(self):
        x = 1*pq.m
        x += pq.m
        self.assertQuantityEqual(x, pq.m+pq.m)

        x = 1*pq.m
        x += -pq.m
        self.assertQuantityEqual(x, 0*pq.m)

        x = [1, 2, 3, 4]*pq.m
        x += pq.m
        self.assertQuantityEqual(x, [2, 3, 4, 5]*pq.m)

        x = [1, 2, 3, 4]*pq.m
        x += x
        self.assertQuantityEqual(x, [2, 4, 6, 8]*pq.m)

        x = [1, 2, 3, 4]*pq.m
        x[:2] += pq.m
        self.assertQuantityEqual(x, [2, 3, 3, 4]*pq.m)

        x = [1, 2, 3, 4]*pq.m
        x[:2] += -pq.m
        self.assertQuantityEqual(x, [0, 1, 3, 4]*pq.m)

        x = [1, 2, 3, 4]*pq.m
        x[:2] += [1, 2]*pq.m
        self.assertQuantityEqual(x, [2, 4, 3, 4]*pq.m)

        x = [1, 2, 3, 4]*pq.m
        x[::2] += [1, 2]*pq.m
        self.assertQuantityEqual(x, [2, 2, 5, 4]*pq.m)

        self.assertRaises(ValueError, op.iadd, 1*pq.m, 1)
        self.assertRaises(ValueError, op.iadd, 1*pq.m, pq.J)
        self.assertRaises(ValueError, op.iadd, 1*pq.m, 5*pq.J)
        self.assertRaises(ValueError, op.iadd, [1, 2, 3]*pq.m, 1)
        self.assertRaises(ValueError, op.iadd, [1, 2, 3]*pq.m, pq.J)
        self.assertRaises(ValueError, op.iadd, [1, 2, 3]*pq.m, 5*pq.J)

    def test_subtraction(self):
        self.assertQuantityEqual(
            pq.eV - pq.eV,
            0*pq.eV
        )
        self.assertQuantityEqual(
            5*pq.eV - pq.eV,
            4*pq.eV
        )
        self.assertQuantityEqual(
            pq.eV - 4*pq.eV,
            -3*pq.eV
        )
        self.assertQuantityEqual(
            pq.rem - [1, 2, 3]*pq.rem,
            [0, -1, -2]*pq.rem
        )
        self.assertQuantityEqual(
            [1, 2, 3]*pq.rem - pq.rem,
            [0, 1, 2]*pq.rem
        )
        self.assertQuantityEqual(
            5*pq.rem - [1, 2, 3]*pq.rem,
            [4, 3, 2]*pq.rem
        )
        self.assertQuantityEqual(
            [1, 2, 3]*pq.rem - 5*pq.rem,
            [-4, -3, -2]*pq.rem
        )
        self.assertQuantityEqual(
            [3, 3, 3]*pq.hp - [1, 2, 3]*pq.hp,
            [2, 1, 0]*pq.hp
        )

        self.assertRaises(ValueError, op.sub, pq.kPa, pq.lb)
        self.assertRaises(ValueError, op.sub, pq.kPa, 10)
        self.assertRaises(ValueError, op.sub, 1*pq.kPa, 5*pq.lb)
        self.assertRaises(ValueError, op.sub, 1*pq.kPa, pq.lb)
        self.assertRaises(ValueError, op.sub, 1*pq.kPa, 5)
        self.assertRaises(ValueError, op.sub, [1, 2, 3]*pq.kPa, [1, 2, 3]*pq.lb)
        self.assertRaises(ValueError, op.sub, [1, 2, 3]*pq.kPa, 5*pq.lb)
        self.assertRaises(ValueError, op.sub, [1, 2, 3]*pq.kPa, pq.lb)
        self.assertRaises(ValueError, op.sub, [1, 2, 3]*pq.kPa, 5)

    def test_in_place_subtraction(self):
        x = 1*pq.m
        x -= pq.m
        self.assertQuantityEqual(x, 0*pq.m)

        x = 1*pq.m
        x -= -pq.m
        self.assertQuantityEqual(x, 2*pq.m)

        x = [1, 2, 3, 4]*pq.m
        x -= pq.m
        self.assertQuantityEqual(x, [0, 1, 2, 3]*pq.m)

        x = [1, 2, 3, 4]*pq.m
        x -= [1, 1, 1, 1]*pq.m
        self.assertQuantityEqual(x, [0, 1, 2, 3]*pq.m)

        x = [1, 2, 3, 4]*pq.m
        x[:2] -= pq.m
        self.assertQuantityEqual(x, [0, 1, 3, 4]*pq.m)

        x = [1, 2, 3, 4]*pq.m
        x[:2] -= -pq.m
        self.assertQuantityEqual(x, [2, 3, 3, 4]*pq.m)

        x = [1, 2, 3, 4]*pq.m
        x[:2] -= [1, 2]*pq.m
        self.assertQuantityEqual(x, [0, 0, 3, 4]*pq.m)

        x = [1, 2, 3, 4]*pq.m
        x[::2] -= [1, 2]*pq.m
        self.assertQuantityEqual(x, [0, 2, 1, 4]*pq.m)

        self.assertRaises(ValueError, op.isub, 1*pq.m, 1)
        self.assertRaises(ValueError, op.isub, 1*pq.m, pq.J)
        self.assertRaises(ValueError, op.isub, 1*pq.m, 5*pq.J)
        self.assertRaises(ValueError, op.isub, [1, 2, 3]*pq.m, 1)
        self.assertRaises(ValueError, op.isub, [1, 2, 3]*pq.m, pq.J)
        self.assertRaises(ValueError, op.isub, [1, 2, 3]*pq.m, 5*pq.J)

    def test_powering(self):
        # test raising a quantity to a power
        self.assertQuantityEqual((5.5 * pq.cm)**5, (5.5**5) * (pq.cm**5))

        # must also work with compound units
        self.assertQuantityEqual((5.5 * pq.J)**5, (5.5**5) * (pq.J**5))

        # does powering work with arrays?
        self.assertQuantityEqual(
            (np.array([1, 2, 3, 4, 5]) * pq.kg)**3,
            np.array([1, 8, 27, 64, 125]) * pq.kg**3
        )

        def q_pow_r(q1, q2):
            return q1 ** q2

        self.assertRaises(ValueError, q_pow_r, 10.0 * pq.m, 10 * pq.J)
        self.assertRaises(ValueError, q_pow_r, 10.0 * pq.m, np.array([1, 2, 3]))

        self.assertQuantityEqual( (10 * pq.J) ** (2 * pq.J/pq.J) , 100 * pq.J**2 )

        # test rpow here
        self.assertRaises(ValueError, q_pow_r, 10.0, 10 * pq.J)

        self.assertQuantityEqual(10**(2*pq.J/pq.J), 100)

        def ipow(q1, q2):
            q1 -= q2
        self.assertRaises(ValueError, ipow, 1*pq.m, [1, 2])

########NEW FILE########
__FILENAME__ = test_comparison
# -*- coding: utf-8 -*-

import operator as op

from .. import units as pq
from .common import TestCase


class TestComparison(TestCase):

    def test_scalar_equality(self):
        self.assertEqual(pq.J == pq.J, [True])
        self.assertEqual(1*pq.J == pq.J, [True])
        self.assertEqual(str(1*pq.J) == '1.0 J', True)
        self.assertEqual(pq.J == pq.kg*pq.m**2/pq.s**2, [True])

        self.assertEqual(pq.J == pq.erg, [False])
        self.assertEqual(2*pq.J == pq.J, [False])
        self.assertEqual(pq.J == 2*pq.kg*pq.m**2/pq.s**2, [False])

        self.assertEqual(pq.J == pq.kg, [False])

    def test_scalar_inequality(self):
        self.assertEqual(pq.J != pq.erg, [True])
        self.assertEqual(2*pq.J != pq.J, [True])
        self.assertEqual(str(2*pq.J) != str(pq.J), True)
        self.assertEqual(pq.J != 2*pq.kg*pq.m**2/pq.s**2, [True])

        self.assertEqual(pq.J != pq.J, [False])
        self.assertEqual(1*pq.J != pq.J, [False])
        self.assertEqual(pq.J != 1*pq.kg*pq.m**2/pq.s**2, [False])

    def test_scalar_comparison(self):
        self.assertEqual(2*pq.J > pq.J, [True])
        self.assertEqual(2*pq.J > 1*pq.J, [True])
        self.assertEqual(1*pq.J >= pq.J, [True])
        self.assertEqual(1*pq.J >= 1*pq.J, [True])
        self.assertEqual(2*pq.J >= pq.J, [True])
        self.assertEqual(2*pq.J >= 1*pq.J, [True])

        self.assertEqual(0.5*pq.J < pq.J, [True])
        self.assertEqual(0.5*pq.J < 1*pq.J, [True])
        self.assertEqual(0.5*pq.J <= pq.J, [True])
        self.assertEqual(0.5*pq.J <= 1*pq.J, [True])
        self.assertEqual(1.0*pq.J <= pq.J, [True])
        self.assertEqual(1.0*pq.J <= 1*pq.J, [True])

        self.assertEqual(2*pq.J < pq.J, [False])
        self.assertEqual(2*pq.J < 1*pq.J, [False])
        self.assertEqual(2*pq.J <= pq.J, [False])
        self.assertEqual(2*pq.J <= 1*pq.J, [False])

        self.assertEqual(0.5*pq.J > pq.J, [False])
        self.assertEqual(0.5*pq.J > 1*pq.J, [False])
        self.assertEqual(0.5*pq.J >= pq.J, [False])
        self.assertEqual(0.5*pq.J >= 1*pq.J, [False])

    def test_array_equality(self):
        self.assertQuantityEqual(
            [1, 2, 3, 4]*pq.J == [1, 22, 3, 44]*pq.J,
            [1, 0, 1, 0]
        )
        self.assertQuantityEqual(
            [1, 2, 3, 4]*pq.J == [1, 22, 3, 44]*pq.kg,
            [0, 0, 0, 0]
        )
        self.assertQuantityEqual(
            [1, 2, 3, 4]*pq.J == [1, 22, 3, 44],
            [1, 0, 1, 0]
        )

    def test_array_inequality(self):
        self.assertQuantityEqual(
            [1, 2, 3, 4]*pq.J != [1, 22, 3, 44]*pq.J,
            [0, 1, 0, 1]
        )
        self.assertQuantityEqual(
            [1, 2, 3, 4]*pq.J != [1, 22, 3, 44]*pq.kg,
            [1, 1, 1, 1]
        )
        self.assertQuantityEqual(
            [1, 2, 3, 4]*pq.J != [1, 22, 3, 44],
            [0, 1, 0, 1]
        )

    def test_quantity_less_than(self):
        self.assertQuantityEqual(
            [1, 2, 33]*pq.J < [1, 22, 3]*pq.J,
            [0, 1, 0]
        )
        self.assertQuantityEqual(
            [50, 100, 150]*pq.cm < [1, 1, 1]*pq.m,
            [1, 0, 0]
        )
        self.assertQuantityEqual(
            [1, 2, 33]*pq.J < [1, 22, 3],
            [0, 1, 0]
        )
        self.assertRaises(
            ValueError,
            op.lt,
            [1, 2, 33]*pq.J,
            [1, 22, 3]*pq.kg,
        )

    def test_quantity_less_than_or_equal(self):
        self.assertQuantityEqual(
            [1, 2, 33]*pq.J <= [1, 22, 3]*pq.J,
            [1, 1, 0]
        )
        self.assertQuantityEqual(
            [50, 100, 150]*pq.cm <= [1, 1, 1]*pq.m,
            [1, 1, 0]
        )
        self.assertQuantityEqual(
            [1, 2, 33]*pq.J <= [1, 22, 3],
            [1, 1, 0]
        )
        self.assertRaises(
            ValueError,
            op.le,
            [1, 2, 33]*pq.J,
            [1, 22, 3]*pq.kg,
        )

    def test_quantity_greater_than_or_equal(self):
        self.assertQuantityEqual(
            [1, 2, 33]*pq.J >= [1, 22, 3]*pq.J,
            [1, 0, 1]
        )
        self.assertQuantityEqual(
            [50, 100, 150]*pq.cm >= [1, 1, 1]*pq.m,
            [0, 1, 1]
        )
        self.assertQuantityEqual(
            [1, 2, 33]*pq.J >= [1, 22, 3],
            [1, 0, 1]
        )
        self.assertRaises(
            ValueError,
            op.ge,
            [1, 2, 33]*pq.J,
            [1, 22, 3]*pq.kg,
        )

    def test_quantity_greater_than(self):
        self.assertQuantityEqual(
            [1, 2, 33]*pq.J > [1, 22, 3]*pq.J,
            [0, 0, 1]
        )
        self.assertQuantityEqual(
            [50, 100, 150]*pq.cm > [1, 1, 1]*pq.m,
            [0, 0, 1]
        )
        self.assertQuantityEqual(
            [1, 2, 33]*pq.J > [1, 22, 3],
            [0, 0, 1]
        )
        self.assertRaises(
            ValueError,
            op.gt,
            [1, 2, 33]*pq.J,
            [1, 22, 3]*pq.kg,
        )

########NEW FILE########
__FILENAME__ = test_constants
# -*- coding: utf-8 -*-

from .. import units as pq
from .. import constants as pc
from .common import TestCase


########NEW FILE########
__FILENAME__ = test_conversion
# -*- coding: utf-8 -*-

from .. import units as pq
from .common import TestCase


class TestConversion(TestCase):

    def test_inplace_conversion(self):
        for u in ('ft', 'feet', pq.ft):
            q = 10*pq.m
            q.units = u
            self.assertQuantityEqual(q, 32.80839895 * pq.ft)

    def test_rescale(self):
        for u in ('ft', 'feet', pq.ft):
            self.assertQuantityEqual((10*pq.m).rescale(u), 32.80839895 * pq.ft)

    def test_compound_reduction(self):
        pc_per_cc = pq.CompoundUnit("pc/cm**3")
        temp = pc_per_cc * pq.CompoundUnit('m/m**3')

        self.assertQuantityEqual(
            temp.simplified,
            3.08568025e+22 / pq.m**4,
            delta=1e17
            )

        self.assertQuantityEqual(
            temp.rescale('pc**-4'),
            2.79740021556e+88 / pq.pc**4,
            delta=1e83
            )


class TestDefaultUnits(TestCase):

    def test_default_length(self):
        pq.set_default_units(length='mm')
        self.assertQuantityEqual(pq.m.simplified, 1000*pq.mm)

        pq.set_default_units(length='m')
        self.assertQuantityEqual(pq.m.simplified, pq.m)
        self.assertQuantityEqual(pq.mm.simplified, 0.001*pq.m)

    def test_default_system(self):
        pq.set_default_units('cgs')
        self.assertQuantityEqual(pq.kg.simplified, 1000*pq.g)
        self.assertQuantityEqual(pq.m.simplified, 100*pq.cm)

        pq.set_default_units('SI')
        self.assertQuantityEqual(pq.g.simplified, 0.001*pq.kg)
        self.assertQuantityEqual(pq.mm.simplified, 0.001*pq.m)

        pq.set_default_units('cgs', length='mm')
        self.assertQuantityEqual(pq.kg.simplified, 1000*pq.g)
        self.assertQuantityEqual(pq.m.simplified, 1000*pq.mm)

########NEW FILE########
__FILENAME__ = test_dimensionality
# -*- coding: utf-8 -*-

import operator as op

from .. import units as pq
from ..dimensionality import Dimensionality
from .common import TestCase

meter = Dimensionality({pq.m: 1})
meter_str = 'm'
centimeter = Dimensionality({pq.cm: 1})
centimeter_str = 'cm'
joule = Dimensionality({pq.kg: 1, pq.m: 2, pq.s: -2})
joule_str = 'kg*m**2/s**2'
joule_uni = 'kg·m²/s²'
joule_tex = r'$\mathrm{\frac{kg{\cdot}m^{2}}{s^{2}}}$'
Joule = Dimensionality({pq.J: 1})
Joule_str = 'J'

class TestDimensionality(TestCase):

    def test_dimensionality_str(self):
        self.assertEqual(str(meter), meter_str)
        self.assertEqual(joule.string, joule_str)
        self.assertEqual(joule.unicode, joule_uni)
        self.assertEqual(joule.latex, joule_tex)
        self.assertEqual(Joule.string, 'J')

    def test_equality(self):
        self.assertTrue(meter == meter)
        self.assertTrue(joule == joule)
        self.assertFalse(meter == Joule)
        self.assertFalse(joule == Joule)

    def test_inequality(self):
        self.assertFalse(meter != meter)
        self.assertFalse(joule != joule)
        self.assertTrue(meter != Joule)
        self.assertTrue(joule != Joule)

    def test_copy(self):
        temp = meter.copy()
        self.assertTrue(temp is not meter)
        self.assertTrue(isinstance(temp, Dimensionality))
        self.assertTrue(temp == meter)
        temp[pq.m] += 1
        self.assertFalse(temp == meter)

    def test_addition(self):
        self.assertTrue(meter + meter is not meter)
        self.assertRaises(ValueError, op.add, meter, joule)
        self.assertRaises(ValueError, op.add, Joule, joule)
        self.assertRaises(TypeError, op.add, Joule, 0)
        self.assertRaises(TypeError, op.add, 0, joule)

    def test_inplace_addition(self):
        temp = meter.copy()
        temp += meter
        self.assertEqual(temp, meter)
        self.assertRaises(ValueError, op.iadd, meter, joule)
        self.assertRaises(ValueError, op.iadd, Joule, joule)
        self.assertRaises(TypeError, op.iadd, Joule, 0)
        self.assertRaises(TypeError, op.iadd, 0, joule)

    def test_subtraction(self):
        self.assertTrue(meter - meter is not meter)
        self.assertRaises(ValueError, op.sub, meter, joule)
        self.assertRaises(ValueError, op.sub, Joule, joule)
        self.assertRaises(TypeError, op.sub, Joule, 0)
        self.assertRaises(TypeError, op.sub, 0, joule)

    def test_inplace_subtraction(self):
        temp = meter.copy()
        temp -= meter
        self.assertEqual(temp, meter)
        self.assertRaises(ValueError, op.isub, meter, joule)
        self.assertRaises(ValueError, op.isub, Joule, joule)
        self.assertRaises(TypeError, op.isub, Joule, 0)
        self.assertRaises(TypeError, op.isub, 0, joule)

    def test_multiplication(self):
        self.assertEqual(meter*meter, Dimensionality({pq.m: 2}))
        self.assertEqual(meter*centimeter, Dimensionality({pq.m: 1, pq.cm: 1}))
        self.assertEqual(joule*meter, Dimensionality({pq.kg: 1, pq.m: 3, pq.s: -2}))
        self.assertRaises(TypeError, op.mul, Joule, 0)
        self.assertRaises(TypeError, op.mul, 0, joule)

    def test_inplace_multiplication(self):
        temp = meter.copy()
        temp *= meter
        self.assertEqual(temp, meter*meter)
        temp *= centimeter
        self.assertEqual(temp, meter*meter*centimeter)
        temp *= centimeter**-1
        self.assertEqual(temp, meter*meter)
        self.assertRaises(TypeError, op.imul, Joule, 0)
        self.assertRaises(TypeError, op.imul, 0, joule)

    def test_division(self):
        self.assertEqual(meter/meter, Dimensionality())
        self.assertEqual(joule/meter, Dimensionality({pq.kg: 1, pq.m: 1, pq.s: -2}))
        self.assertRaises(TypeError, op.truediv, Joule, 0)
        self.assertRaises(TypeError, op.truediv, 0, joule)

    def test_inplace_division(self):
        temp = meter.copy()
        temp /= meter
        self.assertEqual(temp, meter/meter)
        temp /= centimeter
        self.assertEqual(temp, meter/meter/centimeter)
        temp /= centimeter**-1
        self.assertEqual(temp, meter/meter)
        self.assertRaises(TypeError, op.itruediv, Joule, 0)
        self.assertRaises(TypeError, op.itruediv, 0, joule)

    def test_power(self):
        self.assertEqual(meter**2, meter*meter)
        self.assertEqual(meter**0, Dimensionality())
        self.assertEqual(joule**2, Dimensionality({pq.kg: 2, pq.m: 4, pq.s: -4}))
        self.assertRaises(TypeError, op.pow, Joule, joule)
        self.assertRaises(TypeError, op.pow, joule, Joule)
        self.assertEqual(meter**-1 == meter**-2, False)

    def test_inplace_power(self):
        temp = meter.copy()
        temp **= 2
        self.assertEqual(temp, meter**2)
        temp = joule.copy()
        temp **= 2
        self.assertEqual(temp, joule**2)
        temp = meter.copy()
        temp **= 0
        self.assertEqual(temp, Dimensionality())
        self.assertRaises(TypeError, op.ipow, Joule, joule)
        self.assertRaises(TypeError, op.ipow, joule, Joule)

    def test_simplification(self):
        self.assertEqual(Joule.simplified.string, 'kg*m**2/s**2')
        self.assertEqual(Joule.simplified, joule)


    def test_gt(self):
        self.assertTrue(joule > meter)
        self.assertTrue(Joule > meter)
        self.assertFalse(meter > joule)
        self.assertFalse(meter > Joule)
        self.assertFalse(joule > joule)
        self.assertFalse(joule > Joule)

    def test_ge(self):
        self.assertTrue(joule >= meter)
        self.assertTrue(Joule >= meter)
        self.assertFalse(meter >= joule)
        self.assertFalse(meter >= Joule)
        self.assertTrue(joule >= joule)
        self.assertTrue(joule >= Joule)

    def test_lt(self):
        self.assertTrue(meter < joule)
        self.assertTrue(meter < Joule)
        self.assertFalse(joule < meter)
        self.assertFalse(Joule < meter)
        self.assertFalse(joule < joule)
        self.assertFalse(Joule < joule)

    def test_le(self):
        self.assertTrue(meter <= joule)
        self.assertTrue(meter <= Joule)
        self.assertFalse(joule <= meter)
        self.assertFalse(Joule <= meter)
        self.assertTrue(joule <= joule)
        self.assertTrue(joule <= Joule)

########NEW FILE########
__FILENAME__ = test_methods
# -*- coding: utf-8 -*-

from .. import units as pq
from .common import TestCase


class TestQuantityMethods(TestCase):

    def setUp(self):
        self.q = [[1, 2], [3, 4]] * pq.m

    def test_tolist(self):
        self.assertEqual(self.q.tolist(), [[1*pq.m, 2*pq.m], [3*pq.m, 4*pq.m]])

    def test_sum(self):
        self.assertQuantityEqual(self.q.sum(), 10*pq.m)
        self.assertQuantityEqual(self.q.sum(0), [4, 6]*pq.m)
        self.assertQuantityEqual(self.q.sum(1), [3, 7]*pq.m)

    def test_fill(self):
        self.q.fill(6 * pq.ft)
        self.assertQuantityEqual(self.q, [[6, 6], [6, 6]] * pq.ft)
        self.q.fill(5)
        self.assertQuantityEqual(self.q, [[5, 5], [5, 5]] * pq.ft)

    def test_reshape(self):
        self.assertQuantityEqual(self.q.reshape([1,4]), [[1, 2, 3, 4]] * pq.m)

    def test_transpose(self):
        self.assertQuantityEqual(self.q.transpose(), [[1, 3], [2, 4]] * pq.m)

    def test_flatten(self):
        self.assertQuantityEqual(self.q.flatten(), [1, 2, 3, 4] * pq.m)

    def test_ravel(self):
        self.assertQuantityEqual(self.q.ravel(), [1, 2, 3, 4] * pq.m)

    def test_squeeze(self):
        self.assertQuantityEqual(
            self.q.reshape([1,4]).squeeze(),
            [1, 2, 3, 4] * pq.m
            )

    def test_take(self):
        self.assertQuantityEqual(self.q.take([0,1,2,3]), self.q.flatten())

    def test_put(self):
        q = self.q.flatten()
        q.put([0,2], [10,20]*pq.m)
        self.assertQuantityEqual(q, [10, 2, 20, 4]*pq.m)

        q = self.q.flatten()
        q.put([0, 2], [1, 2]*pq.mm)
        self.assertQuantityEqual(q, [0.001, 2, 0.002, 4]*pq.m)

        q = self.q.flatten()/pq.mm
        q.put([0, 2], [1, 2])
        self.assertQuantityEqual(q.simplified, [1, 2000, 2, 4000])
        self.assertQuantityEqual(q, [0.001, 2, 0.002, 4]*pq.m/pq.mm)

        q = self.q.flatten()
        self.assertRaises(ValueError, q.put, [0, 2], [4, 6] * pq.J)
        self.assertRaises(ValueError, q.put, [0, 2], [4, 6])

    def test_repeat(self):
        self.assertQuantityEqual(self.q.repeat(2), [1,1,2,2,3,3,4,4]*pq.m)

    def test_sort(self):
        q = [4, 5, 2, 3, 1, 6] * pq.m
        q.sort()
        self.assertQuantityEqual(q, [1, 2, 3, 4, 5, 6] * pq.m)

    def test_argsort(self):
        q = [1, 4, 5, 6, 2, 9] * pq.MeV
        self.assertQuantityEqual(q.argsort(), [0, 4, 1, 2, 3, 5])

    def test_diagonal(self):
        q = [[1, 2, 3], [1, 2, 3], [1, 2, 3]] * pq.m
        self.assertQuantityEqual(q.diagonal(offset=1), [2, 3] * pq.m)

    def test_compress(self):
        self.assertQuantityEqual(
            self.q.compress([False, True], axis=0),
            [[3, 4]] * pq.m
            )
        self.assertQuantityEqual(
            self.q.compress([False, True], axis=1),
            [[2], [4]] * pq.m
            )

    def test_searchsorted(self):
        self.assertQuantityEqual(
            self.q.flatten().searchsorted([1.5, 2.5] * pq.m),
            [1, 2]
            )

        self.assertRaises(ValueError, self.q.flatten().searchsorted, [1.5, 2.5])

    def test_nonzero(self):
        q = [1, 0, 5, 6, 0, 9] * pq.m
        self.assertQuantityEqual(q.nonzero()[0], [0, 2, 3, 5])

    def test_max(self):
        self.assertQuantityEqual(self.q.max(), 4*pq.m)

    def test_argmax(self):
        self.assertEqual(self.q.argmax(), 3)

    def test_min(self):
        self.assertEqual(self.q.min(), 1 * pq.m)

    def test_argmin(self):
        self.assertEqual(self.q.argmin(), 0)

    def test_ptp(self):
        self.assertQuantityEqual(self.q.ptp(), 3 * pq.m)

    def test_clip(self):
        self.assertQuantityEqual(
            self.q.copy().clip(max=2*pq.m),
            [[1, 2], [2, 2]] * pq.m
        )
        self.assertQuantityEqual(
            self.q.copy().clip(min=3*pq.m),
            [[3, 3], [3, 4]] * pq.m
        )
        self.assertQuantityEqual(
            self.q.copy().clip(min=2*pq.m, max=3*pq.m),
            [[2, 2], [3, 3]] * pq.m
        )
        self.assertRaises(ValueError, self.q.clip, pq.J)
        self.assertRaises(ValueError, self.q.clip, 1)

    def test_round(self):
        q = [1, 1.33, 5.67, 22] * pq.m
        self.assertQuantityEqual(q.round(0), [1, 1, 6, 22] * pq.m)
        self.assertQuantityEqual(q.round(-1), [0, 0, 10, 20] * pq.m)
        self.assertQuantityEqual(q.round(1), [1, 1.3, 5.7, 22] * pq.m)

    def test_trace(self):
        self.assertQuantityEqual(self.q.trace(), (1+4) * pq.m)

    def test_cumsum(self):
        self.assertQuantityEqual(self.q.cumsum(), [1, 3, 6, 10] * pq.m)

    def test_mean(self):
        self.assertQuantityEqual(self.q.mean(), 2.5 * pq.m)

    def test_var(self):
        self.assertQuantityEqual(self.q.var(), 1.25*pq.m**2)

    def test_std(self):
        self.assertQuantityEqual(self.q.std(), 1.11803*pq.m, delta=1e-5)

    def test_prod(self):
        self.assertQuantityEqual(self.q.prod(), 24 * pq.m**4)

    def test_cumprod(self):
        self.assertRaises(ValueError, self.q.cumprod)
        self.assertQuantityEqual((self.q/pq.m).cumprod(), [1, 2, 6, 24])

    def test_conj(self):
        self.assertQuantityEqual((self.q*(1+1j)).conj(), self.q*(1-1j))
        self.assertQuantityEqual((self.q*(1+1j)).conjugate(), self.q*(1-1j))

    def test_getitem(self):
        self.assertRaises(IndexError, self.q.__getitem__, (0,10))
        self.assertQuantityEqual(self.q[0], [1,2]*pq.m)
        self.assertQuantityEqual(self.q[1,1], 4*pq.m)

    def test_setitem (self):
        self.assertRaises(ValueError, self.q.__setitem__, (0,0), 1)
        self.assertRaises(ValueError, self.q.__setitem__, (0,0), 1*pq.J)
        self.assertRaises(ValueError, self.q.__setitem__, 0, 1)
        self.assertRaises(ValueError, self.q.__setitem__, 0, [1, 2])
        self.assertRaises(ValueError, self.q.__setitem__, 0, 1*pq.J)

        q = self.q.copy()
        q[0] = 1*pq.m
        self.assertQuantityEqual(q, [[1,1],[3,4]]*pq.m)

        q[0] = (1,2)*pq.m
        self.assertQuantityEqual(q, self.q)

        q[:] = 1*pq.m
        self.assertQuantityEqual(q, [[1,1],[1,1]]*pq.m)

        # check and see that dimensionless numbers work correctly
        q = [0,1,2,3]*pq.dimensionless
        q[0] = 1
        self.assertQuantityEqual(q, [1,1,2,3])
        q[0] = pq.m/pq.mm
        self.assertQuantityEqual(q, [1000, 1,2,3])

        q = [0,1,2,3] * pq.m/pq.mm
        q[0] = 1
        self.assertQuantityEqual(q, [0.001,1,2,3]*pq.m/pq.mm)

    def test_iterator(self):
        for q in self.q.flatten():
            self.assertQuantityEqual(q.units, pq.m)

########NEW FILE########
__FILENAME__ = test_persistence
# -*- coding: utf-8 -*-

import pickle

from .. import units as pq
from ..uncertainquantity import UncertainQuantity
from .. import constants
from .common import TestCase


class TestPersistence(TestCase):

    def test_unitquantity_persistance(self):
        x = pq.m
        y = pickle.loads(pickle.dumps(x))
        self.assertQuantityEqual(x, y)

        x = pq.CompoundUnit("pc/cm**3")
        y = pickle.loads(pickle.dumps(x))
        self.assertQuantityEqual(x, y)

    def test_quantity_persistance(self):
        x = 20*pq.m
        y = pickle.loads(pickle.dumps(x))
        self.assertQuantityEqual(x, y)

    def test_uncertainquantity_persistance(self):
        x = UncertainQuantity(20, 'm', 0.2)
        y = pickle.loads(pickle.dumps(x))
        self.assertQuantityEqual(x, y)

    def test_unitconstant_persistance(self):
        x = constants.m_e
        y = pickle.loads(pickle.dumps(x))
        self.assertQuantityEqual(x, y)

########NEW FILE########
__FILENAME__ = test_umath
# -*- coding: utf-8 -*-


import numpy as np

from .. import units as pq
from .common import TestCase, unittest


class TestUmath(TestCase):

    @property
    def q(self):
        return [1,2,3,4] * pq.J

    def test_prod(self):
        self.assertQuantityEqual(np.prod(self.q), 24 * pq.J**4)

    def test_sum(self):
        self.assertQuantityEqual(np.sum(self.q), 10 * pq.J)

    def test_nansum(self):
        c = [1,2,3, np.NaN] * pq.m
        self.assertQuantityEqual(np.nansum(c), 6 * pq.m)

    def test_cumprod(self):
        self.assertRaises(ValueError, np.cumprod, self.q)

        q = [10, .1, 5, 50] * pq.dimensionless
        self.assertQuantityEqual(np.cumprod(q), [10, 1, 5, 250])

    def test_cumsum(self):
        self.assertQuantityEqual(np.cumsum(self.q), [1, 3, 6, 10] * pq.J)

    def test_diff(self):
        self.assertQuantityEqual(np.diff(self.q, 1), [1, 1, 1] * pq.J)

    def test_ediff1d(self):
        self.assertQuantityEqual(np.diff(self.q, 1), [1, 1, 1] * pq.J)

    def test_gradient(self):
        try:
            l = np.gradient([[1,1],[3,4]] * pq.J, 1 * pq.m)
            self.assertQuantityEqual(l[0], [[2., 3.], [2., 3.]] * pq.J/pq.m)
            self.assertQuantityEqual(l[1], [[0., 0.], [1., 1.]] * pq.J/pq.m)
        except ValueError as e:
            raise self.failureException(e)

    @unittest.expectedFailure
    def test_cross(self):
        a = [3,-3, 1] * pq.kPa
        b = [4, 9, 2] * pq.m**2
        self.assertQuantityEqual(np.cross(a,b), [-15,-2,39]*pq.kPa*pq.m**2)

    def test_trapz(self):
        self.assertQuantityEqual(np.trapz(self.q, dx = 1*pq.m), 7.5 * pq.J*pq.m)

    def test_sinh(self):
        q = [1, 2, 3, 4, 6] * pq.radian
        self.assertQuantityEqual(
            np.sinh(q),
            np.sinh(q.magnitude)
            )

    def test_arcsinh(self):
        q = [1, 2, 3, 4, 6] * pq.dimensionless
        self.assertQuantityEqual(
            np.arcsinh(q),
            np.arcsinh(q.magnitude) * pq.rad
            )

    def test_cosh(self):
        q = [1, 2, 3, 4, 6] * pq.radian
        self.assertQuantityEqual(
            np.cosh(q),
            np.cosh(q.magnitude) * pq.dimensionless
            )

    def test_arccosh(self):
        q = [1, 2, 3, 4, 6] * pq.dimensionless
        self.assertQuantityEqual(
            np.arccosh(q),
            np.arccosh(q.magnitude) * pq.rad
            )

    def test_tanh(self):
        q = [1, 2, 3, 4, 6] * pq.rad
        self.assertQuantityEqual(
            np.tanh(q),
            np.tanh(q.magnitude)
            )

    def test_arctanh(self):
        q = [.01, .5, .6, .8, .99] * pq.dimensionless
        self.assertQuantityEqual(
            np.arctanh(q),
            np.arctanh(q.magnitude) * pq.rad
            )

    def test_around(self):
        self.assertQuantityEqual(
            np.around([.5, 1.5, 2.5, 3.5, 4.5] * pq.J) ,
            [0., 2., 2., 4., 4.] * pq.J
            )

        self.assertQuantityEqual(
            np.around([1,2,3,11] * pq.J, decimals=1),
            [1, 2, 3, 11] * pq.J
            )

        self.assertQuantityEqual(
            np.around([1,2,3,11] * pq.J, decimals=-1),
            [0, 0, 0, 10] * pq.J
            )

    def test_round_(self):
        self.assertQuantityEqual(
            np.round_([.5, 1.5, 2.5, 3.5, 4.5] * pq.J),
            [0., 2., 2., 4., 4.] * pq.J
            )

        self.assertQuantityEqual(
            np.round_([1,2,3,11] * pq.J, decimals=1),
            [1, 2, 3, 11] * pq.J
            )

        self.assertQuantityEqual(
            np.round_([1,2,3,11] * pq.J, decimals=-1),
            [0, 0, 0, 10] * pq.J
            )

    def test_rint(self):
        a = [-4.1, -3.6, -2.5, 0.1, 2.5, 3.1, 3.9] * pq.m
        self.assertQuantityEqual(
            np.rint(a),
            [-4., -4., -2., 0., 2., 3., 4.]*pq.m
            )

    def test_floor(self):
        a = [-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0] * pq.m
        self.assertQuantityEqual(
            np.floor(a),
            [-2., -2., -1., 0., 1., 1., 2.] * pq.m
            )

    def test_ceil(self):
        a = [-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0] * pq.m
        self.assertQuantityEqual(
            np.ceil(a),
            [-1., -1., -0., 1., 2., 2., 2.] * pq.m
            )

    @unittest.expectedFailure
    def test_fix(self):
        try:
            self.assertQuantityEqual(np.fix(3.14 * pq.degF), 3.0 * pq.degF)
            self.assertQuantityEqual(np.fix(3.0 * pq.degF), 3.0 * pq.degF)
            self.assertQuantityEqual(
                np.fix([2.1, 2.9, -2.1, -2.9] * pq.degF),
                [2., 2., -2., -2.] * pq.degF
                )
        except ValueError as e:
            raise self.failureException(e)

    def test_exp(self):
        self.assertQuantityEqual(np.exp(1*pq.dimensionless), np.e)
        self.assertRaises(ValueError, np.exp, 1*pq.m)

    def test_log(self):
        self.assertQuantityEqual(np.log(1*pq.dimensionless), 0)
        self.assertRaises(ValueError, np.log, 1*pq.m)

    def test_log10(self):
        self.assertQuantityEqual(np.log10(1*pq.dimensionless), 0)
        self.assertRaises(ValueError, np.log10, 1*pq.m)

    def test_log2(self):
        self.assertQuantityEqual(np.log2(1*pq.dimensionless), 0)
        self.assertRaises(ValueError, np.log2, 1*pq.m)

    def test_expm1(self):
        self.assertQuantityEqual(np.expm1(1*pq.dimensionless), np.e-1)
        self.assertRaises(ValueError, np.expm1, 1*pq.m)

    def test_log1p(self):
        self.assertQuantityEqual(np.log1p(0*pq.dimensionless), 0)
        self.assertRaises(ValueError, np.log1p, 1*pq.m)

    def test_sin(self):
        self.assertQuantityEqual(np.sin(np.pi/2*pq.radian), 1)
        self.assertRaises(ValueError, np.sin, 1*pq.m)

    def test_arcsin(self):
        self.assertQuantityEqual(
            np.arcsin(1*pq.dimensionless),
            np.pi/2 * pq.radian
            )
        self.assertRaises(ValueError, np.arcsin, 1*pq.m)

    def test_cos(self):
        self.assertQuantityEqual(np.cos(np.pi*pq.radians), -1)
        self.assertRaises(ValueError, np.cos, 1*pq.m)

    def test_arccos(self):
        self.assertQuantityEqual(np.arccos(1*pq.dimensionless), 0*pq.radian)
        self.assertRaises(ValueError, np.arccos, 1*pq.m)

    def test_tan(self):
        self.assertQuantityEqual(np.tan(0*pq.radian), 0)
        self.assertRaises(ValueError, np.tan, 1*pq.m)

    def test_arctan(self):
        self.assertQuantityEqual(np.arctan(0*pq.dimensionless), 0*pq.radian)
        self.assertRaises(ValueError, np.arctan, 1*pq.m)

    def test_arctan2(self):
        self.assertQuantityEqual(
            np.arctan2(0*pq.dimensionless, 0*pq.dimensionless),
            0
            )
        self.assertRaises(ValueError, np.arctan2, (1*pq.m, 1*pq.m))

    def test_hypot(self):
        self.assertQuantityEqual(np.hypot(3 * pq.m, 4 * pq.m),  5 * pq.m)
        self.assertRaises(ValueError, np.hypot, 1*pq.m, 2*pq.J)

    def test_degrees(self):
        self.assertQuantityEqual(
            np.degrees(6 * pq.radians),
            (6 * pq.radians).rescale(pq.degree)
            )
        self.assertRaises(ValueError, np.degrees, 0*pq.degree)

    def test_radians(self):
        self.assertQuantityEqual(
            np.radians(6 * pq.degree),
            (6 * pq.degree).rescale(pq.radian)
            )
        self.assertRaises(ValueError, np.radians, 0*pq.radians)

    @unittest.expectedFailure
    def test_unwrap(self):
        self.assertQuantityEqual(np.unwrap([0,3*np.pi]*pq.radians), [0,np.pi])
        self.assertQuantityEqual(np.unwrap([0,540]*pq.deg), [0,180]*pq.deg)

########NEW FILE########
__FILENAME__ = test_uncertainty
# -*- coding: utf-8 -*-

from .. import units as pq
from ..uncertainquantity import UncertainQuantity
from .common import TestCase


class TestUncertainty(TestCase):

    def test_creation(self):
        a = UncertainQuantity(1, pq.m)
        self.assertQuantityEqual(a, 1*pq.m)
        self.assertQuantityEqual(a.uncertainty, 0*pq.m)
        a = UncertainQuantity([1, 1, 1], pq.m)
        self.assertQuantityEqual(a, [1,1,1]*pq.m)
        self.assertQuantityEqual(a.uncertainty, [0,0,0]*pq.m)
        a = UncertainQuantity([1, 1, 1], pq.m, [.1, .1, .1])
        self.assertQuantityEqual(a, [1, 1, 1] *pq.m)
        self.assertQuantityEqual(a.uncertainty, [0.1, 0.1, 0.1] *pq.m)
        self.assertRaises(ValueError, UncertainQuantity, [1,1,1], pq.m, 1)
        self.assertRaises(ValueError, UncertainQuantity, [1,1,1], pq.m, [1,1])

    def test_rescale(self):
        a = UncertainQuantity([1, 1, 1], pq.m, [.1, .1, .1])
        b = a.rescale(pq.ft)
        self.assertQuantityEqual(
            a.rescale('ft'),
            [3.2808399, 3.2808399, 3.2808399]*pq.ft
            )
        self.assertQuantityEqual(
            a.rescale('ft').uncertainty,
            [0.32808399, 0.32808399, 0.32808399]*pq.ft
            )

    def test_set_uncertainty(self):
        a = UncertainQuantity([1, 2], 'm', [.1, .2])
        a.uncertainty = [1., 2.]*pq.m
        self.assertQuantityEqual(a.uncertainty, [1, 2]*pq.m)

        def set_u(q, u):
            q.uncertainty = u

        self.assertRaises(ValueError, set_u, a, 1)
        self.assertRaises(ValueError, set_u, a, [1,2])

    def test_uncertainquantity_multiply(self):
        a = UncertainQuantity([1, 2], 'm', [.1, .2])
        self.assertQuantityEqual(a*a, [1., 4.]*pq.m**2)
        self.assertQuantityEqual((a*a).uncertainty, [0.14142,0.56568]*pq.m**2)
        self.assertQuantityEqual(a*2, [2, 4]*pq.m)
        self.assertQuantityEqual((a*2).uncertainty, [0.2,0.4]*pq.m)

    def test_uncertainquantity_divide(self):
        a = UncertainQuantity([1, 2], 'm', [.1, .2])
        self.assertQuantityEqual(a/a, [1., 1.])
        self.assertQuantityEqual((a/a).uncertainty, [0.14142, 0.14142])
        self.assertQuantityEqual(a/pq.m, [1., 2.])
        self.assertQuantityEqual((a/pq.m).uncertainty, [0.1, 0.2])
        self.assertQuantityEqual(a/2, [0.5, 1.]*pq.m)
        self.assertQuantityEqual((a/2).uncertainty, [0.05, 0.1 ]*pq.m)
        self.assertQuantityEqual(1/a, [1., 0.5]/pq.m)
        self.assertQuantityEqual((1/a).uncertainty, [0.1, 0.05]/pq.m)

########NEW FILE########
__FILENAME__ = test_units
# -*- coding: utf-8 -*-

from .. import units as pq
from .common import TestCase

class TestUnits(TestCase):

    def test_compound_units(self):
        pc_per_cc = pq.CompoundUnit("pc/cm**3")
        self.assertEqual(str(pc_per_cc.dimensionality), "(pc/cm**3)")
        self.assertEqual(str(pc_per_cc), "1 (pc/cm**3)")

        temp = pc_per_cc * pq.CompoundUnit('m/m**3')
        self.assertEqual(str(temp.dimensionality), "(pc/cm**3)*(m/m**3)")
        self.assertEqual(str(temp), "1.0 (pc/cm**3)*(m/m**3)")

    def test_units_protected(self):
        def setunits(u, v):
            u.units = v

        def inplace(op, u, val):
            getattr(u, '__i%s__'%op)(val)

        self.assertRaises(AttributeError, setunits, pq.m, pq.ft)
        self.assertRaises(TypeError, inplace, 'add', pq.m, pq.m)
        self.assertRaises(TypeError, inplace, 'sub', pq.m, pq.m)
        self.assertRaises(TypeError, inplace, 'mul', pq.m, pq.m)
        self.assertRaises(TypeError, inplace, 'truediv', pq.m, pq.m)
        self.assertRaises(TypeError, inplace, 'pow', pq.m, 2)

    def test_units_copy(self):
        self.assertQuantityEqual(pq.m.copy(), pq.m)
        pc_per_cc = pq.CompoundUnit("pc/cm**3")
        self.assertQuantityEqual(pc_per_cc.copy(), pc_per_cc)

########NEW FILE########
__FILENAME__ = umath
from __future__ import absolute_import

import numpy as np

from .quantity import Quantity
from .units import dimensionless, radian, degree
from .decorators import with_doc


#__all__ = [
#    'exp', 'expm1', 'log', 'log10', 'log1p', 'log2'
#]


@with_doc(np.prod)
def prod(a, axis=None, dtype=None, out=None):
    return a.prod(axis, dtype, out)

@with_doc(np.sum)
def sum(a, axis=None, dtype=None, out=None):
    return a.sum(axis, dtype, out)

@with_doc(np.nansum)
def nansum(a, axis=None):
    if not isinstance(a, Quantity):
        return np.nansum(a, axis)

    return Quantity(
        np.nansum(a.magnitude, axis),
        a.dimensionality,
        copy=False
    )

@with_doc(np.cumprod)
def cumprod(a, axis=None, dtype=None, out=None):
    """
    Raises a ValueError if input cannot be rescaled to a dimensionless
    quantity.
    """
    return a.cumprod(axis, dtype, out)

@with_doc(np.cumsum)
def cumsum(a,axis=None, dtype=None, out=None):
    return a.cumsum(axis, dtype, out)

diff = np.diff

@with_doc(np.ediff1d)
def ediff1d(ary, to_end=None, to_begin=None):
    if not isinstance(ary, Quantity):
        return np.ediff1d(ary, to_end, to_begin)

    return Quantity(
        np.ediff1d(ary.magnitude, to_end, to_begin),
        ary.dimensionality,
        copy=False
    )

@with_doc(np.gradient)
def gradient(f, *varargs):
    # if no sample distances are specified, use dimensionless 1
    # this mimicks the behavior of np.gradient, but perhaps we should
    # remove this default behavior
    # removed for now::
    #
    #   if len(varargs) == 0:
    #       varargs = (Quantity(1),)

    varargsQuantities = [Quantity(i, copy=False) for i in varargs]
    varargsMag = tuple([i.magnitude for i in varargsQuantities])
    ret = np.gradient(f.magnitude, *varargsMag)

    if len(varargs) == 1:
        # if there was only one sample distance provided,
        # apply the units in all directions
        return tuple([ Quantity(i, f.units/varargs[0].units)  for i  in ret])
    else:
        #give each output array the units of the input array
        #divided by the units of the spacing quantity given
        return tuple([ Quantity(i, f.units/j.units)
                      for i,j  in zip( ret, varargsQuantities)])

@with_doc(np.cross)
def cross (a, b , axisa=-1, axisb=-1, axisc=-1, axis=None):
    if not (isinstance(a, Quantity) and isinstance(b, Quantity)):
        return np.cross(a, b, axisa, axisb, axisc, axis)

    if not isinstance(a, Quantity):
        a = Quantity(a, dimensionless, copy=False)
    if not isinstance(b, Quantity):
        b = Quantity(b, dimensionless, copy=False)

    return Quantity(
        np.cross(a, b, axisa, axisb, axisc, axis),
        a._dimensionality*b._dimensionality,
        copy=False
    )

@with_doc(np.trapz)
def trapz(y, x=None, dx=1.0, axis=-1):
    # this function has a weird input structure, so it is tricky to wrap it
    # perhaps there is a simpler way to do this
    if (
        not isinstance(y, Quantity)
        and not isinstance(x, Quantity)
        and not isinstance(dx, Quantity)
    ):
        return np.trapz(y, x, dx, axis)

    if not isinstance(y, Quantity):
        y = Quantity(y, copy = False)
    if not isinstance(x, Quantity) and not x is None:
        x = Quantity(x, copy = False)
    if not isinstance(dx, Quantity):
        dx = Quantity(dx, copy = False)

    if x is None:
        ret = np.trapz(y.magnitude , x, dx.magnitude, axis)
        return Quantity ( ret, y.units * dx.units)
    else:
        ret = np.trapz(y.magnitude , x.magnitude, dx.magnitude, axis)
        return Quantity ( ret, y.units * x.units)

@with_doc(np.sin)
def sin(x, out=None):
    """
    Raises a ValueError if input cannot be rescaled to radians.

    Returns a dimensionless quantity.
    """
    if not isinstance(x, Quantity):
        return np.sin(x, out)

    return Quantity(np.sin(x.rescale(radian).magnitude, out),
                    copy=False)

@with_doc(np.arcsin)
def arcsin(x, out=None):
    """
    Raises a ValueError if input cannot be rescaled to a dimensionless
    quantity.

    Returns a quantity in units of radians.
    """
    if not isinstance(x, Quantity):
        return np.arcsin(x, out)

    return Quantity(
        np.arcsin(x.rescale(dimensionless).magnitude, out),
        radian,
        copy=False
    )

@with_doc(np.cos)
def cos(x, out=None):
    """
    Raises a ValueError if input cannot be rescaled to radians.

    Returns a dimensionless quantity.
    """
    if not isinstance(x, Quantity):
        return np.cos(x, out)

    return Quantity(np.cos(x.rescale(radian).magnitude), copy=False)

@with_doc(np.arccos)
def arccos(x, out=None):
    """
    Raises a ValueError if input cannot be rescaled to a dimensionless
    quantity.

    Returns a quantity in units of radians.
    """
    if not isinstance(x, Quantity):
        return np.arccos(x, out)

    return Quantity(
        np.arccos(x.rescale(dimensionless).magnitude, out),
        radian,
        copy=False
    )

@with_doc(np.tan)
def tan(x, out=None):
    """
    Raises a ValueError if input cannot be rescaled to radians.

    Returns a dimensionless quantity.
    """
    if not isinstance(x, Quantity):
        return np.tan(x, out)

    return Quantity(np.tan(x.rescale(radian).magnitude), copy=False)

@with_doc(np.arctan)
def arctan(x, out=None):
    """
    Raises a ValueError if input cannot be rescaled to a dimensionless
    quantity.

    Returns a quantity in units of radians.
    """
    if not isinstance(x, Quantity):
        return np.arctan(x, out)

    return Quantity(
        np.arctan(x.rescale(dimensionless).magnitude, out),
        radian,
        copy=False
    )

@with_doc(np.arctan2)
def arctan2(x1, x2, out=None):
    """
    Raises a ValueError if inputs do not have identical units.

    Returns a quantity in units of radians.
    """
    if not (isinstance(x1, Quantity) and isinstance(x2, Quantity)):
        return np.arctan2(x1, x2, out)

    if not isinstance(x1, Quantity):
        x1 = Quantity(x1, dimensionless, copy=False)
    if not isinstance(x2, Quantity):
        x2 = Quantity(x2, dimensionless, copy=False)

    if x1._dimensionality.simplified != x2._dimensionality.simplified:
        raise ValueError(
            'x1 and x2 must have identical units, got "%s" and "%s"'\
            % (str(x1._dimensionality), str(x2._dimensionality))
        )

    return Quantity(
        np.arctan2(x1.magnitude, x2.magnitude, out),
        radian,
        copy=False
    )

@with_doc(np.hypot)
def hypot(x1, x2, out = None):
    """
    Raises a ValueError if inputs do not have identical units.
    """
    if not (isinstance(x1, Quantity) and isinstance(x2, Quantity)):
        return np.hypot(x1, x2, out)

    if not isinstance(x1, Quantity):
        x1 = Quantity(x1, dimensionless, copy=False)
    if not isinstance(x2, Quantity):
        x2 = Quantity(x2, dimensionless, copy=False)

    if x1._dimensionality != x2._dimensionality:
        raise ValueError(
            'x1 and x2 must have identical units, got "%s" and "%s"'\
            % (str(x1._dimensionality), str(x2._dimensionality))
        )

    return Quantity(
        np.hypot(x1.magnitude, x2.magnitude, out),
        x1.dimensionality,
        copy = False
    )

@with_doc(np.unwrap)
def unwrap(p, discont=np.pi, axis=-1):
    if not (isinstance(p, Quantity) and isinstance(discont, Quantity)):
        return np.unwrap(p, discont, axis)

    if not isinstance(p, Quantity):
        p = Quantity(p, copy=False)
    if not isinstance(discont, Quantity):
        discont = Quantity(discont, copy=False)

    discont = discont.rescale(p.units)

    return Quantity(
        np.unwrap(p.magnitude, discont.magnitude, axis),
        p.units
    )

@with_doc(np.sinh)
def sinh(x, out=None):
    """
    Raises a ValueError if input cannot be rescaled to a dimensionless
    quantity.
    """
    if not isinstance(x, Quantity):
        return np.sinh(x, out)

    return Quantity(
        np.sinh(x.rescale(dimensionless).magnitude, out),
        dimensionless,
        copy=False
    )

@with_doc(np.cosh)
def cosh(x, out=None):
    """
    Raises a ValueError if input cannot be rescaled to a dimensionless
    quantity.
    """
    if not isinstance(x, Quantity):
        return np.cosh(x, out)

    return Quantity(
        np.cosh(x.rescale(dimensionless).magnitude, out),
        dimensionless,
        copy=False
    )

@with_doc(np.tanh)
def tanh(x, out=None):
    """
    Raises a ValueError if input cannot be rescaled to a dimensionless
    quantity.
    """
    if not isinstance(x, Quantity):
        return np.tanh(x, out)

    return Quantity(
        np.tanh(x.rescale(dimensionless).magnitude, out),
        dimensionless,
        copy=False
    )

@with_doc(np.arcsinh)
def arcsinh(x, out=None):
    """
    Raises a ValueError if input cannot be rescaled to a dimensionless
    quantity.
    """
    if not isinstance(x, Quantity):
        return np.arcsinh(x, out)

    return Quantity(
        np.arcsinh(x.rescale(dimensionless).magnitude, out),
        dimensionless,
        copy=False
    )

@with_doc(np.arccosh)
def arccosh(x, out=None):
    """
    Raises a ValueError if input cannot be rescaled to a dimensionless
    quantity.
    """
    if not isinstance(x, Quantity):
        return np.arccosh(x, out)

    return Quantity(
        np.arccosh(x.rescale(dimensionless).magnitude, out),
        dimensionless,
        copy=False
    )

@with_doc(np.arctanh)
def arctanh(x, out=None):
    """
    Raises a ValueError if input cannot be rescaled to a dimensionless
    quantity.
    """
    if not isinstance(x, Quantity):
        return np.arctanh(x, out)

    return Quantity(
        np.arctanh(x.rescale(dimensionless).magnitude, out),
        dimensionless,
        copy=False
    )

########NEW FILE########
__FILENAME__ = uncertainquantity
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

import sys

import numpy as np

from . import markup
from .quantity import Quantity, scale_other_units
from .registry import unit_registry
from .decorators import with_doc

class UncertainQuantity(Quantity):

    # TODO: what is an appropriate value?
    __array_priority__ = 22

    def __new__(cls, data, units='', uncertainty=None, dtype='d', copy=True):
        ret = Quantity.__new__(cls, data, units, dtype, copy)
        # _uncertainty initialized to be dimensionless by __array_finalize__:
        ret._uncertainty._dimensionality = ret._dimensionality

        if uncertainty is not None:
            ret.uncertainty = Quantity(uncertainty, ret._dimensionality)
        elif isinstance(data, UncertainQuantity):
            if copy or ret._dimensionality != uncertainty._dimensionality:
                uncertainty = data.uncertainty.rescale(ret.units)
            ret.uncertainty = uncertainty

        return ret

    @Quantity.units.setter
    def units(self, units):
        super(UncertainQuantity, self)._set_units(units)
        self.uncertainty.units = self._dimensionality

    @property
    def _reference(self):
        ret = super(UncertainQuantity, self)._reference.view(UncertainQuantity)
        ret.uncertainty = self.uncertainty._reference
        return ret

    @property
    def simplified(self):
        ret = super(UncertainQuantity, self).simplified.view(UncertainQuantity)
        ret.uncertainty = self.uncertainty.simplified
        return ret

    @property
    def uncertainty(self):
        return self._uncertainty
    @uncertainty.setter
    def uncertainty(self, uncertainty):
        if not isinstance(uncertainty, Quantity):
            uncertainty = Quantity(uncertainty, copy=False)
        try:
            assert self.shape == uncertainty.shape
        except AssertionError:
            raise ValueError('data and uncertainty must have identical shape')
        if uncertainty._dimensionality != self._dimensionality:
            uncertainty = uncertainty.rescale(self._dimensionality)
        self._uncertainty = uncertainty

    @property
    def relative_uncertainty(self):
        return self.uncertainty.magnitude/self.magnitude

    @with_doc(Quantity.rescale, use_header=False)
    def rescale(self, units):
        cls = UncertainQuantity
        ret = super(cls, self).rescale(units).view(cls)
        ret.uncertainty = self.uncertainty.rescale(units)
        return ret

    def __array_finalize__(self, obj):
        Quantity.__array_finalize__(self, obj)
        self._uncertainty = getattr(
            obj,
            'uncertainty',
            Quantity(
                np.zeros(self.shape, self.dtype),
                self._dimensionality,
                copy=False
            )
        )

    @with_doc(Quantity.__add__, use_header=False)
    @scale_other_units
    def __add__(self, other):
        res = super(UncertainQuantity, self).__add__(other)
        u = (self.uncertainty**2+other.uncertainty**2)**0.5
        return UncertainQuantity(res, uncertainty=u, copy=False)

    @with_doc(Quantity.__radd__, use_header=False)
    @scale_other_units
    def __radd__(self, other):
        return self.__add__(other)

    @with_doc(Quantity.__sub__, use_header=False)
    @scale_other_units
    def __sub__(self, other):
        res = super(UncertainQuantity, self).__sub__(other)
        u = (self.uncertainty**2+other.uncertainty**2)**0.5
        return UncertainQuantity(res, uncertainty=u, copy=False)

    @with_doc(Quantity.__rsub__, use_header=False)
    @scale_other_units
    def __rsub__(self, other):
        if not isinstance(other, UncertainQuantity):
            other = UncertainQuantity(other, copy=False)

        return UncertainQuantity.__sub__(other, self)

    @with_doc(Quantity.__mul__, use_header=False)
    def __mul__(self, other):
        res = super(UncertainQuantity, self).__mul__(other)
        try:
            sru = self.relative_uncertainty
            oru = other.relative_uncertainty
            ru = (sru**2+oru**2)**0.5
            u = res.view(Quantity) * ru
        except AttributeError:
            other = np.array(other, copy=False, subok=True)
            u = (self.uncertainty**2*other**2)**0.5

        res._uncertainty = u
        return res

    @with_doc(Quantity.__rmul__, use_header=False)
    def __rmul__(self, other):
        return self.__mul__(other)

    @with_doc(Quantity.__truediv__, use_header=False)
    def __truediv__(self, other):
        res = super(UncertainQuantity, self).__truediv__(other)
        try:
            sru = self.relative_uncertainty
            oru = other.relative_uncertainty
            ru = (sru**2+oru**2)**0.5
            u = res.view(Quantity) * ru
        except AttributeError:
            other = np.array(other, copy=False, subok=True)
            u = (self.uncertainty**2/other**2)**0.5

        res._uncertainty = u
        return res

    @with_doc(Quantity.__rtruediv__, use_header=False)
    def __rtruediv__(self, other):
        temp = UncertainQuantity(
            1/self.magnitude, self.dimensionality**-1,
            self.relative_uncertainty/self.magnitude, copy=False
        )
        return other * temp

    if sys.version_info[0] < 3:
        __div__ = __truediv__
        __rdiv__ = __rtruediv__

    @with_doc(Quantity.__pow__, use_header=False)
    def __pow__(self, other):
        res = super(UncertainQuantity, self).__pow__(other)
        res.uncertainty = res.view(Quantity) * other * self.relative_uncertainty
        return res

    @with_doc(Quantity.__getitem__, use_header=False)
    def __getitem__(self, key):
        return UncertainQuantity(
            self.magnitude[key],
            self._dimensionality,
            self.uncertainty[key],
            copy=False
        )

    @with_doc(Quantity.__repr__, use_header=False)
    def __repr__(self):
        return '%s(%s, %s, %s)'%(
            self.__class__.__name__,
            repr(self.magnitude),
            self.dimensionality.string,
            repr(self.uncertainty.magnitude)
        )

    @with_doc(Quantity.__str__, use_header=False)
    def __str__(self):
        if markup.config.use_unicode:
            dims = self.dimensionality.unicode
        else:
            dims = self.dimensionality.string
        s = '%s %s\n+/-%s (1 sigma)'%(
            str(self.magnitude),
            dims,
            str(self.uncertainty)
        )
        if markup.config.use_unicode:
            return s.replace('+/-', '±').replace(' sigma', 'σ')
        return s

    @with_doc(np.ndarray.sum)
    def sum(self, axis=None, dtype=None, out=None):
        return UncertainQuantity(
            self.magnitude.sum(axis, dtype, out),
            self.dimensionality,
            (np.sum(self.uncertainty.magnitude**2, axis))**0.5,
            copy=False
        )

    def __getstate__(self):
        """
        Return the internal state of the quantity, for pickling
        purposes.

        """
        state = list(super(UncertainQuantity, self).__getstate__())
        state.append(self._uncertainty)
        return tuple(state)

    def __setstate__(self, state):
        (ver, shp, typ, isf, raw, units, sigma) = state
        np.ndarray.__setstate__(self, (shp, typ, isf, raw))
        self._dimensionality = units
        self._uncertainty = sigma

########NEW FILE########
__FILENAME__ = unitquantity
"""
"""
from __future__ import absolute_import

import sys
import weakref

import numpy

from .dimensionality import Dimensionality
from . import markup
from .quantity import Quantity, get_conversion_factor
from .registry import unit_registry
from .decorators import memoize, with_doc


__all__ = [
    'CompoundUnit', 'Dimensionless', 'UnitConstant', 'UnitCurrency',
    'UnitCurrent', 'UnitInformation', 'UnitLength', 'UnitLuminousIntensity',
    'UnitMass', 'UnitMass', 'UnitQuantity', 'UnitSubstance', 'UnitTemperature',
    'UnitTime', 'set_default_units'
]


class UnitQuantity(Quantity):

    _primary_order = 90
    _secondary_order = 0
    _reference_quantity = None

    __array_priority__ = 20

    def __new__(
        cls, name, definition=None, symbol=None, u_symbol=None,
        aliases=[], doc=None
    ):
        try:
            assert isinstance(name, str)
        except AssertionError:
            raise TypeError('name must be a string, got %s (not unicode)'%name)
        try:
            assert symbol is None or isinstance(symbol, str)
        except AssertionError:
            raise TypeError(
                'symbol must be a string, '
                'got %s (u_symbol can be unicode)'%symbol
            )

        ret = numpy.array(1, dtype='d').view(cls)
        ret.flags.writeable = False

        ret._name = name
        ret._symbol = symbol
        ret._u_symbol = u_symbol
        if doc is not None:
            ret.__doc__ = doc

        if definition is not None:
            if not isinstance(definition, Quantity):
                definition *= dimensionless
            ret._definition = definition
            ret._conv_ref = definition._reference
        else:
            ret._definition = None
            ret._conv_ref = None

        ret._aliases = aliases

        ret._format_order = (ret._primary_order, ret._secondary_order)
        ret.__class__._secondary_order += 1

        return ret

    def __init__(
        self, name, definition=None, symbol=None, u_symbol=None,
        aliases=[], doc=None
    ):
        unit_registry[name] = self
        if symbol:
            unit_registry[symbol] = self
        for alias in aliases:
            unit_registry[alias] = self

    def __array_finalize__(self, obj):
        pass

    def __hash__(self):
        return hash((type(self), self._name))

    @property
    def _reference(self):
        if self._conv_ref is None:
            return self
        else:
            return self._conv_ref

    @property
    def _dimensionality(self):
        return Dimensionality({self:1})

    @property
    def format_order(self):
        return self._format_order

    @property
    def name(self):
        return self._name

    @property
    def definition(self):
        if self._definition is None:
            return self
        else:
            return self._definition

    @property
    def simplified(self):
        return self._reference.simplified

    @property
    def symbol(self):
        if self._symbol:
            return self._symbol
        else:
            return self.name

    @property
    def u_symbol(self):
        if self._u_symbol:
            return self._u_symbol
        else:
            return self.symbol

    @property
    def units(self):
        return self
    @units.setter
    def units(self, units):
        raise AttributeError('can not modify protected units')

    def __repr__(self):
        ref = self._definition
        if ref:
            ref = ', %s * %s'%(str(ref.magnitude), ref.dimensionality.string)
        else:
            ref = ''
        symbol = self._symbol
        symbol = ', %s'%(repr(symbol)) if symbol else ''
        if markup.config.use_unicode:
            u_symbol = self._u_symbol
            u_symbol = ', %s'%(repr(u_symbol)) if u_symbol else ''
        else:
            u_symbol = ''
        return '%s(%s%s%s%s)'%(
            self.__class__.__name__, repr(self.name), ref, symbol, u_symbol
        )

    @with_doc(Quantity.__str__, use_header=False)
    def __str__(self):
        if self.u_symbol != self.name:
            if markup.config.use_unicode:
                s = '1 %s (%s)'%(self.u_symbol, self.name)
            else:
                s = '1 %s (%s)'%(self.symbol, self.name)
        else:
            s = '1 %s'%self.name

        return s

    @with_doc(Quantity.__add__, use_header=False)
    def __add__(self, other):
        return self.view(Quantity).__add__(other)

    @with_doc(Quantity.__radd__, use_header=False)
    def __radd__(self, other):
        try:
            return self.rescale(other.units).__radd__(other)
        except AttributeError:
            return self.view(Quantity).__radd__(other)

    @with_doc(Quantity.__sub__, use_header=False)
    def __sub__(self, other):
        return self.view(Quantity).__sub__(other)

    @with_doc(Quantity.__rsub__, use_header=False)
    def __rsub__(self, other):
        try:
            return self.rescale(other.units).__rsub__(other)
        except AttributeError:
            return self.view(Quantity).__rsub__(other)

    @with_doc(Quantity.__mod__, use_header=False)
    def __mod__(self, other):
        return self.view(Quantity).__mod__(other)

    @with_doc(Quantity.__rsub__, use_header=False)
    def __rmod__(self, other):
        try:
            return self.rescale(other.units).__rmod__(other)
        except AttributeError:
            return self.view(Quantity).__rmod__(other)

    @with_doc(Quantity.__mul__, use_header=False)
    def __mul__(self, other):
        return self.view(Quantity).__mul__(other)

    @with_doc(Quantity.__rmul__, use_header=False)
    def __rmul__(self, other):
        return self.view(Quantity).__rmul__(other)

    @with_doc(Quantity.__truediv__, use_header=False)
    def __truediv__(self, other):
        return self.view(Quantity).__truediv__(other)

    @with_doc(Quantity.__rtruediv__, use_header=False)
    def __rtruediv__(self, other):
        return self.view(Quantity).__rtruediv__(other)

    if sys.version_info[0] < 3:
        @with_doc(Quantity.__div__, use_header=False)
        def __div__(self, other):
            return self.view(Quantity).__div__(other)

        @with_doc(Quantity.__rdiv__, use_header=False)
        def __rdiv__(self, other):
            return self.view(Quantity).__rdiv__(other)

    @with_doc(Quantity.__pow__, use_header=False)
    def __pow__(self, other):
        return self.view(Quantity).__pow__(other)

    @with_doc(Quantity.__rpow__, use_header=False)
    def __rpow__(self, other):
        return self.view(Quantity).__rpow__(other)

    @with_doc(Quantity.__iadd__, use_header=False)
    def __iadd__(self, other):
        raise TypeError('can not modify protected units')

    @with_doc(Quantity.__isub__, use_header=False)
    def __isub__(self, other):
        raise TypeError('can not modify protected units')

    @with_doc(Quantity.__imul__, use_header=False)
    def __imul__(self, other):
        raise TypeError('can not modify protected units')

    @with_doc(Quantity.__itruediv__, use_header=False)
    def __itruediv__(self, other):
        raise TypeError('can not modify protected units')

    if sys.version_info[0] < 3:
        @with_doc(Quantity.__idiv__, use_header=False)
        def __idiv__(self, other):
            raise TypeError('can not modify protected units')

    @with_doc(Quantity.__ipow__, use_header=False)
    def __ipow__(self, other):
        raise TypeError('can not modify protected units')

    def __getstate__(self):
        """
        Return the internal state of the quantity, for pickling
        purposes.

        """
        state = (1, self._format_order)
        return state

    def __setstate__(self, state):
        ver, fo = state
        self._format_order = fo

    def __reduce__(self):
        """
        Return a tuple for pickling a UnitQuantity.
        """
        return (
            type(self),
            (
                self._name,
                self._definition,
                self._symbol,
                self._u_symbol,
                self._aliases,
                self.__doc__
            ),
            self.__getstate__()
        )

    def copy(self):
        return (
            type(self)(
                self._name,
                self._definition,
                self._symbol,
                self._u_symbol,
                self._aliases,
                self.__doc__
                )
            )

unit_registry['UnitQuantity'] = UnitQuantity


class IrreducibleUnit(UnitQuantity):

    _default_unit = None

    def __init__(
        self, name, definition=None, symbol=None, u_symbol=None,
        aliases=[], doc=None
    ):
        super(IrreducibleUnit, self).__init__(
            name, definition, symbol, u_symbol, aliases, doc
        )
        cls = type(self)
        if cls._default_unit is None:
            cls._default_unit = self

    @property
    def simplified(self):
        return self.view(Quantity).rescale(self.get_default_unit())

    @classmethod
    def get_default_unit(cls):
        return cls._default_unit
    @classmethod
    def set_default_unit(cls, unit):
        if unit is None:
            return
        if isinstance(unit, str):
            unit = unit_registry[unit]
        try:
            # check that conversions are possible:
            get_conversion_factor(cls._default_unit, unit)
        except ValueError:
            raise TypeError('default unit must be of same type')
        cls._default_unit = unit


class UnitMass(IrreducibleUnit):

    _primary_order = 1


class UnitLength(IrreducibleUnit):

    _primary_order = 2


class UnitTime(IrreducibleUnit):

    _primary_order = 3


class UnitCurrent(IrreducibleUnit):

    _primary_order = 4


class UnitLuminousIntensity(IrreducibleUnit):

    _primary_order = 5


class UnitSubstance(IrreducibleUnit):

    _primary_order = 6


class UnitTemperature(IrreducibleUnit):

    _primary_order = 7


class UnitInformation(IrreducibleUnit):

    _primary_order = 8


class UnitCurrency(IrreducibleUnit):

    _primary_order = 9


class CompoundUnit(UnitQuantity):

    _primary_order = 99

    def __new__(cls, name):
        return UnitQuantity.__new__(cls, name, unit_registry[name])

    def __init__(self, name):
        # do not register
        return

    @with_doc(UnitQuantity.__add__, use_header=False)
    def __repr__(self):
        return '1 %s'%self.name

    @property
    def name(self):
        if markup.config.use_unicode:
            return '(%s)'%(markup.superscript(self._name))
        else:
            return '(%s)'%self._name

    def __reduce__(self):
        """
        Return a tuple for pickling a UnitQuantity.
        """
        return (
            type(self),
            (self._name, ),
            self.__getstate__()
            )

    def copy(self):
        return type(self)(self._name)

unit_registry['CompoundUnit'] = CompoundUnit


class Dimensionless(UnitQuantity):

    _primary_order = 100

    def __init__(self, name, definition=None):
        self._name = name

        if definition is None:
            definition = self
        self._definition = definition

        self._format_order = (self._primary_order, self._secondary_order)
        self.__class__._secondary_order += 1

        unit_registry[name] = self

    def __reduce__(self):
        """
        Return a tuple for pickling a UnitQuantity.
        """
        return (
            type(self),
            (
                self._name,
            ),
            self.__getstate__()
        )

    @property
    def _dimensionality(self):
        return Dimensionality()

dimensionless = Dimensionless('dimensionless')


class UnitConstant(UnitQuantity):

    _primary_order = 0

    def __init__(
        self, name, definition=None, symbol=None, u_symbol=None,
        aliases=[], doc=None
    ):
        # we dont want to register constants in the unit registry
        return


def set_default_units(
    system=None, currency=None, current=None, information=None, length=None,
    luminous_intensity=None, mass=None, substance=None, temperature=None,
    time=None
):
    """
    Set the default units in which simplified quantities will be
    expressed.

    system sets the unit system, and can be "SI" or "cgs". All other
    keyword arguments will accept either a string or a unit quantity.
    An error will be raised if it is not possible to convert between
    old and new defaults, so it is not possible to set "kg" as the
    default unit for time.

    If both system and individual defaults are given, the system
    defaults will be applied first, followed by the individual ones.
    """
    if system is not None:
        system = system.lower()
        try:
            assert system in ('si', 'cgs')
        except AssertionError:
            raise ValueError('system must be "SI" or "cgs", got "%s"' % system)
        if system == 'si':
            UnitCurrent.set_default_unit('A')
            UnitLength.set_default_unit('m')
            UnitMass.set_default_unit('kg')
        elif system == 'cgs':
            UnitLength.set_default_unit('cm')
            UnitMass.set_default_unit('g')
        UnitLuminousIntensity.set_default_unit('cd')
        UnitSubstance.set_default_unit('mol')
        UnitTemperature.set_default_unit('degK')
        UnitTime.set_default_unit('s')

    UnitCurrency.set_default_unit(currency)
    UnitCurrent.set_default_unit(current)
    UnitInformation.set_default_unit(information)
    UnitLength.set_default_unit(length)
    UnitLuminousIntensity.set_default_unit(luminous_intensity)
    UnitMass.set_default_unit(mass)
    UnitSubstance.set_default_unit(substance)
    UnitTemperature.set_default_unit(temperature)
    UnitTime.set_default_unit(time)


########NEW FILE########
__FILENAME__ = acceleration
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .time import s
from .length import m

g_0 = g_n = gravity = standard_gravity = gee = force = free_fall = \
    standard_free_fall = gp = dynamic = geopotential = UnitQuantity(
    'standard_gravity',
    9.806650*m/s**2,
    symbol='g_0',
    u_symbol='g₀',
    doc='exact'
)

del m, s, UnitQuantity

########NEW FILE########
__FILENAME__ = angle
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from math import pi

from ..unitquantity import UnitQuantity, dimensionless

rad = radian = radians = UnitQuantity(
    'radian',
    1*dimensionless,
    symbol='rad',
    aliases=['radians']
)
mrad = milliradian = UnitQuantity(
    'milliradian',
    rad/1000,
    symbol='mrad',
    aliases=['milliradians']
)
urad = microradian = UnitQuantity(
    'microradian',
    mrad/1000,
    symbol='urad',
    u_symbol='µrad',
    aliases=['microradians']
)

turn = revolution = cycle = turns = circle = circles = UnitQuantity(
    'turn',
    2*pi*radian,
    aliases=['turns', 'revolutions', 'circles', 'cycles']
)
deg = degree = degrees = arcdeg = arcdegree = angular_degree = UnitQuantity(
    'arcdegree',
    pi/180*radian,
    symbol='deg',
    u_symbol='°',
    aliases=[
        'degree', 'degrees', 'arc_degree', 'arc_degrees', 'angular_degree',
        'angular_degrees', 'arcdegrees', 'arcdeg'
    ]
)
arcminute = arcmin = arc_minute = angular_minute = UnitQuantity(
    'arcminute',
    arcdeg/60,
    symbol='arcmin',
    u_symbol='′',
    aliases=[
        'arcmins', 'arcminutes', 'arc_minute', 'arc_minutes',
        'angular_minute', 'angular_minutes'
    ]
)
arcsecond = arcsec = arc_second = angular_second = UnitQuantity(
    'arcsecond',
    arcmin/60,
    symbol='arcsec',
    u_symbol='″',
    aliases=[
        'arcsecs', 'arcseconds', 'arc_second', 'arc_seconds',
        'angular_second', 'angular_seconds'
    ]
)
grad = grade = UnitQuantity(
    'grad',
    0.9*arcdeg,
    aliases=['grads', 'grade', 'grades', 'gron', 'grons', 'gradian', 'gradians']
)

degrees_north = degrees_N = UnitQuantity(
    'degrees_north',
    arcdeg,
    symbol='degN',
    u_symbol='°N',
    aliases=['degrees_N']
)
degrees_east = degrees_E = UnitQuantity(
    'degrees_east',
    arcdeg,
    symbol='degE',
    u_symbol='°E',
    aliases=['degrees_E']
)
degrees_west = degrees_W = UnitQuantity(
    'degrees_west',
    arcdeg,
    symbol='degW',
    u_symbol='°W',
    aliases=['degrees_W']
)
degrees_true = degrees_T = UnitQuantity(
    'degrees_true',
    arcdeg,
    symbol='degT',
    u_symbol='°T',
    aliases=['degrees_T']
)

sr = steradian = UnitQuantity(
    'steradian',
    radian**2,
    symbol='sr',
    aliases=['steradians']
)

del UnitQuantity

########NEW FILE########
__FILENAME__ = area
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .length import m, rod

are = ares = UnitQuantity(
    'are',
    100*m**2,
    aliases=['ares']
)
b = barn = UnitQuantity(
    'barn',
    1e-28*m**2,
    symbol='b',
    aliases=['barnes']
)
cmil = circular_mil = UnitQuantity(
    'circular_mil',
    5.067075e-10*m**2,
    symbol='cmil',
    aliases=['circular_mils'],
    doc='conversions approximate, area of a circle with diameter=1 mil'
)
D = darcy = UnitQuantity(
    'darcy',
    9.869233e-13*m**2,
    symbol='D'
)
mD = millidarcy = UnitQuantity(
    'millidarcy',
    D/1000,
    symbol='mD'
)
ha = hectare = UnitQuantity(
    'hectare',
    10000*m**2,
    symbol='ha',
    aliases=['hectares']
)
acre = international_acre = UnitQuantity(
    'acre',
    4046.8564224*m**2,
    aliases=['acres', 'international_acre', 'international_acres'],
    doc="exact. http://en.wikipedia.org/wiki/Acre"
)
US_survey_acre = UnitQuantity(
    'US_survey_acre',
    160*rod**2,
    aliases=['US_survey_acres'],
)

del UnitQuantity, m, rod

########NEW FILE########
__FILENAME__ = compound
"""
"""
from __future__ import absolute_import

from ..unitquantity import CompoundUnit

pc_per_cc = CompoundUnit("pc/cm**3")

########NEW FILE########
__FILENAME__ = concentration
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .substance import mol
from .volume import L

M = molar = UnitQuantity(
    'molar',
    mol / L,
    symbol='M',
    aliases=['Molar']
)

mM = millimolar = UnitQuantity(
    'millimolar',
    molar / 1000,
    symbol='mM'
)

uM = micromolar = UnitQuantity(
    'micromolar',
    mM / 1000,
    symbol='uM',
    u_symbol='µM'
)

########NEW FILE########
__FILENAME__ = dimensionless
"""
"""
from __future__ import absolute_import

from ..unitquantity import dimensionless, UnitQuantity

percent = UnitQuantity(
    'percent',
    .01*dimensionless,
    symbol='%'
)

count = counts = UnitQuantity(
    'count',
    1*dimensionless,
    symbol='ct',
    aliases=['cts', 'counts']
)

del UnitQuantity

########NEW FILE########
__FILENAME__ = electromagnetism
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitCurrent, UnitLuminousIntensity, UnitQuantity
from .time import s
from .length import cm, m
from .energy import J, erg
from .velocity import c
from .force import N
from math import pi


A = amp = amps = ampere = amperes = UnitCurrent(
    'ampere',
    symbol='A',
    aliases=['amp', 'amps', 'amperes']
)
mA = milliamp = milliampere = UnitCurrent(
    'milliampere',
    A/1000,
    symbol='mA',
    aliases=['milliamp', 'milliamps', 'milliamperes']
)
uA = microampere = UnitCurrent(
    'microampere',
    mA/1000,
    symbol='uA',
    u_symbol='µA',
    aliases=['microamp', 'microamps', 'microamperes'])
nA = nanoamp = nanoampere = UnitCurrent(
    'nanoampere',
    uA/1000,
    symbol='nA',
    aliases=['nanoamp', 'nanoamps', 'nanoamperes']
)
pA = picoamp = picoampere = UnitCurrent(
    'picoampere',
    nA/1000,
    symbol='pA',
    aliases=['picoamp', 'picoamps', 'picoamperes']
)
aA = abampere = biot = UnitCurrent(
    'abampere',
    10*A,
    symbol='aA',
    aliases=['abamperes', 'biot', 'biots']
)

esu = statcoulomb = statC = franklin = Fr = UnitQuantity(
    'statcoulomb',
    1 * erg**0.5 * cm**0.5,
    symbol='esu',
    aliases=['statcoulombs', 'statC', 'franklin', 'franklins', 'Fr']
)
esu_per_second = statampere = UnitCurrent(
    'statampere',
    esu/s,
    symbol='(esu/s)',
    aliases=['statamperes']
)

ampere_turn = UnitQuantity(
    'ampere_turn',
    1*A
)
Gi = gilbert = UnitQuantity(
    'gilbert',
    10/(4*pi)*ampere_turn,
    symbol='Gi'
)

C = coulomb = UnitQuantity(
    'coulomb',
    A*s,
    symbol='C'
)
V = volt = UnitQuantity(
    'volt',
    J/C,
    symbol='V',
    aliases=['volts']
)
kV = kilovolt = UnitQuantity(
    'kilovolt',
    1000*V,
    symbol='kV',
    aliases=['kilovolts']
)
mV = millivolt = UnitQuantity(
    'millivolt',
    V/1000,
    symbol='mV',
    aliases=['millivolts']
)
uV = microvolt = UnitQuantity(
    'microvolt',
    V/1e6,
    symbol='uV',
    u_symbol='μV',
    aliases=['microvolts']
)
F = farad = UnitQuantity(
    'farad',
    C/V,
    symbol='F',
    aliases=['farads']
)
mF = UnitQuantity(
    'millifarad',
    F/1000,
    symbol='mF'
)
uF = UnitQuantity(
    'microfarad',
    mF/1000,
    symbol='uF',
    u_symbol='μF'
)
nF = UnitQuantity(
    'nanofarad',
    uF/1000,
    symbol='nF'
)
pF = UnitQuantity(
    'picofarad',
    nF/1000,
    symbol='pF'
)
ohm = Ohm = UnitQuantity(
    'ohm',
    V/A,
    u_symbol='Ω',
    aliases=['ohms', 'Ohm']
)
kOhm = UnitQuantity(
    'kiloohm',
    ohm*1000,
    u_symbol='kΩ',
    aliases=['kOhm', 'kohm', 'kiloohms']
)
MOhm = UnitQuantity(
    'megaohm',
    kOhm*1000,
    u_symbol='MΩ',
    aliases=['MOhm', 'Mohm', 'megaohms']
)
S = siemens = UnitQuantity(
    'siemens',
    A/V,
    symbol='S'
)
mS = siemens = UnitQuantity(
    'millisiemens',
    S/1000,
    symbol='mS'
)
uS = siemens = UnitQuantity(
    'microsiemens',
    mS/1000,
    symbol='uS',
    u_symbol='μS'
)
nS = siemens = UnitQuantity(
    'nanosiemens',
    uS/1000,
    symbol='nS'
)
pS = siemens = UnitQuantity(
    'picosiemens',
    nS/1000,
    symbol='pS'
)
Wb = weber = UnitQuantity(
    'weber',
    V*s,
    symbol='Wb',
    aliases=['webers']
)
T = tesla = UnitQuantity(
    'tesla',
    Wb/m**2,
    symbol='T',
    aliases=['teslas']
)
H = henry = UnitQuantity(
    'henry',
    Wb/A,
    symbol='H'
)
abfarad = UnitQuantity(
    'abfarad',
    1e9*farad,
    aliases=['abfarads']
)
abhenry = UnitQuantity(
    'abhenry',
    1e-9*henry
)
abmho = UnitQuantity(
    'abmho',
    1e9*S
)
abohm = UnitQuantity(
    'abohm',
    1e-9*ohm
)
abvolt = UnitQuantity(
    'abvolt',
    1e-8*V,
    aliases=['abvolts']
)
e = elementary_charge = UnitQuantity(
    'elementary_charge',
    1.602176487e-19*C,
    symbol='e',
    doc='relative uncertainty = 6.64e-8'
)
chemical_faraday = UnitQuantity(
    'chemical_faraday',
    9.64957e4*C
)
physical_faraday = UnitQuantity(
    'physical_faraday',
    9.65219e4*C
)
faraday = C12_faraday = UnitQuantity(
    'faraday',
    96485.3399*C,
    aliases=['faradays'],
    doc='The symbol F is reserved for the farad'
)
gamma = UnitQuantity(
    'gamma',
    1e-9*T
)
gauss = UnitQuantity(
    'gauss',
    1e-4*T,
    symbol='G'
)
maxwell = UnitQuantity(
    'maxwell',
    1e-8*Wb,
    symbol='Mx',
    aliases=['maxwells']
)
Oe = oersted = UnitQuantity(
    'oersted',
    1000/(4*pi)*A/m,
    symbol='Oe',
    aliases=['aliases']
)
statfarad = statF = stF = UnitQuantity(
    'statfarad',
    1.112650e-12*F,
    symbol='stF',
    aliases=['statfarads', 'statF']
)
stathenry = statH = stH = UnitQuantity(
    'stathenry',
    8.987554e11*H,
    symbol='stH',
    aliases=['statH']
)
statmho = statS = stS = UnitQuantity(
    'statmho',
    1.112650e-12*S,
    symbol='stS'
)
statohm = UnitQuantity(
    'statohm',
    8.987554e11*ohm,
    u_symbol='stΩ',
    aliases=['statohms']
)
statvolt = statV = stV = UnitQuantity(
    'statvolt',
    2.997925e2*V,
    symbol='stV',
    aliases=['statvolts', 'statV']
)
unit_pole = UnitQuantity(
    'unit_pole',
    1.256637e-7*Wb
)
vacuum_permeability = mu_0 = magnetic_constant = UnitQuantity(
    'magnetic_constant',
    4*pi*10**-7*N/A**2,
    symbol='mu_0',
    u_symbol='μ₀',
    aliases=['vacuum_permeability']
)
vacuum_permittivity = epsilon_0 = electric_constant = UnitQuantity(
    'electric_constant',
    1/(mu_0*c**2),
    symbol='epsilon_0',
    u_symbol='ε₀',
    aliases=['vacuum_permittivity']
)
Z_0 = impedence_of_free_space = characteristic_impedance_of_vacuum = \
        UnitQuantity(
    'characteristic_impedance_of_vacuum',
    mu_0*c,
    symbol='Z_0',
    u_symbol='Z₀',
    aliases=['impedence_of_free_space']
)

cd = candle = candela = UnitLuminousIntensity(
    'candela',
    symbol='cd',
    aliases=['candle', 'candles', 'candelas']
)

del UnitQuantity, s, m, J, c

########NEW FILE########
__FILENAME__ = energy
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .force import dyne, N
from .length import cm, m
from .time import s, h

J = joule = UnitQuantity(
    'joule',
    N*m,
    symbol='J',
    aliases=['joules']
)
erg = UnitQuantity(
    'erg',
    dyne*cm
)
btu = Btu = BTU = british_thermal_unit = UnitQuantity(
    'British_thermal_unit',
    J*1.05505585262e3,
    symbol='BTU'
)
eV = electron_volt = UnitQuantity(
    'electron_volt',
    J*1.60217653e-19,
    symbol='eV',
    aliases=['electron_volts']
)
meV = UnitQuantity(
    'meV',
    eV/1000
)
keV = UnitQuantity(
    'keV',
    1000*eV
)
MeV = UnitQuantity(
    'MeV',
    1000*keV
)
bev = GeV = UnitQuantity(
    'GeV',
    1000*MeV
)
thm = therm = EC_therm = UnitQuantity(
    'EC_therm',
    100000*BTU,
    symbol='thm'
)
cal = calorie = thermochemical_calorie = UnitQuantity(
    'thermochemical_calorie',
    4.184*J,
    symbol='cal',
    aliases=['calorie', 'calories', 'thermochemical_calories']
)
international_steam_table_calorie = UnitQuantity(
    'international_steam_table_calorie',
    J*4.1868,
    symbol='cal_IT',
    aliases=['international_steam_table_calories']
)
ton_TNT = UnitQuantity(
    'ton_TNT',
    4.184e9*J,
    symbol='tTNT'
)
US_therm = UnitQuantity(
    'US_therm',
    1.054804e8*J,
    aliases=['US_therms']
)
Wh = watthour = watt_hour = UnitQuantity(
    'watt_hour',
    J/s*h,
    symbol='Wh',
    aliases=['watthour', 'watthours', 'watt_hours']
)
kWh = kilowatthour = kilowatt_hour = UnitQuantity(
    'kilowatt_hour',
    1000*Wh,
    symbol='kWh',
    aliases=['kilowatthour', 'kilowatthours', 'kilowatt_hours']
)
MWh = megawatthour = megawatt_hour = UnitQuantity(
    'megawatt_hour',
    1000*kWh,
    symbol='MWh',
    aliases=['megawatthour', 'megawatthours', 'megawatt_hours']
)
GWh = gigawatthour = gigawatt_hour = UnitQuantity(
    'gigawatt_hour',
    1000*MWh,
    symbol='GWh',
    aliases=['gigawatthour', 'gigawatthours', 'gigawatt_hours']
)
E_h = hartree = hartree_energy = UnitQuantity(
    'hartree',
    4.35974394e-18*J,
    symbol='E_h',
    aliases=['hartrees', 'hartree_energy', 'Hartree_energy'],
    doc='relative uncertainty = 2.1e-6'
)

del UnitQuantity, dyne, N, cm, m, s, h

########NEW FILE########
__FILENAME__ = force
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .mass import gram, kg, ounce, lb
from .length import cm, m, ft
from .time import s
from .acceleration import g_0


N = newton = UnitQuantity(
    'newton',
    kg*m/s**2,
    symbol='N',
    aliases=['newtons']
)
dyne = UnitQuantity(
    'dyne',
    gram*cm/s**2,
    symbol='dyn',
    aliases=['dynes']
)
pond = UnitQuantity(
    'pond',
    g_0*kg,
    symbol='p',
    aliases=['ponds']
)
kgf = force_kilogram = kilogram_force = UnitQuantity(
    'kilogram_force',
    kg*g_0,
    symbol='kgf',
    aliases=['force_kilogram']
)
ozf = force_ounce = ounce_force = UnitQuantity(
    'ounce_force',
    ounce*g_0,
    symbol='ozf',
    aliases=['force_ounce']
)
lbf = force_pound = pound_force = UnitQuantity(
    'pound_force',
    lb*g_0,
    symbol='lbf',
    aliases=['force_pound']
)
poundal = UnitQuantity(
    'poundal',
    lb*ft/s**2,
    symbol='pdl',
    aliases=['poundals']
)
gf = gram_force = force_gram = UnitQuantity(
    'gram_force',
    gram*g_0,
    symbol='gf',
    aliases=['force_gram']
)
force_ton = ton_force = UnitQuantity(
    'ton_force',
    2000*force_pound,
    aliases=['force_ton'])
kip = UnitQuantity(
    'kip', 1000*lbf
)

del UnitQuantity, gram, kg, cm, m, s, g_0

########NEW FILE########
__FILENAME__ = frequency
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .angle import revolution
from .time import s, min
from .dimensionless import count


Hz = hertz = rps = UnitQuantity(
    'hertz',
    s**-1,
    symbol='Hz'
)
kHz = kilohertz = UnitQuantity(
    'kilohertz',
    Hz*1000,
    symbol='kHz'
)
MHz = megahertz = UnitQuantity(
    'megahertz',
    kHz*1000,
    symbol='MHz'
)
GHz = gigahertz = UnitQuantity(
    'gigahertz',
    MHz*1000,
    symbol='GHz'
)
rpm = revolutions_per_minute = UnitQuantity(
    'revolutions_per_minute',
    revolution/min,
    symbol='rpm'
)
cps = UnitQuantity(
    'counts_per_second',
    count/s
)

del UnitQuantity, s, min

########NEW FILE########
__FILENAME__ = heat
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .temperature import K, degF
from .length import m, ft
from .power import W
from .energy import BTU
from .time import h


RSI = UnitQuantity(
    'RSI',
    K*m**2/W,
    doc='R-value in SI'
)

clo = clos = UnitQuantity(
    'clo',
    0.155*RSI,
    aliases=['clos']
)

R_value = UnitQuantity(
    'R_value',
    ft**2*degF*h/BTU,
    doc='American customary units'
)


del UnitQuantity, K, degF, m, ft, W, BTU, h

########NEW FILE########
__FILENAME__ = information
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity, UnitInformation, dimensionless
from .time import s

bit = UnitInformation(
    'bit',
    aliases=['bits']
)
B = byte = o = octet = UnitInformation(
    'byte',
    8*bit,
    symbol='B',
    aliases=['bytes', 'o', 'octet', 'octets']
)
Bd = baud = bps = UnitQuantity(
    'baud',
    bit/s,
    symbol='Bd',
)

del UnitQuantity, s, dimensionless

########NEW FILE########
__FILENAME__ = length
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitLength, UnitQuantity

m = meter = metre = UnitLength(
    'meter',
    symbol='m',
    aliases=['meters', 'metre', 'metres']
)
km = kilometer = kilometre = UnitLength(
    'kilometer',
    1000*m,
    symbol='km',
    aliases=['kilometers', 'kilometre', 'kilometres']
)
cm = centimeter = centimetre = UnitLength(
    'centimeter',
    m/100,
    'cm',
    aliases=['centimeters', 'centimetre', 'centimetres']
)
mm = millimeter = millimetre = UnitLength(
    'millimeter',
    m/1000,
    symbol='mm',
    aliases=['millimeters', 'millimetre', 'millimetres']
)
um = micrometer = micrometre = micron = UnitLength(
    'micrometer',
    mm/1000,
    symbol='um',
    u_symbol='µm',
    aliases=[
        'micron', 'microns', 'micrometers', 'micrometre', 'micrometres'
    ]
)
nm = nanometer = nanometre = UnitLength(
    'nanometer',
    um/1000,
    symbol='nm',
    aliases=['nanometers', 'nanometre', 'nanometres']
)
pm = picometer = picometre = UnitLength(
    'picometer',
    nm/1000,
    symbol='pm',
    aliases=['picometers', 'picometre', 'picometres']
)
angstrom = UnitLength(
    'angstrom',
    nm/10,
    u_symbol='Å',
    aliases=['angstroms']
)
fm = femtometer = femtometre = fermi = UnitLength(
    'femtometer',
    pm/1000,
    symbol='fm',
    aliases=['femtometers', 'femtometre', 'femtometres', 'fermi', 'fermis']
)

inch = international_inch = UnitLength(
    'inch',
    2.54*cm,
    symbol='in',
    aliases=['inches', 'international_inch', 'international_inches']
)
ft = foot = international_foot = UnitLength(
    'foot',
    12*inch,
    symbol='ft',
    aliases=['feet', 'international_foot' 'international_feet']
)
mi = mile = international_mile = UnitLength(
    'mile',
    5280*ft,
    symbol='mi',
    aliases=['miles', 'international_mile', 'international_miles']
)
yd = yard = international_yard = UnitLength(
    'yard',
    3*ft,
    symbol='yd',
    aliases=['yards', 'international_yard', 'international_yards']
)
mil = thou = UnitLength(
    'mil',
    inch/1000,
    aliases=['mils', 'thou', 'thous']
)
pc = parsec = UnitLength(
    'parsec',
    3.08568025e16*m,
    symbol='pc',
    aliases=['parsecs'],
    doc='approximate'
)
ly = light_year = UnitLength(
    'light_year',
    9460730472580.8*km,
    symbol='ly',
    aliases=['light_years']
)
au = astronomical_unit = UnitLength(
    'astronomical_unit',
    149597870691*m,
    symbol='au',
    aliases=['astronomical_units'],
    doc='''
    An astronomical unit (abbreviated as AU, au, a.u., or sometimes ua) is a
    unit of length roughly equal to the mean distance between the Earth and
    the Sun. It is approximately 150 million kilometres (93 million miles).

    uncertainty ± 30 m

    http://en.wikipedia.org/wiki/Astronomical_unit
    '''
)

nmi = nautical_mile = UnitLength(
    'nautical_mile',
    1.852e3*m,
    symbol='nmi',
    aliases=['nmile', 'nmiles', 'nautical_miles']
)
pt = printers_point = point = UnitLength(
    'printers_point',
    127*mm/360,
    symbol='point',
    aliases=['printers_points', 'points'],
    doc='pt is reserved for pint'
)
pica = UnitLength(
    'pica',
    12*printers_point,
    aliases=['picas', 'printers_pica', 'printers_picas']
)

US_survey_foot = UnitLength(
    'US_survey_foot',
    1200*m/3937,
    aliases=['US_survey_feet']
)
US_survey_yard = UnitLength(
    'US_survey_yard',
    3*US_survey_foot,
    aliases=['US_survey_yards']
)
US_survey_mile = US_statute_mile = UnitLength(
    'US_survey_mile',
    5280*US_survey_foot,
    aliases=['US_survey_miles', 'US_statute_mile', 'US_statute_miles']
)
rod = pole = perch = UnitLength(
    'rod',
    16.5*US_survey_foot,
    aliases=['rods', 'pole', 'poles', 'perch', 'perches']
)
furlong = UnitLength(
    'furlong',
    660*US_survey_foot,
    aliases=['furlongs']
)
fathom = UnitLength(
    'fathom',
    6*US_survey_foot,
    aliases=['fathoms']
)
chain = UnitLength(
    'chain',
    66*US_survey_foot,
    aliases=['chains']
)
barleycorn = UnitLength(
    'barleycorn',
    inch/3,
    aliases=['barleycorns']
)
arpentlin = UnitLength(
    'arpentlin',
    191.835*ft
)

kayser = wavenumber = UnitQuantity(
    'kayser',
    1/cm,
    aliases=['kaysers', 'wavenumber', 'wavenumbers']
)

del UnitQuantity

########NEW FILE########
__FILENAME__ = mass
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity, UnitMass
from .length import m

kg = kilogram =  UnitMass(
    'kilogram',
    symbol='kg',
    aliases=['kilograms']
)
g = gram = UnitMass(
    'gram',
    kg/1000,
    symbol='g',
    aliases=['grams']
)
mg = milligram = UnitMass(
    'milligram',
    gram/1000,
    symbol='mg',
    aliases=['milligrams']
)
oz = ounce = avoirdupois_ounce = UnitMass(
    'ounce',
    28.349523125*g,
    symbol='oz',
    aliases=['ounces','avoirdupois_ounce', 'avoirdupois_ounces'],
    doc='exact'
)
lb = pound = avoirdupois_pound = UnitMass(
    'pound',
    0.45359237*kg,
    symbol='lb',
    aliases=['pounds', 'avoirdupois_pound', 'avoirdupois_pounds'],
    doc='exact'
)
st = stone = UnitMass(
    'stone',
    14*lb,
    symbol='st',
    doc='As defined in the UK, 1 stone = 14 avoirdupois pounds'
)

carat = UnitMass(
    'carat',
    200*mg,
    aliases=['carats']
)
gr = grain = UnitMass(
    'grain',
    64.79891*mg,
    symbol='gr',
    aliases=['grains']
)
long_hundredweight = UnitMass(
    'long_hundredweight',
    112*lb,
    aliases=['long_hundredweights']
)
short_hundredweight = UnitMass(
    'short_hundredweight',
    100*lb,
    aliases=['short_hundredweights']
) # cwt is used for both short and long hundredweight, so we wont use it
t = metric_ton = tonne = UnitMass(
    'tonne',
    1000*kg,
    symbol='t',
    aliases=['tonnes']
)
dwt = pennyweight = UnitMass(
    'pennyweight',
    24*gr,
    symbol='dwt',
    aliases=['pennyweights']
)
slug = slugs = UnitMass(
    'slug',
    14.59390*kg,
    aliases=['slugs']
)
toz = troy_ounce = apounce = apothecary_ounce = UnitMass(
    'troy_ounce',
    480*gr,
    symbol='toz',
    u_symbol='℥',
    aliases=[
        'apounce', 'apounces', 'apothecary_ounce', 'apothecary_ounces',
        'troy_ounces'
    ]
)
troy_pound = appound = apothecary_pound = UnitMass(
    'troy_pound',
    12*toz,
    symbol='tlb',
    u_symbol='℔',
    aliases=[
        'troy_pounds', 'appound', 'appounds', 'apothecary_pound',
        'apothecary_pounds'
    ]
)
u = amu = atomic_mass_unit = dalton = Da = UnitMass(
    'atomic_mass_unit',
    1.660538782e-27*kg,
    symbol='u',
    aliases=['amu', 'Da', 'dalton'],
    doc='relative uncertainty = 5e-8'
)
scruple = UnitMass(
    'scruple',
    20*gr,
    u_symbol='℈',
    aliases=['scruples']
)
dr = dram = UnitMass(
    'dram',
    oz/16,
    symbol='dr',
    aliases=['drams'],
    doc='avoirdupois dram'
)
drachm = apdram = UnitMass(
    'drachm',
    60*gr,
    u_symbol='  ',
    aliases=['drachms', 'apdram', 'apdrams'],
    doc='also known as the apothecary dram'
)

bag = UnitMass(
    'bag',
    94*lb,
    aliases=['bags']
)

ton = short_ton = UnitMass(
    'short_ton',
    2000*lb,
    aliases=['short_tons']
)
long_ton = UnitMass(
    'long_ton', 2240*lb,
    aliases=['long_tons']
) # both long and short tons are referred to as "ton" so we wont use it

############################################################
##                 Mass per unit length                   ##
############################################################

denier = UnitQuantity(
    'denier',
    g/(9000*m),
    aliases=['deniers']
)
tex = UnitQuantity(
    'tex',
    g/(1000*m),
    aliases=['texs']
)
dtex = UnitQuantity(
    'dtex',
    g/(10000*m),
    aliases=['dtexs']
)

del UnitQuantity, m

########NEW FILE########
__FILENAME__ = power
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .energy import Btu, J
from .time import s, h, min
from .electromagnetism import A, V
from .length import ft
from .force import lbf


W = watt = volt_ampere = UnitQuantity(
    'watt',
    J/s,
    symbol='W',
    aliases=['watts', 'volt_ampere', 'volt_amperes', 'VA']
)
mW = milliwatt = UnitQuantity(
    'milliwatt',
    W/1000,
    symbol='mW',
    aliases=['milliwatts']
)
kW = kilowatt = UnitQuantity(
    'kilowatt',
    1000*W,
    symbol='kW',
    aliases=['kilowatts']
)
MW = megawatt = UnitQuantity(
    'megawatt',
    1000*kW,
    symbol='MW',
    aliases=['megawatts']
)
hp = horsepower = UK_horsepower = British_horsepower = UnitQuantity(
    'horsepower',
    33000*ft*lbf/min,
    symbol='hp',
    aliases=['UK_horsepower', 'British_horsepower']
)
boiler_horsepower = UnitQuantity(
    'boiler_horsepower',
    33475*Btu/h
)
metric_horsepower = UnitQuantity(
    'metric_horsepower',
    0.73549875*kW,
    doc='exact'
)
electric_horsepower = UnitQuantity(
    'electric_horsepower',
    746*W
)
water_horsepower = UnitQuantity(
    'water_horsepower',
    746.043*W,
    doc='exact'
)

refrigeration_ton = ton_of_refrigeration = UnitQuantity(
    'refrigeration_ton',
    12000*Btu/h,
    aliases=['ton_of_refrigeration']
)

del UnitQuantity, Btu, J, s, h, A, V

########NEW FILE########
__FILENAME__ = prefixes

#SI prefixes
yotta = 1e24
zetta = 1e21
exa = 1e18
peta = 1e15
tera = 1e12
giga = 1e9
mega = 1e6
kilo = 1e3
hecto = 1e2
deka = 1e1
deci = 1e-1
centi = 1e-2
milli = 1e-3
micro = 1e-6
nano = 1e-9
pico = 1e-12
femto = 1e-15
atto = 1e-18
zepto = 1e-21

#binary prefixes
kibi = 2**10
mebi = 2**20
gibi = 2**30
tebi = 2**40
pebi = 2**50
exbi = 2**60
zebi = 2**70
yobi = 2**80

########NEW FILE########
__FILENAME__ = pressure
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .acceleration import gravity
from .mass import g, kg, pound
from .length import m, mm, cm, inch, ft
from .force import N, kip


Hg = mercury = conventional_mercury = UnitQuantity(
    'conventional_mercury',
    gravity*13.59510*g/cm**3
)
mercury_60F = UnitQuantity('mercury_60F', gravity*13556.8*kg/m**3)
H2O = h2o = water = conventional_water = UnitQuantity('H2O', gravity*1000*kg/m**3)
water_4C = water_39F = UnitQuantity('water_4C', gravity*999.972*kg/m**3)
water_60F = UnitQuantity('water_60F', gravity*999.001*kg/m**3)

Pa = pascal = UnitQuantity(
    'pascal',
    N/m**2,
    symbol='Pa',
    aliases=['pascals']
)
hPa = hectopascal = UnitQuantity(
    'hectopascal',
    100*Pa,
    symbol='hPa',
)
kPa = kilopascal = UnitQuantity(
    'kilopascal',
    1000*Pa,
    symbol='kPa',
    aliases=['kilopascals']
)
MPa = megapascal = UnitQuantity(
    'megapascal',
    1000*kPa,
    symbol='MPa',
    aliases=['megapascals']
)
GPa = gigapascal = UnitQuantity(
    'gigapascal',
    1000*MPa,
    symbol='GPa',
    aliases=['gigapascals']
)
bar = UnitQuantity(
    'bar',
    100000*pascal,
    aliases=['bars']
)
mb = millibar = UnitQuantity(
    'millibar',
    0.001*bar,
    symbol='mb',
)
kbar = kilobar = UnitQuantity(
    'kilobar',
    1000*bar,
    symbol='kbar',
    aliases=['kilobars']
)
Mbar = kilobar = UnitQuantity(
    'megabar',
    1000*kbar,
    symbol='Mbar',
    aliases=['megabars']
)
Gbar = gigabar = UnitQuantity(
    'gigabar',
    1000*Mbar,
    symbol='Gbar',
    aliases=['gigabars']
)
atm = atmosphere = standard_atmosphere = UnitQuantity(
    'standard_atmosphere',
    101325*pascal,
    symbol='atm',
    aliases=['atmosphere', 'atmospheres', 'standard_atmospheres']
)
at = technical_atmosphere = UnitQuantity(
    'technical_atmosphere',
    kg*gravity/cm**2,
    symbol='at',
    aliases=['technical_atmospheres']
)
torr = UnitQuantity(
    'torr',
    atm/760
)
psi = pound_force_per_square_inch = UnitQuantity(
    'pound_force_per_square_inch',
    pound*gravity/inch**2,
    symbol='psi'
)
ksi = kip_per_square_inch = UnitQuantity(
    'kip_per_square_inch',
    kip/inch**2,
    symbol='ksi'
)
barye = barie = barad = barad = barrie = baryd = UnitQuantity(
    'barye',
    0.1*N/m**2,
    symbol='Ba',
    aliases=[
        'barie', 'baries', 'baryes', 'barad', 'barads', 'barrie', 'baryd',
        'baryed'
    ]
)

mmHg = mm_Hg = millimeter_Hg = millimeter_Hg_0C = UnitQuantity(
    'millimeter_Hg',
    mm*mercury,
    symbol='mmHg',
    aliases=['mm_Hg', 'millimeter_Hg_0C'],
    doc="""
    The pressure exerted at the base of a column of fluid exactly 1 mm high,
    when the density of the fluid is exactly 13.5951 g/cm^3, at a place where
    the acceleration of gravity is exactly 9.80665 m/s^2.

    http://en.wikipedia.org/wiki/Conventional_millimeter_of_mercury
    """
)
cmHg = cm_Hg = centimeter_Hg = UnitQuantity(
    'cmHg',
    cm*Hg,
    aliases=['cm_Hg', 'centimeter_Hg']
)
inHg = in_Hg = inch_Hg = inch_Hg_32F = UnitQuantity(
    'inHg',
    inch*Hg,
    aliases=['in_Hg', 'inch_Hg', 'inch_Hg_32F']
)
inch_Hg_60F = UnitQuantity(
    'inch_Hg_60F',
    inch*mercury_60F
)

inch_H2O_39F = UnitQuantity(
    'inch_H2O_39F',
    inch*water_39F
)
inch_H2O_60F = UnitQuantity(
    'inch_H2O_60F',
    inch*water_60F
)
footH2O = UnitQuantity(
    'footH2O',
    ft*water
)
cmH2O = UnitQuantity(
    'cmH2O',
    cm*water
)
foot_H2O = ftH2O = UnitQuantity(
    'foot_H2O',
    ft*water,
    aliases=['ftH2O']
)

del UnitQuantity, gravity, kg, pound, m, mm, cm, inch, ft, N, kip

########NEW FILE########
__FILENAME__ = radiation
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .time import s
from .mass import kg
from .energy import J
from .electromagnetism import coulomb


Bq = becquerel = UnitQuantity(
    'becquerel',
    1/s,
    symbol='Bq',
    aliases=['becquerels']
)
Ci = curie = UnitQuantity(
    'curie',
    3.7e10*becquerel,
    symbol='Ci',
    aliases=['curies']
)
rd = rutherford = UnitQuantity(
    'rutherford',
    1e6*Bq,
    symbol='Rd',
    aliases=['rutherfords'],
    doc='this unit is obsolete, in favor of 1e6 Bq'
)
Gy = gray = Sv = sievert = UnitQuantity(
    'gray',
    J/kg,
    symbol='Gy',
    aliases=['grays', 'Sv', 'sievert', 'sieverts']
)
rem = UnitQuantity(
    'rem',
    1e-2*sievert,
    aliases=['rems']
)
rads = UnitQuantity(
    'rads',
    1e-2*gray,
    doc='''
    rad is commonly used symbol for radian. 
    rads unit of radiation is deprecated.
    '''
)
R = roentgen = UnitQuantity(
    'roentgen',
    2.58e-4*coulomb/kg,
    symbol='R',
    aliases=['roentgens']
)

del UnitQuantity, s, kg, J, coulomb

########NEW FILE########
__FILENAME__ = substance
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitSubstance

mol = mole = UnitSubstance(
    'mole',
    symbol='mol'
)

########NEW FILE########
__FILENAME__ = temperature
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitTemperature


K = degK = kelvin = Kelvin = UnitTemperature(
    'Kelvin',
    symbol='K',
    aliases=['degK', 'kelvin']
)
degR = rankine = Rankine = UnitTemperature(
    'Rankine',
    K/1.8,
    symbol='degR',
    u_symbol='°R',
    aliases=['rankine']
)
degC = celsius = Celsius = UnitTemperature(
    'Celsius',
    K,
    symbol='degC',
    u_symbol='°C',
    aliases=['celsius'],
    doc='''
    Unicode has special compatibility characters for ℃, but its use is
    discouraged by the unicode consortium.
    '''
)
degF = fahrenheit = Fahrenheit = UnitTemperature(
    'Fahrenheit',
    degR,
    symbol='degF',
    u_symbol='°F',
    aliases=['fahrenheit'],
    doc='''
    Unicode has special compatibility characters for ℉, but its use is
    discouraged by the unicode consortium.
    '''
)

########NEW FILE########
__FILENAME__ = time
# -*- coding: utf-8 -*-
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity, UnitTime


s = sec = second = UnitTime(
    'second',
    symbol='s',
    aliases=['sec', 'seconds']
)
ms = millisecond = UnitTime(
    'millisecond',
    s/1000,
    'ms',
    aliases=['milliseconds']
)
us = microsecond = UnitTime(
    'microsecond',
    ms/1000,
    symbol='us',
    u_symbol='µs',
    aliases=['microseconds']
)
ns = nanosecond = UnitTime(
    'nanosecond',
    us/1000,
    symbol='ns',
    aliases=['nanoseconds']
)
ps = picosecond = UnitTime(
    'picosecond',
    ns/1000,
    symbol='ps',
    aliases=['picoseconds']
)
fs = femtosecond = UnitTime(
    'femtosecond',
    ps/1000,
    symbol='fs',
    aliases=['femtoseconds']
)
attosecond = UnitTime(
    'attosecond',
    fs/1000,
    symbol='as',
    aliases=['attoseconds']
) # as is a keyword in python2.6

min = minute = UnitTime(
    'minute',
    60*s,
    symbol='min',
    aliases=['minutes']
)
h = hr = hour = UnitTime(
    'hour',
    60*min,
    symbol='h',
    aliases=['hr', 'hours']
)
d = day = UnitTime(
    'day',
    24*hr,
    symbol='d',
    aliases=['days']
)
week = UnitTime(
    'week',
    7*day,
    aliases=['weeks']
)
fortnight = UnitTime(
    'fortnight',
    2*week,
    aliases=['fortnights']
)
yr = year = tropical_year = a = UnitTime(
    'year',
    31556925.9747*s,
    symbol='yr',
    aliases=['a', 'years', 'tropical_year', 'tropical_years'],
    doc='a is an acceptable alias for year, short for anno'
)
month = UnitTime(
    'month',
    yr/12,
    aliases=['months']
)
shake = UnitTime(
    'shake',
    1e-8*s,
    aliases=['shakes']
)

sidereal_day = UnitTime(
    'sidereal_day',
    day/1.00273790935079524,
    aliases=['sidereal_days'],
    doc='''
    approximate.

    http://en.wikipedia.org/wiki/Sidereal_time
    '''
)
sidereal_hour = UnitTime(
    'sidereal_hour',
    sidereal_day/24,
    aliases=['sidereal_hours']
)
sidereal_minute = UnitTime(
    'sidereal_minute',
    sidereal_hour/60,
    aliases=['sidereal_minutes']
)
sidereal_second = UnitTime(
    'sidereal_second',
    sidereal_minute/60,
    aliases=['sidereal_seconds']
)
sidereal_year = UnitTime(
    'sidereal_year',
    366.25636042*sidereal_day,
    aliases=['sidereal_years'],
    doc='http://en.wikipedia.org/wiki/Sidereal_year'
)
sidereal_month = UnitTime(
    'sidereal_month',
    27.321661*day,
    aliases=['sidereal_months'],
    doc='http://en.wikipedia.org/wiki/Month#Sidereal_month'
)

tropical_month = UnitTime(
    'tropical_month',
    27.321582*day,
    aliases=['tropical_months']
)
synodic_month = lunar_month = UnitTime(
    'synodic_month',
    29.530589*day,
    aliases=['synodic_months', 'lunar_month', 'lunar_months'],
    doc='''
    long-term average. 

    http://en.wikipedia.org/wiki/Month#Synodic_month
    '''
)
common_year = UnitTime(
    'common_year',
    365*day,
    aliases=['common_years']
)
leap_year = UnitTime(
    'leap_year',
    366*day,
    aliases=['leap_years']
)
Julian_year = UnitTime(
    'Julian_year',
    365.25*day,
    aliases=['Julian_years']
)
Gregorian_year = UnitTime(
    'Gregorian_year',
    365.2425*day,
    aliases=['Gregorian_years']
)

millenium = UnitTime(
    'millenium',
    1000*year,
    aliases=['millenia']
)
eon = UnitTime(
    'eon',
    1e9*year,
    aliases=['eons']
)

work_year = UnitQuantity(
    'work_year',
    2056*hour,
    aliases=['work_years']
)
work_month = UnitQuantity(
    'work_month',
    work_year/12,
    aliases=['work_months']
)

del UnitQuantity

########NEW FILE########
__FILENAME__ = velocity
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .length import m, nmi
from .time import s, h


c = speed_of_light = UnitQuantity(
    'speed_of_light',
    299792458*m/s,
    symbol='c',
    doc='exact'
)
kt = knot = knot_international = international_knot = UnitQuantity(
    'nautical_miles_per_hour',
    nmi/h,
    symbol='kt',
    aliases=['knot', 'knots', 'knot_international', 'international_knot']
)

del UnitQuantity, m, nmi, s, h

########NEW FILE########
__FILENAME__ = viscosity
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .time import s
from .length import m
from .pressure import Pa


P = poise = UnitQuantity(
    'poise',
    1e-1*Pa*s,
    symbol='P'
)
cP = centipoise = UnitQuantity(
    'centipoise',
    P/100,
    symbol='cP'
)
St = stokes = UnitQuantity(
    'stokes',
    1e-4*m**2/s,
    symbol='St'
)
rhe = UnitQuantity(
    'rhe',
    10/(Pa*s)
)

del UnitQuantity, s, m, Pa

########NEW FILE########
__FILENAME__ = volume
"""
"""
from __future__ import absolute_import

from ..unitquantity import UnitQuantity
from .length import cm, m, foot, inch
from .area import acre

l = L = liter = litre = UnitQuantity(
    'liter',
    1e-3*m**3,
    symbol='L',
    aliases=['l', 'liters', 'litre', 'litres']
)
mL = milliliter = millilitre = UnitQuantity(
    'milliliter',
    liter/1000,
    symbol='mL',
    aliases=['ml', 'milliliters', 'millilitre', 'millilitres']
)
kL = kiloliter = kilolitre = UnitQuantity(
    'kiloliter',
    liter*1000,
    symbol='kL',
    aliases=['kl', 'kiloliters', 'kilolitre', 'kilolitres']
)
ML = megaliter = megalitre = UnitQuantity(
    'megaliter',
    kiloliter*1000,
    symbol='ML',
    aliases=['Ml', 'megaliters', 'megalitre', 'megalitres']
)
GL = gigaliter = gigalitre = UnitQuantity(
    'gigaliter',
    megaliter*1000,
    symbol='GL',
    aliases=['Gl', 'gigaliters', 'gigalitre', 'gigalitres']
)
cc = cubic_centimeter = milliliter = UnitQuantity(
    'cubic_centimeter',
    cm**3,
    symbol='cc',
    aliases=['cubic_centimeters']
)

stere = UnitQuantity(
    'stere',
    m**3,
    aliases=['steres']
)
gross_register_ton = register_ton = UnitQuantity(
    'gross_register_ton',
    100*foot**3,
    symbol='GRT',
    aliases=['gross_register_tons', 'register_ton', 'register_tons']
)

acre_foot = UnitQuantity(
    'acre_foot',
    acre*foot,
    aliases=['acre_feet']
)
board_foot = UnitQuantity(
    'board_foot',
    foot**2*inch,
    symbol='FBM',
    aliases=['board_feet'])
bu = bushel = US_bushel = UnitQuantity(
    'US_bushel',
    2150.42*inch**3,
    symbol='bu'
)
US_dry_gallon = UnitQuantity(
    'US_dry_gallon',
    bushel/8,
)
gallon = liquid_gallon = US_liquid_gallon = UnitQuantity(
    'US_liquid_gallon',
    231*inch**3,
    aliases=[
        'gallon', 'gallons', 'liquid_gallon', 'liquid_gallons',
        'US_liquid_gallons'
    ],
)
dry_quart = US_dry_quart = UnitQuantity(
    'US_dry_quart',
    US_dry_gallon/4,
    aliases=['dry_quart', 'dry_quarts', 'US_dry_quarts']
)
dry_pint = US_dry_pint = UnitQuantity(
    'US_dry_pint',
    US_dry_quart/2,
    aliases=['dry_pint', 'dry_pints', 'US_dry_pints']
)
quart = liquid_quart = US_liquid_quart = UnitQuantity(
    'US_liquid_quart',
    US_liquid_gallon/4,
    symbol='quart',
    aliases=['quarts', 'liquid_quart', 'liquid_quarts', 'US_liquid_quarts']
)
pt = pint = liquid_pint = US_liquid_pint = UnitQuantity(
    'US_liquid_pint',
    US_liquid_quart/2,
    symbol='pt',
    aliases=[
        'pint', 'pints', 'liquid_pint', 'liquid_pints', 'US_liquid_pints'
    ],
)
cup = US_liquid_cup = UnitQuantity(
    'cup',
    US_liquid_pint/2,
    aliases=['cups', 'US_liquid_cup', 'US_liquid_cups']
)
gill = US_liquid_gill = UnitQuantity(
    'US_liquid_gill',
    US_liquid_cup/2,
    symbol='gill',
    aliases=['gills', 'US_liquid_gills']
)
floz = fluid_ounce = US_fluid_ounce = US_liquid_ounce = UnitQuantity(
    'US_fluid_ounce',
    US_liquid_gill/4,
    symbol='fl_oz',
    aliases=[
        'fluid_ounce', 'fluid_ounces', 'US_fluid_ounces', 'US_liquid_ounce',
        'US_liquid_ounces'
    ]
)

Imperial_bushel = UnitQuantity(
    'Imperial_bushel',
    36.36872*liter,
    doc='exact'
)
UK_liquid_gallon = Canadian_liquid_gallon = UnitQuantity(
    'UK_liquid_gallon',
    4.54609*liter,
    aliases=[
        'UK_liquid_gallons', 'Canadian_liquid_gallon',
        'Canadian_liquid_gallons'
    ],
    doc='exact'
)
UK_liquid_quart = UnitQuantity(
    'UK_liquid_quart',
    UK_liquid_gallon/4,
    aliases=['UK_liquid_quarts']
)
UK_liquid_pint = UnitQuantity(
    'UK_liquid_pint',
    UK_liquid_quart/2,
    aliases=['UK_liquid_pints']
)
UK_liquid_cup = UnitQuantity(
    'UK_liquid_cup',
    UK_liquid_pint/2,
    aliases=['UK_liquid_cups']
)
UK_liquid_gill = UnitQuantity(
    'UK_liquid_gill',
    UK_liquid_cup/2,
    aliases=['UK_liquid_gills']
)
UK_fluid_ounce = UK_liquid_ounce = UnitQuantity(
    'UK_fluid_ounce',
    UK_liquid_gill/5, # not a mistake
    aliases=['UK_fluid_ounces', 'UK_liquid_ounce', 'UK_liquid_ounces']
)

bbl = barrel = UnitQuantity(
    'barrel',
    42*US_liquid_gallon,
    symbol='bbl'
)
tbsp = Tbsp = Tblsp = tblsp = tbs = Tbl = tablespoon = UnitQuantity(
    'tablespoon',
    US_fluid_ounce/2,
    symbol='tbsp',
    aliases=['Tbsp', 'Tblsp', 'Tbl', 'tblsp', 'tbs', 'tablespoons']
)
tsp = teaspoon = UnitQuantity(
    'teaspoon',
    tablespoon/3,
    symbol='tsp',
    aliases=['teaspoons']
)

pk = peck = UnitQuantity(
    'peck',
    bushel/4,
    symbol='pk',
    aliases=['pecks']
)

fldr = fluid_dram = fluidram = UnitQuantity(
    'fluid_dram',
    floz/8,
    symbol='fldr',
    aliases=['fluid_drams', 'fluidram', 'fluidrams']
)

firkin = UnitQuantity(
    'firkin',
    barrel/4
)

del UnitQuantity, cm, m

########NEW FILE########
__FILENAME__ = version

__version__ = '0.10.1'

########NEW FILE########
