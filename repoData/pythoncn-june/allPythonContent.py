__FILENAME__ = env
from __future__ import with_statement
import os
import sys
from alembic import context
from sqlalchemy import engine_from_config, pool
from logging.config import fileConfig
from alembic.config import Config

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = Config("alembic.ini")

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
cwd = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.append(cwd)
from june.models import db
from wsgi import application as app
# set the database url
config.set_main_option(
    'sqlalchemy.url',
    app.config.get('SQLALCHEMY_DATABASE_URI')
)
target_metadata = db.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(url=url)

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    engine = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix='sqlalchemy.',
        poolclass=pool.NullPool
    )

    connection = engine.connect()
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    try:
        with context.begin_transaction():
            context.run_migrations()
    finally:
        connection.close()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

########NEW FILE########
__FILENAME__ = 43a5cdca0a62_node_feature
"""Node feature

Revision ID: 43a5cdca0a62
Revises: f08sa66d495
Create Date: 2013-12-09 12:09:41.969339

"""

# revision identifiers, used by Alembic.
revision = '43a5cdca0a62'
down_revision = 'f08sa66d495'

from alembic import op
import sqlalchemy as sa


def upgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.add_column('node', sa.Column('mayor', sa.Integer(), nullable=True))
    op.add_column('node', sa.Column('on_home', sa.Boolean(), nullable=True))
    ### end Alembic commands ###


def downgrade():
    ### commands auto generated by Alembic - please adjust! ###
    op.drop_column('node', 'on_home')
    op.drop_column('node', 'mayor')
    ### end Alembic commands ###

########NEW FILE########
__FILENAME__ = 4ad568a7a84e_liketopic
"""LikeTopic

Revision ID: 4ad568a7a84e
Revises: 43a5cdca0a62
Create Date: 2013-12-12 12:35:12.253544

"""

# revision identifiers, used by Alembic.
revision = '4ad568a7a84e'
down_revision = '43a5cdca0a62'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.create_table(
        'like_topic',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('account_id', sa.Integer(), nullable=False),
        sa.Column('topic_id', sa.Integer(), nullable=False),
        sa.Column('created', sa.DateTime(), nullable=True),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint(
            'account_id', 'topic_id', name='uc_account_like_topic'
        )
    )


def downgrade():
    op.drop_table('like_topic')

########NEW FILE########
__FILENAME__ = f08db66d495_init
"""init

Revision ID: f08sa66d495
Revises: None
Create Date: 2013-08-25 21:06:51.286996

"""

# revision identifiers, used by Alembic.
revision = 'f08sa66d495'
down_revision = None

from alembic import op
import sqlalchemy as sa


def create_account():
    op.create_table(
        'account',
        sa.Column('id', sa.Integer, primary_key=True),
        sa.Column('username', sa.String(40), unique=True, index=True,
                  nullable=False),
        sa.Column('email', sa.String(200), nullable=False, unique=True,
                  index=True),
        sa.Column('password', sa.String(100), nullable=False),

        sa.Column('screen_name', sa.String(80)),
        sa.Column('description', sa.String(400)),
        sa.Column('city', sa.String(200)),
        sa.Column('website', sa.String(400)),

        sa.Column('role', sa.String(10)),
        sa.Column('active', sa.DateTime, index=True),
        sa.Column('created', sa.DateTime),
        sa.Column('token', sa.String(20)),
    )


def create_node():
    op.create_table(
        'node',
        sa.Column('id', sa.Integer, primary_key=True),
        sa.Column('title', sa.String(100), nullable=False),
        sa.Column('urlname', sa.String(40), unique=True, index=True),
        sa.Column('description', sa.Text),
        sa.Column('topic_count', sa.Integer),
        sa.Column('role', sa.String(10)),
        sa.Column('created', sa.DateTime),
        sa.Column('updated', sa.DateTime, index=True),
    )


def create_node_status():
    op.create_table(
        'node_status',
        sa.Column('node_id', sa.Integer, primary_key=True),
        sa.Column('account_id', sa.Integer, primary_key=True),
        sa.Column('topic_count', sa.Integer),
        sa.Column('reputation', sa.Integer),
        sa.Column('updated', sa.DateTime),
    )


def create_topic():
    op.create_table(
        'topic',
        sa.Column('id', sa.Integer, primary_key=True),
        sa.Column('account_id', sa.Integer, nullable=False, index=True),
        sa.Column('node_id', sa.Integer, nullable=False, index=True),

        sa.Column('title', sa.String(100), nullable=False),
        sa.Column('content', sa.Text),

        sa.Column('hits', sa.Integer),
        sa.Column('reply_count', sa.Integer),

        sa.Column('created', sa.DateTime),
        sa.Column('updated', sa.DateTime, index=True),
    )


def create_reply():
    op.create_table(
        'reply',
        sa.Column('id', sa.Integer, primary_key=True),
        sa.Column('account_id', sa.Integer, nullable=False),
        sa.Column('topic_id', sa.Integer, index=True, nullable=False),
        sa.Column('content', sa.Text),
        sa.Column('created', sa.DateTime),
        sa.Column('flags', sa.Integer),
    )


def upgrade():
    create_account()
    create_node()
    create_node_status()
    create_topic()
    create_reply()


def downgrade():
    op.drop_table('account')
    op.drop_table('node')
    op.drop_table('node_status')
    op.drop_table('topic')
    op.drop_table('reply')

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# june documentation build configuration file, created by
# sphinx-quickstart on Thu Feb 21 18:59:14 2013.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = []

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'june'
copyright = u'2013, Hsiaoming Yang'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '0.1.0'
# The full version, including alpha/beta/rc tags.
release = '0.1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'junedoc'


# -- Options for LaTeX output --------------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'june.tex', u'june Documentation',
   u'Hsiaoming Yang', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'june', u'june Documentation',
     [u'Hsiaoming Yang'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ------------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'june', u'june Documentation',
   u'Hsiaoming Yang', 'june', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

########NEW FILE########
__FILENAME__ = dev_config
#!/usr/bin/env python

import os
rootdir = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))

# site inform
SITE_TITLE = 'Python China'
SITE_SIDEBAR = os.path.join(rootdir, 'data', 'sidebar.html')
SITE_ABOUT = '/node/about'
# SITE_ANALYTICS = 'UA-xxx-xxx'


# This is a config file for development
DEBUG = True
SECRET_KEY = 'secret-key-for-development'

# cache
CACHE_TYPE = 'filesystem'
CACHE_DIR = os.path.join(rootdir, 'data', 'cache')

# babel settings
BABEL_DEFAULT_LOCALE = 'zh'
BABEL_SUPPORTED_LOCALES = ['zh']

########NEW FILE########
__FILENAME__ = gunicorn
#!/usr/bin/env python

import gevent.monkey
gevent.monkey.patch_all()

import multiprocessing

bind = 'unix:/home/{{user}}/var/run/june.sock'

workers = multiprocessing.cpu_count() * 2 + 1
worker_class = 'egg:gunicorn#gevent'

# you should change this
user = '{{user}}'

# maybe you like error
loglevel = 'warning'
errorlog = '-'

secure_scheme_headers = {
    'X-SCHEME': 'https',
}
x_forwarded_for_header = 'X-FORWARDED-FOR'

########NEW FILE########
__FILENAME__ = fabfile
# coding: utf-8

from fabric.api import env, local, cd, run
from fabric.operations import put

env.user = 'www'
env.hosts = ['python-china.org']
# env.password


def prepare():
    """Prepare server for installation."""
    run('mkdir -p ~/venv')
    run('virtualenv ~/venv/june')
    run('mkdir -p ~/apps/june/public/static')


def tarball():
    """Create tarball for june."""
    local('make static')
    local('python setup.py sdist --formats=gztar', capture=False)


def upload():
    """Upload tarball to the server."""
    dist = local('python setup.py --fullname', capture=True).strip()
    run('mkdir -p ~/tmp/june')

    put('dist/%s.tar.gz' % dist, '~/tmp/june.tar.gz')
    with cd('~/tmp/june'):
        run('tar xzf ~/tmp/june.tar.gz')


def install():
    """Install june package."""
    dist = local('python setup.py --fullname', capture=True).strip()
    with cd('~/tmp/june/%s' % dist):
        run('~/venv/june/bin/python setup.py install')


def clean():
    """Clean packages on server."""
    run('rm -fr ~/tmp/june')
    run('rm -f ~/tmp/june.tar.gz')


def update():
    """Update assets"""
    dist = local('python setup.py --fullname', capture=True).strip()
    tmpdir = '~/tmp/june/%s' % dist
    run('cp -r %s/june/public ~/apps/june/' % tmpdir)


def upgrade():
    """Upgrade database"""
    dist = local('python setup.py --fullname', capture=True).strip()
    tmpdir = '~/tmp/june/%s' % dist
    run('cp %s/alembic.ini ~/apps/june/' % tmpdir)
    run('rm -fr ~/apps/june/alembic')
    run('cp -r %s/alembic ~/apps/june/' % tmpdir)
    with cd('~/apps/june'):
        run('~/venv/june/bin/alembic upgrade head')


def restart():
    """Restart remote server"""
    run('supervisorctl pid june | xargs kill -HUP')

########NEW FILE########
__FILENAME__ = app
#!/usr/bin/env python

import os
import time
import datetime
import logging
import hashlib
from flask import request, g
from flask_mail import Mail
from ._flask import Flask
from .models import db, cache, get_site_status


def create_app(config=None):
    app = Flask(
        __name__,
        template_folder='templates',
    )
    app.config.from_pyfile('_settings.py')

    if 'JUNE_SETTINGS' in os.environ:
        app.config.from_envvar('JUNE_SETTINGS')

    if isinstance(config, dict):
        app.config.update(config)
    elif config:
        app.config.from_pyfile(os.path.abspath(config))

    app.static_folder = app.config.get('STATIC_FOLDER')
    app.config.update({'SITE_TIME': datetime.datetime.utcnow()})

    register_hooks(app)
    register_jinja(app)
    register_database(app)

    Mail(app)
    register_babel(app)
    register_routes(app)
    register_logger(app)
    return app


def register_database(app):
    """Database related configuration."""
    #: prepare for database
    db.init_app(app)
    db.app = app
    #: prepare for cache
    cache.init_app(app)


def register_hooks(app):
    """Hooks for request."""
    from .utils.user import get_current_user

    @app.before_request
    def load_current_user():
        g.user = get_current_user()
        if g.user and g.user.is_staff:
            g._before_request_time = time.time()

    @app.after_request
    def rendering_time(response):
        if hasattr(g, '_before_request_time'):
            delta = time.time() - g._before_request_time
            response.headers['X-Render-Time'] = delta * 1000
        return response


def register_routes(app):
    from .handlers import front, account, node, topic, user, admin
    app.register_blueprint(account.bp, url_prefix='/account')
    app.register_blueprint(node.bp, url_prefix='/node')
    app.register_blueprint(topic.bp, url_prefix='/topic')
    app.register_blueprint(user.bp, url_prefix='/user')
    app.register_blueprint(admin.bp, url_prefix='/admin')
    app.register_blueprint(front.bp, url_prefix='')
    return app


def register_jinja(app):
    from . import filters
    from .handlers.admin import load_sidebar

    if not hasattr(app, '_static_hash'):
        app._static_hash = {}

    def static_url(filename):
        if app.testing:
            return filename

        if filename in app._static_hash:
            return app._static_hash[filename]

        with open(os.path.join(app.static_folder, filename), 'r') as f:
            content = f.read()
            hsh = hashlib.md5(content).hexdigest()

        app.logger.info('Generate %s md5sum: %s' % (filename, hsh))
        prefix = app.config.get('SITE_STATIC_PREFIX', '/static/')
        value = '%s%s?v=%s' % (prefix, filename, hsh[:5])
        app._static_hash[filename] = value
        return value

    @app.context_processor
    def register_context():
        return dict(
            static_url=static_url,
            db=dict(
                site_status=get_site_status,
                site_sidebar=load_sidebar,
            ),
        )

    app.jinja_env.filters['markdown'] = filters.markdown
    app.jinja_env.filters['timesince'] = filters.timesince
    app.jinja_env.filters['xmldatetime'] = filters.xmldatetime


def register_babel(app):
    """Configure Babel for internationality."""
    from flask_babel import Babel

    babel = Babel(app)
    supported = app.config.get('BABEL_SUPPORTED_LOCALES', ['en', 'zh'])
    default = app.config.get('BABEL_DEFAULT_LOCALE', 'en')

    @babel.localeselector
    def get_locale():
        return request.accept_languages.best_match(supported, default)


def register_logger(app):
    """Track the logger for production mode."""
    if app.debug:
        return
    handler = logging.StreamHandler()
    handler.setLevel(logging.ERROR)
    app.logger.addHandler(handler)

########NEW FILE########
__FILENAME__ = filters
# coding: utf-8
"""
    june.filters
    ~~~~~~~~~~~~

    Built-in filters for June.

    :copyright: (c) 2013 by Hsiaoming Yang
"""

import re
import datetime
import misaka as m
from markupsafe import escape
from pygments import highlight
from pygments.lexers import get_lexer_by_name
from pygments.formatters import HtmlFormatter
from flask_babel import gettext as _


def _iframe(src, width=650, height=365, content=None, link=None):
    """Create an iframe html snippet."""
    html = (
        '<iframe width="%s" height="%s" src="%s" '
        'frameborder="0" allowfullscreen></iframe>'
    ) % (width, height, src)
    if not content:
        return html
    if link:
        content = '<a href="%s">%s</a>' % (link, content)
    return '<figure>%s<figcaption>%s</figcaption></figure>' % (
        html, content
    )


def youtube(link):
    """Find youtube player URL."""
    pattern = r'http://www\.youtube\.com\/watch\?v=([a-zA-Z0-9\-\_]+)'
    match = re.match(pattern, link)
    if not match:
        pattern = r'http:\/\/youtu.be\/([a-zA-Z0-9\-\_]+)'
        match = re.match(pattern, link)
    if not match:
        return None
    return 'http://www.youtube.com/embed/%s' % match.group(1)


def vimeo(link):
    """Find vimeo player URL."""
    pattern = r'https?:\/\/vimeo\.com\/([\d]+)'
    match = re.match(pattern, link)
    if not match:
        return None
    return 'https://player.vimeo.com/video/%s' % match.group(1)


def youku(link):
    """Find youku player URL."""
    pattern = r'http:\/\/v\.youku\.com\/v_show/id_([\w]+)\.html'
    match = re.match(pattern, link)
    if not match:
        return None
    return 'http://player.youku.com/embed/%s' % match.group(1)


def gist(link, content=None):
    """Render gist script."""
    pattern = r'(https?:\/\/gist\.github\.com\/.+\d+)'
    match = re.match(pattern, link)
    if not match:
        return None
    html = '<script src="%(link)s.js"></script>' % {'link': match.group(1)}
    if not content:
        return html
    return '<figure>%s<figcaption>%s</figcaption></figure>' % (
        html, content
    )


def embed(link, width=650, height=366, content=None):
    src = youtube(link)
    if src:
        return _iframe(src, width, height, content, link)
    src = vimeo(link)
    if src:
        return _iframe(src, width, height, content, link)
    src = youku(link)
    if src:
        return _iframe(src, width, height, content, link)
    return None


class BaseRenderer(m.HtmlRenderer):
    def autolink(self, link, is_email):
        if is_email:
            return '<a href="mailto:%(link)s">%(link)s</a>' % {'link': link}
        html = embed(link)
        if html:
            return html
        content = link.replace('http://', '').replace('https://', '')
        return '<a href="%s">%s</a>' % (link, content)

    def link(self, link, title, content):
        width = 650
        height = 366
        if title:
            # title can descibe height and width: 650 x 366
            pattern = r'(\d{3,4})[^\d]+(\d{3})'
            match = re.match(pattern, title)
            if match:
                width = match.group(1)
                height = match.group(2)
        html = embed(link, width, height, content)
        if html:
            return html
        html = '<a href="%s"' % link
        if title:
            html = '%s title="%s"' % (html, title)
        html = '%s>%s</a>' % (html, content)
        return html

    def image(self, link, title, alt_text):
        html = '<img src="%s" alt="%s" />' % (link, alt_text)
        if not title:
            return html
        return '<figure>%s<figcaption>%s</figcaption></figure>' % (
            html, title
        )

    def paragraph(self, content):
        pattern = r'<figure>.*</figure>'
        if re.match(pattern, content):
            return content
        # a single image in this paragraph
        pattern = r'^<img[^>]+>$'
        if re.match(pattern, content):
            return '<figure>%s</figure>' % content

        pattern = re.compile(r'\s@(\w+)')
        content = pattern.sub(r' <a href="/user/\1">@\1</a>', content)
        pattern = re.compile(r'^@(\w+)')
        content = pattern.sub(r'<a href="/user/\1">@\1</a>', content)
        return '<p>%s</p>' % content

    def block_quote(self, content):
        pattern = r'^--([^<]+)(.*)$'
        match = re.search(pattern, content, re.M | re.U)
        if not match:
            return '<blockquote>%s</blockquote>' % content
        text = match.group(1).strip()
        pattern = r'%s$' % match.group(0)
        content = re.sub(pattern, match.group(2), content)
        return (
            '<blockquote class="cite-quote">'
            '%s<cite>%s</cite>'
            '</blockquote>'
        ) % (content, text)


class HighlightRenderer(BaseRenderer):
    def autolink(self, link, is_email):
        html = gist(link)
        if html:
            return html
        return super(HighlightRenderer, self).autolink(link, is_email)

    def link(self, link, title, content):
        html = gist(link, content)
        if html:
            return html
        return super(HighlightRenderer, self).link(link, title, content)

    def block_code(self, text, lang):
        if not lang:
            return u'<pre><code>%s</code></pre>' % escape(text)

        inlinestyles = False
        linenos = False
        if hasattr(self, '_inlinestyles'):
            inlinestyles = self._inlinestyles
        if hasattr(self, '_linenos'):
            linenos = self._linenos

        try:
            lexer = get_lexer_by_name(lang, stripall=True)
            formatter = HtmlFormatter(
                noclasses=inlinestyles, linenos=linenos
            )
            code = highlight(text, lexer, formatter)
            if linenos:
                return '<div class="highlight-wrapper">%s</div>' % code
            return code
        except:
            return '<pre class="%s"><code>%s</code></pre>' % (
                lang, escape(text)
            )


class PlainRenderer(BaseRenderer):
    def header(self, text, level):
        return '<div class="md-h%d">%s</div>' % (level, text)


def markdown(text, renderer='highlight', inlinestyles=False, linenos=False):
    """Markdown filter for writeup.

    :param text: the content to be markdownify
    :param highlight: highlight the code block or not
    :param inlinestyles: highlight the code with inline styles
    :param linenos: show linenos of the highlighted code
    """
    if not text:
        return u''

    flags = m.HTML_ESCAPE
    if renderer == 'highlight':
        r = HighlightRenderer(flags=flags)
        r._inlinestyles = inlinestyles
        r._linenos = linenos
    elif renderer == 'plain':
        r = PlainRenderer(flags=flags)
    else:
        r = BaseRenderer(flags=flags)

    extensions = (
        m.EXT_NO_INTRA_EMPHASIS | m.EXT_FENCED_CODE | m.EXT_AUTOLINK |
        m.EXT_TABLES | m.EXT_STRIKETHROUGH | m.EXT_SUPERSCRIPT
    )
    md = m.Markdown(r, extensions=extensions)
    return md.render(text)


def timesince(value):
    now = datetime.datetime.utcnow()
    delta = now - value
    if delta.days > 365:
        return _('%(num)i years ago', num=delta.days / 365)
    if delta.days > 30:
        return _('%(num)i months ago', num=delta.days / 30)
    if delta.days > 0:
        return _('%(num)i days ago', num=delta.days)
    if delta.seconds > 3600:
        return _('%(num)i hours ago', num=delta.seconds / 3600)
    if delta.seconds > 60:
        return _('%(num)i minutes ago', num=delta.seconds / 60)
    return _('just now')


def xmldatetime(value):
    if not isinstance(value, datetime.datetime):
        return value
    return value.strftime('%Y-%m-%dT%H:%M:%SZ')

########NEW FILE########
__FILENAME__ = account
# coding: utf-8

from flask import current_app
from wtforms import TextField, PasswordField, BooleanField
from wtforms import TextAreaField
from wtforms.fields.html5 import EmailField, URLField
from wtforms.validators import DataRequired, Email, Length, Regexp
from wtforms.validators import Optional, URL
from flask_babel import lazy_gettext as _

from ._base import BaseForm
from ..models import Account


__all__ = [
    'SignupForm', 'SigninForm', 'SettingForm',
    'FindForm', 'ResetForm',
]


RESERVED_WORDS = [
    'root', 'admin', 'bot', 'robot', 'master', 'webmaster',
    'account', 'people', 'user', 'users', 'project', 'projects',
    'search', 'action', 'favorite', 'like', 'love', 'none',
    'team', 'teams', 'group', 'groups', 'organization',
    'organizations', 'package', 'packages', 'org', 'com', 'net',
    'help', 'doc', 'docs', 'document', 'documentation', 'blog',
    'bbs', 'forum', 'forums', 'static', 'assets', 'repository',

    'public', 'private',
    'mac', 'windows', 'ios', 'lab',
]


class SignupForm(BaseForm):
    username = TextField(
        _('Username'), validators=[
            DataRequired(), Length(min=3, max=20),
            Regexp(r'^[a-z0-9A-Z]+$')
        ], description=_('English Characters Only.'),
    )
    email = EmailField(
        _('Email'), validators=[DataRequired(), Email()]
    )
    password = PasswordField(
        _('Password'), validators=[DataRequired()]
    )

    def validate_username(self, field):
        data = field.data.lower()
        if data in RESERVED_WORDS:
            raise ValueError(_('This name is a reserved name.'))
        if data in current_app.config.get('RESERVED_WORDS', []):
            raise ValueError(_('This name is a reserved name.'))
        if Account.query.filter_by(username=data).count():
            raise ValueError(_('This name has been registered.'))

    def validate_email(self, field):
        if Account.query.filter_by(email=field.data.lower()).count():
            raise ValueError(_('This email has been registered.'))

    def save(self, role=None):
        user = Account(**self.data)
        if role:
            user.role = role
        user.save()
        return user


class SigninForm(BaseForm):
    account = TextField(
        _('Account'),
        validators=[DataRequired(), Length(min=3, max=200)],
        description=_('Username or Email')
    )
    password = PasswordField(
        _('Password'), validators=[DataRequired()]
    )
    permanent = BooleanField(_('Remember me for a month.'))

    def validate_password(self, field):
        account = self.account.data
        if '@' in account:
            user = Account.query.filter_by(email=account).first()
        else:
            user = Account.query.filter_by(username=account).first()

        if not user:
            raise ValueError(_('Wrong account or password'))
        if user.check_password(field.data):
            self.user = user
            return user
        raise ValueError(_('Wrong account or password'))


class SettingForm(BaseForm):
    screen_name = TextField(_('Display Name'), validators=[Length(max=80)])
    website = URLField(_('Website'), validators=[URL(), Optional()])
    city = TextField(_('City'), description=_('Where are you living'))
    description = TextAreaField(
        _('Description'), validators=[Optional(), Length(max=400)],
        description=_('Markdown is supported.')
    )
    title = TextField(_('Job Title'))


class FindForm(BaseForm):
    account = TextField(
        _('Account'), validators=[DataRequired()],
        description=_('Username or Email')
    )

    def validate_account(self, field):
        account = field.data
        if '@' in account:
            user = Account.query.filter_by(email=account).first()
        else:
            user = Account.query.filter_by(username=account).first()
        if not user:
            raise ValueError(_('This account does not exist.'))
        self.user = user


class ResetForm(BaseForm):
    password = PasswordField(
        _('Password'), validators=[DataRequired()],
        description=_('Remember your password')
    )
    confirm = PasswordField(
        _('Confirm'), validators=[DataRequired()],
        description=_('Confirm your password')
    )

    def validate_confirm(self, field):
        if field.data != self.password.data:
            raise ValueError(_("Passwords don't match."))

########NEW FILE########
__FILENAME__ = node
# coding: utf-8

from wtforms import TextField, TextAreaField, SelectField, BooleanField
from wtforms.validators import DataRequired
from flask.ext.babel import lazy_gettext as _

from ._base import BaseForm
from ..models import Node


class NodeForm(BaseForm):
    title = TextField(
        _('Title'), validators=[DataRequired()],
        description=_('The screen title of the node')
    )
    urlname = TextField(
        _('URL'), validators=[DataRequired()],
        description=_('The url name of the node')
    )
    description = TextAreaField(_('Description'))
    role = SelectField(
        _('Role'),
        description=_('Required role'),
        choices=[
            ('user', _('User')),
            ('staff', _('Staff')),
            ('admin', _('Admin'))
        ],
        default='user',
    )
    on_home = BooleanField(_('Show on home page'), default=True)

    def validate_urlname(self, field):
        if self._obj and self._obj.urlname == field.data:
            return
        if Node.query.filter_by(urlname=field.data).count():
            raise ValueError(_('The node exists'))

    def save(self):
        node = Node(**self.data)
        node.save()
        return node

########NEW FILE########
__FILENAME__ = topic
# coding: utf-8

from wtforms import TextField, TextAreaField
from wtforms.validators import DataRequired
from flask.ext.babel import lazy_gettext as _

from ._base import BaseForm
from ..models import Topic, Reply


class TopicForm(BaseForm):
    title = TextField(
        _('Title'), validators=[DataRequired()],
        description=_('Title of the topic')
    )
    content = TextAreaField(
        _('Content'),
        description=_('Content of the topic')
    )

    def save(self, user, node):
        topic = Topic(**self.data)
        return topic.save(user=user, node=node)


class ReplyForm(BaseForm):
    content = TextAreaField(_('Content'), validators=[DataRequired()])

    def save(self, user, topic):
        item = Reply(**self.data)
        return item.save(user=user, topic=topic)

########NEW FILE########
__FILENAME__ = _base
# coding: utf-8

from flask import _request_ctx_stack
from flask.ext.wtf import Form
from flask.ext.babel import get_locale
from speaklater import make_lazy_string
from babel import support
from wtforms.ext.i18n.utils import messages_path

__all__ = ['BaseForm']


def _get_translations():
    """Returns the correct gettext translations.
    Copy from flask-babel with some modifications.
    """
    ctx = _request_ctx_stack.top
    if ctx is None:
        return None
    # babel should be in extensions for get_locale
    if 'babel' not in ctx.app.extensions:
        return None
    translations = getattr(ctx, 'wtforms_translations', None)
    if translations is None:
        dirname = messages_path()
        translations = support.Translations.load(
            dirname, [get_locale()], domain='wtforms'
        )
        ctx.wtforms_translations = translations
    return translations


def _gettext(string):
    t = _get_translations()
    if t is None:
        return string
    if hasattr(t, 'ugettext'):
        return t.ugettext(string)
    # Python 3 has no ugettext
    return t.gettext(string)


def _ngettext(singular, plural, n):
    t = _get_translations()
    if t is None:
        if n == 1:
            return singular
        return plural

    if hasattr(t, 'ungettext'):
        return t.ungettext(singular, plural, n)
    # Python 3 has no ungettext
    return t.ngettext(singular, plural, n)


class _Translations(object):
    def gettext(self, string):
        return make_lazy_string(_gettext, string)

    def ngettext(self, singular, plural, n):
        return make_lazy_string(_ngettext, singular, plural, n)

_translations = _Translations()


class BaseForm(Form):
    def __init__(self, *args, **kwargs):
        self._obj = kwargs.get('obj', None)
        super(BaseForm, self).__init__(*args, **kwargs)

    def _get_translations(self):
        return _translations

########NEW FILE########
__FILENAME__ = account
# coding: utf-8

from flask import Blueprint
from flask import g, request, flash, current_app
from flask import render_template, redirect, url_for
from flask.ext.babel import gettext as _
from ..models import Account
from ..forms import SignupForm, SigninForm, SettingForm
from ..forms import FindForm, ResetForm
from ..utils.mail import signup_mail, find_mail
from ..utils.user import login_user, logout_user
from ..utils.user import require_login, verify_auth_token

__all__ = ['bp']

bp = Blueprint('account', __name__)


@bp.route('/signup', methods=['GET', 'POST'])
def signup():
    """Sign up page. If the request has an token arguments, it is not
    for registeration, it is for verifying the token.
    """
    next_url = request.args.get('next', url_for('.setting'))
    token = request.args.get('token')
    if token:
        user = verify_auth_token(token, 1)
        if not user:
            flash(_('Invalid or expired token.'), 'error')
            return redirect(next_url)
        user.role = 'user'
        user.save()
        login_user(user)
        flash(_('This account is verified.'), 'success')
        return redirect(next_url)

    form = SignupForm()
    if form.validate_on_submit():
        verify_email = current_app.config.get('VERIFY_EMAIL', True)
        if not verify_email:
            # if no need for verify email
            # we should save the role as user
            user = form.save('user')
            login_user(user)
            return redirect(next_url)
        user = form.save()
        login_user(user)
        # send signup mail to user
        msg = signup_mail(user)
        if current_app.debug:
            return msg.html
        flash(_('We have sent you an activate email, check your inbox.'),
              'info')
        return redirect(next_url)
    return render_template('account/signup.html', form=form)


@bp.route('/signin', methods=['GET', 'POST'])
def signin():
    """Sign in page."""
    next_url = request.args.get('next', '/')
    if g.user:
        return redirect(next_url)
    form = SigninForm()
    if form.validate_on_submit():
        login_user(form.user, form.permanent.data)
        return redirect(next_url)
    return render_template('account/signin.html', form=form)


@bp.route('/signout')
def signout():
    """Sign out, and redirect."""
    next_url = request.args.get('next', '/')
    logout_user()
    return redirect(next_url)


@bp.route('/setting', methods=['GET', 'POST'])
@require_login
def setting():
    """Settings page of current user."""
    user = g.user
    form = SettingForm(obj=user)
    next_url = request.args.get('next', url_for('.setting'))
    if form.validate_on_submit():
        user = Account.query.get(g.user.id)
        form.populate_obj(user)
        user.save()
        flash(_('Your profile is updated.'), 'info')
        return redirect(next_url)
    return render_template('account/setting.html', form=form)


@bp.route('/find', methods=['GET', 'POST'])
def find():
    """Find password page, when user forgot his password, he can
    find the password via email."""
    if g.user:
        return redirect('/')
    form = FindForm()
    if form.validate_on_submit():
        msg = find_mail(form.user)
        if current_app.debug or current_app.testing:
            return msg.html
        flash(_('We have sent you an email, check your inbox.'), 'info')
        return redirect(url_for('.find'))
    return render_template('account/find.html', form=form)


@bp.route('/reset', methods=['GET', 'POST'])
def reset():
    """Reset password page. User launch this page via the link in
    the find password email."""
    if g.user:
        return redirect('/')
    token = request.values.get('token')
    if not token:
        flash(_('Token is missing.'), 'error')
        return redirect('/')
    user = verify_auth_token(token, expires=1)
    if not user:
        flash(_('Invalid or expired token.'), 'error')
        return redirect(url_for('.find'))
    form = ResetForm()
    if form.validate_on_submit():
        user.change_password(form.password.data).save()
        login_user(user)
        flash(_('Your password is updated.'), 'info')
        return redirect(url_for('.setting'))
    return render_template('account/reset.html', form=form, token=token)


@bp.route('/delete', methods=['GET', 'POST'])
@require_login
def delete():
    """Delete the account. This will not delete the data related to
    the user, such as topics and replies."""
    return 'not ready'


@bp.route('/notification')
@require_login
def notification():
    """Show notifications of a user."""
    # 1. read from cache, these notifications are unreaded
    # 2. read from database, these notifications are readed
    # 3. flush the notifications from cache to database
    return 'not ready'

########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

import os
from flask import Blueprint, request, current_app, flash
from flask import render_template, abort, redirect, url_for
from wtforms import TextField, SelectField
from flask.ext.wtf.html5 import EmailField
from wtforms.validators import DataRequired, Email, Length, Regexp

from flask.ext.babel import lazy_gettext as _
from ..helpers import force_int
from ..models import Account
from ..forms import SettingForm
from ..utils.user import require_staff, require_admin


__all__ = ['bp', 'load_sidebar']

bp = Blueprint('admin', __name__)


class UserForm(SettingForm):
    username = TextField(
        _('Username'), validators=[
            DataRequired(), Length(min=3, max=20),
            Regexp(r'^[a-z0-9A-Z]+$')
        ], description=_('English Characters Only.'),
    )
    email = EmailField(
        _('Email'), validators=[DataRequired(), Email()]
    )
    role = SelectField(
        _('Role'),
        choices=[
            ('spam', _('Spam')),
            ('user', _('User')),
            ('staff', _('Staff')),
            ('admin', _('Admin'))
        ],
        default='user',
    )


@bp.route('/', methods=['GET', 'POST'])
@require_staff
def dashboard():
    """
    The dashboard page of admin site.
    """
    if request.method == 'POST':
        save_sidebar(request.form.get('content', None))
        return redirect(url_for('.dashboard'))

    page = force_int(request.args.get('page', 1), 0)
    if not page:
        return abort(404)

    sidebar = load_sidebar()
    paginator = Account.query.order_by(Account.id.desc()).paginate(page)
    return render_template(
        'admin/dashboard.html',
        paginator=paginator,
        sidebar=sidebar,
    )


@bp.route('/user/<int:uid>', methods=['GET', 'POST'])
@require_admin
def user(uid):
    """
    Edit a specified user.
    """
    user = Account.query.get_or_404(uid)
    form = UserForm(obj=user)
    if form.validate_on_submit():
        form.populate_obj(user)
        user.save()
        return redirect(url_for('.user', uid=uid))
    return render_template('admin/user.html', form=form, user=user)


def load_sidebar():
    filepath = current_app.config.get('SITE_SIDEBAR')
    if not filepath:
        return None
    if not os.path.exists(filepath):
        return ''
    with open(filepath) as f:
        content = f.read()
        return content.decode('utf-8')


def save_sidebar(content):
    filepath = current_app.config.get('SITE_SIDEBAR')
    if not filepath:
        flash('Config your site with SITE_SIDEBAR', 'warn')
        return

    dirname = os.path.dirname(filepath)
    if not os.path.exists(dirname):
        os.makdirs(dirname)

    with open(filepath, 'wb') as f:
        content = content.encode('utf-8')
        f.write(content)

########NEW FILE########
__FILENAME__ = front
# coding: utf-8

import os
import time
import datetime
from flask import Blueprint, request, g, current_app
from flask import render_template, Response, jsonify
from ..filters import markdown
from ..utils.user import require_user
from ..models import Node, Topic, fill_topics, cache


bp = Blueprint('front', __name__)


@bp.route('/')
def home():
    """The homepage of the site."""
    nodes = Node.query.order_by(Node.id.desc()).all()

    home_nodes = filter(lambda o: o.on_home, nodes)
    home_node_ids = map(lambda o: o.id, home_nodes)
    if len(home_node_ids):
        topics = Topic.query.filter(
            Topic.node_id.in_(home_node_ids)
            ).order_by(Topic.id.desc()).limit(16)
        topics = fill_topics(topics)
    else:
        topics = None

    # blog is a special node, get the latest posts from blog
    blog = Node.query.filter_by(urlname='blog').first()
    if blog:
        blogs = Topic.query.filter_by(
            node_id=blog.id).order_by(Topic.id.desc()).limit(2)
    else:
        blogs = None

    return render_template(
        'index.html', topics=topics, nodes=nodes[:16],
        blog=blog, blogs=blogs
    )


@bp.route('/feed')
def feed():
    html = cache.get('sitefeed')
    if not html:
        topics = Topic.query.order_by(Topic.id.desc()).limit(16)
        topics = fill_topics(topics)
        now = datetime.datetime.now()
        html = render_template('feed.xml', topics=topics, now=now)
        cache.set('sitefeed', html, 1800)

    return Response(html, content_type='text/xml; charset=utf-8')


@bp.route('/markdown', methods=['POST'])
def preview():
    content = request.form.get('content', '')
    return markdown(content)


@bp.route('/upload', methods=['POST'])
@require_user
def upload():
    """Upload images handler."""
    image = request.files.get('image')
    _, ext = os.path.splitext(image.filename)
    filename = '%d-%d%s' % (g.user.id, int(time.time()), ext.lower())
    try:
        url = current_app.storage.save(image, filename)
        return jsonify(url=url)
    except:
        return jsonify(error='upload failed')

########NEW FILE########
__FILENAME__ = node
# coding: utf-8

from flask import Blueprint, request, g
from flask import render_template, redirect, url_for, abort
from ..models import Node, NodeStatus, Topic, fill_topics
from ..forms import NodeForm
from ..helpers import force_int
from ..utils.user import require_staff


__all__ = ['bp']

bp = Blueprint('node', __name__)


@bp.route('/')
def nodes():
    """Nodes pages."""
    nodes = Node.query.order_by(Node.updated.desc()).all()
    return render_template('node/nodes.html', nodes=nodes)


@bp.route('/create', methods=['GET', 'POST'])
@require_staff
def create():
    """
    Create a node by staff members.
    """
    form = NodeForm()
    if form.validate_on_submit():
        node = form.save()
        return redirect(url_for('.view', urlname=node.urlname))
    return render_template('node/create.html', form=form)


@bp.route('/<urlname>')
def view(urlname):
    """
    The view page of the Node.

    The node page should contain the information of the node, and topics
    in this node.

    :param urlname: the urlname of the Node model
    """

    node = Node.query.filter_by(urlname=urlname).first_or_404()
    page = force_int(request.args.get('page', 1), 0)
    if not page:
        return abort(404)
    paginator = Topic.query.filter_by(
        node_id=node.id).order_by(Topic.id.desc()).paginate(page)
    paginator.items = fill_topics(paginator.items)

    status = None
    if g.user:
        status = NodeStatus.query.filter_by(
            account_id=g.user.id, node_id=node.id
        ).first()
    return render_template(
        'node/view.html', node=node, paginator=paginator, status=status
    )


@bp.route('/<urlname>/edit', methods=['GET', 'POST'])
@require_staff
def edit(urlname):
    """
    Edit a node by staff members.

    :param urlname: the urlname of the Node model
    """
    node = Node.query.filter_by(urlname=urlname).first_or_404()
    form = NodeForm(obj=node)
    if form.validate_on_submit():
        form.populate_obj(node)
        node.save()
        return redirect(url_for('.view', urlname=node.urlname))
    return render_template('node/edit.html', form=form, node=node)

########NEW FILE########
__FILENAME__ = topic
# coding: utf-8

import datetime
from flask import Blueprint, g, request, flash, current_app
from flask import render_template, redirect, abort, jsonify
from flask import url_for
from flask.ext.babel import gettext as _
from ..helpers import force_int, limit_request
from ..models import db, Node, Account
from ..models import Topic, Reply, LikeTopic
from ..models import fill_topics, fill_with_users
from ..forms import TopicForm, ReplyForm
from ..utils.user import require_user


__all__ = ['bp']

bp = Blueprint('topic', __name__)


@bp.route('/')
def topics():
    """
    The topics list page.
    """
    page = force_int(request.args.get('page', 1), 0)
    if not page:
        return abort(404)
    paginator = Topic.query.order_by(Topic.updated.desc()).paginate(page)
    paginator.items = fill_topics(paginator.items)
    return render_template('topic/topics.html', paginator=paginator,
                           endpoint='topic.topics')


@bp.route('/latest')
def latest():
    """
    Topics ordered by created time.
    """
    page = force_int(request.args.get('page', 1), 0)
    if not page:
        return abort(404)
    paginator = Topic.query.order_by(Topic.id.desc()).paginate(page)
    paginator.items = fill_topics(paginator.items)
    return render_template('topic/topics.html', paginator=paginator,
                           endpoint='topic.latest')


@bp.route('/desert')
def desert():
    """
    Topics without any replies.
    """
    page = force_int(request.args.get('page', 1), 0)
    if not page:
        return abort(404)
    paginator = Topic.query.filter_by(
        reply_count=0).order_by(Topic.id.desc()).paginate(page)
    paginator.items = fill_topics(paginator.items)
    return render_template('topic/topics.html', paginator=paginator,
                           endpoint='topic.desert')


@bp.route('/create/<urlname>', methods=['GET', 'POST'])
@require_user
def create(urlname):
    """
    Create a topic in the node by an activated user.

    :param urlname: the urlname of the Node model
    """

    now = datetime.datetime.utcnow()
    delta = now - g.user.created
    verify = current_app.config.get('VERIFY_USER')
    if verify and not delta.days and not g.user.is_admin:
        # only allow user who has been registered after a day
        flash(_('New users can not create a topic'), 'warn')
        return redirect(url_for('.topics'))

    if g.user.active:
        # if user has no active information
        d = now - g.user.active
        delta = d.days * 86400 + d.seconds
    else:
        delta = 1000
    if delta < 300 and not g.user.is_staff:
        # you cannot create a topic
        left = int(300 - delta)
        flash(_("Don't be a spammer, take a rest for %(time)i seconds.",
                time=left), 'warn')
        return redirect(url_for('.topics'))

    node = Node.query.filter_by(urlname=urlname).first_or_404()

    if node.role == 'staff' and not g.user.is_staff:
        flash(_('You have no permission in this node.'), 'warn')
        return redirect(url_for('node.view', urlname=urlname))

    if node.role == 'admin' and not g.user.is_admin:
        flash(_('You have no permission in this node.'), 'warn')
        return redirect(url_for('node.view', urlname=urlname))

    form = TopicForm()
    if form.validate_on_submit():
        topic = form.save(g.user, node)
        return redirect(url_for('.view', uid=topic.id))
    return render_template('topic/create.html', node=node, form=form)


@bp.route('/<int:uid>', methods=['GET', 'POST'])
def view(uid):
    """
    View a topic with the given id.

    :param uid: the id of a topic.
    """
    if request.method == 'POST':
        # record hits
        topic = Topic.query.get_or_404(uid)
        topic.hits += 1
        topic.save()
        return jsonify(hits=topic.hits)

    page = force_int(request.args.get('page', 1), 0)
    if not page:
        return abort(404)

    topic = Topic.query.get_or_404(uid)
    node = Node.query.get_or_404(topic.node_id)
    author = Account.query.get_or_404(topic.account_id)
    topic.author = author
    topic.node = node

    if g.user:
        topic.like = LikeTopic.query.filter_by(
            account_id=g.user.id, topic_id=uid
        ).first()

    paginator = Reply.query.filter_by(topic_id=uid).paginate(page)
    paginator.items = fill_with_users(paginator.items)

    form = None
    if g.user:
        form = ReplyForm()

    return render_template(
        'topic/view.html', topic=topic,
        form=form, paginator=paginator
    )


@bp.route('/<int:uid>/edit', methods=['GET', 'POST'])
@require_user
def edit(uid):
    """
    Edit a topic by the topic author.

    :param uid: the id of the topic
    """
    topic = Topic.query.get_or_404(uid)
    if g.user.id != topic.account_id and not g.user.is_staff:
        return abort(403)
    form = TopicForm(obj=topic)
    if form.validate_on_submit():
        form.populate_obj(topic)
        topic.save()
        return redirect(url_for('.view', uid=uid))
    return render_template('topic/edit.html', topic=topic, form=form)


@bp.route('/<int:uid>/delete', methods=['POST'])
@require_user
def delete(uid):
    """
    Delete a topic by the topic author.
    """
    # TODO: should we delete the replies of the topic?
    password = request.form.get('password')
    if not password:
        flash(_('Password is required to delete a topic'), 'info')
        return redirect(url_for('.view', uid=uid))
    if not g.user.check_password(password):
        flash(_('Password is wrong'), 'error')
        return redirect(url_for('.view', uid=uid))
    topic = Topic.query.get_or_404(uid)
    topic.delete()
    return redirect(url_for('.topics'))


@bp.route('/<int:uid>/move', methods=['GET', 'POST'])
@require_user
def move(uid):
    """
    Move a topic to another node.

    :param uid: the id of the topic
    """
    topic = Topic.query.get_or_404(uid)
    if g.user.id != topic.account_id and not g.user.is_staff:
        return abort(403)

    if request.method == 'GET':
        return render_template('topic/move.html', topic=topic)

    urlname = request.form.get('node', None)
    if not urlname:
        return redirect(url_for('.view', uid=uid))
    node = Node.query.filter_by(urlname=urlname).first()
    if node:
        topic.move(node)
        flash(_('Move topic success.'), 'success')
    else:
        flash(_('Node not found.'), 'error')
    return redirect(url_for('.view', uid=uid))


@bp.route('/<int:uid>/reply', methods=['POST', 'DELETE'])
@limit_request(5, redirect_url=lambda uid: url_for('.view', uid=uid))
@require_user
def reply(uid):
    """
    Reply of the given topic.

    * POST: it will create a reply
    * DELETE: it will delete a reply

    Delete should pass an arg of the reply id, and it can be only deleted
    by the reply author or the staff members.

    :param uid: the id of the topic
    """
    if request.method == 'DELETE':
        reply_id = force_int(request.args.get('reply', 0), 0)
        if not reply_id:
            return abort(404)
        reply = Reply.query.get_or_404(reply_id)
        if not reply:
            return abort(404)
        if reply.topic_id != uid:
            return abort(404)
        if g.user.is_staff or g.user.id == reply.account_id:
            reply.delete()
            return jsonify(status='success')
        return abort(403)

    topic = Topic.query.get_or_404(uid)
    form = ReplyForm()
    if form.validate_on_submit():
        form.save(g.user, topic)
    else:
        flash(_('Missing content'), 'error')
    return redirect(url_for('.view', uid=uid))


@bp.route('/<int:uid>/like', methods=('POST',))
@require_user
def like(uid):
    """Like a topic."""
    like = LikeTopic.query.filter_by(
        account_id=g.user.id, topic_id=uid
    ).first()
    if like:
        db.session.delete(like)
        db.session.commit()
        return jsonify(status='ok', action='cancel')
    like = LikeTopic(account_id=g.user.id, topic_id=uid)
    db.session.add(like)
    db.session.commit()
    return jsonify(status='ok', action='like')

########NEW FILE########
__FILENAME__ = user
# coding: utf-8

from flask import Blueprint, request
from flask import render_template, abort
from ..helpers import force_int
from ..models import Account, Topic, fill_with_nodes


__all__ = ['bp']

bp = Blueprint('user', __name__)


@bp.route('/')
def users():
    """
    The user list page.
    """
    page = force_int(request.args.get('page', 1), 0)
    if not page:
        return abort(404)
    paginator = Account.query.order_by(Account.active.desc()).paginate(page)
    staffs = Account.query.filter(Account.role.in_(('staff', 'admin'))).all()
    return render_template(
        'user/users.html',
        paginator=paginator,
        staffs=staffs
    )


@bp.route('/in/<city>')
def city(city):
    """
    Users in a city.
    """
    page = force_int(request.args.get('page', 1), 0)
    if not page:
        return abort(404)
    paginator = Account.query.filter_by(city=city).paginate(page)
    return render_template('user/city.html', paginator=paginator, city=city)


@bp.route('/<username>')
def view(username):
    """
    View a user with the given username.

    :param username: the username of a user.
    """
    user = Account.query.filter_by(username=username).first_or_404()
    topics = Topic.query.filter_by(
        account_id=user.id).order_by(Topic.id.desc()).limit(16)
    topics = fill_with_nodes(topics)
    return render_template('user/view.html', user=user, topics=topics)


@bp.route('/<username>/topics')
def topics(username):
    """
    View topics of a user.

    :param username: the username of a user.
    """
    page = force_int(request.args.get('page', 1), 0)
    if not page:
        return abort(404)

    user = Account.query.filter_by(username=username).first_or_404()

    paginator = Topic.query.filter_by(
        account_id=user.id).order_by(Topic.id.desc()).paginate(page)
    paginator.items = fill_with_nodes(paginator.items)
    return render_template(
        'user/topics.html', user=user, paginator=paginator
    )

########NEW FILE########
__FILENAME__ = helpers
import time
import base64
import hashlib
import functools
from flask import g, request, session, current_app
from flask import flash, url_for, redirect, abort
from flask.ext.babel import lazy_gettext as _
from .models import Account, cache


class require_role(object):
    roles = {
        'spam': 0,
        'new': 1,
        'user': 2,
        'staff': 3,
        'admin': 4,
    }

    def __init__(self, role):
        self.role = role

    def __call__(self, method):
        @functools.wraps(method)
        def wrapper(*args, **kwargs):
            if not g.user:
                url = url_for('account.signin')
                if '?' not in url:
                    url += '?next=' + request.url
                return redirect(url)
            if self.role is None:
                return method(*args, **kwargs)
            if g.user.id == 1:
                # this is superuser, have no limitation
                return method(*args, **kwargs)
            if g.user.role == 'new':
                flash(_('Please verify your email'), 'warn')
                return redirect(url_for('account.setting'))
            if g.user.role == 'spam':
                flash(_('You are a spammer'), 'error')
                return redirect('/')
            if self.roles[g.user.role] < self.roles[self.role]:
                return abort(403)
            return method(*args, **kwargs)
        return wrapper


require_login = require_role(None)
require_user = require_role('user')
require_staff = require_role('staff')
require_admin = require_role('admin')


class limit_request(object):
    """
    Limitations on user requests.

    :param seconds: next request should be after N seconds
    :param prefix: cache key prefix
    :param method: the method of the request
    :param redirect_url: redirect when exceeding limited time

    The redirect_url can be a string or function. When it is a function,
    it accepts the same parameters as the wrapped methods.
    """

    def __init__(self, seconds=0, prefix=None, method='POST',
                 redirect_url=None):
        self.seconds = seconds
        self.prefix = prefix
        self.method = method
        self.redirect_url = redirect_url

    def __call__(self, method):
        @functools.wraps(method)
        def wrapper(*args, **kwargs):
            if request.method != self.method:
                return method(*args, **kwargs)

            if not g.user:
                return abort(403)

            prefix = self.prefix
            if prefix is None:
                prefix = request.path

            key = '%s-%s-%i' % (prefix, self.method, g.user.id)

            now = time.time()
            last_cached = cache.get(key)
            if last_cached and (now - last_cached) < self.seconds:
                flash(_('Too many requests in a time'), 'warn')
                redirect_url = self.redirect_url or request.url
                if callable(redirect_url):
                    redirect_url = redirect_url(*args, **kwargs)
                return redirect(redirect_url)
            cache.set(key, now)
            return method(*args, **kwargs)
        return wrapper


def get_current_user():
    if 'id' in session and 'token' in session:
        user = Account.query.get(int(session['id']))
        if not user:
            return None
        if user.token != session['token']:
            return None
        return user
    return None


def login_user(user, permanent=False):
    if not user:
        return None
    session['id'] = user.id
    session['token'] = user.token
    if permanent:
        session.permanent = True
    return user


def logout_user():
    if 'id' not in session:
        return
    session.pop('id')
    session.pop('token')


def create_auth_token(user):
    timestamp = int(time.time())
    secret = current_app.secret_key
    token = '%s%s%s%s' % (secret, timestamp, user.id, user.token)
    hsh = hashlib.sha1(token).hexdigest()
    return base64.b32encode('%s|%s|%s' % (timestamp, user.id, hsh))


def verify_auth_token(token, expires=30):
    try:
        token = base64.b32decode(token)
    except:
        return None
    bits = token.split('|')
    if len(bits) != 3:
        return None
    timestamp, user_id, hsh = bits
    try:
        timestamp = int(timestamp)
        user_id = int(user_id)
    except:
        return None
    delta = time.time() - timestamp
    if delta < 0:
        return None
    if delta > expires * 60 * 60 * 24:
        return None
    user = Account.query.get(user_id)
    if not user:
        return None
    secret = current_app.secret_key
    _hsh = hashlib.sha1('%s%s%s%s' % (secret, timestamp, user_id, user.token))
    if hsh == _hsh.hexdigest():
        return user
    return None


def force_int(value, default=1):
    try:
        return int(value)
    except:
        return default

########NEW FILE########
__FILENAME__ = account
# coding: utf-8

import hashlib
from datetime import datetime
from werkzeug import security
from ._base import db, SessionMixin

__all__ = ('Account', 'NonAccount')


class Account(db.Model, SessionMixin):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(40), unique=True, index=True,
                         nullable=False)
    email = db.Column(db.String(200), nullable=False, unique=True, index=True)
    password = db.Column(db.String(100), nullable=False)

    screen_name = db.Column(db.String(80))
    description = db.Column(db.String(400))
    city = db.Column(db.String(200))
    website = db.Column(db.String(400))

    role = db.Column(db.String(10), default='new')
    active = db.Column(db.DateTime, default=datetime.utcnow, index=True)

    created = db.Column(db.DateTime, default=datetime.utcnow)
    token = db.Column(db.String(20))

    def __init__(self, **kwargs):
        self.token = self.create_token(16)

        if 'password' in kwargs:
            raw = kwargs.pop('password')
            self.password = self.create_password(raw)

        if 'username' in kwargs:
            username = kwargs.pop('username')
            self.username = username.lower()

        if 'email' in kwargs:
            email = kwargs.pop('email')
            self.email = email.lower()

        for k, v in kwargs.items():
            setattr(self, k, v)

    def __str__(self):
        return self.screen_name or self.username

    def __repr__(self):
        return '<Account: %s>' % self.username

    def avatar(self, size=48):
        md5email = hashlib.md5(self.email).hexdigest()
        query = "%s?s=%s%s" % (md5email, size, db.app.config['GRAVATAR_EXTRA'])
        return db.app.config['GRAVATAR_BASE_URL'] + query

    @staticmethod
    def create_password(raw):
        passwd = '%s%s' % (raw, db.app.config['PASSWORD_SECRET'])
        return security.generate_password_hash(passwd)

    @staticmethod
    def create_token(length=16):
        return security.gen_salt(length)

    @property
    def is_staff(self):
        if self.id == 1:
            return True
        return self.role == 'staff' or self.role == 'admin'

    @property
    def is_admin(self):
        return self.id == 1 or self.role == 'admin'

    def check_password(self, raw):
        passwd = '%s%s' % (raw, db.app.config['PASSWORD_SECRET'])
        return security.check_password_hash(self.password, passwd)

    def change_password(self, raw):
        self.password = self.create_password(raw)
        self.token = self.create_token()
        return self


class NonAccount(object):
    """Non Account is a model designed for the deleted account.
    Since the account is deleted, the topics and replies will has no
    account related to them, in such cases, a `NonAccount` is used."""

    username = 'none'
    is_staff = False
    is_admin = False

    def __str__(self):
        return 'none'

    def __repr__(self):
        return '<NonAccount: none>'

########NEW FILE########
__FILENAME__ = node
# coding: utf-8

from datetime import datetime
from ._base import db, SessionMixin

__all__ = ['Node', 'NodeStatus']


class Node(db.Model, SessionMixin):
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(100), nullable=False)
    urlname = db.Column(db.String(40), unique=True, index=True)

    description = db.Column(db.Text)
    topic_count = db.Column(db.Integer, default=0)
    role = db.Column(db.String(10), default=u'user')

    # topics will show on homepage ?
    on_home = db.Column(db.Boolean, default=True)
    # a mayor can delete a topic in this node, can change description
    mayor = db.Column(db.Integer, default=0)

    created = db.Column(db.DateTime, default=datetime.utcnow)
    updated = db.Column(
        db.DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow,
        index=True,
    )

    def __str__(self):
        return self.title

    def __repr__(self):
        return '<Node: %s>' % self.urlname


class NodeStatus(db.Model, SessionMixin):
    """
    People's status in a Node
    """
    node_id = db.Column(db.Integer, primary_key=True)
    account_id = db.Column(db.Integer, primary_key=True)

    topic_count = db.Column(db.Integer, default=0)
    reputation = db.Column(db.Integer, default=0)

    updated = db.Column(
        db.DateTime,
        default=datetime.utcnow,
        onupdate=datetime.utcnow
    )

########NEW FILE########
__FILENAME__ = topic
# coding: utf-8

from datetime import datetime
from ._base import db
from .account import Account
from .node import Node, NodeStatus


__all__ = ['Topic', 'Reply', 'LikeTopic']


class Topic(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    account_id = db.Column(db.Integer, nullable=False, index=True)
    node_id = db.Column(db.Integer, nullable=False, index=True)

    title = db.Column(db.String(100), nullable=False)
    content = db.Column(db.Text)

    hits = db.Column(db.Integer, default=0)
    reply_count = db.Column(db.Integer, default=0)

    created = db.Column(db.DateTime, default=datetime.utcnow)
    updated = db.Column(
        db.DateTime,
        default=datetime.utcnow,
        index=True,
    )

    def __str__(self):
        return self.title

    def __repr__(self):
        return '<Topic: %s>' % self.id

    def save(self, user=None, node=None):
        if self.id:
            # update topic
            db.session.add(self)
            db.session.commit()
            return self

        # insert a topic
        if user:
            self.account_id = user.id
            user.active = datetime.utcnow()
            db.session.add(user)
        if node:
            self.node_id = node.id
            node.topic_count += 1
            db.session.add(node)

            ns = NodeStatus.query.filter_by(
                node_id=self.node_id, account_id=self.account_id
            ).first()
            if not ns:
                ns = NodeStatus(
                    node_id=self.node_id,
                    account_id=self.account_id,
                    topic_count=0,
                )
            ns.topic_count += 1
            db.session.add(ns)

        db.session.add(self)
        db.session.commit()
        return self

    def move(self, node=None):
        if self.node_id == node.id:
            return self

        # clear status in pre node
        node1 = Node.query.get(self.node_id)
        node1.topic_count -= 1
        db.session.add(node1)

        ns1 = NodeStatus.query.filter_by(
            node_id=self.node_id, account_id=self.account_id
        ).first()
        ns1.topic_count -= 1
        db.session.add(ns1)

        # increase status in post node
        node.topic_count += 1
        db.session.add(node)
        ns = NodeStatus.query.filter_by(
            node_id=node.id, account_id=self.account_id
        ).first()
        if not ns:
            ns = NodeStatus(
                node_id=node.id,
                account_id=self.account_id,
                topic_count=0,
            )
        ns.topic_count += 1
        db.session.add(ns)

        self.node_id = node.id
        db.session.add(self)
        db.session.commit()
        return self

    def delete(self, user=None, node=None):
        if not user:
            user = Account.query.get(self.account_id)
        if not node:
            node = Node.query.get(self.node_id)

        user.active = datetime.utcnow()
        db.session.add(user)

        node.topic_count -= 1
        db.session.add(node)

        ns = NodeStatus.query.filter_by(
            node_id=self.node_id, account_id=self.account_id
        ).first()
        if ns and ns.topic_count:
            ns.topic_count -= 1
            db.session.add(ns)
        db.session.delete(self)
        db.session.commit()
        return self


class Reply(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    account_id = db.Column(db.Integer, nullable=False)
    topic_id = db.Column(db.Integer, index=True, nullable=False)
    content = db.Column(db.Text)

    created = db.Column(db.DateTime, default=datetime.utcnow)
    flags = db.Column(db.Integer, default=0)

    def __str__(self):
        return self.content

    def save(self, user=None, topic=None):
        if self.id:
            # update
            db.session.add(self)
            db.session.commit()
            return self

        if user:
            self.account_id = user.id
            user.active = datetime.utcnow()
            db.session.add(user)
        if topic:
            self.topic_id = topic.id
            topic.reply_count += 1
            topic.updated = datetime.utcnow()
            db.session.add(topic)

        db.session.add(self)
        db.session.commit()
        return self

    def delete(self, user=None, topic=None):
        if not topic:
            topic = Topic.query.get(self.topic_id)

        topic.reply_count -= 1
        db.session.add(topic)
        db.session.delete(self)
        db.session.commit()
        return self


class LikeTopic(db.Model):
    __table_args__ = (
        db.UniqueConstraint(
            'account_id', 'topic_id', name='uc_account_like_topic'
        ),
    )

    id = db.Column(db.Integer, primary_key=True)
    account_id = db.Column(db.Integer, nullable=False)
    topic_id = db.Column(db.Integer, index=True, nullable=False)
    created = db.Column(db.DateTime, default=datetime.utcnow)

########NEW FILE########
__FILENAME__ = _base
# coding: utf-8

import datetime
from flask.ext.sqlalchemy import SQLAlchemy, BaseQuery
from flask.ext.cache import Cache

__all__ = [
    'db', 'cache', 'JuneQuery', 'SessionMixin',
]


class JuneQuery(BaseQuery):
    def filter_in(self, model, values):
        values = set(values)
        if len(values) == 0:
            return {}
        if len(values) == 1:
            ident = values.pop()
            rv = self.get(ident)
            if not rv:
                return {}
            return {ident: rv}
        items = self.filter(model.in_(values))
        dct = {}
        for item in items:
            dct[getattr(item, model.key)] = item
        return dct

    def as_list(self, *columns):
        return self.options(map(db.defer, columns))


class SessionMixin(object):
    def to_dict(self, *columns):
        dct = {}
        for col in columns:
            value = getattr(self, col)
            if isinstance(value, datetime.datetime):
                value = value.strftime('%Y-%m-%d %H:%M:%S')
            dct[col] = value
        return dct

    def save(self):
        db.session.add(self)
        db.session.commit()
        return self

    def delete(self):
        db.session.delete(self)
        db.session.commit()
        return self


db = SQLAlchemy()
cache = Cache()
db.Model.query_class = JuneQuery

########NEW FILE########
__FILENAME__ = mail
# coding: utf-8

from flask import current_app, url_for, render_template
from flask.ext.babel import gettext as _
from flask_mail import Message
from .user import create_auth_token


def send_mail(app, msg):
    mail = app.extensions['mail']
    if not mail.default_sender:
        return
    mail.send(msg)


def signup_mail(user, path=None):
    config = current_app.config
    msg = Message(
        _("Signup for %(site)s", site=config['SITE_TITLE']),
        recipients=[user.email],
    )
    reply_to = config.get('MAIL_REPLY_TO', None)
    if reply_to:
        msg.reply_to = reply_to

    host = config.get('SITE_URL', '')
    dct = {
        'host': host.rstrip('/'),
        'token': create_auth_token(user)
    }
    if path:
        dct['path'] = path
    else:
        dct['path'] = url_for('account.signup')
    link = '%(host)s%(path)s?token=%(token)s' % dct
    html = render_template('email/signup.html', user=user, link=link)
    msg.html = html
    send_mail(current_app, msg)
    return msg


def find_mail(user):
    config = current_app.config
    msg = Message(
        _("Find password for %(site)s", site=config['SITE_TITLE']),
        recipients=[user.email],
    )
    reply_to = config.get('MAIL_REPLY_TO', None)
    if reply_to:
        msg.reply_to = reply_to
    host = config.get('SITE_URL', '')
    dct = {
        'host': host.rstrip('/'),
        'path': url_for('account.reset'),
        'token': create_auth_token(user)
    }
    link = '%(host)s%(path)s?token=%(token)s' % dct
    html = render_template('email/find.html', user=user, link=link)
    msg.html = html
    send_mail(current_app, msg)
    return msg

########NEW FILE########
__FILENAME__ = user
# coding: utf-8
import time
import base64
import hashlib
import functools
from flask import g, request, session, current_app
from flask import flash, url_for, redirect, abort
from flask_babel import lazy_gettext as _
from ..models import Account


class require_role(object):
    roles = {
        'spam': 0,
        'new': 1,
        'user': 2,
        'staff': 3,
        'admin': 4,
    }

    def __init__(self, role):
        self.role = role

    def __call__(self, method):
        @functools.wraps(method)
        def wrapper(*args, **kwargs):
            if not g.user:
                url = url_for('account.signin')
                if '?' not in url:
                    url += '?next=' + request.url
                return redirect(url)
            if self.role is None:
                return method(*args, **kwargs)
            if g.user.id == 1:
                # this is superuser, have no limitation
                return method(*args, **kwargs)
            if g.user.role == 'new':
                flash(_('Please verify your email'), 'warn')
                return redirect('/account/settings')
            if g.user.role == 'spam':
                flash(_('You are a spammer'), 'error')
                return redirect('/')
            if self.roles[g.user.role] < self.roles[self.role]:
                return abort(403)
            return method(*args, **kwargs)
        return wrapper


require_login = require_role(None)
require_user = require_role('user')
require_staff = require_role('staff')
require_admin = require_role('admin')


def get_current_user():
    if 'id' in session and 'token' in session:
        user = Account.query.get(int(session['id']))
        if not user:
            return None
        if user.token != session['token']:
            return None
        return user
    return None


def login_user(user, permanent=False):
    if not user:
        return None
    session['id'] = user.id
    session['token'] = user.token
    if permanent:
        session.permanent = True
    return user


def logout_user():
    if 'id' not in session:
        return
    session.pop('id')
    session.pop('token')


def create_auth_token(user):
    timestamp = int(time.time())
    secret = current_app.secret_key
    token = '%s%s%s%s' % (secret, timestamp, user.id, user.token)
    hsh = hashlib.sha1(token).hexdigest()
    return base64.b32encode('%s|%s|%s' % (timestamp, user.id, hsh))


def verify_auth_token(token, expires=30):
    try:
        token = base64.b32decode(token)
    except:
        return None
    bits = token.split('|')
    if len(bits) != 3:
        return None
    timestamp, user_id, hsh = bits
    try:
        timestamp = int(timestamp)
        user_id = int(user_id)
    except:
        return None
    delta = time.time() - timestamp
    if delta < 0:
        return None
    if delta > expires * 60 * 60 * 24:
        return None
    user = Account.query.get(user_id)
    if not user:
        return None
    secret = current_app.secret_key
    _hsh = hashlib.sha1('%s%s%s%s' % (secret, timestamp, user_id, user.token))
    if hsh == _hsh.hexdigest():
        return user
    return None

########NEW FILE########
__FILENAME__ = _flask
# coding: utf-8
"""
    june._flask
    ~~~~~~~~~~~

    Rewrite the interface of Flask.

    :copyright: (c) 2013 by Hsiaoming Yang.
"""

import datetime
from speaklater import _LazyString
from flask import Flask as _Flask
from flask.json import JSONEncoder as _JSONEncoder
from werkzeug.datastructures import ImmutableDict


class JSONEncoder(_JSONEncoder):
    def default(self, o):
        if hasattr(o, '__getitem__') and hasattr(o, 'keys'):
            return dict(o)
        if isinstance(o, datetime.datetime):
            return o.strftime('%Y-%m-%d %H:%M:%S')
        if isinstance(o, _LazyString):
            # TODO
            return unicode(o)
        return _JSONEncoder.default(self, o)


class Flask(_Flask):
    json_encoder = JSONEncoder

    jinja_options = ImmutableDict(
        trim_blocks=True,
        lstrip_blocks=True,
        extensions=[
            'jinja2.ext.autoescape',
            'jinja2.ext.with_',
            'jinja2.ext.do',
        ]
    )

########NEW FILE########
__FILENAME__ = _settings
import os

DEBUG = False
TESTING = False
VERIFY_EMAIL = True
VERIFY_USER = True

ROOT_FOLDER = os.path.dirname(os.path.abspath(__file__))
if os.path.exists('public/static'):
    STATIC_FOLDER = os.path.join(os.getcwd(), 'public', 'static')
else:
    STATIC_FOLDER = os.path.join(ROOT_FOLDER, 'public', 'static')

#: site
SITE_TITLE = 'Python China'
SITE_URL = '/'
# SITE_URL = 'http://python-china.org/'

#: sidebar is a absolute path
# SITE_SIDEBAR = '/path/to/sidebar.html'

#: about page url
# SITE_ABOUT = '/node/about'

# SITE_ANALYTICS = 'UA-xxx-xxx'

#: session
SESSION_COOKIE_NAME = '_s'
# SESSION_COOKIE_SECURE = True
PERMANENT_SESSION_LIFETIME = 3600 * 24 * 30

#: account
SECRET_KEY = 'secret key'
PASSWORD_SECRET = 'password secret'
GRAVATAR_BASE_URL = 'http://www.gravatar.com/avatar/'
GRAVATAR_EXTRA = ''

#: sqlalchemy
SQLALCHEMY_DATABASE_URI = 'sqlite:///%s' % os.path.join(
    os.getcwd(), 'db.sqlite'
)
# SQLALCHEMY_POOL_SIZE = 100
# SQLALCHEMY_POOL_TIMEOUT = 10
# SQLALCHEMY_POOL_RECYCEL = 3600

#: email settings
# MAIL_SERVER = 'smtp.gmail.com'
# MAIL_USE_SSL = True
# MAIL_USERNAME = ''
# MAIL_PASSWORD = ''
# MAIL_DEFAULT_SENDER = ('name', 'noreply@email.com')

#: cache settings
# find options on http://pythonhosted.org/Flask-Cache/
# CACHE_TYPE = 'simple'

#: i18n settings
# BABEL_DEFAULT_LOCALE = 'zh'
# BABEL_SUPPORTED_LOCALES = ['zh']

########NEW FILE########
__FILENAME__ = manager
#!/usr/bin/env python
# coding: utf-8

import os
from flask_script import Manager, Server
from june.app import create_app


settings = os.path.abspath('./etc/settings.py')
if not os.path.exists(settings):
    settings = os.path.abspath('./etc/dev_config.py')

if 'JUNE_SETTINGS' not in os.environ and os.path.exists(settings):
    os.environ['JUNE_SETTINGS'] = settings

manager = Manager(create_app)
manager.add_option('-c', '--config', dest='config', required=False)
manager.add_command('runserver', Server())


@manager.command
def createdb():
    """Create database for june."""
    from june.models import db
    db.create_all()


@manager.command
def live(port=5000):
    from livereload import Server
    server = Server(manager.create_app())
    server.watch('assets/*.js', 'make -C assets build')
    server.watch('assets/page/*.js', 'make -C assets build')
    server.watch('assets/stylus', 'make -C assets stylus')
    server.serve(port)


if __name__ == '__main__':
    manager.run()

########NEW FILE########
__FILENAME__ = suite
# coding: utf-8

import os
import tempfile
from june.app import create_app
from june.models import db, Account


class BaseSuite(object):
    def setUp(self):
        config = {'TESTING': True, 'WTF_CSRF_ENABLED': False}
        config['SECRET_KEY'] = 'secret-key-for-test'

        self.db_fd, self.db_file = tempfile.mkstemp()
        config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///%s' % self.db_file

        app = create_app(config)
        self.app = app

        self.client = app.test_client()

        db.create_all()

        if hasattr(self, 'prehook'):
            self.prehook()

    def prepare_account(self):
        with self.app.test_request_context():
            foo = Account(username='foo', email='foo@email.com', password='1')
            foo.role = 'staff'

            bar = Account(username='bar', email='bar@email.com', password='1')
            bar.role = 'user'

            baz = Account(username='baz', email='baz@email.com', password='1')
            db.session.add(foo)
            db.session.add(bar)
            db.session.add(baz)
            db.session.commit()

    def prepare_login(self, username='foo'):
        self.prepare_account()
        self.client.post('/account/signin', data={
            'account': username,
            'password': '1'
        }, follow_redirects=True)

    def tearDown(self):
        db.session.remove()
        db.drop_all()

        os.close(self.db_fd)
        os.unlink(self.db_file)

        if hasattr(self, 'posthook'):
            self.posthook()

########NEW FILE########
__FILENAME__ = test_account
# coding: utf-8

from .suite import BaseSuite


class TestSignup(BaseSuite):
    def test_get(self):
        rv = self.client.get('/account/signup')
        assert '</form>' in rv.data

    def test_required_fields(self):
        rv = self.client.post('/account/signup')
        assert 'This field is required' in rv.data

    def test_invalid_email(self):
        rv = self.client.post('/account/signup', data={
            'username': 'lepture',
            'email': 'lepture',
            'password': '1'
        })
        assert 'Invalid email address' in rv.data

    def test_reserved_username(self):
        rv = self.client.post('/account/signup', data={
            'username': 'root',
            'email': 'me@lepture.com',
            'password': '1'
        })
        assert 'reserved' in rv.data

    def test_success(self):
        rv = self.client.post('/account/signup', data={
            'username': 'lepture',
            'email': 'me@lepture.com',
            'password': '1'
        })
        assert rv.status_code == 302


class TestSignin(BaseSuite):
    def test_get(self):
        rv = self.client.get('/account/signin')
        assert '</form>' in rv.data

    def test_invalid_password(self):
        self.prepare_account()
        rv = self.client.post('/account/signin', data={
            'account': 'foo',
            'password': '2'
        })
        assert b'error' in rv.data

    def test_invalid_account(self):
        rv = self.client.post('/account/signin', data={
            'account': 'foo',
            'password': '1'
        })
        assert b'error' in rv.data

    def test_success(self):
        self.prepare_account()
        rv = self.client.post('/account/signin', data={
            'account': 'foo',
            'password': '1'
        })
        assert rv.status_code == 302


class TestFind(BaseSuite):
    def test_get(self):
        rv = self.client.get('/account/find')
        assert '</form>' in rv.data

    def test_post(self):
        self.prepare_account()
        rv = self.client.post('/account/find', data={
            'account': 'foo',
        })
        assert '</table>' in rv.data

########NEW FILE########
__FILENAME__ = test_front
# coding: utf-8

from .suite import BaseSuite


class TestFront(BaseSuite):
    def test_get(self):
        rv = self.client.get('/')
        assert rv.status_code == 200

########NEW FILE########
__FILENAME__ = test_markdown
from june.filters import markdown


def test_none():
    assert markdown(None) == ''


def test_block_code():
    s = '\n'.join([
        'hello world',
        '',
        '```py',
        'def hello()',
        '    pass',
        '```',
        ''
    ])
    assert 'py' in markdown(s, False)
    assert 'highlight' in markdown(s)


def test_gist():
    gist = 'https://gist.github.com/lepture/5167275'
    assert '</script>' in markdown(gist)

########NEW FILE########
__FILENAME__ = test_node
# coding: utf-8

from .suite import BaseSuite
from june.models import Node


class TestNode(BaseSuite):
    def test_get(self):
        rv = self.client.get('/node/create')
        assert '/account/signin' in rv.location

    def test_create(self):
        self.prepare_login()
        rv = self.client.get('/node/create')
        assert '</form>' in rv.data

        rv = self.client.post('/node/create', data={
            'title': 'june',
            'urlname': 'june'
        })
        assert '/node/june' in rv.location

        # re create
        rv = self.client.post('/node/create', data={
            'title': 'june',
            'urlname': 'june'
        })
        assert 'node exists' in rv.data

    def test_edit(self):
        self.prepare_login()
        with self.app.test_request_context():
            node = Node(title='june', urlname='june')
            node.save()

        rv = self.client.get('/node/june/edit')
        assert '</form>' in rv.data

        # re edit
        rv = self.client.post('/node/june/edit', data={
            'title': 'june',
            'urlname': 'june'
        })
        assert '/node/june' in rv.location

        rv = self.client.post('/node/june/edit', data={
            'title': 'june',
            'urlname': 'foo'
        })
        assert '/node/foo' in rv.location

    def test_nodes(self):
        rv = self.client.get('/node/')
        assert '<title>Nodes' in rv.data

    def test_view(self):
        rv = self.client.get('/node/june')
        assert rv.status_code == 404

        with self.app.test_request_context():
            node = Node(title='june', urlname='june')
            node.save()
            assert repr(node) == '<Node: june>'

        rv = self.client.get('/node/june')
        assert rv.status_code == 200

        rv = self.client.get('/node/june?page=s')
        assert rv.status_code == 404

        self.prepare_login()
        with self.app.test_request_context():
            node.description = 'june'
            node.save()
        rv = self.client.get('/node/june')
        assert rv.status_code == 200

########NEW FILE########
__FILENAME__ = test_topic
# coding: utf-8

from .suite import BaseSuite
from june.models import Node, Topic, db


class TestTopic(BaseSuite):
    def prepare_topic(self):
        node = Node(title='june', urlname='june')
        db.session.add(node)
        topic = Topic(title='june', content='june',
                      account_id=1, node_id=1)
        db.session.add(topic)
        db.session.commit()
        return topic

    def test_create_and_view(self):
        rv = self.client.get('/topic/1')
        assert rv.status_code == 404

        with self.app.test_request_context():
            node = Node(title='june', urlname='june')
            node.save()

        rv = self.client.get('/topic/create/june')
        assert '/account/signin' in rv.location
        self.prepare_login()
        rv = self.client.get('/topic/create/june')
        assert '</form>' in rv.data

        rv = self.client.post('/topic/create/june', data={
            'title': 'june',
            'content': 'june'
        })
        assert '/topic/1' in rv.location

        rv = self.client.get('/topic/1')
        assert b'june</h1>' in rv.data

        rv = self.client.get('/topic/1?page=s')
        assert rv.status_code == 404

        rv = self.client.post('/topic/1')
        assert b'hits' in rv.data

    def test_fail_create_and_edit(self):
        with self.app.test_request_context():
            topic = self.prepare_topic()
            self.prepare_login('bar')
            rv = self.client.get('/topic/%d/edit' % topic.id)
            assert rv.status_code == 403

            rv = self.client.get('/topic/create/june', follow_redirects=True)
            assert b'New users' in rv.data

    def test_edit_topic(self):
        with self.app.test_request_context():
            topic = self.prepare_topic()
            rv = self.client.get('/topic/%d/edit' % topic.id)
            assert '/account/signin' in rv.location

            self.prepare_login()
            rv = self.client.get('/topic/%d/edit' % topic.id)
            assert '</form>' in rv.data

            rv = self.client.post('/topic/%d/edit' % topic.id, data={
                'title': 'flask',
                'content': 'june'
            }, follow_redirects=True)
            assert b'flask</h1>' in rv.data

    def test_reply(self):
        with self.app.test_request_context():
            topic = self.prepare_topic()
            self.prepare_login()
            rv = self.client.post('/topic/%d/reply' % topic.id, data={
            }, follow_redirects=True)
            assert 'Missing content' in rv.data

            rv = self.client.post('/topic/%d/reply' % topic.id, data={
                'content': 'foobar'
            }, follow_redirects=True)
            assert 'foobar' in rv.data
            rv = self.client.delete('/topic/%d/reply?reply=1' % topic.id)
            assert 'success' in rv.data

    def test_topics(self):
        rv = self.client.get('/topic/')
        assert '<title>Topics' in rv.data

        rv = self.client.get('/topic/?page=s')
        assert rv.status_code == 404

    def test_latest(self):
        rv = self.client.get('/topic/latest')
        assert '<title>Topics' in rv.data

        rv = self.client.get('/topic/latest?page=s')
        assert rv.status_code == 404

    def test_desert(self):
        rv = self.client.get('/topic/desert')
        assert '<title>Topics' in rv.data

        rv = self.client.get('/topic/desert?page=s')
        assert rv.status_code == 404

########NEW FILE########
__FILENAME__ = test_user
# coding: utf-8

from .suite import BaseSuite


class TestUser(BaseSuite):
    def test_users(self):
        rv = self.client.get('/user/')
        assert '<title>Users' in rv.data

        rv = self.client.get('/user/?page=s')
        assert rv.status_code == 404

    def test_city(self):
        rv = self.client.get('/user/in/hangzhou')
        assert '<title>hangzhou' in rv.data

        rv = self.client.get('/user/in/hangzhou?page=s')
        assert rv.status_code == 404

    def test_view(self):
        self.prepare_account()
        rv = self.client.get('/user/foo')
        assert '<title>foo' in rv.data

        rv = self.client.get('/user/foo/topics')
        assert rv.status_code == 200
        rv = self.client.get('/user/foo/topics?page=s')
        assert rv.status_code == 404

########NEW FILE########
__FILENAME__ = wsgi
from june.app import create_app

application = create_app()

########NEW FILE########
